<html><head></head><body><div class="part" title="Part&#xA0;IV.&#xA0;Lisp is Science"><div class="titlepage"><div><div><h1 class="title"><a id="lisp_is_science"/>Part IV. Lisp is Science</h1></div></div></div><div class="partintro" title="Lisp is Science" id="id2873150"><div/><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e23468"/><img src="httpatomoreillycomsourcenostarchimages781390.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="chapter" title="Chapter&#xA0;14.&#xA0;Ramping Lisp Up a Notch with Functional Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ramping_lisp_up_a_notch_with_functional"/>Chapter 14. Ramping Lisp Up a Notch with Functional Programming</h1></div></div></div><p>As you’ve seen in the preceding chapters, Lisp makes it pretty easy to throw together some quick code and build some simple games in no time. However, Lisp’s main claim to fame is as an academic tool, appropriate for tackling the most complicated scientific problems. The fact that it’s also great for hacking is arguably just a side benefit.</p><p>In the rest of this book, we’re going to focus on the scientific side of the language, exploring some advanced techniques to build a more sophisticated game that I hope will really blow your mind. It will do things you may never have thought would be possible in a computer program.</p><p>In this chapter, you’re going to learn about the first advanced Lisp concept, called the <span class="emphasis"><em>functional programming technique</em></span>. In the next chapter, we’ll use this technique to build a simple dice wars game, as well as a crude artificially intelligent opponent to play against!<a id="IDX-CHP-14-0001" class="indexterm"/><a id="IDX-CHP-14-0002" class="indexterm"/><a id="IDX-CHP-14-0003" class="indexterm"/></p><div class="sect1" title="What Is Functional Programming?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_functional_programming_question"/>What Is Functional Programming?</h1></div></div></div><p>We’ve already discussed the concept of functional programming a bit in earlier chapters. The glib answer is that functional programming is “a style of programming where we write all of our code using functions.”</p><p>However, we mean something very specific when using the term <span class="emphasis"><em>function</em></span> in this context—exactly the same thing that mathematicians mean when they use the word <span class="emphasis"><em>function</em></span>. So, what do mathematicians mean when they use this word?</p><p>You probably already know the answer. Try to remember way, way back when you took pre-algebra. If you didn’t fall asleep during that particular lesson, you might remember your teacher drawing something like this on the chalkboard:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23512"/><img src="httpatomoreillycomsourcenostarchimages782772.png.jpg" alt="image with no caption"/></div></div><p>This picture shows that a function has arguments that may go into it, called the <span class="emphasis"><em>domain</em></span> of the function. The function then takes these arguments and returns a value. This value is said to fall within the <span class="emphasis"><em>range</em></span> of the function.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some advanced Lispers will cringe when someone says that a function “returns a value.” This is because Lisp derives from a something called the <span class="emphasis"><em>lambda calculus</em></span>, which is a fundamental programming-like algebra developed back in the 1930s by Alonzo Church. In the lambda calculus, you “run” a program by performing substitution rules on the starting program to determine the result of a function. Hence, the result of a set of functions just sort of magically appears by performing substitutions; never does a function consciously “decide” to return a value.<a id="IDX-CHP-14-0004" class="indexterm"/><a id="IDX-CHP-14-0005" class="indexterm"/><a id="IDX-CHP-14-0006" class="indexterm"/><a id="IDX-CHP-14-0007" class="indexterm"/><a id="IDX-CHP-14-0008" class="indexterm"/></p><p>Because of this, Lisp purists prefer to say that a function “evaluates to a result.” However, almost everyone else in the programming world likes to say that functions return a value. It’s up to you to decide which way of thinking about functions feels the most natural.</p></div><p>Here are some important properties of mathematical functions that we’ll want our Lisp functions to obey as well:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The function always returns the same result, as long as the same arguments are passed into it. (This is often referred to as <span class="emphasis"><em>referential transparency</em></span>.)<a id="IDX-CHP-14-0009" class="indexterm"/></p></li><li class="listitem"><p>The function never references variables that are defined outside the function, unless we are certain that these variables will remain constant.</p></li><li class="listitem"><p>No variables are modified (or <span class="emphasis"><em>mutated</em></span>, as functional programmers like to say) by the function.</p></li><li class="listitem"><p>The purpose of the function is to do nothing other than to return a result.</p></li><li class="listitem"><p>The function doesn’t do anything that is visible to the outside world, such as pop up a dialog box on the screen or make your computer go “Bing!”</p></li><li class="listitem"><p>The function doesn’t take information from an outside source, such as the keyboard or the hard drive.</p></li></ul></div><p>If we obey these rules whenever possible, we can say that our code is written in the <span class="emphasis"><em>functional style</em></span>.</p><p>A great example of a true mathematical function is the sine function. Similarly, the <code class="literal">sin</code> function in Lisp (which calculates the mathematical sine) is a great example of a Lisp function that obeys the rules of the functional style:</p><a id="I_programlisting1_d1e23591"/><pre class="programlisting">&gt; <strong class="userinput"><code>(sin 0.5)</code></strong>
0.47942555</pre><p>The <code class="literal">sin</code> function always returns the same result, as long as you always pass the same argument (in this case, <code class="literal">0.5</code>) into it. It doesn’t do anything to interact with the outside world. Its entire purpose in life is to return the sine as a value. It obeys all the rules in the preceding list.</p><p>Clearly, it would be impossible to write <span class="emphasis"><em>all</em></span> the code in a computer program in the functional style. For instance, one of the rules stipulates that the computer isn’t allowed to go “Bing!”—who would want to use a computer if it didn’t go “Bing!” once in a while?</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23610"/><img src="httpatomoreillycomsourcenostarchimages781022.png.jpg" alt="image with no caption"/></div></div><p>Whenever a piece of code does something that is visible to the outside world, such as go “Bing!” or display a dialog box on the screen, we say that the code <span class="emphasis"><em>causes a side effect</em></span>. Functional programmers think of such side effects as making your code “dirty.”<a id="IDX-CHP-14-0010" class="indexterm"/></p><p>The technical term for such dirty code that contains side effects is <span class="emphasis"><em>imperative code</em></span>. The term <span class="emphasis"><em>imperative</em></span> implies that the code is written in a “cookbook” style, where you basically say things like “first do this, and then do that.” Like a cookbook, most lines in imperative code perform side effects, such as writing to the screen or modifying a global variable. Imperative code is the opposite of functional code.<a id="IDX-CHP-14-0011" class="indexterm"/><a id="IDX-CHP-14-0012" class="indexterm"/></p><p>This leads us to the central philosophy of functional programming. It states that you should break your program into two parts:<a id="IDX-CHP-14-0013" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first, and biggest part, should be completely functional and free of side effects. This is the clean part of your program.</p></li><li class="listitem"><p>The second, smaller part of your program is the part that has all the side effects, interacting with the user and the rest of the outside world. This code is dirty and should be kept as small as possible.</p></li></ul></div><p>If a piece of code pops up a dialog box, for example, we deem it dirty and banish it to the imperative section of our code. Things like dialog boxes are not really math, and we shouldn’t let them play with our math functions and other clean, functional code.<a id="IDX-CHP-14-0014" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23661"/><img src="httpatomoreillycomsourcenostarchimages781918.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="Anatomy of a Program Written in the Functional Style"><div class="titlepage"><div><div><h1 class="title"><a id="anatomy_of_a_program_written_in_the_func"/>Anatomy of a Program Written in the Functional Style</h1></div></div></div><p>Now that we’ve discussed how functional programming is done, let’s write a simple program that follows this style. Since we want this program to be a typical example of most software, we should figure out what most software in the world actually does. So what do most programs in the world actually do? They keep track of widgets!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23672"/><img src="httpatomoreillycomsourcenostarchimages781308.png.jpg" alt="image with no caption"/></div></div><p>Here’s our entire example program, written in the functional style:<a id="IDX-CHP-14-0015" class="indexterm"/><a id="IDX-CHP-14-0016" class="indexterm"/><a id="IDX-CHP-14-0017" class="indexterm"/></p><a id="I_programlisting1_d1e23688"/><pre class="programlisting">;the clean, functional part
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun add-widget (database widget)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (cons widget database))

  ;the dirty, nonfunctional part
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defparameter *database* nil)

<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> (defun main-loop ()
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>   (loop (princ "Please enter the name of a new widget:")
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>         (setf *database* (add-widget *database* (read)))
          (format t "The database contains the following: ˜a˜%" *database*)))</pre><p>As promised, it is split into two parts: the <span class="emphasis"><em>clean part</em></span> and the <span class="emphasis"><em>dirty part</em></span>. I did say that the clean part of the program should be much bigger than the dirty part. However, since this example is so short, the dirty part ended up a bit bigger. Usually, you can expect the clean part to be around 80 percent of the actual code.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some programming languages are even more focused on functional programming than Lisp is. Haskell, for instance, has powerful features that let you write 99.9 percent of your code in a functional style. In the end, however, your program will still need to have some kind of side effect; otherwise, your code couldn’t accomplish anything useful.<a id="IDX-CHP-14-0018" class="indexterm"/></p></div><p>So what does our example program do? Well, it basically does what most computer programs in the world are designed to do: It keeps track of widgets in a database!</p><p>The database in this example is very primitive. It’s just a Lisp list, stored in the global variable <code class="literal">*database*</code>. Since the database is going to start off empty, we initialize this variable and set it to be empty <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23748"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>We can call the function <code class="literal">main-loop</code> to start tracking some widgets <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23759"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. This function just starts an infinite loop, asking the user for a widget name <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23765"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Then, after it reads in the widget, it calls the <code class="literal">add-widget</code> function to add the new widget to the database <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23774"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>However, the <code class="literal">add-widget</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23785"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> is in the clean part of the code. That means it’s functional and isn’t allowed to modify the <code class="literal">*database*</code> variable directly. Like all functional code, the <code class="literal">add-widget</code> function is allowed to do nothing more than return a new value. This means that the only way it can “add” a widget to a database is to return a brand-new database! It does this by simply taking the database passed to it and then consing the widget to the database to create a new database <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23797"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. The new database is identical to the previous one, except that it now contains a new widget at the front of the list.</p><p>Think of how crazy this sounds on the face of it. Imagine that we’re running an Oracle database server, containing millions of widgets:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23807"/><img src="httpatomoreillycomsourcenostarchimages782052.png.jpg" alt="image with no caption"/></div></div><p>Then, when we add a new widget, the database server accomplishes this by creating a brand-new replica of the previous database, which differs only in that a single new item has been added:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e23815"/><img src="httpatomoreillycomsourcenostarchimages781440.png" alt="image with no caption"/></div></div><p>This would be horribly inefficient. However, in our widgets example, things are not as bad as they may first appear. It is true that the <code class="literal">add-widgets</code> function creates a new list of widgets every time it is called, and that repeated calls to this function would make the list longer and longer. However, since every new widget is simply added to the front of the list, it turns out that the tail end of the widget list is identical to the previous version of the list. Hence, the <code class="literal">add-widget</code> function can “cheat” whenever it creates a new list, by simply consing a single new widget to the front of the list, and then repurposing the old list as a tail to hold the rest of the items <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23828"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This allows the new list to be created in a way that is fast and also requires very little new memory to be allocated. In fact, the only new memory allocated by <code class="literal">add-widget</code> is a single new cons cell to link the new widget to the previous list.</p><p>This type of cheating when creating new data structures is a key technique that makes efficient functional programming possible. Furthermore, sharing of structures can be done safely, since one of the tenets of functional programming is to never modify old pieces of data.</p><p>So our <code class="literal">add-widget</code> function creates a new database for us with the additional item added to it. The <code class="literal">main-loop</code> function, in the dirty part of the code, sets the global <code class="literal">*database*</code> variable equal to this new database. In this way, we have indirectly modified the database in two steps:<a id="IDX-CHP-14-0019" class="indexterm"/><a id="IDX-CHP-14-0020" class="indexterm"/><a id="IDX-CHP-14-0021" class="indexterm"/><a id="IDX-CHP-14-0022" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The <code class="literal">add-widget</code> function, which is basically the brains of this program, generated an updated database for us.</p></li><li class="listitem"><p>The <code class="literal">main-loop</code> function, which was in charge of the dirty work, modified the global <code class="literal">*database*</code> variable to complete the operation.</p></li></ol></div><p>This example program illustrates the basic layout of a Lisp program written in the functional style. Let’s try out our new program to see it in action:</p><a id="I_programlisting1_d1e23882"/><pre class="programlisting">&gt; <strong class="userinput"><code>(main-loop)</code></strong>
Please enter the name of a new widget: <strong class="userinput"><code>Frombulator</code></strong>
The database contains the following: (FROMBULATOR)
Please enter the name of a new widget: <strong class="userinput"><code>Double-Zingomat</code></strong>
The database contains the following: (DOUBLE-ZINGOMAT FROMBULATOR)
...</pre><p>Remember that you can hit ctrl-C to exit the infinite loop in this example.</p></div>
<div class="sect1" title="Higher-Order Programming"><div class="titlepage"><div><div><h1 class="title"><a id="higher-order_programming"/>Higher-Order Programming</h1></div></div></div><p>One common stumbling block for programmers learning to write programs in the functional style is that they find it hard to combine different chunks of code to perform a single action. This is called <span class="emphasis"><em>code composition</em></span>. A programming language should make code composition easy. In other words, it should make it easy for you to take different pieces of code and use them together to solve a task. The most powerful tool for code composition when writing functional code is <span class="emphasis"><em>higher-order programming</em></span>, which lets you use functions that accept other functions as parameters.<a id="IDX-CHP-14-0023" class="indexterm"/><a id="IDX-CHP-14-0024" class="indexterm"/><a id="IDX-CHP-14-0025" class="indexterm"/></p><p>Let’s look at an example to understand why code composition can be a challenge to a beginning functional programmer. Suppose we want to add two to every number in the following list:</p><a id="I_programlisting1_d1e23919"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *my-list* '(4 7 2 3))</code></strong>
*MY-LIST*</pre><p>To do this, we will need to write code to traverse the list, as well as write code to add two to a number. These are the two tasks we need to compose.</p><div class="sect2" title="Code Composition with Imperative Code"><div class="titlepage"><div><div><h2 class="title"><a id="code_composition_with_imperative_code"/>Code Composition with Imperative Code</h2></div></div></div><p>One possible naïve (and imperative) way to perform this task is to use a <code class="literal">loop</code>:</p><a id="I_programlisting1_d1e23934"/><pre class="programlisting">;For demonstration purposes only. A Lisper would not write code like this.
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(loop for n below (length *my-list*)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>         <strong class="userinput"><code>do (setf (nth n *my-list*) (+ (nth n *my-list*) 2)))</code></strong>
  NIL
  &gt; <strong class="userinput"><code>*my-list*</code></strong>
  (6 9 4 5)</pre><p>Here, we’re creating a variable <code class="literal">n</code> that counts through all the items in the list in a <code class="literal">loop</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23965"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. We then use <code class="literal">setf</code> to add two to the number at the location <code class="literal">n</code> in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23978"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This is similar to the sort of code you might write if you were a C programmer. Although it’s pretty ugly, there are positive things that can be said about it:<a id="IDX-CHP-14-0026" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Code structured like this is potentially very efficient. It’s space-efficient, since we don’t need to allocate any memory for storing a new list (we’re just munging the old list to increase all the numbers in it by two). And it could also be very time-efficient, if we rewrote this loop to work on an array instead of a list. (Remember that finding the <span class="emphasis"><em>n</em></span>th item in a list is slow.)</p></li><li class="listitem"><p>Code written like this clearly composes the task of looping <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e23997"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and the task of adding two to a number <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e24003"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. By putting our code for the addition inside the loop, we are composing these two activities to complete a more complicated goal: adding two to an entire list of numbers.</p></li></ul></div><p>However, there are obvious downsides to the imperative approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It destroys the original list. This is a problem if we use the <code class="literal">*my-list*</code> variable later, and miss the fact that this code has messed up the original values in this list. A Lisper would say that allowing the <code class="literal">*my-list*</code> variable to be modified willy-nilly makes this variable a piece of <span class="emphasis"><em>hidden state</em></span> in the program. Bugs related to hidden state are common in programming languages that encourage imperative-style programming.<a id="IDX-CHP-14-0027" class="indexterm"/></p></li><li class="listitem"><p>We needed to create a variable <code class="literal">n</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e24033"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> to keep track of our position in the list. This makes the code more bulky and also adds more places where bugs could lurk. There’s always a risk that we give <code class="literal">n</code> a wrong value or use it incorrectly to access items from the list.</p></li></ul></div></div><div class="sect2" title="Using the Functional Style"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_functional_style"/>Using the Functional Style</h2></div></div></div><p>Now let’s see what happens if we rewrite this code in a functional style. Let’s first write it as a beginning functional programmer might, without using higher-order programming:<a id="IDX-CHP-14-0028" class="indexterm"/></p><a id="I_programlisting1_d1e24052"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(defun add-two (list)</code></strong>
      <strong class="userinput"><code>(when list</code></strong>
        <strong class="userinput"><code>(cons (+ 2 (car list)) (add-two (cdr list)))))</code></strong>
  ADD-TWO
  &gt; <strong class="userinput"><code>(add-two '(4 7 2 3))</code></strong>
  (6 9 4 5)</pre><p>Here, we’re creating a function <code class="literal">add-two</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e24076"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which adds two to the number at the front of the list and then calls itself recursively to build the tail of the list.</p><p>This code avoids many of the downsides from the imperative solution. It does not destroy the original list, and it does not require us to use a numeric index. Unfortunately, it also lacks one of the critical benefits of the imperative version: There is no longer a clear delineation between the code that adds two to items in the list and the code that traverses the list. These two activities are now deeply intertwined, which is the reason we needed to create a special function, <code class="literal">add-two</code>, to make this solution work. We have lost our ability to compose these two tasks in a clean way.<a id="IDX-CHP-14-0029" class="indexterm"/><a id="IDX-CHP-14-0030" class="indexterm"/></p></div><div class="sect2" title="Higher-Order Programming to the Rescue"><div class="titlepage"><div><div><h2 class="title"><a id="higher-order_programming_to_the_rescue"/>Higher-Order Programming to the Rescue</h2></div></div></div><p>If we want to write code for this task in a functional style, but still allow our code to be composable, we’ll need to make use of higher-order functions. Here is how an experienced Lisper would add two to every number in a list:</p><a id="I_programlisting1_d1e24100"/><pre class="programlisting">&gt; <strong class="userinput"><code>(mapcar (lambda (x)</code></strong>
             <strong class="userinput"><code>(+ x 2))</code></strong>
           <strong class="userinput"><code>'(4 7 2 3))</code></strong>
(6 9 4 5)</pre><p>Now we finally have a version of the code that is functional <span class="emphasis"><em>and</em></span> allows us to compose the traversal code and the addition code. Here, the traversal is performed by the <code class="literal">mapcar</code> function, which is a higher-order function since it applies a supplied function to every member in a list. The addition is performed by a lambda function, which is responsible only for adding two to a number, and is oblivious to the fact that the numbers are in a list. This example shows that higher-order programming can let us write clearly delineated chunks of code and then compose them, without needing to break from the functional style.</p></div></div>
<div class="sect1" title="Why Functional Programming Is Crazy"><div class="titlepage"><div><div><h1 class="title"><a id="why_functional_programming_is_crazy"/>Why Functional Programming Is Crazy</h1></div></div></div><p>We already know one reason why functional programming is crazy: Functional programs can’t really do anything, since they can’t have <span class="emphasis"><em>side effects</em></span>. As Simon Peyton Jones, a well-known functional programmer, likes to say, “All you can do without side effects is push a button and watch the box get hot for a while.” (Which isn’t technically true, since even the box getting hot is a side effect.)<a id="IDX-CHP-14-0031" class="indexterm"/></p><p>We’ve seen that we can work around this limitation of functional programming by adding a dirty section to our programs, which is kept separate from the rest of the code and contains all our code that is imperative and not in the functional style. However, recall the problem with the functional style: It can cause code to be extremely inefficient.<a id="IDX-CHP-14-0032" class="indexterm"/></p><p>Performance has always been a huge concern with functional programs. Having to write code that isn’t allowed to mutate the value of existing variables, but only create new variables, can lead to a huge amount of memory copying and memory allocation, which can slow programs down to a crawl. One way to mitigate this copying and allocation is by using shared structures between different pieces of data in our programs.</p><p>Nonetheless, code written in the functional style has other properties that affect performance. For instance, functional code uses a lot of recursion, instead of looping. Using recursion causes the Lisp compiler/interpreter to put a lot of items on the program stack, which can be very slow.<a id="IDX-CHP-14-0033" class="indexterm"/></p><p>Fortunately, functional programmers have developed optimization techniques that can solve the vast majority of performance problems. These include memoization, tail call optimization, lazy evaluation, and higher-order programming, which we’ll cover in the next few chapters. Using these techniques and others, an experienced functional programmer can write code that is usually comparable in performance to code written in any other style.</p><p>However, some types of programs just can’t be written in a purely functional way. For instance, you probably wouldn’t write something like a full-on Oracle-style relational database system in a functional style. Yet, smaller, memory-resident database systems may be able to use purely functional techniques (an example is the HAppS-IxSet available to Haskell programmers at <a class="ulink" href="http://happs.org/">http://happs.org/</a>). So there is really no hard limit as to when functional programming can be used.</p></div>
<div class="sect1" title="Why Functional Programming Is Fantastic"><div class="titlepage"><div><div><h1 class="title"><a id="why_functional_programming_is_fantastic"/>Why Functional Programming Is Fantastic</h1></div></div></div><p>Now that I’ve told you about all the headaches a functional programmer must endure, you may be wondering, “Why would anyone bother to program this way?” The answer is that functional programming has many enticing benefits that make up for these headaches.<a id="IDX-CHP-14-0034" class="indexterm"/></p><div class="sect2" title="Functional Programming Reduces Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="functional_programming_reduces_bugs"/>Functional Programming Reduces Bugs</h2></div></div></div><p>Bugs in computer programs usually happen because, under certain circumstances, the code behaves in ways the programmer didn’t expect when the code was written. In functional programming, the behavior of your functions depends on one and only one thing: the arguments explicitly passed into the function. This makes it much easier for a programmer to appreciate all the circumstances a program could possibly encounter, including circumstances that could lead to errors.<a id="IDX-CHP-14-0035" class="indexterm"/></p><p>Writing functions that depend on only their arguments for their behavior also makes bugs easy to duplicate. If you call a function with the same data passed in through its arguments, it should do the same exact thing every time. This is the property we called <span class="emphasis"><em>referential transparency</em></span>.<a id="IDX-CHP-14-0036" class="indexterm"/></p></div><div class="sect2" title="Functional Programs Are More Compact"><div class="titlepage"><div><div><h2 class="title"><a id="functional_programs_are_more_compact"/>Functional Programs Are More Compact</h2></div></div></div><p>It turns out a lot of the work in run-of-the-mill computer programs involves creating, initializing, and updating variables. Functional programs don’t do any of this. As we discussed earlier, functional programs make use of higher-order functions, which don’t require us to create tons of temporary variables in our code, and that makes our code more compact.</p></div><div class="sect2" title="Functional Code Is More Elegant"><div class="titlepage"><div><div><h2 class="title"><a id="functional_code_is_more_elegant"/>Functional Code Is More Elegant</h2></div></div></div><p>The biggest advantage of functional programming is that it brings all of computer programming back to the domain of mathematics. It wouldn’t make sense for a math equation to pop up a dialog box or write to the hard drive. It can be argued that if we get our computer code back to this same level of purity, it will be far more elegant. Additionally, if our code is closer to the world of mathematics, we may be able to use tools in mathematics to write better computer code.</p><p>In fact, a lot of research continues to be done in using mathematical proofs to check for the correctness of functional computer programs. Although this research still isn’t to the point where a practical programmer would use such techniques, they may be more common in the future. And, almost certainly, a functional programming style will be essential in making correctness proofs on your code possible.</p></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id14"/>What You've Learned</h1></div></div></div><p>In this chapter, we discussed functional programming. Along the way, you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Programs written in the <span class="emphasis"><em>functional style</em></span> always give the same result when they are given the same values in their arguments.</p></li><li class="listitem"><p>Functional programs do not contain <span class="emphasis"><em>side effects</em></span>. Their whole purpose in life is to just calculate a value to return.</p></li><li class="listitem"><p>Programs that are not functional usually read like a cookbook, with statements like, “First do this, and then do that.” This style of programming is called <span class="emphasis"><em>imperative programming</em></span>.</p></li><li class="listitem"><p>A good strategy for writing Lisp programs is to break them into a clean, functional part and a dirty, imperative part.</p></li><li class="listitem"><p>Functional programs can be written quickly, are more compact, and tend to have fewer bugs, particularly in the hands of an experienced functional programmer.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;15.&#xA0;Dice of Doom, a Game Written in the Functional Style"><div class="titlepage"><div><div><h1 class="title"><a id="dice_of_doom_comma_a_game_written_in_the"/>Chapter 15. Dice of Doom, a Game Written in the Functional Style</h1></div></div></div><p>Now we’re finally ready to create a more sophisticated (and fun) computer program in the functional style. As we expand this program throughout the rest of this book, you’ll learn about techniques for writing elegant functional code, while at the same time maintaining strong performance in your programs.<a id="IDX-CHP-15-0001" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24231"/><img src="httpatomoreillycomsourcenostarchimages782714.png.jpg" alt="image with no caption"/></div></div><div class="sect1" title="The Rules of Dice of Doom"><div class="titlepage"><div><div><h1 class="title"><a id="the_rules_of_dice_of_doom"/>The Rules of Dice of Doom</h1></div></div></div><p>Dice of Doom is a game in the same family as Risk, Dice Wars (<a class="ulink" href="http://www.gamedesign.jp/flash/dice/dice.html">http://www.gamedesign.jp/flash/dice/dice.html</a>), and KDice (<a class="ulink" href="http://kdice.com/">http://kdice.com/</a>). In the beginning, we’re going to keep the rules of Dice of Doom mind-numbingly simple. In later chapters, we’ll expand the rules, until eventually we’ll have a game very similar to Dice Wars.<a id="IDX-CHP-15-0002" class="indexterm"/><a id="IDX-CHP-15-0003" class="indexterm"/></p><p>Here are the simplified rules we’ll start with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Two players (named A and B) occupy spaces on a hexagonal grid. Each hexagon in the grid will have some six-sided dice on it, owned by the occupant.</p></li><li class="listitem"><p>During a turn, a player can perform any number of moves, but must perform at least one move. If the player cannot move, the game ends.</p></li><li class="listitem"><p>A move consists of attacking a neighboring hexagon owned by the opponent. The player must have more dice in her hexagon than the neighboring hexagon in order to attack. For now, all attacks will automatically lead to a win. In future variants, we’ll actually roll the dice for a battle. But for now, the player with more dice just wins automatically.</p></li><li class="listitem"><p>After winning a battle, the losing player’s dice are removed from the board, and all but one of the winning player’s dice are moved onto the newly won hexagon.</p></li><li class="listitem"><p>After a player is finished making her moves, reinforcements are added to that player’s dice armies. Reinforcements to the player’s occupied hexagons are added one die at a time, starting from the upper-left corner, moving across and down. The maximum number of dice added as reinforcements is one less than the player took from the opponent in her completed turn.</p></li><li class="listitem"><p>When a player can no longer take her turn, the game has ended. The player who occupies the most hexagons at this point is the winner. (A tie is also possible.)</p></li></ul></div></div></div>
<div class="sect1" title="A Sample Game of Dice of Doom"><div class="titlepage"><div><div><h1 class="title"><a id="a_sample_game_of_dice_of_doom"/>A Sample Game of Dice of Doom</h1></div></div></div><p>Since our implementation of Dice of Doom will include an AI player, we’re going to start with an extremely humble size for our game board. As you probably know, AI code can be very computationally intensive. In our early, very naive version of this game, any board larger than a 2-by-2 grid of hexagons would bring CLISP to its knees!</p><p>Here is a complete game, played on a puny 2-by-2 board:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24284"/><img src="httpatomoreillycomsourcenostarchimages783538.png.jpg" alt="image with no caption"/></div></div><p>At the beginning of the game, player A (indicated with black hexagons) possesses the top two hexagons, with three dice on each. Player B occupies the bottom row (indicated by the white hexagons), with three dice and one die, respectively. Player A attacks the lone die with one of his piles. After the attack, one of player A’s dice remains behind, while the others move to the conquered spot. Then player A passes the turn.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24292"/><img src="httpatomoreillycomsourcenostarchimages782970.png.jpg" alt="image with no caption"/></div></div><p>Player B now attacks player A’s two dice with a pile of three. Player B then passes. At this point, player B receives a single reinforcement die on her left hexagon. This is because she killed two of player A’s dice. The reinforcements, as per the rules, consist of the number of dice killed, minus one.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24300"/><img src="httpatomoreillycomsourcenostarchimages782752.png.jpg" alt="image with no caption"/></div></div><p>Player A now attacks with three of his dice and passes. Also, he gets a reinforcement die.<a id="IDX-CHP-15-0004" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24313"/><img src="httpatomoreillycomsourcenostarchimages782186.png.jpg" alt="image with no caption"/></div></div><p>Player B now has only one legal move, attacking two against one.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24322"/><img src="httpatomoreillycomsourcenostarchimages781602.png.jpg" alt="image with no caption"/></div></div><p>Player A now has the upper hand, killing all of player B’s remaining dice. As you can see, player A is permitted to perform multiple attacks on his turn before passing. The game has ended with player A as the winner.</p></div>
<div class="sect1" title="Implementing Dice of Doom, Version 1"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_dice_of_doom_comma_version"/>Implementing Dice of Doom, Version 1</h1></div></div></div><p>Let’s start coding this game in Lisp. As we discussed in the previous chapter, this game will contain both clean, functional code and dirty, imperative code. You’ll be able to tell in which category a block of code fits by the “clean/functional” or “dirty/imperative” icon next to it.</p><div class="sect2" title="Defining Some Global Variables"><div class="titlepage"><div><div><h2 class="title"><a id="defining_some_global_variables"/>Defining Some Global Variables</h2></div></div></div><p>First, we’ll create some global variables that define the basic parameters for our game:<a id="IDX-CHP-15-0005" class="indexterm"/></p><a id="I_programlisting2_d1e24346"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defparameter *num-players* 2)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defparameter *max-dice* 3)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defparameter *board-size* 2)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> (defparameter *board-hexnum* (* *board-size* *board-size*))</pre><p>We’re stating that there will be two players <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24373"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, that the maximum number of dice on a square is three <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24379"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and that the board will be 2-by-2 <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24385"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. In later versions of Dice of Doom, we’ll increase all of these parameters, to allow for a more challenging game.<a id="IDX-CHP-15-0006" class="indexterm"/></p><p>Since it’s useful to know the total number or hexagons there are at the current board size, we also define <code class="literal">*board-hexnum*</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24401"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Note that even though the grid is made of hexagons, it is still basically a square grid, since the number of hexagons just equals the square of the side of the grid.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In this chapter, every code sample has an associated icon to indicate whether it is made of dirty, imperative or clean, functional code. By the end of this chapter, you should be able to easily tell the difference and have some appreciation for the benefits of each style.</p></div></div><div class="sect2" title="Representing the Game Board"><div class="titlepage"><div><div><h2 class="title"><a id="representing_the_game_board"/>Representing the Game Board</h2></div></div></div><p>We’re going to represent the game board using a simple list. The hexagons will be stored in this list, starting at the top left, and then moving across and down. For each hexagon, we’ll store a list of two items: a number indicating the current occupant of the hexagon and another number indicating the number of dice at that location.<a id="IDX-CHP-15-0007" class="indexterm"/></p><p>For instance, here is an example of a game board and the list that encodes it:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24423"/><img src="httpatomoreillycomsourcenostarchimages779855.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24428"/><pre class="programlisting">((0 3) (0 3) (1 3) (1 1))</pre><p>Note that most Lisp programmers like to count starting at zero. Therefore, players A and B are represented with the numbers 0 and 1. This list indicates that player A has three dice on the first hexagon and three on the second. Player B has three dice on the third hexagon and one on the fourth.</p><p>When we create our AI player, it will need to be able to look at many hexagons on the board very quickly. Because of this, we’re going to create a second representation of our board in the form of an array. Remember that checking a numeric location (for instance, hexagon 2) in a list requires the <code class="literal">nth</code> function, which is potentially slow. Arrays, on the other hand, will allow for very fast lookup at a specific location, even with very large board sizes.</p><p>The <code class="literal">board-array</code> function converts a board represented with a list to an array for us:<a id="IDX-CHP-15-0008" class="indexterm"/><a id="IDX-CHP-15-0009" class="indexterm"/><a id="IDX-CHP-15-0010" class="indexterm"/><a id="IDX-CHP-15-0011" class="indexterm"/><a id="IDX-CHP-15-0012" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24460"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24465"/><pre class="programlisting">(defun board-array (lst)
  (make-array *board-hexnum* :initial-contents lst))</pre><p>When the game begins, we’ll start with a randomized board. Here’s the function that creates a random board:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24471"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24476"/><pre class="programlisting">(defun gen-board ()
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (board-array (loop for n below *board-hexnum*
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                      collect (list (random *num-players*)
                                       (1+ (random *max-dice*))))))</pre><p>This function is not in the functional style (as the icon indicates), since it will create a different, random result every time it is called. It generates the board as a list, but then converts the list to our speedier array format when it’s done, using <code class="literal">board-array</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24495"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>It generates random values using the Lisp function <code class="literal">random</code>. This function produces a different random integer every time, greater than or equal to zero, but smaller than the number passed to it. We use our <code class="literal">*num-players*</code> and <code class="literal">*max-dice*</code> global variables to generate random values for each hexagon <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24512"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>Let’s try out the <code class="literal">gen-board</code> function:</p><a id="I_programlisting2_d1e24523"/><pre class="programlisting">&gt; <strong class="userinput"><code>(gen-board)</code></strong>
#((0 3) (1 2) (1 3) (0 1))</pre><p>Remember that the hash mark (#) indicates that we’ve created an array, not a list.</p><p>We’ll name our players using letters (just A and B, until we start introducing more players). Here’s a function that converts a player number into a letter:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24533"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24538"/><pre class="programlisting">(defun player-letter (n)
  (code-char (+ 97 n)))</pre><p>The <code class="literal">code-char</code> function converts an ASCII code into the appropriate character. Let’s call it for player 1 to see the result:</p><a id="I_programlisting2_d1e24546"/><pre class="programlisting">&gt; <strong class="userinput"><code>(player-letter 1)</code></strong>
#\b</pre><p>Finally, let’s create a function that will take an encoded board and draw it in a pretty way on the screen. It will tilt the board in the same way as our drawings, so it’s obvious which six hexagons neighbor any given hexagon.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24554"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24559"/><pre class="programlisting">(defun draw-board (board)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (loop for y below *board-size*
          do (progn (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                   (loop repeat (- *board-size* y)
                          do (princ "  "))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                   (loop for x below *board-size*
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                         for hex = (aref board (+ x (* *board-size* y)))
                          do (format t "˜a-˜a " (player-letter (first hex))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                                               (second hex))))))</pre><p>Since the whole purpose of this <code class="literal">draw-board</code> function is to write stuff to the console, it’s definitely not functional. Let’s look at this function more closely.<a id="IDX-CHP-15-0013" class="indexterm"/><a id="IDX-CHP-15-0014" class="indexterm"/></p><p>The outer <code class="literal">loop</code> runs through all the rows of the board, stored in the variable <code class="literal">y</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24612"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. There are two inner <code class="literal">loop</code>s. The first inner <code class="literal">loop</code> adds the indentation to the left side to give the board that tilted look <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24625"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. The second inner <code class="literal">loop</code> loops through the columns, stored in the variable <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24637"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. It then uses <code class="literal">x</code> and <code class="literal">y</code> to calculate the appropriate hex number, and retrieves that hex from the board array using <code class="literal">aref</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24653"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Finally, it prints the data in the hex <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24659"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>Here’s the output of the <code class="literal">draw-board</code> function, as well as a drawing to compare it with:</p><a id="I_programlisting2_d1e24670"/><pre class="programlisting">&gt; <strong class="userinput"><code>(draw-board #((0 3) (0 3) (1 3) (1 1)))</code></strong>
    a-3 a-3
  b-3 b-1</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24676"/><img src="httpatomoreillycomsourcenostarchimages781087.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Decoupling Dice of Doom's Rules from the Rest of the Game"><div class="titlepage"><div><div><h2 class="title"><a id="decoupling_dice_of_doom_apostrophy_s_rul"/>Decoupling Dice of Doom's Rules from the Rest of the Game</h2></div></div></div><p>Now we’re ready to write the code that takes care of the guts of our first Dice of Doom implementation. In writing this code, we’re going to employ a powerful functional programming technique: a <span class="emphasis"><em>function pipeline</em></span>. This means that our game is going to consist of a succession of functions that operate, one after another, on a big chunk of data, which will hold a representation of our game board, making modifications to the structure along the way. A function pipeline will allow us to build a game rule engine that’s <span class="emphasis"><em>100% decoupled from the rest of the game code</em></span>. To understand why this is so cool, let’s first consider some of what’s involved in writing a board game with a smart AI player.<a id="IDX-CHP-15-0015" class="indexterm"/></p><p>For one thing, any computer implementation of a board game will need code that handles the human player’s moves. This part of the code will need to know the rules of the board game and make sure the human player’s move is legal before letting it happen.<a id="IDX-CHP-15-0016" class="indexterm"/></p><p>We’ll also need to write the AI code. And in order for the AI player to pick a move, it needs to know all the rules of the board game.</p><p>Notice something? Both of these separate parts of our game engine need to understand the rules of the game! Clearly, what we want to do is break our game code into three big pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The handling of the human’s moves</p></li><li class="listitem"><p>The AI player</p></li><li class="listitem"><p>The rule engine<a id="IDX-CHP-15-0017" class="indexterm"/></p></li></ul></div><p>One piece handles the player’s moves. Another is the code for the AI player. Both of these then talk to some code that understand the rules, sort of a “rule engine.” Is this kind of design possible?</p><p>In a traditional, imperative programming style, it would be very difficult to write a program like this. Most imperative game engines duplicate the code that “understands the rules,” because of the complexity of writing fully decoupled components in an imperative language. The reason for this is that a board game requires a lot of context—every move is dependent on what moves preceded it. This means that every time the AI module or player-handling module needs to check the rules, it must tell the “rule code” the current context in detail. Both would need to tell the rule code that “It’s player so-and-so’s turn and the game board looks like such-and-such.” Without this information, the rule code can’t tell whether or not a move is legal.<a id="IDX-CHP-15-0018" class="indexterm"/></p><p>Passing around this context requires tons of tedious bookkeeping code everywhere, is error-prone, and is inefficient. It’s inefficient because, with a naive design, the player-handling code may check the legality of moves the AI code had already explored and found legal.</p><p>Using functional programming, however, we can decouple these three concerns entirely in our program. We will be able to do this without bookkeeping code and in a way that avoids duplication any legality calculations. We will accomplish this by encoding our rule code in a lazy game tree!<a id="IDX-CHP-15-0019" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The basic approach we’re using—programming a game in the functional style using a lazy game tree and a function pipeline—is described in the classic paper “Why Functional Programming Matters” by John Hughes (<a class="ulink" href="http://www.scribd.com/doc/26902/whyfp/">http://www.scribd.com/doc/26902/whyfp/</a>).</p></div><p>In this chapter, we’ll be creating a game tree that is not yet lazy. You’ll need to wait until <a class="xref" href="ch20.html" title="Chapter 18. Lazy Programming">Chapter 18</a> to understand lazy programming and what a lazy game tree will look like. That’s also when you’ll be able to fully appreciate how cool this architectural design really is.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24742"/><img src="httpatomoreillycomsourcenostarchimages781119.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Generating a Game Tree"><div class="titlepage"><div><div><h2 class="title"><a id="generating_a_game_tree"/>Generating a Game Tree</h2></div></div></div><p>The entire rule set for our game is encoded in the following master function:<a id="IDX-CHP-15-0020" class="indexterm"/><a id="IDX-CHP-15-0021" class="indexterm"/><a id="IDX-CHP-15-0022" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24766"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24771"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun game-tree (board player spare-dice first-move)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (list player
          board
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>         (add-passing-move board
                            player
                            spare-dice
                            first-move
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                           (attacking-moves board player spare-dice))))</pre><p>The <code class="literal">game-tree</code> function builds a tree of all possible moves, given a certain starting configuration. This function will be called only a single time at the beginning of the game. It will then recursively build a tree of all possible moves for the game, down to the final winning positions. The other parts of our game will then elegantly traverse this tree in order to conform to the rules of the game.</p><p>In order to calculate the legal possible moves of the game tree from a given context, the function needs four pieces of data passed to it as arguments <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24803"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What the board looks like</p></li><li class="listitem"><p>The current player</p></li><li class="listitem"><p>How many dice have been captured by the player in the player’s current turn, which is needed to calculate any future reinforcements, as per our rules<a id="IDX-CHP-15-0023" class="indexterm"/><a id="IDX-CHP-15-0024" class="indexterm"/></p></li><li class="listitem"><p>Whether the current move is the first move for the current player, because a player can’t pass a turn without first making at least one move</p></li></ul></div><p>As the <code class="literal">game-tree</code> function creates the tree, it will put information about the current board and current player at every branch <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24835"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. The subbranches will then hold all the legal follow-up moves from the current branch:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24842"/><img src="httpatomoreillycomsourcenostarchimages783184.png" alt="image with no caption"/></div></div><p>There are two types of legal moves possible for players: attack a hexagon or pass their turn to the next player (assuming they’ve already attacked at least once already). The passing move is added to the list of legal moves through the <code class="literal">add-passing-move</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24852"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. The attacking moves are added to the list through the <code class="literal">attacking-moves</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24861"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Let’s look at these functions next.</p></div><div class="sect2" title="Calculating Passing Moves"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_passing_moves"/>Calculating Passing Moves</h2></div></div></div><p>Here is the function that adds the passing moves to the game tree:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24873"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e24878"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun add-passing-move (board player spare-dice first-move moves)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (if first-move
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       moves
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>       (cons (list nil
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                   (game-tree (add-new-dice board player (1- spare-dice))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                              (mod (1+ player) *num-players*)
                                     0
                                     t))
            moves)))</pre><p>The job of this function is to add a passing move to the tally of moves, if passing is permitted. The current list of moves is passed in to this function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24917"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, and then the function will return the expanded list of moves. If the move is the first move in a player’s turn <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24923"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, no passing is allowed, and we just return the unaltered list <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24929"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Otherwise, we add a new move to the list.<a id="IDX-CHP-15-0025" class="indexterm"/><a id="IDX-CHP-15-0026" class="indexterm"/></p><p>Every move in our game tree consists of two parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first part is a description of the move. Since we’re just passing in this move, we’ll set the description to <code class="literal">nil</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24952"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p></li><li class="listitem"><p>The second part of the move is an entirely new game tree, which holds the entire universe of moves that exists after this move has been performed. We create this by recursively calling <code class="literal">game-tree</code> again <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24964"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Since this is the end of the player’s turn, the player may receive dice as reinforcements. So, we update the board sent to this new <code class="literal">game-tree</code> call with the <code class="literal">add-new-dice</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24976"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p></li></ul></div><p>Of course, we also will need to change the current player, since a new person’s turn is now starting. We do this by adding one to the current player number and taking the modulus of the result, with the total number of players as the denominator <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e24984"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Changing a player in this fancy way will allow the code to work, even when we increase the number of players in the game in future versions.</p></div><div class="sect2" title="Calculating Attacking Moves"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_attacking_moves"/>Calculating Attacking Moves</h2></div></div></div><p>Here is the function that adds the possible attacking moves to the game tree:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24996"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25001"/><pre class="programlisting">(defun attacking-moves (board cur-player spare-dice)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((player (pos)
               (car (aref board pos)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>            (dice (pos)
               (cadr (aref board pos))))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     (mapcan (lambda (src)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>               (when (eq (player src) cur-player)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                 (mapcan (lambda (dst)
                            (when (and (not (eq (player dst) cur-player))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                                 (&gt; (dice src) (dice dst)))
                            (list
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>      (list (list src dst)
<img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/>            (game-tree (board-attack board cur-player src dst (dice src))
                        cur-player
                        (+ spare-dice (dice dst))
                        nil)))))
<img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/>                        (neighbors src))))
              (loop for n below *board-hexnum*
                    collect n))))</pre><p>The <code class="literal">attacking-moves</code> function is a bit more complicated than the <code class="literal">add-passing-move</code> function. It’s responsible for scanning the current game board and figuring out what moves the current player is legally allowed to perform.</p><p>Since it must spend a lot of time figuring out who the player is on a given hexagon, we first write a convenience function called <code class="literal">player</code> that returns the player for a given board position <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25071"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. We write a similar function to get the number of dice on a given hexagon <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25077"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.<a id="IDX-CHP-15-0027" class="indexterm"/><a id="IDX-CHP-15-0028" class="indexterm"/><a id="IDX-CHP-15-0029" class="indexterm"/><a id="IDX-CHP-15-0030" class="indexterm"/><a id="IDX-CHP-15-0031" class="indexterm"/></p><p>Next, we need to scan the board top to bottom and find out which squares the current player occupies. For each occupied square, there may be one or more legal attacks starting at that position. Since the number of attacks from any hexagon may vary, we use <code class="literal">mapcan</code> to scan the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25106"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Remember that <code class="literal">mapcan</code> lets each hexagon we scan return its results as a list. Then <code class="literal">mapcan</code> concatenates these lists together. This way, any scanned hexagon can contribute zero to <span class="emphasis"><em>n</em></span> moves to the list.</p><p>Within the <code class="literal">lambda</code> function used by the <code class="literal">mapcan</code>, which gets called for every hexagon, we first want to check whether the current player occupies this hexagon <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25129"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Then we want to check all of its neighbors to see if any of them present a viable attack. We do this with another <code class="literal">mapcan</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25138"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. We’ll figure out the neighbors to this hexagon by using the <code class="literal">neighbors</code> function, which we’ll write shortly <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25148"/><img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/></span>.</p><p>How do we decide if a hexagon can be an attack destination? Well, it must be a hexagon we don’t already own, plus (as per the rules) the source hexagon needs to have more dice than the destination hexagon <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25156"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. If we have found a legal attack move, we then describe the move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25162"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. The description is simply a list of the source position and the destination position. We then (as with passing moves) recursively generate another game tree that describes what happens if the move is executed <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25168"/><img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/></span>.</p></div><div class="sect2" title="Finding the Neighbors"><div class="titlepage"><div><div><h2 class="title"><a id="finding_the_neighbors"/>Finding the Neighbors</h2></div></div></div><p>Next, let’s create the function that calculates the neighboring hexagons to a given hexagon:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25180"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25185"/><pre class="programlisting">(defun neighbors (pos)
    (let ((up (- pos *board-size*))
          (down (+ pos *board-size*)))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>     (loop for p in (append (list up down)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                            (unless (zerop (mod pos *board-size*))
                               (list (1- up) (1- pos)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                            (unless (zerop (mod (1+ pos) *board-size*))
                               (list (1+ pos) (1+ down))))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                 when (and (&gt;= p 0) (&lt; p *board-hexnum*))
                  collect p)))</pre><p>Every hexagon on the board may have up to six neighbors, or fewer, if the hexagon is on an edge of the board. We build up a list of possible neighbors in a <code class="literal">loop</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25216"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, and then collect the ones with position numbers that aren’t off the edge of the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25222"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Also, since our position numbers wrap from row to row, we need to make sure we don’t look to the left if we’re on the left edge of the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25228"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> or look to the right if we’re on the right edge of the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25234"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>This function is marked clean (it is in the functional style), but nonetheless contains a loop. Usually, looping goes against the tenets of functional programming. However, many Lispers consider it kosher to use a <code class="literal">loop</code> in functional code if all it does is collect some values, since it really isn’t mutating any values or producing any other side effects. So, we will allow ourselves to use such loops in the functional-style part of this game.<a id="IDX-CHP-15-0032" class="indexterm"/><a id="IDX-CHP-15-0033" class="indexterm"/><a id="IDX-CHP-15-0034" class="indexterm"/><a id="IDX-CHP-15-0035" class="indexterm"/></p><p>Let’s try out our <code class="literal">neighbors</code> function:</p><a id="I_programlisting2_d1e25268"/><pre class="programlisting">&gt; <strong class="userinput"><code>(neighbors 2)</code></strong>
(0 3)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25274"/><img src="httpatomoreillycomsourcenostarchimages781241.png" alt="image with no caption"/></div></div><p>As you can see, it correctly tells us that hexagon 2 neighbors hexagons 0 and 3.<a id="IDX-CHP-15-0036" class="indexterm"/></p></div><div class="sect2" title="Attacking"><div class="titlepage"><div><div><h2 class="title"><a id="attacking"/>Attacking</h2></div></div></div><p>Now let’s write our <code class="literal">board-attack</code> function:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25293"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25298"/><pre class="programlisting">(defun board-attack (board player src dst dice)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (board-array (loop for pos
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                      for hex across board
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                      collect (cond ((eq pos src) (list player 1))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                                    ((eq pos dst) (list player (1- dice)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                                    (t hex)))))</pre><p>This is a function that figures out what happens if the hexagon <code class="literal">src</code> attacks the hexagon <code class="literal">dst</code>. It works by <code class="literal">loop</code>ing across the board, keeping track of the current position <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25341"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and the contents in the hexagon at that position <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25347"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. If the current hexagon is the source hexagon, we just place a single die in that place; as per our rules, a single die is left behind after an attack <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25354"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If the current hexagon is the destination position, we place the remaining dice there, subtracting the one left behind <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25360"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. In other cases, we just collect the very same hex <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25366"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>Let’s try out our <code class="literal">board-attack</code> function:</p><a id="I_programlisting2_d1e25377"/><pre class="programlisting">&gt; <strong class="userinput"><code>(board-attack #((0 3) (0 3) (1 3) (1 1)) 0 1 3 3)</code></strong>
#((0 3) (0 1) (1 3) (0 2))</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25383"/><img src="httpatomoreillycomsourcenostarchimages782736.png" alt="image with no caption"/></div></div><p>As you can see, attacking from hexagon 1 to 3 causes <code class="literal">board-attack</code> to properly update the game board, so that one die remains on the old square and two are on the new, conquered square.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Many of the functions in this chapter have inefficiencies to keep things simple. We’ll fix many of these in future versions of the game.</p></div></div><div class="sect2" title="Reinforcements"><div class="titlepage"><div><div><h2 class="title"><a id="reinforcements"/>Reinforcements</h2></div></div></div><p>To add the reinforcements to the board, we need to scan across the game board, find occupied spots that can accommodate another die, and add the die there. Of course, the number of reinforcements is limited based on how many opponent dice the player captured in the last turn. Because of this, we’ll need to keep a running tally of how many reinforcement dice remain.<a id="IDX-CHP-15-0037" class="indexterm"/></p><p>The most obvious way to track the remaining dice would be to have a <code class="literal">remaining-dice</code> variable, and decrement this every time a die is placed. However, having a die that is decremented (mutated) would not be in line with the functional style.</p><p>Therefore, instead, we’re going to write our <code class="literal">add-new-dice</code> function using a local recursive function, which will also maintain this running count of dice.</p><p>Here is this <code class="literal">add-new-dice</code> function:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25422"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25427"/><pre class="programlisting">(defun add-new-dice (board player spare-dice)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((f (lst n)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>              (cond ((null lst) nil)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                    ((zerop n) lst)
                 (t (let ((cur-player (caar lst))
                          (cur-dice (cadar lst)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                     (if (and (eq cur-player player) (&lt; cur-dice *max-dice*))
                          (cons (list cur-player (1+ cur-dice))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                               (f (cdr lst) (1- n)))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                         (cons (car lst) (f (cdr lst) n))))))))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>     (board-array (f (coerce board 'list) spare-dice))))</pre><p>The first thing <code class="literal">add-new-dice</code> does is define a local function named <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25480"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This function will be our list-eater that goes through the hexagons of the board and spits out a new list that includes the reinforcements. Since our board is actually stored in an array for efficiency reasons, we convert our array into a list with the <code class="literal">coerce</code> function before calling <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25493"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>.</p><p>Inside the function <code class="literal">f</code>, we must consider three situations:<a id="IDX-CHP-15-0038" class="indexterm"/><a id="IDX-CHP-15-0039" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>That we’re at the end of the board. In this case, the reinforced board will also be completed, so we just return <code class="literal">nil</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25519"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p></li><li class="listitem"><p>That we’re out of <code class="literal">spare-dice</code> to add to add as reinforcements. In this case, the rest of the board will just be the same as before, so we can just return the remainder of the list as the new board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25531"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p></li><li class="listitem"><p>Neither of the preceding situations. In all other cases, we need to analyze the current hexagon and decide whether a reinforcement should be added in it. We check whether the current player occupies that hexagon and whether we have less than the maximum number of dice on that square <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25540"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. If this is the case, we add a new die on the hexagon and call <code class="literal">f</code> against the rest of the board, recursively <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25549"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Otherwise, we leave the current hexagon unchanged and proceed by recursively calling <code class="literal">f</code> against the rest of the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25558"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p></li></ul></div><p>Let try adding reinforcements to a board:</p><a id="I_programlisting2_d1e25567"/><pre class="programlisting">&gt; <strong class="userinput"><code>(add-new-dice #((0 1) (1 3) (0 2) (1 1)) 0 2)</code></strong>
#((0 2) (1 3) (0 3) (1 1))</pre><p>As you can see, <code class="literal">add-new-dice</code> properly placed two reinforcement dice for player A (player 0).</p></div><div class="sect2" title="Trying Out Our New game-tree Function"><div class="titlepage"><div><div><h2 class="title"><a id="trying_out_our_new_game-tree_function"/>Trying Out Our New game-tree Function</h2></div></div></div><p>We have now written all the code needed to create a comprehensive game tree of our simplified version of Dice of Doom. But be careful! A game tree of most board games is excruciatingly large. Even on a 2-by-2 board, our game may consist of hundreds of possible moves. You’ll want to call the <code class="literal">game-tree</code> function only on a game board that is near the end of play, or you’ll be watching helplessly as the CLISP REPL prints out a humongous tree showing all the possible ways in which a game may progress.</p><p>Here is a safe board position for you to try out:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25589"/><img src="httpatomoreillycomsourcenostarchimages783122.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25594"/><pre class="programlisting">&gt; <strong class="userinput"><code>(game-tree #((0 1) (1 1) (0 2) (1 1)) 0 0 t)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (0
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>  #((0 1)(1 1) (0 2) (1 1))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>  (((2 3)(0
             #((0 1) (1 1) (0 1) (0 1))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>            ((NIL(1
                     #((0 1) (1 1) (0 1) (0 1))
                     NIL)))))))</pre><p>The game tree first lists the current player number <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25625"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, the layout of the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25631"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and then the legal moves for that context. For the initial board position, at the beginning of player A’s turn, there is only one possible move: The player can move from hexagon 2 to hexagon 3, capturing player B’s die in that spot <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25637"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. After that, the player can pass. Player B now has no move available. Since this player’s game tree has no available moves listed <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25643"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, the game has ended, with a win for player A.<a id="IDX-CHP-15-0040" class="indexterm"/><a id="IDX-CHP-15-0041" class="indexterm"/></p></div><div class="sect2" title="Playing Dice of Doom Against Another Human"><div class="titlepage"><div><div><h2 class="title"><a id="playing_dice_of_doom_against_another_hum"/>Playing Dice of Doom Against Another Human</h2></div></div></div><p>Now that we’ve completely captured the universe of Dice of Doom in our comprehensive <code class="literal">game-tree</code> function, it’s simple to create a human versus human version of this game. All we need to do is create some functions that travel down the game tree as players choose their moves.</p><div class="sect3" title="The Main Loop"><div class="titlepage"><div><div><h3 class="title"><a id="the_main_loop"/>The Main Loop</h3></div></div></div><p>Here is the function that travels down the game tree, allowing two humans to play Dice of Doom:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25675"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25680"/><pre class="programlisting">(defun play-vs-human (tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (print-info tree)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (if (caddr tree)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       (play-vs-human (handle-human tree))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>     (announce-winner (cadr tree))))</pre><p>This function, <code class="literal">play-vs-human</code>, is the main loop of our game. It accepts a tree describing the starting position of the board.<a id="IDX-CHP-15-0042" class="indexterm"/></p><p>First, it calls a function named <code class="literal">print-info</code>, which will draw the board on the screen, along with other helpful information about the current state of the game <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25723"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we need to check if any follow-up moves exist. These follow-up moves would be listed starting at the <code class="literal">caddr</code> position of the game tree <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25732"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>If follow-up moves are available, we call the function <code class="literal">handle-human</code>, which will interact with the current player to help him pick his new move. This <code class="literal">handle-human</code> function will then return the subbranch of the tree that represents the player’s choice. We can then recursively pass this subbranch into <code class="literal">play-vs-human</code> to proceed with the game <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25749"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>If no follow-up moves are available, the game has officially ended. We then call the <code class="literal">announce-winner</code> function, which, appropriately, will announce the winner <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25760"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p></div><div class="sect3" title="Giving Information About the State of the Game"><div class="titlepage"><div><div><h3 class="title"><a id="giving_information_about_the_state_of_th"/>Giving Information About the State of the Game</h3></div></div></div><p>Here is the print-info function, which describes the status of the current node in the game tree:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25772"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25777"/><pre class="programlisting">(defun print-info (tree)
  (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (format t "current player = ˜a" (player-letter (car tree)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (draw-board (cadr tree)))</pre><p>This function displays two important pieces of information on the REPL. First, it shows who the current player is <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25793"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then it prints out a pretty version of the game board with the <code class="literal">draw-board</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25802"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.<a id="IDX-CHP-15-0043" class="indexterm"/><a id="IDX-CHP-15-0044" class="indexterm"/><a id="IDX-CHP-15-0045" class="indexterm"/><a id="IDX-CHP-15-0046" class="indexterm"/></p></div><div class="sect3" title="Handling Input from Human Players"><div class="titlepage"><div><div><h3 class="title"><a id="handling_input_from_human_players"/>Handling Input from Human Players</h3></div></div></div><p>Next is the function that lets humans choose their next move. It displays a very helpful, numbered menu of all currently available moves for the player to choose from.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25834"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e25839"/><pre class="programlisting">(defun handle-human (tree)
    (fresh-line)
    (princ "choose your move:")
    (let ((moves (caddr tree)))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>     (loop for move in moves
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>           for n from 1
            do (let ((action (car move)))
                 (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                (format t "˜a. " n)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                (if action
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                    (format t "˜a -&gt; ˜a" (car action) (cadr action))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                    (princ "end turn"))))
      (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>     (cadr (nth (1- (read)) moves))))</pre><p>To display the list of available moves, we use a <code class="literal">loop</code> that traverses all the available moves and prints a description about each one <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25889"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This <code class="literal">loop</code> is not functional, since it prints stuff on the screen for the player to read. We print a counting number in front of each move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25898"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> using the variable n, which counts from 1 inside our <code class="literal">loop</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25908"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>Each move has an action value associated with it. If the action is non-nil <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25916"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, then the action is an attack, where the action value describes the source and destination hexagons of the attack. We print such attacking action using the <code class="literal">format</code> command <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25925"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>We use an empty action value to represent the passing move. In that case, we just <code class="literal">princ</code> “end turn” to describe this move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25936"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>After the available moves have been displayed, we use <code class="literal">read</code> to read in the player’s choice. With the <code class="literal">nth</code> function, we can then select that branch of the game tree and return it from our <code class="literal">handle-human</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25953"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>.</p></div><div class="sect3" title="Determining the Winner"><div class="titlepage"><div><div><h3 class="title"><a id="determining_the_winner"/>Determining the Winner</h3></div></div></div><p>The task of announcing the winner can be nicely broken into a <span class="emphasis"><em>clean/functional</em></span> and a <span class="emphasis"><em>dirty/imperative</em></span> part.</p><p>The clean part concerns the task of calculating the winning player. We want to calculate this in a way that can handle more than just two players, since our game will allow for more in the future. Also, the function must be cognizant of possible ties.</p><p>To accomplish this, we’ll write a function called <code class="literal">winners</code> that returns a list of one or more players who captured the maximum number of hexagons at the end of the game. If there is a tie, it will simply return all the players who share first place, in terms of the total count of occupied spaces for all players. With this design, the function will work for <span class="emphasis"><em>any number of players</em></span> and will elegantly handle ties. This is what the <code class="literal">winners</code> function looks like:<a id="IDX-CHP-15-0047" class="indexterm"/><a id="IDX-CHP-15-0048" class="indexterm"/><a id="IDX-CHP-15-0049" class="indexterm"/><a id="IDX-CHP-15-0050" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e25996"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26001"/><pre class="programlisting">(defun winners (board)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let* ((tally (loop for hex across board
                        collect (car hex)))
           (totals (mapcar (lambda (player)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                            (cons player (count player tally)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                          (remove-duplicates tally)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>          (best (apply #'max (mapcar #'cdr totals))))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>     (mapcar #'car
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>             (remove-if (lambda (x)
                           (not (eq (cdr x) best)))
                         totals))))</pre><p>We calculate the winner for a given ending board position in four steps.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, we build up a tally of who occupies each hexagon on the board <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26046"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. With the <code class="literal">across loop</code> construct, we can traverse the array of the ending board directly and collect the occupier of each hexagon.</p></li><li class="listitem"><p>Second, we need to count the total number of squares each player has captured, using this tally. The totals variable will be an alist of player-&gt;spaces pairs. We build this alist by finding all players who have at least one entry in the tally with <code class="literal">remove-duplicates</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26061"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. We can map across this and then create a count for each occupier <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26067"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p></li><li class="listitem"><p>Third, we want to find what the maximum number of occupied hexagons for a single player is. We do this by stripping the counts from our alist by mapping <code class="literal">cdr</code> across the list <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26079"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. We then apply <code class="literal">max</code> to this list to find the largest number of occupied spaces for a single player.</p></li><li class="listitem"><p>Finally, we need create a list of all the “best” players. We do this by stripping out all but the best from our totals using the <code class="literal">remove-if</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26094"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. We then just pull out the player numbers for the best players by mapping <code class="literal">car</code> across the list of bests <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26103"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p></li></ul></div><p>Next, let’s write the dirty <code class="literal">announce-winner</code> function:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26115"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26120"/><pre class="programlisting">(defun announce-winner (board)
    (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((w (winners board)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (if (&gt; (length w) 1)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       (format t "The game is a tie between ˜a" (mapcar #'player-letter w))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>       (format t "The winner is ˜a" (player-letter (car w))))))</pre><p>This function is rather simple. First, we calculate the winners by calling our earlier function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26149"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then we check if there is more than one winner <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26155"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> (a tie). For ties, we print a special message <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26161"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Otherwise, we just announce a single winner <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26167"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p></div><div class="sect3" title="Trying Out the Human vs. Human Version of Dice of Doom"><div class="titlepage"><div><div><h3 class="title"><a id="trying_out_the_human_vs._human_version_o"/>Trying Out the Human vs. Human Version of Dice of Doom</h3></div></div></div><p>We now have a completely playable game of dice of doom. Here is an example game from start to finish:<a id="IDX-CHP-15-0051" class="indexterm"/><a id="IDX-CHP-15-0052" class="indexterm"/></p><a id="I_programlisting2_d1e26186"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-human (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
    b-2 b-2
  a-2 b-1
choose your move:
1. 2 -&gt; 3
<strong class="userinput"><code>1</code></strong>
current player = a
    b-2 b-2
  a-1 a-1
choose your move:
1. end turn
<strong class="userinput"><code>1</code></strong>
current player = b
    b-2 b-2
  a-1 a-1
choose your move:
1. 0 -&gt; 2
2. 0 -&gt; 3
3. 1 -&gt; 3
<strong class="userinput"><code>1</code></strong>
current player = b
    b-1 b-2
  b-1 a-1
choose your move:
1. end turn
2. 1 -&gt; 3
<strong class="userinput"><code>1</code></strong>
current player = a
    b-1 b-2
  b-1 a-1
The winner is b</pre></div></div></div>
<div class="sect1" title="Creating an Intelligent Computer Opponent"><div class="titlepage"><div><div><h1 class="title"><a id="creating_an_intelligent_computer_opponen"/>Creating an Intelligent Computer Opponent</h1></div></div></div><p>As we discussed when we were designing the game tree code for Dice of Doom, having a separate game tree generator makes it easy to add an AI player to a game engine. In fact, we’re now going to add a computer player that can play an absolutely perfect game with only 23 additional lines of code!</p><p>So how does an AI player decide to make a move? We’ll use the following strategy:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Look at each available move.</p></li><li class="listitem"><p>Give a point rating to the board position resulting from each move.</p></li><li class="listitem"><p>Pick the move with the maximum point rating.</p></li></ol></div><p>This sounds like a simple plan, but there is one step in this algorithm that’s pretty tricky: calculating the best point rating for a given board position.</p><p>If a move leads immediately to a win, it’s easy to give a point rating to that move—any winning move clearly deserves a very high point rating. However, most moves in a game cannot lead to an immediate win. In those cases, in order to determine if the result of a set of moves deserves a good point rating, we need to figure out what the opponent player will do in response.</p><p>But how will we know what the opponent player will decide to do? If we’re not careful, we’ll end up in an ugly impasse where we say, “He thinks that I think that he thinks that I think . . .” in order to calculate a meaningful point value for a given board position. How do we account for the opponent’s behavior without giving ourselves a headache?</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26227"/><img src="httpatomoreillycomsourcenostarchimages781316.png.jpg" alt="image with no caption"/></div></div><div class="sect2" title="The Minimax Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="the_minimax_algorithm"/>The Minimax Algorithm</h2></div></div></div><p>It turns out that for a two-player board game, a simple method exists to model what an opponent will do. We simply accept the truism “What is good for my opponent is bad for me.” This means we can use the following approach to model a move for the opponent:<a id="IDX-CHP-15-0053" class="indexterm"/><a id="IDX-CHP-15-0054" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Look at each available move.</p></li><li class="listitem"><p>Give a point rating to the board position resulting from each move.</p></li><li class="listitem"><p>Pick the move with the minimum point rating.</p></li></ol></div><p>This algorithm for estimating what an opponent will do is identical to the one used for the primary player, except that in step 3, we pick the move with the <span class="emphasis"><em>minimum</em></span> instead of <span class="emphasis"><em>maximum</em></span> rating. The benefit of this approach, called the <span class="emphasis"><em>minimax algorithm</em></span>, is that we use the same point ratings when working out the opponent’s moves that we use for the primary AI player, but then just tweak the third step a little to adjust.<a id="IDX-CHP-15-0055" class="indexterm"/></p><p>This is crucial: It turns out that if we can avoid calculating separate ratings for ourselves as for our opponent in the game, then searching down the game tree for good moves becomes dramatically easier and faster.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The basic minimax algorithm works only in two-player games. When three or more players are involved in a game, we can’t really say that “What is good for my opponent is bad for me” is completely true any more. This is because an additional truism becomes important: “The enemy of my enemy is my friend.” This means that some of my opponents may, at times, act as a friend by making moves that harm a common enemy, while not affecting me directly. We’ll discuss this issue more in <a class="xref" href="ch22.html" title="Chapter 20. Making Dice of Doom More Fun">Chapter 20</a>.</p></div></div><div class="sect2" title="Turning Minimax into Actual Code"><div class="titlepage"><div><div><h2 class="title"><a id="turning_minimax_into_actual_code"/>Turning Minimax into Actual Code</h2></div></div></div><p>Now we’re ready to put the minimax idea into practice, like so:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26288"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26293"/><pre class="programlisting">(defun rate-position (tree player)
    (let ((moves (caddr tree)))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>     (if moves
        (apply (if (eq (car tree) player)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                #'max
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>              #'min)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>              (get-ratings tree player))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>       (let ((w (winners (cadr tree))))
          (if (member player w)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>             (/ 1 (length w))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>           0)))))</pre><p>The <code class="literal">rate-position</code> function generates a numeric point rating for a given branch of the game tree. In order to do this, we first need to figure out if there are any moves available from the given position <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26343"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> (that is, the current move is not an ending move in the game).<a id="IDX-CHP-15-0056" class="indexterm"/><a id="IDX-CHP-15-0057" class="indexterm"/><a id="IDX-CHP-15-0058" class="indexterm"/><a id="IDX-CHP-15-0059" class="indexterm"/></p><p>If moves are available, we’ll need to look at all the subsequent moves to decide how to rate the current position. We accomplish this by calling <code class="literal">get-ratings</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26370"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, a function that will return the point rating of each follow-up move. As per minimax, we will then pick either the best (<code class="literal">max</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26379"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> or worst (<code class="literal">min</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26389"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> rating of all the follow-up moves, depending on whether the move being rated is for the AI player or its opponent.</p><p>If, on the other hand, there are no follow-up moves, we’ll need to check who the winner is for the current board position <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26397"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. If the player isn’t among the winners of this position, we can give the position the minimum rating of <code class="literal">0</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26406"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. Otherwise, we’ll divide one by the number of winners to determine our rating <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26412"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. By doing this, we also give a meaningful rating for ties. If the player is the sole winner, the rating, using this formula, will be the maximum value of <code class="literal">1</code>. For a two-player tie, the rating will be a sensible <code class="literal">0.5</code>.</p><p>Here is what the <code class="literal">get-ratings</code> function looks like:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26431"/><img src="httpatomoreillycomsourcenostarchimages783226.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26436"/><pre class="programlisting">(defun get-ratings (tree player)
  (mapcar (lambda (move)
          (rate-position (cadr move) player))
        (caddr tree)))</pre><p>This function simply maps <code class="literal">rate-position</code> across each available follow-up move for the given branch of the tree.</p></div><div class="sect2" title="Creating a Game Loop with an AI Player"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_game_loop_with_an_ai_player"/>Creating a Game Loop with an AI Player</h2></div></div></div><p>Earlier, we wrote a function called <code class="literal">handle-human</code> that interacted with a human to decide on a move in the game. Here is an analogous function, <code class="literal">handle-computer</code>, that interacts with our AI player to choose a move:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26455"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26460"/><pre class="programlisting">(defun handle-computer (tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((ratings (get-ratings tree (car tree))))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (cadr (nth (position (apply #'max ratings) ratings) (caddr tree)))))</pre><p>This <code class="literal">handle-computer</code> function is quite straightforward. First, we get the ratings of each available move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26479"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then we pick the move that is rated the highest <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26485"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>Finally, let’s create a function that handles the main loop for playing against the computer. This one is analogous to our earlier <code class="literal">play-vs-human</code> function:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e26497"/><img src="httpatomoreillycomsourcenostarchimages781994.png" alt="image with no caption"/></div></div><a id="I_programlisting2_d1e26502"/><pre class="programlisting">(defun play-vs-computer (tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (print-info tree)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (cond ((null (caddr tree)) (announce-winner (cadr tree)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       ((zerop (car tree)) (play-vs-computer (handle-human tree)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>       (t (play-vs-computer (handle-computer tree)))))</pre><p>As with the <code class="literal">play-vs-human</code> function, <code class="literal">play-vs-computer</code> first prints out information about the current state of the game <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26536"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If no more moves are available, it then calls the <code class="literal">announce-winner</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26545"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.<a id="IDX-CHP-15-0060" class="indexterm"/></p><p>Next, we need to check who the current player is. By convention, we’ll have the human be player A (player 0). If the player number is 0, we call our old <code class="literal">handle-human</code> function to let the human decide on her move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26562"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Otherwise, we treat the player as an AI player and use the <code class="literal">handle-computer</code> function to decide on a move <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26571"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>We have now written a fully functional AI engine for Dice of Doom!</p></div><div class="sect2" title="Playing Our First Human vs. Computer Game"><div class="titlepage"><div><div><h2 class="title"><a id="playing_our_first_human_vs._computer_gam"/>Playing Our First Human vs. Computer Game</h2></div></div></div><p>The following is an example game playing against the computer AI. The computer plays an optimal game and wins.</p><a id="I_programlisting2_d1e26585"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-computer (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
    a-3 b-3
  a-2 b-2
choose your move:
1. 0 -&gt; 3
<strong class="userinput"><code>1</code></strong>
current player = a
    a-1 b-3
  a-2 a-2
choose your move:
1. end turn
<strong class="userinput"><code>1</code></strong>
current player = b
    a-2 b-3
  a-2 a-2
current player = b
    b-2 b-1
  a-2 a-2
current player = a
    b-3 b-1
  a-2 a-2
choose your move:
1. 3 -&gt; 1
<strong class="userinput"><code>1</code></strong>
current player = a
    b-3 a-1
  a-2 a-1
choose your move:
1. end turn
<strong class="userinput"><code>1</code></strong>
current player = b
    b-3 a-1
  a-2 a-1
current player = b
    b-1 a-1
  b-2 a-1
current player = b
    b-1 a-1
  b-1 b-1
current player = a
    b-2 a-1
  b-2 b-1
The winner is b</pre></div></div>
<div class="sect1" title="Making Dice of Doom Faster"><div class="titlepage"><div><div><h1 class="title"><a id="making_dice_of_doom_faster"/>Making Dice of Doom Faster</h1></div></div></div><p>The functional programming style can lead to slow code, at least in the hands of a novice programmer. We used the functional style to develop the core of Dice of Doom. Hence, this first version of our game is excruciatingly inefficient. We had to limit our game to a 2-by-2 board to make it playable. But now we can increase our board size to 3-by-3, as we optimize our game engine.<a id="IDX-CHP-15-0061" class="indexterm"/><a id="IDX-CHP-15-0062" class="indexterm"/><a id="IDX-CHP-15-0063" class="indexterm"/><a id="IDX-CHP-15-0064" class="indexterm"/></p><p>Let’s increase the parameters controlling the board size to make this happen. You may not want to play a game at this new size until you’ve implemented all the optimizations throughout the rest of this chapter, unless you are an extremely patient person and don’t mind having the computer take minutes building the initial game tree and deciding on moves.</p><a id="I_programlisting2_d1e26629"/><pre class="programlisting">(defparameter *board-size* 3)
(defparameter *board-hexnum* (* *board-size* *board-size*))</pre><p>There, we’ve upgraded the board size to 3 by 3.</p><p>The rest of this chapter covers some important techniques for optimizing functional code. These techniques apply to all programs written in the functional style, which includes Dice of Doom. In later chapters, we’ll add other optimizations. Eventually, we’ll be able to play against an AI player on much more spacious boards, while still having elegant code written in the functional style.<a id="IDX-CHP-15-0065" class="indexterm"/></p><div class="sect2" title="Closures"><div class="titlepage"><div><div><h2 class="title"><a id="closures"/>Closures</h2></div></div></div><p>Before we start optimizing Dice of Doom, there is an important Lisp programming concept we need to discuss: <span class="emphasis"><em>closures</em></span>. Closures are extra bits of data from the outside world that are captured whenever a lambda function is created. To understand the hows and whys of capturing variables in a closure, consider the following example:<a id="IDX-CHP-15-0066" class="indexterm"/></p><a id="I_programlisting2_d1e26649"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *foo* (lambda ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/><strong class="userinput"><code>                         5))</code></strong>
  *FOO*
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(funcall *FOO*)</code></strong>
  5</pre><p>In this example, we’re creating a new, unnamed function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26673"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, and then setting <code class="literal">*foo*</code> equal to this function. Next, we call this function using the <code class="literal">funcall</code> command <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26685"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. As you would expect, the value returned from this function is <code class="literal">5</code>. All the lambda function does is return this number.<a id="IDX-CHP-15-0067" class="indexterm"/><a id="IDX-CHP-15-0068" class="indexterm"/><a id="IDX-CHP-15-0069" class="indexterm"/><a id="IDX-CHP-15-0070" class="indexterm"/></p><p>Next, consider this more interesting example:</p><a id="I_programlisting2_d1e26711"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(defparameter *foo* (let ((x 5))</code></strong>
<strong class="userinput"><code>                        (lambda ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>                              x)))</code></strong>
  *FOO*</pre><p>This version of <code class="literal">foo</code> is exactly the same as the previous version of <code class="literal">*foo*</code>, except that we first declare a local variable <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26743"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which is set to <code class="literal">5</code>. Then, in the body of the <code class="literal">lambda</code>, we return <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26759"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. So, what do you think will happen if we call this new version of <code class="literal">*foo*</code>?</p><p>The reason this is a tough question is that <code class="literal">x</code> is declared as a “local” variable. However, <code class="literal">x</code> (apparently) no longer exists once we call <code class="literal">*foo*</code>, since we’re already long past the point where we’re evaluating the body of the <code class="literal">let</code> expression.</p><p>Let’s try it out and see what happens:</p><a id="I_programlisting2_d1e26784"/><pre class="programlisting">&gt; <strong class="userinput"><code>(funcall *foo*)</code></strong>
5</pre><p>Holy cow! Somehow the lambda expression we created remembered what <code class="literal">x</code> was at the time it was created. The variable <code class="literal">x</code>, which we previously thought of as a local variable, has somehow managed to live on past the block in which it was created!</p><p>When we first covered <code class="literal">let</code> expressions in <a class="xref" href="ch02.html" title="Chapter 2. Creating Your First Lisp Program">Chapter 2</a>, you learned that advanced Lispers prefer to call variables created with a <code class="literal">let</code> expression <span class="emphasis"><em>lexical variables</em></span>. Now you can see why: A variable created in this way does not need to be local, if it is captured in a closure, by using the variable in a lambda expression.<a id="IDX-CHP-15-0071" class="indexterm"/></p><p>To understand how closures work, remember that Lisp uses garbage collection. In fact, it was the first language to have this feature. Garbage collection means that you never have to “free” variables (as you do in C programming). The Lisp compiler/interpreter is smart enough to know when variables are no longer in use and destroys them automatically.<a id="IDX-CHP-15-0072" class="indexterm"/></p><p>Garbage collection will happen at some arbitrary future time after you’ve exited a <code class="literal">let</code> expression. Periodically, Lisp will search its memory for items that are no longer referenced anywhere and can therefore be safely destroyed. If Lisp notices that a variable defined in a <code class="literal">let</code> is no longer used by anything, it will destroy that variable.</p><p>However, if you create a lambda expression within the <code class="literal">let</code> expression (as we did in the previously), it’s possible for those variables to live on, being referenced from within the lambda expression. In that case, the garbage collector will leave those variables alone. Basically, you’ve created variables that are permanent—at least as long as the lambda expression doesn’t fall out of use and get garbage collected.</p><p>You can do a lot of cool things using closures. They’re often used for caching small pieces of information between uses of a function. For instance, here a function that remembers what line number is currently being printed:</p><a id="I_programlisting2_d1e26834"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(let ((line-number 0))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>     (defun my-print (x)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/><strong class="userinput"><code>       (print line-number)</code></strong>
  <strong class="userinput"><code>      (print x)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/><strong class="userinput"><code>       (incf line-number)</code></strong>
       <strong class="userinput"><code> nil))</code></strong>
  MY-PRINT
  &gt; <strong class="userinput"><code>(my-print "this")</code></strong>
  0
  "this"
  nil
  &gt; <strong class="userinput"><code>(my-print "is")</code></strong>
  1
  "is"
  nil
  &gt; <strong class="userinput"><code>(my-print "a")</code></strong>
  2
  "a"
  nil
  &gt; <strong class="userinput"><code>(my-print "test")</code></strong>
  3
  "test"
  nil</pre><p>In order to keep track of the line number, we first create a lexical variable named <code class="literal">line-number</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26893"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we declare our <code class="literal">my-print</code> function using <code class="literal">defun</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26905"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, in the body of the <code class="literal">let</code>. This command will create a lambda function behind the scenes, therefore letting us also generate a closure.<a id="IDX-CHP-15-0073" class="indexterm"/></p><p>Within the body of the <code class="literal">my-print</code> function, we can then print the <code class="literal">line-number</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26928"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, and even mutate it using <code class="literal">incf</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e26937"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. (<code class="literal">incf</code> just adds one to a variable.) Because the <code class="literal">line-number</code> variable is captured in the closure, it can “live on” between calls to <code class="literal">my-print</code>, allowing us to count line numbers.</p></div><div class="sect2" title="Memoization"><div class="titlepage"><div><div><h2 class="title"><a id="memoization"/>Memoization</h2></div></div></div><p>The first optimization we’re going to perform is called <span class="emphasis"><em>memoization</em></span>. This technique makes use of closures. Memoization works only for functions written in the functional style. As you know, the behavior of a function in the functional style depends only on the arguments passed into it. Also, the only action of a function in the functional style is to calculate a value to return to the caller.<a id="IDX-CHP-15-0074" class="indexterm"/><a id="IDX-CHP-15-0075" class="indexterm"/></p><p>This suggests an obvious optimization: What if we remember the arguments and result of each call of this function? Then, if the function ever gets called again with the same arguments, we won’t need to recalculate the result. Instead, we can simply return the precalculated result.<a id="IDX-CHP-15-0076" class="indexterm"/><a id="IDX-CHP-15-0077" class="indexterm"/><a id="IDX-CHP-15-0078" class="indexterm"/></p><p>Several functions in Dice of Doom can benefit from memoization.</p><div class="sect3" title="Memoizing the neighbors Function"><div class="titlepage"><div><div><h3 class="title"><a id="memoizing_the_neighbors_function"/>Memoizing the neighbors Function</h3></div></div></div><p>Let’s start with the <code class="literal">neighbors</code> function, which lets us know which hexagons on the board can be attacked from a given location:</p><a id="I_programlisting2_d1e26990"/><pre class="programlisting">&gt; <strong class="userinput"><code>(neighbors 0)</code></strong>
(3 1 4)</pre><p>What <code class="literal">neighbors</code> is telling us is that if we want to attack other hexagons on the board from hexagon 0, we can reach only hexagon 3, 1, or 4 (based on our new 3-by-3 board size).</p><p>As you may remember, the <code class="literal">neighbors</code> function needed to do all kinds of ugly checking for the edges of the board, since hexagons along the edges are limited in the hexagons they can attack. However, since the shape of the board never changes mid-game, these numbers never change for a given board position. This makes <code class="literal">neighbors</code> a perfect candidate for memoization! Here is the code that accomplishes this:</p><a id="I_programlisting2_d1e27008"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (let ((old-neighbors (symbol-function 'neighbors))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>       (previous (make-hash-table)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>   (defun neighbors (pos)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>     (or (gethash pos previous)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>         (setf (gethash pos previous) (funcall old-neighbors pos)))))</pre><p>Let’s dissect this code to make sense of what’s happening. First, we save the old version of the <code class="literal">neighbors</code> function in a local variable named <code class="literal">old-neighbors</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27047"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The <code class="literal">symbol-function</code> command simply retrieves the function bound to a symbol. Using <code class="literal">symbol-function</code> here allows us to retain access to the old value of <code class="literal">neighbors</code>, even if we define a new function with the same name, as we’ll do shortly.</p><p>Next, we define a local variable <code class="literal">previous</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27068"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, which will hold all previous arguments and results the function has ever seen. This can be represented as a hash table, where the arguments are the hash key and the results are the values.</p><p>Now we define a new <code class="literal">neighbors</code> function that will override the old definition of <code class="literal">neighbors</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27082"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. This new definition will add memoization to the old version of the function. Then we look up the argument <code class="literal">pos</code> in the hash table and return it, if available <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27091"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Otherwise, we call the old definition of the function (that’s why we needed to create the <code class="literal">old-neighbors</code> lexical variable) and add this new argument/result pair to the hash table <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27101"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Since <code class="literal">setf</code> returns the value being set, this command will also cause this newly calculated result to be returned to the caller of <code class="literal">neighbors</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Be careful not to declare the memoized version of the <code class="literal">neighbors</code> function more than once, without also redeclaring the original version of the function. Otherwise, the <code class="literal">neighbors</code> function will be wrapped in multiple unsightly layers of memoization, since there are no checks if the memoization has already been done.<a id="IDX-CHP-15-0079" class="indexterm"/><a id="IDX-CHP-15-0080" class="indexterm"/><a id="IDX-CHP-15-0081" class="indexterm"/></p></div></div><div class="sect3" title="Memoizing the Game Tree"><div class="titlepage"><div><div><h3 class="title"><a id="memoizing_the_game_tree"/>Memoizing the Game Tree</h3></div></div></div><p>The biggest payoff by far for memoization in our program will be in the <code class="literal">game-tree</code> function. This makes sense, if you think about how a board game works. Very often, you can get the same board positions in a board game by performing the same moves in a slightly different order. In our naive version of the <code class="literal">game-tree</code> function, every different move sequence leads to a completely different branch in the game tree that we need to build in a totally repetitive and inefficient way.</p><p>In the memoized version of the <code class="literal">game-tree</code> code, the function can say to itself, “Hey, I’ve seen that board position before!” and can then share branches of the game tree. Here is a memoized version of <code class="literal">game-tree</code> that does this:</p><a id="I_programlisting2_d1e27152"/><pre class="programlisting">(let ((old-game-tree (symbol-function 'game-tree))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (previous (make-hash-table :test #'equalp)))
    (defun game-tree (&amp;rest rest)
      (or (gethash rest previous)
        (setf (gethash rest previous) (apply old-game-tree rest)))))</pre><p>As you can see, this memoization is virtually identical to the one we used for the <code class="literal">neighbors</code> function. The only difference is that we’re setting the hash table to use <code class="literal">equalp</code> instead of <code class="literal">eql</code> (the default) for the test on the key <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27171"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>This is because the key (that is, the arguments to <code class="literal">game-tree</code>) contains the game board, in the form of an array. If we change the test function to be <code class="literal">equalp</code>, then Lisp will check every hexagon on the board and make sure it matches before using a previous calculation.</p></div><div class="sect3" title="Memoizing the rate-position Function"><div class="titlepage"><div><div><h3 class="title"><a id="memoizing_the_rate-position_function"/>Memoizing the rate-position Function</h3></div></div></div><p>Another function that will benefit greatly from memoization is the <code class="literal">rate-position</code> function. Here it is, memoized:</p><a id="I_programlisting2_d1e27193"/><pre class="programlisting">(let ((old-rate-position (symbol-function 'rate-position))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (previous (make-hash-table)))
    (defun rate-position (tree player)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (let ((tab (gethash player previous)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       (unless tab
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>         (setf tab (setf (gethash player previous) (make-hash-table))))
        (or (gethash tree tab)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>           (setf (gethash tree tab)
                  (funcall old-rate-position tree player))))))</pre><p>We need to do something a bit special for the memoization on this function to work correctly, because of the <code class="literal">tree</code> argument passed into rate-position. The game tree is potentially huge, so we need to make sure we never compare a game tree object with <code class="literal">equal</code> (or a similar comparison function that is slow with large lists). Instead, we want to compare it with <code class="literal">eql</code>. Because of this, we handle the memoization of each of the two parameters to <code class="literal">rate-position</code> (<code class="literal">tree</code> and <code class="literal">player</code>) separately. We accomplish this by having nested hash tables.<a id="IDX-CHP-15-0082" class="indexterm"/><a id="IDX-CHP-15-0083" class="indexterm"/><a id="IDX-CHP-15-0084" class="indexterm"/><a id="IDX-CHP-15-0085" class="indexterm"/></p><p>First, we create an outer hash table with the default <code class="literal">eql</code> test <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27263"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then, we define a <code class="literal">tab</code> variable that looks up one of our variables (<code class="literal">player</code>) in the outer hash table <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27275"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, to retrieve an inner hash table. If <code class="literal">tab</code> is not found in the outer hash table <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27285"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, we’ll create a new, empty inner hash table, storing it in the outer hash table with the same key <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27291"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. The rest of the function is similar to our previous examples, except that we’re now using our inner hash table, with the <code class="literal">tree</code> argument as a key <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27300"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>This memoization will bring us a step closer to having larger, and more fun, boards for Dice of Doom.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You use memoization for optimizing the performance of code written in the functional style. However, memoization code is not, in itself, written in the functional style. It cannot be, since it requires you to maintain and update a table of previous calls to the target function.</p></div></div></div><div class="sect2" title="Tail Call Optimization"><div class="titlepage"><div><div><h2 class="title"><a id="tail_call_optimization"/>Tail Call Optimization</h2></div></div></div><p>The next technique we’re going to use to optimize our functional program is called <span class="emphasis"><em>tail call optimization</em></span>. To understand this concept, let’s study a simple function that calculates the length of a list:<a id="IDX-CHP-15-0086" class="indexterm"/><a id="IDX-CHP-15-0087" class="indexterm"/></p><a id="I_programlisting2_d1e27327"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defun my-length (lst)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/><strong class="userinput"><code>     (if lst</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>        (1+ (my-length (cdr lst)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/><strong class="userinput"><code>        0))</code></strong>
  MY-LENGTH
  &gt; <strong class="userinput"><code>(my-length '(fie foh fum))</code></strong>
  3</pre><p>The <code class="literal">my-length</code> function should be pretty easy for you to understand at this point. First, it checks if the list is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27365"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If not, it recursively calls itself against the tail of the list and adds one to the total, using the <code class="literal">1+</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27374"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. If the list is empty, the function just returns <code class="literal">0</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27384"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>It turns out that this function is actually quite inefficient. We can easily see this by trying to use it against a really big list:</p><a id="I_programlisting2_d1e27392"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *biglist* (loop for i below 100000 collect 'x))</code></strong>
*BIGLIST*
&gt; <strong class="userinput"><code>(my-length *biglist*)</code></strong>

*** - Program stack overflow. RESET</pre><p>Calling this function in CLISP actually causes the program to crash! (Other Common Lisp compilers/interpreters may do better, depending on whether the compiler writers use any special tricks to anticipate this common pitfall in Lisp code.)<a id="IDX-CHP-15-0088" class="indexterm"/></p><p>This happens because of the <code class="literal">1+</code> function. It tells Lisp, “<span class="emphasis"><em>First</em></span>, figure out the length of the shorter list, <span class="emphasis"><em>then</em></span> call <code class="literal">1+</code> on the result.”</p><p>The problem is that each time we call <code class="literal">my-length</code> recursively, Lisp must remember that we need to add one to the result later on, once the length of the tail of the list has been figured out. Since the list is 100,000 items long, it must remember this 99,999 times before it can perform a single addition! The CLISP interpreter places a reminder for all of these additions on the program stack, which eventually overflows, crashing the program.</p><p>So how do we avoid this problem? We do it by rewriting our <code class="literal">my-length</code> function like so:</p><a id="I_programlisting2_d1e27429"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defun my-length (lst)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/><strong class="userinput"><code>     (labels ((f (lst acc)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>                 (if lst</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/><strong class="userinput"><code>                   (f (cdr lst) (1+ acc))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/><strong class="userinput"><code>                   acc)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/><strong class="userinput"><code>       (f lst 0)))</code></strong>
  MY-LENGTH
  &gt; <strong class="userinput"><code>(my-length '(fie foh fum))</code></strong>
  3</pre><p>Here, we define a local function <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27484"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> that will act as our list-eater. This function takes an extra parameter, often called an <code class="literal">accumulator</code>, here shortened to <code class="literal">acc</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27496"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This <code class="literal">acc</code> argument keeps a running count of how many items in the list we have previously encountered. When we initially call the function <code class="literal">f</code>, we set <code class="literal">acc</code> to <code class="literal">0</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27515"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.<a id="IDX-CHP-15-0089" class="indexterm"/></p><p>By making this accumulator available, it means that when <code class="literal">f</code> calls itself recursively <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27529"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, it now longer needs to add one to the result. Instead, it just adds one to the accumulator. Once we reach the end of the list (<code class="literal">lst</code> is <code class="literal">nil</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27541"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>), then <code class="literal">acc</code> will equal the total number of items in the list, so we can just return it <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27551"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>What is important here is that <span class="emphasis"><em>the very last thing</em></span> the function <code class="literal">f</code> does, in the case where more items are on the list, is call itself recursively <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27565"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. (The additional line in the <code class="literal">if</code> statement <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27574"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> doesn’t count, since that part won’t be called if the expression evaluates to true.) When a function in Lisp calls itself (or another function) as its very last action, we call this action a <span class="emphasis"><em>tail call</em></span>. A smart Lisp compiler, when seeing a tail call, can then say to itself, “Hey, since I don’t need to do anything more after calling <code class="literal">f</code> again, I can just go straight to <code class="literal">f</code>, without needing to put the current program context on the stack.”<a id="IDX-CHP-15-0090" class="indexterm"/></p><p>This is actually similar to performing a <code class="literal">GOTO</code> in BASIC or a <code class="literal">longjmp</code> in C++. In all of these cases, we just “forget” where we came from, which is very fast and doesn’t thrash the stack. However, in the case of a tail call in Lisp, it is also perfectly safe. Anyone who has used <code class="literal">GOTO</code> or <code class="literal">longjmp</code> knows they’re anything but safe!</p><p>Notice that there are two different definitions for <code class="literal">lst</code> that exist in the preceding example code. One is an argument to the <code class="literal">my-length</code> function, and the other is an argument to the function <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27618"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The values of these two lst arguments will deviate as the program runs and <code class="literal">f</code> is called recursively. However, within the function <code class="literal">f</code>, the version in its own argument list will take precedence. This process of hiding one variable with another through precedence is called <span class="emphasis"><em>variable shadowing</em></span>.<a id="IDX-CHP-15-0091" class="indexterm"/><a id="IDX-CHP-15-0092" class="indexterm"/><a id="IDX-CHP-15-0093" class="indexterm"/><a id="IDX-CHP-15-0094" class="indexterm"/><a id="IDX-CHP-15-0095" class="indexterm"/><a id="IDX-CHP-15-0096" class="indexterm"/><a id="IDX-CHP-15-0097" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>I used variable shadowing in the <code class="literal">my-length</code> function so it would be impossible for me to accidentally use the “wrong list” when writing the code inside of function <code class="literal">f</code>. Other programmers dislike this technique, since having similarly named variables with different values can lead to confusion. You’ll need to decide which of these arguments is most convincing to you and whether you’ll use variable shadowing in your own code.</p></div><div class="sect3" title="Support for Tail Calls in Common Lisp"><div class="titlepage"><div><div><h3 class="title"><a id="support_for_tail_calls_in_common_lisp"/>Support for Tail Calls in Common Lisp</h3></div></div></div><p>Unfortunately, you can’t be 100 percent sure in Common Lisp that a compiler/interpreter will perform tail call optimizations. It is not required by the ANSI Common Lisp standard. (The situation is actually different in the Scheme dialect, since Scheme has a strict requirement for tail call optimization.)</p><p>However, most Common Lisp compilers support this feature, although CLISP requires some extra cajoling to make tail call optimization work for some functions, including our example function. The reason for this is that tail calls can actually lead to performance problems themselves, in some esoteric cases. Also, when we debug a program, it’s nice to be able to look at the full call stack; tail call optimizations will prevent this, since, by their nature, they will minimize the information available on the stack.</p><p>Here’s the extra step we need to take to get CLISP to tail call optimize the <code class="literal">my-length</code> function:</p><a id="I_programlisting2_d1e27686"/><pre class="programlisting">(compile 'my-length)</pre><p>Calling this function will tell CLISP to run the <code class="literal">my-length</code> function through its full compiler, which includes a tail code optimization step. Now we can run <code class="literal">my-length</code> against our jumbo-sized list!</p><a id="I_programlisting2_d1e27696"/><pre class="programlisting">&gt; <strong class="userinput"><code>(my-length *biglist*)</code></strong>
100000</pre></div><div class="sect3" title="Tail Call Optimization in Dice of Doom"><div class="titlepage"><div><div><h3 class="title"><a id="tail_call_optimization_in_dice_of_doom"/>Tail Call Optimization in Dice of Doom</h3></div></div></div><p>One function in our game that could definitely benefit from tail call optimization is the <code class="literal">add-new-dice</code> function. Here’s the fully optimized version:</p><a id="I_programlisting2_d1e27709"/><pre class="programlisting">(defun add-new-dice (board player spare-dice)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((f (lst n acc)
               (cond ((zerop n) (append (reverse acc) lst))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                    ((null lst) (reverse acc))
                     (t (let ((cur-player (caar lst))
                              (cur-dice (cadar lst)))
                          (if (and (eq cur-player player)
                                   (&lt; cur-dice *max-dice*))
                              (f (cdr lst)
                                 (1- n)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                                (cons (list cur-player (1+ cur-dice)) acc))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                           (f (cdr lst) n (cons (car lst) acc))))))))
      (board-array (f (coerce board 'list) spare-dice ()))))</pre><p>As before, we’re performing the list-eating in a function called <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27740"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which also has an accumulator. However, this time the <code class="literal">acc</code> variable will contain a <span class="emphasis"><em>list</em></span> of newly updated hexagons with extra dice. We can now call <code class="literal">f</code> in tail call positions in two places <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27756"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27761"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, where we <code class="literal">cons</code> new hexagons to the <code class="literal">acc</code> variable.<a id="IDX-CHP-15-0098" class="indexterm"/><a id="IDX-CHP-15-0099" class="indexterm"/></p><p>Once we’ve processed the whole list of hexagons on the board, we can just return <code class="literal">acc</code>. However, since we’ve consed stuff to <code class="literal">acc</code> as we went along the list, <code class="literal">acc</code> will actually be reversed. Therefore, we need to perform an extra call to <code class="literal">reverse</code> at the very end <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e27801"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>We have now explored some basic techniques for optimizing computer programs written in the functional style.</p></div></div><div class="sect2" title="A Sample Game on the 3-by-3 Board"><div class="titlepage"><div><div><h2 class="title"><a id="a_sample_game_on_the_3-by-3_board"/>A Sample Game on the 3-by-3 Board</h2></div></div></div><p>Now let’s enjoy the fruits of our labor. The following is a full game against the AI player on a 3-by-3 board. As you can see, on an evenly matched starting board, the computer is now practically unbeatable.</p><a id="I_programlisting2_d1e27814"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-computer (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
      b-1 a-2 a-3
    a-1 b-1 b-2
  b-2 a-2 b-3
choose your move:
1. 1 -&gt; 4
2. 1 -&gt; 0
3. 2 -&gt; 5
4. 7 -&gt; 4
<strong class="userinput"><code>3</code></strong>
current player = a
      b-1 a-2 a-1
    a-1 b-1 a-2
  b-2 a-2 b-3
choose your move:
1. end turn
2. 1 -&gt; 4
3. 1 -&gt; 0
4. 5 -&gt; 4
5. 7 -&gt; 4
<strong class="userinput"><code>1</code></strong>
current player = b
      b-1 a-3 a-1
    a-1 b-1 a-2
  b-2 a-2 b-3
current player = b
      b-1 a-3 a-1
    b-1 b-1 a-2
  b-1 a-2 b-3
current player = a
      b-1 a-3 a-1
    b-1 b-1 a-2
  b-1 a-2 b-3
choose your move:
1. 1 -&gt; 4
2. 1 -&gt; 0
3. 5 -&gt; 4
4. 7 -&gt; 4
5. 7 -&gt; 3
6. 7 -&gt; 6
<strong class="userinput"><code>1</code></strong>
current player = a
      b-1 a-1 a-1
    b-1 a-2 a-2
  b-1 a-2 b-3
choose your move:
1. end turn
2. 4 -&gt; 0
3. 4 -&gt; 3
4. 7 -&gt; 3
5. 7 -&gt; 6
<strong class="userinput"><code>1</code></strong>
current player = b
      b-1 a-1 a-1
    b-1 a-2 a-2
  b-1 a-2 b-3
current player = b
      b-1 a-1 a-1
    b-1 a-2 b-2
  b-1 a-2 b-1
current player = a
      b-2 a-1 a-1
    b-1 a-2 b-2
  b-1 a-2 b-1
choose your move:
1. 4 -&gt; 3
2. 4 -&gt; 8
3. 7 -&gt; 3
4. 7 -&gt; 6
5. 7 -&gt; 8
<strong class="userinput"><code>2</code></strong>
current player = a
      b-2 a-1 a-1
    b-1 a-1 b-2
  b-1 a-2 a-1
choose your move:
1. end turn
2. 7 -&gt; 3
3. 7 -&gt; 6
<strong class="userinput"><code>1</code></strong>
current player = b
      b-2 a-1 a-1
    b-1 a-1 b-2
  b-1 a-2 a-1
current player = b
      b-1 b-1 a-1
    b-1 a-1 b-2
  b-1 a-2 a-1
current player = a
      b-1 b-1 a-1
    b-1 a-1 b-2
  b-1 a-2 a-1
choose your move:
1. 7 -&gt; 3
2. 7 -&gt; 6
<strong class="userinput"><code>1</code></strong>
current player = a
      b-1 b-1 a-1
    a-1 a-1 b-2
  b-1 a-1 a-1
choose your move:
1. end turn
<strong class="userinput"><code>1</code></strong>
current player = b
      b-1 b-1 a-1
    a-1 a-1 b-2
  b-1 a-1 a-1
current player = b
      b-1 b-1 b-1
    a-1 a-1 b-1
  b-1 a-1 a-1
current player = a
      b-1 b-1 b-1
    a-1 a-1 b-1
  b-1 a-1 a-1
The winner is b</pre></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id15"/>What You've Learned</h1></div></div></div><p>In this chapter, we used our knowledge of functional programming to develop a board game with AI. Along the way you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Functional programming techniques allow you to write a game program with a “rule engine” that is separate from the rest of the code. You accomplish this by using <span class="emphasis"><em>function pipelining</em></span> and building a <span class="emphasis"><em>game tree</em></span> that is independently traversed by other parts of your game code as the game progresses.</p></li><li class="listitem"><p>You can create an AI player for a two-player game using the <span class="emphasis"><em>minimax algorithm</em></span>. This algorithm is based on the truism “What is good for my enemy is bad for me.” It allows you to efficiently rate positions in a two-player board game.</p></li><li class="listitem"><p>Lexical variables (which we’ve been calling <span class="emphasis"><em>local</em></span> variables) can live on past the form in which they were created if they are referenced by a lambda expression. Capturing variables in this way is called <span class="emphasis"><em>creating a closure</em></span>.</p></li><li class="listitem"><p>Functional programs can be optimized using <span class="emphasis"><em>memoization</em></span>, which requires you to cache previous results calculated by a function.</p></li><li class="listitem"><p>You can also improve functional programs by using <span class="emphasis"><em>tail call optimizations</em></span>, which allow you to make sure the call stack isn’t abused. You do this by controlling which function appears in the tail call (final) position of your list-eater functions.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;16.&#xA0;The Magic of Lisp Macros"><div class="titlepage"><div><div><h1 class="title"><a id="the_magic_of_lisp_macros"/>Chapter 16. The Magic of Lisp Macros</h1></div></div></div><p><span class="emphasis"><em>Macro programming</em></span> allows you to mess around inside your Lisp compiler/interpreter to turn Lisp into your own custom programming language. When faced with a difficult programming challenge, many experienced Lispers will first ask themselves, “What programming language could I use to make this problem easy to solve?” Then they’ll use macros to convert Lisp into <span class="emphasis"><em>that</em></span> language!<a id="IDX-CHP-16-0001" class="indexterm"/></p><p>No other programming language possesses such a simple and comprehensive macro system. One can even argue that it would be impossible to add this feature to other programming languages, for a simple reason: The Lisp languages are the only ones in which computer code and program data are made out of the same “stuff.” As discussed many times in this book, the fundamental structures for storing data in Lisp are symbols, numbers, and lists, which are made of cons cells. Similarly, the code of a Lisp program is made out of these same basic building blocks. As you’ll see in this chapter, this symmetry between code and data in Lisp is the magic that makes the Lisp macro system possible.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e27902"/><img src="httpatomoreillycomsourcenostarchimages781590.png" alt="image with no caption"/></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>You may have heard that other programming languages, such as C++, also have a feature called macros. For instance, in the C++ language, you would create these using the #define directive. However, these are not the same thing! Lisp macros work in an entirely different and far more sophisticated way.<a id="IDX-CHP-16-0002" class="indexterm"/><a id="IDX-CHP-16-0003" class="indexterm"/><a id="IDX-CHP-16-0004" class="indexterm"/><a id="IDX-CHP-16-0005" class="indexterm"/></p></div><div class="sect1" title="A Simple Lisp Macro"><div class="titlepage"><div><div><h1 class="title"><a id="a_simple_lisp_macro"/>A Simple Lisp Macro</h1></div></div></div><p>Sometimes when you’re writing a computer program, you get a feeling of <span class="emphasis"><em>déjà vu</em></span>. I’m sure you know this feeling. You’re typing away at your computer, and you suddenly realize, “Hey, this is the third time this week I’ve written this same fragment of code!”</p><p>Suppose, for example, that your program needs a special <code class="literal">add</code> function:</p><a id="I_programlisting3_d1e27941"/><pre class="programlisting">(defun add (a b)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((x (+ a b)))
       (format t "The sum is ˜a" x)
       x))</pre><p>This function adds together two numbers and prints out the sum on the REPL as a side effect. You might find this function useful in a program during debugging:</p><a id="I_programlisting3_d1e27951"/><pre class="programlisting">&gt; <strong class="userinput"><code>(add 2 3)</code></strong>
The sum is 5
5</pre><p>This <code class="literal">add</code> function seems straightforward, but its code has an annoyance: Why do you need so many parentheses to declare your variable <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e27964"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>? The <code class="literal">let</code> command requires so many parentheses that when you need only a single variable, the code ends up looking especially ludicrous.</p><p>The parentheses required by <code class="literal">let</code> are an example of the kind of <span class="emphasis"><em>visual noise</em></span> a programmer must deal with almost every day. However, you can’t just write a regular function to hide those parentheses, because the <code class="literal">let</code> command can do things a regular Lisp function can’t support. The <code class="literal">let</code> command is a <span class="emphasis"><em>special form</em></span>. It’s a core part of the language and has special powers beyond those of a standard Lisp function.<a id="IDX-CHP-16-0006" class="indexterm"/></p><p>Macros let us get rid of the superfluous parentheses. Let’s create a new macro named <code class="literal">let1</code>:<a id="IDX-CHP-16-0007" class="indexterm"/><a id="IDX-CHP-16-0008" class="indexterm"/></p><a id="I_programlisting3_d1e28005"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmacro let1 (var val &amp;body body)
    `(let ((,var ,val))
       ,@body))</pre><p>As you can see, the definition of a macro looks similar to the definition of a function. However, instead of using <code class="literal">defun</code>, we use <code class="literal">defmacro</code> to define it. Like a function, it has a name (in this case, <code class="literal">let1</code>) and arguments passed to it <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28023"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>Once we’ve defined the macro <code class="literal">let1</code>, it can be used just like <code class="literal">let</code>, except that it works with fewer parentheses:</p><a id="I_programlisting3_d1e28038"/><pre class="programlisting">&gt; <strong class="userinput"><code>(let ((foo (+ 2 3)))</code></strong>
<strong class="userinput"><code>    (* foo foo))</code></strong>
25
&gt; <strong class="userinput"><code>(let1 foo (+ 2 3)</code></strong>
<strong class="userinput"><code>    (* foo foo))</code></strong>
25</pre><div class="sect2" title="Macro Expansion"><div class="titlepage"><div><div><h2 class="title"><a id="macro_expansion"/>Macro Expansion</h2></div></div></div><p>Although a macro definition looks very similar to a function definition, a macro is actually very different from a function. To understand why, imagine your Lisp is actually a cute little blob, merrily running your Lisp programs.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e28058"/><img src="httpatomoreillycomsourcenostarchimages782790.png" alt="image with no caption"/></div></div><p>This blob understands only standard Lisp code. If it were to see our <code class="literal">let1</code> command, it would have no idea what to do.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e28069"/><img src="httpatomoreillycomsourcenostarchimages782218.png" alt="image with no caption"/></div></div><p>Now imagine that we have a magic wand that transforms the appearance of our code <span class="emphasis"><em>just before</em></span> Lisp gets a peek at it. In our example, it will transform <code class="literal">let1</code> into a regular <code class="literal">let</code>, so Lisp will stay happy.<a id="IDX-CHP-16-0009" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e28089"/><img src="httpatomoreillycomsourcenostarchimages781008.png" alt="image with no caption"/></div></div><p>This magic wand is called <span class="emphasis"><em>macro expansion</em></span>. This is a special transformation that your code is put through before the core of the Lisp interpreter/compiler gets to see it. The job of the macro expander is to find any macros in your code (such as our let1 macro) and to convert them into regular Lisp code.<a id="IDX-CHP-16-0010" class="indexterm"/></p><p>This means a macro is run at <span class="emphasis"><em>a different time</em></span> than a function is run. A regular Lisp function runs when you execute a program that contains the function. This is called <span class="emphasis"><em>runtime</em></span>. A macro, on the other hand, runs before the program does, when the program is read and compiled by your Lisp environment. This is called <span class="emphasis"><em>macro expansion time</em></span>.<a id="IDX-CHP-16-0011" class="indexterm"/></p><p>Now that we’ve discussed the basic thinking behind Lisp macros, let’s take a closer look at how <code class="literal">let1</code> was defined.</p></div><div class="sect2" title="How Macros Are Transformed"><div class="titlepage"><div><div><h2 class="title"><a id="how_macros_are_transformed"/>How Macros Are Transformed</h2></div></div></div><p>When we define a new macro with the <code class="literal">defmacro</code> command, we’re basically teaching the Lisp macro expansion system a new transformation that it can use to translate code before running a program. The macro receives raw source code in its arguments, in the form of Lisp expressions. Its job is to help the macro expander transform this raw code into standard Lisp code that keeps the Lisp blob happy.</p><p>Let’s take a closer look at how our <code class="literal">let1</code> macro gets transformed. Here is its definition once again:</p><a id="I_programlisting3_d1e28136"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmacro let1 (var val &amp;body body)
    `(let ((,var ,val))
       ,@body))</pre><p>The first line of this <code class="literal">defmacro</code> call <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28148"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> tells the macro expander, “Hey, if you see a form in code that begins with let1, here’s what you need to do to transform it into standard Lisp.” A macro defined with <code class="literal">defmacro</code> may also have arguments passed into it, which will contain the raw source code found inside the macro when the macro is used. The <code class="literal">let1</code> macro has three such arguments passed into it: <code class="literal">var</code>, <code class="literal">val</code>, and <code class="literal">body</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28170"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. So what do these three arguments represent?</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e28177"/><img src="httpatomoreillycomsourcenostarchimages779867.png" alt="image with no caption"/></div></div><p>As you can see, when we use <code class="literal">let1</code>, we’ll end up having three different expressions inside it, which are the arguments to the <code class="literal">let1</code> macro:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>var</code></strong></span></dt><dd><p>The first argument is the name of the variable we’re defining. This name will be available within our macro using the argument named <code class="literal">var</code>. In this example, it will equal the symbol <code class="literal">foo</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>val</code></strong></span></dt><dd><p>The second expression holds the code that determines the value of the variable. In our macro, this is the second argument, <code class="literal">val</code>. It will equal the list <code class="literal">(+ 2 3)</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>body</code></strong></span></dt><dd><p>The third expression inside a <code class="literal">let1</code> call is the body code, which makes use of the new variable that’s created (in this case, <code class="literal">foo</code>). It will be available in the macro through the argument named <code class="literal">body</code>.</p></dd></dl></div><p>Since the <code class="literal">let</code> command is allowed to have multiple statements in its body, we will want to mirror this behavior in the <code class="literal">let1</code> macro. This is why, in the <code class="literal">defmacro</code> command defining let1, the final <code class="literal">body</code> argument has the special keyword <code class="literal">&amp;body</code> in front of it. This tells the macro expander “Give me all remaining expressions in the macro in a list.” Because of this, the body argument in our <code class="literal">let1</code> example is actually <code class="literal">((* foo foo))</code>—a nested list. In this example, we put only a single statement inside <code class="literal">let1</code>.<a id="IDX-CHP-16-0012" class="indexterm"/><a id="IDX-CHP-16-0013" class="indexterm"/><a id="IDX-CHP-16-0014" class="indexterm"/><a id="IDX-CHP-16-0015" class="indexterm"/><a id="IDX-CHP-16-0016" class="indexterm"/></p><p>Now that you’ve seen what the values to the arguments of our <code class="literal">let1</code> macro are, let’s see how the macro uses this information to transform the <code class="literal">let1</code> into a standard <code class="literal">let</code> that the Lisp compiler can understand. The easiest way to transform source code in Lisp is to use backquote syntax. (If you don’t remember how to use backquotes, please see <a class="xref" href="ch05s04.html#how_quasiquoting_works" title="How Quasiquoting Works">How Quasiquoting Works</a> in <a class="xref" href="ch05s04.html#how_quasiquoting_works" title="How Quasiquoting Works">How Quasiquoting Works</a>.) With backquotes, we can build the code for a proper <code class="literal">let</code> command using code passed to <code class="literal">let1</code>. Here’s our <code class="literal">let1</code> macro again for reference:</p><a id="I_programlisting3_d1e28302"/><pre class="programlisting">(defmacro let1 (var val &amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   `(let ((,var ,val))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>      ,@body))</pre><p>As you can see, the <code class="literal">let1</code> macro returns a backquoted list starting with the symbol <code class="literal">let</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28325"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, followed by the variable name and value, placed in a proper nested list, which Lisp’s <code class="literal">let</code> command requires. The commas cause the actual variable name and value to be plopped in at these locations. Finally, we place the <code class="literal">body</code> code from the <code class="literal">let1</code> in the analogous place in the <code class="literal">let</code> command <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28344"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>The <code class="literal">body</code> argument is inserted into the transformed code using the splicing comma <code class="literal">(,@)</code>. To understand why the <code class="literal">body</code> needs to be handled in this special way, consider the following use of our <code class="literal">let1</code> macro:</p><a id="I_programlisting3_d1e28364"/><pre class="programlisting">&gt; <strong class="userinput"><code>(let1 foo (+ 2 3)</code></strong>
<strong class="userinput"><code>    (princ "Lisp is awesome!")</code></strong>
<strong class="userinput"><code>    (* foo foo))</code></strong>
Lisp is awesome!
25</pre><p>In this case, we’ve put more than one thing inside the body of our <code class="literal">let</code>. Remember that the <code class="literal">let</code> command includes an implicit <code class="literal">progn</code> command, and it can have multiple Lisp instructions inside. Our new <code class="literal">let</code>1 macro allows for this as well by placing the special <code class="literal">&amp;body</code> marker in front of the <code class="literal">body</code> argument, causing all remaining syntax expressions to be passed into <code class="literal">let1</code> as a list. So, in the preceding example, the <code class="literal">body</code> argument contains the code <code class="literal">((princ "Lisp is awesome!") (* foo foo))</code>.</p></div><div class="sect2" title="Using the Simple Macro"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_simple_macro"/>Using the Simple Macro</h2></div></div></div><p>Now that we’ve written our <code class="literal">let1</code> macro, let’s rewrite our custom <code class="literal">add</code> function in a cleaner way:<a id="IDX-CHP-16-0017" class="indexterm"/><a id="IDX-CHP-16-0018" class="indexterm"/></p><a id="I_programlisting3_d1e28424"/><pre class="programlisting">(defun add (a b)
  (let1 x (+ a b)
     (format t "The sum is ˜a" x)
     x))</pre><p>Isn’t this much easier on the eyes?</p><p>We can use the <code class="literal">macroexpand</code> command to see code generated by a macro. Simply pass the macro’s code to <code class="literal">macroexpand</code>, like this:</p><a id="I_programlisting3_d1e28436"/><pre class="programlisting">&gt; <strong class="userinput"><code>(macroexpand '(let1 foo (+ 2 3)</code></strong>
  <strong class="userinput"><code>                  (* foo foo)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (LET ((FOO (+ 2 3))) (* FOO FOO)) ;
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> T</pre><p>You can now see the raw code generated by <code class="literal">let1</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28461"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The <code class="literal">T</code> at the end <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28470"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> just means <code class="literal">macroexpand</code> was handed a valid macro that it was able to expand.</p><p>As your macros become more complex, you’ll find that <code class="literal">macroexpand</code> is a valuable tool in testing and debugging their structure.</p></div></div></div>
<div class="sect1" title="More Complex Macros"><div class="titlepage"><div><div><h1 class="title"><a id="more_complex_macros"/>More Complex Macros</h1></div></div></div><p>Let’s suppose you need a custom <code class="literal">my-length</code> command. This is a classic list-eating function that will count the length of a list. We’ll write it in the proper “tail call optimized” style (discussed in <a class="xref" href="ch16.html" title="Chapter 14. Ramping Lisp Up a Notch with Functional Programming">Chapter 14</a>), where the recursive function call is in the tail position. Here’s the code:</p><a id="I_programlisting3_d1e28494"/><pre class="programlisting">(defun my-length (lst)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((f (lst acc)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>              (if lst
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                (f (cdr lst) (1+ acc))
                 acc)))
      (f lst 0)))</pre><p>As you can see, this function has tons of repetitive stuff, once again giving us that dreaded feeling of <span class="emphasis"><em>déjà vu</em></span>. There are two repetitive patterns in this function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>As in other list-eater functions, we have the annoying check to see if the list is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28523"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> and the associated use of <code class="literal">cdr</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28532"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p></li><li class="listitem"><p>We did all this verbose work to create a local function <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28544"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p></li></ul></div><p>Let’s write some macros that make this function (and other functions with the same repetition) more pithy.<a id="IDX-CHP-16-0019" class="indexterm"/><a id="IDX-CHP-16-0020" class="indexterm"/><a id="IDX-CHP-16-0021" class="indexterm"/><a id="IDX-CHP-16-0022" class="indexterm"/></p><div class="sect2" title="A Macro for Splitting Lists"><div class="titlepage"><div><div><h2 class="title"><a id="a_macro_for_splitting_lists"/>A Macro for Splitting Lists</h2></div></div></div><p>First, let’s create a <code class="literal">split</code> macro. It will let us write cleaner list-eater functions, such as our <code class="literal">my-length</code> function.</p><p>List-eaters always check if the list is empty. If it isn’t, they take apart the list using <code class="literal">car</code> and/or <code class="literal">cdr</code>, and then perform operations on the head and/or tail of the list. The <code class="literal">split</code> macro does this for us. Here’s what it looks like when we use the finished <code class="literal">split</code> macro:</p><a id="I_programlisting3_d1e28593"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(split '(2 3)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>     (format t "This can be split into ˜a and ˜a." head tail)</code></strong>
  <strong class="userinput"><code>    (format t "This cannot be split."))</code></strong>
  This can be split into 2 and (3).
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> &gt; <strong class="userinput"><code>(split '()</code></strong>
  <strong class="userinput"><code>    (format t "This can be split into ˜a and ˜a." head tail)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/><strong class="userinput"><code>     (format t "This cannot be split."))</code></strong>
  This cannot be split.</pre><p>The first argument of the <code class="literal">split</code> macro is a list you want to split into a head and a tail <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28640"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If this is possible, the next expression in the <code class="literal">split</code> macro will be called <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28649"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. As a bonus, our <code class="literal">split</code> macro automatically creates two variables for us, named <code class="literal">head</code> and <code class="literal">tail</code>. This way, we don’t always need to call <code class="literal">car</code> and <code class="literal">cdr</code> inside list-eating functions. If the list is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28671"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, we call the expression at the end <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28677"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Let’s look at the code for the <code class="literal">split</code> macro. Note that this initial version of the macro contains some bugs we’ll discuss shortly:</p><a id="I_programlisting3_d1e28688"/><pre class="programlisting">;Warning! Contains Bugs!
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmacro split (val yes no)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   `(if ,val
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>      (let ((head (car ,val))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>            (tail (cdr ,val)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>        ,yes)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>        ,no))</pre><p>Our <code class="literal">split</code> macro requires three (and only three) expressions as arguments <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28732"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This means when we use this macro, we’ll always need exactly three items.</p><p>The code that needs to be generated by <code class="literal">split</code> is pretty straightforward. First, we have an <code class="literal">if</code> that checks if the list is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28746"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. If it is, we break apart the list and stick it into our two local variables, <code class="literal">head</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28755"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> and <code class="literal">tail</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28765"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Then we put in the code that handles the “yes, we can split the list” case <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28771"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. If we can’t split the list, we call the no case <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28777"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Note that in the no case, we don’t have access to the <code class="literal">head/tail</code> variables, since they aren’t created if the list can’t be split.</p><p>With this new <code class="literal">split</code> macro, we can clean up our <code class="literal">my-length</code> macro a bit:<a id="IDX-CHP-16-0023" class="indexterm"/></p><a id="I_programlisting3_d1e28799"/><pre class="programlisting">(defun my-length (lst)
    (labels ((f (lst acc)
               (split lst
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                (f tail (1+ acc))
                 acc)))
      (f lst 0)))</pre><p>Notice how we now make use of the <code class="literal">tail</code> variable created by <code class="literal">split</code>, simplifying our code <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28816"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Macros that automatically generate variables like this are called <span class="emphasis"><em>anaphoric macros</em></span>.<a id="IDX-CHP-16-0024" class="indexterm"/></p><p>However, we are not yet finished with our <code class="literal">split</code> macro. Although it basically works, it contains some subtle bugs that we need to address.</p></div><div class="sect2" title="Avoiding Repeated Execution in Macros"><div class="titlepage"><div><div><h2 class="title"><a id="avoiding_repeated_execution_in_macros"/>Avoiding Repeated Execution in Macros</h2></div></div></div><p>One common bug that can happen in a macro is incorrect repeated execution of code. In fact, our current version of the <code class="literal">split</code> macro contains this flaw. Here is an example that clearly shows the problem:</p><a id="I_programlisting3_d1e28841"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>&gt; <strong class="userinput"><code>(split (progn (princ "Lisp rocks!")</code></strong>
  <strong class="userinput"><code>                '(2 3))</code></strong>
  <strong class="userinput"><code>    (format t "This can be split into ˜a and ˜a." head tail)</code></strong>
  <strong class="userinput"><code>    (format t "This cannot be split."))</code></strong>
  Lisp rocks!Lisp rocks!Lisp rocks!This can be split into 2 and (3).</pre><p>In this use of <code class="literal">split</code>, the statement “Lisp rocks!” was printed three times, even though it appears only once in the original code. How is this possible?</p><p>Remember that the arguments passed into a macro consist of raw source code. This means the <code class="literal">val</code> argument passed into <code class="literal">split</code> contains the raw code of the <code class="literal">progn</code> statement <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28876"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, including the raw code for the <code class="literal">princ</code> statement within it. Since we reference <code class="literal">val</code> three times inside the <code class="literal">split</code> macro, it causes the <code class="literal">princ</code> statement to be executed three times.</p><p>We can verify this by running this example through <code class="literal">macroexpand</code>:</p><a id="I_programlisting3_d1e28900"/><pre class="programlisting">&gt; <strong class="userinput"><code>(macroexpand '(split (progn (princ "Lisp rocks!")</code></strong>
  <strong class="userinput"><code>                              '(2 3))</code></strong>
  <strong class="userinput"><code>                     (format t "This can be split into ˜a and ˜a." head tail)</code></strong>
  <strong class="userinput"><code>                     (format t "This cannot be split.")))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (IF (PROGN (PRINC "Lisp rocks!") '(2 3))
   (LET
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   ((HEAD (CAR (PROGN (PRINC "Lisp rocks!") '(2 3))))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>    (TAIL (CDR (PROGN (PRINC "Lisp rocks!") '(2 3)))))
    (FORMAT T "This can be split into ˜a and ˜a." HEAD TAIL))
   (FORMAT T "This cannot be split.")) ;
  T</pre><p>As you can see, the <code class="literal">princ</code> statement appears three times <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28938"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28943"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e28948"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. This causes unexpected behavior and is inefficient, since we’re repeatedly running the same code unnecessarily.<a id="IDX-CHP-16-0025" class="indexterm"/><a id="IDX-CHP-16-0026" class="indexterm"/><a id="IDX-CHP-16-0027" class="indexterm"/></p><p>If you give this problem some thought, the solution isn’t too hard to figure out. We simply need to create a local variable inside the <code class="literal">split</code> macro, like this:</p><a id="I_programlisting3_d1e28970"/><pre class="programlisting">;Warning! Still contains a bug!
(defmacro split (val yes no)
  `(let1 x ,val
     (if x
       (let ((head (car x))
             (tail (cdr x)))
         ,yes)
         ,no)))</pre><p>Note that we made use of <code class="literal">let1</code> in this new version of <code class="literal">split</code>. As this shows, it is perfectly okay to use macros inside <span class="emphasis"><em>other</em></span> macros.</p><p>Now if we rerun our previous example, we can see that <code class="literal">split</code> behaves correctly, <code class="literal">princ</code>ing the statement only once:</p><a id="I_programlisting3_d1e28992"/><pre class="programlisting">&gt; <strong class="userinput"><code>(split (progn (princ "Lisp rocks!")</code></strong>
<strong class="userinput"><code>                '(2 3))</code></strong>
<strong class="userinput"><code>    (format t "This can be split into ˜a and ˜a." head tail)</code></strong>
<strong class="userinput"><code>    (format t "This cannot be split."))</code></strong>
Lisp rocks!This can be split into 2 and (3).</pre><p>Unfortunately, this new version of the <code class="literal">split</code> macro introduces <span class="emphasis"><em>yet another</em></span> bug. Let’s tackle this new bug next.</p></div><div class="sect2" title="Avoiding Variable Capture"><div class="titlepage"><div><div><h2 class="title"><a id="avoiding_variable_capture"/>Avoiding Variable Capture</h2></div></div></div><p>To see the bug in our newest version of <code class="literal">split</code>, try running the following:</p><a id="I_programlisting3_d1e29022"/><pre class="programlisting">&gt; <strong class="userinput"><code>(let1 × 100</code></strong><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>
<strong class="userinput"><code>    (split '(2 3)</code></strong>
<strong class="userinput"><code>      (+ x head)</code></strong>
<strong class="userinput"><code>      nil))</code></strong>
*** - +: (2 3) is not a number</pre><p>Can you tell what happened? We just created a variable <code class="literal">x</code> inside the new version of our <code class="literal">split</code> macro! Here’s what the call to <code class="literal">split</code> looks like if we <code class="literal">macroexpand</code> it:</p><a id="I_programlisting3_d1e29055"/><pre class="programlisting">&gt; <strong class="userinput"><code>(macroexpand '(split '(2 3)</code></strong>
  <strong class="userinput"><code>                  (+ x head)</code></strong>
  <strong class="userinput"><code>                  nil))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (LET ((X '(2 3)))
     (IF X (LET ((HEAD (CAR X)) (TAIL (CDR X))) (+ X HEAD)) NIL)) ;
  T</pre><p>Notice how the expanded version of <code class="literal">split</code> contains a definition of <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29080"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This blocks the competing definition in our troublesome example <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29086"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. In this scenario, the <code class="literal">split</code> macro accidentally <span class="emphasis"><em>captured</em></span> the variable <code class="literal">x</code> and overwrote it in an unexpected way. How can we avoid this problem?<a id="IDX-CHP-16-0028" class="indexterm"/><a id="IDX-CHP-16-0029" class="indexterm"/><a id="IDX-CHP-16-0030" class="indexterm"/></p><p>One simple solution would be to not create a variable <code class="literal">x</code> in the macro, but to instead use a variable with some insane long name like <code class="literal">xqweopfjsadlkjgh</code>. Then we could feel pretty confident the variable used inside the macro will never clash with a variable inside the code that uses it. If fact, there is a Common Lisp function called <code class="literal">gensym</code> whose job it is to generate crazy variable names exactly for this purpose:</p><a id="I_programlisting3_d1e29124"/><pre class="programlisting">&gt; <strong class="userinput"><code>(gensym)</code></strong>
#:G8695</pre><p>The <code class="literal">gensym</code> function will create a unique variable name for you that is guaranteed never to clash with any other variable name in your code. You may notice that it also has a special prefix (<code class="literal">#</code>:) that differentiates it from other names. Common Lisp handles these <code class="literal">gensym-based</code> names as a special case and will stop you from using the name of a <code class="literal">gensym</code> variable directly.</p><p>Now let’s use the <code class="literal">gensym</code> function inside our <code class="literal">split</code> macro to protect the macro from causing variable capture:</p><a id="I_programlisting3_d1e29151"/><pre class="programlisting">;This function is finally safe to use
  (defmacro split (val yes no)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let1 g (gensym)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   `(let1 ,g ,val
       (if ,g
         (let ((head (car ,g))
               (tail (cdr ,g)))
           ,yes)
           ,no))))</pre><p>In the first line of our revised macro, we define a variable <code class="literal">g</code> that contains the <code class="literal">gensym</code> name <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29174"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. It’s very important to notice that there is <span class="emphasis"><em>not</em></span> a backquote at the front of this line. This means that this line of code is run at <span class="emphasis"><em>macro expand time</em></span>, not <span class="emphasis"><em>runtime</em></span>, and it is perfectly fine to define the variable <code class="literal">g</code> at this point. The <code class="literal">let1</code> on the next line, however, has a backquote in front of it <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29196"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This line will be run at runtime, so we don’t want to use a hardcoded variable in this spot. In this new version, we instead use the unique <code class="literal">gensym</code> name stored in <code class="literal">g</code>.</p><p>Now every time the <code class="literal">split</code> macro is used, a unique name is generated to hold the internal value. We can test this by running some examples through <code class="literal">macroexpand</code>:</p><a id="I_programlisting3_d1e29216"/><pre class="programlisting">&gt; <strong class="userinput"><code>(macroexpand '(split '(2 3)</code></strong>
<strong class="userinput"><code>                  (+ x head)</code></strong>
<strong class="userinput"><code>                  nil))</code></strong>
(LET ((<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>#:G8627 '(2 3))) (IF #:G8627 (LET ((HEAD (CAR #:G8627))
 (TAIL (CDR #:G8627))) (+ X HEAD)) NIL)) ;
T
&gt; <strong class="userinput"><code>(macroexpand '(split '(2 3)</code></strong>
<strong class="userinput"><code>                  (+ x head)</code></strong>
<strong class="userinput"><code>                  nil))</code></strong>
(LET ((<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>#:G8628 '(2 3))) (IF #:G8628 (LET ((HEAD (CAR #:G8628))
 (TAIL (CDR #:G8628))) (+ X HEAD)) NIL)) ;
T</pre><p>Notice how a differently named local variable was created in both instances <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29251"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29256"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This guarantees that the variable name will not only be unique within your code, but will also be unique if the <code class="literal">split</code> macro is ever used multiple times in a nested fashion. We have now created a fully debugged version of our <code class="literal">split</code> macro.<a id="IDX-CHP-16-0031" class="indexterm"/><a id="IDX-CHP-16-0032" class="indexterm"/><a id="IDX-CHP-16-0033" class="indexterm"/><a id="IDX-CHP-16-0034" class="indexterm"/></p><p>Just because it is now bug-free does not mean that it is free of variable capture. Note that the macro still defines the variables <code class="literal">head</code> and <code class="literal">tail</code>. If you used this function in other code in which head or tail had an alternate meaning, your code would fail! However, in the case of <code class="literal">head</code> and <code class="literal">tail</code>, the capture is on purpose. In this situation, the variable capture is a <span class="emphasis"><em>feature</em></span>, not a bug—it is an anaphoric macro. As we’ve discussed, this means that it makes named variables or functions available that we can use in the body of the macro.</p></div><div class="sect2" title="A Recursion Macro"><div class="titlepage"><div><div><h2 class="title"><a id="a_recursion_macro"/>A Recursion Macro</h2></div></div></div><p>Let’s take another look at our improved <code class="literal">my-length</code> macro:</p><a id="I_programlisting3_d1e29312"/><pre class="programlisting">(defun my-length (lst)
  (labels ((f (lst acc)
             (split lst
               (f tail (1+ acc))
               acc)))
    (f lst 0)))</pre><p>As we discussed, there is an additional repetitive pattern in this code: The creation of a local function <code class="literal">f</code>. Let’s write another macro that gets rid of this additional visual noise: <code class="literal">recurse</code>. Here’s an example of the <code class="literal">recurse</code> macro in use:</p><a id="I_programlisting3_d1e29325"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(recurse (n 9)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>     (fresh-line)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/><strong class="userinput"><code>     (if (zerop n)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/><strong class="userinput"><code>       (princ "lift-off!")</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/><strong class="userinput"><code>       (progn (princ n)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/><strong class="userinput"><code>              (self (1- n)))))</code></strong>
  9
  8
  7
  6
  5
  4
  3
  2
  1
  lift-off!</pre><p>The first parameter into the <code class="literal">recurse</code> macro is a list of variables and their starting values <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29381"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. In this case, we’re declaring only one variable (<code class="literal">n</code>) and setting its starting value to 9. The rest of the lines in the macro make up the body of the recursive function.<a id="IDX-CHP-16-0035" class="indexterm"/><a id="IDX-CHP-16-0036" class="indexterm"/></p><p>The first thing we do in the body is start a fresh line <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29398"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Then we check if <code class="literal">n</code> has reached zero yet <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29407"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If it has, we print “lift-off!” <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29413"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Otherwise, we print the current number <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29419"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span> and call the function again, recursively. Like our <code class="literal">split</code> macro, the <code class="literal">recurse</code> macro is anaphoric. In the case of <code class="literal">recurse</code>, it makes a function named <code class="literal">self</code> available, which we call when we’re ready to perform a recursion <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29438"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. We also subtract one from <code class="literal">n</code> at this point to lower the countdown number.</p><p>Now that we’ve seen how <code class="literal">recurse</code> should work, let’s write this <code class="literal">recurse</code> macro. In order to process the list of arguments and starting values, it’s useful for us to have a function that can group items into a list of pairs. Here is a function, <code class="literal">pairs</code>, that accomplishes this:</p><a id="I_programlisting3_d1e29458"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defun pairs (lst)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/><strong class="userinput"><code>     (labels ((f (lst acc)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/><strong class="userinput"><code>                 (split lst</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/><strong class="userinput"><code>                   (if tail</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/><strong class="userinput"><code>                       (f (cdr tail) (cons (cons head (car tail)) acc))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/><strong class="userinput"><code>                       (reverse acc))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/><strong class="userinput"><code>                   (reverse acc))))</code></strong>
  <strong class="userinput"><code>      (f lst nil)))</code></strong>
  PAIRS
  &gt; <strong class="userinput"><code>(pairs '(a b c d e f))</code></strong>
  ((A . B) (C . D) (E . F))</pre><p>The <code class="literal">pairs</code> function is a tail-call-optimized list-eater, which, ironically, has its own local function <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29527"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. (Shortly, we won’t need to declare such a function anymore.) It uses <code class="literal">split</code> to break an item off the list <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29536"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. However, since it needs to process two items (a pair) from the list at once, we need to run an additional check to see if the tail is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29543"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If there are no items in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29549"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span> (or only one item left <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29555"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>), we return our accumulated values. Otherwise, we recursively process the rest of the list, with a new pair of items placed into the accumulator <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29561"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Now we’re finally ready to write the <code class="literal">recurse</code> macro:</p><a id="I_programlisting3_d1e29573"/><pre class="programlisting">(defmacro recurse (vars &amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let1 p (pairs vars)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     `(labels ((self ,(mapcar #'car p)
                  ,@body))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>        (self ,@(mapcar #'cdr p)))))</pre><p>As you can see, it simply transforms the recursion into a traditional local function. First, it uses our new <code class="literal">pairs</code> function to take apart the variable names and starting values, and puts the result into <code class="literal">p</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29601"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then it defines a local function simply named <code class="literal">self</code>. The variable names for <code class="literal">self</code> are the odd-numbered items from <code class="literal">p</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29617"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Since we want <code class="literal">self</code> to be accessible, anaphorically, from inside the macro, we use a plain name instead of a <code class="literal">gensym</code> name for this function. At the bottom of the macro, we then simply call <code class="literal">self</code>, passing in all the starting values <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29632"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.<a id="IDX-CHP-16-0037" class="indexterm"/><a id="IDX-CHP-16-0038" class="indexterm"/></p><p>Now that we’ve created the <code class="literal">recurse</code> macro, let’s once again clean up our <code class="literal">my-length</code> function using this new language construct:</p><a id="I_programlisting3_d1e29657"/><pre class="programlisting">(defun my-length (lst)
  (recurse (lst lst
            acc 0)
           (split lst
             (f tail (1+ acc))
             acc)))</pre><p>As you can see, there is very little repetition or visual noise in this version of our <code class="literal">my-length</code> function.</p><p>Now you can appreciate how helpful macros can be when trying to write clean, succinct code. However, a liberal use of macros will also require you to bear some costs that you need to be aware of. We’ll look at the potential downsides to macros next.</p></div></div>
<div class="sect1" title="Macros: Dangers and Alternatives"><div class="titlepage"><div><div><h1 class="title"><a id="macros_colon_dangers_and_alternatives"/>Macros: Dangers and Alternatives</h1></div></div></div><p>Macros allow us to write code that generates other code, making the Lisp languages a wonderful tool for metaprogramming and prototyping new language ideas. But, at some level, macros are just a sleight of hand: They let you trick the Lisp compiler/interpreter into accepting your own customized language constructs and treating them like standard Lisp. They are indeed a powerful tool in a programmer’s tool chest, but they are not as elegant as some of the other programming tools you’ve encountered in this book.</p><p>The main drawback of macros is that they can make it hard for other programmers to understand your code. After all, if you’re creating your own language dialect, other programmers won’t be familiar with it. Even your future self—say, in a year or two—may have a hard time understanding the structure of your code if you’ve made heavy use of macros. Because of this, experienced Lispers will do their best to use alternate techniques to macro programming whenever possible. Often, a beginning Lisper will write a macro in situations that could be addressed in other, cleaner ways.</p><p>For instance, it’s fun to see how we were able to clean up our <code class="literal">my-length</code> function by adding a couple of macros named <code class="literal">split</code> and <code class="literal">recurse</code>. However, in the previous two chapters, you learned about another tool, functional programming, which can also be used to clean up list-eater functions. One powerful function often used by functional programmers is <code class="literal">reduce</code>. It is a higher-order function that accepts a function and a list, and will call the function once for every value in the list. Here is the <code class="literal">my-length</code> function rewritten to use the powerful <code class="literal">reduce</code> function, rather than macros:</p><a id="I_programlisting3_d1e29694"/><pre class="programlisting">(defun my-length (lst)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (reduce (lambda (x i)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>             (1+ x))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>           lst
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>           :initial-value 0))</pre><p>As you can see, this new version of <code class="literal">my-length</code> easily blows away our previous version. It is shorter, and it doesn’t rely on any of the nonstandard macros that we created.</p><p>The first argument to <code class="literal">reduce</code> holds our <span class="emphasis"><em>reduction function</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29733"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Its job is to keep track of, and update, an accumulated value, here named <code class="literal">x</code>. This variable <code class="literal">x</code> will hold the current accumulated value, which in this case will be the length of the list so far. This means we can simply add one to <code class="literal">x</code> to update it to its new value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29749"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Since the reduction function will be called once for every item in the list, it will, in the end, generate the length of the list. (The reduction function also receives, as an argument, the current item in the list, here given as the variable <code class="literal">i</code>. However, we do not need it for calculating the list’s length.) The next item passed to <code class="literal">reduce</code> is the list we want to reduce <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29761"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Finally, since the accumulated length we’re calculating should have an initial value of zero, we indicate this by setting the <code class="literal">:initial-value</code> keyword argument to zero <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e29771"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Clearly, there are other scenarios where the list-eater macros we’ve created in this chapter are still useful. There are many cases where the <code class="literal">reduce</code> function could not be so easily used. So in the end, there are still many situations where creating your own Lisp dialect is exactly the right solution to a problem, as you’ll see in the next chapter.</p></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id16"/>What You've Learned</h1></div></div></div><p>This chapter covered macro programming. You’ve learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Macros let you write code that writes code. With macros, you can create your own programming language and convert it to standard Lisp just before the compiler can get a peek at it.</p></li><li class="listitem"><p>Macros allow you to get rid of that feeling of <span class="emphasis"><em>déjà vu</em></span> when writing your code, in situations when nothing else can do so.</p></li><li class="listitem"><p>You must be careful when writing macros so that they don’t lead to unintentional, repeated execution of code.</p></li><li class="listitem"><p>You need to be careful to avoid unintended <span class="emphasis"><em>variable capture</em></span> in macros. You can avoid this by using <code class="literal">gensym</code> names.</p></li><li class="listitem"><p>If variables created by a macro are exposed on purpose, as a feature of the macro, the macro is called an <span class="emphasis"><em>anaphoric macro</em></span>.</p></li><li class="listitem"><p>Macro programming is a very powerful technique. However, try to use functional programming instead to solve a problem whenever possible. Macros should always be a last resort.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;17.&#xA0;Domain-Specific Languages"><div class="titlepage"><div><div><h1 class="title"><a id="domain-specific_languages"/>Chapter 17. Domain-Specific Languages</h1></div></div></div><p>One of the best reasons for using macros is to perform <span class="emphasis"><em>domain-specific language</em></span> (<span class="emphasis"><em>DSL</em></span>) programming. DSL programming is an advanced macro programming technique that allows us to solve difficult programming problems by drastically changing the structure and appearance of Lisp code to optimize it for a specialized purpose. Although macros are not strictly necessary for doing DSL programming, by writing a set of macros, you can easily create a DSL in Lisp.<a id="IDX-CHP-17-0001" class="indexterm"/><a id="IDX-CHP-17-0002" class="indexterm"/><a id="IDX-CHP-17-0003" class="indexterm"/></p><div class="sect1" title="What Is a Domain?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_domain_question"/>What Is a Domain?</h1></div></div></div><p>According to the 2000 US Census, the average family in the United States had 1.86 children. Since no individual family has exactly 1.86 children, it is obvious that no particular family is truly perfectly average. In the same way, there is no such thing as an average computer program. Every program is designed to solve a specific problem, and every area of human inquiry, or <span class="emphasis"><em>domain</em></span>, has its own idiosyncratic requirements that influence programs that solve problems in the given area. With DSLs, we enhance the core of our programming language to take these domain-specific requirements into account, potentially making our resulting code easier to write and understand.</p><p>Let’s take a look at some specific domains and create some DSLs that let us easily work within these domains using Lisp. In this chapter, we’ll create two different DSLs. First, we’ll create a DSL for writing <span class="emphasis"><em>scalable vector graphics (SVG)</em></span> files. Then we’ll write a DSL for creating commands in a text adventure—we’re finally going to upgrade our Wizard’s Adventure Game from <a class="xref" href="ch05.html" title="Chapter 5. Building a Text Game Engine">Chapter 5</a> and <a class="xref" href="ch06.html" title="Chapter 6. Interacting with the World: Reading and Printing in Lisp">Chapter 6</a> to make it fully playable!<a id="IDX-CHP-17-0004" class="indexterm"/></p></div></div>
<div class="sect1" title="Writing SVG Files"><div class="titlepage"><div><div><h1 class="title"><a id="writing_svg_files"/>Writing SVG Files</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e29864"/><img src="httpatomoreillycomsourcenostarchimages780406.png" alt="image with no caption"/></div></div><p>The SVG format is a file format for drawing graphics. In this format, you specify objects like circles and polygons, and then pass them to a compatible computer program to view. Because the SVG format specifies a drawing using pure math functions instead of raw pixels, it is easy for a program to render an SVG image at any size, making images in this format easily scalable.</p><p>The SVG format is currently receiving a lot of attention from web developers. All modern browsers (excluding Microsoft Internet Explorer) support SVG natively. Recently, Google released a set of libraries called SVG Web that adds decent support for SVG, even in Internet Explorer. This allows SVG to work in more than 90 percent of current web browsers. Finally, SVG has become a practical and efficient option for drawing graphics on websites.<a id="IDX-CHP-17-0005" class="indexterm"/></p><p>The SVG format is built on top of the XML format. Here is an example of what a complete SVG file looks like:<a id="IDX-CHP-17-0006" class="indexterm"/><a id="IDX-CHP-17-0007" class="indexterm"/><a id="IDX-CHP-17-0008" class="indexterm"/><a id="IDX-CHP-17-0009" class="indexterm"/></p><a id="I_programlisting4_d1e29894"/><pre class="programlisting">&lt;svg &gt;
  &lt;circle cx="50"
          cy="50"
          r="50"
          style="fill:rgb(255,0,0);stroke:rgb(155,0,0)"&gt;
  &lt;/circle&gt;
  &lt;circle cx="100"
          cy="100"
          r="50"
          style="fill:rgb(0,0,255);stroke:rgb(0,0,155)"&gt;
  &lt;/circle&gt;
&lt;/svg&gt;</pre><p>Simply copy this text and place it in a file named <span class="emphasis"><em>example.svg</em></span> (or download this file from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>). Then you can open the file from the Firefox web browser (the Safari, Chrome, and Opera web browsers should also work).</p><p>Here is what you should see, with a red and blue circle:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e29906"/><img src="httpatomoreillycomsourcenostarchimages782270.png.jpg" alt="image with no caption"/></div></div><p>Now, let’s write some macros and functions to let us create a picture like this directly in Common Lisp!</p><div class="sect2" title="Creating XML and HTML with the tag Macro"><div class="titlepage"><div><div><h2 class="title"><a id="creating_xml_and_html_with_the_tag_macro"/>Creating XML and HTML with the tag Macro</h2></div></div></div><p>The XML data format (just like the HTML data format) consists primarily of nested tags:</p><a id="I_programlisting4_d1e29918"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &lt;mytag&gt;
      &lt;inner_tag&gt;
      &lt;/inner_tag&gt;
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &lt;/mytag&gt;</pre><p>Every tag <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e29933"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> also has a matching closing tag <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e29939"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. The closing tag has the same name, but with a slash preceding it. Additionally, tags may contain attributes:<a id="IDX-CHP-17-0010" class="indexterm"/><a id="IDX-CHP-17-0011" class="indexterm"/><a id="IDX-CHP-17-0012" class="indexterm"/><a id="IDX-CHP-17-0013" class="indexterm"/></p><a id="I_programlisting4_d1e29957"/><pre class="programlisting">&lt;mytag color="BLUE" height="9"&gt;&lt;/mytag&gt;</pre><p>In this example, we create a tag named <code class="literal">mytag</code> that has the attribute of being blue and has a height of 9.</p><div class="sect3" title="Writing a Macro Helper Function"><div class="titlepage"><div><div><h3 class="title"><a id="writing_a_macro_helper_function"/>Writing a Macro Helper Function</h3></div></div></div><p>Often, when writing a macro to perform a task, you’ll find a lot of what your macro needs to do can be handled by a function instead. Because of this, it is often prudent to first write a helper function that does most of what the macro needs to do. Then you write the macro, keeping it as simple as possible by leveraging the helper function. This is what we’re going to do as we write a macro to create XML-style tags in Lisp.<a id="IDX-CHP-17-0014" class="indexterm"/></p><p>Here is our helper function, called <code class="literal">print-tag</code>, which prints a single opening (or closing) tag:</p><a id="I_programlisting4_d1e29979"/><pre class="programlisting">(defun print-tag (name alst closingp)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (princ #\&lt;)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (when closingp
      (princ #\/))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>   (princ (string-downcase name))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>   (mapc (lambda (att)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>           (format t " ˜a=\"˜a\"" (string-downcase (car att)) (cdr att)))
        alst)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>   (princ #\&gt;))</pre><p>First, the <code class="literal">print-tag</code> function prints an opening angle bracket <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30023"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Since this is only a character, we use the literal character syntax by prefixing the bracket with #\. Then we check the predicate <code class="literal">closingp</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30032"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. If it is true, the tag needs to have a slash in front of it to make it a closing tag. Then we print the name of the tag, converted to lowercase with the <code class="literal">string-downcase</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30042"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Next, we iterate through all the attributes in the <code class="literal">alst</code> of attributes <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30051"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> and print out each attribute/value pair <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30057"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Finally, we end by putting in a closing angle bracket <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30063"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>The following is an example use of the <code class="literal">print-tag</code> function. Since it is a plain function and not a macro, it’s easy to debug in the REPL. This is another reason why helper functions are a good idea when creating macros.</p><a id="I_programlisting4_d1e30074"/><pre class="programlisting">&gt; <strong class="userinput"><code>(print-tag 'mytag '((color . blue) (height . 9)) nil)</code></strong>
&lt;mytag color="BLUE" height="9"&gt;</pre><p>As you can see, this function does a fine job of printing an XML tag. However, it would be a real chore if all tags had to be created in this way. That’s why we’re going to write the <code class="literal">tag</code> macro next.</p></div><div class="sect3" title="Creating the tag Macro"><div class="titlepage"><div><div><h3 class="title"><a id="creating_the_tag_macro"/>Creating the tag Macro</h3></div></div></div><p>The <code class="literal">tag</code> macro we’ll create has been adopted from the macro of the same name in Paul Graham’s Arc Lisp dialect. It improves on the <code class="literal">print-tag</code> function in several crucial ways, all of which could not be remedied without having a macro:<a id="IDX-CHP-17-0015" class="indexterm"/><a id="IDX-CHP-17-0016" class="indexterm"/><a id="IDX-CHP-17-0017" class="indexterm"/><a id="IDX-CHP-17-0018" class="indexterm"/><a id="IDX-CHP-17-0019" class="indexterm"/><a id="IDX-CHP-17-0020" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Tags always come in pairs. However, if we want to nest tags, a function would not be able to print tags that surround the tags printed inside it. This is because it requires us to execute code before and after nested tags are evaluated. This is possible in a macro, but not a function.</p></li><li class="listitem"><p>Tag names and attribute names usually do not need to change in a dynamic way. Because of this, it’s redundant to need to prefix tag names with a single quote. In other words, tag names should by default be treated as if they were in data mode.</p></li><li class="listitem"><p>Unlike tag names, it’s very desirable for the values of attributes to be dynamically generated. Our macro will have a syntax that places the attribute values into code mode so we can execute Lisp code to populate these values.</p></li></ul></div><p>Ideally, this is how we would like the tag macro to work, when we use it in the REPL:<a id="IDX-CHP-17-0021" class="indexterm"/></p><a id="I_programlisting4_d1e30132"/><pre class="programlisting">&gt; <strong class="userinput"><code>(tag mytag (color 'blue height (+ 4 5)))</code></strong>
&lt;mytag color="BLUE" height="9"&gt;&lt;/mytag&gt;</pre><p>Notice that the tag name and attribute list no longer need quotes in front of them. Additionally, it is now easy to calculate an attribute dynamically with Lisp code. In this case, we’re calculating that the height is 4 plus 5.</p><p>Here’s the macro that accomplishes this task:</p><a id="I_programlisting4_d1e30141"/><pre class="programlisting">(defmacro tag (name atts &amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   `(progn (print-tag ',name
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                      (list ,@(mapcar (lambda (x)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                                        `(cons ',(car x) ,(cdr x)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                                      (pairs atts)))
                       nil)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>           ,@body
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>           (print-tag ',name nil t)))</pre><p>As you would expect, the macro first calls <code class="literal">print-tag</code> to generate the opening tag <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30185"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This is a bit tricky when we generate the alist of attributes for <code class="literal">print-tag</code>, since we want the values for the attributes to be in code mode. We accomplish this by wrapping the attributes using <code class="literal">list</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30197"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Then we <code class="literal">mapcar</code> through the attributes, which we’ve paired with the <code class="literal">pairs</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30210"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. (Remember that we created the <code class="literal">pairs</code> function toward the end of the previous chapter.) For each attribute pair, we generate a code fragment in the list that consists of cons, without a quotation mark in front of the value of the attribute, so that we can dynamically calculate it <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30219"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>Next, we put all the code nested inside our <code class="literal">tag</code> macro, so that it is called after the opening tag <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30230"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Finally we create a closing tag <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30236"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.<a id="IDX-CHP-17-0022" class="indexterm"/><a id="IDX-CHP-17-0023" class="indexterm"/></p><p>To make more sense of how this macro handles the attribute list, let’s pass the output from our example to <code class="literal">macroexpand</code>:</p><a id="I_programlisting4_d1e30258"/><pre class="programlisting">&gt; <strong class="userinput"><code>(macroexpand '(tag mytag (color 'blue height (+ 4 5))))</code></strong>
  (PROGN (PRINT-TAG 'MYTAG
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                   (LIST (CONS 'COLOR 'BLUE)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                         (CONS 'HEIGHT (+ 4 5)))
                    NIL)
          (PRINT-TAG 'MYTAG NIL T)) ;
  T</pre><p>Looking at the macro expansion, it should be clear how the <code class="literal">tag</code> macro builds the attribute list to pass to <code class="literal">print-tag</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30283"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and how it allows us to dynamically generate attribute values, such as the height attribute <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30289"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>Here is another example of this macro in use, now with two inner tags:</p><a id="I_programlisting4_d1e30297"/><pre class="programlisting">&gt; <strong class="userinput"><code>(tag mytag (color 'blue size 'big)</code></strong>
  <strong class="userinput"><code>       (tag first_inner_tag ())</code></strong>
  <strong class="userinput"><code>       (tag second_inner_tag ()))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &lt;mytag color="BLUE" size="BIG"&gt;
    &lt;first_inner_tag&gt;&lt;/first_inner_tag&gt;
    &lt;second_inner_tag&gt;&lt;/second_inner_tag&gt;
  &lt;/mytag&gt;</pre><p>Notice how it correctly surrounds the inner, nested tags with proper XML opening and closing tags. Note also that I have added line breaks and indentation to the output <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30316"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> for clarity. The actual output of the <code class="literal">tag</code> function always prints on a single line, without line breaks or indentation.</p></div><div class="sect3" title="Using the tag Macro to Generate HTML"><div class="titlepage"><div><div><h3 class="title"><a id="using_the_tag_macro_to_generate_html"/>Using the tag Macro to Generate HTML</h3></div></div></div><p>The <code class="literal">tag</code> macro can be used for generating XML <span class="emphasis"><em>or</em></span> HTML. For instance, we could do the following to generate a “Hello World” HTML document:</p><a id="I_programlisting4_d1e30336"/><pre class="programlisting">&gt; <strong class="userinput"><code>(tag html ()</code></strong>
<strong class="userinput"><code>       (tag body ()</code></strong>
<strong class="userinput"><code>            (princ "Hello World!")))</code></strong>
&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;</pre><p>Since HTML uses predefined tags (unlike XML, where the tags can have any name), we could write simple macros for specific HTML tags that make them even easier to write HTML in Lisp. For instance, here are some simple <code class="literal">html</code> and <code class="literal">body</code> macros:</p><a id="I_programlisting4_d1e30355"/><pre class="programlisting">(defmacro html (&amp;body body)
  `(tag html ()
        ,@body))
(defmacro body (&amp;body body)
  `(tag body ()
        ,@body))</pre><p>Now we could write our “Hello World” HTML example even more elegantly:<a id="IDX-CHP-17-0024" class="indexterm"/><a id="IDX-CHP-17-0025" class="indexterm"/><a id="IDX-CHP-17-0026" class="indexterm"/><a id="IDX-CHP-17-0027" class="indexterm"/><a id="IDX-CHP-17-0028" class="indexterm"/><a id="IDX-CHP-17-0029" class="indexterm"/><a id="IDX-CHP-17-0030" class="indexterm"/></p><a id="I_programlisting4_d1e30386"/><pre class="programlisting">&gt; <strong class="userinput"><code>(html</code></strong>
<strong class="userinput"><code>    (body</code></strong>
<strong class="userinput"><code>      (princ "Hello World!")))</code></strong>
&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;</pre><p>However, we want to use the <code class="literal">tag</code> macro to create SVG drawings instead. So let’s expand our DSL for the SVG domain.</p></div></div><div class="sect2" title="Creating SVG-Specific Macros and Functions"><div class="titlepage"><div><div><h2 class="title"><a id="creating_svg-specific_macros_and_functio"/>Creating SVG-Specific Macros and Functions</h2></div></div></div><p>First, let’s write the <code class="literal">svg</code> macro, which embodies an entire SVG image. Here it is:</p><a id="I_programlisting4_d1e30411"/><pre class="programlisting">(defmacro svg (&amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   `(tag svg (xmlns "http://www.w3.org/2000/svg"
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>              "xmlns:xlink" "http://www.w3.org/1999/xlink")
          ,@body))</pre><p>The <code class="literal">svg</code> macro is built on top of the <code class="literal">tag</code> macro. SVG images, for our purposes, require two special attributes to be created:<a id="IDX-CHP-17-0031" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">xmlns</code> attribute tells the SVG viewer (in our case, the Firefox web browser) where it can find the proper documentation for the SVG format <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30443"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p></li><li class="listitem"><p>The second attribute enables hyperlinks inside the picture <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30452"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. We’ll be using this hyperlinking feature in more advanced examples, starting in the next chapter.</p></li></ul></div><p>To draw pictures, we’ll need to manipulate colors. To keep things simple, we’re just going to represent colors as RGB triples stored in a list. For instance, the color <code class="literal">(255 0 0)</code> is bright red.</p><p>Often, it is useful to generate lighter or darker variants of a particular color. The following <code class="literal">brightness</code> function does this for us:</p><a id="I_programlisting4_d1e30468"/><pre class="programlisting">(defun brightness (col amt)
  (mapcar (lambda (x)
        (min 255 (max 0 (+ x amt))))
      col))</pre><p>If you pass bright red into this function and set the brightness to negative 100, you can see that it will generate a darker red:</p><a id="I_programlisting4_d1e30472"/><pre class="programlisting">&gt; <strong class="userinput"><code>(brightness '(255 0 0) −100)</code></strong>
(155 0 0)</pre><p>Next, let’s create a function that sets the style of an SVG picture element:<a id="IDX-CHP-17-0032" class="indexterm"/><a id="IDX-CHP-17-0033" class="indexterm"/><a id="IDX-CHP-17-0034" class="indexterm"/><a id="IDX-CHP-17-0035" class="indexterm"/></p><a id="I_programlisting4_d1e30494"/><pre class="programlisting">(defun svg-style (color)
    (format nil
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>           "˜{fill:rgb(˜a,˜a,˜a);stroke:rgb(˜a,˜a,˜a)˜}"
            (append color
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                   (brightness color −100))))</pre><p>The <code class="literal">svg-style</code> function accepts a color, and then sets the fill and stroke (outline) of a picture element <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30513"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. By using our brightness function, we can make the outline a darker variant of the fill <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30519"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This way, we need to specify only a single color for every element in our pictures, while maintaining a pleasing appearance.</p><p>Now, let’s create a function to draw a circle. Since we won’t need to nest other SVG tags inside a circle, there is no need to write a macro for drawing circles—a function suffices.<a id="IDX-CHP-17-0036" class="indexterm"/></p><a id="I_programlisting4_d1e30532"/><pre class="programlisting">(defun circle (center radius color)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (tag circle (cx (car center)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                cy (cdr center)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                r radius
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                style (svg-style color))))</pre><p>We’ll want to set the center, radius, and color of each circle. The center needs to be assigned to the <code class="literal">cx</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30563"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and <code class="literal">cy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30572"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> SVG attributes of the circle. The radius is put in the <code class="literal">r</code> attribute <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30582"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. We set the style of our circle with our <code class="literal">svg-style</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30591"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>We are now ready to draw the simple SVG picture of two circles shown earlier, using our new DSL! Here’s how we do it:</p><a id="I_programlisting4_d1e30599"/><pre class="programlisting">&gt; <strong class="userinput"><code>(svg (circle '(50 . 50) 50 '(255 0 0))</code></strong>
<strong class="userinput"><code>       (circle '(100 . 100) 50 '(0 0 255)))</code></strong>
&lt;svg  xmlns:xlink="http://www.w3.org/1999/
xlink"&gt;&lt;circle cx="50" cy="50" r="50"
style="fill:rgb(255,0,0);stroke:rgb(155,0,0)"&gt;&lt;/circle&gt;&lt;circle cx="100"
cy="100" r="50" style="fill:rgb(0,0,255);stroke:rgb(0,0,155)"&gt;&lt;/circle&gt;&lt;/svg&gt;</pre><p>We now have a functional SVG DSL. Let’s add some more functionality to our DSL so we can appreciate the power a DSL can give to our programs.</p></div><div class="sect2" title="Building a More Complicated SVG Example"><div class="titlepage"><div><div><h2 class="title"><a id="building_a_more_complicated_svg_example"/>Building a More Complicated SVG Example</h2></div></div></div><p>Let’s add a new function to our SVG DSL that makes it easy to draw an arbitrary polygon:</p><a id="I_programlisting4_d1e30614"/><pre class="programlisting">(defun polygon (points color)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (tag polygon (points (format nil
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                    "˜{˜a,˜a ˜}"
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                    (mapcan (lambda (tp)
                       (list (car tp) (cdr tp)))
                         points))
          style (svg-style color))))</pre><p>An SVG polygon stores all the points of the polygon in the <code class="literal">points</code> attribute <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30639"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. We construct the list of points by using a <code class="literal">format</code> statement, which contains the <code class="literal">˜{ ˜}</code> control strings <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30651"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Remember from <a class="xref" href="ch12.html" title="Chapter 11. Printing Text with the format Function">Chapter 11</a> that these control strings let us iterate through a list inside the <code class="literal">format</code> function. In this case, we’re iterating through the list of points. We then flatten the list of point pairs using <code class="literal">mapcan</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30666"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, which you may remember is the same as using a <code class="literal">mapcar</code> followed by an <code class="literal">append</code>.<a id="IDX-CHP-17-0037" class="indexterm"/><a id="IDX-CHP-17-0038" class="indexterm"/></p><p>In this example, we’re going to draw some random walks. A <span class="emphasis"><em>random walk</em></span> is a graph of what you would get if you decide, at each moment in time, to flip a coin and then move either up or down a step. Random walks are very similar in behavior to stocks in the stock market. They are often used as a starting point for financial modeling. Here is a function that generates a random walk:<a id="IDX-CHP-17-0039" class="indexterm"/></p><a id="I_programlisting4_d1e30693"/><pre class="programlisting">(defun random-walk (value length)
    (unless (zerop length)
      (cons value
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>           (random-walk (if (zerop (random 2))
                             (1- value)
                           (1+ value))
                         (1- length)))))</pre><p>This function builds a list of numbers, starting with the <code class="literal">value</code> parameter. Then it increases or decreases this value randomly. We choose which direction to move using the <code class="literal">random</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30709"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. (Note that, in order to keep it simple, this function isn’t tail call optimized, since the <code class="literal">cons</code> happens after the recursive call.)</p><p>Here’s an example of how we can use the <code class="literal">random-walk</code> function:</p><a id="I_programlisting4_d1e30723"/><pre class="programlisting">&gt; <strong class="userinput"><code>(random-walk 100 10)</code></strong>
(100 101 102 101 100 101 102 103 102 103)</pre><p>Now let’s use our SVG DSL to draw a slew of random walks in a picture:</p><a id="I_programlisting4_d1e30730"/><pre class="programlisting">(with-open-file (*standard-output* "random_walk.svg"
                   :direction :output
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                  :if-exists :supersede)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (svg (loop repeat 10
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>              do (polygon (append '((0 . 200))
                                   (loop for x
                                         for y in (random-walk 100 400)
                                         collect (cons x y))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                                  '((400 . 200)))
                            (loop repeat 3
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                                 collect (random 256))))))</pre><p>Since the amount of data created in this example is quite huge, we’re dumping the data straight to a file (named <span class="emphasis"><em>random_walk.svg</em></span>), instead of printing it to the REPL. We do this by redirecting the <code class="literal">*standard-output*</code> dynamic variable <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30771"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, a technique introduced in <a class="xref" href="ch13.html" title="Chapter 12. Working with Streams">Chapter 12</a>. Notice how we can mix Lisp code freely with our DSL commands. For instance, we can loop right inside the SVG macro to generate 10 polygons at once <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30779"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.<a id="IDX-CHP-17-0040" class="indexterm"/><a id="IDX-CHP-17-0041" class="indexterm"/></p><p>To make the graph pretty, we’re going to fill in the area under each graph line with a color. To do this, we’ll represent each line using a polygon, with the base line along the bottom of the graph (with a y-coordinate of 200) included as points to close the shape:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e30795"/><img src="httpatomoreillycomsourcenostarchimages781225.png" alt="image with no caption"/></div></div><p>This is why we add points for the bottom-left <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30802"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> and bottom-right <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30808"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> corner as we create each polygon. For even more fun, we also randomize the color of each graph line <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30814"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>Here is an example of some random graphs generated by this very simple DSL code:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e30823"/><img src="httpatomoreillycomsourcenostarchimages779828.png.jpg" alt="image with no caption"/></div></div><p>Now that you’ve seen how easily you can write XML, HTML, and SVG DSLs in Lisp, let’s create an entirely different kind of DSL—one that will let us build custom game commands for our Wizard’s Adventure Game from <a class="xref" href="ch05.html" title="Chapter 5. Building a Text Game Engine">Chapter 5</a> and <a class="xref" href="ch06.html" title="Chapter 6. Interacting with the World: Reading and Printing in Lisp">Chapter 6</a>!</p></div></div>
<div class="sect1" title="Creating Custom Game Commands for Wizard's Adventure Game"><div class="titlepage"><div><div><h1 class="title"><a id="creating_custom_game_commands_for_wizard"/>Creating Custom Game Commands for Wizard's Adventure Game</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e30838"/><img src="httpatomoreillycomsourcenostarchimages783098.png" alt="image with no caption"/></div></div><p>If you remember, when we last encountered the game starring our wizard and apprentice in <a class="xref" href="ch05.html" title="Chapter 5. Building a Text Game Engine">Chapter 5</a> and <a class="xref" href="ch06.html" title="Chapter 6. Interacting with the World: Reading and Printing in Lisp">Chapter 6</a>, we could walk around the world and pick up objects. However, we couldn’t really perform any other interesting or fun actions. To make a game fun, it should include special actions that can be performed with certain objects and/or at certain locations in the game. We need frogs that can be kissed, dragons that can be fought, and perhaps even maidens that can be rescued!<a id="IDX-CHP-17-0042" class="indexterm"/><a id="IDX-CHP-17-0043" class="indexterm"/><a id="IDX-CHP-17-0044" class="indexterm"/><a id="IDX-CHP-17-0045" class="indexterm"/></p><p>Creating these kinds of interesting activities in the game poses a unique challenge. On the one hand, there are clearly many similarities between such different game actions. For instance, most of them will require us to have an object in our possession. On the other hand, they all need to have <span class="emphasis"><em>unique and idiosyncratic properties</em></span> (enabled through command-specific Lisp code) or the game becomes boring. As you’ll see, a DSL can help you add many such unique commands to your game.</p><p>To run the code from here until the end of this chapter, we’re going to use all the game code from <a class="xref" href="ch05.html" title="Chapter 5. Building a Text Game Engine">Chapter 5</a> and <a class="xref" href="ch06.html" title="Chapter 6. Interacting with the World: Reading and Printing in Lisp">Chapter 6</a>. Just put the code from those chapters into a file named <span class="emphasis"><em>wizards_game.lisp</em></span> (or download <span class="emphasis"><em>wizards_game.lisp</em></span> from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>). As soon as the game is loaded, you can type game commands like look directly in the CLISP REPL. Alternatively, you can use the <code class="literal">game-repl</code> command we created in <a class="xref" href="ch06.html" title="Chapter 6. Interacting with the World: Reading and Printing in Lisp">Chapter 6</a> to get a more polished game experience. Remember that the <code class="literal">quit</code> command will take you out of the game REPL.</p><p>Here’s what you do to load the game code from the REPL and start running game commands:</p><a id="I_programlisting4_d1e30897"/><pre class="programlisting">&gt; <strong class="userinput"><code>(load "wizards_game.lisp")</code></strong>
;; Loading file wizards_game.lisp ...
;; Loaded file wizards_game.lisp
T
&gt; <strong class="userinput"><code>(look)</code></strong>
(YOU ARE IN THE ATTIC. THERE IS A GIANT WELDING TORCH IN THE CORNER. THERE IS
A LADDER GOING DOWNSTAIRS FROM HERE.)
&gt; <strong class="userinput"><code>(game-repl)</code></strong>
<strong class="userinput"><code>look</code></strong>
You are in the living-room. A wizard is snoring loudly on the couch. There is
a door going west from here. There is a ladder going upstairs
from here. You see a whiskey on the floor. You see a bucket on the floor.
<strong class="userinput"><code>quit</code></strong></pre><div class="sect2" title="Creating New Game Commands by Hand"><div class="titlepage"><div><div><h2 class="title"><a id="creating_new_game_commands_by_hand"/>Creating New Game Commands by Hand</h2></div></div></div><p>So what should our game DSL look like? The only way to really know is to first create some commands by hand. Then we can see if there are any common patterns between different commands that we can use as the basis of our DSL.<a id="IDX-CHP-17-0046" class="indexterm"/></p><div class="sect3" title="A Command for Welding"><div class="titlepage"><div><div><h3 class="title"><a id="a_command_for_welding"/>A Command for Welding</h3></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e30929"/><img src="httpatomoreillycomsourcenostarchimages781998.png.jpg" alt="image with no caption"/></div></div><p>In the attic of the wizard’s house is a welding machine. Let’s allow the players to weld the chain to the bucket if they bring those items to that location. Here’s the code to make this happen:<a id="IDX-CHP-17-0047" class="indexterm"/><a id="IDX-CHP-17-0048" class="indexterm"/></p><a id="I_programlisting4_d1e30942"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun have (object)
    (member object (inventory)))

<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defparameter *chain-welded* nil)

<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defun weld (subject object)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>   (if (and (eq *location* 'attic)
             (eq subject 'chain)
             (eq object 'bucket)
             (have 'chain)
             (have 'bucket)
             (not *chain-welded*))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>       (progn (setf *chain-welded* t)
               '(the chain is now securely welded to the bucket.))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>     '(you cannot weld like that.)))</pre><p>First, we need an easy way of checking whether the player is currently carrying an object, using the <code class="literal">have</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30984"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Remember that we created a command for checking what the player is carrying, named <code class="literal">inventory</code>. If an object is a member of the inventory, it means the player must “have” that object.</p><p>Next, our program needs some way of keeping track of whether or not the chain and bucket are welded together, since there will be actions later in the game that are possible only once this welding has happened. For this purpose, we create a global, dynamic variable named <code class="literal">*chain-welded*</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e30998"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>Finally, we need to create the welding command itself <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31006"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Welding is possible only if a slew of conditions are met <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31012"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You must be in the attic.</p></li><li class="listitem"><p>You must have <code class="literal">chain</code> and <code class="literal">bucket</code> as the subject and object of the welding command.</p></li><li class="listitem"><p>You must be carrying the chain and bucket with you.</p></li><li class="listitem"><p>The chain and bucket can’t already be welded together.</p></li></ul></div><p>If these conditions are met, we set our <code class="literal">*chain-welded*</code> variable to <code class="literal">true</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31045"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span> and print a message indicating this success. If any of the conditions fail, we indicate that the welding was unsuccessful <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31051"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>Let’s try the command in the CLISP REPL:</p><a id="I_programlisting4_d1e31059"/><pre class="programlisting">&gt; <strong class="userinput"><code>(weld 'chain 'bucket)</code></strong>
(YOU CANNOT WELD LIKE THAT.)</pre><p>Well, that’s exactly the right response. After all, we’re not in the attic, and we aren’t carrying the right objects. So far, so good.</p><p>Next, let’s try our new command in our fancy <code class="literal">game-repl</code>:<a id="IDX-CHP-17-0049" class="indexterm"/><a id="IDX-CHP-17-0050" class="indexterm"/><a id="IDX-CHP-17-0051" class="indexterm"/><a id="IDX-CHP-17-0052" class="indexterm"/><a id="IDX-CHP-17-0053" class="indexterm"/></p><a id="I_programlisting4_d1e31091"/><pre class="programlisting">&gt; <strong class="userinput"><code>(game-repl)</code></strong>
<strong class="userinput"><code>weld chain bucket</code></strong>
I do not know that command.
<strong class="userinput"><code>quit</code></strong></pre><p>What? Why doesn’t it “know” that command? The answer is simple: Our <code class="literal">game-re</code>pl has some basic protections against running unauthorized commands. To remedy this, we need to add <code class="literal">weld</code> to our list of permitted commands:</p><a id="I_programlisting4_d1e31109"/><pre class="programlisting">&gt; <strong class="userinput"><code>(pushnew 'weld *allowed-commands*)</code></strong>
(WELD LOOK WALK PICKUP INVENTORY)
&gt; <strong class="userinput"><code>(game-repl)</code></strong>
<strong class="userinput"><code>weld chain bucket</code></strong>
You cannot weld like that.</pre><p>By using the <code class="literal">pushnew</code> command, the <code class="literal">weld</code> function is added only to the allowed commands if it wasn’t already present in that list. Problem solved!</p></div><div class="sect3" title="A Command for Dunking"><div class="titlepage"><div><div><h3 class="title"><a id="a_command_for_dunking"/>A Command for Dunking</h3></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e31132"/><img src="httpatomoreillycomsourcenostarchimages780712.png.jpg" alt="image with no caption"/></div></div><p>In the wizard’s garden, there is a well. Let’s create a command that lets the player dunk the bucket in the well to fill it with water:</p><a id="I_programlisting4_d1e31139"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (setf *bucket-filled* nil)

<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defun dunk (subject object)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>   (if (and (eq *location* 'garden)
             (eq subject 'bucket)
             (eq object 'well)
             (have 'bucket)
             *chain-welded*)
        (progn (setf *bucket-filled* 't)
               '(the bucket is now full of water))
      '(you cannot dunk like that.)))

<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> (pushnew 'dunk *allowed-commands*)</pre><p>As with our <code class="literal">weld</code> command, we first need a variable to keep track of whether the bucket has been filled yet <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31169"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we need a <code class="literal">dunk</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31178"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Notice how, with dunking, we once again have a long list of conditions that need to be met before we can successfully complete the action <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31184"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Some of these are similar to those we needed for our welding command. For instance, dunking also requires the player to be in a specific location with the correct object. Other conditions are dunking-specific, such as the fact that the player needs to have a welded chain before being able to dunk. Finally, we need to push the <code class="literal">dunk</code> function onto our list of allowed actions <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31194"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.<a id="IDX-CHP-17-0054" class="indexterm"/><a id="IDX-CHP-17-0055" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e31211"/><img src="httpatomoreillycomsourcenostarchimages780228.png" alt="image with no caption"/></div></div></div><div class="sect3" title="The game-action Macro"><div class="titlepage"><div><div><h3 class="title"><a id="the_game-action_macro"/>The game-action Macro</h3></div></div></div><p>Now that we’ve created two custom game actions for our game, it’s obvious that the <code class="literal">weld</code> and <code class="literal">dunk</code> commands are very similar in some ways. However, as in our SVG library, each game command needs to contain a certain amount of dynamic logic in it, to customize the behavior of the command. Let’s write a <code class="literal">game-action</code> macro that addresses these issues. It will make it much easier to create new game commands.</p><a id="I_programlisting4_d1e31230"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmacro game-action (command subj obj place &amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   `(progn (defun ,command (subject object)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>             (if (and (eq *location* ',place)
                       (eq subject ',subj)
                       (eq object ',obj)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                      (have ',subj))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                 ,@body
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>             '(i cant ,command like that.)))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>           (pushnew ',command *allowed-commands*)))</pre><p>This <code class="literal">game-action</code> macro embodies the common pattern between our <code class="literal">dunk</code> and <code class="literal">weld</code> commands. The parameters to <code class="literal">game-action</code> are the name of the command, the two objects involved in the action, the place it needs to occur, and some arbitrary additional code in the <code class="literal">body</code> parameter that lets us add custom logic to the command <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31292"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.<a id="IDX-CHP-17-0056" class="indexterm"/><a id="IDX-CHP-17-0057" class="indexterm"/><a id="IDX-CHP-17-0058" class="indexterm"/><a id="IDX-CHP-17-0059" class="indexterm"/></p><p>The main job of the <code class="literal">game-action</code> macro is to define a new function for a command <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31319"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. It may be surprising to you that a macro can do something as powerful as define a new function on its own, but there is nothing to stop it from doing this. I hope this example shows you just how flexible and mind-bending the Common Lisp macro system can be.</p><p>Since all game actions for this game require the location, subject, and object, we can take care of some of the conditions directly within this macro <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31327"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. However, we’re going to leave other conditions open for each specific command. Notice, for example, that the subject of the game sentence needs to be owned by the player <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31333"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, but the object does not. This makes sense, since there are many actions that can be performed, such as “throw rock dragon,” where the object of the sentence (dragon) does <span class="emphasis"><em>not</em></span> need to be in the player’s inventory.</p><p>Once the basic macro-level conditions have been met, we will defer the rest of the logic to the level of the individual command <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31344"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. If the conditions were <span class="emphasis"><em>not</em></span> met, we print an error message, customized with the name of the current command <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31353"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Finally, we <code class="literal">pushnew</code> the command into the list of allowed commands for our fancy <code class="literal">game-repl</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e31366"/><img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/></span>.</p><p>One thing we do <span class="emphasis"><em>not</em></span> do in this macro is define or set any global variables. If a game command needs to define a <code class="literal">*chain-welded*</code> or <code class="literal">*bucket-filled*</code> global variable, it must do this itself. This makes sense, since there is clearly no guarantee that there will be a one-to-one relationship between state variables for our game and particular commands. For instance, some commands may be permitted multiple times, making the state unnecessary. Or an action may depend on multiple state variables. Having this kind of variation in the commands is what makes them unique and fun.</p><p>With this macro, we now have a simple DSL for creating new game actions! Essentially, this command gives us our own programming language, specialized for the domain of creating game commands. Let’s rewrite our previous <code class="literal">weld</code> and <code class="literal">dunk</code> commands using our new game command programming language:</p><a id="I_programlisting4_d1e31391"/><pre class="programlisting">(defparameter *chain-welded* nil)

(game-action weld chain bucket attic
             (if (and (have 'bucket) (not *chain-welded*))
                 (progn (setf *chain-welded* 't)
                        '(the chain is now securely welded to the bucket.))
               '(you do not have a bucket.)))

(setf *bucket-filled* nil)

(game-action dunk bucket well garden
             (if *chain-welded*
                 (progn (setf *bucket-filled* 't)
                        '(the bucket is now full of water))
               '(the water level is too low to reach.)))</pre><p>As you can see, these commands have become much easier on the eyes. Notice how <code class="literal">weld</code> checks for ownership of the bucket, whereas <code class="literal">dunk</code> does not need to check for ownership of the well.<a id="IDX-CHP-17-0060" class="indexterm"/><a id="IDX-CHP-17-0061" class="indexterm"/><a id="IDX-CHP-17-0062" class="indexterm"/></p><p>To further illustrate the value of using macros to implement our game command DSL, let’s implement a more complicated game command, <code class="literal">splash</code>:</p><a id="I_programlisting4_d1e31418"/><pre class="programlisting">(game-action splash bucket wizard living-room
   (cond ((not *bucket-filled*) '(the bucket has nothing in it.))
         ((have 'frog) '(the wizard awakens and sees that you stole his frog.
                         he is so upset he banishes you to the
                         netherworlds- you lose! the end.))
         (t '(the wizard awakens from his slumber and greets you warmly.
              he hands you the magic low-carb donut- you win! the end.))))</pre><p>For this command, there are three distinct scenarios that might happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The bucket is empty.</p></li><li class="listitem"><p>Your bucket is full, but you stole the frog. In that case, you lose.</p></li><li class="listitem"><p>Your bucket is full and you didn’t steal the frog. You win!</p></li></ul></div><p>With our <code class="literal">game-action</code> macro, we can support many action commands, each with special idiosyncratic behavior. Still, we are able to avoid unnecessary repetition.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">game-action</code> command exposes the <code class="literal">subject</code> and <code class="literal">object</code> variables within the body of the macro. This allows game commands to access this information, but it might also cause a name collision if the code that creates the <code class="literal">game-action</code> commands also has variables named <code class="literal">subject</code> and <code class="literal">object</code>. As an exercise, try modifying the <code class="literal">game-action</code> macro so that the <code class="literal">subject</code> and <code class="literal">object</code> variables are replaced by <code class="literal">gensym</code> names, as discussed in <a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a>.</p></div></div></div><div class="sect2" title="Let's Try the Completed Wizard's Adventure Game!"><div class="titlepage"><div><div><h2 class="title"><a id="let_apostrophy_s_try_the_completed_wizar"/>Let's Try the Completed Wizard's Adventure Game!</h2></div></div></div><p>Here is a sample run through of the Wizard’s Adventure Game that shows off some of the rich functionality we’ve put into this game. Play the game yourself and see if you can win the magic donut!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e31479"/><img src="httpatomoreillycomsourcenostarchimages780868.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting4_d1e31484"/><pre class="programlisting">&gt; <strong class="userinput"><code>(game-repl)</code></strong>
<strong class="userinput"><code>look</code></strong>
You are in the living-room. There is a wizard  snoring loudly on the couch.
There is a door going west from here. There is a ladder going upstairs from
here. You see a whiskey on the floor. You see a bucket on the floor.
<strong class="userinput"><code>pickup bucket</code></strong>
You are now carrying the bucket
<strong class="userinput"><code>pickup whiskey</code></strong>
You are now carrying the whiskey
<strong class="userinput"><code>inventory</code></strong>
Items- whiskey bucket
<strong class="userinput"><code>walk upstairs</code></strong>
You are in the attic. There is a giant welding torch in the corner. There is a
ladder going downstairs from here.
<strong class="userinput"><code>walk east</code></strong>
You cannot go that way.
<strong class="userinput"><code>walk downstairs</code></strong>
You are in the living-room. A wizard is snoring loudly on the couch. There is
a door going west from here. There is a ladder going upstairs from here.
<strong class="userinput"><code>walk west</code></strong>
You are in a beautiful garden. There is a well in front of you. There is a
door going east from here. You see a frog on the floor. You see
a chain on the floor.
<strong class="userinput"><code>dunk bucket well</code></strong>
The water level is too low to reach.
<strong class="userinput"><code>pickup chain</code></strong>
You are now carrying the chain
<strong class="userinput"><code>walk east</code></strong>
You are in the living-room. A wizard is snoring loudly on the couch. There is
a door going west from here. There is a ladder going upstairs
from here.
<strong class="userinput"><code>splash bucket wizard</code></strong>
The bucket has nothing in it.</pre></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id17"/>What You've Learned</h1></div></div></div><p>This chapter demonstrated how to create DSLs in Lisp. You learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When you need to do some weird programming for a very specific domain, Macros are a great solution. With them, you can create your own DSL.</p></li><li class="listitem"><p>Often, it makes sense to first write a helper function for a macro (like <code class="literal">print-tag</code>), and then write a macro (like <code class="literal">tag</code>) to add improvements that only a macro can provide. These improvements usually involve being able to access the code with a clearer, and often safer, syntax.</p></li><li class="listitem"><p>You can mix DSLs with regular Lisp code, which gives you a lot of power.</p></li><li class="listitem"><p>DSLs are useful when you need to write very specific code—whether it’s code for a web page, code that draws a picture, or code that builds special game commands.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;18.&#xA0;Lazy Programming"><div class="titlepage"><div><div><h1 class="title"><a id="lazy_programming"/>Chapter 18. Lazy Programming</h1></div></div></div><p>In <a class="xref" href="ch16.html" title="Chapter 14. Ramping Lisp Up a Notch with Functional Programming">Chapter 14</a>, you learned that your programs can be simpler and cleaner when built with clean, math-like functions. These functions always return the same result, which depends solely on the arguments passed into them. When you rely only on these types of functions, you are using the <span class="emphasis"><em>functional programming style</em></span>.<a id="IDX-CHP-18-0001" class="indexterm"/></p><p>However, when we used the functional programming style to create the Dice of Doom game in <a class="xref" href="ch17.html" title="Chapter 15. Dice of Doom, a Game Written in the Functional Style">Chapter 15</a>, a problem became evident: If your functions rely entirely on the arguments passed into them, the stuff that you need to pass into them often becomes <span class="emphasis"><em>huge</em></span>.</p><p>In the Dice of Doom game, we pass around the <code class="literal">game-tree</code> variable, which holds all the possible future states of the game board. This is a truly massive structure, even on a measly 3-by-3 board! So while the game’s current design makes our code very simple and elegant, it doesn’t appear to scale well to larger game boards, which would have exponentially larger game trees. The only way we could conceivably maintain our elegant code while allowing more complex games on larger boards is to make our program smart enough not to look at every conceivable move right from the start of the game. Is this possible? Yes, it is possible, using a feature called <span class="emphasis"><em>lazy evaluation</em></span>. In this chapter, we’ll employ lazy evaluation to create an improved version of Dice of Doom.<a id="IDX-CHP-18-0002" class="indexterm"/><a id="IDX-CHP-18-0003" class="indexterm"/><a id="IDX-CHP-18-0004" class="indexterm"/></p><div class="sect1" title="Adding Lazy Evaluation to Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="adding_lazy_evaluation_to_lisp"/>Adding Lazy Evaluation to Lisp</h1></div></div></div><p>With lazy evaluation, we can still create our entire game tree in a single place in our code—at the beginning of our game. However, we use some clever tricks so that some branches of our game tree are hidden in clouds:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e31598"/><img src="httpatomoreillycomsourcenostarchimages782958.png.jpg" alt="image with no caption"/></div></div><p>The branches of the game tree are still declared right from the start. However, we don’t bother doing all the actual calculations for the branches in clouds, as we would do when we create a “real” branch. This is the <span class="emphasis"><em>lazy</em></span> part of lazy evaluation.<a id="IDX-CHP-18-0005" class="indexterm"/><a id="IDX-CHP-18-0006" class="indexterm"/></p><p>Instead, we wait to see if anyone “looks” at a cloudy branch. The moment this happens, POOF!, we create a real branch of our game tree at that spot:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e31621"/><img src="httpatomoreillycomsourcenostarchimages781540.png" alt="image with no caption"/></div></div><p>This means that these branches in the game tree are created only if some part of the code happens to look at them. If the player never chooses a particular move in the game, and the AI never decides to contemplate it, our program will lazily avoid the calculations needed to figure out what the given branch actually looks like.</p><p>Some languages, such as Haskell and Clojure Lisp, contain support for lazy evaluation as part of the core of the language. In fact, Clojure encourages its use and clearly demonstrates how useful it is for functional programming. However, the ANSI Common Lisp standard does not contain any similar feature for such lazy evaluation. Fortunately, with Common Lisp’s powerful macro system, we can easily add this feature to the language ourselves!</p><div class="sect2" title="Creating the lazy and force Commands"><div class="titlepage"><div><div><h2 class="title"><a id="creating_the_lazy_and_force_commands"/>Creating the lazy and force Commands</h2></div></div></div><p>The most basic commands for lazy evaluation we’re going to create are <code class="literal">lazy</code> and <code class="literal">force</code>. The <code class="literal">lazy</code> command will be a wrapper you can put around a piece of code, telling Lisp that you would like the code to be evaluated in a lazy way, like this:<a id="IDX-CHP-18-0007" class="indexterm"/><a id="IDX-CHP-18-0008" class="indexterm"/></p><a id="I_programlisting5_d1e31650"/><pre class="programlisting">&gt; <strong class="userinput"><code>(lazy (+ 1 2))</code></strong>
#&lt;FUNCTION ...&gt;</pre><p>As you can see, the computer <span class="emphasis"><em>does not</em></span> try to calculate the value of 1 plus 2. Instead, it simply returns a function. To get the actual result of the calculation, we must call our other basic lazy evaluation command on a lazy value:</p><a id="I_programlisting5_d1e31660"/><pre class="programlisting">&gt; <strong class="userinput"><code>(force (lazy (+ 1 2)))</code></strong>
3</pre><p>The important thing is that the calculation was performed, but not when the lazy value was created—only when it was forced. To see that this is the case, let’s look at a more complex example:</p><a id="I_programlisting5_d1e31667"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(defun add (a b)</code></strong>
  <strong class="userinput"><code>     (princ "I am adding now")</code></strong>
  <strong class="userinput"><code>     (+ a b))</code></strong>
  ADD
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(defparameter *foo* (lazy (add 1 2)))</code></strong>
  *FOO*
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> &gt; <strong class="userinput"><code>(force *foo*)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> I am adding now
  3</pre><p>Here, we’ve created our own <code class="literal">add</code> function, which, as a side effect, prints a message to the console showing when the addition is happening <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31713"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we lazily add two numbers with our function and store the result in the variable <code class="literal">*foo*</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31722"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. So far, we know the addition hasn’t actually happened, since the message “I am adding now” has not yet appeared.</p><p>Then we <code class="literal">force</code> our variable <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31733"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. By forcing the value, the calculation is actually performed, and the result of <code class="literal">3</code> is returned. You can see that the addition took place when we forced the lazy value, since our message was also printed in the console <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31742"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Here is the code for a simple implementation of <code class="literal">lazy</code>:<a id="IDX-CHP-18-0009" class="indexterm"/><a id="IDX-CHP-18-0010" class="indexterm"/></p><a id="I_programlisting5_d1e31761"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmacro lazy (&amp;body body)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (let ((forced (gensym))
          (value (gensym)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     `(let ((,forced nil)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>        (,value nil))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>        (lambda ()
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>          (unless ,forced
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>            (setf ,value (progn ,@body))
<img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/>            (setf ,forced t))
<img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/>          ,value))))</pre><p>We implement <code class="literal">lazy</code> by declaring a macro <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31823"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This macro will require two variables in the code it generates. We need to declare these as <code class="literal">gensym</code> names <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31832"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, as discussed in <a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a>. Next, we begin generating the code that the macro will output <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31841"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> (note the backquote at the beginning of this line).</p><p>At the top of the code generated by the macro is a declaration for two local variables, using the <code class="literal">gensym</code> names we created <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31852"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. The first variable tells us whether this lazy value has been forced yet <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31858"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If it is <code class="literal">nil</code>, the value can hide in a cloud. If the variable is true, the value is no longer hidden in a cloud, because it has been forced.</p><p>Once the value has been calculated through a call to <code class="literal">force</code>, we store the resulting value in another variable, though initially this value isn’t used and is set to <code class="literal">nil</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31875"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. When our <code class="literal">lazy</code> macro is called, we want it to return a function, which can be called at a later time to force our lazy value to return a result. Therefore, we declare a lambda function next <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31884"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>Remember that any local variables declared outside this lambda function will be captured by the function as a closure. This means that the local variables above <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31892"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31897"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> will persist between subsequent calls of the lambda function. Why does this matter? Well, once the cloud goes POOF!, we have completed all the work to calculate a value, and we don’t want to do it again when the lazy value is forced and checked again multiple times in the future. We can avoid this by remembering the value after the first <code class="literal">force</code> here <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31906"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> between calls.</p><p>When our lazy value is forced (by calling the lambda function we created), the first question we must ask ourselves is whether it has been forced already or is still hidden behind the cloud <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31914"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. For a value that has not yet been forced, we go POOF! and perform the lazy calculation <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31920"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>, and save it as our <code class="literal">value</code>. We also mark it as having been <code class="literal">forced</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31932"/><img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/></span>. Now the cloud has been destroyed.</p><p>Once the cloud is gone, we can simply return our calculated value <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e31940"/><img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/></span>. This may have been just calculated, or it may already exist from a previous call to <code class="literal">force</code>.<a id="IDX-CHP-18-0011" class="indexterm"/><a id="IDX-CHP-18-0012" class="indexterm"/><a id="IDX-CHP-18-0013" class="indexterm"/><a id="IDX-CHP-18-0014" class="indexterm"/></p><p>Unlike the (admittedly mind-bending) code for the <code class="literal">lazy</code> macro, the <code class="literal">force</code> function is super-simple. All it does is call the lambda function created by <code class="literal">lazy</code>:</p><a id="I_programlisting5_d1e31972"/><pre class="programlisting">(defun force (lazy-value)
  (funcall lazy-value))</pre><p>We now have a fully functional set of primitive lazy evaluation commands. Many different types of sophisticated tools could be built on top of these simple <code class="literal">lazy</code> and <code class="literal">force</code> commands.</p></div><div class="sect2" title="Creating a Lazy Lists Library"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_lazy_lists_library"/>Creating a Lazy Lists Library</h2></div></div></div><p>We will now employ our new commands to build a library for <span class="emphasis"><em>lazy lists</em></span>, based loosely on their implementation in Clojure. (In Clojure, lazy lists are referred to as <span class="emphasis"><em>lazy sequences</em></span>.)<a id="IDX-CHP-18-0015" class="indexterm"/><a id="IDX-CHP-18-0016" class="indexterm"/></p><p>Since the fundamental command for working with Lisp lists is the <code class="literal">cons</code> command, you shouldn’t be surprised that the first command we create for working with lazy lists is the <code class="literal">lazy-cons</code> command:</p><a id="I_programlisting5_d1e32011"/><pre class="programlisting">(defmacro lazy-cons (a d)
  `(lazy (cons ,a ,d)))</pre><p>This macro emulates the behavior of <code class="literal">cons</code>, except that the result is wrapped in the <code class="literal">lazy</code> macro. To accompany <code class="literal">lazy-cons</code>, we’ll also create <code class="literal">lazy-car</code> and <code class="literal">lazy-cdr</code> commands:</p><a id="I_programlisting5_d1e32030"/><pre class="programlisting">(defun lazy-car (x)
  (car (force x)))

(defun lazy-cdr (x)
  (cdr (force x)))</pre><p>All these functions do is force the lazy value and then call <code class="literal">car</code> and <code class="literal">cdr</code>, respectively. Let’s try using these new commands:</p><a id="I_programlisting5_d1e32040"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(defparameter *foo* (lazy-cons 4 7))</code></strong>
  *FOO*
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(lazy-car *foo*)</code></strong>
  4
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> &gt; <strong class="userinput"><code>(lazy-cdr *foo*)</code></strong>
  7</pre><p>As you can see, we can use <code class="literal">lazy-cons</code> exactly as we would use <code class="literal">cons</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32076"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then we can take apart a lazy cons in the same way we would take apart a cons <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32082"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32087"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>So far, it looks like our lazy list functions aren’t any different from the standard <code class="literal">cons</code>, <code class="literal">car</code>, and <code class="literal">cdr</code> functions. However, we can actually use them to perform some pretty amazing feats. Consider, for instance, the following definition:<a id="IDX-CHP-18-0017" class="indexterm"/><a id="IDX-CHP-18-0018" class="indexterm"/><a id="IDX-CHP-18-0019" class="indexterm"/><a id="IDX-CHP-18-0020" class="indexterm"/></p><a id="I_programlisting5_d1e32118"/><pre class="programlisting">(defparameter *integers*
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((f (n)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>              (lazy-cons n (f (1+ n)))))
        (f 1)))</pre><p>Here, we’ve used the <code class="literal">lazy-cons</code> command to declare something impossible: a variable that holds a list of all positive integers! We do this by creating a local function <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32141"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which we then call recursively to build an infinite chain of <code class="literal">lazy-cons</code>es, using an ever-increasing number <code class="literal">n</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32154"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Once we’ve declared this seemingly impossible <code class="literal">*integers*</code> variable, we can use it just as you might expect:</p><a id="I_programlisting5_d1e32163"/><pre class="programlisting">&gt; <strong class="userinput"><code>(lazy-car *integers*)</code></strong>
1
&gt; <strong class="userinput"><code>(lazy-car (lazy-cdr *integers*))</code></strong>
2
&gt; <strong class="userinput"><code>(lazy-car (lazy-cdr (lazy-cdr *integers*)))</code></strong>
3</pre><p>As long as we stick to using only our <code class="literal">lazy-</code> commands, we can pull whatever we want out of our infinite list of integers, forcing more and more numbers from <code class="literal">*integers*</code> on an as-needed basis.</p><p>Since not all lists are infinite (as is the list of positive integers), we’ll also need to have a concept of a <code class="literal">lazy-nil</code> to terminate a list. Similarly, we need a <code class="literal">lazy-null</code> function that we can use to check if we’ve reached the end of a list, just as the <code class="literal">null</code> function can be used to check for the end of a regular list.</p><a id="I_programlisting5_d1e32193"/><pre class="programlisting">(defun lazy-nil ()
  (lazy nil))

(defun lazy-null (x)
  (not (force x)))</pre><p>Now that we have all the basic building blocks for working with lazy lists, let’s create some useful functions for our library.</p></div><div class="sect2" title="Converting Between Regular Lists and Lazy Lists"><div class="titlepage"><div><div><h2 class="title"><a id="converting_between_regular_lists_and_laz"/>Converting Between Regular Lists and Lazy Lists</h2></div></div></div><p>One obvious thing we would want to be able to do is convert a regular list into a lazy list. The <code class="literal">make-lazy</code> function allows us to do this:</p><a id="I_programlisting5_d1e32205"/><pre class="programlisting">(defun make-lazy (lst)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (lazy (when lst
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>           (cons (car lst) (make-lazy (cdr lst))))))</pre><p>As the <code class="literal">make-lazy</code> function clearly shows, writing lazy list library functions is sort of like writing zen koans. The only way to understand them is to stare at them for a long time. The English language doesn’t have appropriate words for clearly explaining functions like <code class="literal">make-lazy</code>.<a id="IDX-CHP-18-0021" class="indexterm"/><a id="IDX-CHP-18-0022" class="indexterm"/><a id="IDX-CHP-18-0023" class="indexterm"/></p><p>In broad terms, <code class="literal">make-lazy</code> uses recursion to travel across the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32243"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and then wraps each cons in a call to the <code class="literal">lazy</code> macro <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32252"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. However, to get the full meaning of this function (and the other remaining functions in our lazy library), you’ll just have to try to think carefully about what <code class="literal">lazy</code> and <code class="literal">force</code> really mean, and meditate a bit over each function. Luckily, once our little lazy list library is complete, it will hide most of the strangeness of lazy evaluation.</p><p>Just as we wrote the <code class="literal">make-lazy</code> function to convert regular lists to lazy lists, we can create some functions to do the reverse—convert lazy lists into regular ones. The <code class="literal">take</code> and <code class="literal">take-all</code> functions allow us to do this.</p><a id="I_programlisting5_d1e32276"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun take (n lst)
    (unless (or (zerop n) (lazy-null lst))
      (cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))

<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defun take-all (lst)
    (unless (lazy-null lst)
      (cons (lazy-car lst) (take-all (lazy-cdr lst)))))</pre><p>The reason we want two different commands for going from lazy to regular lists is that, unlike regular lists, lazy lists can be infinite. Therefore, it is useful to have an additional command that lets us take just a specified number of items from the list. The <code class="literal">take</code> function accepts an extra argument <code class="literal">n</code> that indicates just how many values we want to take <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32297"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If we just want all values, we can call the <code class="literal">take-all</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32306"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Of course, this function cannot be used on infinite lists—taking all items from an infinite list would lead to an infinite loop.</p><p>Let’s try out our new lazy list conversion functions:</p><a id="I_programlisting5_d1e32314"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(take 10 *integers*)</code></strong>
  (1 2 3 4 5 6 7 8 9 10)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(take 10 (make-lazy '(q w e r t y u i o p a s d f)))</code></strong>
  (Q W E R T Y U I O P)
  &gt; <strong class="userinput"><code>(take-all (make-lazy '(q w e r t y u i o p a s d f)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (Q W E R T Y U I O P A S D F)</pre><p>As you would expect, if we take the first 10 integers off the list of all positive integers, we just get the numbers 1 through 10 as a result <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32344"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The <code class="literal">take</code> function can also be used on a finite list we’ve created by calling <code class="literal">make-lazy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32356"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. However, if a list is finite, we can use the simpler <code class="literal">take-all</code> function and just get a regular list of all items in the lazy list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32366"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p></div><div class="sect2" title="Mapping and Searching Across Lazy Lists"><div class="titlepage"><div><div><h2 class="title"><a id="mapping_and_searching_across_lazy_lists"/>Mapping and Searching Across Lazy Lists</h2></div></div></div><p>We also want to be able to map and search across lazy lists. Here are some functions to allow that:<a id="IDX-CHP-18-0024" class="indexterm"/><a id="IDX-CHP-18-0025" class="indexterm"/><a id="IDX-CHP-18-0026" class="indexterm"/><a id="IDX-CHP-18-0027" class="indexterm"/><a id="IDX-CHP-18-0028" class="indexterm"/><a id="IDX-CHP-18-0029" class="indexterm"/><a id="IDX-CHP-18-0030" class="indexterm"/><a id="IDX-CHP-18-0031" class="indexterm"/></p><a id="I_programlisting5_d1e32406"/><pre class="programlisting">(defun lazy-mapcar (fun lst)
  (lazy (unless (lazy-null lst)
          (cons (funcall fun (lazy-car lst))
                (lazy-mapcar fun (lazy-cdr lst))))))

(defun lazy-mapcan (fun lst)
  (labels ((f (lst-cur)
          (if (lazy-null lst-cur)
                  (force (lazy-mapcan fun (lazy-cdr lst)))
                (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))
    (lazy (unless (lazy-null lst)
        (f (funcall fun (lazy-car lst)))))))

(defun lazy-find-if (fun lst)
  (unless (lazy-null lst)
    (let ((x (lazy-car lst)))
      (if (funcall fun x)
          x
        (lazy-find-if fun (lazy-cdr lst))))))

(defun lazy-nth (n lst)
  (if (zerop n)
      (lazy-car lst)
    (lazy-nth (1- n) (lazy-cdr lst))))</pre><p>These functions are analogous to the functions <code class="literal">mapcar</code>, <code class="literal">mapcan</code>, <code class="literal">find-if</code>, and <code class="literal">nth</code>. The only difference is that they accept and return lazy lists. This means that instead of using <code class="literal">null</code>, <code class="literal">car</code>, and <code class="literal">cdr</code>, they use the lazy versions of these functions (<code class="literal">lazy-null</code>, <code class="literal">lazy-car</code>, and <code class="literal">lazy-cdr</code>) that we just created.</p><p>Using these functions is pretty straightforward:</p><a id="I_programlisting5_d1e32443"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(take 10 (lazy-mapcar #'sqrt *integers*))</code></strong>
  (1 1.4142135 1.7320508 2 2.236068 2.4494898
   2.6457512 2.828427 3 3.1622777)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(take 10 (lazy-mapcan (lambda (x)</code></strong>
  <strong class="userinput"><code>                          (if (evenp x)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> <strong class="userinput"><code>                              (make-lazy (list x))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> <strong class="userinput"><code>                            (lazy-nil)))</code></strong>
  <strong class="userinput"><code>                        *integers*))</code></strong>
  (2 4 6 8 10 12 14 16 18 20)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/> &gt; <strong class="userinput"><code>(lazy-find-if #'oddp (make-lazy '(2 4 6 7 8 10)))</code></strong>
  7
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/> &gt; <strong class="userinput"><code>(lazy-nth 4 (make-lazy '(a b c d e f g)))</code></strong>
  E</pre><p>Calling <code class="literal">lazy-mapcar</code> to map the square root function across the positive integers gives us a lazy list of the square roots of the positive integers. The first 10 are shown <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32511"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we call <code class="literal">lazy-mapcan</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32520"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> and check if each positive integer is even. If it is, we return a lazy list of the numbers <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32526"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If it isn’t, we return the lazy empty list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32533"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. The result is that we’ve filtered out all the even numbers from our lazy list of integers. We can use <code class="literal">lazy-find-if</code> to find the first odd number in a lazy list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32542"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. In this case, the number was 7. Finally, we can use <code class="literal">lazy-nth</code> to pick a number out of a specific location in a lazy list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32551"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.<a id="IDX-CHP-18-0032" class="indexterm"/><a id="IDX-CHP-18-0033" class="indexterm"/><a id="IDX-CHP-18-0034" class="indexterm"/><a id="IDX-CHP-18-0035" class="indexterm"/></p><p>We have now written an entire, if rather simple, lazy list library. Place all the functions we’ve written so far in this chapter in a file named <span class="emphasis"><em>lazy.lisp</em></span> (or simply download that file from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>).</p><p>Now, you’re going to see that lazy lists allow us to greatly boost the power of our Dice of Doom game engine!</p></div></div></div>
<div class="sect1" title="Dice of Doom, Version 2"><div class="titlepage"><div><div><h1 class="title"><a id="dice_of_doom_comma_version_2"/>Dice of Doom, Version 2</h1></div></div></div><p>In <a class="xref" href="ch17.html" title="Chapter 15. Dice of Doom, a Game Written in the Functional Style">Chapter 15</a>, we created the first version of our Dice of Doom game. We are now going to modify some of the functions from that version. To proceed, place the code from that chapter into a file named <span class="emphasis"><em>dice_of_doom_v1.lisp</em></span> so that we can reference it in this new version (or just download that file from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>).</p><p>To use our previous Dice of Doom and our new lazy list library, run the following in the REPL:</p><a id="I_programlisting5_d1e32601"/><pre class="programlisting">&gt; <strong class="userinput"><code>(load "dice_of_doom_v1.lisp")</code></strong>
&gt; <strong class="userinput"><code>(load "lazy.lisp")</code></strong></pre><p>Next, we’re going to increase the size of our board to a more roomy 4-by-4:</p><a id="I_programlisting5_d1e32610"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *board-size* 4)</code></strong>
&gt; <strong class="userinput"><code>(defparameter *board-hexnum* (* *board-size* *board-size*))</code></strong></pre><p>To allow the game to run at a reasonable speed at this larger size, we’ll make the list of moves at each branch of our game tree a lazy list, instead of just a regular list. By simply converting this one structure in our game from a regular list to a lazy list, the entire game tree will become lazy as a result. To accomplish this, we now need to redefine some of the functions from the first version of our game to use our new lazy list functions.</p><p>First, let’s make some small modifications to the functions that calculate the attacking and passing moves possible from a given board position:</p><a id="I_programlisting5_d1e32621"/><pre class="programlisting">(defun add-passing-move (board player spare-dice first-move moves)
    (if first-move
        moves
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (lazy-cons (list nil
                         (game-tree (add-new-dice board player
                                                  (1- spare-dice))
                                    (mod (1+ player) *num-players*)
                                    0
                                    t))
                   moves)))

  (defun attacking-moves (board cur-player spare-dice)
    (labels ((player (pos)
          (car (aref board pos)))
       (dice (pos)
           (cadr (aref board pos))))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (lazy-mapcan
       (lambda (src)
         (if (eq (player src) cur-player)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>            (lazy-mapcan
              (lambda (dst)
                (if (and (not (eq (player dst)
                                  cur-player))
                         (&gt; (dice src) (dice dst)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                   (make-lazy
                     (list (list (list src dst)
                                 (game-tree (board-attack board
                                                          cur-player
                                                          src
                                                          dst
                                                          (dice src))
                                            cur-player
                                            (+ spare-dice (dice dst))
                                            nil))))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                 (lazy-nil)))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>             (make-lazy (neighbors src)))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>          (lazy-nil)))
<img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/>      (make-lazy (loop for n below *board-hexnum*
                        collect n)))))</pre><p>As you can see, the <code class="literal">add-passing-move</code> function needs only one small change. Since the list of moves is now a lazy list, we use <code class="literal">lazy-cons</code> to add a passing move to the top of the list of possible moves <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32680"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.<a id="IDX-CHP-18-0036" class="indexterm"/><a id="IDX-CHP-18-0037" class="indexterm"/><a id="IDX-CHP-18-0038" class="indexterm"/><a id="IDX-CHP-18-0039" class="indexterm"/></p><p>The <code class="literal">attacking-moves</code> function requires a few more changes. First, since it now needs to return a lazy list, we use <code class="literal">lazy-mapcan</code> in lieu of <code class="literal">mapcan</code> in two places as the moves are calculated <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32709"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32714"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. The <code class="literal">lazy-mapcan</code> function also requires the lists created inside it to be lazy, which we accomplish with the <code class="literal">make-lazy</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32727"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32732"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Also, any place we returned <code class="literal">nil</code> we now instead return a <code class="literal">lazy-nil</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32744"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32749"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. Finally, we also make the list of calculated board positions lazy <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32756"/><img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/></span>, since it is fed into the outer <code class="literal">lazy-mapcan</code>.</p><p>Next, let’s make similar changes to two of the functions that deal with human players:</p><a id="I_programlisting5_d1e32768"/><pre class="programlisting">(defun handle-human (tree)
    (fresh-line)
    (princ "choose your move:")
    (let ((moves (caddr tree)))
      (labels ((print-moves (moves n)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                     (unless (lazy-null moves)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                       (let* ((move (lazy-car moves))
                           (action (car move)))
                          (fresh-line)
                          (format t "˜a. " n)
                          (if action
                            (format t "˜a -&gt; ˜a" (car action) (cadr action))
                           (princ "end turn")))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                       (print-moves (lazy-cdr moves) (1+ n)))))
            (print-moves moves 1))
      (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>     (cadr (lazy-nth (1- (read)) moves))))

  (defun play-vs-human (tree)
    (print-info tree)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>   (if (not (lazy-null (caddr tree)))
        (play-vs-human (handle-human tree))
      (announce-winner (cadr tree))))</pre><p>In the <code class="literal">handle-human</code> function, we have a local function <code class="literal">print-moves</code>, which is a list-eater function across the list of moves. We modify it to use our lazy commands when checking for the end of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32808"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, taking a move off the front of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32814"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and recursing across the tail of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32820"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Finally, we modify <code class="literal">handle-human</code> to use <code class="literal">lazy-nth</code> to pick a move after the human chooses it from the list of options <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32833"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.<a id="IDX-CHP-18-0040" class="indexterm"/><a id="IDX-CHP-18-0041" class="indexterm"/></p><p>In the <code class="literal">play-vs-human</code> function, we make just a single pinpoint change. In order to determine whether we’ve reached the end of a game, we need to check whether the list of subsequent possible moves is empty, and then announce the winner. We simply use <code class="literal">lazy-null</code> to check if the lazy list of moves is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32857"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>With these simple changes in place, you can play Dice of Doom against another human on much larger board sizes, since no move in the tree is realized unless one of the players decides to make it. On our larger, 4-by-4 board, enter the following to start a game (just as for version 1 of our game):</p><a id="I_programlisting5_d1e32865"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-human (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
        a-1 a-3 a-1 b-2
      b-3 a-3 a-3 a-1
    a-3 a-3 b-1 a-2
  b-3 a-3 a-1 a-3
choose your move:
1. 5 -&gt; 10
2. 6 -&gt; 10
3. 9 -&gt; 10
4. 11 -&gt; 10
5. 15 -&gt; 10</pre><p>Version 1 would screech to a halt the moment this command was executed. This is because it would need to generate the entirety of the game tree, <span class="emphasis"><em>for every possible move of the whole game</em></span>, before the game would even start playing.</p><p>With our lazy version of Dice of Doom, the game starts instantly!</p></div>
<div class="sect1" title="Making Our AI Work on Larger Game Boards"><div class="titlepage"><div><div><h1 class="title"><a id="making_our_ai_work_on_larger_game_boards"/>Making Our AI Work on Larger Game Boards</h1></div></div></div><p>Next, we’re going to adjust our game AI functions to use the new lazy list library when processing moves. Along the way, we will make some additional improvements to the AI code.<a id="IDX-CHP-18-0042" class="indexterm"/><a id="IDX-CHP-18-0043" class="indexterm"/><a id="IDX-CHP-18-0044" class="indexterm"/><a id="IDX-CHP-18-0045" class="indexterm"/><a id="IDX-CHP-18-0046" class="indexterm"/></p><div class="sect2" title="Trimming the Game Tree"><div class="titlepage"><div><div><h2 class="title"><a id="trimming_the_game_tree"/>Trimming the Game Tree</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e32905"/><img src="httpatomoreillycomsourcenostarchimages779954.png.jpg" alt="image with no caption"/></div></div><p>In version 1 of Dice of Doom, our AI code was, in certain ways, extremely powerful. This is because, at every decision point, the AI player would look at <span class="emphasis"><em>every possible future board position</em></span> to choose the absolute best next move. In this way, it could play a perfect game of Dice of Doom, winning every game that was winnable.</p><p>However, such a design does not scale to larger boards. This is because it becomes impossible to contemplate every single possible future move once there are too many. In fact, the whole point of our new lazy game tree is to avoid contemplating every possible move. Therefore, we need a way to tell the computer, “Consider only this many moves, and no more.” In other words, we want to be able tell it to look only two, three, or four moves ahead, and then stop looking any further.</p><p>The functional programming style of Dice of Doom allows us to do this in a very elegant but nonobvious way.</p><p>The <span class="emphasis"><em>obvious</em></span> solution to the problem would be to modify the <code class="literal">get-ratings</code> and <code class="literal">rate-position</code> from version 1 to have a new argument called <code class="literal">search-depth</code>. Then we could ask ourselves at every call of those functions, “Have we reached the maximum search depth we want?”</p><p>The problem with this approach is that it gunks up those functions with extra, confusing code. In fact, the way we evaluate board positions is theoretically a separate issue from how deep we wish to search. As programmers like to say, these issues are <span class="emphasis"><em>orthogonal</em></span>, and it would be best if we could write separate functions to deal with each of these issues independently.</p><p>In fact, with our new lazy game tree, it is possible to write a separate function that is solely responsible for “trimming” the search tree and is completely independent from the main AI code that contemplates and rates possible moves.<a id="IDX-CHP-18-0047" class="indexterm"/></p><p>Here is the function that trims our tree:<a id="IDX-CHP-18-0048" class="indexterm"/><a id="IDX-CHP-18-0049" class="indexterm"/></p><a id="I_programlisting5_d1e32953"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun limit-tree-depth (tree depth)
    (list (car tree)
      (cadr tree)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (if (zerop depth)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>         (lazy-nil)
        (lazy-mapcar (lambda (move)
                         (list (car move)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                              (limit-tree-depth (cadr move) (1- depth))))
                 (caddr tree)))))</pre><p>This is a pretty simple function that takes just two arguments: a lazy tree and the depth to which we wish to trim it <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32980"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. As a result, it just outputs a new game tree, calling itself recursively, decrementing the depth for each level it travels into the tree <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32986"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Once this depth reaches zero <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32992"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, we know we’re at the level that we want to trim, and we set the lazy list of moves to the empty list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32998"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>Now all we need to do is call our new <code class="literal">limit-tree-depth</code> function before doing our AI rating calculations. We do this by tweaking our <code class="literal">handle-computer</code> function a bit:</p><a id="I_programlisting5_d1e33013"/><pre class="programlisting">(defparameter *ai-level* 4)

  (defun handle-computer (tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*)
                                (car tree))))
      (cadr (lazy-nth (position (apply #'max ratings) ratings)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                     (caddr tree)))))</pre><p>Before calling <code class="literal">get-ratings</code> to get a rating for every next available move, we transform our game tree into our trimmed game tree <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33032"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. All of our AI code can now run on the trimmed tree, completely oblivious to the fact that a larger game tree exists or that there are deeper moves it isn’t including in its calculations. With this technique, we have managed to decouple the code that limits the AI search depth from the algorithm that actually evaluates board positions. One other small modification is to use <code class="literal">lazy-nth</code> when picking a move out of the lazy list of moves <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33041"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">limit-tree-depth</code> function uses a pretty crude method for trimming our tree: It simply trims all tree branches beyond a certain depth. For most board games, doing this is an optimal way of trimming the game tree. However, Dice of Doom has the uncommon property that multiple moves in a row are allowed for each player. It would probably be more optimal if <code class="literal">limit-tree-depth</code> took into account how many times we’ve switched players as a criterion for trimming a branch. But our simpler version works well enough.</p></div><p>At this point, we should also make a pinpoint change to <code class="literal">play-vs-computer</code>:<a id="IDX-CHP-18-0050" class="indexterm"/><a id="IDX-CHP-18-0051" class="indexterm"/><a id="IDX-CHP-18-0052" class="indexterm"/><a id="IDX-CHP-18-0053" class="indexterm"/></p><a id="I_programlisting5_d1e33081"/><pre class="programlisting">(defun play-vs-computer (tree)
    (print-info tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (cond ((lazy-null (caddr tree)) (announce-winner (cadr tree)))
          ((zerop (car tree)) (play-vs-computer (handle-human tree)))
          (t (play-vs-computer (handle-computer tree)))))</pre><p>Here, we just added a <code class="literal">lazy-null</code> to check for the end of the lazy list of moves in a single spot <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33094"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>Now let’s look at another trick that will improve the power of our AI code.</p></div><div class="sect2" title="Applying Heuristics"><div class="titlepage"><div><div><h2 class="title"><a id="applying_heuristics"/>Applying Heuristics</h2></div></div></div><p>By trimming our game tree, we’ve fundamentally changed our AI player. Without trimming, the AI player was able to play a perfect game at all times. By trimming the tree, however, it is possible for the AI to “miss something,” since it is no longer contemplating every possible future move. In version 2 of Dice of Doom, the computer player will no longer be able to play a perfect game—just a “pretty good” game is possible.</p><p>Basically, we’ve exchanged the AI’s ability to play a perfect game for much better performance. In the process, we’ve turned the AI code from something precise that can be analyzed by mathematics into something that is “squishier” and far less precise. As computer scientists would say, we have now entered into the realm of <span class="emphasis"><em>heuristics</em></span>.<a id="IDX-CHP-18-0054" class="indexterm"/></p><p>In computer science, heuristics are programming techniques that are imperfect, but allow us to get good results very quickly. Broadly speaking, any technique that is fast but not guaranteed to work 100 percent of the time is a heuristic. When we write code that uses heuristics (as our Dice of Doom AI engine now does), it is often worthwhile to use some creative thinking and to “play around” with the code in different ways.<a id="IDX-CHP-18-0055" class="indexterm"/></p><p>Basically, since we’re already given up on our goal of a perfect solution and are now using imprecise techniques, it’s possible that tweaking the knobs on the heuristic code in different ways could dramatically improve our results. And indeed, it turns out that there is a simple change we can make to our Dice of Doom AI heuristics that will significantly improve the AI player’s game.</p></div><div class="sect2" title="Winning by a Lot vs. Winning by a Little"><div class="titlepage"><div><div><h2 class="title"><a id="winning_by_a_lot_vs._winning_by_a_little"/>Winning by a Lot vs. Winning by a Little</h2></div></div></div><p>In version 1 of our Dice of Doom code, the AI player had no reason to ever worry about its margin of victory. All it cared about was that when the game ended, it had ownership of at least one more territory of the board than its opponent, which meant it had won.</p><p>However, now that we’re using imprecise heuristics in our AI code, it matters <span class="emphasis"><em>a lot</em></span> how large the lead is at any point in the game. A heuristic rule for this situation is “If I am totally whomping my opponent in the game, it is pretty unlikely he/she will be able to recover, even if I look only a few moves ahead.”<a id="IDX-CHP-18-0056" class="indexterm"/><a id="IDX-CHP-18-0057" class="indexterm"/><a id="IDX-CHP-18-0058" class="indexterm"/></p><p>Remember that a minimax algorithm (as we’re using in our AI) assigns a point score to every final leaf branch in the tree. In version 1 of our game, this score was either 0 or 1, or sometimes 1/2 when the game ended in a tie. In version 2, these are not truly “final leaves” in the tree, but simply leaves in our much smaller trimmed tree. In this situation, it would be much better if our leaf point scores had a larger range of values, so that we can tell which moves lead to a game we’re winning by “a lot” and which moves lead to a game we’re winning by only “a little.”</p><p>Let’s write a <code class="literal">score-board</code> function that uses some more complex heuristics to score the board position at a leaf:</p><a id="I_programlisting5_d1e33152"/><pre class="programlisting">(defun score-board (board player)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (loop for hex across board
          for pos from 0
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>         sum (if (eq (car hex) player)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                 (if (threatened pos board)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                     1
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                   2)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>               −1)))</pre><p>The <code class="literal">score-board</code> function loops <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33196"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> across all of the hexes of the board and builds a running total of points for each hex using the <code class="literal">sum</code> directive of the loop macro. If the player we’re scoring owns the current hex <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33205"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, we want to add positive points to the total <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33211"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33216"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.</p><p>To decide exactly how many points to add to the total for an occupied hex, we make another heuristic observation: Hexes that neighbor a stronger opponent aren’t quite as valuable as hexes without strong neighbors. We’ll call a hex that neighbors an enemy hex that has more dice on it a <span class="emphasis"><em>threatened hex</em></span>. For hexes that are threatened <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33227"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, we’ll add only 1 point to the point total <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33233"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. For hexes that are unthreatened, we’ll add 2 points <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33239"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Finally, for each hex owned by an opposing player, we’ll subtract 1 point from the total <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33245"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>Again, the important thing to realize is that <code class="literal">score-board</code> is a heuristic function, and there is no truly right or wrong way to generate such a score. Instead of adding 2 points for unthreatened hexes, we could just as easily have added 1.5 points. In developing this example, I ran some simulations playing various opponents using different versions of the <code class="literal">score-board</code> function, and this version ended up working reasonably well. Developing heuristics is not an exact science.</p><p>Here is the function that determines whether a given hex is threatened:<a id="IDX-CHP-18-0059" class="indexterm"/><a id="IDX-CHP-18-0060" class="indexterm"/><a id="IDX-CHP-18-0061" class="indexterm"/></p><a id="I_programlisting5_d1e33270"/><pre class="programlisting">(defun threatened (pos board)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let* ((hex (aref board pos))
           (player (car hex))
           (dice (cadr hex)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (loop for n in (neighbors pos)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>           do (let* ((nhex (aref board n))
                      (nplayer (car nhex))
                      (ndice (cadr nhex)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                (when (and (not (eq player nplayer)) (&gt; ndice dice))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                  (return t))))))</pre><p>First, we get the hex in question and figure out who the occupying player is, and how many dice that player has <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33305"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then we loop through all the neighboring squares for the current position <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33311"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. After that, we find out the player and dice count for each of the neighbors <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33317"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. As soon as we find a neighboring hex owned by an opponent with a larger dice count (a threatening neighbor) <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33323"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, we can return true <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33329"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Calling <code class="literal">return</code> in this way causes the loop to stop early with true as a result.</p><p>Now that we have completed our <code class="literal">score-board</code> and <code class="literal">threatened</code> functions, we’re ready to write our improved <code class="literal">get-ratings</code> and <code class="literal">rate-position</code> functions:</p><a id="I_programlisting5_d1e33353"/><pre class="programlisting">(defun get-ratings (tree player)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (take-all (lazy-mapcar (lambda (move)
                             (rate-position (cadr move) player))
                           (caddr tree))))

  (defun rate-position (tree player)
    (let ((moves (caddr tree)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (if (not (lazy-null moves))
      (apply (if (eq (car tree) player)
             #'max
           #'min)
             (get-ratings tree player))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       (score-board (cadr tree) player))))</pre><p>As you can see, we’ve updated a couple lines of code <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33375"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33380"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> to be compatible with our new lazy game tree. Notice that any game positions that lack follow-up moves (that is, leaves) now cause our new score-board function to be called <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33386"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>Now that we have a fully working heuristic AI player that can play on larger game boards, let’s try it out. As usual, all moves for player B in the following example are being automatically calculated by the AI algorithm:</p><a id="I_programlisting5_d1e33394"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-computer (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
        a-1 b-2 b-1 a-3
      b-3 a-1 a-3 a-3
    b-3 b-2 b-2 b-2
  a-3 a-3 a-2 a-2
choose your move:
1. 3 -&gt; 2
2. 6 -&gt; 2
3. 6 -&gt; 10
4. 6 -&gt; 1
5. 6 -&gt; 11
6. 7 -&gt; 11
7. 7 -&gt; 2
8. 13 -&gt; 9
<strong class="userinput"><code>3</code></strong>
current player = a
        a-1 b-2 b-1 a-3
      b-3 a-1 a-1 a-3
    b-3 b-2 a-2 b-2
  a-3 a-3 a-2 a-2
choose your move:
1. end turn
2. 3 -&gt; 2
3. 7 -&gt; 11
4. 7 -&gt; 2
5. 13 -&gt; 9
<strong class="userinput"><code>1</code></strong>
current player = b
        a-2 b-2 b-1 a-3
      b-3 a-1 a-1 a-3
    b-3 b-2 a-2 b-2
  a-3 a-3 a-2 a-2
current player = b
        a-2 b-1 b-1 a-3
      b-3 b-1 a-1 a-3
    b-3 b-2 a-2 b-2
  a-3 a-3 a-2 a-2
current player = b
        b-2 b-1 b-1 a-3
      b-1 b-1 a-1 a-3
    b-3 b-2 a-2 b-2
  a-3 a-3 a-2 a-2
current player = b
        b-2 b-1 b-1 a-3
      b-1 b-1 b-1 a-3
    b-3 b-2 a-2 b-1
  a-3 a-3 a-2 a-2
current player = a
        b-3 b-2 b-2 a-3
      b-1 b-1 b-1 a-3
    b-3 b-2 a-2 b-1
  a-3 a-3 a-2 a-2
choose your move:
1. 3 -&gt; 2
2. 7 -&gt; 11
3. 7 -&gt; 2
4. 7 -&gt; 6
5. 10 -&gt; 6
6. 10 -&gt; 5
7. 10 -&gt; 11
8. 13 -&gt; 9
9. 15 -&gt; 11
...</pre><p>With these changes in place, the AI player will win around 65 to 70 percent of all games (depending on the board size and AI level) when pitted against a player that chooses only random moves. This is actually a very good result. Our simple <code class="literal">gen-board</code> function often creates very lopsided starting positions, so many of the remaining 30 percent of the games are simply unwinnable for the computer.<a id="IDX-CHP-18-0062" class="indexterm"/><a id="IDX-CHP-18-0063" class="indexterm"/></p></div><div class="sect2" title="Alpha Beta Pruning"><div class="titlepage"><div><div><h2 class="title"><a id="alpha_beta_pruning"/>Alpha Beta Pruning</h2></div></div></div><p>Let’s add one final improvement to version 2 of our Dice of Doom AI.</p><p><span class="emphasis"><em>Alpha-beta pruning</em></span> is a well-known optimization of the minimax algorithm that improves performance by skipping over some branches (<span class="emphasis"><em>pruning</em></span> those branches) if it is certain that they will not impact the final minimax evaluation.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e33433"/><img src="httpatomoreillycomsourcenostarchimages780064.png.jpg" alt="image with no caption"/></div></div><p>When would a branch in the game tree be unable to impact the final result? In order to understand how alpha-beta pruning works, look at the following picture, showing the game tree for a simple 2-by-2 board:<a id="IDX-CHP-18-0064" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e33444"/><img src="httpatomoreillycomsourcenostarchimages783278.png.jpg" alt="image with no caption"/></div></div><p>At the top of this picture is the starting position of the game. The arrows point to possible moves. Above each board it states which player (A or B) currently is making a move.</p><p>The picture also shows the results of a minimax analysis of the game tree. On the bottom right of each board, you can see a number showing how our latest <code class="literal">get-ratings</code> function (with the new <code class="literal">score-board</code> logic) would rate that position. For leaf nodes (the boards along the very bottom), this number is calculated through <code class="literal">score-board</code>. For branch nodes, the number is calculated based on the minimax algorithm.</p><p>Every position in the game tree that allows a choice of moves is marked either as a MAX node or MIN node. Since the analysis in the picture is based on finding the best move for player A, all places allowing choices for player A are marked as MAX. All positions allowing choices for player B are marked as MIN. As you can see from the picture, this game is pretty unexciting, and there is only one position where player B actually has a choice of moves. In other words, only one MIN node exists in the game tree.</p><p>Working left to right, the minimax algorithm travels, depth first, exploring all the way down to the leaves. This is called a <span class="emphasis"><em>depth-first search</em></span>. (We’re assuming no trimming is occurring, with <code class="literal">*ai-level*</code> set very high.) Then it chooses either the maximum or minimum scores for any nodes that have more than one branch.<a id="IDX-CHP-18-0065" class="indexterm"/></p><p>When it does this, the first (left) branch of the MIN node in the picture ends up with a score of 8. If the AI engine now dips into the right branch, it really only cares what it finds there as long as the score remains below 8. After all, the minimum of 8 and any larger number larger than 8 will still be 8, making such large numbers irrelevant to the eventual outcome of the calculation.<a id="IDX-CHP-18-0066" class="indexterm"/><a id="IDX-CHP-18-0067" class="indexterm"/><a id="IDX-CHP-18-0068" class="indexterm"/><a id="IDX-CHP-18-0069" class="indexterm"/></p><p>As soon as the AI finds a node in the right branch that has a score of 8 (marked with a star in the picture), it knows the rest of the right branch is irrelevant and can be pruned away from our calculations. This means the minimax algorithm has no need to look at the branch in the tree marked with the dotted line in the picture.</p><p>This is a simple example, showing alpha-beta pruning in action. In the game tree shown in the picture, this pruning leads to only modest savings, since just a small number of the total nodes can be pruned. However, with larger game trees, the savings from alpha-beta pruning are typically immense, constituting a majority of the nodes in the game tree.</p><p>We’re going to take some liberties in how we implement alpha-beta pruning in our game to keep things simple. First, an alpha-beta pruning algorithm usually will pass around two variables called, naturally, <code class="literal">alpha</code> and <code class="literal">beta</code>.</p><p>This is because it’s possible to write code that handles both the MAX nodes and MIN nodes at once by switching <code class="literal">alpha</code> and <code class="literal">beta</code> between the high and low limits. In our example, we’re going to use the variables <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code> instead, indicating the highest and lowest values we care about as we traverse the game tree. As a cost, there will be some repetitive-looking code for handling the MAX and MIN cases. However, thinking of alpha-beta pruning in terms of <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code> makes the code a bit easier to understand.</p><p>Another compromise we’re making is that we’re not decoupling the pruning code from the minimax code. Remember that with the trimming code, we wrote an independent function named <code class="literal">limit-tree-depth</code>, which separated the act of trimming from the rest of the AI code. We could use a similar approach for separating the alpha-beta pruning code as well, creating a function that can transform the game tree into a pruned version on its own. However, doing this is a bit more involved, because the alpha-beta pruning code must have access to intermediate minimax calculations. For a more advanced AI engine, this would be a good idea. For our simple engine, we will just add our alpha-beta pruning check directly inside our minimax functions.</p><p>So let’s get started. First, we’ll rewrite our <code class="literal">get-ratings</code> function as two new functions: <code class="literal">ab-get-ratings-max</code> and <code class="literal">ab-get-ratings-min</code>.</p><p>Remember that the <code class="literal">get-ratings</code> function was responsible for calculating the best score out of multiple available moves from a single-board arrangement. Now, however, we want it to stop early in its evaluation of moves once it decides it has found a move that’s “as good as is possible.” Determining whether it has reached this point is subtly different depending on whether the node in question is a MAX move (a move of the current player) or a MIN move (a move for the opponent).</p><p>Let’s look at the version responsible for MAX nodes first:</p><a id="I_programlisting5_d1e33548"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun ab-get-ratings-max (tree player upper-limit lower-limit)
    (labels ((f (moves lower-limit)
             (unless (lazy-null moves)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>              (let ((x (ab-rate-position (cadr (lazy-car moves))
                                          player
                                          upper-limit
                                          lower-limit)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                (if (&gt;= x upper-limit)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                    (list x)
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                  (cons x (f (lazy-cdr moves) (max x lower-limit))))))))
      (f (caddr tree) lower-limit)))</pre><p>We’re now passing in an extra <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code> argument into <code class="literal">ab-get-ratings-max</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33590"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This function won’t actually ever check the <code class="literal">lower-limit</code> argument directly, since it is concerned only with finding the maximum rating possible from the given location in the tree. However, it will pass this value on to child branches, which may contain MIN nodes that <span class="emphasis"><em>do</em></span> care about the lower limit.</p><p>When we rate the next branch of the tree <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33605"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> (by calling <code class="literal">ab-rate-position</code>, which we’ll write shortly), we save the result as <code class="literal">x</code>. If <code class="literal">x</code> is greater than or equal to our <code class="literal">upper-limit</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33624"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, we know we got a result as good as we can hope for, and can just return the latest rating as a final value in our list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33630"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>If <code class="literal">x</code> isn’t large enough, we need to keep looking at the remaining branches <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33642"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Note that <code class="literal">x</code> will become the new <code class="literal">lower-limit</code> if it’s larger than the previous <code class="literal">lower-limit</code>.</p><p>Next, let’s look at the <code class="literal">ab-get-ratings-min</code> function:</p><a id="I_programlisting5_d1e33662"/><pre class="programlisting">(defun ab-get-ratings-min (tree player upper-limit lower-limit)
  (labels ((f (moves upper-limit)
           (unless (lazy-null moves)
             (let ((x (ab-rate-position (cadr (lazy-car moves))
                                        player
                                        upper-limit
                                        lower-limit)))
               (if (&lt;= x lower-limit)
                   (list x)
                 (cons x (f (lazy-cdr moves) (min x upper-limit))))))))
    (f (caddr tree) upper-limit)))</pre><p>The <code class="literal">ab-get-ratings-min</code> function is basically identical to the <code class="literal">ab-get-ratings-max</code> function, except the roles of the upper and lower limits are flipped. Based on the repetitiveness of these two functions, you could probably imagine how the <code class="literal">ab-get-ratings-max</code> and <code class="literal">ab-get-ratings-min</code> functions could be combined into a single function. As mentioned earlier, with that approach, rather than <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code>, you would use the more generic terms <code class="literal">alpha</code> and <code class="literal">beta</code>, as these will differ based on whether the node is a MAX node or a MIN node.<a id="IDX-CHP-18-0070" class="indexterm"/><a id="IDX-CHP-18-0071" class="indexterm"/><a id="IDX-CHP-18-0072" class="indexterm"/><a id="IDX-CHP-18-0073" class="indexterm"/></p><p>Next, we need to tweak <code class="literal">rate-position</code>, the function that rates a single-board arrangement:</p><a id="I_programlisting5_d1e33710"/><pre class="programlisting">(defun ab-rate-position (tree player upper-limit lower-limit)
    (let ((moves (caddr tree)))
      (if (not (lazy-null moves))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (if (eq (car tree) player)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>           (apply #'max (ab-get-ratings-max tree
                                             player
                                             upper-limit
                                             lower-limit))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>           (apply #'min (ab-get-ratings-min tree
                                             player
                                             upper-limit
                                             lower-limit)))
        (score-board (cadr tree) player))))</pre><p>In our new <code class="literal">ab-rate-position</code>, we check if this node in the game tree is a move for us or a move for an opponent <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33735"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If it’s a move for us, then it’s a MAX node, and we want to dispatch to <code class="literal">ab-get-ratings-max</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33744"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. If it’s the opponent’s turn, we instead dispatch to <code class="literal">ab-get-ratings-min</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33754"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Otherwise, <code class="literal">ab-rate-positon</code> is the same as our previous <code class="literal">rate-position</code> function.</p><p>To complete our support for alpha-beta pruning, we need to modify one more function: the <code class="literal">handle-computer</code> function that kicks off our minimax calculations:</p><a id="I_programlisting5_d1e33771"/><pre class="programlisting">(defun handle-computer (tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((ratings (ab-get-ratings-max (limit-tree-depth tree *ai-level*)
                                       (car tree)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                                      most-positive-fixnum
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                                      most-negative-fixnum)))
      (cadr (lazy-nth (position (apply #'max ratings) ratings) (caddr tree)))))</pre><p>This function starts off the minimax calculation by calling <code class="literal">ab-get-ratings-max</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33796"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, since the first move most definitely belongs to the target player and therefore is a MAX node.</p><p>When we call this function, we’ll need to pass in our starting <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code>. Since we’re at the very beginning of our minimax searching, we’ll want to set these to be as large and as small as possible. Ideally, we would want them to be <span class="emphasis"><em>positive infinity</em></span> and <span class="emphasis"><em>negative infinity</em></span>. Although many Lisp environments contain support for such concepts, they are not part of the ANSI Common Lisp standard. However, the standard does define <code class="literal">most-positive-fixnum</code> and <code class="literal">most-negative-fixnum</code>, which are very large positive and negative numbers, making them perfectly suited for our purposes. Hence, we pass these into <code class="literal">ab-get-ratings-max</code> to start off our limits <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33826"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span><span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e33831"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.<a id="IDX-CHP-18-0074" class="indexterm"/><a id="IDX-CHP-18-0075" class="indexterm"/><a id="IDX-CHP-18-0076" class="indexterm"/><a id="IDX-CHP-18-0077" class="indexterm"/></p><p>If we wanted to squeeze out a tad more efficiency from our AI engine, we could, instead, set the <code class="literal">upper-limit</code> and <code class="literal">lower-limit</code> to be the maximum and minimum values from our <code class="literal">score-board</code> function. That would slightly improve the amount of pruning that is possible. However, the <code class="literal">score-board</code> function may return a different range of scores based on the size of the board. and it might have other dependencies if we decide to optimize board scoring even more in the future. Therefore, it is best for the time being if we set our limits to nigh infinity for the start of our minimax calculations so we don’t need to worry about this.<a id="IDX-CHP-18-0078" class="indexterm"/></p><p>As a final reward for once again improving the performance of our AI, let’s increase the size of the board to use a 5-by-5 game field. With our new lazy, trimmed, and pruned AI algorithms, we should be able to handle this larger board without a sweat:<a id="IDX-CHP-18-0079" class="indexterm"/><a id="IDX-CHP-18-0080" class="indexterm"/></p><a id="I_programlisting5_d1e33883"/><pre class="programlisting">(defparameter *board-size* 5)
(defparameter *board-hexnum* (* *board-size* *board-size*))</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember that we used memoization for some of our earlier functions. If you have already played some games in this chapter on a 4-by-4 board, one function in particular, the <code class="literal">neighbors</code> function, may return results based on this old board size. This is only an issue if you’ve already played a game on the 4-by-4 board without restarting your Lisp in the interim. To fix this, simply rerun the definition of the <code class="literal">neighbors</code> function in <code class="literal">dice_of_doom_v1.lisp</code> from the REPL (including the memoized revision at the bottom of the file) to clear any cached results.</p></div><p>Here’s what our game looks like now:</p><a id="I_programlisting5_d1e33899"/><pre class="programlisting">&gt; <strong class="userinput"><code>(play-vs-computer (game-tree (gen-board) 0 0 t))</code></strong>
current player = a
          a-2 b-2 a-1 b-2 b-2
        a-1 b-2 b-3 b-3 a-3
      a-1 b-2 a-3 b-1 b-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
choose your move:
1. 9 -&gt; 13
2. 9 -&gt; 4
3. 9 -&gt; 14
4. 12 -&gt; 13
5. 17 -&gt; 22
6. 23 -&gt; 18
7. 23 -&gt; 22
<strong class="userinput"><code>3</code></strong>
current player = a
          a-2 b-2 a-1 b-2 b-2
        a-1 b-2 b-3 b-3 a-1
      a-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
choose your move:
1. end turn
2. 12 -&gt; 13
3. 14 -&gt; 13
4. 14 -&gt; 15
5. 17 -&gt; 22
6. 23 -&gt; 18
7. 23 -&gt; 22
<strong class="userinput"><code>1</code></strong>
current player = b
          a-3 b-2 a-1 b-2 b-2
        a-1 b-2 b-3 b-3 a-1
      a-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 a-1 b-2 b-2
        b-1 b-2 b-3 b-3 a-1
      a-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 b-1 b-1 b-2
        b-1 b-2 b-3 b-3 a-1
      a-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 b-1 b-1 b-1
        b-1 b-2 b-3 b-3 b-1
      a-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 b-1 b-1 b-1
        b-1 b-1 b-3 b-3 b-1
      b-1 b-2 a-3 b-1 a-2
    b-1 b-3 a-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 b-1 b-1 b-1
        b-1 b-1 b-3 b-3 b-1
      b-1 b-2 a-3 b-1 a-2
    b-1 b-1 b-2 b-2 a-1
  b-3 b-1 b-1 a-3 b-3
current player = b
          a-3 b-1 b-1 b-1 b-1
        b-1 b-1 b-3 b-3 b-1
      b-1 b-2 a-3 b-1 a-2
    b-1 b-1 b-2 b-2 b-2
  b-3 b-1 b-1 a-3 b-1
current player = a
          a-3 b-2 b-2 b-2 b-2
        b-2 b-2 b-3 b-3 b-1
      b-1 b-2 a-3 b-1 a-2
    b-1 b-1 b-2 b-2 b-2
  b-3 b-1 b-1 a-3 b-1
choose your move:
1. 0 -&gt; 4
2. 0 -&gt; 1
3. 0 -&gt; 5
4. 12 -&gt; 13
5. 14 -&gt; 10
6. 14 -&gt; 9
7. 14 -&gt; 13
8. 14 -&gt; 15
9. 23 -&gt; 18
10. 23 -&gt; 17
11. 23 -&gt; 22
12. 23 -&gt; 24</pre><p>At this point, our REPL game interface is becoming really impractical for such a large game field. We’ll be addressing that next.</p></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id18"/>What You've Learned</h1></div></div></div><p>In this chapter, we made the computer player for our Dice of Doom game much more sophisticated. We implementing the game tree using lazy lists, and applied several optimization techniques to limit the number of board positions that are searched by the AI engine. Along the way, you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Lazy programming</em></span> allows you to work with very large (and even infinite) data structures and do so efficiently.</p></li><li class="listitem"><p>Once you have a <code class="literal">lazy</code> macro and a <code class="literal">force</code> function, you can use them to build more sophisticated lazy operations, including building a lazy list library.</p></li><li class="listitem"><p>Heuristics are imperfect algorithms that can be used to improve the performance of your code, with some creative thinking. In our example, we made some heuristic changes to how we score leaf nodes.</p></li><li class="listitem"><p>Once we converted Dice of Doom to use a lazy tree, we were able to elegantly trim the game tree in order to limit how deep the AI thinks when contemplating its moves.</p></li><li class="listitem"><p>Alpha-beta pruning lets us improve performance even more, by pruning branches that have no way of impacting the final scores on the moves being considered by the AI.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;19.&#xA0;Creating a Graphical, Web-Based Version of Dice of Doom"><div class="titlepage"><div><div><h1 class="title"><a id="creating_a_graphical_comma_web-based_ver"/>Chapter 19. Creating a Graphical, Web-Based Version of Dice of Doom</h1></div></div></div><p>In the previous chapter, we created a second version of Dice of Doom to play on larger game boards. It has become quite difficult to understand the board and make moves using our crude console interface. Certainly, Dice of Doom would be infinitely better if we had a pretty graphical game board that allowed us to simply click where we wanted to make our moves. Well, I have good news for you . . .<a id="IDX-CHP-19-0001" class="indexterm"/></p><p>In this chapter, we’ll put together a lot of code from earlier chapters to transform Dice of Doom into a full-featured, graphical game you can play right inside a web browser!</p><div class="sect1" title="Drawing the Game Board Using the SVG Format"><div class="titlepage"><div><div><h1 class="title"><a id="drawing_the_game_board_using_the_svg_for"/>Drawing the Game Board Using the SVG Format</h1></div></div></div><p>We’ve already written a primitive web server in <a class="xref" href="ch14.html" title="Chapter 13. Let's Create a Web Server!">Chapter 13</a>. Also, we’ve covered how to draw SVG graphics with a DSL in <a class="xref" href="ch19.html" title="Chapter 17. Domain-Specific Languages">Chapter 17</a>. Lucky for us, the new HTML5 standard includes features that make it possible to embed SVG pictures directly inside a standard HTML document. In this way, we’ll be able to use our simple little web server to serve up some fully interactive vector graphics. You’ll be amazed at how easy it is to do this.<a id="IDX-CHP-19-0002" class="indexterm"/><a id="IDX-CHP-19-0003" class="indexterm"/><a id="IDX-CHP-19-0004" class="indexterm"/><a id="IDX-CHP-19-0005" class="indexterm"/><a id="IDX-CHP-19-0006" class="indexterm"/><a id="IDX-CHP-19-0007" class="indexterm"/><a id="IDX-CHP-19-0008" class="indexterm"/><a id="IDX-CHP-19-0009" class="indexterm"/><a id="IDX-CHP-19-0010" class="indexterm"/><a id="IDX-CHP-19-0011" class="indexterm"/><a id="IDX-CHP-19-0012" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>At the time this book was written, the only web browser to support inline SVG within HTML was Firefox 3.7 Alpha. Use this, or a more recent release of Firefox with our new version of Dice of Doom. If you’re having problems, try navigating to the about:config page in the Firefox address bar, and set the html5.enable configuration setting to true. This will allow Firefox to use the latest HTML5 settings.</p><p>Also, remember that our web server library is not pure ANSI Common Lisp, and makes use of some CLISP-specific extensions. This means it requires CLISP to function.</p></div><p>First, we’ll need to pull in code from various other chapters to get ready. In the previous chapter, we created version 2 of our Dice of Doom engine. Place all the code from that chapter in a file named <span class="emphasis"><em>dice_of_doom_v2.lisp</em></span>. You should also already have created a file named <span class="emphasis"><em>webserver.lisp</em></span> from <a class="xref" href="ch14.html" title="Chapter 13. Let's Create a Web Server!">Chapter 13</a>. (These files are all freely available from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>.)</p><p>Let’s load in these files:</p><a id="I_programlisting6_d1e34035"/><pre class="programlisting">&gt; <strong class="userinput"><code>(load "dice_of_doom_v2.lisp")</code></strong>
&gt; <strong class="userinput"><code>(load "webserver.lisp")</code></strong></pre><p>For our SVG support, we’ll also need the SVG-rendering code from <a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a> and <a class="xref" href="ch19.html" title="Chapter 17. Domain-Specific Languages">Chapter 17</a>. Place those functions in <span class="emphasis"><em>svg.lisp</em></span>. (This file is also available from <a class="ulink" href="http://landoflisp.com/">http://landoflisp.com/</a>.) For reference, the functions we’ll need are <code class="literal">let1</code>, <code class="literal">split</code>, <code class="literal">pairs</code>, <code class="literal">print-tag</code>, <code class="literal">tag</code>, <code class="literal">svg</code>, <code class="literal">brightness</code>, <code class="literal">svg-style</code>, and <code class="literal">polygon</code>. Load this file next:</p><a id="I_programlisting6_d1e34082"/><pre class="programlisting">&gt; <strong class="userinput"><code>(load "svg.lisp")</code></strong></pre><p>Now let’s write some code that can draw a pretty version of our game board using SVG. First, we’ll want to define some constants that control the various dimensions needed to draw the board:</p><a id="I_programlisting6_d1e34088"/><pre class="programlisting">(defparameter *board-width* 900)
  (defparameter *board-height* 500)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defparameter *board-scale* 64)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defparameter *top-offset* 3)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defparameter *dice-scale* 40)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> (defparameter *dot-size* 0.05)</pre><p>The board width and height will be 900-by-500 pixels, which is a good size for playing a game in a browser on most people’s computer screens. The board scale <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34116"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> represents half the width of a single hex on the screen in pixels. The <code class="literal">*top-offset*</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34125"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> tells us we want three extra hex heights of free space above the base of the board. We’ll need this because a hex with lot of dice on it will have its dice sticking out, upward, and we need room for these dice to be visible on the screen. The <code class="literal">*dice-scale*</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34134"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> tells us that a single die will be about 40 pixels tall and wide on the screen. Finally, we set <code class="literal">*dot-size*</code> to <code class="literal">0.05</code>, which tells us that each dot will be about 0.05 times the size of a die <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34147"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.<a id="IDX-CHP-19-0013" class="indexterm"/><a id="IDX-CHP-19-0014" class="indexterm"/><a id="IDX-CHP-19-0015" class="indexterm"/><a id="IDX-CHP-19-0016" class="indexterm"/><a id="IDX-CHP-19-0017" class="indexterm"/><a id="IDX-CHP-19-0018" class="indexterm"/><a id="IDX-CHP-19-0019" class="indexterm"/><a id="IDX-CHP-19-0020" class="indexterm"/></p><div class="sect2" title="Drawing a Die"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_a_die"/>Drawing a Die</h2></div></div></div><p>Now we’re ready to write a function that can draw a die. Note that we won’t use bitmaps or anything like that to draw. Instead, we’re drawing a die “the hard way,” by rendering it directly out of raw SVG polygons. Here’s the code:</p><a id="I_programlisting6_d1e34188"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun draw-die-svg (x y col)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (labels ((calc-pt (pt)
                  (cons (+ x (* *dice-scale* (car pt)))
                        (+ y (* *dice-scale* (cdr pt)))))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>            (f (pol col)
                (polygon (mapcar #'calc-pt pol) col)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>         (f '((0 . −1) (−0.6 . −0.75) (0 . −0.5) (0.6 . −0.75))
             (brightness col 40))
          (f '((0 . −0.5) (−0.6 . −0.75) (−0.6 . 0) (0 . 0.25))
             col)
          (f '((0 . −0.5) (0.6 . −0.75) (0.6 . 0) (0 . 0.25))
             (brightness col −40))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>         (mapc (lambda (x y)
                (polygon (mapcar (lambda (xx yy)
                                   (calc-pt (cons (+ x (* xx *dot-size*))
                                                  (+ y (* yy *dot-size*)))))
                                 '(−1 −1 1 1)
                                 '(−1 1 1 −1))
                         '(255 255 255)))
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>             '(−0.05 0.125 0.3 −0.3 −0.125 0.05 0.2 0.2 0.45 0.45 −0.45 −0.2)
              '(−0.875 −0.80 −0.725 −0.775 −0.70 −0.625
                −0.35 −0.05 −0.45 −0.15 −0.45 −0.05))))</pre><p>To draw a die, we need to pass in three arguments <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34227"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The first two are the x and y position at which the die should appear in the SVG picture. The third is the color we want the die to be. This function will take some liberties with that color and modify it as needed to give the die a little shading.</p><p>Anything we draw in this function will need to be rendered in a scaled fashion, based on the <code class="literal">*dice-scale*</code> constant we defined. Therefore, we first define a local function <code class="literal">calc-pt</code> that scales a point for us <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34241"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Since we’ll need to draw several scaled polygons, let’s also create a convenience function, <code class="literal">f</code>, that runs <code class="literal">calc-pt</code> against all points in a polygon and then draws it by calling the <code class="literal">polygon</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34257"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>A die in our picture will have three visible faces: the top face, the front face, and the right face. We draw these by calling our function <code class="literal">f</code> three times starting here <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34268"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span> and using some hard-coded coordinates for the three faces.</p><p>The last thing we need to do is draw the little dots on the faces of the die. We do this by <code class="literal">mapcing</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34279"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span> the coordinates for the dots <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34285"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span> against a lambda function that can render a dot. This lambda function uses the <code class="literal">*dot-size*</code> variable to scale down a square-shaped polygon that represents each dot on the die face. We could write more sophisticated code to draw circular and/or elliptical dots, but the dots are so small that squares look just fine.</p><p>Let’s try drawing a die at x=50 and y=50 with an RGB red <code class="literal">(255 0 0)</code> color:</p><a id="I_programlisting6_d1e34299"/><pre class="programlisting">&gt; <strong class="userinput"><code>(svg 100 100 (draw-die-svg 50 50 '(255 0 0)))</code></strong>
&lt;svg  xmlns
:xlink="http://www.w3.org/1999/xlink" height="100" width="100"&gt;&lt;polygon
 points="50,10 26.0,20.0 50,30.0 74.0,20.0 " style="fill:rgb(255,40,40);stroke:rgb
(155,0,0)"&gt;&lt;/polygon&gt;&lt;polygon points="50,30.0 26.0,20.0 26.0,50 50,60.0
" style="fill:rgb(255,0,0);stroke:rgb(155,0,0)"&gt;&lt;/polygon&gt;&lt;polygon points="50,
30.0 74.0,20.0 74.0,50 50,60.0 " style="fill:rgb(215,0,0);
stroke:rgb(115,0,0)"&gt;&lt;/polygon&gt;&lt;polygon points="46.0,
13.0 46.0,17.0 50.0,17.0 50.0,13.0 " style="fill:rgb(255,255,255);stroke:rgb(155,155,
155)"&gt;&lt;/polygon&gt;&lt;polygon points="53.0,16.0 53.0,20.0 57.0,20.0 57.0,16.0
 " style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon
 points="60.0,18.999998 60.0,23.0 64.0,23.0 64.0,18.999998 "
 style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon
 points="36.0,17.0 36.0,21.000002 40.0,21.000002 40.0,17.0 " style="fill:rgb(255,255,
255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon points="43.0,20.0 43.0,
24.0 47.0,24.0 47.0,20.0 " style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;
/polygon&gt;&lt;polygon points="50.0,23.0 50.0,27.0 54.0,27.0 54.0,23.0 "
 style="fill:rgb(255,255,255);
stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon points="56.0,34.0 56.0,38.0
60.0,38.0 60.0,34.0 " style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;
&lt;polygon points="56.0,46.0 56.0,50.0 60.0,50.0 60.0,46.0 "
 style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;
&lt;/polygon&gt;&lt;polygon points="66.0,30.0 66.0,34.0 70.0,34.0 70.0,30.0 " style=
"fill:rgb(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon
 points="66.0,42.0 66.0,46.0 70.0,46.0 70.0,42.0 " style="fill:rgb
(255,255,255);stroke:rgb(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon points="30.0,30.0
 30.0,34.0 34.0,34.0 34.0,30.0 " style="fill:rgb(255,255,255);stroke:rgb
(155,155,155)"&gt;&lt;/polygon&gt;&lt;polygon points="40.0,46.0 40.0,50.0 44.0,
50.0 44.0,46.0 " style="fill:rgb(255,255,255);stroke:rgb(155,155,155)"
&gt;&lt;/polygon&gt;&lt;/svg&gt;</pre><p>If you want to see what the final die looks like, just save this gobbledygook to a file named <span class="emphasis"><em>die.svg</em></span>. Then load the result in Firefox, where you should see the following picture (shown at a blown-up size):<a id="IDX-CHP-19-0021" class="indexterm"/><a id="IDX-CHP-19-0022" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e34320"/><img src="httpatomoreillycomsourcenostarchimages782140.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Drawing a Tile"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_a_tile"/>Drawing a Tile</h2></div></div></div><p>Next, let’s write the function to draw an entire hex tile, including the base and the dice on the tile:</p><a id="I_programlisting6_d1e34330"/><pre class="programlisting">(defun draw-tile-svg (x y pos hex xx yy col chosen-tile)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (loop for z below 2
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>         do (polygon (mapcar (lambda (pt)
                                (cons (+ xx (* *board-scale* (car pt)))
                                      (+ yy (* *board-scale*
                                               (+ (cdr pt) (* (- 1 z) 0.1))))))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                             '((−1 . −0.2) (0 . −0.5) (1 . −0.2)
                                (1 . 0.2) (0 . 0.5) (−1 . 0.2)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                     (if (eql pos chosen-tile)
                          (brightness col 100)
                        col)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>   (loop for z below (second hex)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>         do (draw-die-svg (+ xx
                              (* *dice-scale*
                                 0.3
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>                                (if (oddp (+ x y z))
                                     −0.3
                                   0.3)))
                           (- yy (* *dice-scale* z 0.8)) col)))</pre><p>This function takes in a lot of parameters, because a lot of information is encoded in a single tile of the board. You’ll learn the precise meaning of each of these parameters when we draw the board in the next section.</p><p>First, our <code class="literal">draw-tile-svg</code> function draws the base. To give the base a mild 3D look, we’ll draw it twice, with one level stacked on top of the other. Here <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34382"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> is the loop that draws the two bases. Within that loop, we need to draw a hexagonal polygon <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34388"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. We map a scaling function across the coordinates so that they are scaled to our <code class="literal">*board-scale*</code> variable. Here <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34397"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> you can see the six points of a hexagon in perspective encoded using decimal notation. The color of the base will be brightened slightly if it has been chosen by the player to perform a move. We do this by increasing the brightness of the tile when creating our polygons <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34404"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.<a id="IDX-CHP-19-0023" class="indexterm"/><a id="IDX-CHP-19-0024" class="indexterm"/></p><p>After we’ve finished drawing the tile base, we need to draw the dice that reside on the tile. We do this by looping across the number of dice <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34418"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span> and then calling our <code class="literal">draw-die-svg</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34427"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. When calculating the x and y positions of the dice, we need to perform a bit of scaling math. The most interesting piece of this math is that we shift the dice a bit to the left or right, depending on whether the sum of the x-, y-, and z-coordinates for a given die is odd or even <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34433"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. This makes the stacks look a little imperfect and will give the stacked dice for the complete board a pleasing, natural appearance.</p><p>Now let’s call our function to draw a finished tile and see how it looks. Again, just copy the output from this command to a file named something like <span class="emphasis"><em>tile.svg</em></span>.</p><a id="I_programlisting6_d1e34444"/><pre class="programlisting">&gt; <strong class="userinput"><code>(svg 300 300 (draw-tile-svg 0 0 0 '(0 3) 100 150 '(255 0 0) nil))</code></strong>
&lt;svg  xmlns:xlink="http://www.w3.org/
1999/xlink" height="300" width="300"&gt;&lt;polygon points="36,143.6 100,124.4
 164,143.6 164,169.2 100,188.4 36,169.2 " style="fill:rgb
(255,0,0);stroke:rgb(155,0,0)"&gt;
...</pre><p>Here’s what you should see when looking at the file in Firefox:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e34452"/><img src="httpatomoreillycomsourcenostarchimages782446.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Drawing the Board"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_the_board"/>Drawing the Board</h2></div></div></div><p>Now we’re ready to write a function that draws an entire game board as an SVG. It will be very similar to our <code class="literal">draw-board</code> function, which we’ve been using to draw the board to the console. It fulfills the same role, but simply outputs the result as SVG data.<a id="IDX-CHP-19-0025" class="indexterm"/></p><a id="I_programlisting6_d1e34472"/><pre class="programlisting">(defparameter *die-colors* '((255 63 63) (63 63 255)))

<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun draw-board-svg (board chosen-tile legal-tiles)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (loop for y below *board-size*
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       do (loop for x below *board-size*
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>              for pos = (+ x (* *board-size* y))
               for hex = (aref board pos)
               for xx = (* *board-scale* (+ (* 2 x) (- *board-size* y)))
               for yy = (* *board-scale* (+ (* y 0.7) *top-offset*))
               for col = (brightness (nth (first hex) *die-colors*)
                                         (* −15 (- *board-size* y)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                  do (if (member pos legal-tiles)
                          (tag g ()
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                           (tag a ("xlink:href" (make-game-link pos))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>                       (draw-tile-svg x y pos hex xx yy col chosen-tile)))
                        (draw-tile-svg x y pos hex xx yy col chosen-tile)))))

  (defun make-game-link (pos)
    (format nil "/game.html?chosen=˜a" pos))</pre><p>The <code class="literal">draw-board-svg</code> function takes the board as an argument, but also requires two other arguments that will be important for using the picture as the front end of the user interface for our game <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34522"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. One argument is <code class="literal">chosen-tile</code>, which indicates a tile that the player has clicked with the mouse. We’re going to color that tile a bit lighter, so the player can tell that the computer has recognized the selection. Another argument is <code class="literal">legal-tiles</code>, which indicates which tiles the player can legally click next.<a id="IDX-CHP-19-0026" class="indexterm"/><a id="IDX-CHP-19-0027" class="indexterm"/><a id="IDX-CHP-19-0028" class="indexterm"/><a id="IDX-CHP-19-0029" class="indexterm"/><a id="IDX-CHP-19-0030" class="indexterm"/></p><p>It so happens that SVG pictures have a feature for web links, which works just like the <code class="literal">&lt;a href="..."&gt;</code> hyperlinks in regular HTML. If a tile is a legal tile for the player’s next move, we’ll wrap the SVG for that tile in such a link, making it clickable. Having the <code class="literal">legal-tiles</code> parameter lets us know which tiles we want to be clickable.</p><p>The <code class="literal">draw-board-svg</code> function consists of a couple of nested loops that loop through the <code class="literal">y</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34568"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> and <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34577"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> coordinates of the tile board. For each tile, we then define a ton of local variables (using the facility for local variables in the <code class="literal">loop</code> macro introduced in <a class="xref" href="ch11.html" title="Chapter 10. Looping with the loop Command">Chapter 10</a>). First, we declare <code class="literal">pos</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34592"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, which indicates the position of current tile in the hex array. Then we fetch that hex. Next, we calculate the pixel coordinates for the tiles, in the variables <code class="literal">xx</code> and <code class="literal">yy</code>. As you can see, the math for these coordinates gets a bit tricky, since the board is drawn in perspective on the screen.</p><p>The final local variable we define is <code class="literal">col</code>, which will hold the color of the tile and dice in the current spot. We do this by using a list of die colors, which currently holds the colors red (for player A) and blue (for player B). We also darken the color a bit based on the y-coordinate using the <code class="literal">brightness</code> function (discussed in <a class="xref" href="ch19.html" title="Chapter 17. Domain-Specific Languages">Chapter 17</a>). This darkens the rows in the back a bit, adding to the 3D appearance of our SVG game board.</p><p>If the current tile is a member of the legal tiles <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34616"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>, we’re going to wrap it in a web link, as mentioned previously. In SVG, this is done with a tag in the form <code class="literal">&lt;a xlink:href="..."&gt;</code>, which we create here <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34625"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Notice that we also wrap each tile in a <code class="literal">&lt;g&gt;</code> tag, which tells the SVG renderer to treat the polygons in this tile as a group. To figure out the actual URL we want to link to, we call the <code class="literal">make-game-link</code> function. This function builds an appropriate URL. You’ll understand the format of the URL better once we start writing the code that handles the web server for our game.<a id="IDX-CHP-19-0031" class="indexterm"/><a id="IDX-CHP-19-0032" class="indexterm"/><a id="IDX-CHP-19-0033" class="indexterm"/></p><p>Finally, we’re ready to call our <code class="literal">draw-tile</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34658"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. There are two different versions of the call in our code: one for the hyperlinked version and one for the nonlinked version.</p><p>Phew! Now we can finally draw a full game board dynamically, using the SVG format:</p><a id="I_programlisting6_d1e34666"/><pre class="programlisting">&gt; <strong class="userinput"><code>(svg *board-width* *board-height* (draw-board-svg (gen-board) nil nil))</code></strong>
&lt;svg  xmlns:xlink="http://www.w3.org/
1999/xlink" height="500" width="900"&gt;&lt;polygon points="256,185.6 320,166.4
 384,185.6 384,211.2 320,230.4 256,211.2 "
...</pre><p>If you save the output to <span class="emphasis"><em>board.svg</em></span> and load it in Firefox, here is what you should see:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e34678"/><img src="httpatomoreillycomsourcenostarchimages781682.png.jpg" alt="image with no caption"/></div></div></div></div></div>
<div class="sect1" title="Building the Web Server Interface"><div class="titlepage"><div><div><h1 class="title"><a id="building_the_web_server_interface"/>Building the Web Server Interface</h1></div></div></div><p>Now that we’ve completed the graphical side of Dice of Doom version 3, we’re ready to write the side that interfaces with the web server.</p><div class="sect2" title="Writing Our Web Request Handler"><div class="titlepage"><div><div><h2 class="title"><a id="writing_our_web_request_handler"/>Writing Our Web Request Handler</h2></div></div></div><p>The central function for our web server handling is called <code class="literal">dod-request-handler</code>. It is the function that we can pass to the <code class="literal">serve</code> command in our web server library, and it is responsible for handling all the web requests coming from the web browser. Here is the code for <code class="literal">dod-request-handler</code>:</p><a id="I_programlisting6_d1e34702"/><pre class="programlisting">(defparameter *cur-game-tree* nil)
  (defparameter *from-tile* nil)

  (defun dod-request-handler (path header params)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (if (equal path "game.html")
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>       (progn (princ "&lt;!doctype html&gt;")
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>              (tag center ()
                    (princ "Welcome to DICE OF DOOM!")
                    (tag br ())
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                   (let ((chosen (assoc 'chosen params)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                     (when (or (not *cur-game-tree*) (not chosen))
                        (setf chosen nil)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                       (web-initialize))
                      (cond ((lazy-null (caddr *cur-game-tree*))
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>                              (web-announce-winner (cadr *cur-game-tree*)))
                            ((zerop (car *cur-game-tree*))
<img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/>                              (web-handle-human
                                  (when chosen
                                        (read-from-string (cdr chosen)))))
<img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/>                           (t (web-handle-computer))))
                    (tag br ())
<img src="httpatomoreillycomsourcenostarchimages783062.png" alt=""/>                   (draw-dod-page *cur-game-tree* *from-tile*)))
      (princ "Sorry... I don't know that page.")))</pre><p>First, this function checks whether the current page being fetched from the web server is <code class="literal">game.html</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34770"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This is the page where our game will reside on the web server. At the top of the page, we specify the <code class="literal">doctype</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34779"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. When done in this way, it tells the web browser to expect an HTML5-encoded web page. Then we put in some simple HTML to center the page and print a welcome message <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34785"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.<a id="IDX-CHP-19-0034" class="indexterm"/><a id="IDX-CHP-19-0035" class="indexterm"/><a id="IDX-CHP-19-0036" class="indexterm"/></p><p>The <code class="literal">params</code> passed from the web server library may contain an important value named <code class="literal">chosen</code>, which we fetch using this line <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34813"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. If there is no chosen tile, or if the game tree is currently empty <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34819"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>, it means the player must be starting a brand-new game. If that’s the case, we will call a function named <code class="literal">web-initialize</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34829"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>.</p><p>Next, we need to find out whether the game has ended. We can tell this by checking if the list of moves is empty (which, as you might remember, is stored in the <code class="literal">caddr</code> location of the tree). In that case, we’ll announce a winner <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34840"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>.</p><p>Following that, we need to see if the current player is player zero, which means the player is the human player. In that case, we’ll call the function <code class="literal">web-handle-human</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34851"/><img src="httpatomoreillycomsourcenostarchimages783566.png" alt=""/></span> to build the rest of the HTML data in the body of the page. We also use the <code class="literal">read-from-string</code> function to pull the number of the chosen tile from the <code class="literal">chosen</code> parameter, if it exists.</p><p>In all other cases, we know we’re dealing with a computer player and hand over control to <code class="literal">web-handle-computer</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34868"/><img src="httpatomoreillycomsourcenostarchimages783498.png" alt=""/></span> to build the rest of the HTML.</p><p>Lastly, the <code class="literal">dod-request-handler</code> function needs to call the <code class="literal">draw-dod-page</code> function to draw the game board, which we do here <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34882"/><img src="httpatomoreillycomsourcenostarchimages783062.png" alt=""/></span>.</p></div><div class="sect2" title="Limitations of Our Game Web Server"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_of_our_game_web_server"/>Limitations of Our Game Web Server</h2></div></div></div><p>The limitations of our game web server are quite significant. First of all, for simplicity’s sake, the <code class="literal">dod-request-handler</code> function makes absolutely no effort to try to determine from whom the web request is coming. It behaves as if all game interactions were coming from a single player, and therefore isn’t a true multiplayer server for Dice of Doom. If multiple players were to try to play different games at the same time, the <code class="literal">dod-request-handler</code> would get confused and <span class="emphasis"><em>bad things</em></span> would happen.<a id="IDX-CHP-19-0037" class="indexterm"/><a id="IDX-CHP-19-0038" class="indexterm"/><a id="IDX-CHP-19-0039" class="indexterm"/><a id="IDX-CHP-19-0040" class="indexterm"/><a id="IDX-CHP-19-0041" class="indexterm"/><a id="IDX-CHP-19-0042" class="indexterm"/><a id="IDX-CHP-19-0043" class="indexterm"/><a id="IDX-CHP-19-0044" class="indexterm"/><a id="IDX-CHP-19-0045" class="indexterm"/></p><p>It would not be too difficult to expand <code class="literal">dod-request-handler</code> into a true web server for multiple, parallel games. To do this, we would need to pull session information out of the header data it receives as an argument from the web server, and then all variables it references (such as <code class="literal">*cur-game-tree*</code>, for instance) would need to live in a hash table, using the session information as a key. This way, each player would have her own game tree, and our engine could then serve multiple games in parallel. The implementation of such a multigame version of the <code class="literal">dod-request-handler</code> is “an exercise for the reader.”</p><p>Another limitation of <code class="literal">dod-request-handler</code> is that it reads information from the URL using the <code class="literal">read-from-string</code> function. As you’ve learned in earlier chapters, this function can be compromised to run arbitrary code in the hands of an experienced (and evil) Lisper.</p></div><div class="sect2" title="Initializing a New Game"><div class="titlepage"><div><div><h2 class="title"><a id="initializing_a_new_game"/>Initializing a New Game</h2></div></div></div><p>Here is the <code class="literal">web-initialize</code> function, which initializes our game engine to start a brand-new game of Dice of Doom:</p><a id="I_programlisting6_d1e34973"/><pre class="programlisting">(defun web-initialize ()
    (setf *from-tile* nil)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (setf *cur-game-tree* (game-tree (gen-board) 0 0 t)))</pre><p>As you can see, it generates a random game board, builds a tree from it, and then stores the result in the global <code class="literal">*cur-game-tree*</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e34986"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p></div><div class="sect2" title="Announcing a Winner"><div class="titlepage"><div><div><h2 class="title"><a id="announcing_a_winner"/>Announcing a Winner</h2></div></div></div><p>Here is the function that announces the winner within the web browser:</p><a id="I_programlisting6_d1e34997"/><pre class="programlisting">(defun web-announce-winner (board)
    (fresh-line)
    (let ((w (winners board)))
      (if (&gt; (length w) 1)
        (format t "The game is a tie between ˜a" (mapcar #'player-letter w))
        (format t "The winner is ˜a" (player-letter (car w)))))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (tag a (href "game.html")
         (princ " play again")))</pre><p>It is exactly the same as our previous <code class="literal">announce-winner</code> function, except that it now includes some extra code at the end to build a web link <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35010"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which will allow us to conveniently start a brand-new game, since the current game has ended.</p></div><div class="sect2" title="Handling the Human Player"><div class="titlepage"><div><div><h2 class="title"><a id="handling_the_human_player"/>Handling the Human Player</h2></div></div></div><p>The <code class="literal">web-handle-human</code> function is responsible for creating the HTML and doing the bookkeeping when the player taking the current turn is the human player.</p><a id="I_programlisting6_d1e35024"/><pre class="programlisting">(defun web-handle-human (pos)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (cond ((not pos) (princ "Please choose a hex to move from:"))
          ((eq pos 'pass) (setf *cur-game-tree*
                                (cadr (lazy-car (caddr *cur-game-tree*))))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>          (princ "Your reinforcements have been placed.")
           (tag a (href (make-game-link nil))
                (princ "continue")))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>         ((not *from-tile*) (setf *from-tile* pos)
                             (princ "Now choose a destination:"))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>         ((eq pos *from-tile*) (setf *from-tile* nil)
                                (princ "Move cancelled."))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>         (t (setf *cur-game-tree*
                   (cadr (lazy-find-if (lambda (move)
                                         (equal (car move)
                                                (list *from-tile* pos)))
                                       (caddr *cur-game-tree*))))
             (setf *from-tile* nil)
             (princ "You may now ")
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>            (tag a (href (make-game-link 'pass))
                  (princ "pass"))
             (princ " or make another move:"))))</pre><p>The recent choices the human has made dictate what this function will do. The <code class="literal">web-handle-human</code> function knows the human’s choices by referencing the most recently chosen position, which derives from a variable passed as a parameter through the web request. It also can reference the <code class="literal">*from-tile*</code> global variable, which tells it which tile the player initially chose to use as a starting location for a move. It needs both of these values, since a move has both a source location and a destination location.<a id="IDX-CHP-19-0046" class="indexterm"/><a id="IDX-CHP-19-0047" class="indexterm"/></p><p>If the player has not yet chosen a location, we want to print a message requesting that the player choose a hex <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35079"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If the player chose to pass, we want to print a message saying that player’s reinforcements have been placed <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35085"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. (Remember that reinforcements are placed right after someone passes.)</p><p>Next, we check if the <code class="literal">*from-tile*</code> variable is nil. If this is the case, it means the player has not yet chosen a starting location for a dice attack. If it’s <code class="literal">nil</code>, we can set <code class="literal">*from-tile*</code> equal to the location that was just selected <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35102"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, as well as ask the player to select a destination.</p><p>If the currently selected location is the same as the <code class="literal">*from-tile*</code> variable, it means a tile was selected twice. This must mean the player has changed his mind and wants to undo his selection. Therefore, we will set <code class="literal">*from-tile*</code> to <code class="literal">nil</code> and print a cancellation message <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35119"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>In all other cases, it means the player has selected two valid locations for the start and end of an attack. We can now advance the <code class="literal">*cur-game-tree*</code> to point to the appropriate next tree inside the lazy list of available moves <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35130"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. We want to print a message, allowing the player to pass <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35136"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span> or make yet another attack.</p><p>We have now completed the code our game server will use to interact with the human player. Next, let’s write a function to handle the computer player.</p></div><div class="sect2" title="Handling the Computer Player"><div class="titlepage"><div><div><h2 class="title"><a id="handling_the_computer_player"/>Handling the Computer Player</h2></div></div></div><p>Handling the web interface for our computer player is pretty simple. After all, computer players don’t need any fancy user interface stuff to know what’s going on in the game. All the web stuff that happens when the computer is making moves is there solely for the benefit of the human player. Here is the <code class="literal">web-handle-computer</code> code that renders the HTML in the web interface as the AI player makes a move:<a id="IDX-CHP-19-0048" class="indexterm"/><a id="IDX-CHP-19-0049" class="indexterm"/><a id="IDX-CHP-19-0050" class="indexterm"/><a id="IDX-CHP-19-0051" class="indexterm"/><a id="IDX-CHP-19-0052" class="indexterm"/></p><a id="I_programlisting6_d1e35179"/><pre class="programlisting">(defun web-handle-computer ()
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (setf *cur-game-tree* (handle-computer *cur-game-tree*))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (princ "The computer has moved. ")
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>   (tag script ()
      (princ
        "window.setTimeout('window.location=\"game.html?chosen=NIL\"',5000)")))</pre><p>All this function does is call our previous <code class="literal">handle-computer</code> function, which will return the next branch that the computer has selected in the game tree. We use this to update our <code class="literal">*cur-game-tree*</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35207"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we print a message to state that the player has moved <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35213"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. The last part of the function is a clever little gimmick to spice up our web interface a bit. It puts a smidgen of JavaScript in the HTML of the web page <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35219"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, which forces the web browser to automatically load a new web page in five seconds. This means that as the computer AI player makes its moves, we get to see everything happen in a crude animation!</p></div><div class="sect2" title="Drawing the SVG Game Board from Within the HTML"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_the_svg_game_board_from_within_t"/>Drawing the SVG Game Board from Within the HTML</h2></div></div></div><p>We have only one more function to write to complete version 3 of Dice of Doom: the <code class="literal">draw-dod-page</code> function. This function interfaces our page game server code with the SVG code that draws our board.</p><a id="I_programlisting6_d1e35233"/><pre class="programlisting">(defun draw-dod-page (tree selected-tile)
    (svg *board-width*
         *board-height*
         (draw-board-svg (cadr tree)
                         selected-tile
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                        (take-all (if selected-tile
                                       (lazy-mapcar
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                                        (lambda (move)
                                           (when (eql (caar move)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                                                     selected-tile)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                                                (cadar move)))
                                         (caddr tree))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                                    (lazy-mapcar #'caar (caddr tree)))))))</pre><p>The most complicated part of this function is the code that determines which tiles on the board are legal tiles for the player to click <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35267"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If the player has already selected a tile, we want to find all moves <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35273"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> where the starting position for the move matches the selected tile <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35279"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> and return the destination position for the given move <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35285"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. If the player hasn’t selected a tile yet, we just want to return all the legal starting positions <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e35291"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>.<a id="IDX-CHP-19-0053" class="indexterm"/><a id="IDX-CHP-19-0054" class="indexterm"/></p><p>We have now completed our fully graphical version of Dice of Doom. Let’s play!</p></div></div>
<div class="sect1" title="Playing Version 3 of Dice of Doom"><div class="titlepage"><div><div><h1 class="title"><a id="playing_version_3_of_dice_of_doom"/>Playing Version 3 of Dice of Doom</h1></div></div></div><p>First, we need to start up our web server. Simply serve up our <code class="literal">dod-request-handler</code>, and we’re ready to go:</p><a id="I_programlisting6_d1e35318"/><pre class="programlisting">&gt; <strong class="userinput"><code>(serve #'dod-request-handler)</code></strong></pre><p>Now move over to Firefox and go to <a class="ulink" href="http://localhost:8080/game.html">http://localhost:8080/game.html</a>. You should see our game in your browser:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e35327"/><img src="httpatomoreillycomsourcenostarchimages783058.png.jpg" alt="image with no caption"/></div></div><p>When you click a tile, it is highlighted:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e35335"/><img src="httpatomoreillycomsourcenostarchimages782450.png.jpg" alt="image with no caption"/></div></div><p>Now you can select a tile to attack. In this example, we’ll choose the stack of two dice to the right of the selected stack:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e35343"/><img src="httpatomoreillycomsourcenostarchimages781872.png.jpg" alt="image with no caption"/></div></div><p>Next, let’s pass our turn by clicking the <strong class="userinput"><code>pass</code></strong> web link. This will cause the reinforcement dice to be placed (in this case, only a single additional die in the upper-left corner):</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e35354"/><img src="httpatomoreillycomsourcenostarchimages781252.png.jpg" alt="image with no caption"/></div></div><p>If you now hit <strong class="userinput"><code>continue</code></strong>, you will see the game cycle automatically through the moves for the computer player, in a similar fashion. It will keep going on like this until there is a winner for the game. You can always start a new game by just going back to the original <span class="emphasis"><em>game.html</em></span> URL.</p><p>This is much nicer than the crude console interface we’ve been using so far! But there are still a few, final improvements we’re going to make to pep up Dice of Doom. We’ll be covering those in the next (and final chapter) of this book.</p></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id19"/>What You've Learned</h1></div></div></div><p>In this chapter, we discussed how you can generate interactive graphics in a web browser from a Lisp program. Along the way, you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can create a graphical version of Dice Of Doom by rendering the board using the SVG format.</p></li><li class="listitem"><p>The HTML5 standard supports inline SVG images. You can use this to create an interactive, web-based version of your game.</p></li><li class="listitem"><p>The simple web server used for our example has several limitations. For example, our game cannot be played by multiple players. However, the request handler could be expanded to allow for multiple, parallel games.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;20.&#xA0;Making Dice of Doom More Fun"><div class="titlepage"><div><div><h1 class="title"><a id="making_dice_of_doom_more_fun"/>Chapter 20. Making Dice of Doom More Fun</h1></div></div></div><p>It’s now time to create a final version of Dice of Doom. Version 4 of our game will be much more fun to play than our earlier versions.<a id="IDX-CHP-20-0001" class="indexterm"/></p><p>Although you probably were not aware of it, we made some major compromises in the rules for our game to make it easier to program. In this chapter, we will allow more players, add rolling of the dice, and implement a few more changes to make Dice of Doom a much more interesting game.</p><div class="sect1" title="Increasing the Number of Players"><div class="titlepage"><div><div><h1 class="title"><a id="increasing_the_number_of_players"/>Increasing the Number of Players</h1></div></div></div><p>To begin, put all the code from the previous chapter in a file named <span class="emphasis"><em>dice_of_doom_v3.lisp</em></span> (also available from the companion website), and then execute the following command:</p><a id="I_programlisting7_d1e35407"/><pre class="programlisting">&gt; <strong class="userinput"><code>(load "dice_of_doom_v3.lisp")</code></strong></pre><p>The first change we’re going to make is to increase the number of players from two to four. Three of these will be AI opponents, played by the computer. Because of how we’ve written our code so far, this requires very little extra code:<a id="IDX-CHP-20-0002" class="indexterm"/><a id="IDX-CHP-20-0003" class="indexterm"/><a id="IDX-CHP-20-0004" class="indexterm"/><a id="IDX-CHP-20-0005" class="indexterm"/><a id="IDX-CHP-20-0006" class="indexterm"/></p><a id="I_programlisting7_d1e35434"/><pre class="programlisting">(defparameter *num-players* 4)
(defparameter *die-colors* '((255 63 63) (63 63 255) (63 255 63)
                             (255 63 255)))</pre><p>First, we simply change our <code class="literal">*num-players*</code> variable to <code class="literal">4</code>. Then we need to indicate additional die colors for our new players. The colors for the four players will be red, blue, green, and purple.</p><p>It turns out that the AI we’ve created so far already works just fine in a four-player game.</p><p>Our AI game engine will use what is called a “paranoid strategy.” This means that the AI players will always assume that every other player (including the human) has no other goal but to—how should I put this?—screw them over personally. This isn’t a bad strategy to use; however, a game with more than two players opens up new possibilities. For instance, losing players could gang up on a winning player to improve their odds. Our game AI isn’t smart enough to form such packs of cooperation, but it’s good enough.<a id="IDX-CHP-20-0007" class="indexterm"/></p><p>Now that we’ve already tweaked some constants to increase the number of players, let’s tweak a couple more:</p><a id="I_programlisting7_d1e35453"/><pre class="programlisting">(defparameter *max-dice* 5)
(defparameter *ai-level* 2)</pre><p>Here, we’re increasing the maximum number of dice on a hex tile from three to five, and decreasing the level of our AI from four to two. With the new rules described in this chapter, we’ll need to dumb down our AI a bit to make sure it stays zippy. Since there are now four competing players, the AI actually doesn’t need to be so smart to challenge the human opponent.</p></div></div>
<div class="sect1" title="Rolling the Dice"><div class="titlepage"><div><div><h1 class="title"><a id="rolling_the_dice"/>Rolling the Dice</h1></div></div></div><p>I’m sure you’ve probably noticed one obvious flaw in our game so far: Despite the fact that it is called Dice of Doom, it actually is completely devoid of any randomness! The dice are never rolled, and the larger stack will always automatically win, which makes for a pretty lame dice game. Now we’re finally going to rectify this flaw.</p><p>In this version of the game, during an attack, both piles of dice are rolled, and whoever rolls the highest number wins the battle. Ties are a victory for the defender. If the attacker loses, that player must surrender all dice from the attacking hex except one.</p><p>In the lingo of AI programming, this means we will add <span class="emphasis"><em>chance nodes</em></span> to our game tree. The way we’re going to implement this is pretty simple.</p><div class="sect2" title="Building Chance Nodes"><div class="titlepage"><div><div><h2 class="title"><a id="building_chance_nodes"/>Building Chance Nodes</h2></div></div></div><p>Every move in our lazy list of moves up to now has always had exactly two items in it: a description of the move (a list of the source and destination of the attack, or <code class="literal">nil</code> for a passing move) and the new node of the game tree for when the move has been taken. Now we’re simply going to add a third item to a move, which contains the game tree for an unsuccessful attack. This means that each move in our move list will double as a chance node, with two possible follow-up nodes for the next game tree, depending on whether an attack is successful.<a id="IDX-CHP-20-0008" class="indexterm"/><a id="IDX-CHP-20-0009" class="indexterm"/></p><p>Let’s update our <code class="literal">attacking-moves</code> function to add this extra item to the move so that each move acts as a chance node.</p><a id="I_programlisting7_d1e35488"/><pre class="programlisting">(defun attacking-moves (board cur-player spare-dice)
    (labels ((player (pos)
                 (car (aref board pos)))
           (dice (pos)
               (cadr (aref board pos))))
      (lazy-mapcan (lambda (src)
                     (if (eq (player src) cur-player)
                       (lazy-mapcan
                         (lambda (dst)
                           (if (and (not (eq (player dst) cur-player))
                                    (&gt; (dice src) 1))
                               (make-lazy (list (list (list src dst)
        (game-tree (board-attack board cur-player src dst (dice src))
                   cur-player
                   (+ spare-dice (dice dst))
                   nil)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (game-tree (board-attack-fail board cur-player src dst (dice src))
                   cur-player
                   (+ spare-dice (dice dst))
                   nil))))
                                        (lazy-nil)))
                                    (make-lazy (neighbors src)))
                       (lazy-nil)))
                   (make-lazy (loop for n below *board-hexnum*
                            collect n)))))</pre><p>The only thing new in this updated version of <code class="literal">attacking-moves</code> is right here <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35501"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, where we add a third item as we create a new move in the game tree. The board in this alternate branch of our chance node is constructed by calling the function <code class="literal">board-attack-fail</code>, which we will write next.</p><p>The <code class="literal">board-attack-fail</code> function does exactly what you would expect: It takes a board and returns a board that has all dice but one removed from the hex from which a failed attack originated.</p><a id="I_programlisting7_d1e35515"/><pre class="programlisting">(defun board-attack-fail (board player src dst dice)
    (board-array (loop for pos from 0
                       for hex across board
                       collect (if (eq pos src)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                                  (list player 1)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                                hex))))</pre><p>Here, we simply loop over the board and return each hex unmodified <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35531"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, unless it happens to be the source hex for the attack. In that case, we remove all dice from that hex but one <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35537"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.<a id="IDX-CHP-20-0010" class="indexterm"/><a id="IDX-CHP-20-0011" class="indexterm"/><a id="IDX-CHP-20-0012" class="indexterm"/><a id="IDX-CHP-20-0013" class="indexterm"/></p></div><div class="sect2" title="Doing the Actual Dice Rolling"><div class="titlepage"><div><div><h2 class="title"><a id="doing_the_actual_dice_rolling"/>Doing the Actual Dice Rolling</h2></div></div></div><p>Next, we need to write some functions to actually roll the dice. Here is a function that rolls a pile of dice:</p><a id="I_programlisting7_d1e35566"/><pre class="programlisting">(defun roll-dice (dice-num)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (let ((total (loop repeat dice-num
                       sum (1+ (random 6)))))
      (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>     (format t "On ˜a dice rolled ˜a. " dice-num total)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     total))</pre><p>First, it calculates a total count of a pile of rolled dice by looping once for each die. For each die, it generates a random number from 1 to 6. Then it stores the total sum in the <code class="literal">total</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35591"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, the <code class="literal">roll-dice</code> function prints a descriptive message about the roll <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35600"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Finally, it returns the total <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35606"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>Since we’re never going to roll a pile of dice in isolation, let’s create another function that pits two piles of dice against each other:</p><a id="I_programlisting7_d1e35614"/><pre class="programlisting">(defun roll-against (src-dice dst-dice)
  (&gt; (roll-dice src-dice) (roll-dice dst-dice)))</pre><p>This simply calls <code class="literal">roll-dice</code> twice and compares the total of the two rolls. We’ll want to use this function as we travel along our game tree to pick either the winning or losing move as a turn is chosen by either the human or the computer.</p></div><div class="sect2" title="Calling the Dice Rolling Code from Our Game Engine"><div class="titlepage"><div><div><h2 class="title"><a id="calling_the_dice_rolling_code_from_our_g"/>Calling the Dice Rolling Code from Our Game Engine</h2></div></div></div><p>In the context of our game engine, rolling dice simply means picking either the winning or losing branch of the chance node after the human or computer has chosen a move. This action is performed by the <code class="literal">pick-chance-branch</code> function:</p><a id="I_programlisting7_d1e35629"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun pick-chance-branch (board move)
    (labels ((dice (pos)
                   (cadr (aref board pos))))
      (let ((path (car move)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>       (if (or (null path) (roll-against (dice (car path))
                                          (dice (cadr path))))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>           (cadr move)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>         (caddr move)))))</pre><p>This function takes the current board and also the move that contains the chance node that needs to be resolved <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35656"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. When the path inside the move is not <code class="literal">null</code>, we call <code class="literal">roll-against</code> with a count of dice in the source and destination hexes along the path of attack <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35668"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. We check for a <code class="literal">null</code> path because that means the move was a “pass,” which doesn’t require any dice rolling.<a id="IDX-CHP-20-0014" class="indexterm"/><a id="IDX-CHP-20-0015" class="indexterm"/></p><p>If the dice roll for the attack is successful, we remove the first child tree from the chance node within the move <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35686"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If the attack is unsuccessful, we return the second child of the chance node <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35692"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Now we need to make sure that the <code class="literal">pick-chance-branch</code> function is called when the human or computer chooses a move. First, let’s take care of the human:</p><a id="I_programlisting7_d1e35703"/><pre class="programlisting">(defun handle-human (tree)
    (fresh-line)
    (princ "choose your move:")
    (let ((moves (caddr tree)))
      (labels ((print-moves (moves n)
                      (unless (lazy-null moves)
                        (let* ((move (lazy-car moves))
                             (action (car move)))
                          (fresh-line)
                          (format t "˜a. " n)
                          (if action
                            (format t "˜a -&gt; ˜a" (car action) (cadr action))
                          (princ "end turn")))
                        (print-moves (lazy-cdr moves) (1+ n)))))
            (print-moves moves 1))
      (fresh-line)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>     (pick-chance-branch (cadr tree) (lazy-nth (1- (read)) moves))))</pre><p>All we’ve done here is to add a call to <code class="literal">pick-chance-branch</code> at the end of our previous <code class="literal">handle-human</code> function, at the point we need to return the child branch of the game tree that holds the next state of the game <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35719"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>We update the <code class="literal">handle-computer</code> function in the same way:</p><a id="I_programlisting7_d1e35730"/><pre class="programlisting">(defun handle-computer (tree)
    (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*) (car tree))))
      (pick-chance-branch
        (cadr tree)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>       (lazy-nth (position (apply #'max ratings) ratings) (caddr tree)))))</pre><p>Again, we’ve simply added a call to <code class="literal">pick-chance-branch</code> at the end of the function <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35743"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>It is now possible to play our updated Dice of Doom game. However, at this point, the computer player will play a very poor game, because the AI does not yet understand that the chance nodes exist. It will simply assume that every attack will always be successful, making it much too foolhardy to play a decent game. We need to improve our AI so that it takes into account the rolling of the dice as it makes its decisions.</p></div><div class="sect2" title="Updating the AI"><div class="titlepage"><div><div><h2 class="title"><a id="updating_the_ai"/>Updating the AI</h2></div></div></div><p>For the AI to be able to deal with the dice rolls that are now important to our game, it must know a little something about the statistics of dice rolls. The following table gives it the needed statistical information:<a id="IDX-CHP-20-0016" class="indexterm"/><a id="IDX-CHP-20-0017" class="indexterm"/><a id="IDX-CHP-20-0018" class="indexterm"/></p><a id="I_programlisting7_d1e35770"/><pre class="programlisting">(defparameter *dice-odds* #(#(0.84 0.97 1.0 1.0)
                            #(0.44 0.78 0.94 0.99)
                            #(0.15 0.45 0.74 0.91)
                            #(0.04 0.19 0.46 0.72)
                            #(0.01 0.06 0.22 0.46)))</pre><p>This table contains the odds of winning for each possible pairing of dice in our game. The columns represent the attacking dice, starting with one die. The rows represent the destination dice, starting with two dice (the minimum dice needed for an attack).</p><p>This table tells us, for instance, that a roll of two attacking dice against one defending die has an 84 percent chance of winning. Four attacking dice against three defending dice have a 74 percent chance of winning.</p><p>If you remember, the core function in our AI code is the <code class="literal">get-ratings</code> function, which gives a point score to the list of possible follow-up moves. We need to modify how it calculates the score of each possible move to take the odds of success of the dice roll into account. We are now going to make use of our <code class="literal">*dice-odds*</code> table, as well as the point scores of the successful or failed outcomes of each attack, to interpolate a combined score for each available move:</p><a id="I_programlisting7_d1e35784"/><pre class="programlisting">(defun get-ratings (tree player)
    (let ((board (cadr tree)))
      (labels ((dice (pos)
                     (cadr (aref board pos))))
        (take-all (lazy-mapcar
                    (lambda (move)
                      (let ((path (car move)))
                        (if path
                            (let* ((src (car path))
                                   (dst (cadr path))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                                  (odds (aref (aref *dice-odds*
                                                     (1- (dice dst)))
                                               (- (dice src) 2))))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                             (+ (* odds (rate-position (cadr move) player))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                                (* (- 1 odds) (rate-position (caddr move)
                                                              player))))
                          (rate-position (cadr move) player))))
                    (caddr tree))))))</pre><p>In our updated <code class="literal">get-ratings</code> function, we look up the odds of each attack succeeding from our table <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35809"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then we multiply the odds with the rating for the winning child tree <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35815"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Additionally, we add in the odds of losing the attack (one minus the odds of winning) multiplied by the rating for the losing board position <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35821"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. We now have an updated <code class="literal">get-ratings</code> function that understands chance nodes and accounts for them appropriately when generating the score for a move.<a id="IDX-CHP-20-0019" class="indexterm"/><a id="IDX-CHP-20-0020" class="indexterm"/><a id="IDX-CHP-20-0021" class="indexterm"/></p><p>For our game AI to be fully compatible with chance nodes, we need to make one additional small change. Our tree-trimming function needs to know about the two branches of the chance node within each move, so it can properly trim both the winning and losing alternatives for each move:</p><a id="I_programlisting7_d1e35848"/><pre class="programlisting">(defun limit-tree-depth (tree depth)
    (list (car tree)
          (cadr tree)
          (if (zerop depth)
              (lazy-nil)
            (lazy-mapcar (lambda (move)
                           (cons (car move)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>                                (mapcar (lambda (x)
                                           (limit-tree-depth x (1- depth)))
                                         (cdr move))))
                         (caddr tree)))))</pre><p>We <code class="literal">mapcar</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35861"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> across the tail of each move, so trimming is performed on both branches of any chance nodes.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Version 4 of Dice of Doom will not have alpha-beta pruning. Performing proper alpha-beta pruning in the presence of chance nodes is very complex.</p></div></div></div>
<div class="sect1" title="Improving the Dice of Doom Reinforcement Rules"><div class="titlepage"><div><div><h1 class="title"><a id="improving_the_dice_of_doom_reinforcement"/>Improving the Dice of Doom Reinforcement Rules</h1></div></div></div><p>Until now, the number of reinforcements at the end of a player’s turn always equals the number of captured opponent dice, minus one. This reinforcement rule guaranteed that the total number of dice in a game always decreases, so that the game was certain to eventually terminate, and the game tree was always finite in size.</p><p>However, since version 2, our game tree has been a lazy tree, so it is perfectly fine if the tree is infinite. Remember that one of the main benefits of lazy evaluation is that you can have data structures that are infinite in size.<a id="IDX-CHP-20-0022" class="indexterm"/></p><p>Therefore, we are now going to adjust our reinforcement rules to make our game strategically more interesting.</p><p>According to our new rules, the number of reinforcement dice will equal the number of tiles in the player’s largest contiguous territory. This adds a lot of strategic depth, because the players must constantly decide whether to risk connecting their territories, or perhaps even to sacrifice smaller, nonviable territories by sending them on suicide missions.<a id="IDX-CHP-20-0023" class="indexterm"/><a id="IDX-CHP-20-0024" class="indexterm"/><a id="IDX-CHP-20-0025" class="indexterm"/></p><p>In order to implement this new reinforcement rule, let’s first define the function <code class="literal">get-connected</code>, which returns a list of tiles that are owned by the current player and are connected as a cluster of neighbors to the target tile:</p><a id="I_programlisting7_d1e35899"/><pre class="programlisting">(defun get-connected (board player pos)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((check-pos (pos visited)
               (if (and (eq (car (aref board pos)) player)
                        (not (member pos visited)))
                   (check-neighbors (neighbors pos) (cons pos visited))
                 visited))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>            (check-neighbors (lst visited)
               (if lst
                   (check-neighbors (cdr lst) (check-pos (car lst) visited))
                 visited)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     (check-pos pos '())))</pre><p>This function uses the same algorithm for finding connected tiles as we used for calculating connectedness in our Grand Theft Wumpus game in <a class="xref" href="ch09.html" title="Chapter 8. This Ain't Your Daddy's Wumpus">Chapter 8</a>. We traverse through the hexes and their neighbors recursively, while maintaining a <code class="literal">visited</code> list.</p><p>The <code class="literal">get-connected</code> function accomplishes this by defining two recursive local functions. The <code class="literal">check-pos</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35934"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> checks a single position and appends any new neighbors accessible from that location to the visited list. The <code class="literal">check-neighbors</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35943"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> checks an entire list of neighbors, similarly appending new neighbors to the visited list. These two functions call each other recursively until all neighbors in a cluster are found. To start off this recursive calculation, we call the <code class="literal">check-pos</code> function with the target position and an initially empty <code class="literal">visited</code> list <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e35956"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>We can now find clusters. However, to find the <span class="emphasis"><em>largest</em></span> cluster, we need the <code class="literal">largest-cluster-size</code> function:</p><a id="I_programlisting7_d1e35970"/><pre class="programlisting">(defun largest-cluster-size (board player)
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>   (labels ((f (pos visited best)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>             (if (&lt; pos *board-hexnum*)
                (if (and (eq (car (aref board pos)) player)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                        (not (member pos visited)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>                   (let* ((cluster (get-connected board player pos))
                         (size (length cluster)))
<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/>                   (if (&gt; size best)
<img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/>                       (f (1+ pos) (append cluster visited) size)
<img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/>                     (f (1+ pos) (append cluster visited) best)))
                  (f (1+ pos) visited best))
              best)))
          (f 0 '() 0)))</pre><p>This function defines a local function <code class="literal">f</code>, which we’ll use to check every position on the board, while maintaining both a list of previously visited nodes and the size of the largest, best cluster found so far <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36021"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.<a id="IDX-CHP-20-0026" class="indexterm"/><a id="IDX-CHP-20-0027" class="indexterm"/><a id="IDX-CHP-20-0028" class="indexterm"/></p><p>As long as the current position number is less than the total number of spots on the board <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36038"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, we continue to check tiles. If the current tile to be checked belongs to the player and also has not yet been visited <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36044"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, we’ll call <code class="literal">get-connected</code> to retrieve the cluster of hexes reachable from this spot <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36053"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Then, if the size of the cluster is larger than the best found so far <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36059"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>, we make this the new best size in our recursive call <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36066"/><img src="httpatomoreillycomsourcenostarchimages783544.png" alt=""/></span>. Otherwise, we proceed by calling <code class="literal">f</code> while keeping the previous best size <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36075"/><img src="httpatomoreillycomsourcenostarchimages783556.png" alt=""/></span>. (The best variable at this point will hold the best value found so far from previous iterations.) No matter what happens, however, the <code class="literal">pos</code> variable is incremented with every recursive call to <code class="literal">f</code>, so that we eventually cover the whole board.</p><p>Finally, we need to update <code class="literal">add-new-dice</code> to make use of our new rule for choosing the number of reinforcements:</p><a id="I_programlisting7_d1e36092"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun add-new-dice (board player spare-dice)
    (labels ((f (lst n)
              (cond ((zerop n) lst)
                  ((null lst) nil)
                  (t (let ((cur-player (caar lst))
                         (cur-dice (cadar lst)))
                     (if (and (eq cur-player player) (&lt; cur-dice *max-dice*))
                         (cons (list cur-player (1+ cur-dice))
                               (f (cdr lst) (1- n)))
                       (cons (car lst) (f (cdr lst) n))))))))
          (board-array (f (coerce board 'list)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                         (largest-cluster-size board player)))))</pre><p>As you can see, the <code class="literal">add-new-dice</code> function still receives <code class="literal">spare-dice</code> as an argument for compatibility with our old code <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36113"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, but now this argument is simply ignored. Instead, the number of reinforcements added to the board depends on the size of the largest cluster <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e36119"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Otherwise, the <code class="literal">add-new-dice</code> is identical to our previous version.</p><p>This is all the code we need to enable the new reinforcement rules. Note that, due to the design of our code, the AI player has full access to the game tree. Since the game tree now contains all of this new reinforcement data, the AI will automatically adapt its playing strategy to take into account the new reinforcement rules!</p></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion"/>Conclusion</h1></div></div></div><p>We’ve gone through quite a long trip as we’ve created the Dice of Doom game, employing an immense number of different programming techniques along the way. We’ve taken even more trips with all the other games in this book. Thanks for taking this journey with me through the world of Lisp programming!</p><p>I suggest that you take a moment to enjoy the fruits of your labor and play a few games of the fourth and final version of Dice of Doom. Again, all you need to do is serve up the Dice of Doom request handler through our web server:</p><a id="I_programlisting7_d1e36137"/><pre class="programlisting">&gt; <strong class="userinput"><code>(serve #'dod-request-handler)</code></strong></pre><p>Now you can play Dice of Doom in Firefox (again, at the address <span class="emphasis"><em>localhost:8080/game.html</em></span>) as it is meant to be played, with four players and all the new rules we’ve added in this chapter.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e36147"/><img src="httpatomoreillycomsourcenostarchimages781284.png.jpg" alt="image with no caption"/></div></div><p>Good luck with all your Dice of Doom battles and all your future Lisp programming!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e36155"/><img src="httpatomoreillycomsourcenostarchimages780634.png.jpg" alt="image with no caption"/></div></div></div>
<div class="appendix" title="Appendix&#xA0;A.&#xA0;Epilogue"><div class="titlepage"><div><div><h1 class="title"><a id="epilogue"/>Appendix A. Epilogue</h1></div></div></div><p>Now that you’ve worked your way through this book, here is one final reward: A story about the technologies behind the entire Lisp family of programming languages, set in the not-too-distant future . . .<a id="IDX-CHP-20-0029" class="indexterm"/><a id="IDX-CHP-20-0030" class="indexterm"/><a id="IDX-CHP-20-0031" class="indexterm"/><a id="IDX-CHP-20-0032" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36184"/><img src="httpatomoreillycomsourcenostarchimages781408.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36190"/><img src="httpatomoreillycomsourcenostarchimages780716.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36196"/><img src="httpatomoreillycomsourcenostarchimages780760.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36202"/><img src="httpatomoreillycomsourcenostarchimages780566.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36208"/><img src="httpatomoreillycomsourcenostarchimages780604.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36214"/><img src="httpatomoreillycomsourcenostarchimages780012.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36220"/><img src="httpatomoreillycomsourcenostarchimages783188.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36226"/><img src="httpatomoreillycomsourcenostarchimages783236.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36232"/><img src="httpatomoreillycomsourcenostarchimages782622.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36239"/><img src="httpatomoreillycomsourcenostarchimages782670.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36245"/><img src="httpatomoreillycomsourcenostarchimages782072.png.jpg" alt="image with no caption"/></div></div><div class="sect1" title="Functional Guild Cruiser"><div class="titlepage"><div><div><h1 class="title"><a id="functional_guild_cruiser"/>Functional Guild Cruiser</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp<a id="IDX-CHP-20-0033" class="indexterm"/><a id="IDX-CHP-20-0034" class="indexterm"/><a id="IDX-CHP-20-0035" class="indexterm"/><a id="IDX-CHP-20-0036" class="indexterm"/><a id="IDX-CHP-20-0037" class="indexterm"/></p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis"/>Synopsis</h2></div></div></div><p>Functional programming is a mathematical approach to programming that was pioneered by the creators of Lisp. Functional programming places certain restrictions on the programmer, but it can lead to very elegant code. When using functional programming, every variable that is used by a given function must be one of the following:<a id="IDX-CHP-20-0038" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36293"/><img src="httpatomoreillycomsourcenostarchimages782902.png" alt="image with no caption"/></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A parameter passed into that function</p></li><li class="listitem"><p>A local variable created within that function</p></li><li class="listitem"><p>A constant</p></li></ul></div><p>Also, functional programming doesn’t allow a function to have <span class="emphasis"><em>side effects</em></span>. This means a function can’t write to the disk, print messages on the screen, or do anything other than return a result. The goal is to write most of a program using “functional code,” while retaining a teensy bit of code that does any dirty, nonfunctional stuff that is still needed.<a id="IDX-CHP-20-0039" class="indexterm"/></p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs"/>How It Kills Bugs</h2></div></div></div><p>Writing code in a functional style guarantees that a function does only one thing (returns a value) and is dependent on one only thing (the parameters passed to it). This makes it very easy to debug. No matter how many times you run a function, as long as you’re passing it the same data, you will always get the same result.</p><div class="example"><a id="example"/><p class="title">Example A-1. Example</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defun unique-letters (name)
      (concatenate 'string
                   "Hello "
                   (coerce (remove-duplicates name) 'string)))

<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defun ask-and-respond ()
      (princ "What is your name?")
      (princ (unique-letters (read-line))))</pre></div></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation"/>Explanation</h2></div></div></div><p>If you enter this code into the Lisp REPL and execute <code class="literal">(ask-and-respond)</code>, you will be asked for your name, and then greeted by your name but with all duplicate letters removed. All the hard work in this function is handled by <code class="literal">unique-letters</code>, which is written in a functional style <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36348"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The dirty work of interacting with the user, which can’t be written in a purely functional way, is handled by <code class="literal">ask-and-respond</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36357"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness"/>Weakness</h2></div></div></div><p>The main weakness of functional programming is that some side effects are almost always necessary for a program to actually <span class="emphasis"><em>do</em></span> something. This means you can’t write a useful program that has the entirety of its code written in the functional style. At least a small amount of code will be nonfunctional.</p><p>Functional programming is discussed in <a class="xref" href="ch16.html" title="Chapter 14. Ramping Lisp Up a Notch with Functional Programming">Chapter 14</a>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36376"/><img src="httpatomoreillycomsourcenostarchimages782372.png.jpg" alt="image with no caption"/></div></div></div></div></div>
<div class="sect1" title="Macro Guild Melee Fighters"><div class="titlepage"><div><div><h1 class="title"><a id="macro_guild_melee_fighters"/>Macro Guild Melee Fighters</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp<a id="IDX-CHP-20-0040" class="indexterm"/></p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id1"/>Synopsis</h2></div></div></div><p><span class="emphasis"><em>True macros</em></span> are one of Lisp’s most unique and amazing features. In fact, the reason Lispers put up with all those annoying parentheses in their code is that those parentheses enable the awesome Lisp macro system.<a id="IDX-CHP-20-0041" class="indexterm"/><a id="IDX-CHP-20-0042" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36411"/><img src="httpatomoreillycomsourcenostarchimages780362.png" alt="image with no caption"/></div></div><p>True macros allow you to add new functionality to Lisp in a very fundamental way. Experienced Lispers can use macros to make their Lisp compiler/interpreter do their bidding cleanly and elegantly.</p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id1"/>How It Kills Bugs</h2></div></div></div><p>By using macros, an experienced Lisper can minimize code duplication, and better tailor the underlying language to the problem at hand. This leads to cleaner code and fewer bugs.</p><div class="example"><a id="example-id1"/><p class="title">Example A-2. Example</p><div class="example-contents"><pre class="programlisting">(defmacro three-way-if (expr a b &amp;rest c)
   (let ((val (gensym)))
       `(let ((,val ,expr))
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>          (cond ((and (numberp ,val) (zerop ,val)) ,a)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                (,val ,@c)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                (t ,b)))))</pre></div></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id1"/>Explanation</h2></div></div></div><p>Lisp macros are so powerful that you can actually write your own if-then command! The code shown here creates a macro called <code class="literal">three-way-if</code> that has three branches: one for a <code class="literal">nil</code> value <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36457"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, one for a numerical zero value <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36463"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and one for everything else <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36469"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. For most purposes, a function like this might seem stupid, but if you ever want to write a program that constantly needs to distinguish zeros from <code class="literal">nil</code>s (or needs to handle some other domain-specific headache), you’ll make your life much easier by writing a macro.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id1"/>Weakness</h2></div></div></div><p>Since Lisp macros are so powerful, there is always the danger of programmers abusing them. Overuse of macros can make it hard for other programmers to understand your code.</p><p>Macros are discussed in <a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a>.</p></div></div>
<div class="sect1" title="Restart Guild Armored Fighter"><div class="titlepage"><div><div><h1 class="title"><a id="restart_guild_armored_fighter"/>Restart Guild Armored Fighter</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp</p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id2"/>Synopsis</h2></div></div></div><p>Proper exception handling is extremely difficult. There are really only two good approaches: Don’t handle exceptions at all and just let your program die when one occurs, or handle every single exception in the most direct and specific way possible. But is it truly possible to handle every potential exception in your code? If your write Common Lisp code, it’s possible to get extremely close to this ideal goal.<a id="IDX-CHP-20-0043" class="indexterm"/><a id="IDX-CHP-20-0044" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36513"/><img src="httpatomoreillycomsourcenostarchimages782448.png" alt="image with no caption"/></div></div><p>For example, suppose you write a function that raises the prices on a list of widgets. But then, while the function is processing one of the widgets in the list, there’s a memory allocation error. You can’t prepare for this type of error ahead of time, since it could happen anywhere in a program. This makes it impossible to address using traditional exception handling methods.</p><p>Even if a function lower in the call stack catches and resolves the source of the exception, the program still faces an unsolvable problem: Some of the widget prices have been raised, while others have not. Common Lisp, however, has a mechanism for addressing this problem, called <span class="emphasis"><em>restarts</em></span>.<a id="IDX-CHP-20-0045" class="indexterm"/></p><p>In a language that supports restarts, the function that raises the widget prices can make the proclamation, “Hey everybody! If something bad happens while I’m working on my widgets, just use my restart (called <code class="literal">try-again</code>) when it’s safe for me to finish my work!” Another function, lower in the call tree, can now handle the error, and then call <code class="literal">try-again</code> to ensure that the widget prices won’t become corrupt. This allows the function to finish raising widget prices at the exact point of failure.</p><p>In fact, if you have a program that can’t afford to shut down (a web server, for example), you can still handle a surprising number of extreme exceptions in Common Lisp without ending the program. Even if the program encounters a truly exceptional exception, it can simply divert control back to the REPL. The programmer can then fix the cause of the exception, access a list of available restarts, and continue running the program on the spot.</p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id2"/>How It Kills Bugs</h2></div></div></div><p>By using restarts and the Lisp REPL, a bug can be fixed in a running program, allowing you to “hot script” long-running applications with only a negligible interruption.<a id="IDX-CHP-20-0046" class="indexterm"/></p><div class="example"><a id="example-id2"/><p class="title">Example A-3. Example</p><div class="example-contents"><pre class="programlisting">(defun raise-widget-prices (widgets)
   (when widgets
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>        (loop (restart-case (progn (raise-price (car widgets))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>                                   (return))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>                (try-again () (princ "trying again"))))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>         (raise-widget-prices (cdr widgets))))</pre></div></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id2"/>Explanation</h2></div></div></div><p>This is an implementation of a function that raises prices on a list of widgets. The actual work of raising the price of a single widget is done by the <code class="literal">raise-price</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36583"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The call to this function is protected by wrapping it in a <code class="literal">loop</code> and the <code class="literal">restart-case</code> command, which declares a restart called <code class="literal">try-again</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36599"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If the price can be raised without problems, the <code class="literal">raise-price</code> function will complete normally, the loop is interrupted with a <code class="literal">return</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36611"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, and the next item in the list of widgets is processed. On the other hand, if an error occurs while raising the price on a widget, another function (or the programmer) can attempt to fix the problem and call the <code class="literal">try-again</code> restart to retry the widget at the point of failure <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36620"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, which leads to another cycle through the <code class="literal">loop</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36630"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The function can then continue down the rest of the list, raising the prices on the remaining widgets <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36636"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>By using restarts, your code can offer multiple alternative follow-up options for coping with an exception, so that even the most exceptional exceptions can be handled appropriately.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id2"/>Weakness</h2></div></div></div><p>Even though Common Lisp has one of the most advanced exception handling systems in existence, it is still difficult to handle every exception appropriately in your code. However, restarts give you the unique ability to fix a running program and allow it to continue operating, which is usually not possible in other languages.</p><p>Restarts are discussed in <a class="xref" href="ch16.html" title="Chapter 14. Ramping Lisp Up a Notch with Functional Programming">Chapter 14</a>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36654"/><img src="httpatomoreillycomsourcenostarchimages782184.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="Generic Setter Guild Supply Ship"><div class="titlepage"><div><div><h1 class="title"><a id="generic_setter_guild_supply_ship"/>Generic Setter Guild Supply Ship</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp<a id="IDX-CHP-20-0047" class="indexterm"/><a id="IDX-CHP-20-0048" class="indexterm"/></p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id3"/>Synopsis</h2></div></div></div><p>To modify the value of a variable in Common Lisp, you use <code class="literal">setf</code>. However, this command also has an amazing special power: Instead of a variable name, you can pass it a complex Lisp expression that retrieves a value. It can then turn that expression “inside out” and use it to modify that value, rather than simply retrieve it. These types of expressions are called <span class="emphasis"><em>generic setters</em></span>.<a id="IDX-CHP-20-0049" class="indexterm"/><a id="IDX-CHP-20-0050" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36698"/><img src="httpatomoreillycomsourcenostarchimages779817.png" alt="image with no caption"/></div></div><p>Many commands besides <code class="literal">setf</code> also support generic setters. Using this feature, most types of data structures can get by without any specific “setting” functions of their own.</p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id3"/>How It Kills Bugs</h2></div></div></div><p>When you have a complicated, nested data structure, it’s often easier to understand code that retrieves data from a specific location than it is to understand code that sets a value at the same location. If you want to set a value at a specific location in a complicated structure, you usually need to work backward through the structure to figure out how to change it. But with generic setters, you can let Lisp handle the hard code for you. Having simpler code is a great way to fight bugs.</p><div class="example"><a id="example-id3"/><p class="title">Example A-4. Example</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defparameter foo (list 1 (make-hash-table) 3))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (setf (gethash 'my-key (nth foo 1)) 77)</pre></div></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id3"/>Explanation</h2></div></div></div><p>The example creates a variable named <code class="literal">foo</code>, which holds a list of three items <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36737"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The second item in the list is an empty hash table. Then it adds a key named <code class="literal">my-key</code> with a value of <code class="literal">77</code> to the table inside <code class="literal">foo</code> all at once, by putting a complex expression into <code class="literal">setf</code> that “gets at” this location <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36756"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id3"/>Weakness</h2></div></div></div><p>By mutating an existing data structure, generic setters cause a side effect, which violates one of the tenets of functional programming. This means they can’t be used when programming in a purely functional style.</p><p>Generic setters are discussed in <a class="xref" href="ch10.html" title="Chapter 9. Advanced Datatypes and Generic Programming">Chapter 9</a>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36772"/><img src="httpatomoreillycomsourcenostarchimages783056.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36778"/><img src="httpatomoreillycomsourcenostarchimages783102.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="DSL Guild Hot Rods"><div class="titlepage"><div><div><h1 class="title"><a id="dsl_guild_hot_rods"/>DSL Guild Hot Rods</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp<a id="IDX-CHP-20-0051" class="indexterm"/><a id="IDX-CHP-20-0052" class="indexterm"/></p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id4"/>Synopsis</h2></div></div></div><p>Because Lisp has such a simple syntax (everything is delimited with parentheses), it is easy to use it to build your own custom programming language, designed for a specific domain. Such <span class="emphasis"><em>domain-specific languages</em></span> (<span class="emphasis"><em>DSLs</em></span>) tend to make heavy use of the Lisp macro system. They represent an extreme form of macro programming, transforming Lisp into a completely new programming language.<a id="IDX-CHP-20-0053" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36817"/><img src="httpatomoreillycomsourcenostarchimages781109.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id4"/>Explanation</h2></div></div></div><p>This is an example of code that uses a DSL to build an HTML page. In this case, the page displays “Hello <span class="strong"><strong>World</strong></span>” in a browser, with the second word rendered in bold. The <code class="literal">html</code> and <code class="literal">body</code> commands (macros created for the HTML library in <a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a>) generate opening and closing tags that will contain the body of the page <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36838"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Then it calls the regular Lisp function <code class="literal">princ</code> to generate the text. The second word is wrapped in another custom DSL command, <code class="literal">bold</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36851"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, which generates opening and closing bold tags around the specified text.</p><div class="example"><a id="example-id4"/><p class="title">Example A-5. Example</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (html (body (princ "Hello ")
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>             (bold (princ "World!"))))</pre></div></div></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id4"/>Weakness</h2></div></div></div><p>Since DSLs are programming languages you create all by yourself, you can definitely shoot yourself in the foot if you aren’t careful. It’s easy to create code in a language that is impossible for others (and perhaps even you) to understand.</p><p><a class="xref" href="ch19.html" title="Chapter 17. Domain-Specific Languages">Chapter 17</a> discusses DSLs, including the DSL that allows you to write HTML directly inside your Lisp code, as shown in this example.</p></div></div>
<div class="sect1" title="CLOS Guild Battleship"><div class="titlepage"><div><div><h1 class="title"><a id="clos_guild_battleship"/>CLOS Guild Battleship</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Common Lisp<a id="IDX-CHP-20-0054" class="indexterm"/><a id="IDX-CHP-20-0055" class="indexterm"/><a id="IDX-CHP-20-0056" class="indexterm"/><a id="IDX-CHP-20-0057" class="indexterm"/><a id="IDX-CHP-20-0058" class="indexterm"/><a id="IDX-CHP-20-0059" class="indexterm"/><a id="IDX-CHP-20-0060" class="indexterm"/></p></dd></dl></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id5"/>Synopsis</h2></div></div></div><p>Common Lisp has the most sophisticated object-oriented programming framework of any major programming language, called the <span class="emphasis"><em>Common Lisp Object System</em></span> (<span class="emphasis"><em>CLOS</em></span>). It is customizable at a fundamental level using the <span class="emphasis"><em>Metaobject Protocol</em></span> (<span class="emphasis"><em>MOP</em></span>). There’s really nothing like it anywhere else in programming. It lets you create incredibly complex software without losing control over the code.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e36933"/><img src="httpatomoreillycomsourcenostarchimages782004.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id4"/>How It Kills Bugs</h2></div></div></div><p><span class="emphasis"><em>Object-oriented programing</em></span> (<span class="emphasis"><em>OOP</em></span>) is a commonly used technique for keeping bugs under control. By writing code in an object-oriented style, you can <span class="emphasis"><em>decouple</em></span> different parts of your code. When you decouple code, you break your code into logical components, which can be tested independently.</p><div class="example"><a id="example_1_colon_wrapping_code_around_met"/><p class="title">Example A-6. Example 1: Wrapping Code Around Methods</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defclass widget ()
      ((color :accessor widget-color
                :initarg :color)))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defmethod describe-widget ((w widget))
     (format t "this is a ˜a widget" (widget-color w)))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defmethod describe-widget :before ((w widget))
    (add-to-log "Somebody is checking on a widget"))</pre></div></div><p>The basic concepts behind object-oriented programming in Common Lisp are discussed in <a class="xref" href="ch10.html" title="Chapter 9. Advanced Datatypes and Generic Programming">Chapter 9</a>. For detailed information on the design of CLOS, I recommend reading the CLOS papers compiled at <a class="ulink" href="http://www.dreamsongs.com/CLOS.html">http://www.dreamsongs.com/CLOS.html</a>.</p></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id5"/>Explanation</h2></div></div></div><p>For this example, imagine we run a company that sells widgets, and we need some object-oriented Lisp code to help keep track of them. First, we need to create a new CLOS class (called <code class="literal">widget</code>) with <code class="literal">defclass</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e36990"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. It has one property (or <span class="emphasis"><em>slot</em></span>, in Lisp lingo) describing the widget’s color. Next, we declare a <code class="literal">describe-widget</code>, which prints out a description of the widget <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37003"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. By convention, a function designed to operate on a specific type of object is called a <span class="emphasis"><em>method</em></span>. In this case, the <code class="literal">describe-widget</code> is considered a method of the <code class="literal">widget</code> object.</p><p>Now suppose we want to write an entry to a log file every time a user checks on a widget. Using the CLOS, we can declare one or more <span class="emphasis"><em>before methods</em></span> that will automatically be called before the main <code class="literal">describe-widget</code> method is executed <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37026"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>If we didn’t have before methods available, we would need to dirty up our main widget code to add logging, like so:</p><a id="I_programlisting_d1e37034"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defmethod describe-widget ((w widget))
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (add-to-log "Somebody is checking on a widget")
    (format t "this is a ˜a widget" (widget-color w)))</pre><p>Here, we’ve added the command for logging <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37049"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span> right in the middle of the <code class="literal">describe-widget</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37058"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This code is a lot uglier, because writing to logs has nothing intrinsically to do with describing a widget. The logging in this version is also tightly coupled to the main code, which means we can no longer test the widget code independently from the debugging code. Using the before method leads to cleaner, more decoupled code.</p></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id6"/>Explanation</h2></div></div></div><p>This example demontrates <span class="emphasis"><em>multiple dispatch</em></span>, a powerful technique for writing methods that are chosen based on the types of their parameters.<a id="IDX-CHP-20-0061" class="indexterm"/></p><div class="example"><a id="example_2_colon_multiple_dispatch"/><p class="title">Example A-7. Example 2: Multiple Dispatch</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (defclass color () ())
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defclass red (color) ())
  (defclass blue (color) ())
  (defclass yellow (color) ())

<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> (defmethod mix ((c1 color) (c2 color))
      "I don't know what color that makes")

<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> (defmethod mix ((c1 blue) (c2 yellow))
    "you made green!")

<img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/> (defmethod mix ((c1 yellow) (c2 red))
    "you made orange!")</pre></div></div><p>The example begins by creating a <code class="literal">color</code> class <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37114"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and also defines three derived classes: <code class="literal">red</code>, <code class="literal">green</code>, and <code class="literal">blue</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37130"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Then we declare a <code class="literal">mix</code> method, which will tell us what happens if we mix any two colors. By default, when we mix two colors, it just says, “I don’t know what color that makes” <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37139"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. However, using multiple dispatch, <span class="emphasis"><em>we can define more versions</em></span> of the <code class="literal">mix</code> method. For instance, we can declare a version that mixes blue and yellow <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37151"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, and another version for yellow and red <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37158"/><img src="httpatomoreillycomsourcenostarchimages783510.png" alt=""/></span>. Here’s what happens when we call these methods with different colors:</p><a id="I_programlisting_d1e37164"/><pre class="programlisting">&gt; <strong class="userinput"><code>(mix (make-instance 'red) (make-instance 'blue))</code></strong>
"I don't know what color that makes"
&gt; <strong class="userinput"><code>(mix (make-instance 'yellow) (make-instance 'red))</code></strong>
"you made orange!"</pre><p>The important thing to note about the example is that in order to figure out which mix method to call in a given situation, the CLOS needs to take into account both of the objects passed into the method. It is <span class="emphasis"><em>dispatching</em></span> to a specific implementation of the method based on the types of <span class="emphasis"><em>multiple</em></span> objects. This is a feature that is not available in traditional object-oriented languages, such as Java or C++.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id5"/>Weakness</h2></div></div></div><p>Opinions vary widely in the Lisp community as to how large a role object-oriented techniques should play in programming. The critics of this style complain that object-oriented techniques force data to be hidden away in lot of disparate places by requiring them to live inside many different objects. Having data located in disparate places can make programs difficult to understand, especially if that data changes over time. Therefore, many Lispers prefer to use functional techniques over object-oriented techniques, though the two can often be used together with some care. Nonetheless, there are still many domains in which object-oriented techniques are invaluable, such as in user interface programming or simulation programming.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37186"/><img src="httpatomoreillycomsourcenostarchimages780010.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="The Continuation Guild Rocket Pods"><div class="titlepage"><div><div><h1 class="title"><a id="the_continuation_guild_rocket_pods"/>The Continuation Guild Rocket Pods</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Scheme (limited support in Common Lisp with <span class="emphasis"><em>continuation-passing style</em></span>, or through the use of special libraries)</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37206"/><img src="httpatomoreillycomsourcenostarchimages783034.png" alt="image with no caption"/></div></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id6"/>Synopsis</h2></div></div></div><p>In the 1970s, a special dialect of Lisp was created that featured a particularly powerful programming feature called <span class="emphasis"><em>continuations</em></span>. Basically, continuations let you put “time travel” into your code. This allows you to do things like run programs backward, sideways, or in other crazy ways. For instance, it’s great for implementing advanced programming techniques, such as <span class="emphasis"><em>nondeterministic programming</em></span>. In nondeterministic programming, you write code that offers the computer multiple choices for what to do next. If one choice isn’t satisfactory, the computer can “roll back time” with continuations to try a different path.<a id="IDX-CHP-20-0062" class="indexterm"/><a id="IDX-CHP-20-0063" class="indexterm"/><a id="IDX-CHP-20-0064" class="indexterm"/><a id="IDX-CHP-20-0065" class="indexterm"/></p><div class="example"><a id="example-id5"/><p class="title">Example A-8. Example</p><div class="example-contents"><pre class="programlisting">(define continuation null)

<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (define (foo n)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>    (* (call-with-current-continuation
           (lambda (c)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>             (set! continuation c)
              (+ n 1)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>      2))</pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This example is in the Scheme Lisp dialect and won’t run in Common Lisp.</p></div></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id5"/>How It Kills Bugs</h2></div></div></div><p>There are many situations where having time travel in your code can make the code easier to understand. The classic example is in a web server. Often, a person must visit several pages on a web page in order to perform a single action. With a continuation-aware web server, you can write code that pretends these pages were visited all at the same time, making your code a lot less buggy. Later on, the web server uses continuations to break your code into several parts (by using the time-travel abilities of continuations), taking care of all the ugly details of handling a multipage web action.<a id="IDX-CHP-20-0066" class="indexterm"/></p></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id7"/>Explanation</h2></div></div></div><p>In the example, we create a simple function called <code class="literal">foo</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37288"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, which adds one to a number, and then doubles it. For instance, running <code class="literal">(foo 7)</code> will return <code class="literal">16</code>. However, inside the function, there is a call to <code class="literal">call-with-current-continuation</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37304"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, which captures the state of the function before the doubling step. It saves this “moment in time” in the variable <code class="literal">continuation</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37313"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. The current state of the running program is captured at this line <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37319"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Everything that happens <span class="emphasis"><em>after</em></span> the continuation was captured will then be executed if we call the captured continuation. The only part of the <code class="literal">foo</code> command that happens after the continuation was captured is the multiplication by two <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37332"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Consequently, the variable <code class="literal">continuation</code> is now a time machine that we can use to jump into this past moment to switch out the number we want to double with another one. So, if we were to now call <code class="literal">(continuation 100)</code>, it would return 200 (which is 100 doubled). We have traveled backward in time!</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id6"/>Weakness</h2></div></div></div><p>Continuations are such an awesome feature that they don’t really have a downside. The only real problem they present is for creators of programming languages. True continuations are technically difficult to put into a programming language, so few languages support them. Scheme happens to be one of them. To learn more about continuation-based web servers, see “Implementation and Use of the PLT Scheme Web Server”by Shriram Krishnamurthi, et al.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37350"/><img src="httpatomoreillycomsourcenostarchimages782118.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37356"/><img src="httpatomoreillycomsourcenostarchimages782166.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37362"/><img src="httpatomoreillycomsourcenostarchimages781552.png.jpg" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37368"/><img src="httpatomoreillycomsourcenostarchimages781592.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="Brevity Guild Micro Fighter"><div class="titlepage"><div><div><h1 class="title"><a id="brevity_guild_micro_fighter"/>Brevity Guild Micro Fighter</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Arc Lisp (indirectly available in Common Lisp using custom macros)<a id="IDX-CHP-20-0067" class="indexterm"/><a id="IDX-CHP-20-0068" class="indexterm"/><a id="IDX-CHP-20-0069" class="indexterm"/><a id="IDX-CHP-20-0070" class="indexterm"/></p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37399"/><img src="httpatomoreillycomsourcenostarchimages779769.png.jpg" alt="image with no caption"/></div></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id7"/>Synopsis</h2></div></div></div><p>Lisp allows you to write code that is incredibly concise but doesn’t look like your cat walked over your keyboard. (I’m looking at you, Perl!) This is possible because of the various features we’ve already mentioned, such as macros, functional programming, and Lisp’s dynamic typing system.</p><p>There is one Lisp dialect, however, that takes this idea to the extreme: Arc. In fact, code brevity is the primary design goal for this language. Paul Graham, the designer of Arc, analyzed large amounts of computer code in an attempt to figure out which primitive commands are needed to write code that is as concise as possible, while keeping the code readable.</p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id6"/>How It Kills Bugs</h2></div></div></div><p>With Arc, the goal is to write programs that are short. It is designed to let you say what you want to say in the most concise way possible, leaving no place for bugs to hide.</p><div class="example"><a id="example-id6"/><p class="title">Example A-9. Example</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (accum a
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   (for n 1 1000
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>        (unless (some [is 0 (mod n _)] (range 2 (- n 1)))
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>            a.n)))</pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This example is in the Arc Lisp dialect and won’t run in Common Lisp.<a id="IDX-CHP-20-0071" class="indexterm"/></p></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id8"/>Explanation</h2></div></div></div><p>This example creates a list of all prime numbers between 1 and 1000, using the naïve method of checking for smaller numbers that divide evenly into the current loop value.</p><p>The <code class="literal">accum</code> function creates a local function named <code class="literal">a</code>, which is used to collect any primes that are found <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37463"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. We iterate through the integers with a <code class="literal">for</code> loop <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37472"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, checking for smaller numbers that divide evenly into the current value of <code class="literal">i</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37482"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If none are are found, <code class="literal">i</code> is added to the list of primes <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37491"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>, by calling the function <code class="literal">a</code> with this new number. The brackets, <code class="literal">[ ]</code>, are a shortcut for creating a lambda function with one parameter, which is accessed with the underscore character.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id7"/>Weakness</h2></div></div></div><p>Finding an optimally concise set of commands is difficult. With too many commands available, your code can become hard to understand, since it’s difficult to remember what each function does. With too few commands, programs can get too bulky. Arc Lisp tries to find a happy medium, although there’s still room for alternative language designs optimized for code brevity.</p><p><a class="xref" href="ch18.html" title="Chapter 16. The Magic of Lisp Macros">Chapter 16</a> demonstrates how to use macros to make your code concise, and many other examples of Lisp’s powers of brevity are shown in the chapters following that discussion.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37512"/><img src="httpatomoreillycomsourcenostarchimages781032.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="Multicore Guild Formation Fighters"><div class="titlepage"><div><div><h1 class="title"><a id="multicore_guild_formation_fighters"/>Multicore Guild Formation Fighters</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Lisp Dialect</strong></span></span></dt><dd><p>Clojure Lisp (available in Common Lisp with the CL-STM extension)<a id="IDX-CHP-20-0072" class="indexterm"/><a id="IDX-CHP-20-0073" class="indexterm"/><a id="IDX-CHP-20-0074" class="indexterm"/></p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37540"/><img src="httpatomoreillycomsourcenostarchimages783054.png" alt="image with no caption"/></div></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id8"/>Synopsis</h2></div></div></div><p>Now that most computers have multiple cores, there is a lot of interest in finding elegant ways to write multicore/multithreaded code. One popular approach is to use functional data structures along with a <span class="emphasis"><em>software transactional memory</em></span> system.<a id="IDX-CHP-20-0075" class="indexterm"/><a id="IDX-CHP-20-0076" class="indexterm"/></p><p>Using software transactional memory, you can share complex data structures between several threads, with a guarantee that no thread will see inconsistent information in the data, even if it tries to read shared data while another thread is attempting to write to it.</p></div><div class="sect2" title="How It Fights Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_fights_bugs"/>How It Fights Bugs</h2></div></div></div><p>Multithreaded code tends to be very buggy. By using software transactional memory, you can greatly increase your odds of writing bug-free multithreaded software.</p></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id9"/>Explanation</h2></div></div></div><p>In this example, we define two bank accounts called <code class="literal">checking</code> and <code class="literal">savings</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37579"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, with a total amount of $300 between them. We then define a <code class="literal">transfer-to-savings</code> function, which can be called to move money from the <code class="literal">checking</code> account to the <code class="literal">savings</code> account <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37595"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><div class="example"><a id="example-id7"/><p class="title">Example A-10. Example</p><div class="example-contents"><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (def checking (ref 100))
  (def savings (ref 200))

<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (defn transfer-to-savings [n]
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>       (dosync (alter checking - n)
                (alter savings + n)))</pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This example is in the Clojure Lisp dialect and won’t run in Common Lisp.</p></div><p>Because this function contains a <code class="literal">dosync</code> block, Clojure will make sure these two <code class="literal">alter</code> operations <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37634"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span> happen at the same moment in time. Of course, both values aren’t really altered at the exact same point in time, but the language makes sure it will appear to happen simultaneously. If another thread were to read these two accounts at the same time, also within a <code class="literal">dosync</code> block, it would see exactly $300 in the combined accounts, no matter how many times either thread checks these values.</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id8"/>Weakness</h2></div></div></div><p>Software transactional memory carries a performance penalty that cancels out some of the performance gains that come with using multiple CPU cores. However, as the number of CPU cores increases, this penalty is less of an issue.</p></div></div>
<div class="sect1" title="The Lazy Guild Frigate"><div class="titlepage"><div><div><h1 class="title"><a id="the_lazy_guild_frigate"/>The Lazy Guild Frigate</h1></div></div></div><div class="sect2" title="Lisp Dialect"><div class="titlepage"><div><div><h2 class="title"><a id="lisp_dialect"/>Lisp Dialect</h2></div></div></div><p>Clojure (available in Common Lisp with the Series library, CLAZY library, or custom macros)<a id="IDX-CHP-20-0077" class="indexterm"/><a id="IDX-CHP-20-0078" class="indexterm"/><a id="IDX-CHP-20-0079" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37671"/><img src="httpatomoreillycomsourcenostarchimages783350.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Synopsis"><div class="titlepage"><div><div><h2 class="title"><a id="synopsis-id9"/>Synopsis</h2></div></div></div><p>A lazy programming language will perform a calculation <span class="emphasis"><em>only</em></span> if the compiler determines it is absolutely necessary to produce a visible result. Clojure is the most popular Lisp dialect to include lazy programming as a primary feature. However, limited forms of lazy programming are common in all Lisp dialects.</p></div><div class="sect2" title="How It Kills Bugs"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_kills_bugs-id7"/>How It Kills Bugs</h2></div></div></div><p>Lazy languages let you create infinitely big data structures (as long as you don’t try to use <span class="emphasis"><em>all</em></span> of the data), which allows more of your code to be formulated as transformations of large data structures. In general, it is easier to debug data structures than it is to debug algorithms. Algorithms involve steps that unfold over time, and to understand them, you usually need to watch them as they execute. Data, on the other hand, exists independently of time, which means you can find bugs in a data structure just by looking at it.</p><div class="example"><a id="example-id8"/><p class="title">Example A-11. Example</p><div class="example-contents"><pre class="programlisting">(take 20<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (filter even?<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> (iterate inc 0)<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>))</pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This example is in the Clojure Lisp dialect and won’t run in Common Lisp.</p></div></div><div class="sect2" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="explanation-id10"/>Explanation</h2></div></div></div><p>This code returns the first 20 even positive integers. To do this, it first creates an infinite list of all positive integers <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37723"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, using the <code class="literal">iterate</code> function to create a list of integers starting at zero. Then it filters out the even numbers <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37732"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Finally, it takes the first 20 numbers from that result <span class="inlinemediaobject"><a id="I_inlinemediaobject_d1e37738"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Until the final <code class="literal">take</code> command, the data structures being operated on are theoretically infinite. However, since Clojure is a lazy language, it instantiates these data structures only on an as-needed basis. This means that only the first 20 such numbers are ever generated. (And even then, they are generated only if we actually use the final value somehow, such as printing it to the screen.)</p></div><div class="sect2" title="Weakness"><div class="titlepage"><div><div><h2 class="title"><a id="weakness-id9"/>Weakness</h2></div></div></div><p>Since a lazy programming language chooses the order in which your code is run, it can lead to debugging headaches if you try to trace your code as it is running.</p><p><a class="xref" href="ch20.html" title="Chapter 18. Lazy Programming">Chapter 18</a> discusses lazy programming.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e37756"/><img src="httpatomoreillycomsourcenostarchimages782876.png.jpg" alt="image with no caption"/></div></div></div></div></body></html>