["```\n  1 /***********************************************\n  2  * bit_test -- Test out our new high speed     *\n  3  *      bit_array.                             *\n  4  ***********************************************/\n  5 #include <iostream>\n  6 #include <memory.h>\n  7\n  8 // The size of a fast bit_array.\n  9 // (Private to fast bit array)\n 10 const int BIT_ARRAY_MAX = 64;   // Size in bits\n 11\n 12 // Number of bits in a byte\n 13 const int BITS_PER_BYTE = 8;\n 14 /************************************************\n 15  * fast_bit_array -- A bit array using fast    *\n 16  * allocate technology.                         *\n 17  *                                              *\n 18  * Member functions:                            *\n 19  *      get -- Get an element from the          *\n 20  *              array.                          *\n 21  *      set -- Set the value of an element      *\n 22  *              in the array.                   *\n 23  *                                              *\n 24  *      new -- used to quickly allocate a bit   *\n 25  *              array.                          *\n 26  *      delete -- used to quickly deallocate    *\n 27  *                      a bit array.            *\n 28  ************************************************/\n 29 class fast_bit_array\n 30 {\n 31     protected:\n 32         // Array data\n 33         unsigned char\n 34             data[BIT_ARRAY_MAX/BITS_PER_BYTE];\n 35\n 36     public:\n 37         fast_bit_array(void)\n 38         {\n 39            memset(data, '\\0', sizeof(data));\n 40         }\n 41         // Destructor defaults\n 42     private:\n 43         // No copy constructor\n 44         fast_bit_array(const fast_bit_array &);\n 45\n 46         // No assignment operator\n 47         fast_bit_array & operator =\n 48             (const fast_bit_array &);\n 49     public:\n 50         // Set the value on an item\n 51         void set(\n 52             // Index into the array\n 53             const unsigned int index,\n 54\n 55             // Value to put in the array\n 56             const unsigned int value\n 57         )\n 58         {\n 59             // Index into the bit in the byte\n 60             unsigned int bit_index = index % 8;\n 61\n 62             // Byte in the array to use\n 63             unsigned int byte_index = index / 8;\n 64\n 65             if (value)\n 66             {\n 67                 data[byte_index] |=\n 68                     (1 << bit_index);\n 69             }\n 70             else\n 71             {\n 72                 data[byte_index] &=\n 73                     ~(1 << bit_index);\n 74             }\n 75         }\n 76         // Return the value of an element\n 77         int get(unsigned int index)\n 78         {\n 79             // Index into the bit in the byte\n 80             unsigned int bit_index = index % 8;\n 81             // Byte in the array to use\n 82             unsigned int byte_index = index / 8;\n 83\n 84             return (\n 85                 (data[byte_index] &\n 86                        (1 << bit_index)) != o);\n 87        }\n 88        // Allocate a new fast_bit_array\n 89        void *operator new(const size_t);\n 90\n 91        // Delete a fast bit array.\n 92        void operator delete(void *ptr);\n 93 };\n 94\n 95 /************************************************\n 96  * The following routines handle the local      *\n 97  * new/delete for the fast_bit_array.           *\n 98  ************************************************/\n 99 // Max number of fast_bit_arrays we can use at once\n100 const int N_FAST_BIT_ARRAYS = 30;\n101\n102 // If true, the bit array slot is allocated\n103 // false indicates a free slot\n104 static bool\n105     bit_array_used[N_FAST_BIT_ARRAYS] = {false};\n106\n107 // Space for our fast bit arrays.\n108 static char\n109     bit_array_mem[N_FAST_BIT_ARRAYS]\n110                 [sizeof(fast_bit_array)];\n111\n112 // Handle new for \"fast_bit_array\".\n113 // (This is much quicker than the\n114 //      system version of new)\n115 /************************************************\n116  * fast_bit_array -- new                        *\n117  *                                              *\n118  * This is a high speed allocation routine for  *\n119  * the fast_bit_array class.   The method used  *\n120  * for this is simple, but we know that only    *\n121  * a few bit_arrays will be allocated.          *\n122  *                                              *\n123  * Returns a pointer to the new memory.         *\n124  ************************************************/\n125 void *fast_bit_array::operator new(const size_t)\n126 {\n127     int i;      // Index into the bit array slots\n128\n129     // Look for a free slot\n130     for (i = 0; i < N_FAST_BIT_ARRAYS; ++i)\n131     {\n132         if (!bit_array_used[i])\n133         {\n134             // Free slot found, allocate the space\n135             bit_array_used[i] = true;\n136             return(bit_array_mem[i]);\n137         }\n138     }\n139     std::cout << \"Error: Out of local memory\\n\";\n140     exit (8);\n141 }\n142\n143 /************************************************\n144  * fast_bit_array -- delete                     *\n145  *                                              *\n146  * Quickly free the space used by a             *\n147  * fast bit array.                              *\n148  ************************************************/\n149 void fast_bit_array::operator delete(\n150     void *ptr   // Pointer to the space to return\n151 )\n152 {\n153     int i;      // Slot index\n154\n155     for (i = 0; i < N_FAST_BIT_ARRAYS; ++i)\n156     {\n157         // Is this the right slot\n158         if (ptr == bit_array_mem[i])\n159         {\n160             // Right slot, free it\n161             bit_array_used[i] = false;\n162             return;\n163         }\n164     }\n165     std::cout <<\n166         \"Error: Freed memory we didn't have\\n\";\n167     exit (8);\n168 }\n169\n170\n171 /************************************************\n172  * safe_bit_array -- A safer bit array.         *\n173  *                                              *\n174  * Like bit array, but with error checking.     *\n175  ************************************************/\n176 class safe_bit_array : public fast_bit_array\n177 {\n178     public:\n179         // Sequence number generator\n180         static int bit_array_counter;\n181\n182         // Our bit array number\n183         int sequence;\n184\n185         safe_bit_array(void)\n186         {\n187             sequence = bit_array_counter;\n188             ++bit_array_counter;\n189         };\n190         // Destructor defaults\n191     private:\n192         // No copy constructor\n193         safe_bit_array(const safe_bit_array &);\n194\n195         // No assignment operator\n196         safe_bit_array & operator = (\n197                 const safe_bit_array &);\n198     public:\n199         // Set the value on an item\n200         void set(\n201             // Where to put the item\n202             const unsigned int index,\n203             // Item to put\n204             const unsigned int value\n205         )\n206         {\n207             if (index >= (BIT_ARRAY_MAX-1))\n208             {\n209                 std::cout <<\n210                    \"Bit array set error \"\n211                    \"for bit array #\"\n212                    << sequence << \"\\n\";\n213                 exit (8);\n214             }\n215             fast_bit_array::set(index, value);\n216         }\n217         // Return the value of an element\n218         int get(unsigned int index)\n219         {\n220             if (index >= (BIT_ARRAY_MAX-1))\n221             {\n222                 std::cout <<\n223                    \"Bit array get error \"\n224                    \"for bit array #\"\n225                    << sequence << \"\\n\";\n226                 exit (8);\n227             }\n228             return (fast_bit_array::get(index));\n229         }\n230 };\n231\n232 // Sequence information\n233 int safe_bit_array::bit_array_counter = 0;\n234\n235 int main()\n236 {\n237     // Create a nice new safe bit array\n238     safe_bit_array *a_bit_array =\n239         new safe_bit_array;\n240\n241     a_bit_array->set(5, 1);\n242     // Return the bit_array to the system\n243     delete a_bit_array;\n244     return (0); 245 }\n\n```"]