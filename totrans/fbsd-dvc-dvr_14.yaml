- en: Chapter 14. Common Access Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Common Access Method (CAM)* is an ANSI standard. Although primarily used for
    SCSI, CAM is a method for separating host bus adapter (HBA) drivers from storage
    drivers. HBAs are devices (that is, a card or integrated circuit) that connect
    the host to other devices. For example, USB HBAs allow the host to communicate
    with USB devices.'
  prefs: []
  type: TYPE_NORMAL
- en: By separating HBA drivers from storage drivers, CAM reduces the complexity of
    individual drivers. Furthermore, this separation enables storage drivers (such
    as CD-ROM and tape drivers) to control their devices on anyI/O bus (such as IDE,
    SCSI, and so on) as long as an appropriate HBA driver is available. In other words,
    CAM modularizes HBA and storage drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In CAM vernacular, HBA drivers are known as software interface modules (SIMs),
    and storage drivers are known as peripheral modules. Incidentally, the storage
    drivers discussed in [Chapter 13](ch13.html "Chapter 13. Storage Drivers") are
    not under CAM. To avoid confusion, I’ll refer to storage drivers under CAM as
    peripheral modules from now on.
  prefs: []
  type: TYPE_NORMAL
- en: The FreeBSD CAM implementation contains SIMs for SCSI Parallel Interface (SPI),
    Fibre Channel (FC), USB Mass Storage (UMASS), FireWire (IEEE 1394), and Advanced
    Technology Attachment Packet Interface (ATAPI). It has peripheral modules for
    disks (`da`), CD-ROMs (`cd`), tapes (`sa`), tape changers (`ch`), processor type
    devices (`pt`), and enclosure services (`ses`). Also, it provides a “pass-through”
    interface that allows user applications to send I/O requests directly to any CAM-controlled
    device (McKusick and Neville-Neil, 2005). This interface is, fundamentally, a
    SIM (as you’ll soon see).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn how to manage HBAs using CAM. Of course, before
    you can do that, you’ll need to know how CAM interfaces peripheral modules with
    SIMs. Because peripheral modules are just storage drivers with some CAM-related
    code, they’re only briefly discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How CAM Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CAM is most easily understood by tracing an I/O request through it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-1](ch14.html#the_path_of_an_i_solidus_o_request_throu "Figure 14-1. The
    path of an I/O request through the CAM subsystem"),^([[9](#ftn.CHP-14-FN-1)])
    the kernel passes a block-centric I/O request to the `da(4)` peripheral module.
    As you would expect, this causes `da(4)`’s strategy routine (`dastrategy`) to
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: '![The path of an I/O request through the CAM subsystem](httpatomoreillycomsourcenostarchimages1137519.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1. The path of an I/O request through the CAM subsystem
  prefs: []
  type: TYPE_NORMAL
- en: The `dastrategy` function gets the block-centric I/O request and inserts it
    on the appropriate block I/O queue via `bioq_disksort`. It concludes by calling
    the `xpt_schedule` function. (The `da(4)` peripheral module supports every SCSI
    disk. Consequently, it manages multiple block I/O queues.)
  prefs: []
  type: TYPE_NORMAL
- en: The `xpt_schedule` function, by and large, schedules a peripheral module to
    receive a *CAM Control Block (CCB)*. A CCB describes the location (or path) to
    the target device (that is, the intended recipient of the I/O request). The `xpt_schedule`
    function concludes by calling the `xpt_run_dev_allocq` function. (Note that my
    definition of CCB isn’t complete. I’ll expand this definition throughout this
    chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: The `xpt_run_dev_allocq` function allocates and constructs a CCB. Afterward,
    it calls the peripheral module’s start routine (`dastart` in this example).
  prefs: []
  type: TYPE_NORMAL
- en: The `dastart` function takes the first block-centric I/O request off the appropriate
    block I/O queue and converts that into a SCSI command. This command is stored
    in the CCB constructed by `xpt_run_dev_allocq`. The `dastart` function ends by
    calling the `xpt_action` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `xpt_action` function uses the path information stored in the CCB to determine
    the SIM to which the SCSI command should be sent. It then calls that SIM’s action
    routine (`ahc_action` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A SIM was pseudo-randomly chosen for this example, so the fact that it’s `ahc(4)`
    is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: The `ahc_action` function gets the CCB and translates the SCSI command into
    a hardware-specific command. This hardware-specific command is then passed to
    the device to be executed. Afterward, `ahc_action` returns back to the caller
    of `dastrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the device completes the hardware-specific command (which may involve
    DMA), it sends an interrupt, which causes `ahc(4)`’s done routine (`ahc_done`)
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The `ahc_done` function appends the completion status (that is, successful or
    unsuccessful) to the CCB related to the completed hardware-specific command. It
    then calls the `xpt_done` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `xpt_done` function gets the completed CCB and sets it up for processing
    by `camisr`, the CAM interrupt service routine. It then schedules `camisr` to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely speaking, the `camisr` function carries out some “housekeeping” on the
    CCB. It ends by calling the CCB’s specified completion function (`dadone` in this
    example).
  prefs: []
  type: TYPE_NORMAL
- en: The `dadone` function, more or less, tells the kernel that the block-centric
    I/O request has been serviced by calling `biodone`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#CHP-14-FN-1)]) [Figure 14-1](ch14.html#the_path_of_an_i_solidus_o_request_throu
    "Figure 14-1. The path of an I/O request through the CAM subsystem") is adapted
    from *The Design and Implementation of the FreeBSD Operating System* by Marshall
    Kirk McKusick and George V. Neville-Neil (Addison-Wesley, 2005).
  prefs: []
  type: TYPE_NORMAL
- en: A (Somewhat) Simple Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’re familiar with the CAM subsystem, let’s work through some code.
    After that, I’ll detail the different CAM-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 14-1](ch14s02.html#mfi_underscore_cam.c "Example 14-1. mfi_cam.c")
    is a SIM for a pseudo-HBA (taken from the `mfi(4)` code base).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1. mfi_cam.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following sections describe the functions defined in [Example 14-1](ch14s02.html#mfi_underscore_cam.c
    "Example 14-1. mfi_cam.c") roughly in the order they would execute.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, because ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `mfip_probe` is extremely rudimentary and because we’ve examined similar code
    elsewhere, I’ll omit discussing it.
  prefs: []
  type: TYPE_NORMAL
- en: mfip_attach Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `mfip_attach` function is the `device_attach` implementation for this driver.
    Here is its function definition (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function first calls ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `cam_simq_alloc` to allocate a SIM queue. Loosely speaking, *SIM queues* ensure
    that HBAs cannot be swamped by I/O requests. See, I/O requests from peripheral
    modules are housed on SIM queues to await service. When a queue becomes full,
    any additional requests are rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, ![](httpatomoreillycomsourcenostarchimages1137501.png) `cam_sim_alloc`
    is called to allocate a SIM (or bus) descriptor. Note that if an HBA implements
    multiple buses (or channels), each bus requires its own descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, ![](httpatomoreillycomsourcenostarchimages1137503.png) `xpt_bus_register`
    takes the descriptor returned by `cam_sim_alloc` and registers it with the CAM
    subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: mfip_detach Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `mfip_detach` function is the `device_detach` implementation for this driver.
    Here is its function definition (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    deregistering and ![](httpatomoreillycomsourcenostarchimages1137501.png) freeing
    its SIM descriptor. Afterward, its SIM queue is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    freed.
  prefs: []
  type: TYPE_NORMAL
- en: mfip_action Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mfip_action` function is defined in `mfip_attach` as the action routine
    (for verification, see the first argument to `cam_sim_alloc`). *Action routines*
    are executed every time a SIM receives a CCB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that a CCB houses an I/O request (or command) to perform along with the
    identity of the target device (that is, the intended recipient of the I/O request).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, `mfip_action` is akin to the `ahc_action` function shown in
    [Figure 14-1](ch14.html#the_path_of_an_i_solidus_o_request_throu "Figure 14-1. The
    path of an I/O request through the CAM subsystem"). Here is its function definition
    (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most action routines simply take a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    CCB and ![](httpatomoreillycomsourcenostarchimages1137501.png) branch according
    to the `ccb_h.func_code` variable, which denotes the I/O operation to perform.
  prefs: []
  type: TYPE_NORMAL
- en: For now, I’m going to focus on the structure of `mfip_action` and avoid its
    specifics. An in-depth explanation of `mfip_action` appears in [Action Routines](ch14s04.html
    "Action Routines") in [xpt_bus_register Function](ch14s03.html#xpt_underscore_bus_underscore_register
    "xpt_bus_register Function").
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this function can perform one of six I/O operations: it can
    ![](httpatomoreillycomsourcenostarchimages1137503.png) return the SIM and HBA
    properties, reset a ![](httpatomoreillycomsourcenostarchimages1137505.png) bus
    or ![](httpatomoreillycomsourcenostarchimages1137507.png) device, ![](httpatomoreillycomsourcenostarchimages1137509.png)
    get or ![](httpatomoreillycomsourcenostarchimages1137511.png) set the transfer
    settings, or ![](httpatomoreillycomsourcenostarchimages1137513.png) issue a SCSI
    command to a device.'
  prefs: []
  type: TYPE_NORMAL
- en: mfip_poll Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mfip_poll` function is defined in `mfip_attach` as the poll routine (for
    verification, see the second argument to `cam_sim_alloc`). Customarily, *poll
    routines* wrap a SIM’s interrupt handler. See, when interrupts are unavailable
    (for example, after a kernel panic) the CAM subsystem will use poll routines to
    run its interrupt handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the function definition for `mfip_poll` (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because this SIM does not implement an interrupt handler, `mfip_poll` just ![](httpatomoreillycomsourcenostarchimages1137499.png)
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: mfip_start Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mfip_start` function transforms a SCSI command into a hardware-specific
    command. This function is called exclusively by `mfi_startio`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mfi_startio` function is defined in *mfi.c* (which is not described in
    this book). `mfi_startio` is called by `mfip_action` (described in [mfip_action
    Function](ch14s02.html#mfip_underscore_action_function "mfip_action Function")
    in [mfip_action Function](ch14s02.html#mfip_underscore_action_function "mfip_action
    Function")) to issue a SCSI command to a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function definition for `mfip_start` (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function is fairly straightforward—it’s just a bunch of
    assignments. Until we’ve examined `struct ccb_scsiio` and `struct ccb_hdr`, which
    occurs in [XPT_SCSI_IO](ch14s04.html#xpt_underscore_scsi_underscore_io "XPT_SCSI_IO")
    in [XPT_SCSI_IO](ch14s04.html#xpt_underscore_scsi_underscore_io "XPT_SCSI_IO"),
    I’m going to postpone walking through this function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that ![](httpatomoreillycomsourcenostarchimages1137499.png) `mfip_done`
    is set as the done routine for the hardware-specific command.
  prefs: []
  type: TYPE_NORMAL
- en: mfip_done Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As implied previously, the `mfip_done` function is the done routine for this
    SIM. It is executed by `mfi_intr` immediately after a device completes a hardware-specific
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mfi_intr` function is `mfi(4)`’s interrupt handler. It is defined in *mfi.c*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, `mfip_done` is akin to the `ahc_done` function shown in [Figure 14-1](ch14.html#the_path_of_an_i_solidus_o_request_throu
    "Figure 14-1. The path of an I/O request through the CAM subsystem"). Here is
    its function definition (again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Commonly, done routines take a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    hardware-specific command and append the completion status (that is, successful
    or unsuccessful) to its associated ![](httpatomoreillycomsourcenostarchimages1137501.png)
    ![](httpatomoreillycomsourcenostarchimages1137503.png) ![](httpatomoreillycomsourcenostarchimages1137505.png)
    ![](httpatomoreillycomsourcenostarchimages1137507.png) ![](httpatomoreillycomsourcenostarchimages1137509.png)
    CCB. Once this is done, ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `xpt_done` is called to process the completed CCB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mfi(4)` code base uses DMA to acquire the completion status from a device.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with [Example 14-1](ch14s02.html#mfi_underscore_cam.c
    "Example 14-1. mfi_cam.c"), I’ll expound on the different functions, structures,
    and constructs it employs.
  prefs: []
  type: TYPE_NORMAL
- en: SIM Registration Routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As alluded to previously, registering a SIM with the CAM subsystem involves
    three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cam_simq_alloc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cam_sim_alloc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xpt_bus_register`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cam_simq_alloc Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cam_simq_alloc` function allocates a SIM queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `max_sim_transactions` denotes the size of the SIM queue. Normally, it
    is calculated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: cam_sim_alloc Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cam_sim_alloc` function allocates a SIM (or bus) descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an HBA implements multiple buses (or channels), each bus requires its own
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because the first six arguments to `cam_sim_alloc` are fairly obvious—they’re
    exactly what their name implies—I’ll omit discussing them.
  prefs: []
  type: TYPE_NORMAL
- en: The `max_dev_transactions` argument specifies the maximum number of concurrent
    transactions per device. This argument applies only to devices that do not support
    SCSI Tagged Command Queuing (SCSI TCQ). Generally, `max_dev_transactions` is always
    set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `max_tagged_dev_transactions` argument is identical to `max_dev_transactions`,
    but it applies only to devices that support SCSI TCQ.
  prefs: []
  type: TYPE_NORMAL
- en: The `queue` argument expects a pointer to a SIM queue (that is, `cam_simq_alloc`’s
    return value).
  prefs: []
  type: TYPE_NORMAL
- en: xpt_bus_register Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `xpt_bus_register` function registers a SIM with the CAM subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sim` specifies the SIM to register (that is, `cam_sim_alloc`’s return
    value) and `bus` denotes its bus number. The `parent` argument is currently unused.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an HBA implements multiple buses (or channels), each bus needs its own unique
    bus number.
  prefs: []
  type: TYPE_NORMAL
- en: Action Routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, action routines are executed every time a SIM receives
    a CCB. You can think of action routines like the “main function” for a SIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function prototype for an action routine (taken from the `<cam/cam_sim.h>`
    header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Recall that action routines `switch` according to the `ccb->ccb_h.func_code`
    variable, which contains a constant that symbolizes the I/O operation to perform.
    For the rest of this chapter, I’ll detail the most common constants/operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the complete list of constants/operations, see the `xpt_opcode` enumeration
    defined in the `<cam/cam_ccb.h>` header.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_PATH_INQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `XPT_PATH_INQ` constant specifies a path inquiry operation, which returns
    the SIM and HBA properties. Action routines that are passed `XPT_PATH_INQ` simply
    fill in a `ccb_pathinq` structure and then return.
  prefs: []
  type: TYPE_NORMAL
- en: '`struct ccb_pathinq` is defined in the `<cam/cam_ccb.h>` header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example `XPT_PATH_INQ` operation (taken from [Example 14-1](ch14s02.html#mfi_underscore_cam.c
    "Example 14-1. mfi_cam.c")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `ccb_pathinq` structure is provided by the ![](httpatomoreillycomsourcenostarchimages1137499.png)
    CCB. Moreover, notice that the ![](httpatomoreillycomsourcenostarchimages1137503.png)
    success or ![](httpatomoreillycomsourcenostarchimages1137507.png) failure of any
    operation is returned in ![](httpatomoreillycomsourcenostarchimages1137501.png)
    ![](httpatomoreillycomsourcenostarchimages1137505.png) `ccb_h.status`.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_RESET_BUS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `XPT_RESET_BUS` constant specifies a bus reset operation. As you’d expect,
    `XPT_RESET_BUS` is horrifically hardware specific. Here is a minimalist implementation
    (taken from [Example 14-1](ch14s02.html#mfi_underscore_cam.c "Example 14-1. mfi_cam.c")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `sim` is the bus
    to reset. Unsurprisingly, minimalist implementations forgo any “real” work and
    simply return ![](httpatomoreillycomsourcenostarchimages1137501.png) success.
  prefs: []
  type: TYPE_NORMAL
- en: Many SIMs use a minimalist implementation. A “proper” implementation is out
    of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_GET_TRAN_SETTINGS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `XPT_GET_TRAN_SETTINGS` constant denotes an I/O operation that returns the
    current transfer settings or the user-defined upper limits. Action routines that
    are passed `XPT_GET_TRAN_SETTINGS` simply fill in a `ccb_trans_settings` structure
    and then return.
  prefs: []
  type: TYPE_NORMAL
- en: '`struct ccb_trans_settings` is defined in `<cam/cam_ccb.h>` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `ccb_trans_settings` marshals a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    protocol structure and five ![](httpatomoreillycomsourcenostarchimages1137501.png)
    transport-specific structures. These structures are defined in `<cam/cam_ccb.h>`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example `XPT_GET_TRAN_SETTINGS` operation (taken from [Example 14-1](ch14s02.html#mfi_underscore_cam.c
    "Example 14-1. mfi_cam.c")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the ![](httpatomoreillycomsourcenostarchimages1137501.png) `ccb_trans_settings`
    structure is provided by the ![](httpatomoreillycomsourcenostarchimages1137499.png)
    CCB. Naturally, only the fields applicable to the HBA are filled in.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_SET_TRAN_SETTINGS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’d expect, `XPT_SET_TRAN_SETTINGS` is the opposite of `XPT_GET_TRAN_SETTINGS`.
    That is, `XPT_SET_TRAN_SETTINGS` changes the current transfer settings based on
    a `ccb_trans_settings` structure. Unsurprisingly, not all SIMs support this operation.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function states that `XPT_SET_TRAN_SETTINGS` is ![](httpatomoreillycomsourcenostarchimages1137499.png)
    not available. Note that a “proper” implementation is hardware specific and not
    covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_SCSI_IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `XPT_SCSI_IO` constant denotes an I/O operation that issues a SCSI command
    to a device. The particulars of this SCSI command are stored in two structures:
    `ccb_scsiio` and `ccb_hdr`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct ccb_scsiio` is defined in `<cam/cam_ccb.h>` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`struct ccb_hdr` is also defined in `<cam/cam_ccb.h>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`struct ccb_hdr` should seem familiar—it’s used to return the ![](httpatomoreillycomsourcenostarchimages1137499.png)
    completion status in every I/O operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example `XPT_SCSI_IO` operation (taken from [Example 14-1](ch14s02.html#mfi_underscore_cam.c
    "Example 14-1. mfi_cam.c")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This operation begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    checking that the SCSI command length is acceptable. Then it determines whether
    the SCSI command uses ![](httpatomoreillycomsourcenostarchimages1137503.png) physical
    addresses or ![](httpatomoreillycomsourcenostarchimages1137507.png) scatter/gather
    segments to ![](httpatomoreillycomsourcenostarchimages1137501.png) transfer data.
    If either is used, this operation ![](httpatomoreillycomsourcenostarchimages1137505.png)
    ![](httpatomoreillycomsourcenostarchimages1137509.png) exits (as it’s received
    invalid arguments). Then `ccb_h->ccb_mfip_ptr` is ![](httpatomoreillycomsourcenostarchimages1137511.png)
    set to the software context and `mfi_startio` is ![](httpatomoreillycomsourcenostarchimages1137513.png)
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mfi_startio` function is what actually issues the SCSI command.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [mfip_start Function](ch14s02.html#mfip_underscore_start_function
    "mfip_start Function") in [mfip_poll Function](ch14s02.html#mfip_underscore_poll_function
    "mfip_poll Function") that `mfi_startio` calls `mfip_start` to transform the SCSI
    command into a hardware-specific command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `struct ccb_hdr` lists the target’s ![](httpatomoreillycomsourcenostarchimages1137499.png)
    device ID and ![](httpatomoreillycomsourcenostarchimages1137501.png) logical unit
    number. It also lists whether the SCSI command transfers data ![](httpatomoreillycomsourcenostarchimages1137513.png)
    in, ![](httpatomoreillycomsourcenostarchimages1137515.png) out, or ![](httpatomoreillycomsourcenostarchimages1137517.png)
    nothing. Note that `XPT_SCSI_IO` operations are seen from the SIM’s point of view.
    Therefore, “in” means from the device, and “out” means to the device.
  prefs: []
  type: TYPE_NORMAL
- en: The `ccb_scsiio` structure maintains the ![](httpatomoreillycomsourcenostarchimages1137509.png)
    data to transfer and its ![](httpatomoreillycomsourcenostarchimages1137511.png)
    length. It also maintains the SCSI command (through a ![](httpatomoreillycomsourcenostarchimages1137503.png)
    pointer or a ![](httpatomoreillycomsourcenostarchimages1137507.png) buffer) and
    the command’s ![](httpatomoreillycomsourcenostarchimages1137505.png) length.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once more, the hardware-specific command constructed above is issued to the
    target device via `mfi_startio`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that as soon as a device completes a hardware-specific command, it sends
    an interrupt, which causes the done routine (`mfip_done` in this case) to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if the hardware-specific command ![](httpatomoreillycomsourcenostarchimages1137499.png)
    returns an error, the ![](httpatomoreillycomsourcenostarchimages1137503.png) error
    information (or sense data) is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    copied to the `ccb_scsiio` structure’s ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `sense_data` field.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the game, the unexplained parts of this function should be
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: XPT_RESET_DEV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `XPT_RESET_DEV` constant specifies a device reset operation. Unsurprisingly,
    `XPT_RESET_DEV` is fairly hardware specific. Here is a simple `XPT_RESET_DEV`
    operation (taken from *bt.c*):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *bt.c* source file is part of the `bt(4)` code base.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Given that a hardware-specific command must be issued to reset this device,
    `XPT_RESET_DEV` simply ![](httpatomoreillycomsourcenostarchimages1137499.png)
    cascades into `XPT_SCSI_IO`.
  prefs: []
  type: TYPE_NORMAL
- en: While not shown here, it should be stressed that all operations conclude by
    appending their completion status to their CCB and then calling `xpt_done(ccb)`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrated heavily on HBA drivers, or SIMs, because they’re the
    most commonly written CAM-related driver. Of course, there’s more to CAM than
    what’s been shown here. You could conceivably write an entire book on CAM!
  prefs: []
  type: TYPE_NORMAL
