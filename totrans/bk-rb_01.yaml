- en: Chapter 1. Strings, Numbers, Classes, and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing to know about Ruby is that it’s easy to use. To prove this,
    let’s look at the code of the traditional “Hello world” program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1helloworld.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That’s it in its entirety. The program contains one method, `puts`, and one
    string, “hello world.” It doesn’t have any headers or class definitions, and it
    doesn’t have any import sections or “main” functions. This really is as simple
    as it gets. Load the code, *1helloworld.rb*, and try it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Putting Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having “put” a string to the output (here, a command window), the obvious next
    step is to “get” a string. As you might guess, the Ruby method for this is `gets`.
    The *2helloname.rb* program prompts the user for his or her name—let’s suppose
    it’s Fred—and then displays a greeting: “Hello Fred.” Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2helloname.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although this is still very simple, a few important details need to be explained.
    First, notice that I’ve used `print` rather than `puts` to display the prompt.
    This is because `puts` adds a line feed at the end of the printed string, whereas
    `print` does not; in this case, I want the cursor to remain on the same line as
    the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line, I use `gets()` to read in a string when the user presses enter.
    This string is assigned to the variable `name`. I have not predeclared this variable,
    nor have I specified its type. In Ruby, you can create variables as and when you
    need them, and the interpreter “infers” their types. In the example, I have assigned
    a string to `name` so Ruby knows that the type of the `name` variable must be
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ruby is case sensitive. A variable called `myvar` is different from one called
    `myVar`. A variable such as `name` in the sample project must begin with a lowercase
    character. If it begins with an uppercase character, Ruby will treat it as a constant.
    I’ll have more to say on constants in [Chapter 6](ch06.html "Chapter 6. Conditional
    Statements").
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the parentheses following `gets()` are optional, as are the parentheses
    enclosing the strings after `print` and `puts`; the code would run just the same
    if you removed them. However, parentheses can help resolve ambiguities, and in
    some cases, the interpreter will warn you if you omit them.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Embedded Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last line in the sample code is rather interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `name` variable is embedded into the string. You do this by placing
    the variable between two curly brackets preceded by a *hash mark* (or “number”
    or “pound” character), as in `#{}`. This kind of *embedded* evaluation works only
    with strings delimited by double quotes. If you were to try this with a string
    delimited by single quotes, the variable would not be evaluated, and the string
    `''Hello #{name}''` would be displayed exactly as entered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also embed nonprinting characters such as newlines (`"\n"`) and tabs
    (`"\t"`), and you can even embed bits of program code and mathematical expressions.
    For instance, let’s assume you have a method called `showname` that returns the
    string “Fred.” The following string would, in the process of evaluation, call
    the `showname` method and display “Hello Fred”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'See whether you can figure out what would be displayed by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3string_eval.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now run the *3string_eval.rb* program to see whether you are right.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numbers are just as easy to use as strings. For example, let’s suppose you
    want to calculate the selling price or grand total of some item based on its pretax
    value or subtotal. To do this, you would need to multiply the subtotal by the
    applicable tax rate and add the result to the value of the subtotal. Assuming
    the subtotal to be $100 and the tax rate to be 17.5 percent, this Ruby program
    does the calculation and displays the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '*4calctax.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this program would be more useful if it could perform calculations
    on a variety of subtotals rather than calculating the same value time after time!
    Here is a simple calculator that prompts the user to enter a subtotal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here `s.to_f` is a method of the String class. It attempts to convert the string
    to a floating-point number. For example, the string `"145.45"` would be converted
    to the floating-point number 145.45\. If the string cannot be converted, 0.0 is
    returned. For instance, `"Hello world".to_f` would return 0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the source code examples that come with this book are documented with
    comments that are ignored by the Ruby interpreter. You can place a comment after
    the hash mark (`#`). The text on a line following this character is all treated
    as a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to comment out multiple lines of text, you can place `=begin` at
    the start and `=end` at the end (both `=begin` and `=end` must be flush with the
    left margin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing a Condition: if..then'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with the simple tax calculator code shown earlier is that it accepts
    negative subtotals and calculates negative tax on them—a situation upon which
    the government is unlikely to look favorably! I therefore need to check for negative
    numbers and, when found, set them to zero. This is my new version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*5taxcalculator.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby `if` test is similar to an `if` test in other programming languages.
    Note, however, that the parentheses are once again optional, as is the keyword
    `then`. However, if you were to write the following, with no line break after
    the test condition, the `then` would be obligatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Putting everything on one line like this adds nothing to the clarity of the
    code, which is why I tend to avoid it. My long familiarity with Pascal instinctively
    makes me want to add a `then` after the `if` condition, but because this really
    is not required, you may look upon this as a willful eccentricity of mine. The
    `end` keyword that terminates the `if` block is *not* optional. If you forget
    to add it, your code will not run.
  prefs: []
  type: TYPE_NORMAL
- en: Local and Global Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, I assigned values to variables such as `subtotal`,
    `tax`, and `taxrate`. Variables such as these that begin with a lowercase character
    are called *local variables*. This means they exist only within a specific part
    of a program—in other words, they are restricted to a well-defined scope. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*variables.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, there are two functions (or *methods*), `amethod` and
    `anotherMethod`, each of which is declared using the keyword `def` and contains
    code up to the keyword `end`. There are three local variables called `localvar`.
    One is assigned the value `"hello"` within the “main scope” of the program; two
    others are assigned integers within the scope of two separate methods. Since each
    local variable has a different scope, the assignments have no effect on the other
    local variables with the same name in different scopes. You can verify this by
    calling the methods in turn. The following examples show output in comments followed
    by the `=>` characters. In this book, output or returned values will often be
    indicated in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a *global variable*—one that begins with the dollar sign
    character (`$`)—has global scope. When an assignment is made to a global variable
    inside a method, that affects the value of that variable elsewhere in the program
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of going through all the rest of Ruby’s syntax—its types, loops, modules,
    and so on—let’s move rapidly on and look at how to create classes and objects.
    (But fear not, we’ll return to those other topics soon.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic Terminology: Classes, Objects, and Methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'A class is the blueprint for an object. It defines the data an object contains
    and the way it behaves. Many different objects can be created from a single class.
    So, you might have one Cat *class* but three cat *objects*: tiddles, cuddles,
    and flossy. A *method* is like a function or subroutine that is defined inside
    the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem like no big deal to say that Ruby is object-oriented. Aren’t all
    languages these days? Well, up to a point. Most modern “object-oriented” languages
    (Java, C++, C#, Object Pascal, and so on) have a greater or lesser degree of object-oriented
    programming (OOP) features. Ruby, on the other hand, is obsessively object-oriented.
    In fact, unless you have programmed in Smalltalk or Eiffel (languages that are
    even more obsessive than Ruby about objects), it is likely to be the most object-oriented
    language you have ever used. Every chunk of data—from a simple number or string
    to something more complicated like a file or a module—is treated as an object.
    And almost everything you do with an object is done by a method. Even operators
    such as plus (`+`) and minus (`−`) are methods. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here `+` is a method of the Fixnum (Integer) object 1\. The value 2 is sent
    to this method; the result, 3, is returned, and this is assigned to the object
    x. Incidentally, the assignment operator (`=`) is one of the rare exceptions to
    the rule that “everything you do with an object is done by a method.” The assignment
    operator is a special built-in “thingummy” (this is not the formal terminology,
    I hasten to add), and it is not a method of anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’ll see how to create objects of your own. As in most other OOP languages,
    a Ruby object is defined by a class. The class is like a blueprint from which
    individual objects are constructed. For example, this class defines a dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '*6dogs.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the class definition begins with the keyword `class` (all lowercase)
    and the name of the class itself, which must begin with an uppercase letter. The
    class contains a method called `set_name`. This takes an incoming argument, `aName`.
    The body of the method assigns the value of `aName` to a variable called `@myname`.
  prefs: []
  type: TYPE_NORMAL
- en: Instance Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables beginning with the at sign (`@`) are *instance variables*, which
    means they belong to individual objects (or *instances*) of the class. It is not
    necessary to predeclare instance variables. I can create instances of the Dog
    class (that is, “dog objects”) by calling the `new` method. Here I am creating
    two dog objects (note that although class names begin with uppercase letters,
    object names begin with lowercase letters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, these two dogs have no names. So, the next thing I do is call
    the `set_name` method to give them names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving Data from an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having given each dog a name, I need to have some way to find out their names
    later. How should I do this? I can’t poke around inside an object to get at the
    `@name` variable, since the internal details of each object are known only to
    the object itself. This is a fundamental principle of “pure” object orientation:
    The data inside each object is private. There are precisely defined ways into
    each object (for example, the method `set_name`) and precisely defined ways out.
    Only the object itself can mess around with its internal state; the outside world
    cannot. This is called *data hiding*, and it is part of the principle of *encapsulation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: '*Encapsulation* describes the fact that an object contains both its own data
    and the methods required to manipulate that data. Some object-oriented languages
    encourage or enforce *data hiding* so that the data encapsulated within an object
    cannot be accessed by code outside that object. In Ruby, data hiding is not quite
    as rigorously enforced as it initially appears. You can use some very dirty tricks
    to mess around inside an object, but to keep things simple, I’ll silently pass
    over these features of the language for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you need each dog to know its own name, let’s provide the Dog class with
    a `get_name` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `return` keyword here is optional. When it is omitted, Ruby methods will
    return the last expression evaluated. However, for the sake of clarity—and to
    avoid unexpected results from methods more complex than this one—I will make a
    habit of explicitly returning any values that I plan to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s give the dog some behavior by asking it to talk. Here is the
    finished class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a dog, name it, display its name, and ask it to talk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I’ve written an expanded version of this code in the *6dogs.rb* program. This
    also contains a Cat class that is similar to the Dog class except that its `talk`
    method, naturally enough, returns a *meow* instead of a *woof*.
  prefs: []
  type: TYPE_NORMAL
- en: What Happens When a Variable Is Unassigned?
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! It seems that this program contains an error. The object named `someotherdog`
    never has a value assigned to its `@name variable` since its `set_name()` method
    is never called. This means the following code, which attempts to print its name,
    cannot succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, Ruby doesn’t blow up when you try to display this dog’s name. Instead,
    it just prints “nil.” You’ll shortly look at a simple way of making sure that
    errors like this don’t happen again.
  prefs: []
  type: TYPE_NORMAL
- en: Messages, Methods, and Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This cats and dogs example, incidentally, is based on a classic Smalltalk demo
    program that illustrates how the same “message” (such as `talk`) can be sent to
    different objects (such as cats and dogs), and each different object responds
    differently to the same message with its own special method (here the `talk` method).
    The ability to have different classes containing methods with the same name goes
    by the fancy object-oriented name of *polymorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: When you run a program such as *6dogs.rb*, the code is executed in sequence.
    The code of the classes themselves is not executed until instances of those classes
    (that is, objects) are created by the code at the bottom of the program. You will
    see that I frequently mix class definitions with “free-standing” bits of code
    that execute when the program is run. This may not be the way you would want to
    write a major application, but for just trying things, it is extremely convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Free-Standing Bits of Code?
  prefs: []
  type: TYPE_NORMAL
- en: 'If Ruby is really an object-oriented language, you may think it’s odd that
    you can enter “free-floating” methods. In fact, when you run a program, Ruby creates
    a main object, and any code that appears inside your main code unit—that is, the
    main Ruby code file you have loaded and run—is actually running inside that object.
    You can easily verify this by creating a new source file and adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: One obvious defect of this program is that the two classes, Cat and Dog, are
    highly repetitious. It would make more sense to have one class, Animal, that has
    `get_name` and `set_name` methods and two descendant classes, Cat and Dog, that
    contain only the behavior specific to that species of animal (woofing or meowing).
    We’ll find out how to do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors: new and initialize'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at another example of a user-defined class. Load *7treasure.rb*.
    This is an adventure game in the making. It contains two classes, Thing and Treasure.
    The Thing class is similar to the Cat and Dog classes from the previous program—except
    that it doesn’t woof or meow, that is.
  prefs: []
  type: TYPE_NORMAL
- en: '*7treasure.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Treasure class doesn’t have `get_name` and `set_name` methods. Instead,
    it contains a method named `initialize`, which takes two arguments. Those two
    values are then assigned to the `@name` and `@description` variables. When a class
    contains a method named `initialize`, it will be called automatically when an
    object is created using the `new` method. This makes it a convenient place to
    set the values of an object’s instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: This has two clear benefits over setting each instance variable using methods
    such `set_name`. First, a complex class may contain numerous instance variables,
    and you can set the values of all of them with the single `initialize` method
    rather than with many separate “set” methods; second, if the variables are all
    automatically initialized at the time of object creation, you will never end up
    with an “empty” variable (like the “nil” value returned when you tried to display
    the name of someotherdog in the previous program).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I have created a method called `to_s`, which returns a string representation
    of a Treasure object. The method name, `to_s`, is not arbitrary—the same method
    name is used throughout the standard Ruby object hierarchy. In fact, the `to_s`
    method is defined for the Object class itself, which is the ultimate ancestor
    of all other classes in Ruby (with the exception of the BasicObject class, which
    you’ll look at more closely in the next chapter). By redefining the `to_s` method,
    I have added new behavior that is more appropriate to the Treasure class than
    the default method. In other words, I have *overridden* its `to_s` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `new` method creates an object, it can be thought of as the object’s
    *constructor*. A constructor is a method that allocates memory for an object and
    then executes the `initialize` method, if it exists, to assign any specified values
    to the new object’s internal variables. You should not normally implement your
    own version of the `new` method. Instead, when you want to perform any “setup”
    actions, do so in the `initialize` method.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage Collection
  prefs: []
  type: TYPE_NORMAL
- en: In many languages (such as C++ and Delphi for Win32), it is the programmer’s
    responsibility to destroy any object that has been created when it is no longer
    required. In other words, objects are given *destructors* as well as constructors.
    This isn’t necessary in Ruby, since a built-in *garbage collector* automatically
    destroys objects and reclaims the memory they used when they are no longer referenced
    in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice that in the *7treasure.rb* program I “looked inside” the Treasure object
    t1 using the `inspect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inspect` method is defined for all Ruby objects. It returns a string containing
    a human-readable representation of the object. In the present case, it displays
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This begins with the class name, Treasure. This is followed by a number, which
    may be different from the number shown earlier—this is Ruby’s internal identification
    code for this particular object. Next the names and values of the object’s variables
    are shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby also provides the `p` method as a shortcut to inspect objects and print
    their details, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'where `anobject` can be any type of Ruby object. For example, let’s suppose
    you create the following three objects: a string, a number, and a Treasure object:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `p` to display those objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what Ruby displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To see how you can use `to_s` with a variety of objects and test how a Treasure
    object would be converted to a string in the absence of an overridden `to_s` method,
    try the *8to_s.rb* program.
  prefs: []
  type: TYPE_NORMAL
- en: '*8to_s.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will see, classes such as Class, Object, String, and Treasure simply
    return their names when the `to_s` method is called. An object, such as the Treasure
    object t, returns its identifier—which is the same identifier returned by the
    `inspect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although the *7treasure.rb* program may lay the foundations for a game containing
    a variety of different object types, its code is still repetitive. After all,
    why have a Thing class that contains a name and a Treasure class that also contains
    a name? It would make more sense to regard a Treasure as a “type of” Thing. In
    a complete game, other objects such as Rooms and Weapons might be yet other types
    of Thing. It is clearly time to start working on a proper class hierarchy, which
    is what you will do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
