["```\ntypedef int d_ioctl_t(struct cdev *dev, u_long cmd, caddr_t data,\n                      int fflag, struct thread *td);\n```", "```\nstatic int\necho_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n        int error = 0;\n\n        switch (cmd) {\n      case ECHO_CLEAR_BUFFER:\n                memset(echo_message->buffer, '\\0',\n                    echo_message->buffer_size);\n                echo_message->length = 0;\n                uprintf(\"Buffer cleared.\\n\");\n                break;\n      case ECHO_SET_BUFFER_SIZE:\n                error = echo_set_buffer_size(*(int *)data);\n                if (error == 0)\n                        uprintf(\"Buffer resized.\\n\");\n                break;\n      default:\n                error = ENOTTY;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n#define _IO(g,n)        _IOC(IOC_VOID,  (g), (n), 0)\n#define _IOR(g,n,t)     _IOC(IOC_OUT,   (g), (n), sizeof(t))\n#define _IOW(g,n,t)     _IOC(IOC_IN,    (g), (n), sizeof(t))\n#define _IOWR(g,n,t)    _IOC(IOC_INOUT, (g), (n), sizeof(t))\n```", "```\n#define FOO_DO_SOMETHING        _IO('F', 1)\n#define FOO_GET_SOMETHING       _IOR('F', 2, int)\n#define FOO_SET_SOMETHING       _IOW('F', 3, int)\n#define FOO_SWITCH_SOMETHING    _IOWR('F', 10, struct foo)\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/malloc.h>\n  #include <sys/ioccom.h>\n\n  MALLOC_DEFINE(M_ECHO, \"echo_buffer\", \"buffer for echo driver\");\n\n #define ECHO_CLEAR_BUFFER       _IO('E', 1)\n #define ECHO_SET_BUFFER_SIZE    _IOW('E', 2, int)\n\n  static d_open_t         echo_open;\n  static d_close_t        echo_close;\n  static d_read_t         echo_read;\n  static d_write_t        echo_write;\n  static d_ioctl_t        echo_ioctl;\n\n  static struct cdevsw echo_cdevsw = {\n          .d_version =    D_VERSION,\n          .d_open =       echo_open,\n          .d_close =      echo_close,\n          .d_read =       echo_read,\n          .d_write =      echo_write,\n        .d_ioctl =      echo_ioctl,\n          .d_name =       \"echo\"\n  };\n\n  typedef struct echo {\n        int buffer_size;\n          char *buffer;\n          int length;\n  } echo_t;\n\n  static echo_t *echo_message;\n  static struct cdev *echo_dev;\n\n  static int\n  echo_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n  {\n          uprintf(\"Opening echo device.\\n\");\n          return (0);\n  }\n\n  static int\n  echo_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n  {\n          uprintf(\"Closing echo device.\\n\");\n          return (0);\n  }\n\n  static int\n  echo_write(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int error = 0;\n          int amount;\n\n          amount = MIN(uio->uio_resid,\n              (echo_message->buffer_size - 1 - uio->uio_offset > 0) ?\n               echo_message->buffer_size - 1 - uio->uio_offset : 0);\n          if (amount == 0)\n                  return (error);\n\n          error = uiomove(echo_message->buffer, amount, uio);\n          if (error != 0) {\n                  uprintf(\"Write failed.\\n\");\n                  return (error);\n          }\n\n          echo_message->buffer[amount] = '\\0';\n          echo_message->length = amount;\n\n          return (error);\n  }\n\n  static int\n  echo_read(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int error = 0;\n          int amount;\n\n          amount = MIN(uio->uio_resid,\n              (echo_message->length - uio->uio_offset > 0) ?\n               echo_message->length - uio->uio_offset : 0);\n\n          error = uiomove(echo_message->buffer + uio->uio_offset, amount, uio);\n          if (error != 0)\n                  uprintf(\"Read failed.\\n\");\n\n          return (error);\n  }\n\n  static int\n  echo_set_buffer_size(int size)\n  {\n          int error = 0;\n\n          if (echo_message->buffer_size == size)\n                  return (error);\n\n          if (size >= 128 && size <= 512) {\n                  echo_message->buffer = realloc(echo_message->buffer, size,\n                      M_ECHO, M_WAITOK);\n                  echo_message->buffer_size = size;\n\n                  if (echo_message->length >= size) {\n                          echo_message->length = size - 1;\n                          echo_message->buffer[size - 1] = '\\0';\n                  }\n          } else\n                  error = EINVAL;\n\n          return (error);\n  }\n\n  static int\n  echo_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n          int error = 0;\n\n          switch (cmd) {\n          case ECHO_CLEAR_BUFFER:\n                  memset(echo_message->buffer, '\\0',\n                      echo_message->buffer_size);\n                  echo_message->length = 0;\n                  uprintf(\"Buffer cleared.\\n\");\n                  break;\n          case ECHO_SET_BUFFER_SIZE:\n                  error = echo_set_buffer_size(*(int *)data);\n                  if (error == 0)\n                          uprintf(\"Buffer resized.\\n\");\n                  break;\n          default:\n                  error = ENOTTY;\n                  break;\n          }\n\n          return (error);\n  }\n\n  static int\n  echo_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  echo_message = malloc(sizeof(echo_t), M_ECHO, M_WAITOK);\n                  echo_message->buffer_size = 256;\n                  echo_message->buffer = malloc(echo_message->buffer_size,\n                      M_ECHO, M_WAITOK);\n                  echo_dev = make_dev(&echo_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                      0600, \"echo\");\n                  uprintf(\"Echo driver loaded.\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  destroy_dev(echo_dev);\n                  free(echo_message->buffer, M_ECHO);\n                  free(echo_message, M_ECHO);\n                  uprintf(\"Echo driver unloaded.\\n\");\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  DEV_MODULE(echo, echo_modevent, NULL);\n```", "```\nstatic int\necho_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n        int amount;\n\n        amount = MIN(uio->uio_resid,\n          (echo_message->buffer_size - 1 - uio->uio_offset > 0) ?\n            echo_message->buffer_size - 1 - uio->uio_offset : 0);\n        if (amount == 0)\n                return (error);\n\n        error = uiomove(echo_message->buffer, amount,\n uio);\n        if (error != 0) {\n                uprintf(\"Write failed.\\n\");\n                return (error);\n        }\n\n        echo_message->buffer[amount] = '\\0';\n        echo_message->length = amount;\n\n        return (error);\n}\n```", "```\nstatic int\necho_set_buffer_size(int size)\n{\n        int error = 0;\n\n      if (echo_message->buffer_size == size)\n              return (error);\n\n        if (size >= 128 && size <= 512) {\n                echo_message->buffer = realloc(echo_message->buffer, size,\n                    M_ECHO, M_WAITOK);\n              echo_message->buffer_size = size;\n\n              if (echo_message->length >= size) {\n                        echo_message->length = size - 1;\n                        echo_message->buffer[size - 1] = '\\0';\n                }\n        } else\n                error = EINVAL;\n\n        return (error);\n}\n```", "```\nstatic int\necho_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n        int error = 0;\n\n        switch (cmd) {\n      case ECHO_CLEAR_BUFFER:\n                memset(echo_message->buffer, '\\0',\n                    echo_message->buffer_size);\n                echo_message->length = 0;\n                uprintf(\"Buffer cleared.\\n\");\n                break;\n      case ECHO_SET_BUFFER_SIZE:\n                error = echo_set_buffer_size(*(int *)data);\n                if (error == 0)\n                        uprintf(\"Buffer resized.\\n\");\n                break;\n        default:\n                error = ENOTTY;\n                break;\n        }\n\n        return (error);\n}\n```", "```\nstatic int\necho_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n        switch (event) {\n        case MOD_LOAD:\n                echo_message = malloc(sizeof(echo_t), M_ECHO, M_WAITOK);\n                echo_message->buffer_size = 256;\n                echo_message->buffer = malloc(echo_message->buffer_size,\n                    M_ECHO, M_WAITOK);\n                echo_dev = make_dev(&echo_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, \"echo\");\n                uprintf(\"Echo driver loaded.\\n\");\n                break;\n        case MOD_UNLOAD:\n                destroy_dev(echo_dev);\n                free(echo_message->buffer, M_ECHO);\n                free(echo_message, M_ECHO);\n                uprintf(\"Echo driver unloaded.\\n\");\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n$ `sudo kldload ./echo-3.0.ko`\nEcho driver loaded.\n$ `su`\nPassword:\n# `echo \"DON'T PANIC\" > /dev/echo`\nOpening echo device.\nClosing echo device.\n# `cat /dev/echo`\nOpening echo device.\nDON'T PANIC\nClosing echo device.\n```", "```\n#include <sys/ioctl.h>\n\nint\nioctl(int d, unsigned long request, ...);\n```", "```\n#include <sys/types.h>\n  #include <sys/ioctl.h>\n\n  #include <err.h>\n  #include <fcntl.h>\n  #include <limits.h>\n  #include <stdio.h>\n  #include <stdlib.h>\n  #include <unistd.h>\n\n #define ECHO_CLEAR_BUFFER       _IO('E', 1)\n #define ECHO_SET_BUFFER_SIZE    _IOW('E', 2, int)\n\n  static enum {UNSET, CLEAR, SETSIZE} action = UNSET;\n\n  /*\n   * The usage statement: echo_config -c | -s size\n   */\n\n  static void\n  usage()\n  {\n          /*\n           * Arguments for this program are \"either-or.\" That is,\n           * 'echo_config -c' and 'echo_config -s size' are valid; however,\n           * 'echo_config -c -s size' is invalid.\n           */\n\n          fprintf(stderr, \"usage: echo_config -c | -s size\\n\");\n          exit(1);\n  }\n\n  /*\n   * This program clears or resizes the memory buffer\n   * found in /dev/echo.\n   */\n\n  int\n  main(int argc, char *argv[])\n  {\n          int ch, fd, i, size;\n          char *p;\n\n          /*\n           * Parse the command-line argument list to determine\n           * the correct course of action.\n           *\n           *    -c:      clear the memory buffer\n           *    -s size: resize the memory buffer to size.\n           */\n\n          while ((ch = getopt(argc, argv, \"cs:\")) != âˆ’1)\n                  switch (ch) {\n                  case 'c':\n                          if (action != UNSET)\n                                  usage();\n                          action = CLEAR;\n                          break;\n                  case 's':\n                          if (action != UNSET)\n                                  usage();\n                          action = SETSIZE;\n                          size = (int)strtol(optarg, &p, 10);\n                          if (*p)\n                                  errx(1, \"illegal size -- %s\", optarg);\n                          break;\n                  default:\n                          usage();\n                  }\n\n          /*\n           * Perform the chosen action.\n           */\n\n          if (action == CLEAR) {\n                  fd = open(\"/dev/echo\", O_RDWR);\n                  if (fd < 0)\n                          err(1, \"open(/dev/echo)\");\n\n                  i = ioctl(fd, ECHO_CLEAR_BUFFER, NULL);\n                  if (i < 0)\n                          err(1, \"ioctl(/dev/echo)\");\n\n                  close (fd);\n          } else if (action == SETSIZE) {\n                  fd = open(\"/dev/echo\", O_RDWR);\n                  if (fd < 0)\n                          err(1, \"open(/dev/echo)\");\n\n                  i = ioctl(fd, ECHO_SET_BUFFER_SIZE, &size);\n                  if (i < 0)\n                          err(1, \"ioctl(/dev/echo)\");\n\n                  close (fd);\n          } else\n                  usage();\n\n          return (0);\n  }\n```", "```\n$ `sudo cat /dev/echo`\nOpening echo device.\nDON'T PANIC\nClosing echo device.\n$ `sudo ./echo_config -c`\nOpening echo device.\nBuffer cleared.\nClosing echo device.\n$ `sudo cat /dev/echo`\nOpening echo device.\nClosing echo device.\n```", "```\n$ `sudo ./echo_config -s 128`\nOpening echo device.\nBuffer resized.\nClosing echo device.\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n  #include <sys/sysctl.h>\n\n  static long  a = 100;\n  static int   b = 200;\n  static char *c = \"Are you suggesting coconuts migrate?\";\n\n  static struct sysctl_ctx_list clist;\n  static struct sysctl_oid *poid;\n\n  static int\n sysctl_pointless_procedure(SYSCTL_HANDLER_ARGS)\n  {\n          char *buf = \"Not at all. They could be carried.\";\n          return (sysctl_handle_string(oidp, buf, strlen(buf), req));\n  }\n\n  static int\n  pointless_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  sysctl_ctx_init(&clist);\n\n                  poid = SYSCTL_ADD_NODE(&clist,\n                      SYSCTL_STATIC_CHILDREN(/* tree top */), OID_AUTO,\n                      \"example\", CTLFLAG_RW, 0, \"new top-level tree\");\n                  if (poid == NULL) {\n                          uprintf(\"SYSCTL_ADD_NODE failed.\\n\");\n                          return (EINVAL);\n                  }\n                  SYSCTL_ADD_LONG(&clist, SYSCTL_CHILDREN(poid), OID_AUTO,\n                      \"long\", CTLFLAG_RW, &a, \"new long leaf\");\n                  SYSCTL_ADD_INT(&clist, SYSCTL_CHILDREN(poid), OID_AUTO,\n                      \"int\", CTLFLAG_RW, &b, 0, \"new int leaf\");\n\n                  poid = SYSCTL_ADD_NODE(&clist, SYSCTL_CHILDREN(poid),\n                      OID_AUTO, \"node\", CTLFLAG_RW, 0,\n                      \"new tree under example\");\n                  if (poid == NULL) {\n                          uprintf(\"SYSCTL_ADD_NODE failed.\\n\");\n                          return (EINVAL);\n                  }\n                  SYSCTL_ADD_PROC(&clist, SYSCTL_CHILDREN(poid), OID_AUTO,\n                      \"proc\", CTLFLAG_RD, 0, 0, sysctl_pointless_procedure,\n                      \"A\", \"new proc leaf\");\n\n                  poid = SYSCTL_ADD_NODE(&clist,\n                      SYSCTL_STATIC_CHILDREN(_debug), OID_AUTO, \"example\",\n                      CTLFLAG_RW, 0, \"new tree under debug\");\n                  if (poid == NULL) {\n                          uprintf(\"SYSCTL_ADD_NODE failed.\\n\");\n                          return (EINVAL);\n                  }\n                  SYSCTL_ADD_STRING(&clist, SYSCTL_CHILDREN(poid), OID_AUTO,\n                      \"string\", CTLFLAG_RD, c, 0, \"new string leaf\");\n\n                  uprintf(\"Pointless module loaded.\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  if (sysctl_ctx_free(&clist)) {\n                          uprintf(\"sysctl_ctx_free failed.\\n\");\n                          return (ENOTEMPTY);\n                  }\n                  uprintf(\"Pointless module unloaded.\\n\");\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  static moduledata_t pointless_mod = {\n          \"pointless\",\n          pointless_modevent,\n          NULL\n  };\n\n  DECLARE_MODULE(pointless, pointless_mod, SI_SUB_EXEC, SI_ORDER_ANY);\n```", "```\nexample.long\n```", "```\nexample.long\nexample.int\n```", "```\nexample.long\nexample.int\nexample.node\n```", "```\nexample.long\nexample.int\nexample.node.proc\n```", "```\ndebug.example\nexample.long\nexample.int\nexample.node.proc\n```", "```\ndebug.example.string\nexample.long\nexample.int\nexample.node.proc\n```", "```\n$ `sudo kldload ./pointless.ko`\nPointless module loaded.\n$ `sysctl -A | grep example`\ndebug.example.string: Are you suggesting coconuts migrate?\nexample.long: 100\nexample.int: 200\nexample.node.proc: Not at all. They could be carried.\n```", "```\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nint\nsysctl_ctx_init(struct sysctl_ctx_list *clist);\n```", "```\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nint\nsysctl_ctx_free(struct sysctl_ctx_list *clist);\n```", "```\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nstruct sysctl_oid *\nSYSCTL_ADD_OID(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int kind, void *arg1, int arg2, int (*handler) (SYSCTL_HANDLER_ARGS),\n    const char *format, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_NODE(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, int (*handler) (SYSCTL_HANDLER_ARGS), const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_STRING(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, char *arg, int len, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_INT(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, int *arg, int len, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_UINT(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, unsigned int *arg, int len, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_LONG(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, long *arg, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_ULONG(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, unsigned long *arg, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_OPAQUE(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, void *arg, int len, const char *format,\n    const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_STRUCT(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, void *arg, STRUCT_NAME, const char *descr);\n\nstruct sysctl_oid *\nSYSCTL_ADD_PROC(struct sysctl_ctx_list *ctx,\n    struct sysctl_oid_list *parent, int number, const char *name,\n    int access, void *arg, int len,\n    int (*handler) (SYSCTL_HANDLER_ARGS), const char *format,\n    const char *descr);\n```", "```\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nstruct sysctl_oid_list *\nSYSCTL_STATIC_CHILDREN(struct sysctl_oid_list OID_NAME);\n```", "```\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\nstruct sysctl_oid_list *\nSYSCTL_CHILDREN(struct sysctl_oid *oidp);\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/ioccom.h>\n#include <sys/sysctl.h>\n\nMALLOC_DEFINE(M_ECHO, \"echo_buffer\", \"buffer for echo driver\");\n\n#define ECHO_CLEAR_BUFFER       _IO('E', 1)\n\nstatic d_open_t         echo_open;\nstatic d_close_t        echo_close;\nstatic d_read_t         echo_read;\nstatic d_write_t        echo_write;\nstatic d_ioctl_t        echo_ioctl;\n\nstatic struct cdevsw echo_cdevsw = {\n        .d_version =    D_VERSION,\n        .d_open =       echo_open,\n        .d_close =      echo_close,\n        .d_read =       echo_read,\n        .d_write =      echo_write,\n        .d_ioctl =      echo_ioctl,\n        .d_name =       \"echo\"\n};\n\ntypedef struct echo {\n        int buffer_size;\n        char *buffer;\n        int length;\n} echo_t;\n\nstatic echo_t *echo_message;\nstatic struct cdev *echo_dev;\n\nstatic struct sysctl_ctx_list clist;\nstatic struct sysctl_oid *poid;\n\nstatic int\necho_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n...\n}\n\nstatic int\necho_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n...\n}\n\nstatic int\necho_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n...\n}\n\nstatic int\necho_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n...\n}\n\nstatic int\necho_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case ECHO_CLEAR_BUFFER:\n                memset(echo_message->buffer, '\\0',\n                    echo_message->buffer_size);\n                echo_message->length = 0;\n                uprintf(\"Buffer cleared.\\n\");\n                break;\n        default:\n                error = ENOTTY;\n                break;\n        }\n\n        return (error);\n}\n\nstatic int\nsysctl_set_buffer_size(SYSCTL_HANDLER_ARGS)\n{\n        int error = 0;\n        int size = echo_message->buffer_size;\n\n        error = sysctl_handle_int(oidp, &size, 0, req);\n        if (error || !req->newptr || echo_message->buffer_size == size)\n                return (error);\n\n        if (size >= 128 && size <= 512) {\n                echo_message->buffer = realloc(echo_message->buffer, size,\n                    M_ECHO, M_WAITOK);\n                echo_message->buffer_size = size;\n\n                if (echo_message->length >= size) {\n                        echo_message->length = size - 1;\n                        echo_message->buffer[size - 1] = '\\0';\n                }\n        } else\n                error = EINVAL;\n\n        return (error);\n}\n\nstatic int\necho_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n\n        switch (event) {\n        case MOD_LOAD:\n                echo_message = malloc(sizeof(echo_t), M_ECHO, M_WAITOK);\n                echo_message->buffer_size = 256;\n                echo_message->buffer = malloc(echo_message->buffer_size,\n                    M_ECHO, M_WAITOK);\n                sysctl_ctx_init(&clist);\n                poid = SYSCTL_ADD_NODE(&clist,\n                    SYSCTL_STATIC_CHILDREN(/* tree top */), OID_AUTO,\n                    \"echo\", CTLFLAG_RW, 0, \"echo root node\");\n                SYSCTL_ADD_PROC(&clist, SYSCTL_CHILDREN(poid), OID_AUTO,\n                    \"buffer_size\", CTLTYPE_INT | CTLFLAG_RW,\n                   &echo_message->buffer_size, 0,\n sysctl_set_buffer_size,\n                    \"I\", \"echo buffer size\");\n                echo_dev = make_dev(&echo_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, \"echo\");\n                uprintf(\"Echo driver loaded.\\n\");\n                break;\n        case MOD_UNLOAD:\n                destroy_dev(echo_dev);\n                sysctl_ctx_free(&clist);\n                free(echo_message->buffer, M_ECHO);\n                free(echo_message, M_ECHO);\n                uprintf(\"Echo driver unloaded.\\n\");\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n\nDEV_MODULE(echo, echo_modevent, NULL);\n```", "```\nstatic int\nsysctl_set_buffer_size(SYSCTL_HANDLER_ARGS)\n```", "```\n#define SYSCTL_HANDLER_ARGS struct sysctl_oid *oidp, void *arg1, \\\n        int arg2, struct sysctl_req *req\n```", "```\nstatic int\nsysctl_set_buffer_size(SYSCTL_HANDLER_ARGS)\n{\n        int error = 0;\n      int size = echo_message->buffer_size;\n\n        error = sysctl_handle_int(oidp, &size, 0, req);\n      if (error ||\n !req->newptr || echo_message->buffer_size == size)\n                return (error);\n\n        if (size >= 128 && size <= 512) {\n                echo_message->buffer = realloc(echo_message->buffer, size,\n                    M_ECHO, M_WAITOK);\n                echo_message->buffer_size = size;\n\n                if (echo_message->length >= size) {\n                        echo_message->length = size - 1;\n                        echo_message->buffer[size - 1] = '\\0';\n                }\n        } else\n                error = EINVAL;\n\n        return (error);\n}\n```", "```\n$ `sudo kldload ./echo-4.0.ko`\nEcho driver loaded.\n$ `sudo sysctl echo.buffer_size=128`\necho.buffer_size: 256 -> 128\n```"]