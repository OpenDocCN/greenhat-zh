["```\n#include <sys/tty.h>\n\nstruct tty *\ntty_alloc_mutex(struct ttydevsw *tsw, void *softc, struct mtx *mtx);\n\nvoid\ntty_makedev(struct tty *tp, struct ucred *cred, const char *fmt, ...);\n\nvoid *\ntty_softc(struct tty *tp);\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/eventhandler.h>\n#include <sys/limits.h>\n#include <sys/serial.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/taskqueue.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\nMALLOC_DEFINE(M_NMDM, \"nullmodem\", \"nullmodem data structures\");\n\nstruct nmdm_part {\n        struct tty              *np_tty;\n        struct nmdm_part        *np_other;\n        struct task             np_task;\n        struct callout          np_callout;\n        int                     np_dcd;\n        int                     np_rate;\n        u_long                  np_quota;\n        int                     np_credits;\n        u_long                  np_accumulator;\n\n#define QS 8                    /* Quota shift. */\n};\n\nstruct nmdm_softc {\n        struct nmdm_part        ns_partA;\n        struct nmdm_part        ns_partB;\n        struct mtx              ns_mtx;\n};\n\nstatic tsw_outwakeup_t          nmdm_outwakeup;\nstatic tsw_inwakeup_t           nmdm_inwakeup;\nstatic tsw_param_t              nmdm_param;\nstatic tsw_modem_t              nmdm_modem;\n\nstatic struct ttydevsw nmdm_class = {\n        .tsw_flags =            TF_NOPREFIX,\n        .tsw_outwakeup =        nmdm_outwakeup,\n        .tsw_inwakeup =         nmdm_inwakeup,\n        .tsw_param =            nmdm_param,\n        .tsw_modem =            nmdm_modem\n};\n\nstatic int nmdm_count = 0;\n\nstatic void\nnmdm_timeout(void *arg)\n{\n...\n}\n\nstatic void\nnmdm_task_tty(void *arg, int pending __unused)\n{\n...\n}\n\nstatic struct nmdm_softc *\nnmdm_alloc(unsigned long unit)\n{\n...\n}\n\nstatic void\nnmdm_clone(void *arg, struct ucred *cred, char *name, int len,\n    struct cdev **dev)\n{\n...\n}\n\nstatic void\nnmdm_outwakeup(struct tty *tp)\n{\n...\n}\n\nstatic void\nnmdm_inwakeup(struct tty *tp)\n{\n...\n}\n\nstatic int\nbits_per_char(struct termios *t)\n{\n...\n}\n\nstatic int\nnmdm_param(struct tty *tp, struct termios *t)\n{\n...\n}\n\nstatic int\nnmdm_modem(struct tty *tp, int sigon, int sigoff)\n{\n...\n}\n\nstatic int\nnmdm_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n...\n}\n\nDEV_MODULE(nmdm, nmdm_modevent, NULL);\n```", "```\nstatic int\nnmdm_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        static eventhandler_tag tag;\n\n        switch (event) {\n        case MOD_LOAD:\n                tag = EVENTHANDLER_REGISTER(dev_clone,\n nmdm_clone, 0,\n                    1000);\n                if (tag == NULL)\n                        return (ENOMEM);\n                break;\n        case MOD_SHUTDOWN:\n                break;\n        case MOD_UNLOAD:\n              if (nmdm_count != 0)\n                       return (EBUSY);\n              EVENTHANDLER_DEREGISTER(dev_clone, tag);\n                break;\n        default:\n                return (EOPNOTSUPP);\n        }\n\n        return (0);\n\n}\n```", "```\nstatic void\nnmdm_clone(void *arg, struct ucred *cred, char *name, int len,\n    struct cdev **dev)\n{\n        unsigned long unit;\n        char *end;\n        struct nmdm_softc *ns;\n\n      if (*dev != NULL)\n                return;\n      if (strncmp(name, \"nmdm\", 4) != 0)\n                return;\n\n        /* Device name must be \"nmdm%lu%c\", where %c is \"A\" or \"B\". */\n        name += 4;\n        unit = strtoul(name, &end, 10);\n      if (unit == ULONG_MAX || name == end)\n                return;\n      if ((end[0] != 'A' && end[0] != 'B') || end[1] != '\\0')\n                return;\n\n        ns = nmdm_alloc(unit);\n\n        if (end[0] == 'A')\n              *dev = ns->ns_partA.np_tty->t_dev;\n        else\n              *dev = ns->ns_partB.np_tty->t_dev;\n}\n```", "```\nstatic struct ttydevsw nmdm_class = {\n        .tsw_flags =          TF_NOPREFIX,\n        .tsw_outwakeup =        nmdm_outwakeup,\n        .tsw_inwakeup =         nmdm_inwakeup,\n        .tsw_param =            nmdm_param,\n        .tsw_modem =            nmdm_modem\n\n};\n```", "```\nstatic struct nmdm_softc *\nnmdm_alloc(unsigned long unit)\n{\n        struct nmdm_softc *ns;\n\n      atomic_add_int(&nmdm_count, 1);\n\n        ns = malloc(sizeof(*ns), M_NMDM, M_WAITOK | M_ZERO);\n      mtx_init(&ns->ns_mtx, \"nmdm\", NULL, MTX_DEF);\n\n        /* Connect the pairs together. */\n      ns->ns_partA.np_other = &ns->ns_partB;\n      TASK_INIT(&ns->ns_partA.np_task, 0, nmdm_task_tty, &ns->ns_partA);\n      callout_init_mtx(&ns->ns_partA.np_callout, &ns->ns_mtx, 0);\n\n      ns->ns_partB.np_other = &ns->ns_partA;\n      TASK_INIT(&ns->ns_partB.np_task, 0, nmdm_task_tty, &ns->ns_partB);\n      callout_init_mtx(&ns->ns_partB.np_callout, &ns->ns_mtx, 0);\n\n        /* Create device nodes. */\n        ns->ns_partA.np_tty = tty_alloc_mutex(&nmdm_class, &ns->ns_partA,\n            &ns->ns_mtx);\n        tty_makedev(ns->ns_partA.np_tty, NULL, \"nmdm%luA\", unit);\n\n        ns->ns_partB.np_tty = tty_alloc_mutex(&nmdm_class, &ns->ns_partB,\n            &ns->ns_mtx);\n        tty_makedev(ns->ns_partB.np_tty, NULL, \"nmdm%luB\", unit);\n\n        return (ns);\n\n}\n```", "```\nstatic void\nnmdm_outwakeup(struct tty *tp)\n{\n        struct nmdm_part *np = tty_softc(tp);\n\n        /* We can transmit again, so wake up our side. */\n      taskqueue_enqueue(taskqueue_swi, &np->np_task);\n}\n```", "```\nstatic void\nnmdm_task_tty(void *arg, int pending __unused)\n{\n        struct tty *tp, *otp;\n        struct nmdm_part *np = arg;\n        char c;\n\n        tp = np->np_tty;\n        tty_lock(tp);\n\n        otp = np->np_other->np_tty;\n        KASSERT(otp != NULL, (\"nmdm_task_tty: null otp\"));\n        KASSERT(otp != tp, (\"nmdm_task_tty: otp == tp\"));\n\n      if (np->np_other->np_dcd) {\n              if (!tty_opened(tp)) {\n                      np->np_other->np_dcd = 0;\n                      ttydisc_modem(otp, 0);\n                }\n      } else {\n              if (tty_opened(tp)) {\n                        np->np_other->np_dcd = 1;\n                        ttydisc_modem(otp, 1);\n                }\n        }\n\n        while (ttydisc_rint_poll(otp) > 0) {\n                if (np->np_rate && !np->np_quota)\n                        break;\n                if (ttydisc_getc(tp, &c, 1) != 1)\n                        break;\n                np->np_quota--;\n              ttydisc_rint(otp, c, 0);\n        }\n        ttydisc_rint_done(otp);\n\n        tty_unlock(tp);\n}\n```", "```\nstatic void\nnmdm_inwakeup(struct tty *tp)\n{\n        struct nmdm_part *np = tty_softc(tp);\n\n        /* We can receive again, so wake up the other side. */\n      taskqueue_enqueue(taskqueue_swi,\n &np->np_other->np_task);\n}\n```", "```\nstatic int\nnmdm_modem(struct tty *tp, int sigon, int sigoff)\n{\n        struct nmdm_part *np = tty_softc(tp);\n        int i = 0;\n\n        /* Set modem control lines. */\n      if (sigon || sigoff) {\n              if (sigon & SER_DTR)\n                       np->np_other->np_dcd = 1;\n              if (sigoff & SER_DTR)\n                       np->np_other->np_dcd = 0;\n\n              ttydisc_modem(np->np_other->np_tty, np->np_other->np_dcd);\n\n                return (0);\n        /* Get state of modem control lines. */\n        } else {\n              if (np->np_dcd)\n                       i |= SER_DCD;\n              if (np->np_other->np_dcd)\n                       i |= SER_DTR;\n\n                return (i);\n        }\n\n}\n```", "```\nstatic int\nnmdm_param(struct tty *tp, struct termios *t)\n{\n        struct nmdm_part *np = tty_softc(tp);\n        struct tty *otp;\n        int bpc, rate, speed, i;\n\n        otp = np->np_other->np_tty;\n\n      if (!((t->c_cflag | otp->t_termios.c_cflag) & CDSR_OFLOW)) {\n                np->np_rate = 0;\n                np->np_other->np_rate = 0;\n                return (0);\n        }\n\n      bpc = imax(bits_per_char(t), bits_per_char(&otp->t_termios));\n\n        for (i = 0; i < 2; i++) {\n                /* Use the slower of their transmit or our receive rate. */\n              speed = imin(otp->t_termios.c_ospeed, t->c_ispeed);\n                if (speed == 0) {\n                        np->np_rate = 0;\n                        np->np_other->np_rate = 0;\n                        return (0);\n                }\n\n                speed <<= QS;                  /* bits per second, scaled. */\n                speed /= bpc;                  /* char per second, scaled. */\n                rate = (hz << QS) / speed;     /* hz per callout. */\n                if (rate == 0)\n                        rate = 1;\n\n                speed *= rate;\n                speed /= hz;                   /* (char/sec)/tick, scaled. */\n\n              np->np_credits = speed;\n                np->np_rate = rate;\n                callout_reset(&np->np_callout, rate,\n nmdm_timeout, np);\n\n                /* Swap pointers for second pass--to update the other end. */\n                np = np->np_other;\n                t = &otp->t_termios;\n                otp = tp;\n        }\n\n        return (0);\n}\n```", "```\nstatic void\nnmdm_timeout(void *arg)\n{\n        struct nmdm_part *np = arg;\n\n      if (np->np_rate == 0)\n                return;\n\n        /*\n         * Do a simple Floyd-Steinberg dither to avoid FP math.\n         * Wipe out unused quota from last tick.\n         */\n        np->np_accumulator += np->np_credits;\n        np->np_quota = np->np_accumulator >> QS;\n        np->np_accumulator &= ((1 << QS) - 1);\n\n      taskqueue_enqueue(taskqueue_swi, &np->np_task);\n      callout_reset(&np->np_callout, np->np_rate,\n nmdm_timeout, np);\n}\n```", "```\nstatic int\nbits_per_char(struct termios *t)\n{\n        int bits;\n\n      bits = 1;               /* start bit. */\n      switch (t->c_cflag & CSIZE) {\n        case CS5:\n                bits += 5;\n                break;\n        case CS6:\n                bits += 6;\n                break;\n        case CS7:\n                bits += 7;\n                break;\n        case CS8:\n                bits += 8;\n                break;\n        }\n      bits++;                 /* stop bit. */\n      if (t->c_cflag & PARENB)\n                bits++;\n      if (t->c_cflag & CSTOPB)\n                bits++;\n\n        return (bits);\n}\n```", "```\n$ `sudo kldload ./nmdm.ko`\n$ `sudo /usr/libexec/getty std.9600 nmdm0A &`\n[1] 936\n$ `sudo cu -l /dev/nmdm0B`\nConnected\n\nFreeBSD/i386 (wintermute.phub.net.cable.rogers.com) (nmdm0A)\nlogin:\n```"]