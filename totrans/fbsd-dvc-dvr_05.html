<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Delaying Execution"><div class="titlepage"><div><div><h1 class="title"><a id="delaying_execution"/>Chapter 5. Delaying Execution</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id5"/><div class="mediaobject"><a id="I_mediaobject5_d1e9112"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>Often, drivers need to delay their execution in order to give their device(s), the kernel, or a user the time to accomplish some task. In this chapter, I’ll detail the different functions available for achieving these delays. In the process, I’ll also describe asynchronous code execution.</p><div class="sect1" title="Voluntary Context Switching, or Sleeping"><div class="titlepage"><div><div><h1 class="title"><a id="voluntary_context_switching_comma_or_sle"/>Voluntary Context Switching, or Sleeping</h1></div></div></div><p><span class="emphasis"><em>Voluntary context switching</em></span>, or <span class="emphasis"><em>sleeping</em></span>, is done when a driver thread must await the availability of a resource or the arrival of an event; for example, a driver thread should sleep after it requests data from an input device, such as a terminal (McKusick and Neville-Neil, 2005). A driver thread sleeps by calling a <code class="literal">*sleep</code> function.<a class="indexterm" id="IDX-CHP-5-0001"/><a class="indexterm" id="IDX-CHP-5-0002"/><a class="indexterm" id="IDX-CHP-5-0003"/><a class="indexterm" id="IDX-CHP-5-0004"/></p><a id="I_programlisting5_d1e9148"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/proc.h&gt;

int
tsleep(void *chan, int priority, const char *wmesg, int timo);

void
wakeup(void *chan);

void
wakeup_one(void *chan);

void
pause(const char *wmesg, int timo);

#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

int
mtx_sleep(void *chan, struct mtx *mtx, int priority, const char *wmesg,
    int timo);

#include &lt;sys/param.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/proc.h&gt;

int
msleep_spin(void *chan, struct mtx *mtx, const char *wmesg, int timo);

#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;

int
sx_sleep(void *chan, struct sx *sx, int priority, const char *wmesg,
    int timo);

#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/rwlock.h&gt;

int
rw_sleep(void *chan, struct rwlock *rw, int priority, const char *wmesg,
    int timo);</pre><p>A thread voluntarily context switches (or sleeps) by calling <code class="literal">tsleep</code>. The arguments for <code class="literal">tsleep</code> are common to the other <code class="literal">*sleep</code> functions and are described in the next few paragraphs.<a class="indexterm" id="IDX-CHP-5-0005"/><a class="indexterm" id="IDX-CHP-5-0006"/><a class="indexterm" id="IDX-CHP-5-0007"/><a class="indexterm" id="IDX-CHP-5-0008"/></p><p>The <code class="literal">chan</code> argument is the channel (that is to say, an arbitrary address) that uniquely identifies the event that the thread is waiting for.</p><p>The <code class="literal">priority</code> argument is the priority for the thread when it resumes. If <code class="literal">priority</code> is <code class="literal">0</code>, the current thread priority is used. If <code class="literal">PCATCH</code> is <code class="literal">OR</code>’ed into <code class="literal">priority</code>, signals are checked before and after sleeping.</p><p>The <code class="literal">wmesg</code> argument expects a concise description of the sleeping thread. This description is displayed by user-mode utilities, such as <code class="literal">ps(1)</code>, and has no real impact on performance.<a class="indexterm" id="IDX-CHP-5-0009"/><a class="indexterm" id="IDX-CHP-5-0010"/><a class="indexterm" id="IDX-CHP-5-0011"/><a class="indexterm" id="IDX-CHP-5-0012"/><a class="indexterm" id="IDX-CHP-5-0013"/></p><p>The <code class="literal">timo</code> argument specifies the sleep timeout. If <code class="literal">timo</code> is nonzero, the thread will sleep for at most <code class="literal">timo</code> / <code class="literal">hz</code> seconds. Afterward, <code class="literal">tsleep</code> returns the error code <code class="literal">EWOULDBLOCK</code>.</p><p>The <code class="literal">wakeup</code> function wakes up every thread asleep on the channel <code class="literal">chan</code>. Generally speaking, threads woken from sleep should re-evaluate the conditions they slept on.</p><p>The <code class="literal">wakeup_one</code> function is a variant of <code class="literal">wakeup</code> that only gets up the first thread that it finds asleep on chan. The assumption is that when the awakened thread is done, it calls <code class="literal">wakeup_one</code> to wake up another thread that’s asleep on <code class="literal">chan</code>; this succession of <code class="literal">wakeup_one</code> calls continues until every thread asleep on <code class="literal">chan</code> has been awakened (McKusick and Neville-Neil, 2005). This reduces the load in cases when numerous threads are asleep on <code class="literal">chan</code>, but only one thread can do anything meaningful when made runnable.</p><p>The <code class="literal">pause</code> function puts the calling thread to sleep for <code class="literal">timo</code> / <code class="literal">hz</code> seconds. This thread cannot be awoken by <code class="literal">wakeup</code>, <code class="literal">wakeup_one</code>, or signals.</p><p>The remaining <code class="literal">*sleep</code> functions—<code class="literal">mtx_sleep</code>, <code class="literal">msleep_spin</code>, <code class="literal">sx_sleep</code>, and <code class="literal">rw_</code>sleep—are variants of tsleep that take a particular lock. This lock is dropped before the thread sleeps and is reacquired before the thread awakes; if <code class="literal">PDROP</code> is <code class="literal">OR</code>’ed into <code class="literal">priority</code>, this lock is not reacquired.</p><p>Note that the <code class="literal">msleep_spin</code> function does not have a <code class="literal">priority</code> argument. Consequently, it cannot assign a new thread priority, catch signals via <code class="literal">PCATCH</code>, or drop its spin mutex via <code class="literal">PDROP</code>.</p></div></div>
<div class="sect1" title="Implementing Sleeps and Condition Variables"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_sleeps_and_condition_variab"/>Implementing Sleeps and Condition Variables</h1></div></div></div><p><a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a> (which is based on code written by John Baldwin) is a KLD designed to demonstrate sleeps and condition variables. It works by obtaining “events” from a sysctl; each event is then passed to a thread, which performs a specific task based on the event it received.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Take a quick look at this code and try to discern some of its structure. If you don’t understand all of it, don’t worry; an explanation follows.</p></div><div class="example"><a id="sleep.c"/><p class="title">Example 5-1. sleep.c</p><div class="example-contents"><pre class="programlisting">#define INVARIANTS
  #define INVARIANT_SUPPORT

  #include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/kthread.h&gt;
  #include &lt;sys/proc.h&gt;
  #include &lt;sys/sched.h&gt;
  #include &lt;sys/unistd.h&gt;
  #include &lt;sys/lock.h&gt;
  #include &lt;sys/mutex.h&gt;
  #include &lt;sys/condvar.h&gt;
  #include &lt;sys/sysctl.h&gt;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> #define MAX_EVENT 1

<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> static struct proc *kthread;
<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/> static int event;
<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/> static struct cv event_cv;
<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/> static struct mtx event_mtx;

  static struct sysctl_ctx_list clist;
  static struct sysctl_oid *poid;

  static void
<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/> sleep_thread(void *arg)
  {
          int ev;

          for (;;) {
                  mtx_lock(&amp;event_mtx);
                  while ((ev = event) == 0)
                          cv_wait(&amp;event_cv, &amp;event_mtx);
                  event = 0;
                  mtx_unlock(&amp;event_mtx);

                  switch (ev) {
                  case −1:
                          kproc_exit(0);
                          break;
                  case 0:
                          break;
                  case 1:
                          printf("sleep... is alive and well.\n");
                          break;
                  default:
                          panic("event %d is bogus\n", event);
                  }
          }
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/> sysctl_debug_sleep_test(SYSCTL_HANDLER_ARGS)
  {
          int error, i = 0;

          error = sysctl_handle_int(oidp, &amp;i, 0, req);
          if (error == 0 &amp;&amp; req-&gt;newptr != NULL) {
                  if (i &gt;= 1 &amp;&amp; i &lt;= MAX_EVENT) {
                          mtx_lock(&amp;event_mtx);
                          KASSERT(event == 0, ("event %d was unhandled",
                              event));
                          event = i;
                          cv_signal(&amp;event_cv);
                          mtx_unlock(&amp;event_mtx);
                  } else
                          error = EINVAL;
          }

          return (error);
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/> load(void *arg)
  {
          int error;
          struct proc *p;
          struct thread *td;

          error = kproc_create(sleep_thread, NULL, &amp;p, RFSTOPPED, 0, "sleep");
          if (error)
                  return (error);

          event = 0;
          mtx_init(&amp;event_mtx, "sleep event", NULL, MTX_DEF);
          cv_init(&amp;event_cv, "sleep");

          td = FIRST_THREAD_IN_PROC(p);
          thread_lock(td);
          TD_SET_CAN_RUN(td);
          sched_add(td, SRQ_BORING);
          thread_unlock(td);
          kthread = p;

          sysctl_ctx_init(&amp;clist);
          poid = SYSCTL_ADD_NODE(&amp;clist, SYSCTL_STATIC_CHILDREN(_debug),
              OID_AUTO, "sleep", CTLFLAG_RD, 0, "sleep tree");
          SYSCTL_ADD_PROC(&amp;clist, SYSCTL_CHILDREN(poid), OID_AUTO, "test",
              CTLTYPE_INT | CTLFLAG_RW, 0, 0, sysctl_debug_sleep_test, "I",
              "");

          return (0);
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/> unload(void *arg)
  {
          sysctl_ctx_free(&amp;clist);
          mtx_lock(&amp;event_mtx);
          event = −1;
          cv_signal(&amp;event_cv);
          mtx_sleep(kthread, &amp;event_mtx, PWAIT, "sleep", 0);
          mtx_unlock(&amp;event_mtx);
          mtx_destroy(&amp;event_mtx);
          cv_destroy(&amp;event_cv);

          return (0);
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/> sleep_modevent(module_t mod __unused, int event, void *arg)
  {
          int error = 0;

          switch (event) {
          case MOD_LOAD:
                  error = load(arg);
                  break;
          case MOD_UNLOAD:
                  error = unload(arg);
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

  static moduledata_t sleep_mod = {
          "sleep",
          sleep_modevent,
          NULL
  };

  DECLARE_MODULE(sleep, sleep_mod, SI_SUB_SMP, SI_ORDER_ANY);</pre></div></div><p>Near the beginning of <a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a>, a constant named <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9413"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">MAX_EVENT</code> is defined as <code class="literal">1</code>, and a <code class="literal">struct proc</code> pointer named <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9429"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">kthread</code> is declared. For now, ignore these two objects; I’ll discuss them later.<a class="indexterm" id="IDX-CHP-5-0014"/><a class="indexterm" id="IDX-CHP-5-0015"/><a class="indexterm" id="IDX-CHP-5-0016"/></p><p>Next, there are two variable declarations: an integer named <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9451"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">event</code> and a condition variable named <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9460"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">event_cv</code>. These variables are used to synchronize <a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a>’s threads. Obviously, the <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9472"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">event_mtx</code> mutex is used to protect even<code class="literal">t</code>.<a class="indexterm" id="IDX-CHP-5-0017"/></p><p>The remaining parts—<span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9489"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">sleep_thread</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9498"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">sysctl_debug_sleep_test</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9507"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">load</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9517"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">unload</code>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9526"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">sleep_modevent</code>—require a more in-depth explanation and are therefore described in their own sections.</p><p>To make things easier to follow, I’ll describe the abovementioned parts in the order they execute, rather than in the order they appear. Thus, I’ll begin with <a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a>’s module event handler.</p><div class="sect2" title="sleep_modevent Function"><div class="titlepage"><div><div><h2 class="title"><a id="sleep_underscore_modevent_function"/>sleep_modevent Function</h2></div></div></div><p>The <code class="literal">sleep_modevent</code> function is the module event handler for <a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a>. Here is its function definition (again):</p><a id="I_programlisting5_d1e9549"/><pre class="programlisting">static int
sleep_modevent(module_t mod __unused, int event, void *arg)
{

        int error = 0;

        switch (event) {
        case MOD_LOAD:
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>load(arg);
                break;
        case MOD_UNLOAD:
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>unload(arg);
                break;
        default:
                error = EOPNOTSUPP;
                break;
        }

        return (error);
}</pre><p>On module load, this function simply calls the <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9565"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> load function. On module unload, it calls the <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9571"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">unload</code> function.<a class="indexterm" id="IDX-CHP-5-0018"/><a class="indexterm" id="IDX-CHP-5-0019"/><a class="indexterm" id="IDX-CHP-5-0020"/><a class="indexterm" id="IDX-CHP-5-0021"/><a class="indexterm" id="IDX-CHP-5-0022"/></p></div><div class="sect2" title="load Function"><div class="titlepage"><div><div><h2 class="title"><a id="load_function"/>load Function</h2></div></div></div><p>The <code class="literal">load</code> function initializes this KLD. Here is its function definition (again):</p><a id="I_programlisting5_d1e9606"/><pre class="programlisting">static int
load(void *arg)
{
        int error;
        struct proc *p;
        struct thread *td;

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>kproc_create(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>sleep_thread, NULL, <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>&amp;p,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>RFSTOPPED, 0,
            "sleep");
        if (error)
                return (error);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>event = 0;
        mtx_init(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;event_mtx, "sleep event", NULL, MTX_DEF);
        cv_init(<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>&amp;event_cv, "sleep");

        td = FIRST_THREAD_IN_PROC(p);
        thread_lock(td);
        TD_SET_CAN_RUN(td);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>sched_add(td, SRQ_BORING);
        thread_unlock(td);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>kthread = p;

        sysctl_ctx_init(&amp;clist);
        poid = SYSCTL_ADD_NODE(&amp;clist, SYSCTL_STATIC_CHILDREN(_debug),
            OID_AUTO, "sleep", CTLFLAG_RD, 0, "sleep tree");
        SYSCTL_ADD_PROC(&amp;clist, SYSCTL_CHILDREN(poid), OID_AUTO, "test",
            CTLTYPE_INT | CTLFLAG_RW, 0, 0, <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>sysctl_debug_sleep_test, "I",
            "");

        return (0);
}</pre><p>This function can be split into four parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9671"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> creates a kernel process to execute the function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9677"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">sleep_thread</code>. A handle to this process is saved in <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9686"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">p</code>. The constant <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9696"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">RFSTOPPED</code> puts the process in the stopped state. The second part initializes the <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9705"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">event</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9714"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">event_mtx</code>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9724"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">event_cv</code> variables. The third part <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9733"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> schedules the new process to execute <code class="literal">sleep_thread</code>. It also saves the process handle in <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9742"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">kthread</code>.<a class="indexterm" id="IDX-CHP-5-0023"/><a class="indexterm" id="IDX-CHP-5-0024"/><a class="indexterm" id="IDX-CHP-5-0025"/><a class="indexterm" id="IDX-CHP-5-0026"/><a class="indexterm" id="IDX-CHP-5-0027"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Processes are executed at thread granularity, which is why this code is thread centric.</p></div><p>The fourth part creates a sysctl named debug.sleep.test, which uses a handler function named <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9774"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">sysctl_debug_sleep_test</code>.</p></div><div class="sect2" title="sleep_thread Function"><div class="titlepage"><div><div><h2 class="title"><a id="sleep_underscore_thread_function"/>sleep_thread Function</h2></div></div></div><p>The <code class="literal">sleep_thread</code> function receives events from the <code class="literal">sysctl_debug_sleep_test</code> function. It then performs a specific task based on the event received. Here is its function definition (again):</p><a id="I_programlisting5_d1e9794"/><pre class="programlisting">static void
sleep_thread(void *arg)
{
        int ev;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>for (;;) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>mtx_lock(&amp;event_mtx);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>while ((ev = event) == 0)
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>cv_wait(&amp;event_cv, &amp;event_mtx);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>event = 0;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>mtx_unlock(&amp;event_mtx);

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>switch (ev) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>case −1:
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>kproc_exit(0);
                        break;
                case 0:
                        break;
                case 1:
                        printf("sleep... is alive and well.\n");
                        break;
                default:
                        panic("event %d is bogus\n", event);
                }
        }
}</pre><p>As you can see, the execution of <code class="literal">sleep_thread</code> is contained within a <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9856"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> forever loop. This loop begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9862"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> acquiring <code class="literal">event_mtx</code>. Next, the value of <code class="literal">event</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9875"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> saved in <code class="literal">ev</code>. If <code class="literal">event</code> is equal to <code class="literal">0</code>, <code class="literal">sleep_thread</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9893"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> waits on <code class="literal">event_cv</code>. See, <code class="literal">event</code> is only <code class="literal">0</code> if <code class="literal">sleep_thread</code> has yet to receive an event. If an event has been received, <code class="literal">sleep_thread</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9915"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> sets event to 0 to prevent reprocessing it. Next, <code class="literal">event_mtx</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9925"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> released. Finally, the received event is processed by a <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9931"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">switch</code> statement. Note that if the received event is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9940"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">−1, sleep_thread</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9950"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> self-terminates via <code class="literal">kproc_exit</code>.<a class="indexterm" id="IDX-CHP-5-0028"/><a class="indexterm" id="IDX-CHP-5-0029"/><a class="indexterm" id="IDX-CHP-5-0030"/><a class="indexterm" id="IDX-CHP-5-0031"/><a class="indexterm" id="IDX-CHP-5-0032"/></p></div><div class="sect2" title="sysctl_debug_sleep_test Function"><div class="titlepage"><div><div><h2 class="title"><a id="sysctl_underscore_debug_underscore_sleep"/>sysctl_debug_sleep_test Function</h2></div></div></div><p>The <code class="literal">sysctl_debug_sleep_test</code> function obtains events from the sysctl <code class="literal">debug.sleep.test</code>. It then passes those events to the <code class="literal">sleep_thread</code> function.</p><a id="I_programlisting5_d1e9993"/><pre class="programlisting">static int
sysctl_debug_sleep_test(SYSCTL_HANDLER_ARGS)
{
        int error, i = 0;

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sysctl_handle_int(oidp, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>&amp;i, 0, req);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>if (error == 0 &amp;&amp; req-&gt;newptr != NULL) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (i &gt;= 1 &amp;&amp; i &lt;= MAX_EVENT) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>mtx_lock(&amp;event_mtx);
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>KASSERT(event == 0, ("event %d was unhandled",
                            event));
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>event = i;
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>cv_signal(&amp;event_cv);
                        mtx_unlock(&amp;event_mtx);
                } else
                        error = EINVAL;
        }

        return (error);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10046"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> obtaining an event from <code class="literal">debug.sleep.test</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10055"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> storing it in <code class="literal">i</code>. The following <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10064"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> if statement ensures that the event was obtained successfully. Next, a <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10071"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> range check is performed on <code class="literal">i</code>. If <code class="literal">i</code> is in the allowable range, <code class="literal">event_mtx</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10086"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> acquired and <code class="literal">event</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10096"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> queried to ensure that it equals 0.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If <code class="literal">event</code> does not equal <code class="literal">0</code>, something has gone horribly wrong. And if <code class="literal">INVARIANTS</code> is enabled, the kernel panics.</p></div><p>Finally, <code class="literal">event</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10119"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> set to <code class="literal">i</code> and <code class="literal">sleep_thread</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10131"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> unblocked to process it.</p></div><div class="sect2" title="unload Function"><div class="titlepage"><div><div><h2 class="title"><a id="unload_function"/>unload Function</h2></div></div></div><p>The <code class="literal">unload</code> function shuts down this KLD. Here is its function definition (again):</p><a id="I_programlisting5_d1e10145"/><pre class="programlisting">static int
unload(void *arg)
{
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sysctl_ctx_free(&amp;clist);
        mtx_lock(&amp;event_mtx);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>event = −1;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>cv_signal(&amp;event_cv);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>mtx_sleep(<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>kthread, &amp;event_mtx, PWAIT, "sleep", 0);
        mtx_unlock(&amp;event_mtx);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>mtx_destroy(&amp;event_mtx);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>cv_destroy(&amp;event_cv);

        return (0);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10192"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> tearing down the sysctl <code class="literal">debug.sleep.test</code>. Afterward, <code class="literal">event</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10204"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> set to -<code class="literal">1</code> and <code class="literal">sleep_thread</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10217"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> unblocked to process it.<a class="indexterm" id="IDX-CHP-5-0033"/><a class="indexterm" id="IDX-CHP-5-0034"/><a class="indexterm" id="IDX-CHP-5-0035"/><a class="indexterm" id="IDX-CHP-5-0036"/><a class="indexterm" id="IDX-CHP-5-0037"/><a class="indexterm" id="IDX-CHP-5-0038"/></p><p>Recall that if event is <code class="literal">−1</code>, <code class="literal">sleep_thread</code> self-terminates via <code class="literal">kproc_exit</code>. Note that <code class="literal">kproc_exit</code> executes <code class="literal">wakeup</code> on its caller’s process handle before returning. This is why <code class="literal">unload</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10264"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> sleeps on the channel <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10270"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">kthread</code>, because it contains <code class="literal">sleep_thread</code>’s process handle.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Recall that <code class="literal">load</code> saved <code class="literal">sleep_thread</code>’s process handle in <code class="literal">kthread</code>.</p></div><p>As <code class="literal">unload</code> sleeps (at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10299"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span>) until <code class="literal">sleep_thread</code> exits, it cannot destroy <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10308"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">event_mtx</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10318"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">event_cv</code> while they’re still in use.</p></div><div class="sect2" title="Don’t Panic"><div class="titlepage"><div><div><h2 class="title"><a id="donat_panic-id4"/>Don’t Panic</h2></div></div></div><p>Here are the results from loading and unloading <a class="xref" href="ch05s02.html#sleep.c" title="Example 5-1. sleep.c">Example 5-1</a>:</p><a id="I_programlisting5_d1e10334"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./sleep.ko</code></strong>
$ <strong class="userinput"><code>sudo sysctl debug.sleep.test=1</code></strong>
debug.sleep.test: 0 -&gt; 0
$ <strong class="userinput"><code>dmesg | tail -n 1</code></strong>
sleep... is alive and well.
$ <strong class="userinput"><code>sudo kldunload ./sleep.ko</code></strong>
$</pre><p>Naturally, it works. Now, let’s look at some other ways to delay execution.</p></div></div>
<div class="sect1" title="Kernel Event Handlers"><div class="titlepage"><div><div><h1 class="title"><a id="kernel_event_handlers"/>Kernel Event Handlers</h1></div></div></div><p><span class="emphasis"><em>Event handlers</em></span> allow drivers to register one or more functions to be called when an event occurs. As an example, before halting the system, every function that is registered with the event handler <code class="literal">shutdown_final</code> is called. <a class="xref" href="ch05s03.html#kernel_event_handlers-id1" title="Table 5-1. Kernel Event Handlers">Table 5-1</a> describes every event handler that is available.</p><div class="table"><a id="kernel_event_handlers-id1"/><p class="title">Table 5-1. Kernel Event Handlers</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Kernel Event Handlers"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Event Handler</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">acpi_sleep_event</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the system is sent to sleep.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">acpi_wakeup_event</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the system is woken up.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">dev_clone</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a solicited item under <span class="emphasis"><em>/dev</em></span> does not exist; in other words, these functions create device nodes on demand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ifaddr_event</code><a class="indexterm" id="IDX-CHP-5-0039"/><a class="indexterm" id="IDX-CHP-5-0040"/><a class="indexterm" id="IDX-CHP-5-0041"/><a class="indexterm" id="IDX-CHP-5-0042"/><a class="indexterm" id="IDX-CHP-5-0043"/><a class="indexterm" id="IDX-CHP-5-0044"/><a class="indexterm" id="IDX-CHP-5-0045"/><a class="indexterm" id="IDX-CHP-5-0046"/><a class="indexterm" id="IDX-CHP-5-0047"/><a class="indexterm" id="IDX-CHP-5-0048"/><a class="indexterm" id="IDX-CHP-5-0049"/><a class="indexterm" id="IDX-CHP-5-0050"/><a class="indexterm" id="IDX-CHP-5-0051"/><a class="indexterm" id="IDX-CHP-5-0052"/><a class="indexterm" id="IDX-CHP-5-0053"/><a class="indexterm" id="IDX-CHP-5-0054"/><a class="indexterm" id="IDX-CHP-5-0055"/></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when an address is set up on a network interface.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">if_clone_event</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a network interface is cloned.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ifnet_arrival_event</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a new network interface appears.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ifnet_departure_event</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a network interface is taken down.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">power_profile_change</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the system’s power profile changes.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">process_exec</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a process issues an <code class="literal">exec</code> operation.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">process_exit</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a process exits.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">process_fork</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when a process forks.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">shutdown_pre_sync</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the system is shut down before any filesystems are synchronized.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">shutdown_post_sync</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the system is shut down after every filesystem is synchronized.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">shutdown_final</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called before halting the system.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">vm_lowmem</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when virtual memory is low.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">watchdog_list</code></p></td><td style="text-align: left" valign="top"><p>Registered functions are called when the watchdog timer is reinitialized.</p></td></tr></tbody></table></div></div><p>The FreeBSD kernel provides the following three macros for working with event handlers:</p><a id="I_programlisting5_d1e10566"/><pre class="programlisting">#include &lt;sys/eventhandler.h&gt;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> eventhandler_tag
EVENTHANDLER_REGISTER(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>name, <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>func, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>arg, <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>priority);

EVENTHANDLER_DEREGISTER(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>name, <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>tag);

EVENTHANDLER_INVOKE(<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>name, ...);</pre><p>The <code class="literal">EVENTHANDLER_REGISTER</code> macro registers the function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10622"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">func</code> with the event handler <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10631"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">name</code>. If successful, an <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10641"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">eventhandler_tag</code> is returned. When <code class="literal">func</code> is called, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10653"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">arg</code> will be its first argument. Functions registered with <code class="literal">name</code> are called in order of <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10666"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">priority</code>. <code class="literal">priority</code> can be 0 (which is the highest priority) to <code class="literal">20000</code> (which is the lowest priority).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Generally, I use the constant <code class="literal">EVENTHANDLER_PRI_ANY</code>, which equals <code class="literal">10000</code>, for <code class="literal">priority</code>.</p></div><p>The <code class="literal">EVENTHANDLER_DEREGISTER</code> macro deletes the function associated with <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10698"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">tag</code> from the event handler <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10707"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">name</code> (where <code class="literal">tag</code> is an <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10720"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">eventhandler_tag</code>).</p><p>The <code class="literal">EVENTHANDLER_INVOKE</code> macro executes every function registered with the event handler <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10734"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">name</code>. Note that you’ll never call <code class="literal">EVENTHANDLER_INVOKE</code>, because each event handler has threads dedicated to do just that.<a class="indexterm" id="IDX-CHP-5-0056"/><a class="indexterm" id="IDX-CHP-5-0057"/><a class="indexterm" id="IDX-CHP-5-0058"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>We’ll walk through an example that uses event handlers in <a class="xref" href="ch06.html" title="Chapter 6. Case Study: Virtual Null Modem">Chapter 6</a>.</p></div></div>
<div class="sect1" title="Callouts"><div class="titlepage"><div><div><h1 class="title"><a id="callouts"/>Callouts</h1></div></div></div><p><span class="emphasis"><em>Callouts</em></span> allow drivers to asynchronously execute a function after a specified amount of time (or at regular intervals). These functions are known as <span class="emphasis"><em>callout functions</em></span>.<a class="indexterm" id="IDX-CHP-5-0059"/><a class="indexterm" id="IDX-CHP-5-0060"/></p><p>The FreeBSD kernel provides the following seven functions for working with callouts:</p><a id="I_programlisting5_d1e10781"/><pre class="programlisting">#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;

typedef void timeout_t (void *);

void
callout_init(struct callout <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*c, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>mpsafe);

void
callout_init_mtx(struct callout *c, struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*mtx, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>flags);

void
callout_init_rw(struct callout *c, struct rwlock <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>*rw, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>flags);

int
callout_stop(struct callout *c);

int
callout_drain(struct callout *c);

int
callout_reset(struct callout <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*c, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ticks, timeout_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>*func,
    void <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>*arg);

int
callout_schedule(struct callout *c, int ticks);</pre><p>The <code class="literal">callout_init</code> function initializes the <code class="literal">callout</code> structure <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10852"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">c</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10861"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">mpsafe</code> argument denotes whether the callout function is “multiprocessor safe.” Valid values for this argument are shown in <a class="xref" href="ch05s04.html#callout_underscore_init_symbolic_constan" title="Table 5-2. callout_init Symbolic Constants">Table 5-2</a>.</p><div class="table"><a id="callout_underscore_init_symbolic_constan"/><p class="title">Table 5-2. callout_init Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="callout_init Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant<a class="indexterm" id="IDX-CHP-5-0061"/><a class="indexterm" id="IDX-CHP-5-0062"/><a class="indexterm" id="IDX-CHP-5-0063"/><a class="indexterm" id="IDX-CHP-5-0064"/><a class="indexterm" id="IDX-CHP-5-0065"/><a class="indexterm" id="IDX-CHP-5-0066"/></p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">0</code></p></td><td style="text-align: left" valign="top"><p>The callout function is <span class="emphasis"><em>not</em></span> multiprocessor safe; the <code class="literal">Giant</code> mutex is acquired before executing the callout function, and it’s dropped after the callout function returns.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CALLOUT_MPSAFE</code></p></td><td style="text-align: left" valign="top"><p>The callout function is multiprocessor safe; in other words, race conditions are dealt with by the callout function itself.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Here, <code class="literal">Giant</code> is acquired and dropped by the callout subsystem. <code class="literal">Giant</code> primarily protects legacy code and should not be used by contemporary code.</p></div><p>The <code class="literal">callout_init_mtx</code> function is an alternative to <code class="literal">callout_init</code>. The mutex <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10945"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">mtx</code> is acquired before executing the callout function and it’s dropped after the callout function returns (<code class="literal">mtx</code> is acquired and dropped by the callout subsystem). After <code class="literal">callout_init_mtx</code> returns, <code class="literal">mtx</code> is associated with the <code class="literal">callout</code> structure <code class="literal">c</code> and its callout function.</p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10972"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">flags</code> argument modifies <code class="literal">callout_init_mtx’s</code> behavior. <a class="xref" href="ch05s04.html#callout_underscore_init_underscore_mtx_s" title="Table 5-3. callout_init_mtx Symbolic Constants">Table 5-3</a> displays its only valid value.</p><div class="table"><a id="callout_underscore_init_underscore_mtx_s"/><p class="title">Table 5-3. callout_init_mtx Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="callout_init_mtx Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">CALLOUT_RETURNUNLOCKED</code></p></td><td style="text-align: left" valign="top"><p>Indicates that the callout function will drop mtx itself; in other words, <code class="literal">mtx</code> is not dropped after the callout function returns, but during.</p></td></tr></tbody></table></div></div><p>The <code class="literal">callout_init_rw</code> function is an alternative to <code class="literal">callout_init</code>. The rw lock <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11020"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">rw</code> is acquired, as a writer, before executing the callout function and it’s dropped after the callout function returns (<code class="literal">rw</code> is acquired and dropped by the callout subsystem). After <code class="literal">callout_init_rw</code> returns, <code class="literal">rw</code> is associated with the <code class="literal">callout</code> structure <code class="literal">c</code> and its callout function.</p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11048"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">flags</code> argument modifies <code class="literal">callout_init_rw</code>’s behavior. <a class="xref" href="ch05s04.html#callout_underscore_init_underscore_rw_sy" title="Table 5-4. callout_init_rw Symbolic Constants">Table 5-4</a> displays its only valid value.</p><div class="table"><a id="callout_underscore_init_underscore_rw_sy"/><p class="title">Table 5-4. callout_init_rw Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="callout_init_rw Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">CALLOUT_SHAREDLOCK</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">rw</code> to be acquired as a reader</p></td></tr></tbody></table></div></div><p>The <code class="literal">callout_stop</code> function cancels a callout function that’s currently pending. If successful, a nonzero value is returned. If 0 is returned, the callout function is either currently executing or it has already finished executing.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You must exclusively hold the lock associated with the callout function that you’re trying to stop before calling <code class="literal">callout_stop</code>.<a class="indexterm" id="IDX-CHP-5-0067"/><a class="indexterm" id="IDX-CHP-5-0068"/><a class="indexterm" id="IDX-CHP-5-0069"/><a class="indexterm" id="IDX-CHP-5-0070"/><a class="indexterm" id="IDX-CHP-5-0071"/></p></div><p>The <code class="literal">callout_drain</code> function is identical to <code class="literal">callout_stop</code> except that if the callout function is currently executing, it waits for the callout function to finish before returning. If the callout function that you’re trying to stop requires a lock and you’re exclusively holding that lock while calling <code class="literal">callout_drain</code>, deadlock will result.</p><p>The <code class="literal">callout_reset</code> function schedules the function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11136"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">func</code> to be executed, one time, after <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11145"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">ticks</code> / <code class="literal">hz</code> seconds; negative values for <code class="literal">ticks</code> are converted to <code class="literal">1</code>. When func is called, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11164"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">arg</code> will be its first and only argument. After <code class="literal">callout_reset</code> returns, <code class="literal">func</code> is the callout function for the callout structure <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11180"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">c</code>.</p><p>The <code class="literal">callout_reset</code> function can also reschedule a pending callout function to execute at a new time.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You must exclusively hold the lock associated with the callout or callout function that you’re trying to establish or reschedule before calling <code class="literal">callout_reset</code>.</p></div><p>The <code class="literal">callout_schedule</code> function reschedules a pending callout function to execute at a new time. This function is simply a convenience wrapper for <code class="literal">callout_reset</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You must exclusively hold the lock associated with the callout function that you’re trying to reschedule before calling <code class="literal">callout_schedule</code>.</p></div></div>
<div class="sect1" title="Callouts and Race Conditions"><div class="titlepage"><div><div><h1 class="title"><a id="callouts_and_race_conditions"/>Callouts and Race Conditions</h1></div></div></div><p>Because callout functions execute asynchronously, it’s possible for a callout function to be called while another thread attempts to stop or reschedule it; thus creating a race condition. Fortunately, there are two simple solutions available for solving this problem:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Use</strong></span> <strong class="userinput"><code>callout_init_mtx</code></strong>, <strong class="userinput"><code>callout_init_rw</code></strong>, <span class="strong"><strong>or</strong></span> <strong class="userinput"><code>callout_init(foo, 0)</code></strong></span></dt><dd><p>Callout functions associated with a lock are exempt from the race condition described above—as long as the associated lock is held before calling the callout management functions.</p></dd><dt><span class="term"><span class="strong"><strong>Use</strong></span> <strong class="userinput"><code>callout_drain</code></strong> <span class="strong"><strong>to permanently cancel a callout function</strong></span></span></dt><dd><p>Use <code class="literal">callout_drain</code> instead of <code class="literal">callout_stop</code> to permanently cancel a callout function. See, by waiting for the callout function to finish, you can’t destroy any objects that it might need.</p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>We’ll walk through an example that uses callouts in <a class="xref" href="ch06.html" title="Chapter 6. Case Study: Virtual Null Modem">Chapter 6</a>.</p></div></div>
<div class="sect1" title="Taskqueues"><div class="titlepage"><div><div><h1 class="title"><a id="taskqueues"/>Taskqueues</h1></div></div></div><p><span class="emphasis"><em>Taskqueues</em></span> allow drivers to schedule the asynchronous execution of one or more functions at a later time. These functions are known as <span class="emphasis"><em>tasks</em></span>. Taskqueues are primarily used for deferred work.<a class="indexterm" id="IDX-CHP-5-0072"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Taskqueues are like callouts except that you can’t specify the time to execute your functions.<a class="indexterm" id="IDX-CHP-5-0073"/><a class="indexterm" id="IDX-CHP-5-0074"/><a class="indexterm" id="IDX-CHP-5-0075"/><a class="indexterm" id="IDX-CHP-5-0076"/><a class="indexterm" id="IDX-CHP-5-0077"/></p></div><p>Taskqueues work by having tasks queued on them. Intermittently, these tasks get executed.</p><div class="sect2" title="Global Taskqueues"><div class="titlepage"><div><div><h2 class="title"><a id="global_taskqueues"/>Global Taskqueues</h2></div></div></div><p>FreeBSD runs and maintains four global taskqueues:<a class="indexterm" id="IDX-CHP-5-0078"/><a class="indexterm" id="IDX-CHP-5-0079"/><a class="indexterm" id="IDX-CHP-5-0080"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>taskqueue_swi</code></strong></span></dt><dd><p>The <code class="literal">taskqueue_swi</code> taskqueue executes its tasks in the context of an interrupt. Interrupt handlers typically defer their computationally expensive work to this taskqueue. This taskqueue lets interrupt handlers finish sooner, thereby reducing the amount of time spent with interrupts disabled. Interrupt handlers are discussed in detail in <a class="xref" href="ch08.html" title="Chapter 8. Interrupt Handling">Chapter 8</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>taskqueue_swi_giant</code></strong></span></dt><dd><p>The <code class="literal">taskqueue_swi_giant</code> taskqueue is identical to <code class="literal">taskqueue_swi</code> except that it acquires the <code class="literal">Giant</code> mutex before executing its tasks. Contemporary code should avoid this taskqueue.</p></dd><dt><span class="term"><strong class="userinput"><code>taskqueue_thread</code></strong></span></dt><dd><p>The <code class="literal">taskqueue_thread</code> taskqueue is the general-purpose taskqueue. It executes its tasks in the context of a kernel thread (which is the same context that drivers execute in). You can use this taskqueue when you have code that executes without a thread context (such as an interrupt handler) that needs to execute code that requires a thread context.</p></dd><dt><span class="term"><strong class="userinput"><code>taskqueue_fast</code></strong></span></dt><dd><p>The <code class="literal">taskqueue_fast</code> taskqueue is identical to <code class="literal">taskqueue_thread</code> except that it acquires a spin mutex before executing its tasks. Use this taskqueue when your tasks cannot sleep.</p></dd></dl></div></div><div class="sect2" title="Taskqueue Management Routines"><div class="titlepage"><div><div><h2 class="title"><a id="taskqueue_management_routines"/>Taskqueue Management Routines</h2></div></div></div><p>The FreeBSD kernel provides the following macro and functions for working with taskqueues:</p><a id="I_programlisting5_d1e11383"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/malloc.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/taskqueue.h&gt;

typedef void (*task_fn_t)(void *context, int pending);

struct task {
        STAILQ_ENTRY(task)      ta_link;        /* Link for queue. */
        u_short               <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>ta_pending;     /* # of times queued. */
        u_short                 ta_priority;    /* Task priority. */
        task_fn_t               ta_func;        /* Task handler function. */
        void                    *ta_context;    /* Argument for handler. */
};

TASK_INIT(struct task <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*task, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>priority, task_fn_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>*func,
    void <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>*context);

int
taskqueue_enqueue(struct taskqueue <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>*queue, struct task <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*task);

void
taskqueue_run(struct taskqueue <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>*queue);

void
taskqueue_drain(struct taskqueue <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>*queue, struct task <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>*task);</pre><p>The <code class="literal">TASK_INIT</code> macro initializes the <code class="literal">task</code> structure <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11454"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">task</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11463"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">priority</code> argument is <code class="literal">task</code>’s position on a taskqueue. The <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11476"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">func</code> argument is the function to be executed (one time). When <code class="literal">func</code> is called, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11488"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">context</code> will be its first argument and the value of <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11498"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">ta_pending</code> will be its second.<a class="indexterm" id="IDX-CHP-5-0081"/><a class="indexterm" id="IDX-CHP-5-0082"/><a class="indexterm" id="IDX-CHP-5-0083"/><a class="indexterm" id="IDX-CHP-5-0084"/><a class="indexterm" id="IDX-CHP-5-0085"/><a class="indexterm" id="IDX-CHP-5-0086"/></p><p>The <code class="literal">taskqueue_enqueue</code> function puts <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11531"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">task</code> on the taskqueue <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11540"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">queue</code> right before the first <code class="literal">task</code> structure that has a lower <code class="literal">priority</code> value. If <code class="literal">taskqueue_enqueue</code> gets called to put <code class="literal">task</code> on <code class="literal">queue</code> again, <code class="literal">task</code>’s <code class="literal">ta_pending</code> value is incremented—another copy of <code class="literal">task</code> is <span class="emphasis"><em>not</em></span> put on <code class="literal">queue</code>.</p><p>The <code class="literal">taskqueue_run</code> function executes every task on the taskqueue <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11586"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">queue</code> in the order of the task’s <code class="literal">priority</code> value. After each task finishes, its <code class="literal">task</code> structure is removed from <code class="literal">queue</code>. Then its <code class="literal">ta_pending</code> value is zeroed and <code class="literal">wakeup</code> is called on its <code class="literal">task</code> structure. Note that you’ll never call <code class="literal">taskqueue_run</code>, because each taskqueue has threads dedicated to do just that.</p><p>The <code class="literal">taskqueue_drain</code> function waits for <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11622"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> task, which is on <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11628"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">queue</code>, to finish executing.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We’ll walk through an example that uses taskqueues in <a class="xref" href="ch06.html" title="Chapter 6. Case Study: Virtual Null Modem">Chapter 6</a>.</p></div></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id4"/>Conclusion</h1></div></div></div><p>This chapter covered the four different methods for delaying execution:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>Sleeping</strong></span> Sleeping is done when you must wait for something to occur before you can proceed.</td></tr><tr><td><span class="strong"><strong>Event Handlers</strong></span> Event handlers let you register one or more functions to be executed when an event occurs.</td></tr><tr><td><span class="strong"><strong>Callouts</strong></span> Callouts let you perform asyn chronous code execution. Callouts are used to execute your functions at a specific time.</td></tr><tr><td><span class="strong"><strong>Taskqueues</strong></span> Taskqueues also let you perform asynchronous code execution. Taskqueues are used for deferred work.</td></tr></table></div></body></html>