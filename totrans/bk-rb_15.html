<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Marshal"><div class="titlepage"><div><div><h1 class="title"><a id="marshal"/>Chapter 15. Marshal</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id18"/><div class="mediaobject"><a id="I_mediaobject15_d1e17343"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>An alternative way of saving and loading data is provided by Ruby’s Marshal library. This has a similar set of methods to YAML to enable you to save and load data to and from disk.<a id="IDX-CHP-15-0001" class="indexterm"/><a id="IDX-CHP-15-0002" class="indexterm"/></p><div class="sect1" title="Saving and Loading Data"><div class="titlepage"><div><div><h1 class="title"><a id="saving_and_loading_data"/>Saving and Loading Data</h1></div></div></div><p>Compare the following program with <span class="emphasis"><em>yaml_dump2.rb</em></span> from the previous chapter:<a id="IDX-CHP-15-0003" class="indexterm"/></p><p><span class="emphasis"><em>marshal1.rb</em></span></p><a id="I_programlisting15_d1e17374"/><pre class="programlisting">f = File.open( 'friends.sav', 'w' )
Marshal.dump( ["fred", "bert", "mary"], f )
f.close

File.open( 'morefriends.sav', 'w' ){ |friendsfile|
    Marshal.dump( ["sally", "agnes", "john" ], friendsfile )
}

File.open( 'morefriends.sav' ){ |f|
    $arr= Marshal.load(f)
}
myfriends = Marshal.load(File.open( 'friends.sav' ))
morefriends = Marshal.load(File.open( 'morefriends.sav' ))

p( myfriends )    #=&gt; ["fred", "bert", "mary"]
p( morefriends )  #=&gt; ["sally", "agnes", "john"]
p( $arr )         #=&gt; ["sally", "agnes", "john"]</pre><p>The two programs are pretty much identical except that each occurrence of <code class="literal">YAML</code> (as in <code class="literal">YAML.dump</code> and <code class="literal">YAML.load</code>) has been replaced with <code class="literal">Marshal</code>. Moreover, Marshal is “built in” to Ruby as standard, so you don’t have to <code class="literal">require</code> any extra files in order to use it.<a id="IDX-CHP-15-0004" class="indexterm"/><a id="IDX-CHP-15-0005" class="indexterm"/><a id="IDX-CHP-15-0006" class="indexterm"/></p><p>If you look at the data files produced (such as <span class="emphasis"><em>friends.sav</em></span>), you will immediately see that there is a major difference, however. Whereas YAML files are in plaintext format, Marshal files are in binary format. So although you may be able to read <span class="emphasis"><em>some</em></span> characters, such as those in the strings, you won’t simply be able to load the saved data and modify it in a text editor.</p><p>As with YAML, most data structures can be automatically serialized using Marshal just by dumping the top-level object and loading it when you want to reconstruct all the objects beneath it. For an example, take a look at my little adventure game program. In the previous chapter, I explained how to save and restore a Map containing Rooms containing Treasures just by dumping and loading the Map object, <code class="literal">mymap</code> (see <span class="emphasis"><em>gamesave_y.rb</em></span> in <a class="xref" href="ch14s07.html" title="Adventures in YAML">Adventures in YAML</a>). You can do the same using Marshal instead of YAML:</p><p><span class="emphasis"><em>gamesave_m.rb</em></span></p><a id="I_programlisting15_d1e17430"/><pre class="programlisting">File.open( 'game.sav', 'w' ){ |f|
    Marshal.dump( mymap, f )    # save data to file
}

File.open( 'game.sav' ){ |f|
    mymap = Marshal.load(f)     # reload saved data from file
}</pre><p>Objects cannot be so easily serialized in a few special circumstances. These exceptions are documented in the code of Ruby’s <code class="literal">Marshal</code> module (<span class="emphasis"><em>marshal.c</em></span>), which states, “If the objects to be dumped include bindings, procedure or method objects, instances of class IO, or singleton objects, a TypeError will be raised.” I’ll show an example of this while discussing how you might go about saving singletons with marshaling.<a id="IDX-CHP-15-0007" class="indexterm"/></p></div></div>
<div class="sect1" title="Omitting Variables on Saving"><div class="titlepage"><div><div><h1 class="title"><a id="omitting_variables_on_saving-id1"/>Omitting Variables on Saving</h1></div></div></div><p>As with YAML serialization, it is possible to limit the variables that are saved when serializing using Marshal. In YAML, you did this by writing a method called <code class="literal">to_yaml_properties</code>. With Marshal, you need to write a method named <code class="literal">marshal_dump</code>. In the code of this method you should create an array containing the <span class="emphasis"><em>actual variables</em></span> to be saved (in YAML, you created an array of <span class="emphasis"><em>strings</em></span> containing the variable <span class="emphasis"><em>names</em></span>).<a id="IDX-CHP-15-0008" class="indexterm"/><a id="IDX-CHP-15-0009" class="indexterm"/></p><p>This is an example:</p><a id="I_programlisting15_d1e17476"/><pre class="programlisting">def marshal_dump
    [@variable_a, @variable_b]
end</pre><p>Another difference is that, with YAML, you were able simply to load the data in order to re-create an object. With Marshal, you need to add a special method called <code class="literal">marshal_load</code> to which any loaded data is passed as an argument. This will be invoked automatically when you call <code class="literal">Marshal.load</code>, and it will be passed the data in the form of an array. The previously saved objects can be parsed from this array. You can also assign values to any variables that were omitted (such as <code class="literal">@some_other_variable</code> here) when the data was saved:<a id="IDX-CHP-15-0010" class="indexterm"/><a id="IDX-CHP-15-0011" class="indexterm"/></p><a id="I_programlisting15_d1e17499"/><pre class="programlisting">def marshal_load(data)
    @variable_a = data[0]
    @variable_b = data[1]
    @some_other_variable = "a default value"
end</pre><p>Here is a complete program that saves and restores the variables <code class="literal">@num</code> and <code class="literal">@arr</code> but omits <code class="literal">@str</code>:</p><p><span class="emphasis"><em>limit_m.rb</em></span></p><a id="I_programlisting15_d1e17515"/><pre class="programlisting">class Mclass
    def initialize(aNum, aStr, anArray)
        @num = aNum
        @str = aStr
        @arr = anArray
    end

    def marshal_dump
        [@num, @arr]
    end

    def marshal_load(data)
        @num = data[0]
        @arr = data[1]
        @str = "default"
   end
end

ob = Mclass.new( 100, "fred", [1,2,3] )
p( ob )
#=&gt; #&lt;Mclass:0x2be7278 @num=100, @str="fred", @arr=[1, 2, 3]&gt;

marshal_data = Marshal.dump( ob )
ob2 = Marshal.load( marshal_data )
p( ob2 )
#=&gt; #&lt;Mclass:0x2be70e0 @num=100, @str="default", @arr=[1, 2, 3]&gt;</pre><p>Note that although the serialization is done here in memory, the same techniques can be used when using Marshal to save and load objects to and from disk.<a id="IDX-CHP-15-0012" class="indexterm"/><a id="IDX-CHP-15-0013" class="indexterm"/><a id="IDX-CHP-15-0014" class="indexterm"/></p></div>
<div class="sect1" title="Saving Singletons"><div class="titlepage"><div><div><h1 class="title"><a id="saving_singletons"/>Saving Singletons</h1></div></div></div><p>Let’s take a look at a concrete example of a problem mentioned earlier, namely, the inability to use marshaling to save and load a singleton. In <span class="emphasis"><em>singleton_m.rb</em></span> I have created an instance of Object, <code class="literal">ob</code>, and then extended it in the form of a singleton class that is given the additional method, <code class="literal">xxx</code>:</p><p><span class="emphasis"><em>singleton_m.rb</em></span></p><a id="I_programlisting15_d1e17551"/><pre class="programlisting">ob = Object.new

class &lt;&lt; ob
    def xxx( aStr )
        @x = aStr
    end
end</pre><p>The problem arises when I try to save this data to disk using <code class="literal">Marshal.dump</code>. Ruby displays an error message: “singleton can’t be dumped (TypeError).”</p><div class="sect2" title="YAML and Singletons"><div class="titlepage"><div><div><h2 class="title"><a id="yaml_and_singletons"/>YAML and Singletons</h2></div></div></div><p>Before considering how you might deal with this, let’s briefly take a look at how YAML would cope in this situation. The program <span class="emphasis"><em>singleton_y.rb</em></span> tries to save the singleton that I created a moment ago using <code class="literal">YAML.dump</code>, and, unlike <code class="literal">Marshal.dump</code>, it succeeds—well, sort of:</p><p><span class="emphasis"><em>singleton_y.rb</em></span></p><a id="I_programlisting15_d1e17575"/><pre class="programlisting"># YAML version of singleton-save
ob.xxx( "hello world" )

File.open( 'test.yml', 'w' ){ |f|
    YAML.dump( ob, f )
}

ob.xxx( "new string" )

File.open( 'test.yml' ){ |f|
    ob = YAML.load(f)
}</pre><p>If you look at the YAML file that is saved, <span class="emphasis"><em>test.yml</em></span>, you’ll find that it defines an instance of a plain-vanilla Object to which a variable named <code class="literal">x</code> is appended that has the string value <code class="literal">hello world</code>:</p><a id="I_programlisting15_d1e17588"/><pre class="programlisting">--- !ruby/object
x: hello world</pre><p>That’s all well and good. However, when you reconstruct the object by loading the saved data, the new <code class="literal">ob</code> will be a standard instance of Object, which happens to contain an additional instance variable, <code class="literal">@x</code>. Since it is no longer the original singleton, this <code class="literal">ob</code> will not have access to any of the methods (here the <code class="literal">xxx</code> method) defined in that singleton. So, although YAML serialization is more permissive about saving and loading data items that were created in a singleton, it does not automatically re-create the singleton itself when the saved data is reloaded.<a id="IDX-CHP-15-0015" class="indexterm"/><a id="IDX-CHP-15-0016" class="indexterm"/><a id="IDX-CHP-15-0017" class="indexterm"/></p></div><div class="sect2" title="Marshal and Singletons"><div class="titlepage"><div><div><h2 class="title"><a id="marshal_and_singletons"/>Marshal and Singletons</h2></div></div></div><p>Let’s now return to the Marshal version of this program. The first thing I need to do is find a way of at least making it save and load data items. Once I’ve done that, I’ll try to figure out how to reconstruct singletons on reloading.</p><p>To save specific data items, I can define the <code class="literal">marshal_dump</code> and <code class="literal">marshal_load</code> methods as explained earlier (see <span class="emphasis"><em>limit_m.rb</em></span>). These should normally be defined in a class from which the singleton derives, <span class="emphasis"><em>not</em></span> in the singleton itself. This is because, as already explained, when the data is saved, it will be stored as a representation of the class from which the singleton derives. This means that although you could indeed add <code class="literal">marshal_dump</code> to a singleton derived from class X, when you reconstruct the object, you will be loading data for an object of the generic type X, not of the specific singleton instance.<a id="IDX-CHP-15-0018" class="indexterm"/><a id="IDX-CHP-15-0019" class="indexterm"/></p><p>This code creates a singleton, <code class="literal">ob</code>, of class X, saves its data, and then re-creates a generic object of class X:</p><p><span class="emphasis"><em>singleton_m2.rb</em></span></p><a id="I_programlisting15_d1e17659"/><pre class="programlisting">class X
    def marshal_dump
        [@x]
    end

    def marshal_load(data)
        @x = data[0]
    end
end

ob = X.new

class &lt;&lt; ob
    def xxx( aStr )
        @x = aStr
    end
end

ob.xxx( "hello" )
p( ob )

File.open( 'test2.sav', 'w' ){ |f|
    Marshal.dump( ob, f )
}

ob.xxx( "new string" )
p( ob )
File.open( 'test2.sav' ){ |f|
    ob = Marshal.load(f)
}

p( ob )</pre><p>The code here uses <code class="literal">Marshal.dump</code> to save an object, <code class="literal">ob</code>, of class X and then calls the singleton method, <code class="literal">xxx</code>, to assign a different string to the <code class="literal">@x</code> variable before reloading the saved data using <code class="literal">Marshal.load</code> and using this data to re-create the object. The contents of <code class="literal">ob</code> are displayed using <code class="literal">p()</code> before it is saved, then again after a new string is assigned to it, and finally once again when it is reloaded. This lets you verify that <code class="literal">@x</code> is assigned the value that was saved when the reloaded object is reconstructed:</p><a id="I_programlisting15_d1e17688"/><pre class="programlisting">#&lt;X:0x2b86cc0 @x="hello"&gt;       # value when saved
#&lt;X:0x2b86cc0 @x="new string"&gt;  # new value then assigned
#&lt;X:0x2b869f0 @x="hello"&gt;       # value after saved data loaded</pre><p>In terms of the data it contains, the object saved and the object reloaded are identical. However, the object that is reloaded knows nothing about the singleton class. The method <code class="literal">xxx</code> that the singleton class contains forms no part of the reconstructed object. The following, then, would fail:</p><a id="I_programlisting15_d1e17695"/><pre class="programlisting">ob.xxx( "this fails" )</pre><p>This Marshal version of the code is equivalent to the YAML version given earlier. It saves and restores the data correctly, but it does not reconstruct the singleton. How, then, is it possible to reconstruct a singleton from saved data? There are, no doubt, many clever and subtle ways in which this might be accomplished. I shall, however, opt for a very simple technique:</p><p><span class="emphasis"><em>singleton_m3.rb</em></span></p><a id="I_programlisting15_d1e17703"/><pre class="programlisting">FILENAME = 'test2.sav'

class X
    def marshal_dump
        [@x]
    end

    def marshal_load(data)
        @x = data[0]
    end
end

ob = X.new

# a) if File exists, load data into ob - a generic X object
if File.exists?(FILENAME) then
    File.open(FILENAME){ |f|
        ob = Marshal.load(f)
    }
else
    puts( "Saved data can't be found" )
end
# b) Now transform ob in a singleton
class &lt;&lt; ob
    def xxx=( aStr )
        @x = aStr
    end

    def xxx
        return @x
    end
end</pre><p>This code first checks whether a file containing the saved data can be found. (This sample has been kept deliberately simple—in a real application you would of course need to write some exception-handling code to deal with the possibility of reading in invalid data.) If the file is found, the data is loaded into an object of the generic <code class="literal">X</code> type.</p><p>Only when this has been done is this object “transformed” into a singleton in the usual way. In other words, the object is loaded, and then the code beginning <code class="literal">class &lt;&lt; ob</code> executes (simply because the singleton-creation code occurs after the loading code and so is executed in sequence by the Ruby interpreter). This provides the object with the additional <code class="literal">xxx</code> singleton method. You can then save the new data back to disk and reload and re-create the modified singleton, as explained earlier, at a later stage:</p><a id="I_programlisting15_d1e17718"/><pre class="programlisting">if ob.xxx == "hello" then
   ob.xxx = "goodbye"
else
   ob.xxx = "hello"
end

File.open( FILENAME, 'w' ){ |f|
    Marshal.dump( ob, f )
}</pre><p>If you wanted to save and load singletons in a real application, the singleton “reconstruction” code could, naturally, be given its own method so that you don’t have to rely upon its position in your code as in the previous example.</p><p><span class="emphasis"><em>singleton_m4.rb</em></span></p><a id="I_programlisting15_d1e17725"/><pre class="programlisting">def makeIntoSingleton( someOb )
   class &lt;&lt; someOb
      def xxx=( aStr )
         @x = aStr
      end

      def xxx
         return @x
      end
   end
   return someOb
end</pre><div class="sidebar"><a id="digging_deeper-id14"/><p class="title">Digging Deeper</p><p>If you attempt to load data that was saved with a different version of the Marshal library you may run into problems. Here you will learn how to verify the version of Marshal.<a id="IDX-CHP-15-0020" class="indexterm"/><a id="IDX-CHP-15-0021" class="indexterm"/><a id="IDX-CHP-15-0022" class="indexterm"/></p><p><span class="bolditalic">Marshal Version Numbers</span></p><p>The embedded documentation of the Marshal library (a C language file named <span class="emphasis"><em>marshal.c</em></span>) states the following: “Marshaled data has major and minor version numbers stored along with the object information. In normal use, marshaling can only load data written with the same major version number and an equal or lower minor version number.”</p><p>This clearly raises the potential problem that the format of data files created by marshaling may be incompatible with the current Ruby application. The Marshal version number, incidentally, is not dependent on the Ruby version number, so it is not safe to make assumptions of compatibility based solely on the Ruby version.</p><p>This possibility of incompatibility means you should always check the version number of the saved data before attempting to load it. But how do you get hold of the version number? Once again, the embedded documentation provides a clue. It states, “You can extract the version by reading the first two bytes of marshaled data.”</p><p>Ruby 1.8 provides this example:</p><a id="I_programlisting15_d1e17761"/><pre class="programlisting">str = Marshal.dump("thing")
RUBY_VERSION       #=&gt; "1.8.0"
str[0]             #=&gt; 4
str[1]             #=&gt; 8</pre><p>Okay, so let’s try this in a fully worked piece of code. Here goes:</p><p><span class="emphasis"><em>version_m.rb</em></span></p><a id="I_programlisting15_d1e17768"/><pre class="programlisting">x = Marshal.dump( "hello world" )
print( "Marshal version: #{x[0]}:#{x[1]}\n" )</pre><p>In the previous code, <code class="literal">x</code> is a string, and its first two bytes are the major and minor version numbers. In Ruby 1.8, this prints out the following:</p><a id="I_programlisting15_d1e17776"/><pre class="programlisting">Marshal version: 4:8</pre><p>In Ruby 1.9, however, no numbers are displayed. This is because the first two bytes are returned as integers in Ruby 1.8 but as strings in Ruby 1.9. These strings are not necessarily printable. You can see this quite simply by using the <code class="literal">p()</code> method to display the elements at index 0 and index 1 of the array <code class="literal">x</code>:</p><a id="I_programlisting15_d1e17786"/><pre class="programlisting">p( x[0] )   #=&gt; 4 (Ruby 1.8)    "\x04" (Ruby 1.9)
p( x[1] )   #=&gt; 8 (Ruby 1.8)    "\b"   (Ruby 1.9)</pre><p>The strings returned by Ruby 1.9 may be shown either as hexadecimal values or as escape characters. Here you can see that, for Marshal version 4.8, the first value is \x04, which is the hexadecimal representation of 4, while the second value is \b, which is the escape character for the backspace that happens to have the ASCII value of 8. The <code class="literal">ord</code> method can be used to do the necessary conversion from string to integer. This is the Ruby 1.9 version:<a id="IDX-CHP-15-0023" class="indexterm"/><a id="IDX-CHP-15-0024" class="indexterm"/></p><a id="I_programlisting15_d1e17801"/><pre class="programlisting">print( "Marshal version: #{x[0].ord}:#{x[1].ord}\n" )</pre><p>This now correctly displays the version number: <code class="literal">4:8</code>. Of course, if you are using a different version of the Marshal library, the numbers displayed will be different. The Marshal library also declares two constants, <code class="literal">MAJOR_VERSION</code> and <code class="literal">MINOR_VERSION</code>, which store the version numbers of the Marshal library currently in use. So, at first sight, it looks as though it should be easy to compare the version number of saved data with the current version number.</p><p>There is just one problem: When you save data to a file on disk, the <code class="literal">dump</code> method takes an IO or File object, and it returns an IO (or File) object rather than a string:</p><p><span class="emphasis"><em>version_error.rb</em></span></p><a id="I_programlisting15_d1e17822"/><pre class="programlisting">f = File.open( 'friends.sav', 'w' )
x = Marshal.dump( ["fred", "bert", "mary"], f )
f.close        #=&gt; x is now: #&lt;File:friends.sav (closed)&gt;</pre><p>If you now try to get the values of <code class="literal">x[0]</code> and <code class="literal">x[1]</code>, you will receive an error message:</p><a id="I_programlisting15_d1e17833"/><pre class="programlisting">p( x[0] )
#=&gt; Error: undefined method '[]' for #&lt;File:friends.sav (closed)&gt; (NoMethodError)</pre><p>Loading the data back from the file is no more instructive:</p><a id="I_programlisting15_d1e17837"/><pre class="programlisting">File.open( 'friends.sav' ){ |f|
    x = Marshal.load(f)
}

puts( x[0] )
puts( x[1] )</pre><p>The two <code class="literal">puts</code> statements here don’t (as I was naively hoping) print out the major and minor version numbers of the marshaled data; in fact, they print out the names “fred” and “bert”—that is, the two first items loaded into the array, <code class="literal">x</code>, from the data file, <span class="emphasis"><em>friends.sav</em></span>.</p><p>So, how the heck can you get the version number from the saved data? I have to admit that I was forced to read my way through the C code (not my favorite activity!) in <span class="emphasis"><em>marshal.c</em></span> and examine the hexadecimal data in a saved file to figure this out. It turns out that, just as the documentation says, “You can extract the version by reading the first two bytes of marshaled data.” However, this isn’t done for you. You have to read this data explicitly, as shown here:</p><p><span class="emphasis"><em>version_m2.rb</em></span></p><a id="I_programlisting15_d1e17858"/><pre class="programlisting">f = File.open('test2.sav')
if (RUBY_VERSION.to_f &gt; 1.8) then
    vMajor = f.getc().ord
    vMinor = f.getc().ord
else
    vMajor = f.getc()
    vMinor = f.getc()
end
f.close</pre><p>Here the <code class="literal">getc</code> method reads the next 8-bit byte from the input stream. Notice that I have once again written a test to make this compatible both with Ruby 1.8, in which <code class="literal">getc</code> returns a numeric character value, and with Ruby 1.9, in which <code class="literal">getc</code> returns a one-character string that has to be converted to an integer using <code class="literal">ord</code>.<a id="IDX-CHP-15-0025" class="indexterm"/><a id="IDX-CHP-15-0026" class="indexterm"/><a id="IDX-CHP-15-0027" class="indexterm"/></p><p>My sample project, <span class="emphasis"><em>version_m2.rb</em></span>, shows a simple way of comparing the version number of the saved data with that of the current Marshal library in order to establish whether the data formats are likely to be compatible before attempting to reload the data.</p><a id="I_programlisting15_d1e17893"/><pre class="programlisting">if vMajor == Marshal::MAJOR_VERSION then
   puts( "Major version number is compatible" )
   if vMinor == Marshal::MINOR_VERSION then
      puts( "Minor version number is compatible" )
   elsif vMinor &lt; Marshal::MINOR_VERSION then
      puts( "Minor version is lower - old file format" )
   else
      puts( "Minor version is higher - newer file format" )
   end
else
   puts( "Major version number is incompatible" )
end</pre></div></div></div></body></html>