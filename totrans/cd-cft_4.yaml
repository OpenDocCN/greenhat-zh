- en: Part V. PART OF THE PROCESS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing high-quality software isn't just about churning out good code. Obviously,
    good code helps. A little. But there's much more to it than that. Good software
    is created intentionally; it takes planning, foresight, and a robust battle plan.
    We'll see exactly what this battle plan looks like in the next section. However,
    before we assemble the troops, we must know what they should do. It helps to point
    them all in the same direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section looks at some specific parts of the development process, the extra
    activities we schedule time for that help us to intentionally craft excellent
    code. We''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: How to write and read software specifications. The correct approach to recording
    what you will do, and what you have done. This chapter shows how specifications
    can make your life easier, rather than get on your nerves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  prefs: []
  type: TYPE_NORMAL
- en: A discussion of *code reviews*—an important practice that ensures you are writing
    high-quality code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 21](ch21.html "Chapter 21. HOW LONG IS A PIECE OF STRING?")'
  prefs: []
  type: TYPE_NORMAL
- en: Software timescale estimation—an essential activity in the planning process,
    yet still one of the mystic black arts of the software development community.
    This chapter busts some estimation myths and provides practical advice to use
    on the front line.
  prefs: []
  type: TYPE_NORMAL
- en: The relentless pressures of the software factory continually drive us to work
    faster and harder. The only way to cope is to learn ways to work smarter. We need
    to employ each of these pracices to stand a chance in the endgame.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19. BEING SPECIFIC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing Software Specifications*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've never known any trouble that an hour's reading didn't assuage.
  prefs: []
  type: TYPE_NORMAL
- en: --Charles De Secondat
  prefs: []
  type: TYPE_NORMAL
- en: Almost everything worth using is documented. Your DVD player has an instruction
    manual. Your car has a maintenance manual. A contract has small print. Chocolate
    cake has a recipe. There are books and magazines dedicated to practically every
    pursuit known to man. If your software is worth using, it also should be well
    documented.^([[1](#ftn.CHP-19-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: We all know that the carefully tested software we give to our customers needs
    to have documentation. Just how much documentation is a moot point. The user of
    an office suite certainly thinks there should be more than the publisher does.
    Without a manual to describe the usage mechanics of your software, whatever form
    it takes, people will falsely assume that it can do more than it was designed
    to, or use it for purposes no sane programmer would have ever imagined.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can just as easily make the same kinds of mistakes during coding.
    Just as the final software product needs documentation, so do the intermediate
    development steps. This is the sort of documentation that the end user will (usually)
    never see. These are the definitions of how the program will be designed and built.
    These are the software *specifications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing and working with specifications is an important skill of the practicing
    programmer. Communicating in English (or any other natural language) is just as
    important as communicating in code.^([[2](#ftn.CHP-19-FN-2)]) Like eating your
    vegetables and exercising regularly, specifications are "good for you" and good
    for your software. However, like cabbage and the gym, we avoid them, feel guilty,
    and then live to regret the consequences: We end up with unhealthy, flabby software
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional notion of a software specification involves a huge wedge of
    paper filled with dense text, cryptic tables, and meaningless terminology. It''s
    a highly uninspiring prospect: a document that requires more maintenance effort
    than the code it describes. Developers live in perpetual fear of being forced
    to work with the spec.'
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn't have to be this way. Used correctly, specifications oil the development
    process. They reduce development risk, help you to work effectively, and make
    your life a lot easier. In this chapter, we'll investigate the sorts of specifications
    we need, what should be in them, and why reality differs so greatly from this
    ideal.
  prefs: []
  type: TYPE_NORMAL
- en: What Are They, Specifically?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply your heart to instruction and your ears to words of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: --Proverbs 23:12
  prefs: []
  type: TYPE_NORMAL
- en: Specifications are formal documents that form part of the development process,
    providing internal software documentation. There are many different types of specification
    (we'll see them shortly) containing different information and targeted at different
    audiences. Each one is appropriate to a particular stage of the software construction
    process, from the conception of a project to its final deliverable. We use them
    to capture exactly what the user requires (or exactly what they are going to get,
    if the two differ—they usually do), to detail the architecture of a software solution,
    the interface of a particular code module, the design and implementation decisions
    for a piece of code, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Specifications help you to work smarter and to produce better software. But
    a bad specification can do quite the opposite. Like your code, the quality of
    a software specification is vital. Good specifications and documentation are generally
    taken for granted, whereas poor specifications rapidly become loathed; a millstone
    around the project's neck.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Not just the existence, but also the quality of software specifications is
    vital to the software development process*.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifications are a form of inter- and intrateam communication. We've seen
    that projects can die from a lack of communication. We should therefore exploit
    specifications as a communication medium—where appropriate. (Projects can just
    as easily fail because too much time is spent writing documents, and not enough
    time is actually spent writing software!)
  prefs: []
  type: TYPE_NORMAL
- en: Specifications become increasingly important as the size of a project increases.
    This is not because specifications are unimportant in smaller projects but because
    larger projects have more to lose—there are more people whose lack of communication
    and coordination will have a greater negative impact on the outcome of the software
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specifications are an important communication mechanism for software developers.
    Use them to capture information that must not be lost or forgotten*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing specifications helps to make your information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information isn''t stored in people''s heads where it can be lost, forgotten,
    or remembered incorrectly. With all important facts written down, there''s less
    risk when people leave the project: The amount of information loss will be minimized,
    and there will be a solid base to help any replacement programmer get up to speed.'
  prefs: []
  type: TYPE_NORMAL
- en: Thorough, complete specifications reduce the risk of two people making different
    sets of assumptions—the classic reason why two separately created modules do not
    worktogether when first integrated. Specifications help to prevent subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessible**'
  prefs: []
  type: TYPE_NORMAL
- en: All information is conveniently recorded in a known place. New people can join
    your project and understand what each component does and how they fit together,
    just by reading the documentation. They don't have to search for the information
    in a hundred different people's heads before they become productive.
  prefs: []
  type: TYPE_NORMAL
- en: '**More accurate**'
  prefs: []
  type: TYPE_NORMAL
- en: When all information is gathered and captured, you are more likely to see problems,
    to indentify missing parts of the design, and to spot any unfortunate consequences
    or side effects. A few disconnected thoughts floating around your brain are not
    as easy to validate.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-19-FN-1)]) Of course, that's no excuse to craft a bad interface;
    it must still be easy and intuitive to use.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-19-FN-2)]) Indeed, Dijkstra once remarked, "Besides a mathematical
    inclination, an exceptionally good mastery of one's native tongue is the most
    vital asset of a competent programmer."
  prefs: []
  type: TYPE_NORMAL
- en: The Types of Specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each type of specification forms an intermediate gate of the software process:
    A method of handover between separate parts of the development process. For example,
    a specification for the API of a software component is written by the group of
    people who are scoping its functionality and interface. The programmer works to
    this specification; it is complete enough to implement all the code. The same
    specification is a contract detailing how the systems integrator can stitch it
    into the system and how other programmers can use it. It also describes expected
    behavior, so the test department can validate that the software is working correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the output of one specification flows naturally into the contents
    of the next, leaving a trail of documents in the wake of the rapidly evolving
    software. An example of this paper trail is shown in [Figure 19-1](ch19s02.html#the_typical_specification_paper_trail
    "Figure 19-1. The typical specification paper trail"). We see a natural hierarchy
    of documents generated as a project matures—each subcomponent has a similar set
    of documents to the overall project; its development can be managed as a mini-project.
  prefs: []
  type: TYPE_NORMAL
- en: Since software design is an iterative process, this is not a one-way flow of
    information (otherwise you're trapped in a waterfall methodology straight-jacket—see
    "[Waterfall Model](ch22s03.html#waterfall_model "Waterfall Model")" on page 427).
    As you discover missing information or need to adjust the software design, the
    specifications must be updated accordingly. If your documents are not malleable
    and maintainable, your software development will suffer. Bureaucratic development
    processes try to stifle good software development by ensuring that all work is
    performed to The Specification, even if it's 10 years old and completely out of
    date. Good programmers consider their specifications to be just as malleable as
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: '![The typical specification paper trail](tagoreillycom20080909nostarchimages207566.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 19-1. The typical specification paper trail**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the different types of software specifications and see how they
    enhance your code-writing lifestyle. Unfortunately, in the Real World, these documents
    are called by many different names. A *requirements specification* is variously
    called a *user requirements specification* and a *functional constraints specification*
    by different people.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all other specifications disappeared in a software development process meltdown,
    this is the one document that you should fight for. It's the head of the merry
    software development parade and the stumbling block for many failing projects.
    The information in here is vital. It will keep you sane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for a project are never clear at first; customers can''t tell
    you *exactly* what they want their software to do (they''re not computer experts,
    so they don''t know). This can cause all kinds of problems, so there must be a
    single document that pins down what your software is supposed to do and the characteristics
    of an acceptable implementation: the *requirements specification*. It lists in
    great detail (or at least appropriate detail, which will usually be great) how
    the code is expected to behave. It must cover all the important, high-risk, high-value
    areas of system behavior, comprehensively and unambiguously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements are usually written as a series of numbered sentences each
    containing a single factual piece of information. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.5 The user interface shall consist of a black rectangle containing the words
    Don't Panic in a red sans-serif typeface at 13pt.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniquely numbering each requirement enables easy cross-referencing in subsequent
    documents and helps you to trace a particular design or implementation decision
    back to a single requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These requirements detail what the program must do. For example: *Must process
    BMP images and convert them to either JPEG or GIF format*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These requirements show how fast it must work and whether there are operations
    with deadlines. For example: *The user must receive feedback for every operation
    within one second, and all operations must complete within five seconds*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interoperability requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These requirements describe the other software, hardware, and external systems
    that it must interact with. For example: *Must support HTTP and RS232 communication
    with an upgrade server*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Future operation requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These requirements determine what functionality must be *accommodated* now,
    even if it''s not implemented right away. For example: *Must provide a skinnable
    UI so that the user can customize the look and feel*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These requirements fall into two camps. *Discrete requirements* are binary.
    You can easily check whether your program meets them by looking at the source:
    There will be a chunk of code dedicated to each bit of functionality. You can
    write specific tests to ensure that each discrete requirement is honored.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Nondiscrete requirements* are less tangible. You can''t check whether your
    program meets them just by inspecting the source. These include the required fault-tolerance
    of a system, the required uptime of a server, a program''s mean time between failure,
    its security, or its scalability. These kinds of requirements can be massively
    important and remarkably hard to verify.'
  prefs: []
  type: TYPE_NORMAL
- en: The process for creating a requirements specification will differ from company
    to company, and often depends on the project characteristics and the customers
    (how smart and competent they are). The requirements specification is collated
    by the marketing team, a future product focus group, or a *business analyst* whose
    job is to understand the problem domain and scope the work required. Usually the
    customer, or a representative of the customer, is involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customer must agree to and sign off on the requrements specification; it
    forms an effective contract between the software developer and its client. The
    supplier agrees to ship a product whose functionality meets these requirements;
    the customer agrees to pay for it. Without an agreed specification, the customer
    can refuse the product on a whim, and the developers will have spent a lot of
    effort to no avail. Sadly, this is a common problem in the software factory that
    I have seen many times, especially when the customer is not a technical expert
    and doesn''t know what a good software solution looks like. When the requested
    software is finally built, the customer realizes that what it asked for wasn''t
    what it actually wanted: *Rewrite it in pink*. You''re back to square one. This
    sort of thing happens all the time; the requirements specification is your insurance
    policy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, many software factories skip requirements gathering or do not give it
    sufficient import. It''s *vital* to agree on the requirements early on, before
    software design has started and certainly before any code has been written. We
    use the functional requirements specification:'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the project on track and on time—by preventing (or at least reducing)
    the tardy addition of new features that will postpone delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve customer satisfaction—by setting expectations up front.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce bugs—by restricting *feature creep*, we avoid last-minute code additions,
    which helps to avoid scary bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain your sanity—without requirements specifications, developers rapidly
    lose their hair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the type of development methodology you employ, a single monolithic
    requirements specification might be written up front before any software development
    begins, or it might be developed incrementally alongside the code. Understand
    how your requirements are gathered from the customer and how this impacts the
    way you develop code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software requirements must be captured early to set expectations, to prevent
    feature creep, and to reduce developer angst*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also consider your *developmental requirements*: the things that you as a developer
    must have in order to develop the software. For example, you might require a certain
    kind of internal architecture to provide adequate future extensibility, and you
    *need* version control to develop software (it is not optional). Some of these
    might justifiably belong in a requirements specification.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the document most frequently used by programmers, the *functional specification*
    describes the observable behavior of a piece of software. It is derived from—and
    must satisfy—the requirements specification. There are usually a number of functional
    specifications in one project: one for the overall product and then individual
    specifications for individual software components.'
  prefs: []
  type: TYPE_NORMAL
- en: For a software component, the functional specification includes a complete and
    unambiguous description of its public interface. This equates to a list of every
    method or function in the module's API, together with a description of what they
    do and how to use them. It contains details of all external data structures and
    formats, and all dependencies on other components, work packages, or specifications.
  prefs: []
  type: TYPE_NORMAL
- en: This is more than a user guide to a piece of software. There is enough detail
    to build the component from it. Two teams could read the document and work separately
    on implementions. Although the implementations will differ, both components should
    behave identically.
  prefs: []
  type: TYPE_NORMAL
- en: 'This fact is exploited in practice: Some NASA spacecraft employ five computers
    to do the job of one; four computers implement the specification for a particular
    computation, running independently developed implementations. The fifth computer
    is used to average the results of the four calculations (or to decide if one computer
    wildly disagrees with the others).'
  prefs: []
  type: TYPE_NORMAL
- en: If you're writing a software component without a functional specification, begin
    by writing one yourself. Show it to all interested parties so they can agree that
    what you'll build is sufficient and so they won't be surprised when it is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your software task is not adequately specified, don''t start coding until
    you''ve written a functional specification, and people agree that it''s correct*.'
  prefs: []
  type: TYPE_NORMAL
- en: System Architecture Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *architecture specification* describes the overall shape and structure
    of the software solution. It encompasses such things as:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical computer layout. (Is it distributed client/server software or a single
    user desktop application?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software componentization. (How is it split up? Which parts do we need to write;
    which can we buy in?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency. (How many threads run at the same time?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage (including database design).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other aspects of the system's architecture (redundancy, communication channels,
    and more).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to specify these things in detail before too much development
    work happens. The architecture affects the later stages of development; a mistake
    or ambiguity here will filter down to become serious flaws in later phases. Of
    course, nothing is set in stone: If you discover a flaw in the architecture specification,
    then it must be fixed, regardless of how much work has already occurred. Don''t
    accept a bad architecture specification as a millstone around your neck. However,
    it is important to perform adequate architectural design up front. We discuss
    software architecture in detail in [Chapter 14](ch14.html "Chapter 14. SOFTWARE
    ARCHITECTURE").'
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This document contains information about the user interface: what it will look
    like and how it will react. This is how we present the system''s capabilities
    to the user. It might describe a GUI application or a web-based interface, an
    audible phone menu system, a braille accessibility interface, or a simple, single-LED
    display.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes the user''s view of the system is very different from the implementation
    behind the shiny façade. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A highly networked system can be deployed on a single box and hidden behind
    a unified UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available functionality can be simplified for ease of use or to create a
    cut-down cheaper version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI specification describes the interface conventions and metaphors and shows
    how the user sees the functions interact. It is comprised of a textual description,
    with pictures and screenshots. It often contains a *storyboard* representation
    of the UI in action—a pictorial map of each UI state, its transitions, and what
    is displayed in each. It includes every screen that the user will see and all
    detail (that is, all graphics, fields, lists, buttons, and the on-screen layout
    of each). It will also detail acceptable response times for each operation and
    the behavior in common error cases (this isn't exhaustive—trying to enumerate
    *all* possible error conditions is a practically endless task!).
  prefs: []
  type: TYPE_NORMAL
- en: This work may include or lead to a *UI prototype*. Prototypes can be made with
    varying levels of detail and accuracy; this depends on the application and how
    much testing and review will be done. Inevitably, the UI design is incomplete
    at this stage, but this is your first chance to see what the finished product
    will look like. Although prototypes help to envision how the interface will behave,
    it's not until the system is integrated that the UI can be properly reviewed and
    tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: Design Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *design specification* (or *technical specification*) documents the internal
    design of a component. It describes how a functional specification will be, or
    has been, implemented. The design specification describes all internal APIs, data
    structures, and formats. It should detail all key algorithms, execution paths,
    and thread interactions. It describes the choice of programming language and the
    tools used to build the code. All of this is critical information for the code
    implementers and maintainters.
  prefs: []
  type: TYPE_NORMAL
- en: Many heavyweight development processes mandate the production of a design specification
    prior to implementation; it is reviewed before coding begins to prevent work from
    progressing down a dead end. However, in most software factories, this document
    is written alongside, or after, the code.
  prefs: []
  type: TYPE_NORMAL
- en: It sounds like such a good idea, but most design specifications are a big waste
    of time! They need continual maintenance to stay in sync with the code being described.
    Without care, they quickly rot and are left inaccurate and incomplete—potential
    snares for unwary readers. For this reason, I suggest that you *don't write a
    design specification*!
  prefs: []
  type: TYPE_NORMAL
- en: But wait, before you run off unencumbered, there's more. Replace it with something
    that contains the same information but is easier to keep accurate. *Literate programming
    tools* (see "[Practical Self-Documentation Methodologies](ch04s03.html "Practical
    Self-Documentation Methodologies")" on page 66) are a great documentation mechanism
    that can replace heavyweight design specifications by generating documentation
    from the code itself. You need only supply any extra commentary in specially formatted
    code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use literate programming tools to write your technical documentation. Don''t
    write a word-processed document that will quickly go stale*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t need the complete production code to use literate documentation
    tools in this way. You can document your intended code structure in the same manner:
    Mock up some code and run the tool over it. This automatically generates design
    documentation, serves as prototype proof-of-concept code and, with care, can evolve
    into the production code.'
  prefs: []
  type: TYPE_NORMAL
- en: Test Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *test specification* describes the testing strategy for a particular piece
    of software. It shows how to validate the implementation against its functional
    specification so you know when the software is acceptable for release. Naturally,
    the size and scope of this task depends on what is being tested: whether it''s
    a single software component, an entire subsystem, a desktop application, or an
    embedded consumer product.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test specification contains a list of every test that must be performed.
    Each test is detailed in a *test script*: a set of simple steps to run the test,
    together with its acceptance criteria and the environment in which the test will
    run. The scripts themselves may be written in separate documents or included in
    this one.'
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen in [Chapter 8](ch08.html "Chapter 8. TESTING TIMES"), many code-level
    tests can be performed *in code* themselves and run as an automated part of the
    development process. These tests stand distinct from high-level tests that can
    only be performed by running the software in its final context with scripted human
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever you can create programmatic unit tests for your software, prefer to
    do this rather than create a lengthy test specification. Just as design specifications
    can rapidly become out of date, test specifications written at the code level
    will rot as the system evolves around them. Use programatic test code as the documentation
    of your testing strategy—you can write literate test code as easily as literate
    normal code. Automated test cycles will also force you to keep the tests up to
    date with the code; your tests will fail if you don't!
  prefs: []
  type: TYPE_NORMAL
- en: '**DEVIL''S ADVOCATE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifications are expensive: Reading and writing them requires both time and
    effort. They require extra work. Are all of these documents *really* necessary?
    Yes, they are—to write high-quality software, you need to consciously generate
    all this information and then record it somewhere where it can be retrieved when
    necessary. Specifications encourage us to follow good development practices—to
    track requirements, perform design, and construct a test plan—and we''ve seen
    how they facilitate communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes (see "[Agile Methodologies](ch22s03.html#agile_methodologies
    "Agile Methodologies")" on page 433) place far less emphasis on writing specifications,
    but they don't advocate coding by the seat of your pants. Since specifications
    don't write themselves, can easily get out-of-date, and require extra work to
    maintain, and programmers have more than enough to do already, it's sensible to
    only write as many documents as necessary. We should always avoid lengthy procedural
    hurdles. *But any specification you remove must be replaced by an equivalent store
    of information*. Don't skip a specification unless you have conciously replaced
    it with something of equal quality containing the same set of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extreme Programming doesn''t produce a lengthy requirements specification,
    but it captures all requirements in an equivalent set of user stories, held on
    a stack of story cards. Design specifications are eschewed: The code is its own
    documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Agile practice also promotes test-driven *design*, where codified tests act
    as additional documentation of the code and its behavior. This full and clear
    suite of unit tests can replace the test specification for individual components
    but is seldom suitable to verify the final product against its validation criteria.
  prefs: []
  type: TYPE_NORMAL
- en: What Should Specifications Contain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The contents of each type of specification are naturally very different. However,
    the information in any specification must be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem obvious, but it is absolutely vital. An incorrect specification
    can cause days of wasted effort. It must be kept up to date or it will become
    dangerously misleading: It will waste readers'' time, cause confusion, and may
    lead to bugs being introduced as a consequence.'
  prefs: []
  type: TYPE_NORMAL
- en: If a specification can be interpreted in more than one way, then the "specification"
    isn't specific—it's not doing its job. Two readers could make different interpretations
    of the ambiguous information, with inevitable unfortunate consequences. Make sure
    that your specifications can only be interpreted as you intended.
  prefs: []
  type: TYPE_NORMAL
- en: The text must not contradict itself. When a specification gets reasonably large,
    it becomes difficult to ensure consistency. This becomes a particular problem
    when a maintainer (different from the original author) makes modifications—it
    can be very easy to alter information in one place and not change any subsequent
    sections that allude to the same information.
  prefs: []
  type: TYPE_NORMAL
- en: A specification should be carefully written to comply with all relevant standards
    (for example, language definitions and company coding standards). It should follow
    the document standards/conventions of your company and use any document templates
    that exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensible**'
  prefs: []
  type: TYPE_NORMAL
- en: An effective specification is inviting to read and easy to understand. It makes
    sense to every reader. If it's so technical that only engineers can understand
    it, then non-techie departments (like marketing and management) will not feel
    part of the audience and will not look at it carefully. Problems won't be spotted
    until it's too late.
  prefs: []
  type: TYPE_NORMAL
- en: Like good code, the best specifications are written from the perspective of
    the reader, not the writer. The information is organized to make it comprehensible
    to a newcomer, rather than convenient for the author. Blaise Pascal once apologized,
    "I made this letter longer than usual because I lack the time to make it short."
    Good writing is concise and doesn't hide the main point behind a wall of words.
    This does require more work and will take more time, but it's worth it if the
    result is simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel compelled to write reams of boring prose in a specification. Consider
    using devices to compress it and make it easier to read. Bulleted and numbered
    lists, diagrams, headings and subheadings, tables, and judicious use of whitespace
    break up the flow and help the reader to create a mental map of the material.
  prefs: []
  type: TYPE_NORMAL
- en: '**Complete**'
  prefs: []
  type: TYPE_NORMAL
- en: A specification should be self-contained and complete. That doesn't mean it
    should contain *all* possible information; it is perfectly acceptable to reference
    other relevant documents, as long as the reference is precise (consider document
    revisions in your references) and will allow the reader to easily locate the document.
  prefs: []
  type: TYPE_NORMAL
- en: The level of detail in a specification should be significantly less than the
    detail in the implementation; otherwise it is either overly prescriptive or too
    dense to understand. People tend to ignore complicated specifications, so they
    become abandoned. Left festering in a corner, they only serve to confuse readers
    who don't realize that they're no longer authoritative.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verifiable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A specification for a software component interface will lead to the production
    of two things: the software implementation and a test harness to verify it. The
    contents of a specification must, therefore, be verifiable. In practice, this
    largely equates to being correct, unambiguous, and complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifiable**'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing is set in stone, neither code nor documents. If a specification needs
    updating (perhaps to correct a factual error) then this should be easy. A cast-iron
    specification prevents the world changing underneath your feet. However, it's
    no use if the specification is wrong. The document must be editable (i.e., you
    should be able to get to the source, not just a PDF copy), and its release and
    update procedure must not be too troublesome.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make modifications easily, the document must be carefully structured
    and no bigger than absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-describing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each specification must contain at least:'
  prefs: []
  type: TYPE_NORMAL
- en: A *frontsheet*, clearly showing the document title, subtitle, author(s), revision
    number, date last modified, and document release status (e.g., company confidential,
    supplied externally under NDA, or a public release).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *introduction* to the document, providing a brief summary of its aims, scope,
    and the target audience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All relevant *terms and definitions* that the reader needs in order to understand
    the contents. (But don''t patronize the reader: If your audience is made up of
    software engineers, don''t explain what RAM stands for.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of *references* to other related or cross-referenced documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *history* section that lists all important modification and revision information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traceable**'
  prefs: []
  type: TYPE_NORMAL
- en: There should be a document control procedure (akin to a source management system)
    and a central file store in which all documents reside. Every release version
    of a specification should be lodged in the repository and must remain be accessible,
    so you can discover which version of a spec you were working to a year ago; one
    day you'll need it again. Consider using a revision control system—it's a great
    tool for versioning any sort of file.
  prefs: []
  type: TYPE_NORMAL
- en: The document frontsheet contains control information (version number, date,
    author, etc.) so you can check that you have the most up-to-date copy.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Think about the contents of your specification as you write it. Choose a structure
    and vocabulary that the audience will understand, and make sure that the document
    is correct, complete, and self-describing*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Specification-Writing Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is written without effort is in general read without pleasure.
  prefs: []
  type: TYPE_NORMAL
- en: --Samuel Johnson
  prefs: []
  type: TYPE_NORMAL
- en: 'Now knowing the types of specification we must produce and what should go in
    them, we''re armed and ready. It''s time to write something! The specification-writing
    process is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the appropriate document template to start from. This may be provided
    as part of a defined project development process. If there is no template, base
    it on an existing specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the document. Okay, this is the hard part. What you write naturally depends
    on the type of specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange for the document to be reviewed. Include all the people with an interest
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it's agreed upon (and, if your process demands, formally signed off on),
    put a versioned copy in the document repository and release it to the appropriate
    audience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any later problems, raise a change request for the specification
    and make sure that you understand how the modification affects the scope of your
    development work. If you don't, then the coding effort will double without anyone
    noticing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a simple procedure to list, but it isn't simple to do. It's easy to
    focus only on step 2—we skip the rest for an easy life. But without these other
    actions, you haven't created a formal identifiable document; this may cause problems
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider these spec-writing guidelines when composing your literary masterpiece.
    The first few relate to authorship and to your artistic sensibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing usually works best when there is one author per document. It's hard
    to coordinate multiple authors and accommodate different writing styles. If you
    are documenting a big system, then split the specification into parts and give
    one to each person to work on separately. Create an umbrella document that links
    them all together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrary to some opinions, it is not at all egotistical to have one person's
    name on the front of a specification. Someone needs to take credit for it—praise
    when it's a good job and blame when it's not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you significantly extend someone else's document, don't feel embarassed to
    add yourself to the list of authors. But don't remove someone from the author
    list unless his or her original input has now been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**LANGUAGE BARRIERS**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I hate definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: —Benjamin Disraeli
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compose your specification''s text very carefully. Compared to code, the English
    language is full of ambiguity and complexity. These *genuine* newspaper headlines
    show just how ambiguous seemingly simple English statements can be: "Stolen painting
    found by tree," "Kids make nutritious snacks," "Red tape holds up new bridge,"
    and "Hospitals are sued by *7* foot doctors."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Specifications are formal documents and they must not be chatty or verbose;
    this tends to hide the important facts behind a wall of words. Non-native English
    readers may struggle. However, a terse document is hard to follow. This is a delicate
    balance, and document review helps to determine the correct style of writing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Formal documents are written in the third person, in present tense. An accurate
    selection of words is very important. A useful convention is defined in the Internet
    RFC document #2119\. This defines the following key terms for protocol specifications
    (which are also very useful in requirements specifications):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Must**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The word *must* (*or shall or is required to*) means that the following definition
    is an absolute requirement of the specification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Must not**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The words *must not* (*or shall not*) signify an absolute prohibition of the
    specification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Should**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use *should* (or the adjective *recommended*) to indicate an optional requirement—
    behavior that may be ignored, but only when the full implications are understood
    and have been carefully considered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Should not**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use *should* not (or the adjective not *recommended*) to describe a particular
    behavior that should be avoided unless there are valid reasons to choose it— again,
    the consequences must be fully understood.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**May**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using *may* (or the adjective optional) means that an item is truly optional.
    An implementer can choose to support it or ignore it but, when applied to protocols,
    it must interoperate with another implementation that made a different choice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the word that should often be used when people write can. *Can* is a
    commonly misused word in specifications and standards; it is ambiguous and, depending
    on the reader's interpretation, could be taken to mean *must* or *may*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The author must be the right person. The marketing department doesn't write
    your functional specification; it provides requirements. Managers don't design
    the code; the developer with the right skill and knowledge does it. The author
    must be capable of writing—it's a skill that's learned, a muscle that requires
    exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each document must have a defined *owner* who takes responsibility for it. The
    owner may be different from the original author; it might be the technical authority
    or the document's maintainer now that the primary author has moved on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some tips for the document writing process:'
  prefs: []
  type: TYPE_NORMAL
- en: It's good to have a *best practice* example of each kind of specification. This
    will help authors to understand what is expected of them as they write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Early drafts of a specification should be marked as such, with a disclaimer
    stating that it is incomplete. This will prevent people from mistakenly interpreting
    it as complete—they can't moan at you about the content (yet). Maintain a list
    of the incomplete sections and open issues within the document itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Document review is important: It checks that the contents are correct and well
    presented. It is a mechanism to get others'' agreement with your decisions and
    to thereby bestow authority on the document. This is especially important for
    specifications that are sent outside the project: to the customer or to other
    departments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've finished the specification, don't forget about it. Keep it alive
    and up to date. A functional specification is not complete when the design phase
    is over. Requirements inevitably change, and we continue to learn more about the
    system's operation. Capture all of this in revised specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Don't We Write Specifications?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I do not understand what I do. For what I want to do I do not do, but what I
    hate I do.
  prefs: []
  type: TYPE_NORMAL
- en: --Romans 7:15
  prefs: []
  type: TYPE_NORMAL
- en: Decent specifications are conspicuous by their absence in the Real World. We
    know it's not good practice to avoid them, so hasty developers gloss over their
    absense and pretend that there's no problem. It's not unusual to be given a coding
    task without an adequate requirements or functional specification. (This is a
    procedural problem that must be overcome by persistent moaning, education, and
    abuse of the powers that be.)
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s equally common for sloppy programmers to sidestep their own document
    writing. Why is this? There are a few excuses we meet repeatedly. Developers don''t
    write specifications because:'
  prefs: []
  type: TYPE_NORMAL
- en: They don't know that they should
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They forget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't have the time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They consciously decide not to, thinking they can get by without them ("Who
    reads specifications, anyway?")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these reasons are defensible. An experienced developer certainly shouldn't
    fall foul of the first two if a specification is an expected deliverable of his
    or her work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers like to program, not write long documents. Most programmers don''t
    have good writing skills; they write elegant code but awful English. It''s hardly
    surprising that they try to avoid writing specs: It''s hard work, uninteresting,
    or they just don''t like doing it. Often it''s seen as a time wasting activity
    that isn''t really necessary. Or they think, *I''ll code first, then come back
    to the documentation later*. Bitter experience shows that this does not happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The depressing thought that *no one will ever read my beautiful specification*
    puts many more programmers off of the idea of committing their brainwaves to prose.
    And it''s probably true: No other soul may ever read your literary masterpiece.
    But so what? The act of specification writing forces *you* to engage your brain:
    a very important step. Sure, a few Gurus can code on the run and produce excellent
    work. But most programmers, whether they admit it or not, simply can''t. We need
    to design. Carefully. First. That design should then be captured: in a document.
    Potentially, this document will be for your eyes only. But, if one day you hear
    a higher calling and run off to become a Croatian monk, how can a maintenance
    programmer pick up your work? The specification will outlive you. Think of it
    as your legacy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not having time is the only scenario that *you* don''t have control over: Sometimes
    a coding task lands in front of you and there genuinely isn''t enough time to
    write a good specification for it. If you have no time to write a specification,
    then you probably don''t have time to write the code properly either. Make sure
    you''re aware of when you''re doing things properly and when you''re rushing code
    out without any real discipline—that sort of code really doesn''t belong in a
    production release.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving time by avoiding specifications is almost certainly a false economy;
    specifications help to *save time* communicating. When you write a specification,
    you only have to describe how the program works once. If you skip this step, at
    least the same amount of communication happens anyway, but on an ad hoc basis—over
    a longer space of time and in a less controlled manner. This communication is
    far less effective and will actually take *longer*, because you will have to explain
    the same things over and over again with a slightly different spin for each audience.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It is dangerous and unprofessional to avoid writing specifications. If there
    isn''t enough time to write a specification, there probably isn''t enough time
    to write the code*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, few people write detailed specifications at home for their own personal
    pet projects. This is an extreme case of an appropriately detailed specification.
    Any reasonably large project (which could be determined by the number of source
    files, modules, developers, or customers) really does require specification support.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Words are, of course, the most powerful drug used by mankind.
  prefs: []
  type: TYPE_NORMAL
- en: --Rudyard Kipling
  prefs: []
  type: TYPE_NORMAL
- en: They're not the most glamorous part of a software developer's life, but specifications
    are an important part of our code-writing routine. Learn to read and write them
    effectively—to record the right information in the right place, in a way that
    will save time and hassle later. But don't become enslaved by a paper-chain bureaucracy.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the importance of specifications and use them to make their development
    lives easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know the *appropriate* level of documentation required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to improve their writing skills and seek reviews and chances to practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Dive headlong into a code task without a thought for design, documentation,
    or review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't think about the text they are writing; they produce unstructured, hard-to-follow
    specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid writing documents, thinking it's boring and pointless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Self-documenting code* is a solid technique that helps to eliminate some code
    documentation. Good code is so easy and intuitive to work with that it doesn''t
    need a long manual.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs: []
  type: TYPE_NORMAL
- en: Consider change control and a backup strategy for your specifications—they're
    as vital as your code and need protecting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  prefs: []
  type: TYPE_NORMAL
- en: Just like your code, any document you write should be reviewed to ensure that
    it's correct and of a high quality.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: Specifications are an essential part of the software development process and
    are often the gates between development phases.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207568.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 544.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is a poor specification better than no specification at all?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How detailed does a good specification have to be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it important that all the documents in a company/project have a common presentation
    style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you store documents? Should you provide an index of them (by type
    or by project), for example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you conduct a specification review?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does self-documenting code render all specifications useless? Specific ones?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a document be collaborated on by more than one author?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Who decides on the contents of your documents?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider your current project. Do you have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A requirements specification?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An architecture specification?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A design specification?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A functional specification?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any other specification?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are they up to date? Are they complete? Do you know how to get the latest versions?
    Can you access historical revisions?
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Do you revision control your documents? If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20. A REVIEW TO A KILL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Performing Code Reviews*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reviewing has one advantage over suicide: in suicide you take it out on yourself;
    in reviewing you take it out on other people.'
  prefs: []
  type: TYPE_NORMAL
- en: --George Bernard Shaw
  prefs: []
  type: TYPE_NORMAL
- en: How do you learn to be a good carpenter? You become a carpenter's apprentice.
    You watch the master work, help him daily, gradually take on more responsibility,
    and learn from his advice. You don't jump in feet first without any practical
    ability and expect to churn out quality woodwork right away.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have a version of that in the coding world, even though programming
    is as much a craft as it is an engineering discipline (possibly more so). A good
    programmer learns the difference between good and bad code by experiencing it
    firsthand, discovering what works in Real Life and what doesn't. This is the stuff
    that books can't teach you, andonly a lucky few ever learn these things from a
    mentor. *Code reviews* are about as close as most of us will ever come to this
    ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews (also called *inspections* or *walkthroughs*) are similar to the
    open source model of software development—providing a structured opportunity for
    others to eyeball your precious code and for you to inspect others' work. They
    facilitate knowledge interchange. But their primary goal is to increase software
    quality. They help you to spot faults before they become raging disasters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code reviews also have another subtle advantage: They encourage you to take
    greaterresponsibility for your handiwork. When you know that the code isn''t just
    for *you* to look at, but that it will be viewed, used, maintained, and criticized
    by others, your approach tends to change. You''re less likely to make the quick-and-dirty
    fix that you''ll never have time to revise. The accountability brought on by code
    reviews brings a greater quality to your coding. They help to establish the "[Collective
    Code Ownership](ch17s06.html#collective_code_ownership "Collective Code Ownership")"
    culture described in "[Collective Code Ownership](ch17s06.html#collective_code_ownership
    "Collective Code Ownership")" on page 336.'
  prefs: []
  type: TYPE_NORMAL
- en: Sound good, don't they? Let's pop the hood and see how they work. . . .
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Code Review?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A review places source code under the microscope—really aiming to criticize
    and verify it. This is not to ridicule or get at the author, but to improve the
    quality of software that the team produces. The process normally generates a list
    of must-fix issues (the size of the list is a reflection of the quality of your
    programming skills!). Sometimes you will spot improvements that are not worth
    making now; chalk up those discoveries for future experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We look for bugs and any code that could be improved. The code review weeds
    out problems at several levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall design (we check the choice of algorithms and external interfaces).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression of that design in the code (its breakdown into classes andfunctions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in each semantic block (we check that each class, function, and loop
    is correct, follows appropriate language idioms, and is a practical implementation
    choice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each individual code statement (each must follow project coding standardsand
    best practices).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code reviews can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Personal**'
  prefs: []
  type: TYPE_NORMAL
- en: The author carefully and methodically reviews his or her own work to makesure
    that it's good. Don't get this confused with casually reading your code after
    typingit; a personal code review is a more detailed and involved task.
  prefs: []
  type: TYPE_NORMAL
- en: '**One-on-one**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You walk another programmer through your code. The other programmer checks
    the logic and looks out for faults as you lead through it. These reviews tend
    to be informal, driven by the author. The code is therefore approached from the
    author''s perspective: with his or her set of assumptions, rather than from a
    more objective, outside view.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formal**'
  prefs: []
  type: TYPE_NORMAL
- en: Involving other programmers brings new expertise, more experience, and more
    eyeballs to the task and shifts the perspective from which the review is run.
    Large-scale reviews are consequently harder to coordinate and require greater
    overall effort, but they are more likely to root out problems. It's difficult
    to delve this deeply in a personal review; often the author is too close to the
    code, and it's easy to overlook flaws.
  prefs: []
  type: TYPE_NORMAL
- en: 'This usually takes place in a formal meeting, but it can be run as a virtual
    review: online, with no physical meeting.'
  prefs: []
  type: TYPE_NORMAL
- en: Each type of review can be used at a different time in the development process.
    One-to-ones might be used daily throughout code development, as an integration
    review before modifications are committed to the main source tree. Formal reviews
    are brought in toward the end of code development, as a final software quality
    audit.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the obvious benefits of correct code, reviews have other useful side
    effects. The cross fertilization that comes from looking at each other's code
    ensures that coding style is more uniform across a whole project. A review also
    spreads knowledge about the inner workings of core bits of code, so there is less
    risk of losing information when people leave a project (a very real problem—see
    "[Team Closure](ch17s07.html#team_closure "Team Closure")" on page 343).
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code reviews are excellent tools to detect and eliminate hard-to-find bugs,
    to increase code quality, to enforce collective code responsibility, and to spread
    knowledge*.'
  prefs: []
  type: TYPE_NORMAL
- en: When Do You Review?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not criticized, you may not be doing much.
  prefs: []
  type: TYPE_NORMAL
- en: --Donald H. Rumsfeld
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, every bit of code would be carefully reviewed prior to release.
    According to the Software Engineering Institute at Carnegie Mellon University,
    a thoroughcode review should take at least 50 percent or more of coding time (personal
    code review is included in this statistic). (Humphrey 98) That would take longer
    than most Real Worldprojects are prepared to invest.^([[1](#ftn.CHP-20-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As we write a system, we need to ask* whether *to review the code and, if
    so, exactly* which *code to review*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**REVIEWING THE ALTERNATIVES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of development techniques that have been argued to make
    formal code reviews redundant. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pair programming**'
  prefs: []
  type: TYPE_NORMAL
- en: When you pair program (described in "[IT'S ALL GOING PAIR SHAPED](ch17s02.html#it_apostrophy_s_all_going_pair_shaped
    "IT'S ALL GOING PAIR SHAPED")" on page 319), your code is effectively reviewed
    on the fly. Two pairs of eyes are better than one and will find many, many more
    faults—as they are entered. However, code reviews cancatch even more problems
    by employing reviewers who are physically and emotionally removed from the implementation
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Open source**'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and freely releasing the source code allows anyone to see it, to judge
    the code's quality, and to fix problems. Some call this the ultimate code review.
    However, it doesn't actually guarantee that anyone *will* inspect the source.
    Only really popular open projects have actively maintained codebases. Making your
    code open source will not instantly bring code review–like benefits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**'
  prefs: []
  type: TYPE_NORMAL
- en: These are an automatic means to show that a modification hasn't degraded the
    *correctness* of your code's output (see "[Look! No Hands!](ch08s07.html "Look!
    No Hands!")" on page 144), but they don'thelp to increase the overall quality
    of the written code statements. Your code could be ajumbled mess of spaghetti,
    but if it passes the unit tests, no one will notice. If the unit tests aren't
    rigorous, bugs could still slip through, regardless.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not reviewing**'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can just trust the programmer to get it right—that's his
    job after all. If this is a winning strategy, then you don't need to test the
    code either. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: None of these, on their own, can honestly replace the code review. Perhaps a
    combination of them and a particularly effective development team culture would
    render reviews less necessary, but I've yet to meet a team where that has been
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: Whether to Review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen that bugs are inevitable, and that you can be sure your code contains
    some classic mistakes. There will be obvious flaws that you''ll find quickly and
    many more subtle problems that would only be spotted by a fresh pair of eyes approaching
    the code with no preconceptions. It''s hard for the original author to see the
    inherent faults in hisown work—he''s too close to the codeface, suffering the
    psychological *cognitive dissonance* described in. (Weinberg 71) If your code
    is at all important (clue: it is, or you wouldn''t have written it) and if you
    care about its quality (clue: you do, or you''re a disgrace), then you *must*
    review it.'
  prefs: []
  type: TYPE_NORMAL
- en: Not reviewing code drastically increases the chance of faults slipping into
    your production software. That could spell your embarrassment, a lot of expensive
    rework and in-the-field upgrades and, in extreme cases, your company's financial
    ruin. The effort of a code review pales in comparison to the consequences. According
    to Humphrey, "Students andengineers typically inject 1 to 3 defects per hour during
    design and 5 to 8 defects when writing code. They only remove about 2 to 4 defects
    per hour in testing but find 6 to 12 per hour during code review." (Humphrey 97)
  prefs: []
  type: TYPE_NORMAL
- en: People often make excuses to justify avoiding reviews. They say, "The code's
    too large to review fully," or "It's too complex; no one person could ever understand
    it—there's no point in even *trying* to review it." If a project can muster enough
    man-hours to write a large program, it can find enough time to review it. If the
    code is too complex, then it desperately needs to be reviewed! In fact, it probably
    needs something a little more drastic. Well-written code is decomposed into self-contained
    sections that can undergo separate reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Which Code to Review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any project will quickly produce a ton of source code. For all but the most
    stringent development processes, there simply isn't enough time to review every
    last scrap of code. So how do you decide which parts to review? That isn't easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must select the code that will benefit most from review. This is the code
    that is most likely to be bad or that is most important to the correct functioning
    of your system. You could try these strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Select core bits of code in the central components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a profiler to see where most CPU time is spent, and review those parts of
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run compexity analysis tools, and review the worst offending code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target areas that have already exhibited a high bug count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick on code written by programmers you don't trust (a code review vendetta!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most practical approach is probably a hybrid of all of the above. Pick the
    bestcode candidates based on a sober assessment of your team, the codebase, and
    the current system characteristics (performance, bug count, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Select the code you review carefully. If you can''t review everything, make*
    informed *choices about review candidates. Don''t guess—you might waste your precious
    time*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-20-FN-1)]) The fact that they're rarely prepared to invest any time
    in code review is a more serious problem.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Code Reviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That which we persist in doing becomes easier, not that the task itself has
    become easier, but that our ability to perform it has improved.
  prefs: []
  type: TYPE_NORMAL
- en: --Ralph Waldo Emerson
  prefs: []
  type: TYPE_NORMAL
- en: Simply *having* a code review is not enough. It's not going to solve all the
    problems itself. You also need to make sure that you review *properly*. The next
    few sections describe how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Code Review Meetings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common review setting (at least in high-ceremony development processes)
    isthe formal *code review meeting*. There is a fixed agenda (to ensure that no
    action is forgotten) and a defined ending (not necessarily a time limit, but a
    definition of exactly which code you are reviewing, and which you aren't—it's
    very easy to be unclear about this).
  prefs: []
  type: TYPE_NORMAL
- en: An example code review meeting procedure is described below.
  prefs: []
  type: TYPE_NORMAL
- en: Where?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best place to hold a code review meeting is in a quiet room. The reviewers
    should not be disturbed. There should be coffee (and, for those who must, tea)
    available.
  prefs: []
  type: TYPE_NORMAL
- en: A suite of networked laptops with code editors may be useful, as may a computer
    hooked up to a projector. Old-school programmers swear by printouts and pen-and-paper
    notetaking—detaching from the computer screen can help to find new faults. This
    really depends on how much respect you have for trees and electricity consumption.
  prefs: []
  type: TYPE_NORMAL
- en: When?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, at a mutually convenient time. Common sense tells us that Friday
    at 5 PMis not a good time. You need to devote serious time to this, so make sure
    that you won't be disturbed or distracted.
  prefs: []
  type: TYPE_NORMAL
- en: If the code is too large, split the review into a number of separate sessions.
    You can't sit people in an enclosed space for hours on end and expect the quality
    of their review to remain high.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and Responsibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most important factors contributing to the success of a code review
    meeting is who attends. Each attendee should be assigned a specific role; in small
    groups it is likely that people will take on multiple roles. These roles will
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Author**'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously the person who wrote the code should attend the review to describe
    what he or she has done, refute unfair or incorrect criticism, and listen to (and
    subsequently act on) valid, constructive feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reviewers**'
  prefs: []
  type: TYPE_NORMAL
- en: The reviewers should be carefully picked, people with available time and skill
    to review. It helps if the code is within their area of expertise or if they are
    involved with it in some way. For instance, the writer of a library should be
    invited to review a program that uses the library to diagnose incorrect API usage.
  prefs: []
  type: TYPE_NORMAL
- en: There should be an appropriate number of experienced software engineers present.
    There should possibly be a representative from the QA or testing department (see
    "[QUALITY ASSURANCE](ch08.html#quality_assurance "QUALITY ASSURANCE")" on page
    132) so QA can be assured of the software's quality and of the quality of thedevelopment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chairman**'
  prefs: []
  type: TYPE_NORMAL
- en: Any meeting needs a chairman, or chaos will ensue (see "[MEETING YOUR FATE](ch17s07.html#meeting_your_fate
    "MEETING YOUR FATE")" on page 340). This person leads the review and guides the
    discussion. He or she ensuresthat the conversation keeps to the point and that
    the meeting doesn't get sidetracked. Any minor issues that don't need to be discussed
    in the meeting should be quickly taken offline by the chairman. Given half a chance,
    programmers will discuss a minute technical detail for hours at the expense of
    the rest of the code review.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secretary**'
  prefs: []
  type: TYPE_NORMAL
- en: The secretary takes minutes. This means writing down all points that arise,
    to make sure that nothing is forgotten after the review. If there is a review
    checklist (see the example on page 398), the secretary fills it in. The secretary
    role should notbe fulfilled by the same person who acts as chairman.
  prefs: []
  type: TYPE_NORMAL
- en: Before arrival, everyone is expected to have familiarized themselves with the
    code. Everyone must have read the supporting documentation (any relevant specifications,
    etc.)^([[2](#ftn.CHP-20-FN-2)]) and must be aware of any project coding standards.
    Whoever organizes the meeting should highlight these documents in the meeting
    announcement to prevent misunderstanding.
  prefs: []
  type: TYPE_NORMAL
- en: Agenda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To organize the code review meeting:'
  prefs: []
  type: TYPE_NORMAL
- en: The author signals that their code is ready for review.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chairman arranges the meeting (booking an appropriate location, setting
    the time, and assembling the correct set of reviewers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All required resources (computers, a projector, printouts, etc.) are arranged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The meeting must be called sufficiently ahead of time to allow the reviewers
    to prepare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the meeting announcement, the author cannot change the code gratuitously—this
    is not fair to the reviewers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code review meeting is run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The chairman arranges for the room to be prepared beforehand so the review can
    start on time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author takes a few minutes (no longer!) to explain the purpose of the code
    and a little bit about its structure. This should be prior knowledge, but it's
    surprising what misunderstandings can be caught at this first stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design comments are invited. These are comments relating to the structure
    of the implementation—not the code at statement level. This could include the
    breakdown of functionality into classes, the split of code into files, and the
    style of function writing. (Is it sufficiently defensive, andare there good tests?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General code comments are invited. These may relate to a consistent incorrect
    coding style, bad application of design patterns, or incorrect language idioms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is carefully stepped through in detail, a line or block at a time,
    to look for flaws. The things to look out for are described later (in "[Code Perfection](ch20s05.html
    "Code Perfection")" on page 395).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of example scenarios of code usage are considered, and the flow of
    control is investigated. If there is a complete suite of unit tests (there should
    be) then these detail all the scenarios to explore. This helps the reviewers cover
    all execution paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secretary notes all changes required (recording the filename and line number).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any issue that might percolate out to the wider codebase is recorded for further
    investigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the review has finished, a follow-up step should be agreed upon. The possible
    scenarios are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Okay**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code is fine, no further work is necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rework and verify**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code needs some rework, but another code review meeting is unnecessary.
    The chairman nominates someone to act as *verifier*. When the rework is complete,
    the verifier checks it against the recorded minutes of the code review meeting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A reasonable deadline should be imposed for any rework, so that the detail of
    and reasons for actions stay fresh in people's minds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rework and re-review**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code needs a lot of rework, and another code review is deemed necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember, the aim here is to identify problems, not to fix them during the meeting.
    Some problems require considerable thought to fix, and this is a job for the author
    (or modifier) after the review has finished.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it useful to use the code review checklist at the end of this chapter
    when conducting your reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Integration Reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code review meetings are a high-ceremony review method. They're hard work, but
    theyundoubtedly find many problems that would otherwise go undetected.
  prefs: []
  type: TYPE_NORMAL
- en: Other, less intense review procedures exist, providing most of the benefits
    of codereview meetings but packaged in an easier-to-swallow pill. Perhaps the
    most effective is the *integration review*, performed whenever new code is integrated
    onto a mainline code branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be when:'
  prefs: []
  type: TYPE_NORMAL
- en: A new piece of code *is about to be* checked into source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new piece of code *has just been* checked into source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code package is merged from a feature development branch onto the main release
    branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At such a point, the code in question is marked for review, and a suitable
    revieweris picked: either someone responsible for that module (the code integrator
    or maintainer^([[3](#ftn.CHP-20-FN-3)])) or a *shadow* (or *code buddy*) who is
    assignedto verify that author''s work in a one-on-one review session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These gated code check-ins are often implemented with a software tool that
    is integrated with the source control system. They''re quite hard to arrange manually
    and are usually left as a check-in discipline: You are not supposed to check any
    code in until it hasbeen peer reviewed. This approach is quite hard to police;
    errors can slip past in hurried, last-minute check-ins.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual review step here is usually a lot less formal than the meetings described
    earlier. The reviewer scans the code to check that it isn't obviously broken,
    tests it (perhaps reviewing the available unit tests to ensure that they're valid),
    and then authorizes it for inclusion in the mainline. Only then will the code
    integrator migrate the verified code into the release tree. For more serious projects,
    or at more sensitive times ( just before a major release milestone, for example)
    this review step may become much more stringent—requiring more eyeballs and more
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: Since the reviewer and author don't need to actually meet face to face (although
    itis preferable to do so), this can be considered a form of virtual review process.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-20-FN-2)]) Naturally, all supporting documentation will have been
    thoroughly reviewed beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-20-FN-3)]) Compare this with an open source project's maintainer,
    who collates patches submitted by other hackers and integrates them into the main
    source tree, performing periodic software update releases.
  prefs: []
  type: TYPE_NORMAL
- en: Review Your Attitudes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do to others as you would have them do to you.
  prefs: []
  type: TYPE_NORMAL
- en: --Luke 6:31
  prefs: []
  type: TYPE_NORMAL
- en: 'Code reviews require a constructive attitude—you need to approach a review
    with the correct mindset, or it will be unsuccessful. This works two ways: for
    the author and the reviewer.'
  prefs: []
  type: TYPE_NORMAL
- en: The Author's Attitude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people shy away from a code review for fear it will expose their inadequacies.
    Don't do this. Having your code reviewed is a good way to learn new techniques.
    You must be humble enough to admit that you're not perfect and are willing to
    accept criticism from others. Your coding style will improve as you learn from
    the changes made to your work.
  prefs: []
  type: TYPE_NORMAL
- en: '**METHOD IN OUR MADNESS**'
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews are a universally acknowledged technique and have been around since
    people punched their programs into stacks of cards. We've looked at two review
    procedures in detail, but there are many subtle variants. Programming teams pick
    a review mechanism to suit their members and the nature of their work. (Poor teams
    perform no code review at all.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two other common review methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fagan inspections**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a well-respected process for formal reviews, much as described inthis
    chapter, defined by Michael Fagan in his *Defect Free Process*. (Fagan 76) Fagan
    emphasizes the importance of an ability to review and shows how to improve review
    skills. Fagan inspections identify problems both with the work product and with
    the process that created it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shadowing**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a a halfway house between pair programming and code reviews. Eachcode
    module has a *lead developer* who works on the code. A *shadow developer* is also
    assigned; periodically the shadow reviews the module with the lead. As design
    solidifies, the shadow developer verifies the decisions that are made. As the
    code fills out, the shadow reviews progress and offers constructive advice.
  prefs: []
  type: TYPE_NORMAL
- en: In more formal settings, the shadow is given authority to approve the code for
    release. No module can be integrated until the shadow developer agrees that it'sready
    for inclusion in the release build.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*No one''s code is above review and peer scrutiny. Actively invite review of
    your code*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an author, do not be defensive about your code. There is a natural tendency
    to take all criticism personally and assume that it''s an assault on your abilities.
    To cope with a code review, you need to reduce ego and personal pride. Understand
    that no one writes perfect code: Even the most awesome programmer''s code will
    be criticized for tedious little problems in a code review.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is *egoless programming*, described by Gerald M. Weinberg in his 1971
    book *The Psychology of Computer Programming*: a timeless description of the critical
    attitude that makes reviews work. (Weinberg 71) Programmers who aren''t afraid
    of bugs in their code or of others finding those bugs will generate better, safer,
    more correct software. A willingness for others to help find faults in your work
    is an essential attribute of the master programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: When you're in the hotseat, try not to waste other people's time. Before you
    present your code for review, run a dummy review by yourself first. Imagine you're
    presenting your work to the others. You'll be surprised by how many little flaws
    you'll filter out, and it will help you to be more confident in the real review.
    Don't rush out half-baked code and expect others to review the flaws away for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: The Reviewer's Attitude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When reviewing code and making criticism, you must be sensitive. Comments must
    always be constructive and not intended to lay blame. Do not launch personal attacks
    on the author. Diplomacy and tact are important. Address your comments to the
    code, rather than the coder; prefer to say *The code does this* . . . rather than
    *You always do this*. . . .
  prefs: []
  type: TYPE_NORMAL
- en: 'Code review is a *peer process*: Every reviewer is considered equal. Seniority
    doesn''t matter, and all views are considered. It is interesting that even the
    least experienced programmer will have something worth mentioning in a code review.
    And just as the author learns from the review, so may a reviewer.'
  prefs: []
  type: TYPE_NORMAL
- en: Over time, you will perform many, many reviews (especially if you perform integration
    reviews). Be careful that your review process doesn't become a mundane chore;
    it'll soon be an ineffective waste of everyone's time. Maintain a positive approach
    to your code reviewing. As a reviewer, always try to have something useful to
    say at each review. Sometimes this is easy; sometimes it is very difficult to
    say anything interesting. But by forcing yourself to make comments, you won't
    fall into the easy review rut, becoming a yes man who adds nothing to the process.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The success of a code review depends heavily on the author and reviewers adopting
    a positive attitude. The aim of a review is to collaboratively improve the code,
    not to apportion blame or to justify implementation decisions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Perfection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When perfection comes, the imperfect disappears.
  prefs: []
  type: TYPE_NORMAL
- en: --1 Corinthians 13:10
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t yet considered what type of code will pass review and what code
    will fail. It''s beyond the scope of this chapter to describe what good code looks
    like—the first 15 chapters of this book describe important aspects of high-quality
    code. As we look for bad code design and hunt software bugs, there are a few recurring
    themes. The reviewed code must be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug free**'
  prefs: []
  type: TYPE_NORMAL
- en: Bugs are our enemy, the nemesis of good software development. We must be confident
    about the quality of our work and need to find faults as early as possible in
    the development process. The earlier we try to find problems, the more we are
    likely to find and fix and the less cost and hassle they incur (see "[THE ECONOMICS
    OF FAILURE](ch09s02.html#the_economics_of_failure "THE ECONOMICS OF FAILURE")"
    on page 157).
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct**'
  prefs: []
  type: TYPE_NORMAL
- en: The code must meet all relevant standards and its requirements. Ensure that
    all variables are of the correct type (e.g., there is no chance of numeric overflow).
    Comments must be completely accurate. The code must meet any memory size or performance
    requirements (especially important for embedded platforms). Check that there is
    appropriate use of libraries and that all function parameters are correct.
  prefs: []
  type: TYPE_NORMAL
- en: The code is validated to conform with its requirements and functional specifications.
    The content of its specification is taken to be correct; if it wasn't, then the
    task would be herculean! Sometimes code review comments might feed up to the specification
    (for example, where clarification is needed), but this is not our goal at code
    review—don't get sidetracked into discussions on whether the specification is
    wrong; the secretary should record the issue in the minutes, and the review should
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Complete**'
  prefs: []
  type: TYPE_NORMAL
- en: The code must implement the entire functional specification. It must have been
    integrated and debugged satisfactorily and pass all test suites. The test suites
    must be comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Well structured**'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the implementation's design is sound, that the code is easy tounderstand,
    and that there is no duplication or redundant code. Look for any obvious *cut-and-paste
    programming*, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictable**'
  prefs: []
  type: TYPE_NORMAL
- en: There must be no unnecessary complexity and no unexpected surprises. The code
    should not be self-modifying, must not rely on magic default values, and must
    not contain the subtle chance of infinite loops or recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Robust**'
  prefs: []
  type: TYPE_NORMAL
- en: The code is defensive. Wherever possible, it protects against detectable run-time
    errors (divide by zero, number-out-of-range errors, etc.). All input should be
    checked (both function parameters and program input). The code handles all error
    conditions and is exception safe. All appropriate signals are caught.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data checking**'
  prefs: []
  type: TYPE_NORMAL
- en: Bounds checking is performed on C-style array access. Other similarly insidious
    data access errors are avoided. Multithreaded code has correct use of mutexes
    to prevent race conditions and deadlock. The return values of *all* system/library
    calls are checked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainable**'
  prefs: []
  type: TYPE_NORMAL
- en: The programmer has been wise in his or her use of comments. The code is kept
    under correct revision control. There is appropriate configuration information.
    The code formatting meets house standard. It compiles quietly, without spurious
    warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you don''t know what good code looks like, then you can''t make a valid
    judgment of other people''s work*.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the Code Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A review process is key to the production of any high-quality item, so it is
    not solely useful for source code development. A similar review process is used
    for specification documents, lists of requirements, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easier to be critical than to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: --Benjamin Disraeli
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews are an essential part of the software development process and help
    us to maintain a high quality of code. Just as an apprentice learns a trade from
    knowledge passed on, code reviews spread knowledge and teach coding capability.
    As more of a peer-to-peer than master-apprentice activity, they provide a learning
    opportunity for author andreviewer alike.
  prefs: []
  type: TYPE_NORMAL
- en: Write your code to be reviewed. Remember that it's never just for you to read;
    other people must be able to maintain it as well. The author is always accountable
    for the quality of his or her work. A good programmer cares more about crafting
    great code than hisor her own pride.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Desire code reviews and are confident in their code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept others' opinions and learn from them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can sensitively and accurately comment on other people's code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Are scared of code reviews and frightened of others' opinions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take criticism badly; they are defensive and easily offended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use reviews to demonstrate their superiority over lesser abled coders; their
    comments are unduly harsh and unconstructive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE") through [Chapter 15](ch15.html
    "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")**'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the opening chapters of this book describes important aspects of good
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: A description of the types of bugs that may exist in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Code is reviewed against its *specification*. The specification also requires
    careful reviewing.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207570.png)'
  prefs: []
  type: TYPE_IMG
- en: Checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many review processes involve a *checklist*—a set of characteristics of good
    (passable) code to check off as you go along. If your code doesn't meet these
    criteria, then it has failed the review. These checklists vary in detail, length,
    and subject matter.
  prefs: []
  type: TYPE_NORMAL
- en: The following code review checklist is an example. You can use it to help direct
    your review work. Unlike some checklists, it doesn't systematically list every
    potential problem in every possible language; it just helps to guide the review
    process and figure out when to continue to the next review step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checklist](tagoreillycom20080909nostarchimages207572.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 547.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does the required number of reviewers depend on the size of the code being reviewed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tools are useful aids for code reviewing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you perform a code review before or after running it through source code
    checking tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What preparation is required for a code review meeting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you differentiate review comments to be acted upon immediately from those
    to chalk up for experience on the next project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you run a virtual review meeting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How useful are informal code reviews?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does your project perform code reviews? Does it perform *enough* code reviews?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you work with any programmers whose code is considered to be above review?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What percentage of your code has ever been subject to code review?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 21. HOW LONG IS A PIECE OF STRING?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Black Art of Software Timescale Estimation*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I never guess. It is a shocking habit—destructive to the logical faculty.
  prefs: []
  type: TYPE_NORMAL
- en: --Sherlock Holmes (Sir Arthur Conan Doyle)
  prefs: []
  type: TYPE_NORMAL
- en: How long *is* a piece of string? Or for our purposes, how long does a piece
    of string take? It's as simple a question to answer, and it makes about as much
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about *software timescale estimation*, an important skill of
    the professional programmer. It's one of the mystical black arts of development,
    based more on hunches than science, with frequently inaccurate results. It's complicated,
    but an essential part of the software development process, and is something that
    every programmer must learn to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules of the software factory are necessarily governed by economics: the
    flow of money. Timing estimates are important, since the bulk of the cost of software
    development is manpower—programmers aren''t cheap. Development environments and
    hardware costs pale into insignificance. To make a software product, we must know
    how much work is involved, how many people are required to build it, and when
    it will be completed and ready to make money. This tells us how much construction
    will cost. The marketing department will predict how much it will make in sales.
    These two predictions go head-to-head in a dramatic fight to the death; the bean
    counters draw up budgets to work out whether a project is financially viable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an odd thing called *planning*, something at which most programmers
    don''t excel. Don''t worry: That''s why we have managers. But you have to understand
    the rules of the game if you really want to play well. Writing commercially successful
    software requires a huge amount of foresight and planning. Oh, and nerves of steel.'
  prefs: []
  type: TYPE_NORMAL
- en: To construct a development plan, we perform a high-level design of the software
    system, break it into components, and estimate how long each component will take
    to write. There's rarely enough time to seriously scope and design each one, so
    this is a very rough science. Choosing a software development model (see "[Development
    Processes](ch22s03.html "Development Processes")" on page 425), we assemble the
    estimates on a plan, spread across a number of programmers, and use this to work
    out the economics. The quality of this plan is clearly founded on the quality
    of the timescale estimates. Catastrophically bad guesses could spell financial
    ruin, so it's important stuff!
  prefs: []
  type: TYPE_NORMAL
- en: Without plans, you're creating products by luck, not on purpose. Estimation
    is an integral part of the project planning process—but that doesn't mean that
    it's done by the project planners! The only people able to provide timescale information
    are the programmers who have to do the work. That's you! This is part of the commercial
    reality of life in the software factory.
  prefs: []
  type: TYPE_NORMAL
- en: A Stab in the Dark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any company, on any project, at any point in time, software timescale estimates
    are nothing more than educated guesses—or else they wouldn''t be estimates. Guesswork
    doesn''t sound very professional, does it? But it''s the best you can do: You''ll
    never know exactly how long a task will take until it''s complete, when it''s
    generally too late for the information to be useful.^([[1](#ftn.CHP-21-FN-1)])'
  prefs: []
  type: TYPE_NORMAL
- en: The quality of an estimate is primarily determined by how well you understand
    the task being estimated. That is, how well you *really* understand it, not how
    well you *think* you do. It also depends on how much time you have to create the
    estimate, and therefore how much effort you can put into a realistic design effort
    or feasibility review. With a very precise specification, you can make an estimate
    in a short time; with a vague specification, it could take ages. A reasonable,
    justified estimate might require several prototypes to investigate implementation
    choices—different options could have radically different time consequences and
    levels of inherent risk.
  prefs: []
  type: TYPE_NORMAL
- en: Without enough time to do this, you need to concoct a worst-case figure that
    development should not exceed. The less effort you put into a timescale estimate,
    the less the confidence you may have in the figure, and the greater the likely
    variance of reality from the estimate. Development could take half of the estimate,
    the full period or—even worse—could require more time. We manage this risk by
    building *contingency* into the development plan to balance risky areas. How much
    contingency do you provide? You have to guess! We'll look at this later.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software timescale estimation requires* educated guesswork. *Each estimate
    should come with a gauge of your confidence in it*.'
  prefs: []
  type: TYPE_NORMAL
- en: While good estimates are reasoned and justified, bad estimates are little more
    than a stab in the dark. This is a standard engineering issue, requiring a perceptive
    and flexible management. It has been an engineering issue for centuries.^([[2](#ftn.CHP-21-FN-2)])
    Managers and planners deal with estimations for the whole project. That's *exceptionally*
    hard. We'll just look at estimating single programming jobs. Thankfully, that's
    not exceptionally hard, just *really* hard.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-21-FN-1)]) Except, of course, as experience to base future estimates
    on.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-21-FN-2)]) For a Biblical example, see Luke 14:28!
  prefs: []
  type: TYPE_NORMAL
- en: Why Is Estimation So Hard?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I live in Cambridge, UK; my family lives in Bristol. Software timescale estimation
    is like estimating how long it will take me to visit them. Given a strong tailwind
    and no traffic, I can tell you how long the drive takes. But if there is road
    work or a traffic jam, if my car breaks down, I leave late, or I travel at rush
    hour, then this estimate becomes a lot less reliable. Foreseeing some of these
    problems, I will commit to a likely arrival window. I know the best-case journey
    time; I have an idea of the worst case (I''ve had some nightmare trips). I can
    judge an expected arrival time somewhere between the two. However, I can''t ever
    fully account for the unforeseen—if my car breaks down, I''m stuck. Mobile phones
    are helpful in this situation: If I''m going to be late, I can call and let my
    folks know to keep dinner heated (and preferably out of the dog''s bowl).'
  prefs: []
  type: TYPE_NORMAL
- en: The software development process follows a similar pattern. When planning software,
    there are foreseeable potential problems to account for, third-party dependencies
    to manage, and a need for contingency to cope with the unforeseen. You can give
    a best-case development time for a slice of work, and you need to consider a worst-case
    time. Of course, the impact of a bad guess isn't just your dinner inside the family
    pet—it's the success or failure of a project, and possibly the solvency of your
    company.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE WEAKEST LINK**'
  prefs: []
  type: TYPE_NORMAL
- en: Unforeseen problems can trip you up in unexpected places. Recently, my linker
    couldn't cope with the size of executable image I was generating, and I needed
    to go off and fix the linker before I could run my code. The development time
    more than tripled its original estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This begins to show us why estimating the length of a development task is so
    hard and so crucial. There are plenty of things conspiring to make this a tricky
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of variables to consider. They come with the inherent complexity
    of the problem, the implications of your code design, and the existing software
    ecosystem it must fit into. Some of those variables may change from day to day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements will change under your feet, leading to software scope increases.
    As the feasibility of a project is investigated, new problems and user-level requirements
    are unearthed at a phenomenal rate. This makes the estimation job tricky—you've
    got to work hard to keep up with it all (see "[Requirements Specification](ch19s02.html#requirements_specification
    "Requirements Specification")" on page 371 for strategies to manage this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't give an accurate estimate without knowing *all* the work involved.
    Perhaps you'll need to rework existing libraries that don't provide enough functionality
    or refactor to enable safe extension of existing code. If you haven't discovered
    this, then your estimate will be too low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Few projects start on a blank canvas. You must learn the existing system before
    you can estimate how long work will take. You seldom have time to do this properly
    before the estimate is delivered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the task is something that has not been attempted before, then it is harder
    to figure how long it will take. You have no prior experience to base the estimate
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many projects rely on third parties, and these dependencies can prove to be
    nightmarish. The source of the dependency could be an operating system vendor,
    a small but significant code library, an external specification, even the customer.
    You can't control the third-party delivery; your estimates depend on it shipping
    on time. This increases the risk of delay and must be monitored carefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Estimation is hard. But that doesn''t absolve us from responsibility. We must
    account for the things that are genuinely foreseeable: Like road work or bad weather,
    we can reasonably expect some of these pitfalls. You need to find the right balance
    of pessimism, optimism, and—somewhere in the middle—realism.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating timescale estimates is a genuinely hard task. Don''t underestimate
    how much work is involved. Appreciate the repercussions of making a bad estimate*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The story doesn''t end there: It''s not just making the estimate that''s hard.
    Living with the consequences can be just as painful.'
  prefs: []
  type: TYPE_NORMAL
- en: Estimates become contractual, used to set delivery schedules with customers.
    Once set in concrete, these dates are hard to move and costly to get wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hard to work to someone else's estimate—were you not up to the task if
    you miss a deadline, or was the estimate wrong?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New tasks are often discovered during development which need accounting for
    and slotting into the schedule, pushing everything else back. Similarly, you'll
    only discover specification problems once the development work is actually under
    way. These specification changes will affect the amount of work required, and
    therefore the time estimate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are *always* unforeseen problems. You can absorb the impact of small problems
    by working a little harder to stay on schedule. You didn't need to sleep this
    month, did you? But large problems introduce buckets of extra work and cause schedule
    mayhem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The estimate is just *another* responsibility: You are not only accountable
    for creating the code, and for it to be good, well-designed, maintainable code;
    you also have to deliver it to a timescale that you have promised. Pity the poor
    programmers!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under Pressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software factory is not a reasonable place, and the temptation to give optimistic
    estimates is strong. Programmers new to the estimation game are particularly vulnerable.
    There is pressure from above to promise short schedules so that we can win contracts,
    announce new releases, maintain internal political stability, and so on. This
    is an understandable, sad reality; no company exists in a vacuum, and the shareholders
    want to be kept in caviar and champagne.
  prefs: []
  type: TYPE_NORMAL
- en: But the pressure isn't entirely from above. It also comes from a programmer's
    personal pride. Techies like to promise an optimistic timescale; we are motivated
    people who are proud of what we deliver and how fast we can do it. It's tempting
    to think, "Oh, it shouldn't take too long." But there's a very real difference
    between a quick code hack or prototype effort and a full, production-ready piece
    of work. Our timescales must be grounded in reality, not in hopeful ideals.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Everyone (including you) wants shorter development timescales. Don''t kid
    yourself about what is technically possible in the given development time. Don''t
    promise a hack timescale when you must deliver production code*.'
  prefs: []
  type: TYPE_NORMAL
- en: We must be aware of this pressure and react to it carefully. Beware of the danger
    of an extreme opposite reaction. It is easy to be a pessimistic doom-sayer, to
    imagine a task lasting indefinitely, and compensating with a stupidly large timescale
    estimate. The very real danger of an overestimate is that projects inevitably
    expand to fit the available time! You'll always find bits of code to polish when
    there are a few days spare.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an ideal world, project deadlines are established *after* a feasibility
    review that proves the project is possible in reasonable time. The Real World
    is rarely that kind. Instead, you are given a deadline ("Get it shipping by Christmas"),
    and then have to figure out how to deliver. If the work doesn''t fit, you must
    negotiate how you''ll get there: Remove features, add programmers, outsource risky
    parts, or perhaps provide a later upgrade with more functionality. Sometimes this
    planning becomes more of a marketing exercise and gets quite creative!'
  prefs: []
  type: TYPE_NORMAL
- en: No one said that it was supposed to be easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WAR STORY**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The company had just taken the biggest and most strategically important order
    in its five-year history. This one was *make or break*. Sales fought hard to close
    the deal, agreeing to a hard customer deadline: The software *must* ship by the
    end of the year. With contracts signed, everyone patted themselves on the back.'
  prefs: []
  type: TYPE_NORMAL
- en: But no one had the time (or wit) to confer with the technical staff to ensure
    that the project was feasible. It wasn't. Managers started panicking, but with
    an immobile deadline and fixed feature set, there wasn't much they could do. The
    engineers complained and waved their project plans aloft, but were told to "just
    make it fit." They worked hard day after day, late into the night, and were soon
    exhausted. Each week saw them slip further away from the hopelessly optimistic
    schedule.
  prefs: []
  type: TYPE_NORMAL
- en: In one last herculean effort, they completed the code by their deadline, only
    to be tripped up by an unforeseen hardware problem that delayed the project by
    two months. There was no contingency in the plan to account for this disaster.
  prefs: []
  type: TYPE_NORMAL
- en: The project was a failure, the engineers got burned out, nerves were fraught,
    and the customer was unhappy. Not long into the next project, most of the development
    team quit.
  prefs: []
  type: TYPE_NORMAL
- en: Practical Ways to Estimate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the increasing pressure to be prophets as much as programmers, how do we
    meet expectations? Estimation, like many other skills, is something you get better
    at it with experience. It's not an old man's game, but if you don't work against
    a backdrop of schedules and set yourself targets to work toward, then you won't
    grow in the skill. Practice makes perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Real World, we rarely have the luxury of practice projects or a sandbox
    to experiment with timescale estimation. Somewhere along the road from junior
    programmer to guru, you have to pick up this skill! Sadly there is no magic formula
    or easy recipe for coming up with an estimate. But following these simple steps
    will immeasurably improve your accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: Break the task down into the smallest blocks possible, effectively performing
    a first pass of system design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you reach a fine resolution with suitably comprehensible parts, provide
    a timescale estimate for each block in *man-hours* or *man-days*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''ve estimated all of the individual timescales, place them back-to-back,
    add up their durations, and voilà: an instant timescale estimate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This strategy works because you can fully comprehend and accurately estimate
    a series of smaller activities more easily than one gargantuan task. Estimates
    should *never* be made in units larger than man-days: Such large tasks show that
    you don''t really understand the problem yet; your estimate cannot be at all reliable.
    Mercilessly decompose large tasks until you end up with fine-grained—estimatable—work
    units.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Time estimates should be made for small tasks whose individual scope is easy
    to understand. The measurement should be in units of* man-hours *or* man-days.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, development work can often be parallelized between people; by breaking
    it into small comprehensible parts, we can juggle tasks around and work out how
    to run them concurrently, bringing forward the completion date. This becomes a
    project planning issue.
  prefs: []
  type: TYPE_NORMAL
- en: Set aside a reasonable amount of time to make an estimate. The requisite high-level
    design is not immediate; don't presume that timescales can be guessed easily.
    You'll fool yourself by producing a finger-in-the-air estimate with no foundation
    on prior experience and no basis in a system design.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is vital to consider *every* activity that will be required to deliver the
    software. This means including time for:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing adequate thoughtful design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any exploratory work or prototyping required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual code implementation work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any research or training you'll be undertaking in the period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list shows that less time than you might expect is spent writing code,
    compared to other peripheral activities. Programming isn't just about cutting
    code; don't forget to include testing and documentation in your timescale estimates.
    They are essential. Without testing and documentation, you'll deliver code that
    doesn't work properly and can't be fixed later because no one knows how to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't try to calculate *elapsed time* (by incorporating distractions from other
    projects, reading email, browsing the web, drinking coffee, and answering the
    call of nature). It will inevitably be very different from the actual time spent
    on the task. The task may run concurrently with another, or be interrupted to
    provide space for another project. We deal with this on a project plan (described
    in "[The Planning Game](ch21s05.html "The Planning Game")" on page 409).
  prefs: []
  type: TYPE_NORMAL
- en: 'How conservative should your estimate be? Should you veer toward optimism or
    pessimism? The correct answer is: The estimate must be realistic. Anticipate likely
    problems and factor them in, but don''t invent 1,000 ways a simple task could
    fail and use it as an excuse to give an inflated estimate. Don''t overestimate
    just to cover your tracks, or to give yourself more slack to fill with games of
    solitaire. Our individual task estimates can''t mitigate for everything that can
    go wrong. Risk should be managed at the *project level*; the scheduler takes our
    estimates and works them into a reasonable plan with suitable contingency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make more accurate estimates, consider these important issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The more concrete and specified a project is, the easier it is to estimate.
    Have you been given a good spec?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without a specification, there is no traceability, and a lot of the work involved
    in each package will be assumed. Two people could assume very different things
    about the project scope and expect different things at the project deadline. Rigorous
    specifications avoid this problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delivering the wrong system on time can be just as damaging as delivering the
    right one, late. If there is no specification, write one and get it approved by
    the task stakeholders.^([[3](#ftn.CHP-21-FN-3)]) At the very least, document all
    assumptions that you have made about the work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The more functionality requested, the harder the estimate is to make. Try to
    shave off all unnecessary work. An excellent approach is to stage the delivery
    of the software, giving estimates for each deliverable iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feed estimate information back upstream. The project decision-makers can then
    balance the importance of each requirement against its technical difficulty. It
    helps to see which small feature requests will double development time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you don't fully comprehend the entire problem, then you'll make a very bad
    estimate. Spend time getting to know exactly what the software must do. If you
    need more time to make an estimate, then ask for it, or indicate your confidence
    in the time values. Never guess an estimate and hope that it's about right—if
    you can't justify an estimate, then don't give it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the task depends on third-party input, then it is harder to estimate. Who
    is responsible for chasing the third party for delivery? You may need to factor
    this into your development estimate. Get the third party's estimated delivery
    date, and then add time to integrate its work with your codebase (it never "just
    slots in"). Consider how much you trust the third party, and include a suitable
    amount of contingency as a buffer to accommodate problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different people will work on the same task at different rates. This is natural;
    everyone has a different set of skills, level of experience, confidence level,
    and relative number of distractions (e.g., older projects vying for attention
    or home commitments). You need to gauge how fast you work, and have a good understanding
    of the task you're embarking on. Estimation is personal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Understand whether you''re creating an estimate for work that* you *will do
    (on a system you understand well) or that someone else will do (who might have
    to learn it first)*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't accept pressure from above to be optimistic. Don't promise unrealistic
    timescales, thinking you can make it up if you work overtime. Have an appropriate
    response to managers who say, "It just has to be done faster."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps most importantly, *never* plan up front on working overtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple way to improve your estimates is to ask for help with them. If you
    don't understand a problem, then find someone who does, and ask for his or her
    opinion. James Surowiecki's book *The Wisdom of Crowds* describes how large groups
    of people can be smarter than an elite few. Taking this extreme approach, get
    all the developers in your team to give rough estimates for all tasks on the plan,
    and then take the average of their individual estimates. That estimate might not
    be too far off!
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t make estimates in isolation. Solicit other people''s opinions to help
    improve your estimates*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-21-FN-3)]) Of course, that will take time you didn't plan for!
  prefs: []
  type: TYPE_NORMAL
- en: The Planning Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few disconnected timescale estimates are no use to anyone. You have to join
    them up and convert them into something useful: a project plan with which you
    can manage the development schedule. Based on their individual timescale estimates,
    tasks are assembled on a timeline and allotted to developers. Dependencies between
    tasks are identified and factored in to the plan (obviously, dependent tasks cannot
    start before their dependencies have completed). The final result is a pictorial
    chart with time running along the horizontal axis and tasks positioned concurrently
    on it, looking something like [Figure 21-1](ch21s05.html#a_gantt_chart "Figure 21-1. A
    Gantt chart") (a variant of the classic *Gantt chart*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Gantt chart](tagoreillycom20080909nostarchimages207574.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 21-1. A Gantt chart**'
  prefs: []
  type: TYPE_NORMAL
- en: Project planning is about allocating tasks to developers and working out how
    to schedule development effort. But that's the easy half of the game. The important
    part is *risk management*—creating a safe and sensible plan in the face of uncertainty
    and hidden traps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The safest project plans:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce the** *`critical path`*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the single line of back-to-back tasks that trace from the start to the
    end of the project, shown by the darker blocks in the diagram above. A slip in
    any one of these tasks will force back all the tasks depending on it and push
    out the final deadline.
  prefs: []
  type: TYPE_NORMAL
- en: There is always—by definition—a critical path on the plan. This is what gives
    project planners grey hair! We aim for the optimum juxtaposition of tasks to provide
    the smallest (or least risky) critical path.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are not massively parallel**'
  prefs: []
  type: TYPE_NORMAL
- en: The standard planning misconception when trying to compress a large project
    is that throwing more developers at a problem will speed it up. This rarely works.
    An extra burden is imposed when managing more people—there are more lines of communication,
    more people to coordinate, and more points of failure. This is the subject of
    Brooks's seminal essay, "The Mythical Man-Month." (Brooks 95)
  prefs: []
  type: TYPE_NORMAL
- en: 'You mustn''t over-parallelize a project plan, and you shouldn''t parallelize
    individual developers, either. If you put one developer against two tasks concurrently,
    you can''t expect them to finish in the same length of time as those two tasks
    serialized. This sounds obvious, but it often happens in practice: You might be
    asked to support an old project and simultaneously start development work on another.
    Significant time is taken up switching between tasks, which reduces your overall
    efficiency. If you did the two tasks back to back, then you''d complete faster
    (but probably fail to meet the business requirements of your organization).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Are not too long**'
  prefs: []
  type: TYPE_NORMAL
- en: A lengthy project plan is too ambitious. One small problem on the critical path
    at any point could jeopardize the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: This is where iterative and incremental development (see "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432) brings benefits, by breaking large development
    schedules into smaller, less risky iterations that can be more easily managed.
    This makes the plan more dynamic; it is effectively re-created at each delivery
    point. Although this approach is inherently safer and will highlight problems
    earlier in the development process, it consequently involves more work overall.
    Many managers don't like this—they like the illusion of an up-front waterfall
    plan that cannot be deviated from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good plans don''t just butt timescale estimates back to back. They account
    for the reality of the software factory and build in important risk-reducing structures.
    This includes accounting for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vacation**'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of vacation allocated to each developer is known in advance and must
    be built in to the schedule. We must also include public holidays and any company
    shutdown over a Christmas break. On average, a developer takes half a day a week
    as vacation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading**'
  prefs: []
  type: TYPE_NORMAL
- en: To be realistic, the plan must factor in normal interruptions (meetings, training,
    sickness, and so on). It's normal to employ an 80 percent loading on the plan
    for each developer to accommodate this. People who are in more demand are spread
    more thinly. You must be honest about this, or the "popular" developers will slip
    against the schedule, despite their hard work, and will quickly become frustrated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contingency**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the biggie. You have to account for the problems seen looming on the
    horizon and provide space for the unforeseen disasters that might stand between
    you and your release date. This is where the risk management rubber hits the road.
  prefs: []
  type: TYPE_NORMAL
- en: Risk is best managed at this project level, rather than within individual timescale
    estimates. On a development plan, we can accommodate potential problems by making
    informed judgments in full sight of the whole development process. The alternative,
    a series of pessimistic estimates placed on a plan, will inevitably be wildly
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The million dollar question is: How much contingency should you add in? You
    can''t simply multiply the plan by three and call it contingency! A good strategy
    is to give each task a confidence value. Based on this, provide an extra pseudo-task
    on the plan for the riskiest tasks as "danger time." Make this a fraction of the
    original task length, based on your confidence value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration**'
  prefs: []
  type: TYPE_NORMAL
- en: A task is not done once a component is code complete and unit tested. Reserve
    adequate time to glue all of the components together, and to test that the entire
    system works as expected. There will be debugging required and issues that only
    surface when components meet (performance issues or interface mismatches, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: '**Support**'
  prefs: []
  type: TYPE_NORMAL
- en: The longer people have been within an organization, the more call there will
    be on them to support old projects, answer bug reports from the field, and so
    on. Ensure that this is incorporated into their loading, and that they then stick
    to the plan, highlighting when other projects are demanding more of their time.
  prefs: []
  type: TYPE_NORMAL
- en: Projects slip subtly when key people are stretched in all directions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mopping up**'
  prefs: []
  type: TYPE_NORMAL
- en: Provide time to tidy up at the end of your plan. In the battle to release software,
    corners are cut to meet the deadline. This is known as amassing *technical debt*.
    Despite our preaching about good design and coding practices, this isn't necessarily
    evil; it's quite pragmatic. However, you must set aside time to tidy up and maintain
    a good, clean codebase. Otherwise, the next development iteration will build upon
    a broken, crufty codebase. Left unaddressed, this increasing pile of short-term
    hacks will become a burden to your programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this exercise as part of the *previous* job (despite occurring after
    the release deadline), and not as the beginning of the next one. Pay off your
    debt in the project that accrued it.
  prefs: []
  type: TYPE_NORMAL
- en: Never let these tidy-ups been viewed as optional extras; they are an important
    integral part of the project. In the frantic world of the software factory, optional
    tasks placed at the end of the schedule simply will not happen. Guard these tasks
    carefuly.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Create development schedules that will leave your codebase in a clean state.
    Plan to repay your technical debt*.'
  prefs: []
  type: TYPE_NORMAL
- en: An in-depth investigation of project planning is outside the scope of this book;
    it's a large, complex task. But it is important to understand the basic principles.
    You must be able to develop software according to a plan, and must understand
    the rationale behind a plan to truly understand what you're asked to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The are many planning models: formal methods of making educated guesses. *Program
    Evaluation and Review Technique (PERT)* is a classic planning method developed
    in the 1950s by the US Navy. It''s like my arrival window calculation when driving
    to Bristol. For each task, you estimate three times corresponding to different
    likelihoods of meeting delivery dates: a best case, worst case, and likely case.
    This ties into a scheduling procedure that identifies the critical path and calculates
    the best- and worst-case project completion time. The bigger the gap between each
    task''s estimate, the bigger the risk associated with the task. Perhaps it will
    need more careful management or to be given to a more experienced member of the
    staff.'
  prefs: []
  type: TYPE_NORMAL
- en: Boehm's *Constructive Cost Model (COCOMO)* dates from 1981 and is an estimation
    model based on analysis of real software projects. It has evolved into *COCOMO
    II*, which more accurately reflects the nature of modern software projects. (Boehm
    81) *Projects in Controlled Environments* (known by the rather contrived acronym
    *PRINCE*) is a classic British piece of bureaucracy embodied in project management
    form; if it could mandate standing in queues, it would!^([[4](#ftn.CHP-21-FN-4)])
    Its scope is the entire project life cycle, from start to closure. The PRINCE
    planning process comprises seven steps, covering designing the plan, through estimation
    and scheduling, to plan completion. It too has evolved, into a method imaginatively
    called *PRINCE2*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-21-FN-4)]) Queueing is a popular British pastime, like drinking
    tea and playing cricket.
  prefs: []
  type: TYPE_NORMAL
- en: Keep Up!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a project get to be a year late? . . . One day at a time.
  prefs: []
  type: TYPE_NORMAL
- en: --Frederick P. Brooks Jr.
  prefs: []
  type: TYPE_NORMAL
- en: As work slips and the project deadline looms, engineers work very hard and get
    little credit. The idea of rigorous testing is squeezed out in a mad rush to get
    something passable out the door on time. Bad estimates are a prime cause of this
    software circus. They foster managers' incorrect assumptions about the difficulty
    of the development work, since they have no way to know the schedule was incorrect
    in the first place. When we make an estimate, it is therefore essential to get
    it right.^([[5](#ftn.CHP-21-FN-5)])
  prefs: []
  type: TYPE_NORMAL
- en: '**IT''S ALL ABOUT PLANNING**'
  prefs: []
  type: TYPE_NORMAL
- en: The development team was getting quite large, and our working space had become
    really cramped. After a lot of effort, a new office was found and the team was
    told on Friday that we'd be working in the new location on Monday. Over the weekend,
    all the computers, servers, cables, routers, printers—everything—would be manhandled
    into vans and transported to the new location. We were assured that it would be
    seamless and that everything would be ready on Monday morning.
  prefs: []
  type: TYPE_NORMAL
- en: On Monday morning, we turned up at the new office and, sure enough, everything
    had been set up and worked perfectly! All the IT infrastructure had been installed.
    The servers were back online and fully operational. Everyone's workspace had been
    set up. A truly herculean effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there was one small problem: There were no chairs. Not one. They had somehow
    been forgotten in the move plan, had gotten lost, and couldn''t be found anywhere!
    We had no chairs for three days.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that's what you call planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a realistic estimate for a software task, there are a few key ways to
    keep to schedule and prevent this kind of last-minute squeeze:'
  prefs: []
  type: TYPE_NORMAL
- en: When starting a new task, check whether or not the allotted timescale really
    *is* practical—especially if you didn't have the luxury of making the estimate
    yourself. Even if you did make the estimate, start by verifying it. Don't rush
    headlong into a code editor, *hoping* that you can complete on time; be sure that
    you are genuinely able to deliver. A little sanity checking up front can save
    you from a world of pain and embarrassment later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the schedule—it matters. Keep a constant eye on how long you're taking
    against scheduled time. Write down your timescales and keep them close at hand.
    Add personal estimates for any intermediate tasks that don't figure on the main
    software plan, and run yourself as a mini-project. If you hit your internal milestones,
    you'll have more chance of keeping on track with your externally visible timescales.
    Repeatedly review your list—at least once a day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you discover that you won't hit the deadline, make this known as soon as
    possible so the plan can be adjusted. Like phoning ahead when I'm traveling to
    Bristol, it is better to get this fact out in the open as soon as possible. If
    the possibility of overrun is foreseen, then different scheduling decisions can
    be made to minimize the impact of the overrun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This happens far too rarely in practice. If an important project has five programmers
    who must all report their progress, then none of them wants to be the first one
    to admit falling behind the schedule. This is known as playing *schedule chicken*.
    The result is everything seems to be fine, but then suddenly the project is hugely
    late. It was getting late one day at a time, but no wanted to admit it. Break
    this cycle and broadcast a warning as early as possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Continually monitor your progress against the plan. Then you will never be
    surprised that your task has slipped*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do as much work as necessary, and no more. It might be fun to add that cute
    extra feature. But don't. There are more important—planned—things to be done.
    Ask for important extras to be scheduled in later if they aren't *really* needed
    now. An ill-chosen detour on my route to Bristol will really set back my arrival
    time—even if it is a lovely scenic drive—so I take the sensible straight route
    to arrive on time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Careful design exploiting modularity tends to reduce component dependency, and
    so reduces the ill effects of slippage and the bunching up of tasks on the schedule.
    Agree on component interfaces early on, and provide stub components so development
    can continue while others parts of the system are being built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write good code, with a thorough set of unit tests. As keen craftsmen, this
    should be self-evident! It helps to reduce debug and maintenance time radically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to finish coding with time to document and test thoroughly. Don't
    build up to a final coding sprint in the last few days of the schedule. You need
    time to prove that your code works. Otherwise, you'll slip as debugging inches
    out beyond your deadline. If you don't have time to complete all this work, say
    so and get the timescale extended. Don't skip these things—they'll bite you later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Watch out for changing requirements and specifications and track how this will
    affect your timescales. If it's an adverse change, report it immediately. Don't
    silently absorb functionality changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be strict with distractions. Don't work on other tasks unless they are accounted
    for on a plan. Learn to say *no* to old projects, extra work from other departments,
    and intrusions from the phone and email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard against these external distractions, even the short ones that seem harmless;
    they can really lower the quality of your work. It takes time to *get into the
    zone*, that productive place where your mind is on the task and the code is flowing
    freely from your fingertips (psychologists call this state *flow*). Even short
    distractions interrupt this effectiveness, and when you return to work, you must
    spend more time getting back into the zone. The impact of interruptions can be
    more than three times their duration. (DeMarco 99)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Foster a development culture that''s conducive to getting work done. Respect
    each other''s brain-space: a person''s time to think and work. Make sure that
    every meeting really is necessary—don''t pull developers into random, time-wasting
    get-togethers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Maintain a positive and optimistic approach. Believing a project is doomed is
    a surefire way to make that happen in reality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-21-FN-5)]) 5Ironically, good estimates can also cause this problem.
    DeMarco and Lister recount a genuine episode where a project lead reported their
    100 percent confidence that the project would complete on time and to budget.
    (DeMarco 99) The managers, taken aback by this unexpected piece of good news,
    consequently decided to bring the deadline forward! No matter how good the engineer,
    you can always build a better manager to destroy his or her hard work!
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good luck is a lazy man's estimate of a worker's success.
  prefs: []
  type: TYPE_NORMAL
- en: --Anonymous
  prefs: []
  type: TYPE_NORMAL
- en: Timescale estimation and planning help us to develop commercially successful
    software. However, there is no rigorous method to accurately determine software
    timescale values. That's why it's *estimation*.
  prefs: []
  type: TYPE_NORMAL
- en: Aim to develop your estimation techniques, and become wary of potential problems
    that can ruin your neatly scheduled development plan. Learn how to work to a schedule
    and to identify when your schedules are impractical.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Create good timescale estimates by considering all parts of the development
    process, based on a sound component breakdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to produce tested code with full documentation, properly integrated within
    the timescales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight timescale problems early on so that they can be dealt with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Produce hopeful estimates, based solely on hunches and gut feelings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can hack out some code within their timescale estimates but will not produce
    production quality, bug-free code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think that admitting a timescale problem is a sign of weakness, and work themselves
    silly trying to catch up—when they fail, they look silly (and tired)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: Good timescale estimates can only be based on a sound initial code design.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Making an estimate requires a well-defined scope of work, which must be captured
    unambiguously in a *specification*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: Development methodologies determine how tasks are slotted together and placed
    on a project plan.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207576.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 550.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can you rescue a slipping project and bring it back on track?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the correct response to having a deadline imposed on you before feasibility
    or planning work commences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that a development plan is genuinely useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do different programmers work at different rates? How can you reflect this
    on the plan?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What percentage of the projects that you've worked on have run to schedule?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For those that did: What contributed to the success of the planning effort?'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For those that failed: What were the main problems?'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How accurate are your timescale estimates? How far off target are you normally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
