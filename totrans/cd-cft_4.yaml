- en: Part V. PART OF THE PROCESS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分。过程的一部分
- en: Writing high-quality software isn't just about churning out good code. Obviously,
    good code helps. A little. But there's much more to it than that. Good software
    is created intentionally; it takes planning, foresight, and a robust battle plan.
    We'll see exactly what this battle plan looks like in the next section. However,
    before we assemble the troops, we must know what they should do. It helps to point
    them all in the same direction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量的软件不仅仅是产出好的代码。显然，好的代码有帮助。有一点。但还有更多。好的软件是有意创造的；它需要规划、远见和稳健的战斗计划。我们将在下一节中确切地看到这个战斗计划的样子。然而，在我们集结部队之前，我们必须知道他们应该做什么。指向同一个方向是有帮助的。
- en: 'This section looks at some specific parts of the development process, the extra
    activities we schedule time for that help us to intentionally craft excellent
    code. We''ll see:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨开发过程中的某些特定部分，我们为帮助有意创造优秀代码而安排的额外活动。我们将看到：
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: How to write and read software specifications. The correct approach to recording
    what you will do, and what you have done. This chapter shows how specifications
    can make your life easier, rather than get on your nerves.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写和阅读软件规范。正确记录你将做什么，以及你已经做了什么的方法。本章展示了规范如何使你的生活更轻松，而不是让你感到烦恼。
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章。致命的回顾")'
- en: A discussion of *code reviews*—an important practice that ensures you are writing
    high-quality code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码审查的讨论——这是一个重要的实践，确保你正在编写高质量的代码。
- en: '[Chapter 21](ch21.html "Chapter 21. HOW LONG IS A PIECE OF STRING?")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第21章](ch21.html "第21章。一根绳子有多长？")'
- en: Software timescale estimation—an essential activity in the planning process,
    yet still one of the mystic black arts of the software development community.
    This chapter busts some estimation myths and provides practical advice to use
    on the front line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件时间尺度估计——规划过程中的一个基本活动，但仍然是软件开发社区中的一种神秘的黑魔法。本章破除了一些估计的迷思，并提供了实际的建议，以便在一线使用。
- en: The relentless pressures of the software factory continually drive us to work
    faster and harder. The only way to cope is to learn ways to work smarter. We need
    to employ each of these pracices to stand a chance in the endgame.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工厂无情的压力不断驱使我们更快、更努力地工作。唯一的应对方式是学习更聪明的工作方式。我们需要采用这些实践中的每一个，以在最终决战中有一线机会。
- en: Chapter 19. BEING SPECIFIC
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章。具体化
- en: '*Writing Software Specifications*'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*编写软件规范*'
- en: I've never known any trouble that an hour's reading didn't assuage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未知道任何麻烦是一小时的阅读不能缓解的。
- en: --Charles De Secondat
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: --查尔斯·德·塞孔达
- en: Almost everything worth using is documented. Your DVD player has an instruction
    manual. Your car has a maintenance manual. A contract has small print. Chocolate
    cake has a recipe. There are books and magazines dedicated to practically every
    pursuit known to man. If your software is worth using, it also should be well
    documented.^([[1](#ftn.CHP-19-FN-1)])
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有值得使用的东西都有文档。你的DVD播放器有说明书。你的车有维护手册。合同有细小字。巧克力蛋糕有食谱。有书籍和杂志致力于人类所知的几乎所有追求。如果你的软件值得使用，它也应该有很好的文档。[^[[1](#ftn.CHP-19-FN-1])]
- en: We all know that the carefully tested software we give to our customers needs
    to have documentation. Just how much documentation is a moot point. The user of
    an office suite certainly thinks there should be more than the publisher does.
    Without a manual to describe the usage mechanics of your software, whatever form
    it takes, people will falsely assume that it can do more than it was designed
    to, or use it for purposes no sane programmer would have ever imagined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道我们给客户的经过仔细测试的软件需要文档。究竟需要多少文档是一个悬而未决的问题。办公套件的用户当然认为应该比出版商认为的更多。如果没有描述你的软件使用机制的说明书，无论它采取什么形式，人们都会错误地假设它能够做比它设计时要多的东西，或者用它来实现任何理智的程序员都不会想象的用途。
- en: Developers can just as easily make the same kinds of mistakes during coding.
    Just as the final software product needs documentation, so do the intermediate
    development steps. This is the sort of documentation that the end user will (usually)
    never see. These are the definitions of how the program will be designed and built.
    These are the software *specifications*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在编码过程中同样容易犯同样的错误。就像最终软件产品需要文档一样，中间的开发步骤也需要文档。这是最终用户（通常）永远不会看到的文档。这些是程序将如何设计和构建的定义。这些是软件的*规范*。
- en: 'Writing and working with specifications is an important skill of the practicing
    programmer. Communicating in English (or any other natural language) is just as
    important as communicating in code.^([[2](#ftn.CHP-19-FN-2)]) Like eating your
    vegetables and exercising regularly, specifications are "good for you" and good
    for your software. However, like cabbage and the gym, we avoid them, feel guilty,
    and then live to regret the consequences: We end up with unhealthy, flabby software
    development.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和使用规范是实践程序员的重要技能。用英语（或任何其他自然语言）进行沟通与用代码进行沟通一样重要。[^2](#ftn.CHP-19-FN-2)] 就像吃蔬菜和定期锻炼一样，规范对你的健康和软件都是有益的。然而，就像卷心菜和健身房一样，我们避免它们，感到内疚，然后后悔后果：我们最终得到的是不健康、松弛的软件开发。
- en: 'The traditional notion of a software specification involves a huge wedge of
    paper filled with dense text, cryptic tables, and meaningless terminology. It''s
    a highly uninspiring prospect: a document that requires more maintenance effort
    than the code it describes. Developers live in perpetual fear of being forced
    to work with the spec.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件规范概念涉及一大块纸张，上面满是密集的文字、晦涩的表格和毫无意义的术语。这是一个非常令人沮丧的前景：一个需要比描述的代码更多维护努力的文档。开发者们永远生活在被迫与规范一起工作的恐惧之中。
- en: But it doesn't have to be this way. Used correctly, specifications oil the development
    process. They reduce development risk, help you to work effectively, and make
    your life a lot easier. In this chapter, we'll investigate the sorts of specifications
    we need, what should be in them, and why reality differs so greatly from this
    ideal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但情况不必如此。如果正确使用，规范可以润滑开发过程。它们减少了开发风险，帮助你有效地工作，并使你的生活变得更加容易。在本章中，我们将探讨我们需要什么样的规范，它们应该包含什么内容，以及为什么现实与这个理想相差如此之大。
- en: What Are They, Specifically?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们具体是什么？
- en: Apply your heart to instruction and your ears to words of knowledge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用心去听教导，用耳朵去听知识的言语。
- en: --Proverbs 23:12
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: --箴言 23:12
- en: Specifications are formal documents that form part of the development process,
    providing internal software documentation. There are many different types of specification
    (we'll see them shortly) containing different information and targeted at different
    audiences. Each one is appropriate to a particular stage of the software construction
    process, from the conception of a project to its final deliverable. We use them
    to capture exactly what the user requires (or exactly what they are going to get,
    if the two differ—they usually do), to detail the architecture of a software solution,
    the interface of a particular code module, the design and implementation decisions
    for a piece of code, and more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是构成开发过程一部分的正式文件，提供内部软件文档。有许多不同类型的规范（我们很快就会看到），包含不同的信息，针对不同的受众。每一种都适合软件构建过程的特定阶段，从项目的构思到最终交付。我们使用它们来捕捉用户确切需要的内容（或者他们将要得到的内容，如果两者不同——通常是这样的），详细说明软件解决方案的架构、特定代码模块的接口、代码的设计和实现决策，等等。
- en: Specifications help you to work smarter and to produce better software. But
    a bad specification can do quite the opposite. Like your code, the quality of
    a software specification is vital. Good specifications and documentation are generally
    taken for granted, whereas poor specifications rapidly become loathed; a millstone
    around the project's neck.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 规范可以帮助你更聪明地工作，并生产出更好的软件。但一个糟糕的规范可能会产生相反的效果。就像你的代码一样，软件规范的质量至关重要。好的规范和文档通常被视为理所当然，而差的规范会迅速变得令人厌恶；成为项目脖子上的一块磨石。
- en: '**KEY CONCEPT**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Not just the existence, but also the quality of software specifications is
    vital to the software development process*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件规范的存在及其质量对于软件开发过程至关重要*。'
- en: Specifications are a form of inter- and intrateam communication. We've seen
    that projects can die from a lack of communication. We should therefore exploit
    specifications as a communication medium—where appropriate. (Projects can just
    as easily fail because too much time is spent writing documents, and not enough
    time is actually spent writing software!)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是团队间和团队内沟通的一种形式。我们已经看到，项目可能会因为缺乏沟通而失败。因此，我们应该利用规范作为沟通媒介——在适当的时候。（项目同样可能因为花太多时间写文档，而实际编写软件的时间不足而失败！）
- en: Specifications become increasingly important as the size of a project increases.
    This is not because specifications are unimportant in smaller projects but because
    larger projects have more to lose—there are more people whose lack of communication
    and coordination will have a greater negative impact on the outcome of the software
    development process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目规模的增加，规范变得越来越重要。这并不是因为规范在较小的项目中不重要，而是因为较大的项目有更多可以失去的东西——有更多的人缺乏沟通和协调，这将对软件开发过程的成果产生更大的负面影响。
- en: '**KEY CONCEPT**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Specifications are an important communication mechanism for software developers.
    Use them to capture information that must not be lost or forgotten*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*规范是软件开发者的重要沟通机制。使用它们来捕捉必须不丢失或遗忘的信息*。'
- en: 'Writing specifications helps to make your information:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编写规范有助于使你的信息：
- en: '**Safer**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**更安全**'
- en: 'Information isn''t stored in people''s heads where it can be lost, forgotten,
    or remembered incorrectly. With all important facts written down, there''s less
    risk when people leave the project: The amount of information loss will be minimized,
    and there will be a solid base to help any replacement programmer get up to speed.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 信息不是存储在人们的脑海中，那里可能会丢失、遗忘或错误地记住。将所有重要事实写下来，当人们离开项目时风险更小：信息损失将最小化，并且有一个坚实的基础来帮助任何接替的程序员快速上手。
- en: Thorough, complete specifications reduce the risk of two people making different
    sets of assumptions—the classic reason why two separately created modules do not
    worktogether when first integrated. Specifications help to prevent subtle bugs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽、完整的规范可以降低两个人做出不同假设的风险——这是两个分别创建的模块在首次集成时无法协同工作的经典原因。规范有助于防止微妙的错误。
- en: '**Accessible**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**可访问**'
- en: All information is conveniently recorded in a known place. New people can join
    your project and understand what each component does and how they fit together,
    just by reading the documentation. They don't have to search for the information
    in a hundred different people's heads before they become productive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有信息都方便地记录在已知的位置。新加入项目的人只需阅读文档，就能了解每个组件的功能以及它们是如何协同工作的，无需在成为生产力之前在众多人的脑海中搜寻信息。
- en: '**More accurate**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**更准确**'
- en: When all information is gathered and captured, you are more likely to see problems,
    to indentify missing parts of the design, and to spot any unfortunate consequences
    or side effects. A few disconnected thoughts floating around your brain are not
    as easy to validate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有信息都被收集和捕捉时，你更有可能发现问题，识别设计中的缺失部分，以及发现任何不幸的后果或副作用。你大脑中漂浮的几个零散的想法并不容易验证。
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-19-FN-1)]) Of course, that's no excuse to craft a bad interface;
    it must still be easy and intuitive to use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-19-FN-1)]) 当然，这并不是制作糟糕界面的借口；它仍然必须易于使用且直观。
- en: ^([[2](#CHP-19-FN-2)]) Indeed, Dijkstra once remarked, "Besides a mathematical
    inclination, an exceptionally good mastery of one's native tongue is the most
    vital asset of a competent programmer."
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-19-FN-2)]) 的确，迪杰斯特拉曾说过：“除了数学倾向之外，对本族语的良好掌握是合格程序员最重要的资产。”
- en: The Types of Specification
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范的类型
- en: 'Each type of specification forms an intermediate gate of the software process:
    A method of handover between separate parts of the development process. For example,
    a specification for the API of a software component is written by the group of
    people who are scoping its functionality and interface. The programmer works to
    this specification; it is complete enough to implement all the code. The same
    specification is a contract detailing how the systems integrator can stitch it
    into the system and how other programmers can use it. It also describes expected
    behavior, so the test department can validate that the software is working correctly.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的规范构成了软件流程中的一个中间关卡：开发过程不同部分之间的交接方法。例如，软件组件API的规范是由那些界定其功能和界面的团队编写的。程序员根据这个规范工作；它足够完整，可以实施所有代码。同样的规范是一份合同，详细说明了系统集成商如何将其整合到系统中，以及其他程序员如何使用它。它还描述了预期的行为，因此测试部门可以验证软件是否正确运行。
- en: In this way, the output of one specification flows naturally into the contents
    of the next, leaving a trail of documents in the wake of the rapidly evolving
    software. An example of this paper trail is shown in [Figure 19-1](ch19s02.html#the_typical_specification_paper_trail
    "Figure 19-1. The typical specification paper trail"). We see a natural hierarchy
    of documents generated as a project matures—each subcomponent has a similar set
    of documents to the overall project; its development can be managed as a mini-project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，一个规格说明的输出自然地流入下一个内容的组成部分，在快速演变的软件中留下了一串文档。[图19-1](ch19s02.html#the_typical_specification_paper_trail
    "图19-1.典型的规格说明文档轨迹")展示了这种文档轨迹的例子。我们看到，随着项目的成熟，生成了一系列自然的文档层次结构——每个子组件都有与整体项目相似的一组文档；其开发可以作为一个迷你项目来管理。
- en: Since software design is an iterative process, this is not a one-way flow of
    information (otherwise you're trapped in a waterfall methodology straight-jacket—see
    "[Waterfall Model](ch22s03.html#waterfall_model "Waterfall Model")" on page 427).
    As you discover missing information or need to adjust the software design, the
    specifications must be updated accordingly. If your documents are not malleable
    and maintainable, your software development will suffer. Bureaucratic development
    processes try to stifle good software development by ensuring that all work is
    performed to The Specification, even if it's 10 years old and completely out of
    date. Good programmers consider their specifications to be just as malleable as
    their code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件设计是一个迭代的过程，这不是信息单向流动（否则你将陷入瀑布方法的紧身衣——参见第427页的"[瀑布模型](ch22s03.html#waterfall_model
    "瀑布模型")")。随着你发现缺失的信息或需要调整软件设计，规格说明必须相应地进行更新。如果你的文档不可塑性和不可维护性，你的软件开发将受到影响。官僚主义的发展过程试图通过确保所有工作都按照规格说明执行来压制良好的软件开发，即使它已经10年之久了，并且完全过时。好的程序员认为他们的规格说明就像他们的代码一样可塑。
- en: '![The typical specification paper trail](tagoreillycom20080909nostarchimages207566.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![典型的规格说明文档轨迹](tagoreillycom20080909nostarchimages207566.png)'
- en: '**Figure 19-1. The typical specification paper trail**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19-1.典型的规格说明文档轨迹**'
- en: Let's look at the different types of software specifications and see how they
    enhance your code-writing lifestyle. Unfortunately, in the Real World, these documents
    are called by many different names. A *requirements specification* is variously
    called a *user requirements specification* and a *functional constraints specification*
    by different people.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同类型的软件规格说明，看看它们如何提升你的编码生活方式。不幸的是，在现实世界中，这些文档被许多人用不同的名字称呼。一个*需求规格说明*被不同的人称为*用户需求规格说明*和*功能约束规格说明*。
- en: Requirements Specification
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求规格说明
- en: If all other specifications disappeared in a software development process meltdown,
    this is the one document that you should fight for. It's the head of the merry
    software development parade and the stumbling block for many failing projects.
    The information in here is vital. It will keep you sane.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在软件开发过程中发生崩溃，所有其他规格说明都消失了，那么这是你应该争取的文档之一。它是快乐软件开发游行中的领头羊，也是许多失败项目的绊脚石。这里的信息至关重要。它将让你保持理智。
- en: 'The requirements for a project are never clear at first; customers can''t tell
    you *exactly* what they want their software to do (they''re not computer experts,
    so they don''t know). This can cause all kinds of problems, so there must be a
    single document that pins down what your software is supposed to do and the characteristics
    of an acceptable implementation: the *requirements specification*. It lists in
    great detail (or at least appropriate detail, which will usually be great) how
    the code is expected to behave. It must cover all the important, high-risk, high-value
    areas of system behavior, comprehensively and unambiguously.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的需求一开始通常是不清晰的；客户不能确切地告诉你他们的软件应该做什么（他们不是计算机专家，所以不知道）。这可能会引起各种问题，因此必须有一个单一的文档来明确指出你的软件应该做什么以及可接受实现的特性：*需求规格说明*。它详细列出（或者至少是适当的详细程度，这通常将是详细的）代码预期如何表现。它必须全面且明确地涵盖系统行为的重要、高风险、高价值领域。
- en: 'The requirements are usually written as a series of numbered sentences each
    containing a single factual piece of information. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需求通常被写成一系列编号的句子，每个句子包含一个单一的事实信息。例如：
- en: 1.3.5 The user interface shall consist of a black rectangle containing the words
    Don't Panic in a red sans-serif typeface at 13pt.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.5 用户界面应包含一个黑色矩形，其中以13pt的红色无衬线字体显示单词“不要慌张”。
- en: Uniquely numbering each requirement enables easy cross-referencing in subsequent
    documents and helps you to trace a particular design or implementation decision
    back to a single requirement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个需求进行唯一编号可以在后续文档中轻松进行交叉引用，并帮助你将特定的设计或实现决策追溯到单个需求。
- en: 'We must consider:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑：
- en: '**Functional requirements**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能需求**'
- en: 'These requirements detail what the program must do. For example: *Must process
    BMP images and convert them to either JPEG or GIF format*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求详细说明了程序必须执行的操作。例如：*必须处理 BMP 图像并将它们转换为 JPEG 或 GIF 格式*。
- en: '**Performance requirements**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能需求**'
- en: 'These requirements show how fast it must work and whether there are operations
    with deadlines. For example: *The user must receive feedback for every operation
    within one second, and all operations must complete within five seconds*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求显示了它必须工作的速度以及是否存在具有截止日期的操作。例如：*用户必须在每一秒内收到每个操作的反馈，并且所有操作必须在五秒内完成*。
- en: '**Interoperability requirements**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**互操作性需求**'
- en: 'These requirements describe the other software, hardware, and external systems
    that it must interact with. For example: *Must support HTTP and RS232 communication
    with an upgrade server*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求描述了它必须与之交互的其他软件、硬件和外部系统。例如：*必须支持与升级服务器的 HTTP 和 RS232 通信*。
- en: '**Future operation requirements**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**未来操作需求**'
- en: 'These requirements determine what functionality must be *accommodated* now,
    even if it''s not implemented right away. For example: *Must provide a skinnable
    UI so that the user can customize the look and feel*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求确定现在必须*提供*的功能，即使它们不是立即实现的。例如：*必须提供可定制的用户界面，以便用户可以自定义外观和感觉*。
- en: 'These requirements fall into two camps. *Discrete requirements* are binary.
    You can easily check whether your program meets them by looking at the source:
    There will be a chunk of code dedicated to each bit of functionality. You can
    write specific tests to ensure that each discrete requirement is honored.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求分为两大类。*离散需求*是二元的。通过查看源代码可以轻松检查程序是否满足这些需求：将会有专门针对每个功能部分的代码块。你可以编写特定的测试来确保每个离散需求得到尊重。
- en: '*Nondiscrete requirements* are less tangible. You can''t check whether your
    program meets them just by inspecting the source. These include the required fault-tolerance
    of a system, the required uptime of a server, a program''s mean time between failure,
    its security, or its scalability. These kinds of requirements can be massively
    important and remarkably hard to verify.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*非离散需求*不太具体。仅通过检查源代码无法确定程序是否满足这些需求。这包括系统的所需容错性、服务器的所需正常运行时间、程序的平均故障间隔时间、其安全性或其可扩展性。这类需求可能非常重要，但验证起来却非常困难。'
- en: The process for creating a requirements specification will differ from company
    to company, and often depends on the project characteristics and the customers
    (how smart and competent they are). The requirements specification is collated
    by the marketing team, a future product focus group, or a *business analyst* whose
    job is to understand the problem domain and scope the work required. Usually the
    customer, or a representative of the customer, is involved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建需求规范的过程会因公司而异，通常取决于项目特性和客户（他们的智慧和能力）。需求规范由市场营销团队、未来的产品焦点小组或*业务分析师*整理，其工作职责是理解问题领域并确定所需工作的范围。通常客户或客户的代表会参与其中。
- en: 'The customer must agree to and sign off on the requrements specification; it
    forms an effective contract between the software developer and its client. The
    supplier agrees to ship a product whose functionality meets these requirements;
    the customer agrees to pay for it. Without an agreed specification, the customer
    can refuse the product on a whim, and the developers will have spent a lot of
    effort to no avail. Sadly, this is a common problem in the software factory that
    I have seen many times, especially when the customer is not a technical expert
    and doesn''t know what a good software solution looks like. When the requested
    software is finally built, the customer realizes that what it asked for wasn''t
    what it actually wanted: *Rewrite it in pink*. You''re back to square one. This
    sort of thing happens all the time; the requirements specification is your insurance
    policy.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 客户必须同意并签署需求规范；它构成了软件开发者与其客户之间有效的合同。供应商同意交付一个功能符合这些要求的产品；客户同意为其付费。如果没有达成一致规范，客户可以随意拒绝产品，而开发者将白白浪费大量努力。遗憾的是，这是我多次看到的软件工厂中的常见问题，尤其是在客户不是技术专家且不知道一个好的软件解决方案是什么样子时。当请求的软件最终建成时，客户意识到它所要求的东西并不是它真正想要的：*用粉色重写它*。你回到了起点。这类事情经常发生；需求规范是你的保险政策。
- en: 'Sadly, many software factories skip requirements gathering or do not give it
    sufficient import. It''s *vital* to agree on the requirements early on, before
    software design has started and certainly before any code has been written. We
    use the functional requirements specification:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，许多软件开发工厂跳过了需求收集，或者没有给予它足够的重视。在软件设计开始之前，当然是在任何代码编写之前就达成一致意见是**至关重要的**。我们使用功能需求规范：
- en: To keep the project on track and on time—by preventing (or at least reducing)
    the tardy addition of new features that will postpone delivery.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保项目按计划并按时完成——通过防止（或至少减少）新功能的迟缓添加，这些新功能将推迟交付。
- en: To improve customer satisfaction—by setting expectations up front.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高客户满意度——通过提前设定期望。
- en: To reduce bugs—by restricting *feature creep*, we avoid last-minute code additions,
    which helps to avoid scary bugs.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了减少错误——通过限制**功能蔓延**，我们避免在最后时刻添加代码，这有助于避免令人恐惧的错误。
- en: To maintain your sanity—without requirements specifications, developers rapidly
    lose their hair.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持你的理智——没有需求规范，开发者会迅速失去头发。
- en: Depending on the type of development methodology you employ, a single monolithic
    requirements specification might be written up front before any software development
    begins, or it might be developed incrementally alongside the code. Understand
    how your requirements are gathered from the customer and how this impacts the
    way you develop code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你采用的开发方法类型，单一的整体需求规范可能在任何软件开发开始之前就编写好，或者它可能随着代码的编写而逐步开发。了解你的需求是如何从客户那里收集的，以及这如何影响你的代码开发方式。
- en: '**KEY CONCEPT**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Software requirements must be captured early to set expectations, to prevent
    feature creep, and to reduce developer angst*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件需求必须尽早捕捉，以设定期望，防止功能蔓延，并减少开发者的焦虑*。'
- en: 'Also consider your *developmental requirements*: the things that you as a developer
    must have in order to develop the software. For example, you might require a certain
    kind of internal architecture to provide adequate future extensibility, and you
    *need* version control to develop software (it is not optional). Some of these
    might justifiably belong in a requirements specification.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑你的**开发需求**：作为开发者，你必须拥有的东西，以便开发软件。例如，你可能需要一种特定的内部架构来提供足够的未来可扩展性，你需要版本控制来开发软件（这不是可选项）。其中一些可能合理地属于需求规范。
- en: Functional Specification
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能规范
- en: 'Perhaps the document most frequently used by programmers, the *functional specification*
    describes the observable behavior of a piece of software. It is derived from—and
    must satisfy—the requirements specification. There are usually a number of functional
    specifications in one project: one for the overall product and then individual
    specifications for individual software components.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是程序员最常使用的文档，*功能规范*描述了软件的可见行为。它源于并必须满足需求规范。一个项目中通常有几个功能规范：一个用于整体产品，然后为各个软件组件提供个别规范。
- en: For a software component, the functional specification includes a complete and
    unambiguous description of its public interface. This equates to a list of every
    method or function in the module's API, together with a description of what they
    do and how to use them. It contains details of all external data structures and
    formats, and all dependencies on other components, work packages, or specifications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个软件组件，功能规范包括对其公共接口的完整且明确的描述。这相当于列出模块API中的每个方法或函数，以及它们的用途和使用方法。它包含所有外部数据结构和格式的详细信息，以及所有对其他组件、工作包或规范的依赖。
- en: This is more than a user guide to a piece of software. There is enough detail
    to build the component from it. Two teams could read the document and work separately
    on implementions. Although the implementations will differ, both components should
    behave identically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一份软件的用户指南。其中包含足够详细的说明，可以从它构建组件。两个团队可以阅读这份文档，并分别独立工作。尽管实现会有所不同，但两个组件的行为应该是相同的。
- en: 'This fact is exploited in practice: Some NASA spacecraft employ five computers
    to do the job of one; four computers implement the specification for a particular
    computation, running independently developed implementations. The fifth computer
    is used to average the results of the four calculations (or to decide if one computer
    wildly disagrees with the others).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实在实践中得到了利用：一些NASA的航天器使用五台计算机来完成一台计算机的工作；四台计算机独立开发并实施特定计算的任务规范。第五台计算机用于平均这四次计算的结果（或者决定是否有计算机与其他计算机有极大的差异）。
- en: If you're writing a software component without a functional specification, begin
    by writing one yourself. Show it to all interested parties so they can agree that
    what you'll build is sufficient and so they won't be surprised when it is delivered.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写没有功能规范的软件组件，首先自己编写一个。向所有相关方展示，以便他们可以同意你将构建的内容是足够的，这样在交付时他们就不会感到惊讶。
- en: '**KEY CONCEPT**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*If your software task is not adequately specified, don''t start coding until
    you''ve written a functional specification, and people agree that it''s correct*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的软件任务没有充分说明，不要开始编码，直到你写出一个功能规范，并且人们同意它是正确的*。'
- en: System Architecture Specification
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统架构规范
- en: 'The *architecture specification* describes the overall shape and structure
    of the software solution. It encompasses such things as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*架构规范*描述了软件解决方案的整体形状和结构。它包括如下内容：'
- en: Physical computer layout. (Is it distributed client/server software or a single
    user desktop application?)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理计算机布局。（是分布式客户端/服务器软件还是单用户桌面应用程序？）
- en: Software componentization. (How is it split up? Which parts do we need to write;
    which can we buy in?)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件组件化。（如何分割？我们需要编写哪些部分；哪些可以购买？）
- en: Concurrency. (How many threads run at the same time?)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性。（同时运行多少个线程？）
- en: Data storage (including database design).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储（包括数据库设计）。
- en: All other aspects of the system's architecture (redundancy, communication channels,
    and more).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构的所有其他方面（冗余、通信通道等）。
- en: 'It is important to specify these things in detail before too much development
    work happens. The architecture affects the later stages of development; a mistake
    or ambiguity here will filter down to become serious flaws in later phases. Of
    course, nothing is set in stone: If you discover a flaw in the architecture specification,
    then it must be fixed, regardless of how much work has already occurred. Don''t
    accept a bad architecture specification as a millstone around your neck. However,
    it is important to perform adequate architectural design up front. We discuss
    software architecture in detail in [Chapter 14](ch14.html "Chapter 14. SOFTWARE
    ARCHITECTURE").'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量开发工作发生之前详细指定这些内容是很重要的。架构会影响开发的后期阶段；这里的错误或歧义将过滤到后期阶段，成为严重的缺陷。当然，没有什么是一成不变的：如果你发现架构规范中的缺陷，那么它必须得到修复，无论已经发生了多少工作。不要接受一个糟糕的架构规范作为你脖子上的磨石。然而，进行充分的架构设计是很重要的。我们在[第14章](ch14.html
    "第14章。软件架构")中详细讨论了软件架构。
- en: User Interface Specification
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面规范
- en: 'This document contains information about the user interface: what it will look
    like and how it will react. This is how we present the system''s capabilities
    to the user. It might describe a GUI application or a web-based interface, an
    audible phone menu system, a braille accessibility interface, or a simple, single-LED
    display.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档包含有关用户界面的信息：它的外观和它将如何反应。这是我们向用户展示系统功能的方式。它可能描述了一个图形用户界面应用程序或基于Web的界面，一个可听电话菜单系统，一个盲文可访问性界面，或者一个简单的单LED显示屏。
- en: 'Sometimes the user''s view of the system is very different from the implementation
    behind the shiny façade. Here are two examples:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用户的系统视图与光鲜亮丽的表面背后的实现非常不同。这里有两个例子：
- en: A highly networked system can be deployed on a single box and hidden behind
    a unified UI.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高度网络化的系统可以部署在一个单独的盒子上，并隐藏在统一的用户界面后面。
- en: The available functionality can be simplified for ease of use or to create a
    cut-down cheaper version.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的功能可以简化以方便使用或创建一个削减成本更低的版本。
- en: The UI specification describes the interface conventions and metaphors and shows
    how the user sees the functions interact. It is comprised of a textual description,
    with pictures and screenshots. It often contains a *storyboard* representation
    of the UI in action—a pictorial map of each UI state, its transitions, and what
    is displayed in each. It includes every screen that the user will see and all
    detail (that is, all graphics, fields, lists, buttons, and the on-screen layout
    of each). It will also detail acceptable response times for each operation and
    the behavior in common error cases (this isn't exhaustive—trying to enumerate
    *all* possible error conditions is a practically endless task!).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: UI规范描述了界面约定和隐喻，并展示了用户如何看待功能交互。它由文本描述、图片和截图组成。它通常包含UI动作的*故事板*表示——每个UI状态的图片映射、其转换以及每个状态中显示的内容。它包括用户将看到的每个屏幕以及所有细节（即所有图形、字段、列表、按钮以及屏幕上的布局）。它还将详细说明每个操作的合理响应时间以及常见错误情况下的行为（这并不是详尽的——试图列举*所有*可能错误条件是一项实际上无休止的任务！）。
- en: This work may include or lead to a *UI prototype*. Prototypes can be made with
    varying levels of detail and accuracy; this depends on the application and how
    much testing and review will be done. Inevitably, the UI design is incomplete
    at this stage, but this is your first chance to see what the finished product
    will look like. Although prototypes help to envision how the interface will behave,
    it's not until the system is integrated that the UI can be properly reviewed and
    tweaked.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作可能包括或导致一个*用户界面原型*。原型可以根据应用和测试审查的程度以不同详细程度和准确性制作；这取决于应用和将进行多少测试和审查。不可避免的是，在这个阶段，UI设计是不完整的，但这是您第一次看到最终产品将是什么样子。虽然原型有助于设想界面将如何表现，但直到系统集成，UI才能得到适当的审查和调整。
- en: Design Specification
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计规范
- en: A *design specification* (or *technical specification*) documents the internal
    design of a component. It describes how a functional specification will be, or
    has been, implemented. The design specification describes all internal APIs, data
    structures, and formats. It should detail all key algorithms, execution paths,
    and thread interactions. It describes the choice of programming language and the
    tools used to build the code. All of this is critical information for the code
    implementers and maintainters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计规范*（或*技术规范*）记录了一个组件的内部设计。它描述了功能规范将如何实现，或者已经如何实现。设计规范描述了所有内部API、数据结构和格式。它应该详细说明所有关键算法、执行路径和线程交互。它描述了编程语言的选择以及构建代码所使用的工具。所有这些对于代码实现者和维护者来说都是关键信息。'
- en: Many heavyweight development processes mandate the production of a design specification
    prior to implementation; it is reviewed before coding begins to prevent work from
    progressing down a dead end. However, in most software factories, this document
    is written alongside, or after, the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多重量级开发流程要求在实现之前生产设计规范；在编码开始之前进行审查，以防止工作走向死胡同。然而，在大多数软件开发工厂中，这个文档是与代码一起编写，或者是在代码编写之后。
- en: It sounds like such a good idea, but most design specifications are a big waste
    of time! They need continual maintenance to stay in sync with the code being described.
    Without care, they quickly rot and are left inaccurate and incomplete—potential
    snares for unwary readers. For this reason, I suggest that you *don't write a
    design specification*!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是个好主意，但大多数设计规范都是浪费时间！它们需要持续维护以与所描述的代码保持同步。如果不加注意，它们会迅速腐烂，变得不准确和不完整——对粗心大意的读者来说可能是陷阱。因此，我建议您**不要编写设计规范**！
- en: But wait, before you run off unencumbered, there's more. Replace it with something
    that contains the same information but is easier to keep accurate. *Literate programming
    tools* (see "[Practical Self-Documentation Methodologies](ch04s03.html "Practical
    Self-Documentation Methodologies")" on page 66) are a great documentation mechanism
    that can replace heavyweight design specifications by generating documentation
    from the code itself. You need only supply any extra commentary in specially formatted
    code blocks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，在您轻松出发之前，还有更多。用包含相同信息但更容易保持准确性的东西来替换它。*文献化编程工具*（参见第66页的"[实用的自我文档方法](ch04s03.html
    "实用的自我文档方法")"）是一种优秀的文档机制，可以通过从代码本身生成文档来替代重量级的设计规范。您只需要在特别格式化的代码块中提供任何额外的注释。
- en: '**KEY CONCEPT**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Use literate programming tools to write your technical documentation. Don''t
    write a word-processed document that will quickly go stale*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用文献化编程工具编写您的技术文档。不要编写一个很快就会过时的文字处理文档*。'
- en: 'You don''t need the complete production code to use literate documentation
    tools in this way. You can document your intended code structure in the same manner:
    Mock up some code and run the tool over it. This automatically generates design
    documentation, serves as prototype proof-of-concept code and, with care, can evolve
    into the production code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要完整的生产代码就可以以这种方式使用文献化文档工具。您可以用同样的方式记录您打算的代码结构：模拟一些代码，然后运行工具。这会自动生成设计文档，充当原型验证概念代码，并且经过精心设计，可以演变成生产代码。
- en: Test Specification
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试规范
- en: 'The *test specification* describes the testing strategy for a particular piece
    of software. It shows how to validate the implementation against its functional
    specification so you know when the software is acceptable for release. Naturally,
    the size and scope of this task depends on what is being tested: whether it''s
    a single software component, an entire subsystem, a desktop application, or an
    embedded consumer product.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试规范*描述了特定软件的测试策略。它展示了如何验证实现与功能规范的一致性，以便您知道软件何时可以发布。当然，这个任务的大小和范围取决于正在测试的内容：是单个软件组件、整个子系统、桌面应用程序还是嵌入式消费产品。'
- en: 'The test specification contains a list of every test that must be performed.
    Each test is detailed in a *test script*: a set of simple steps to run the test,
    together with its acceptance criteria and the environment in which the test will
    run. The scripts themselves may be written in separate documents or included in
    this one.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试规范包含必须执行的每个测试的列表。每个测试都在一个*测试脚本*中详细说明：一系列运行测试的简单步骤，以及其验收标准和测试将运行的环境。这些脚本本身可以写在单独的文档中，也可以包含在这个文档中。
- en: As we've seen in [Chapter 8](ch08.html "Chapter 8. TESTING TIMES"), many code-level
    tests can be performed *in code* themselves and run as an automated part of the
    development process. These tests stand distinct from high-level tests that can
    only be performed by running the software in its final context with scripted human
    input.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第8章](ch08.html "第8章. 测试时代")中看到的，许多代码级别的测试可以在代码本身中执行，并作为开发过程的一部分自动运行。这些测试与只能通过在最终环境中运行软件并使用脚本化人工输入才能执行的高级测试截然不同。
- en: Wherever you can create programmatic unit tests for your software, prefer to
    do this rather than create a lengthy test specification. Just as design specifications
    can rapidly become out of date, test specifications written at the code level
    will rot as the system evolves around them. Use programatic test code as the documentation
    of your testing strategy—you can write literate test code as easily as literate
    normal code. Automated test cycles will also force you to keep the tests up to
    date with the code; your tests will fail if you don't!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你可以为你的软件创建程序单元测试，都优先这样做，而不是创建冗长的测试规范。正如设计规范可以迅速过时一样，在代码级别编写的测试规范也会随着系统的发展而腐化。使用程序测试代码作为你的测试策略的文档——你可以像编写可读的正常代码一样轻松地编写可读的测试代码。自动化的测试周期也将迫使你保持测试与代码的一致性；如果你不这样做，你的测试将会失败！
- en: '**DEVIL''S ADVOCATE**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**魔鬼的辩护士**'
- en: 'Specifications are expensive: Reading and writing them requires both time and
    effort. They require extra work. Are all of these documents *really* necessary?
    Yes, they are—to write high-quality software, you need to consciously generate
    all this information and then record it somewhere where it can be retrieved when
    necessary. Specifications encourage us to follow good development practices—to
    track requirements, perform design, and construct a test plan—and we''ve seen
    how they facilitate communication.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是昂贵的：阅读和编写它们需要时间和精力。它们需要额外的工作。所有这些文件*真的*都是必要的吗？是的，它们是——为了编写高质量的软件，你需要有意识地生成所有这些信息，然后将其记录在可以检索的地方，以便在需要时使用。规范鼓励我们遵循良好的开发实践——跟踪需求、执行设计和构建测试计划——我们已经看到它们如何促进沟通。
- en: Agile processes (see "[Agile Methodologies](ch22s03.html#agile_methodologies
    "Agile Methodologies")" on page 433) place far less emphasis on writing specifications,
    but they don't advocate coding by the seat of your pants. Since specifications
    don't write themselves, can easily get out-of-date, and require extra work to
    maintain, and programmers have more than enough to do already, it's sensible to
    only write as many documents as necessary. We should always avoid lengthy procedural
    hurdles. *But any specification you remove must be replaced by an equivalent store
    of information*. Don't skip a specification unless you have conciously replaced
    it with something of equal quality containing the same set of information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷流程（参见第433页的“[敏捷方法](ch22s03.html#agile_methodologies "敏捷方法")”）对编写规范的关注远低于其他方面，但它们并不提倡凭直觉编码。由于规范不会自己编写，很容易过时，并且需要额外的工作来维护，而程序员已经有很多事情要做，因此只编写必要的文件是明智的。我们应该始终避免冗长的程序障碍。*但是，你移除的任何规范都必须被等价的信息库所取代*。除非你有意用同等质量且包含相同信息的东西来替换它，否则不要跳过规范。
- en: 'Extreme Programming doesn''t produce a lengthy requirements specification,
    but it captures all requirements in an equivalent set of user stories, held on
    a stack of story cards. Design specifications are eschewed: The code is its own
    documentation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 极限编程不会产生冗长的需求规范，但它通过一组等价的用户故事来捕捉所有需求，这些故事卡堆叠在一起。设计规范被摒弃：代码本身就是其文档。
- en: Agile practice also promotes test-driven *design*, where codified tests act
    as additional documentation of the code and its behavior. This full and clear
    suite of unit tests can replace the test specification for individual components
    but is seldom suitable to verify the final product against its validation criteria.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷实践也促进了测试驱动的*设计*，其中编码的测试作为代码及其行为的额外文档。这个完整且清晰的单元测试套件可以替代单个组件的测试规范，但很少适合验证最终产品是否符合其验证标准。
- en: What Should Specifications Contain?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范应包含什么内容？
- en: 'The contents of each type of specification are naturally very different. However,
    the information in any specification must be:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型规范的 内容自然非常不同。然而，任何规范中的信息必须包括：
- en: '**Correct**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确**'
- en: 'This might seem obvious, but it is absolutely vital. An incorrect specification
    can cause days of wasted effort. It must be kept up to date or it will become
    dangerously misleading: It will waste readers'' time, cause confusion, and may
    lead to bugs being introduced as a consequence.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显，但绝对是至关重要的。一个错误的规范可能导致数天的徒劳无功。它必须保持最新，否则会变得极其误导：它会浪费读者的时间，造成混乱，并可能导致引入错误作为后果。
- en: If a specification can be interpreted in more than one way, then the "specification"
    isn't specific—it's not doing its job. Two readers could make different interpretations
    of the ambiguous information, with inevitable unfortunate consequences. Make sure
    that your specifications can only be interpreted as you intended.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个规范可以有多种解释方式，那么这个“规范”就不具体——它没有完成它的任务。两个读者可能会对模糊的信息有不同的解读，这不可避免地会导致不幸的后果。确保你的规范只能按照你的意图来解释。
- en: The text must not contradict itself. When a specification gets reasonably large,
    it becomes difficult to ensure consistency. This becomes a particular problem
    when a maintainer (different from the original author) makes modifications—it
    can be very easy to alter information in one place and not change any subsequent
    sections that allude to the same information.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文本必须不自相矛盾。当规范变得相当大时，确保一致性变得困难。当维护者（不同于原始作者）进行修改时，这是一个特别的问题——很容易在某个地方更改信息，而不会更改任何后续引用相同信息的部分。
- en: A specification should be carefully written to comply with all relevant standards
    (for example, language definitions and company coding standards). It should follow
    the document standards/conventions of your company and use any document templates
    that exist.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 规范应该仔细编写，以确保符合所有相关标准（例如，语言定义和公司编码标准）。它应该遵循你公司的文档标准/惯例，并使用任何现有的文档模板。
- en: '**Comprehensible**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**可理解**'
- en: An effective specification is inviting to read and easy to understand. It makes
    sense to every reader. If it's so technical that only engineers can understand
    it, then non-techie departments (like marketing and management) will not feel
    part of the audience and will not look at it carefully. Problems won't be spotted
    until it's too late.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的规范应该易于阅读和理解。对每个读者来说都是有意义的。如果它过于技术化，只有工程师才能理解，那么非技术部门（如市场和管理工作）就不会觉得自己是受众的一部分，也不会仔细查看。问题只有在太晚的时候才会被发现。
- en: Like good code, the best specifications are written from the perspective of
    the reader, not the writer. The information is organized to make it comprehensible
    to a newcomer, rather than convenient for the author. Blaise Pascal once apologized,
    "I made this letter longer than usual because I lack the time to make it short."
    Good writing is concise and doesn't hide the main point behind a wall of words.
    This does require more work and will take more time, but it's worth it if the
    result is simpler to understand.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像好的代码一样，最好的规范是从读者的角度而不是作者的角度编写的。信息组织得让新手也能理解，而不是让作者方便。布莱兹·帕斯卡曾道歉说：“我让这封信比平时更长，因为我缺乏时间让它更短。”好的写作是简洁的，不会在文字的墙壁后面隐藏主要观点。这确实需要更多的工作，并且会花费更多的时间，但如果结果是更容易理解，那么这是值得的。
- en: Don't feel compelled to write reams of boring prose in a specification. Consider
    using devices to compress it and make it easier to read. Bulleted and numbered
    lists, diagrams, headings and subheadings, tables, and judicious use of whitespace
    break up the flow and help the reader to create a mental map of the material.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中，没有必要写一大堆无聊的散文。考虑使用一些工具来压缩它，使其更容易阅读。项目符号和编号列表、图表、标题和副标题、表格以及适度的空白可以帮助打断流程，帮助读者在脑海中构建材料的思维导图。
- en: '**Complete**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整**'
- en: A specification should be self-contained and complete. That doesn't mean it
    should contain *all* possible information; it is perfectly acceptable to reference
    other relevant documents, as long as the reference is precise (consider document
    revisions in your references) and will allow the reader to easily locate the document.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 规范应该是自包含和完整的。这并不意味着它应该包含所有可能的信息；引用其他相关文档是完全可接受的，只要引用准确（考虑你在引用中的文档修订）并且允许读者轻松找到该文档。
- en: The level of detail in a specification should be significantly less than the
    detail in the implementation; otherwise it is either overly prescriptive or too
    dense to understand. People tend to ignore complicated specifications, so they
    become abandoned. Left festering in a corner, they only serve to confuse readers
    who don't realize that they're no longer authoritative.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的详细程度应该远低于实现的详细程度；否则，它要么过于具体，要么过于密集而难以理解。人们倾向于忽略复杂的规范，因此它们变得被遗弃。在角落里腐烂，它们只会让那些没有意识到它们不再是权威的人感到困惑。
- en: '**Verifiable**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**可验证**'
- en: 'A specification for a software component interface will lead to the production
    of two things: the software implementation and a test harness to verify it. The
    contents of a specification must, therefore, be verifiable. In practice, this
    largely equates to being correct, unambiguous, and complete.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件接口的规范将导致两个东西的产生：软件实现和用于验证它的测试工具。因此，规范的内容必须是可验证的。在实践中，这主要等同于正确、明确和完整。
- en: '**Modifiable**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**可修改性**'
- en: Nothing is set in stone, neither code nor documents. If a specification needs
    updating (perhaps to correct a factual error) then this should be easy. A cast-iron
    specification prevents the world changing underneath your feet. However, it's
    no use if the specification is wrong. The document must be editable (i.e., you
    should be able to get to the source, not just a PDF copy), and its release and
    update procedure must not be too troublesome.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么是一成不变的，无论是代码还是文档。如果规范需要更新（可能是为了纠正事实错误），那么这应该是容易的。一个铁定的规范可以防止世界在你脚下改变。然而，如果规范是错误的，那就毫无用处。文档必须是可编辑的（即，你应该能够访问源文件，而不仅仅是PDF副本），并且其发布和更新程序不应过于繁琐。
- en: In order to make modifications easily, the document must be carefully structured
    and no bigger than absolutely necessary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于修改，文档必须精心结构化，并且不要超过绝对必要的范围。
- en: '**Self-describing**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**自我描述**'
- en: 'Each specification must contain at least:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规范至少必须包含：
- en: A *frontsheet*, clearly showing the document title, subtitle, author(s), revision
    number, date last modified, and document release status (e.g., company confidential,
    supplied externally under NDA, or a public release).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*封面*，清楚地显示文档标题、副标题、作者、修订号、最后修改日期和文档发布状态（例如，公司机密、在NDA下外部提供，或公开发布）。
- en: An *introduction* to the document, providing a brief summary of its aims, scope,
    and the target audience.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档的*简介*，提供对其目标、范围和目标受众的简要概述。
- en: 'All relevant *terms and definitions* that the reader needs in order to understand
    the contents. (But don''t patronize the reader: If your audience is made up of
    software engineers, don''t explain what RAM stands for.)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者为了理解内容所需的所有相关*术语和定义*。（但不要对读者居高临下：如果你的受众是软件工程师，不要解释RAM代表什么。）
- en: A set of *references* to other related or cross-referenced documents.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组*参考*其他相关或交叉引用的文档。
- en: A *history* section that lists all important modification and revision information.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列出所有重要修改和修订信息的*历史*部分。
- en: '**Traceable**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**可追溯性**'
- en: There should be a document control procedure (akin to a source management system)
    and a central file store in which all documents reside. Every release version
    of a specification should be lodged in the repository and must remain be accessible,
    so you can discover which version of a spec you were working to a year ago; one
    day you'll need it again. Consider using a revision control system—it's a great
    tool for versioning any sort of file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个文档控制程序（类似于源管理系统）和一个中央文件存储库，其中所有文档都驻留。每个规范的发布版本都应该存档在存储库中，并且必须保持可访问，这样你就可以发现一年前你正在工作的规范版本；总有一天你会再次需要它。考虑使用版本控制系统——这是一个为任何类型的文件进行版本管理的优秀工具。
- en: The document frontsheet contains control information (version number, date,
    author, etc.) so you can check that you have the most up-to-date copy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文档封面包含控制信息（版本号、日期、作者等），以便你可以检查你是否拥有最新的副本。
- en: '**KEY CONCEPT**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Think about the contents of your specification as you write it. Choose a structure
    and vocabulary that the audience will understand, and make sure that the document
    is correct, complete, and self-describing*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*在编写规范时，思考其内容。选择一个受众能够理解的结构和词汇，并确保文档是正确、完整且自我描述的*。'
- en: The Specification-Writing Process
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范编写过程
- en: What is written without effort is in general read without pleasure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有付出努力写下的文字，通常也是没有乐趣去阅读的。
- en: --Samuel Johnson
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: --塞缪尔·约翰逊
- en: 'Now knowing the types of specification we must produce and what should go in
    them, we''re armed and ready. It''s time to write something! The specification-writing
    process is simple:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了必须生成的规范类型以及它们应该包含的内容，我们已经准备好了。是时候写点东西了！规范编写过程很简单：
- en: Select the appropriate document template to start from. This may be provided
    as part of a defined project development process. If there is no template, base
    it on an existing specification.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择合适的文档模板开始。这可能作为定义的项目开发过程的一部分提供。如果没有模板，可以基于现有的规范。
- en: Write the document. Okay, this is the hard part. What you write naturally depends
    on the type of specification.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写文档。好吧，这是难点。你写的内容自然取决于规范类型。
- en: Arrange for the document to be reviewed. Include all the people with an interest
    in it.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排对文档进行审查。包括所有对该文档感兴趣的人。
- en: Once it's agreed upon (and, if your process demands, formally signed off on),
    put a versioned copy in the document repository and release it to the appropriate
    audience.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦达成一致（如果你的流程要求，正式签署），将带有版本号的副本放入文档存储库，并发布给适当的受众。
- en: If there are any later problems, raise a change request for the specification
    and make sure that you understand how the modification affects the scope of your
    development work. If you don't, then the coding effort will double without anyone
    noticing.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何后续问题，提出规范变更请求，并确保你理解修改如何影响你的开发工作范围。如果不这样做，编码工作将翻倍，而没有人会注意到。
- en: This is a simple procedure to list, but it isn't simple to do. It's easy to
    focus only on step 2—we skip the rest for an easy life. But without these other
    actions, you haven't created a formal identifiable document; this may cause problems
    later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的列表程序，但做起来并不简单。很容易只关注第2步——我们跳过其余部分以简化生活。但没有这些其他行动，你没有创建一个正式可识别的文档；这可能会在以后造成问题。
- en: 'Consider these spec-writing guidelines when composing your literary masterpiece.
    The first few relate to authorship and to your artistic sensibilities:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在创作你的文学杰作时，请考虑以下规范编写指南。前几条与作者身份和你的艺术感相关：
- en: Writing usually works best when there is one author per document. It's hard
    to coordinate multiple authors and accommodate different writing styles. If you
    are documenting a big system, then split the specification into parts and give
    one to each person to work on separately. Create an umbrella document that links
    them all together.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写作通常在每份文档只有一个作者时效果最好。协调多个作者和适应不同的写作风格很难。如果你正在记录一个大型系统，那么将规范分成几个部分，并分别给每个人一份去单独工作。创建一个将这些部分联系在一起的伞状文档。
- en: Contrary to some opinions, it is not at all egotistical to have one person's
    name on the front of a specification. Someone needs to take credit for it—praise
    when it's a good job and blame when it's not.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与一些观点相反，在规范的前面只署一个人的名字根本不是自大的。有人需要为它承担责任——当工作做得好时得到表扬，当工作做得不好时受到责备。
- en: If you significantly extend someone else's document, don't feel embarassed to
    add yourself to the list of authors. But don't remove someone from the author
    list unless his or her original input has now been removed.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你显著扩展了别人的文档，不要因为自己被添加到作者名单而感到尴尬。但除非他的原始输入已被删除，否则不要从作者名单中删除任何人。
- en: '**LANGUAGE BARRIERS**'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**语言障碍**'
- en: I hate definitions.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我讨厌定义。
- en: —Benjamin Disraeli
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ——本杰明·迪斯雷利
- en: 'Compose your specification''s text very carefully. Compared to code, the English
    language is full of ambiguity and complexity. These *genuine* newspaper headlines
    show just how ambiguous seemingly simple English statements can be: "Stolen painting
    found by tree," "Kids make nutritious snacks," "Red tape holds up new bridge,"
    and "Hospitals are sued by *7* foot doctors."'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非常仔细地编写你的规范文本。与代码相比，英语语言充满了歧义和复杂性。以下这些*真正的*报纸标题仅展示了看似简单的英语陈述可以有多大的歧义：“被盗的画作被树发现”，“孩子们制作营养小吃”，“红
    tape 拦住了新桥”，“医院被*7*英尺高的医生起诉。”
- en: Specifications are formal documents and they must not be chatty or verbose;
    this tends to hide the important facts behind a wall of words. Non-native English
    readers may struggle. However, a terse document is hard to follow. This is a delicate
    balance, and document review helps to determine the correct style of writing.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规范是正式文档，它们不得闲聊或冗长；这往往会在一堵文字墙后隐藏重要的事实。非英语母语读者可能会感到困难。然而，简短的文档很难跟随。这是一个微妙的平衡，文档审查有助于确定正确的写作风格。
- en: 'Formal documents are written in the third person, in present tense. An accurate
    selection of words is very important. A useful convention is defined in the Internet
    RFC document #2119\. This defines the following key terms for protocol specifications
    (which are also very useful in requirements specifications):'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正式文档以第三人称、现在时态编写。准确选择词语非常重要。在互联网RFC文档#2119中定义了一个有用的惯例。这为协议规范（在需求规范中也非常有用）定义了以下关键术语：
- en: '**Must**'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**必须**'
- en: The word *must* (*or shall or is required to*) means that the following definition
    is an absolute requirement of the specification.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 词语“必须”（或“应当”或“必须”）意味着以下定义是规范的绝对要求。
- en: '**Must not**'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**不得**'
- en: The words *must not* (*or shall not*) signify an absolute prohibition of the
    specification.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 词语*不得*（*或应不*）表示规范中绝对禁止。
- en: '**Should**'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应该**'
- en: Use *should* (or the adjective *recommended*) to indicate an optional requirement—
    behavior that may be ignored, but only when the full implications are understood
    and have been carefully considered.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*应该*（或形容词*推荐*）来表示一个可选的要求——可能被忽略的行为，但只有在充分理解其全部影响并经过仔细考虑的情况下。
- en: '**Should not**'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**不应该**'
- en: Use *should* not (or the adjective not *recommended*) to describe a particular
    behavior that should be avoided unless there are valid reasons to choose it— again,
    the consequences must be fully understood.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*不应该*（或形容词*不推荐*）来描述应避免的特定行为，除非有合理的理由选择它——再次，必须完全理解后果。
- en: '**May**'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**可能**'
- en: Using *may* (or the adjective optional) means that an item is truly optional.
    An implementer can choose to support it or ignore it but, when applied to protocols,
    it must interoperate with another implementation that made a different choice.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*可能*（或形容词*可选*）意味着一个项目确实是可选的。实现者可以选择支持它或忽略它，但当应用于协议时，它必须与做出不同选择的另一个实现进行互操作。
- en: This is the word that should often be used when people write can. *Can* is a
    commonly misused word in specifications and standards; it is ambiguous and, depending
    on the reader's interpretation, could be taken to mean *must* or *may*.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在人们写“可以”时应该经常使用的词。*可以*是规范和标准中常用词的错误用法；它是模糊的，并且根据读者的解释，可能会被理解为*必须*或*可能*。
- en: The author must be the right person. The marketing department doesn't write
    your functional specification; it provides requirements. Managers don't design
    the code; the developer with the right skill and knowledge does it. The author
    must be capable of writing—it's a skill that's learned, a muscle that requires
    exercise.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者必须是正确的人。市场营销部门不会编写你的功能规范；它提供需求。经理不会设计代码；具有正确技能和知识的开发者来做。作者必须能够写作——这是一种需要学习的技能，是一种需要锻炼的肌肉。
- en: Each document must have a defined *owner* who takes responsibility for it. The
    owner may be different from the original author; it might be the technical authority
    or the document's maintainer now that the primary author has moved on.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文档都必须有一个定义的*所有者*，该所有者对其负责。所有者可能不同于原始作者；现在主要作者已经离开，它可能是技术权威或文档的维护者。
- en: 'Here are some tips for the document writing process:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于文档编写过程的提示：
- en: It's good to have a *best practice* example of each kind of specification. This
    will help authors to understand what is expected of them as they write.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有每种规范的最佳实践示例是好的。这将帮助作者了解他们在写作时应该期望什么。
- en: Early drafts of a specification should be marked as such, with a disclaimer
    stating that it is incomplete. This will prevent people from mistakenly interpreting
    it as complete—they can't moan at you about the content (yet). Maintain a list
    of the incomplete sections and open issues within the document itself.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范的早期草稿应标记为草稿，并在免责声明中指出其不完整。这将防止人们错误地将其视为完整——他们现在还不能对你关于内容的内容抱怨（）。在文档内部维护一个不完整部分和开放问题的列表。
- en: 'Document review is important: It checks that the contents are correct and well
    presented. It is a mechanism to get others'' agreement with your decisions and
    to thereby bestow authority on the document. This is especially important for
    specifications that are sent outside the project: to the customer or to other
    departments.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档审查很重要：它检查内容是否正确且表述良好。这是一个获取他人对你决定的同意并因此赋予文档权威的机制。这对于发送到项目外的规范尤为重要：发送给客户或其他部门。
- en: Once you've finished the specification, don't forget about it. Keep it alive
    and up to date. A functional specification is not complete when the design phase
    is over. Requirements inevitably change, and we continue to learn more about the
    system's operation. Capture all of this in revised specifications.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你完成了规范，不要忘记它。保持其活力并更新。当设计阶段结束时，功能规范并不完整。需求不可避免地会变化，我们继续更多地了解系统的操作。在修订规范中捕捉所有这些。
- en: Why Don't We Write Specifications?
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么不写规范？
- en: I do not understand what I do. For what I want to do I do not do, but what I
    hate I do.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我不明白我在做什么。对于我想做的事情，我没有做，但我讨厌的事情我却做了。
- en: --Romans 7:15
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: --罗马书 7:15
- en: Decent specifications are conspicuous by their absence in the Real World. We
    know it's not good practice to avoid them, so hasty developers gloss over their
    absense and pretend that there's no problem. It's not unusual to be given a coding
    task without an adequate requirements or functional specification. (This is a
    procedural problem that must be overcome by persistent moaning, education, and
    abuse of the powers that be.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，良好的规范往往因为缺失而引人注目。我们知道避免它们不是好的做法，所以匆忙的开发者会忽略它们的缺失，假装没有问题。在没有适当的需求或功能规范的情况下接受编码任务并不罕见。（这是一个必须通过持续抱怨、教育和滥用权力来克服的程序问题。）
- en: 'But it''s equally common for sloppy programmers to sidestep their own document
    writing. Why is this? There are a few excuses we meet repeatedly. Developers don''t
    write specifications because:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但粗心大意的程序员回避自己文档编写的情况也同样常见。为什么会出现这种情况呢？我们反复遇到一些借口。开发者不编写规范的原因是：
- en: They don't know that they should
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们不知道他们应该
- en: They forget
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们忘记了
- en: They don't have the time
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们没有时间
- en: They consciously decide not to, thinking they can get by without them ("Who
    reads specifications, anyway?")
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们有意识地决定不这样做，认为没有它们也能应付过去（“毕竟，谁会阅读规范呢？”）
- en: None of these reasons are defensible. An experienced developer certainly shouldn't
    fall foul of the first two if a specification is an expected deliverable of his
    or her work.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些理由都是站不住脚的。经验丰富的开发者如果规范是他或她工作的预期成果，那么他或她不应该犯前两个错误。
- en: 'Programmers like to program, not write long documents. Most programmers don''t
    have good writing skills; they write elegant code but awful English. It''s hardly
    surprising that they try to avoid writing specs: It''s hard work, uninteresting,
    or they just don''t like doing it. Often it''s seen as a time wasting activity
    that isn''t really necessary. Or they think, *I''ll code first, then come back
    to the documentation later*. Bitter experience shows that this does not happen.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员喜欢编程，而不是撰写冗长的文档。大多数程序员没有良好的写作技巧；他们能写出优雅的代码，但英语却糟糕。他们试图避免编写规范并不足为奇：这是一项艰苦的工作，没有趣味，或者他们只是不喜欢做这件事。通常，这被视为一种浪费时间且并非真正必要的行为。或者他们认为，“谁会阅读规范呢？”
- en: 'The depressing thought that *no one will ever read my beautiful specification*
    puts many more programmers off of the idea of committing their brainwaves to prose.
    And it''s probably true: No other soul may ever read your literary masterpiece.
    But so what? The act of specification writing forces *you* to engage your brain:
    a very important step. Sure, a few Gurus can code on the run and produce excellent
    work. But most programmers, whether they admit it or not, simply can''t. We need
    to design. Carefully. First. That design should then be captured: in a document.
    Potentially, this document will be for your eyes only. But, if one day you hear
    a higher calling and run off to become a Croatian monk, how can a maintenance
    programmer pick up your work? The specification will outlive you. Think of it
    as your legacy.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种令人沮丧的想法——“没有人会阅读我那美丽的规范”——让许多程序员对将他们的思维火花转化为文字的想法望而却步。这可能也是真的：可能没有其他灵魂会阅读你的文学杰作。但那又如何呢？编写规范的行为迫使你动脑：这是一个非常重要的步骤。当然，一些大师可以边编码边产生优秀的工作。但大多数程序员，无论他们是否承认，都无法这样做。我们需要设计。首先，仔细地设计。然后，应该将这种设计捕捉下来：在文档中。可能，这份文档将仅供你一人阅读。但，如果有一天你听到更高的召唤，跑去做克罗地亚的僧侣，维护程序员如何能接手你的工作？规范将超越你。把它看作是你的遗产。
- en: 'Not having time is the only scenario that *you* don''t have control over: Sometimes
    a coding task lands in front of you and there genuinely isn''t enough time to
    write a good specification for it. If you have no time to write a specification,
    then you probably don''t have time to write the code properly either. Make sure
    you''re aware of when you''re doing things properly and when you''re rushing code
    out without any real discipline—that sort of code really doesn''t belong in a
    production release.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 没有时间是你无法控制的唯一场景：有时编码任务摆在你面前，你真的没有足够的时间为它编写良好的规范。如果你没有时间编写规范，那么你可能也没有时间正确地编写代码。确保你清楚何时在正确地做事，何时在匆忙地编写代码而没有真正的纪律——那种代码根本不适合在生产版本中发布。
- en: Saving time by avoiding specifications is almost certainly a false economy;
    specifications help to *save time* communicating. When you write a specification,
    you only have to describe how the program works once. If you skip this step, at
    least the same amount of communication happens anyway, but on an ad hoc basis—over
    a longer space of time and in a less controlled manner. This communication is
    far less effective and will actually take *longer*, because you will have to explain
    the same things over and over again with a slightly different spin for each audience.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过避免规范来节省时间几乎肯定是一种错误的经济行为；规范有助于*节省时间*进行沟通。当你编写规范时，你只需要描述程序的工作方式一次。如果你跳过这一步，至少同样数量的沟通仍然会发生，但基于临时性——在更长的时间内以更不控制的方式。这种沟通效率远低于前者，实际上会花费*更长*的时间，因为你将不得不反复解释相同的事情，每次对不同的受众都有所不同。
- en: '**KEY CONCEPT**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*It is dangerous and unprofessional to avoid writing specifications. If there
    isn''t enough time to write a specification, there probably isn''t enough time
    to write the code*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免编写规范是危险且不专业的。如果没有足够的时间编写规范，可能也没有足够的时间编写代码*。'
- en: Of course, few people write detailed specifications at home for their own personal
    pet projects. This is an extreme case of an appropriately detailed specification.
    Any reasonably large project (which could be determined by the number of source
    files, modules, developers, or customers) really does require specification support.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，很少有人会为他们的个人项目详细编写文档。这是一个适当地详细文档的极端例子。任何合理规模的项目（可能由源文件、模块、开发者或客户数量决定）确实需要规范支持。
- en: In a Nutshell
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要概述
- en: Words are, of course, the most powerful drug used by mankind.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 词语当然是人类使用的最强大的药物。
- en: --Rudyard Kipling
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: --鲁德亚德·吉卜林
- en: They're not the most glamorous part of a software developer's life, but specifications
    are an important part of our code-writing routine. Learn to read and write them
    effectively—to record the right information in the right place, in a way that
    will save time and hassle later. But don't become enslaved by a paper-chain bureaucracy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不是软件开发者生活中最迷人的部分，但规范是我们代码编写常规的重要组成部分。学会有效地阅读和编写它们——以记录正确信息在正确位置的方式，这样可以节省时间和麻烦。但不要成为官僚主义的奴隶。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的人…… | 不擅长编程的人…… |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand the importance of specifications and use them to make their development
    lives easier
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解规范的重要性，并使用它们来简化他们的开发生活
- en: Know the *appropriate* level of documentation required
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解所需的*适当*文档水平
- en: Want to improve their writing skills and seek reviews and chances to practice
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要提高他们的写作技巧并寻求反馈和练习的机会
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Dive headlong into a code task without a thought for design, documentation,
    or review
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有考虑设计、文档或审查的情况下，一头扎进代码任务中
- en: Don't think about the text they are writing; they produce unstructured, hard-to-follow
    specifications
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们不会考虑他们正在写的文本；他们产生的文档结构不清晰，难以理解
- en: Avoid writing documents, thinking it's boring and pointless
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免编写文档，认为它无聊且无意义
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](ch04.html "第四章. 写作技巧")'
- en: '*Self-documenting code* is a solid technique that helps to eliminate some code
    documentation. Good code is so easy and intuitive to work with that it doesn''t
    need a long manual.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*自文档代码*是一种有效的技术，有助于消除一些代码文档。好的代码易于使用且直观，不需要冗长的手册。'
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章. 安全源代码实践")'
- en: Consider change control and a backup strategy for your specifications—they're
    as vital as your code and need protecting.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑变更控制和备份策略，因为它们与你的代码一样重要，需要保护。
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章. 杀手级回顾")'
- en: Just like your code, any document you write should be reviewed to ensure that
    it's correct and of a high quality.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你的代码一样，你写的任何文档都应该经过审查，以确保其正确性和高质量。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章. 程序配方")'
- en: Specifications are an essential part of the software development process and
    are often the gates between development phases.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是软件开发过程中的一个基本部分，通常是开发阶段之间的关卡。
- en: '![See Also](tagoreillycom20080909nostarchimages207568.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207568.png)'
- en: Get Thinking
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 544.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的详细讨论可以在第544页的“[附录A](apa.html "附录A. 答案和讨论")”部分找到。
- en: Mull It Over
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: Is a poor specification better than no specification at all?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个糟糕的规范是否比没有规范要好？
- en: How detailed does a good specification have to be?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的规范需要有多详细？
- en: Is it important that all the documents in a company/project have a common presentation
    style?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公司/项目中的所有文档都拥有统一的呈现风格是否很重要？
- en: How should you store documents? Should you provide an index of them (by type
    or by project), for example?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何存储文档？例如，你应该提供它们的索引（按类型或按项目）吗？
- en: How should you conduct a specification review?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何进行规范审查？
- en: Does self-documenting code render all specifications useless? Specific ones?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自文档化的代码会使得所有规范都变得无用吗？具体是哪些？
- en: How can a document be collaborated on by more than one author?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何让多个作者协作编写文档？
- en: Getting Personal
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: Who decides on the contents of your documents?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁决定你文档的内容？
- en: 'Consider your current project. Do you have:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑你当前的项目。你是否有：
- en: A requirements specification?
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求规范？
- en: An architecture specification?
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 架构规范？
- en: A design specification?
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计规范？
- en: A functional specification?
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能规范？
- en: Any other specification?
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有其他规范吗？
- en: Are they up to date? Are they complete? Do you know how to get the latest versions?
    Can you access historical revisions?
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们是最新版本的吗？它们是完整的吗？你知道如何获取最新版本吗？你能访问历史修订版吗？
- en: Do you revision control your documents? If so, how?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你对文档进行版本控制吗？如果是，你是如何做的？
- en: Chapter 20. A REVIEW TO A KILL
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二十章. 杀死审查
- en: '*Performing Code Reviews*'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*执行代码审查*'
- en: 'Reviewing has one advantage over suicide: in suicide you take it out on yourself;
    in reviewing you take it out on other people.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 审查有一个比自杀更好的优势：在自杀中，你伤害了自己；在审查中，你伤害了其他人。
- en: --George Bernard Shaw
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ——乔治·萧伯纳
- en: How do you learn to be a good carpenter? You become a carpenter's apprentice.
    You watch the master work, help him daily, gradually take on more responsibility,
    and learn from his advice. You don't jump in feet first without any practical
    ability and expect to churn out quality woodwork right away.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你是如何学习成为一名优秀的木匠的？你成为了一名木匠的学徒。你观察大师的工作，每天帮助他，逐渐承担更多责任，并从他的建议中学习。你不会毫无实际能力地盲目跳入，并期望立即完成高质量的木工作品。
- en: We don't have a version of that in the coding world, even though programming
    is as much a craft as it is an engineering discipline (possibly more so). A good
    programmer learns the difference between good and bad code by experiencing it
    firsthand, discovering what works in Real Life and what doesn't. This is the stuff
    that books can't teach you, andonly a lucky few ever learn these things from a
    mentor. *Code reviews* are about as close as most of us will ever come to this
    ideal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码世界中，我们没有这样的版本，尽管编程既是一门手艺，也是一门工程学科（可能更多）。一个好的程序员通过亲身体验，发现哪些在现实生活中有效，哪些无效。这是书籍无法教给你的东西，而且只有少数幸运的人能从导师那里学到这些。*代码审查*几乎是我们大多数人能接近的理想。
- en: Code reviews (also called *inspections* or *walkthroughs*) are similar to the
    open source model of software development—providing a structured opportunity for
    others to eyeball your precious code and for you to inspect others' work. They
    facilitate knowledge interchange. But their primary goal is to increase software
    quality. They help you to spot faults before they become raging disasters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查（也称为*检查*或*走查*）类似于开源软件开发模式——为其他人提供一个结构化的机会来审视你宝贵的代码，以及让你检查他人的工作。它们促进了知识交流。但它们的主要目标是提高软件质量。它们帮助你在大灾难发生之前发现错误。
- en: 'Code reviews also have another subtle advantage: They encourage you to take
    greaterresponsibility for your handiwork. When you know that the code isn''t just
    for *you* to look at, but that it will be viewed, used, maintained, and criticized
    by others, your approach tends to change. You''re less likely to make the quick-and-dirty
    fix that you''ll never have time to revise. The accountability brought on by code
    reviews brings a greater quality to your coding. They help to establish the "[Collective
    Code Ownership](ch17s06.html#collective_code_ownership "Collective Code Ownership")"
    culture described in "[Collective Code Ownership](ch17s06.html#collective_code_ownership
    "Collective Code Ownership")" on page 336.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查还有另一个微妙的优势：它们鼓励你对自己的作品承担更大的责任。当你知道代码不仅仅是为了让你自己查看，而是会被其他人查看、使用、维护和批评时，你的态度往往会改变。你不太可能做出那种快速且草率的修复，因为你永远没有时间去修订。代码审查带来的责任感提高了你的编码质量。它们有助于建立第336页上描述的“[集体代码所有权](ch17s06.html#collective_code_ownership
    "集体代码所有权")”文化。
- en: Sound good, don't they? Let's pop the hood and see how they work. . . .
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错，不是吗？让我们揭开盖子看看它们是如何工作的……
- en: What Is a Code Review?
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是代码审查？
- en: A review places source code under the microscope—really aiming to criticize
    and verify it. This is not to ridicule or get at the author, but to improve the
    quality of software that the team produces. The process normally generates a list
    of must-fix issues (the size of the list is a reflection of the quality of your
    programming skills!). Sometimes you will spot improvements that are not worth
    making now; chalk up those discoveries for future experience.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 审查将源代码置于显微镜下——真正旨在批评和验证它。这并不是为了嘲笑或针对作者，而是为了提高团队生产的软件质量。这个过程通常会产生一个必须修复的问题列表（列表的大小反映了你的编程技能质量！）。有时你会注意到现在不值得做的改进；将这些发现归入未来的经验。
- en: 'We look for bugs and any code that could be improved. The code review weeds
    out problems at several levels:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们寻找错误以及任何可以改进的代码。代码审查在几个层面上排除问题：
- en: The overall design (we check the choice of algorithms and external interfaces).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体设计（我们检查算法和外部接口的选择）。
- en: The expression of that design in the code (its breakdown into classes andfunctions).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那种设计在代码中的表达（将其分解为类和函数）。
- en: The code in each semantic block (we check that each class, function, and loop
    is correct, follows appropriate language idioms, and is a practical implementation
    choice).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个语义块中的代码（我们检查每个类、函数和循环是否正确，是否遵循适当的语言习惯，以及是否是实际的选择）。
- en: Each individual code statement (each must follow project coding standardsand
    best practices).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个代码语句（每个都必须遵循项目编码标准和最佳实践）。
- en: 'Code reviews can be:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以是：
- en: '**Personal**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人**'
- en: The author carefully and methodically reviews his or her own work to makesure
    that it's good. Don't get this confused with casually reading your code after
    typingit; a personal code review is a more detailed and involved task.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 作者仔细而系统地审查自己的工作，以确保其质量。不要将这与其他随意阅读自己代码的行为混淆；个人代码审查是一个更详细和复杂的工作。
- en: '**One-on-one**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**一对一**'
- en: 'You walk another programmer through your code. The other programmer checks
    the logic and looks out for faults as you lead through it. These reviews tend
    to be informal, driven by the author. The code is therefore approached from the
    author''s perspective: with his or her set of assumptions, rather than from a
    more objective, outside view.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你带着另一位程序员走一遍你的代码。当你在引导过程中，这位程序员检查逻辑并寻找错误。这些审查往往是非正式的，由作者驱动。因此，代码是从作者的角度来处理的：基于他们的假设，而不是从更客观的外部视角。
- en: '**Formal**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**正式**'
- en: Involving other programmers brings new expertise, more experience, and more
    eyeballs to the task and shifts the perspective from which the review is run.
    Large-scale reviews are consequently harder to coordinate and require greater
    overall effort, but they are more likely to root out problems. It's difficult
    to delve this deeply in a personal review; often the author is too close to the
    code, and it's easy to overlook flaws.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及其他程序员会带来新的专业知识、更多经验和更多关注，从而改变审查的视角。因此，大规模的审查更难协调，需要更大的总体努力，但更有可能找出问题。在个人审查中深入挖掘是困难的；通常作者与代码过于接近，很容易忽略缺陷。
- en: 'This usually takes place in a formal meeting, but it can be run as a virtual
    review: online, with no physical meeting.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常发生在正式会议上，但也可以作为虚拟审查进行：在线上，没有物理会议。
- en: Each type of review can be used at a different time in the development process.
    One-to-ones might be used daily throughout code development, as an integration
    review before modifications are committed to the main source tree. Formal reviews
    are brought in toward the end of code development, as a final software quality
    audit.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中的不同时间可以使用不同类型的审查。一对一的审查可能在整个代码开发过程中每天使用，作为修改提交到主源树之前的集成审查。正式审查通常在代码开发的后期进行，作为最终的软件质量审计。
- en: Apart from the obvious benefits of correct code, reviews have other useful side
    effects. The cross fertilization that comes from looking at each other's code
    ensures that coding style is more uniform across a whole project. A review also
    spreads knowledge about the inner workings of core bits of code, so there is less
    risk of losing information when people leave a project (a very real problem—see
    "[Team Closure](ch17s07.html#team_closure "Team Closure")" on page 343).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正确的代码带来的明显好处外，审查还有其他有用的副作用。通过查看彼此的代码而产生的交叉授粉确保了整个项目中的编码风格更加统一。审查还传播了关于核心代码内部工作原理的知识，因此当人们离开项目时，信息丢失的风险更小（这是一个非常现实的问题——参见第343页的"[团队关闭](ch17s07.html#team_closure
    "Team Closure")"）。
- en: '**KEY CONCEPT**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Code reviews are excellent tools to detect and eliminate hard-to-find bugs,
    to increase code quality, to enforce collective code responsibility, and to spread
    knowledge*.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码审查是检测和消除难以发现的错误、提高代码质量、强制集体代码责任以及传播知识的优秀工具*。'
- en: When Do You Review?
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时进行审查？
- en: If you are not criticized, you may not be doing much.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有受到批评，你可能没有做多少。
- en: --Donald H. Rumsfeld
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: --唐纳德·H·拉姆斯菲尔德
- en: In an ideal world, every bit of code would be carefully reviewed prior to release.
    According to the Software Engineering Institute at Carnegie Mellon University,
    a thoroughcode review should take at least 50 percent or more of coding time (personal
    code review is included in this statistic). (Humphrey 98) That would take longer
    than most Real Worldprojects are prepared to invest.^([[1](#ftn.CHP-20-FN-1)])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，每一块代码在发布之前都应该被仔细审查。根据卡内基梅隆大学软件工程研究所的数据，彻底的代码审查应该至少占用50%或更多的编码时间（个人代码审查包含在这个统计数据中）。（Humphrey
    98）这将比大多数现实世界项目愿意投入的时间更长。（^[[1](#ftn.CHP-20-FN-1)])
- en: '**KEY CONCEPT**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*As we write a system, we need to ask* whether *to review the code and, if
    so, exactly* which *code to review*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们编写系统时，我们需要问*是否*要审查代码，如果是的话，*具体*要审查哪部分代码*。'
- en: '**REVIEWING THE ALTERNATIVES**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**审查替代方案**'
- en: 'There are a number of development techniques that have been argued to make
    formal code reviews redundant. These are:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开发技术被争论为使正式代码审查变得多余。这些包括：
- en: '**Pair programming**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**结对编程**'
- en: When you pair program (described in "[IT'S ALL GOING PAIR SHAPED](ch17s02.html#it_apostrophy_s_all_going_pair_shaped
    "IT'S ALL GOING PAIR SHAPED")" on page 319), your code is effectively reviewed
    on the fly. Two pairs of eyes are better than one and will find many, many more
    faults—as they are entered. However, code reviews cancatch even more problems
    by employing reviewers who are physically and emotionally removed from the implementation
    work.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在第319页描述的"[IT'S ALL GOING PAIR SHAPED](ch17s02.html#it_apostrophy_s_all_going_pair_shaped
    "IT'S ALL GOING PAIR SHAPED")"中进行结对编程时，你的代码实际上是在实时被审查的。双倍的眼睛比一双更好，并且会发现许多许多更多的错误——因为它们被输入。然而，通过采用与实现工作在物理和情感上分离的审查者，代码审查可以捕捉到更多的问题。
- en: '**Open source**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源**'
- en: Opening and freely releasing the source code allows anyone to see it, to judge
    the code's quality, and to fix problems. Some call this the ultimate code review.
    However, it doesn't actually guarantee that anyone *will* inspect the source.
    Only really popular open projects have actively maintained codebases. Making your
    code open source will not instantly bring code review–like benefits.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 开放和自由地发布源代码允许任何人查看它，判断代码的质量，并修复问题。有些人称之为终极代码审查。然而，这实际上并不能保证任何人*会*检查源代码。只有真正受欢迎的开源项目才有积极维护的代码库。使你的代码开源不会立即带来类似代码审查的好处。
- en: '**Unit tests**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: These are an automatic means to show that a modification hasn't degraded the
    *correctness* of your code's output (see "[Look! No Hands!](ch08s07.html "Look!
    No Hands!")" on page 144), but they don'thelp to increase the overall quality
    of the written code statements. Your code could be ajumbled mess of spaghetti,
    but if it passes the unit tests, no one will notice. If the unit tests aren't
    rigorous, bugs could still slip through, regardless.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是一种自动方式，表明修改没有降低你代码输出的*正确性*（参见第144页的"[Look! No Hands!](ch08s07.html "Look!
    No Hands!")"），但它们并不能帮助提高代码语句的整体质量。你的代码可能是一团糟的意大利面，但如果它通过了单元测试，没有人会注意到。如果单元测试不够严格，错误仍然可能通过，无论怎样。
- en: '**Not reviewing**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**不进行代码审查**'
- en: Alternatively, you can just trust the programmer to get it right—that's his
    job after all. If this is a winning strategy, then you don't need to test the
    code either. Good luck!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以只是相信程序员能够正确地完成工作——毕竟这是他的工作。如果这是一个有效的策略，那么你甚至不需要测试代码。祝你好运！
- en: None of these, on their own, can honestly replace the code review. Perhaps a
    combination of them and a particularly effective development team culture would
    render reviews less necessary, but I've yet to meet a team where that has been
    the case.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法本身都不能真正取代代码审查。也许将它们与特别有效的开发团队文化结合起来可以减少审查的必要性，但我还没有遇到过这样的情况。
- en: Whether to Review
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否进行代码审查
- en: 'We''ve seen that bugs are inevitable, and that you can be sure your code contains
    some classic mistakes. There will be obvious flaws that you''ll find quickly and
    many more subtle problems that would only be spotted by a fresh pair of eyes approaching
    the code with no preconceptions. It''s hard for the original author to see the
    inherent faults in hisown work—he''s too close to the codeface, suffering the
    psychological *cognitive dissonance* described in. (Weinberg 71) If your code
    is at all important (clue: it is, or you wouldn''t have written it) and if you
    care about its quality (clue: you do, or you''re a disgrace), then you *must*
    review it.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，错误是不可避免的，你可以确信你的代码中包含一些经典的错误。会有一些明显的缺陷你很快就能发现，还有许多更微妙的问题，只有一双没有先入为主的眼睛才能在审视代码时发现。原作者很难看到自己作品中的固有缺陷——因为他离代码太近，遭受着心理上的*认知失调*（参见Weinberg
    71）。如果你的代码有任何重要性（提示：它确实有，否则你不会写它），并且你关心其质量（提示：你确实关心，否则你就是一个耻辱），那么你*必须*进行代码审查。
- en: Not reviewing code drastically increases the chance of faults slipping into
    your production software. That could spell your embarrassment, a lot of expensive
    rework and in-the-field upgrades and, in extreme cases, your company's financial
    ruin. The effort of a code review pales in comparison to the consequences. According
    to Humphrey, "Students andengineers typically inject 1 to 3 defects per hour during
    design and 5 to 8 defects when writing code. They only remove about 2 to 4 defects
    per hour in testing but find 6 to 12 per hour during code review." (Humphrey 97)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行代码审查会大大增加错误滑入生产软件的机会。这可能会给你带来尴尬，大量的昂贵的返工和现场升级，在极端情况下，甚至可能导致你公司的财务崩溃。代码审查的努力与后果相比微不足道。根据Humphrey的说法，“学生在设计和编写代码时，每小时通常会注入1到3个缺陷，而在代码审查时每小时发现6到12个缺陷。”（Humphrey
    97）
- en: People often make excuses to justify avoiding reviews. They say, "The code's
    too large to review fully," or "It's too complex; no one person could ever understand
    it—there's no point in even *trying* to review it." If a project can muster enough
    man-hours to write a large program, it can find enough time to review it. If the
    code is too complex, then it desperately needs to be reviewed! In fact, it probably
    needs something a little more drastic. Well-written code is decomposed into self-contained
    sections that can undergo separate reviews.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常找借口来为避免审查辩护。他们说，“代码太大，无法全面审查，”或者“它太复杂；没有人能理解它——甚至尝试审查都没有意义。”如果一个项目能够调动足够的人时来编写一个大型程序，那么它也能找到足够的时间来审查它。如果代码太复杂，那么它迫切需要审查！实际上，它可能需要一些更彻底的措施。写得好的代码被分解成可以单独审查的自包含部分。
- en: Which Code to Review
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查哪些代码
- en: Any project will quickly produce a ton of source code. For all but the most
    stringent development processes, there simply isn't enough time to review every
    last scrap of code. So how do you decide which parts to review? That isn't easy.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目都会迅速产生大量的源代码。对于除了最严格的开发流程之外的所有情况，根本没有足够的时间来审查每一行代码。那么，你如何决定审查哪些部分呢？这并不容易。
- en: 'You must select the code that will benefit most from review. This is the code
    that is most likely to be bad or that is most important to the correct functioning
    of your system. You could try these strategies:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须选择将最能从审查中受益的代码。这是最有可能出现错误或对系统正确运行至关重要的代码。你可以尝试以下策略：
- en: Select core bits of code in the central components.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择核心组件中的核心代码片段。
- en: Run a profiler to see where most CPU time is spent, and review those parts of
    code.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行分析器以查看CPU时间花费最多的地方，并审查这些代码部分。
- en: Run compexity analysis tools, and review the worst offending code.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行复杂性分析工具，并审查最严重的违规代码。
- en: Target areas that have already exhibited a high bug count.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对已经显示出高错误数量的区域。
- en: Pick on code written by programmers you don't trust (a code review vendetta!).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你不太信任的程序员编写的代码（代码审查的复仇！）。
- en: The most practical approach is probably a hybrid of all of the above. Pick the
    bestcode candidates based on a sober assessment of your team, the codebase, and
    the current system characteristics (performance, bug count, etc.).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最实际的方法可能是上述所有方法的混合。根据你对团队、代码库和当前系统特征（性能、错误数量等）的清醒评估，选择最佳的代码候选者。
- en: '**KEY CONCEPT**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Select the code you review carefully. If you can''t review everything, make*
    informed *choices about review candidates. Don''t guess—you might waste your precious
    time*.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*仔细选择你将要审查的代码。如果你不能审查所有内容，就*明智地*选择审查候选者。不要猜测——你可能会浪费宝贵的时间*。'
- en: '* * *'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-20-FN-1)]) The fact that they're rarely prepared to invest any time
    in code review is a more serious problem.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-20-FN-1)]) 他们很少准备好在代码审查上投入任何时间，这是一个更严重的问题。
- en: Performing Code Reviews
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行代码审查
- en: That which we persist in doing becomes easier, not that the task itself has
    become easier, but that our ability to perform it has improved.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坚持不懈做的事情会变得更容易，不是任务本身变得更容易，而是我们执行它的能力提高了。
- en: --Ralph Waldo Emerson
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: --拉尔夫·瓦尔多·爱默生
- en: Simply *having* a code review is not enough. It's not going to solve all the
    problems itself. You also need to make sure that you review *properly*. The next
    few sections describe how to do this.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅*进行*代码审查是不够的。它本身并不能解决所有问题。你还需要确保你*正确地*进行审查。接下来的几节将描述如何做到这一点。
- en: Code Review Meetings
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查会议
- en: The most common review setting (at least in high-ceremony development processes)
    isthe formal *code review meeting*. There is a fixed agenda (to ensure that no
    action is forgotten) and a defined ending (not necessarily a time limit, but a
    definition of exactly which code you are reviewing, and which you aren't—it's
    very easy to be unclear about this).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的审查设置（至少在高仪式的开发过程中）是正式的*代码审查会议*。有一个固定的议程（以确保不会忘记任何行动）和明确的结束（不一定是时间限制，而是确切地定义你要审查哪些代码，哪些不要审查——对此可能很容易产生混淆）。
- en: An example code review meeting procedure is described below.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下面描述了一个示例代码审查会议程序。
- en: Where?
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在哪里？
- en: The best place to hold a code review meeting is in a quiet room. The reviewers
    should not be disturbed. There should be coffee (and, for those who must, tea)
    available.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 举行代码审查会议的最佳地点是在一个安静的房间里。审查者不应被打扰。应该有咖啡（以及那些必须喝的人的茶）。
- en: A suite of networked laptops with code editors may be useful, as may a computer
    hooked up to a projector. Old-school programmers swear by printouts and pen-and-paper
    notetaking—detaching from the computer screen can help to find new faults. This
    really depends on how much respect you have for trees and electricity consumption.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一套联网的笔记本电脑和代码编辑器可能很有用，连接到投影仪的计算机也可能有用。老式的程序员发誓使用打印稿和笔纸笔记——脱离电脑屏幕可以帮助找到新的错误。这完全取决于你对树木和电力消耗的尊重程度。
- en: When?
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时？
- en: Obviously, at a mutually convenient time. Common sense tells us that Friday
    at 5 PMis not a good time. You need to devote serious time to this, so make sure
    that you won't be disturbed or distracted.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在双方都方便的时间。常识告诉我们，周五下午5点不是一个好时间。你需要投入大量时间，所以请确保你不会被打扰或分心。
- en: If the code is too large, split the review into a number of separate sessions.
    You can't sit people in an enclosed space for hours on end and expect the quality
    of their review to remain high.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码太大，将审查分成几个单独的会议。你不能让人们连续几个小时坐在封闭的空间里，并期望他们的审查质量保持高水平。
- en: Roles and Responsibilities
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色和职责
- en: 'One of the most important factors contributing to the success of a code review
    meeting is who attends. Each attendee should be assigned a specific role; in small
    groups it is likely that people will take on multiple roles. These roles will
    include:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查会议成功的重要因素之一是参会人员。每位参会者应分配一个特定的角色；在小组中，人们可能会承担多个角色。这些角色包括：
- en: '**Author**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**作者**'
- en: Obviously the person who wrote the code should attend the review to describe
    what he or she has done, refute unfair or incorrect criticism, and listen to (and
    subsequently act on) valid, constructive feedback.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，编写代码的人应该参加审查，描述他们所做的工作，反驳不公平或不正确的批评，并听取（随后采取行动）有效的、建设性的反馈。
- en: '**Reviewers**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**审查员**'
- en: The reviewers should be carefully picked, people with available time and skill
    to review. It helps if the code is within their area of expertise or if they are
    involved with it in some way. For instance, the writer of a library should be
    invited to review a program that uses the library to diagnose incorrect API usage.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 应仔细挑选审查员，选择有可用时间和技能进行审查的人。如果代码在其专业领域内或以某种方式参与其中，这会有所帮助。例如，库的编写者应被邀请审查使用该库的程序，以诊断错误的API使用。
- en: There should be an appropriate number of experienced software engineers present.
    There should possibly be a representative from the QA or testing department (see
    "[QUALITY ASSURANCE](ch08.html#quality_assurance "QUALITY ASSURANCE")" on page
    132) so QA can be assured of the software's quality and of the quality of thedevelopment
    process.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 应有适当数量的经验丰富的软件工程师在场。可能需要QA或测试部门的代表（见第132页的"[QUALITY ASSURANCE](ch08.html#quality_assurance
    "QUALITY ASSURANCE")"），以确保软件的质量和开发过程的质量。
- en: '**Chairman**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**主席**'
- en: Any meeting needs a chairman, or chaos will ensue (see "[MEETING YOUR FATE](ch17s07.html#meeting_your_fate
    "MEETING YOUR FATE")" on page 340). This person leads the review and guides the
    discussion. He or she ensuresthat the conversation keeps to the point and that
    the meeting doesn't get sidetracked. Any minor issues that don't need to be discussed
    in the meeting should be quickly taken offline by the chairman. Given half a chance,
    programmers will discuss a minute technical detail for hours at the expense of
    the rest of the code review.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 任何会议都需要一个主席，否则将会陷入混乱（见第340页的"[MEETING YOUR FATE](ch17s07.html#meeting_your_fate
    "MEETING YOUR FATE")"）。这个人领导审查并指导讨论。他或她确保对话保持主题，会议不会偏离方向。任何不需要在会议中讨论的次要问题应由主席迅速线下处理。如果给程序员一半的机会，他们可能会讨论一个微小的技术细节数小时，而牺牲其他代码审查。
- en: '**Secretary**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**秘书**'
- en: The secretary takes minutes. This means writing down all points that arise,
    to make sure that nothing is forgotten after the review. If there is a review
    checklist (see the example on page 398), the secretary fills it in. The secretary
    role should notbe fulfilled by the same person who acts as chairman.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 秘书负责记录会议纪要。这意味着记录所有出现的要点，以确保在审查后不会遗漏任何内容。如果有审查清单（见第398页的示例），秘书需要填写它。秘书的角色不应由担任主席的同一个人来履行。
- en: Before arrival, everyone is expected to have familiarized themselves with the
    code. Everyone must have read the supporting documentation (any relevant specifications,
    etc.)^([[2](#ftn.CHP-20-FN-2)]) and must be aware of any project coding standards.
    Whoever organizes the meeting should highlight these documents in the meeting
    announcement to prevent misunderstanding.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达之前，每个人都应熟悉代码。每个人都必须阅读支持性文档（任何相关的规范等）^([[2](#ftn.CHP-20-FN-2)])，并且必须了解任何项目编码标准。组织会议的人应在会议通知中强调这些文档，以防止误解。
- en: Agenda
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会议议程
- en: 'To organize the code review meeting:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 组织代码审查会议：
- en: The author signals that their code is ready for review.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者表示他们的代码已准备好接受审查。
- en: The chairman arranges the meeting (booking an appropriate location, setting
    the time, and assembling the correct set of reviewers).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主席安排会议（预订合适的地点、设定时间，并召集正确的审查员团队）。
- en: All required resources (computers, a projector, printouts, etc.) are arranged.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排所有必需的资源（电脑、投影仪、打印件等）。
- en: The meeting must be called sufficiently ahead of time to allow the reviewers
    to prepare.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会议必须提前足够的时间召开，以便审查员做好准备。
- en: After the meeting announcement, the author cannot change the code gratuitously—this
    is not fair to the reviewers.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在会议通知后，作者不能随意更改代码——这对审查员来说是不公平的。
- en: 'The code review meeting is run as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查会议的流程如下：
- en: The chairman arranges for the room to be prepared beforehand so the review can
    start on time.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主席安排在会议前准备房间，以便审查能准时开始。
- en: The author takes a few minutes (no longer!) to explain the purpose of the code
    and a little bit about its structure. This should be prior knowledge, but it's
    surprising what misunderstandings can be caught at this first stage.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者花几分钟（不超过！）时间解释代码的目的以及其结构的一些内容。这应该是先验知识，但令人惊讶的是，在这个最初阶段可能会捕捉到许多误解。
- en: Structural design comments are invited. These are comments relating to the structure
    of the implementation—not the code at statement level. This could include the
    breakdown of functionality into classes, the split of code into files, and the
    style of function writing. (Is it sufficiently defensive, andare there good tests?)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构设计评论被邀请。这些评论与实现的结构有关——而不是代码语句级别。这可能包括将功能分解为类、将代码拆分为文件以及函数编写的风格。（是否足够防御性，是否有良好的测试？）
- en: General code comments are invited. These may relate to a consistent incorrect
    coding style, bad application of design patterns, or incorrect language idioms.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎一般性代码评论。这些评论可能涉及一致的错误编码风格、设计模式的错误应用或错误的语言习惯。
- en: The code is carefully stepped through in detail, a line or block at a time,
    to look for flaws. The things to look out for are described later (in "[Code Perfection](ch20s05.html
    "Code Perfection")" on page 395).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码被仔细地逐行或逐块审查，以寻找缺陷。要留意的事项将在稍后描述（在“[代码完美](ch20s05.html "Code Perfection")”第395页）。
- en: A number of example scenarios of code usage are considered, and the flow of
    control is investigated. If there is a complete suite of unit tests (there should
    be) then these detail all the scenarios to explore. This helps the reviewers cover
    all execution paths.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑了代码使用的多个示例场景，并调查了控制流。如果存在完整的单元测试套件（应该有），那么这些测试详细说明了要探索的所有场景。这有助于审查员覆盖所有执行路径。
- en: The secretary notes all changes required (recording the filename and line number).
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘书记录所有需要更改的内容（记录文件名和行号）。
- en: Any issue that might percolate out to the wider codebase is recorded for further
    investigation.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录可能渗透到更广泛代码库的任何问题，以便进一步调查。
- en: 'When the review has finished, a follow-up step should be agreed upon. The possible
    scenarios are:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当审查完成后，应商定一个后续步骤。可能的场景包括：
- en: '**Okay**'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**好的**'
- en: The code is fine, no further work is necessary.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码没有问题，不需要进一步的工作。
- en: '**Rework and verify**'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重做并验证**'
- en: The code needs some rework, but another code review meeting is unnecessary.
    The chairman nominates someone to act as *verifier*. When the rework is complete,
    the verifier checks it against the recorded minutes of the code review meeting.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码需要一些重做，但不需要另一次代码审查会议。主席提名某人担任*验证者*。重做完成后，验证者将检查它与代码审查会议记录的对比。
- en: A reasonable deadline should be imposed for any rework, so that the detail of
    and reasons for actions stay fresh in people's minds.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应为任何重做设定一个合理的截止日期，以便人们能够记住行动的细节和原因。
- en: '**Rework and re-review**'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重做并重新审查**'
- en: The code needs a lot of rework, and another code review is deemed necessary.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码需要大量重做，并且认为有必要进行另一次代码审查。
- en: Remember, the aim here is to identify problems, not to fix them during the meeting.
    Some problems require considerable thought to fix, and this is a job for the author
    (or modifier) after the review has finished.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里的目的是识别问题，而不是在会议期间修复它们。一些问题需要相当多的思考才能修复，这是审查结束后作者（或修改者）的工作。
- en: You may find it useful to use the code review checklist at the end of this chapter
    when conducting your reviews.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行审查时，您可能会发现使用本章末尾的代码审查清单很有用。
- en: Integration Reviews
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成审查
- en: Code review meetings are a high-ceremony review method. They're hard work, but
    theyundoubtedly find many problems that would otherwise go undetected.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查会议是一种高规格的审查方法。虽然工作量大，但无疑能发现许多否则可能被忽视的问题。
- en: Other, less intense review procedures exist, providing most of the benefits
    of codereview meetings but packaged in an easier-to-swallow pill. Perhaps the
    most effective is the *integration review*, performed whenever new code is integrated
    onto a mainline code branch.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着其他不那么强烈的审查程序，它们提供了代码审查会议的大部分好处，但以更容易接受的方式呈现。可能最有效的是*集成审查*，它在新代码集成到主线代码分支时进行。
- en: 'This could be when:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能发生在：
- en: A new piece of code *is about to be* checked into source control
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段新代码*即将*被检查到源代码控制中
- en: A new piece of code *has just been* checked into source control
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段新的代码刚刚被检查到源代码控制中
- en: A code package is merged from a feature development branch onto the main release
    branch
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码包从功能开发分支合并到主发布分支
- en: 'At such a point, the code in question is marked for review, and a suitable
    revieweris picked: either someone responsible for that module (the code integrator
    or maintainer^([[3](#ftn.CHP-20-FN-3)])) or a *shadow* (or *code buddy*) who is
    assignedto verify that author''s work in a one-on-one review session.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，相关的代码被标记为需要审查，并选择了一位合适的审稿人：要么是负责该模块的人（代码集成者或维护者^([[3](#ftn.CHP-20-FN-3)]))，要么是一个*影子*（或*代码伙伴*），被分配在一对一的审查会议中验证作者的工作。
- en: 'These gated code check-ins are often implemented with a software tool that
    is integrated with the source control system. They''re quite hard to arrange manually
    and are usually left as a check-in discipline: You are not supposed to check any
    code in until it hasbeen peer reviewed. This approach is quite hard to police;
    errors can slip past in hurried, last-minute check-ins.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这些门控代码检查通常使用与源代码控制系统集成的软件工具实现。手动安排它们相当困难，通常被作为检查纪律：你不应该在代码经过同行评审之前进行检查。这种方法很难执行；在匆忙的最后时刻检查中，错误可能会被忽略。
- en: The actual review step here is usually a lot less formal than the meetings described
    earlier. The reviewer scans the code to check that it isn't obviously broken,
    tests it (perhaps reviewing the available unit tests to ensure that they're valid),
    and then authorizes it for inclusion in the mainline. Only then will the code
    integrator migrate the verified code into the release tree. For more serious projects,
    or at more sensitive times ( just before a major release milestone, for example)
    this review step may become much more stringent—requiring more eyeballs and more
    effort.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的审查步骤通常比前面描述的会议要正式得多。审稿人扫描代码以检查它没有明显错误，测试它（可能审查可用的单元测试以确保它们有效），然后授权将其包含在主线中。只有在那时，代码集成者才会将经过验证的代码迁移到发布树中。对于更严肃的项目或在更敏感的时间（例如，在重大发布里程碑之前）这个审查步骤可能会变得更加严格——需要更多的眼睛和更多的努力。
- en: Since the reviewer and author don't need to actually meet face to face (although
    itis preferable to do so), this can be considered a form of virtual review process.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 由于审稿人和作者实际上不需要面对面地见面（尽管这样做是首选），这可以被认为是一种虚拟审稿过程。
- en: '* * *'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-20-FN-2)]) Naturally, all supporting documentation will have been
    thoroughly reviewed beforehand.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-20-FN-2)]) 自然，所有支持性文档在之前都已经被彻底审查过了。
- en: ^([[3](#CHP-20-FN-3)]) Compare this with an open source project's maintainer,
    who collates patches submitted by other hackers and integrates them into the main
    source tree, performing periodic software update releases.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-20-FN-3)]) 将其与开源项目的维护者进行比较，维护者收集其他黑客提交的补丁，并将它们集成到主源代码树中，定期发布软件更新。
- en: Review Your Attitudes
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审视你的态度
- en: Do to others as you would have them do to you.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以你希望别人对你做的事情去做。
- en: --Luke 6:31
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: --路加福音 6:31
- en: 'Code reviews require a constructive attitude—you need to approach a review
    with the correct mindset, or it will be unsuccessful. This works two ways: for
    the author and the reviewer.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查需要建设性的态度——你需要以正确的思维方式进行审查，否则将不会成功。这双向起作用：对作者和审稿人来说都是如此。
- en: The Author's Attitude
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者的态度
- en: Many people shy away from a code review for fear it will expose their inadequacies.
    Don't do this. Having your code reviewed is a good way to learn new techniques.
    You must be humble enough to admit that you're not perfect and are willing to
    accept criticism from others. Your coding style will improve as you learn from
    the changes made to your work.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人因为害怕代码审查会暴露他们的不足而回避它。不要这样做。让代码被审查是学习新技术的良好方式。你必须谦虚到承认自己并不完美，并愿意接受他人的批评。随着你从对工作的修改中学习，你的编码风格将会改进。
- en: '**METHOD IN OUR MADNESS**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**疯狂中的方法**'
- en: Code reviews are a universally acknowledged technique and have been around since
    people punched their programs into stacks of cards. We've looked at two review
    procedures in detail, but there are many subtle variants. Programming teams pick
    a review mechanism to suit their members and the nature of their work. (Poor teams
    perform no code review at all.)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是一种普遍认可的技术，自从人们将程序打孔到卡片堆中以来就已经存在了。我们已经详细探讨了两种审查程序，但还有许多细微的变体。编程团队选择一种审查机制来适应他们的成员和工作性质。（差的团队甚至不做代码审查。）
- en: 'Here are two other common review methods:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两种其他常见的审查方法：
- en: '**Fagan inspections**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fagan审查**'
- en: This is a well-respected process for formal reviews, much as described inthis
    chapter, defined by Michael Fagan in his *Defect Free Process*. (Fagan 76) Fagan
    emphasizes the importance of an ability to review and shows how to improve review
    skills. Fagan inspections identify problems both with the work product and with
    the process that created it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个备受推崇的正式审查流程，正如本章所述，由Michael Fagan在其《无缺陷流程》中定义。（Fagan 76）Fagan强调了审查能力的重要性，并展示了如何提高审查技能。Fagan审查识别了工作产品和创建该过程的问题。
- en: '**Shadowing**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**影子审查**'
- en: This is a a halfway house between pair programming and code reviews. Eachcode
    module has a *lead developer* who works on the code. A *shadow developer* is also
    assigned; periodically the shadow reviews the module with the lead. As design
    solidifies, the shadow developer verifies the decisions that are made. As the
    code fills out, the shadow reviews progress and offers constructive advice.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在结对编程和代码审查之间的一个中间地带。每个代码模块都有一个**主开发者**负责代码。还分配了一个**影子开发者**；定期地，影子开发者会与主开发者一起审查模块。随着设计的巩固，影子开发者会验证所做的决策。随着代码的完善，影子开发者会审查进度并提供建设性的建议。
- en: In more formal settings, the shadow is given authority to approve the code for
    release. No module can be integrated until the shadow developer agrees that it'sready
    for inclusion in the release build.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在更正式的场合，影子审查员被赋予批准代码发布的权限。没有任何模块可以在影子开发者同意它准备纳入发布构建之前被集成。
- en: '**KEY CONCEPT**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*No one''s code is above review and peer scrutiny. Actively invite review of
    your code*.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有人的代码是免于审查和同行审查的。积极邀请对你的代码进行审查**。'
- en: 'As an author, do not be defensive about your code. There is a natural tendency
    to take all criticism personally and assume that it''s an assault on your abilities.
    To cope with a code review, you need to reduce ego and personal pride. Understand
    that no one writes perfect code: Even the most awesome programmer''s code will
    be criticized for tedious little problems in a code review.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 作为作者，不要对你的代码进行防御。有一种自然的倾向是将所有的批评都视为针对个人的，并认为这是对你能力的攻击。为了应对代码审查，你需要减少自我和个人的骄傲。理解没有人的代码是完美的：即使是最好的程序员的代码在代码审查中也会因为一些繁琐的小问题而受到批评。
- en: 'This is *egoless programming*, described by Gerald M. Weinberg in his 1971
    book *The Psychology of Computer Programming*: a timeless description of the critical
    attitude that makes reviews work. (Weinberg 71) Programmers who aren''t afraid
    of bugs in their code or of others finding those bugs will generate better, safer,
    more correct software. A willingness for others to help find faults in your work
    is an essential attribute of the master programmer.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指由Gerald M. Weinberg在1971年的著作《计算机编程心理学》中描述的**无我编程**：这是一个永恒的描述，它揭示了使审查工作有效的关键态度。（Weinberg
    71）那些不害怕自己代码中的错误或他人发现这些错误的程序员将能够生成更好、更安全、更正确的软件。愿意让他人帮助找出你工作中的错误是高级程序员的一个基本属性。
- en: When you're in the hotseat, try not to waste other people's time. Before you
    present your code for review, run a dummy review by yourself first. Imagine you're
    presenting your work to the others. You'll be surprised by how many little flaws
    you'll filter out, and it will help you to be more confident in the real review.
    Don't rush out half-baked code and expect others to review the flaws away for
    you.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处于热点位置时，尽量不要浪费他人的时间。在你将代码提交审查之前，先自己进行一次模拟审查。想象你正在向其他人展示你的工作。你会惊讶于你将过滤出多少小缺陷，这将帮助你更有信心地进行真正的审查。不要匆忙提交半成品代码，并期望他人帮你审查缺陷。
- en: The Reviewer's Attitude
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查者的态度
- en: When reviewing code and making criticism, you must be sensitive. Comments must
    always be constructive and not intended to lay blame. Do not launch personal attacks
    on the author. Diplomacy and tact are important. Address your comments to the
    code, rather than the coder; prefer to say *The code does this* . . . rather than
    *You always do this*. . . .
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查代码和提出批评时，你必须敏感。评论必须始终是建设性的，而不是为了归咎。不要对作者进行人身攻击。外交和策略很重要。将你的评论针对代码，而不是程序员；更愿意说“代码这样做……”……而不是“你总是这样做……”……。
- en: 'Code review is a *peer process*: Every reviewer is considered equal. Seniority
    doesn''t matter, and all views are considered. It is interesting that even the
    least experienced programmer will have something worth mentioning in a code review.
    And just as the author learns from the review, so may a reviewer.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是一个**同行过程**：每个审查者都被视为平等。资历并不重要，所有观点都被考虑。有趣的是，即使是经验最少的程序员在代码审查中也会有一些值得提及的内容。正如作者可以从审查中学习一样，审查者也可以。
- en: Over time, you will perform many, many reviews (especially if you perform integration
    reviews). Be careful that your review process doesn't become a mundane chore;
    it'll soon be an ineffective waste of everyone's time. Maintain a positive approach
    to your code reviewing. As a reviewer, always try to have something useful to
    say at each review. Sometimes this is easy; sometimes it is very difficult to
    say anything interesting. But by forcing yourself to make comments, you won't
    fall into the easy review rut, becoming a yes man who adds nothing to the process.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你将进行许多、许多次审查（特别是如果你进行集成审查）。小心你的审查过程不要变成一项枯燥的任务；很快它就会变成一个无效的浪费时间的行为。保持对代码审查的积极态度。作为审查员，在每次审查中都要尽力提出有用的意见。有时这很容易；有时很难说出有趣的话。但通过强迫自己做出评论，你不会陷入简单的审查套路，成为一个对过程毫无贡献的应声虫。
- en: '**KEY CONCEPT**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The success of a code review depends heavily on the author and reviewers adopting
    a positive attitude. The aim of a review is to collaboratively improve the code,
    not to apportion blame or to justify implementation decisions*.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码审查的成功在很大程度上取决于作者和审查员采取积极的态度。审查的目的是共同改进代码，而不是分摊责任或证明实现决策的合理性*。'
- en: Code Perfection
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码完美
- en: When perfection comes, the imperfect disappears.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当完美到来时，不完美就会消失。
- en: --1 Corinthians 13:10
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: --哥林多前书 13:10
- en: 'We haven''t yet considered what type of code will pass review and what code
    will fail. It''s beyond the scope of this chapter to describe what good code looks
    like—the first 15 chapters of this book describe important aspects of high-quality
    code. As we look for bad code design and hunt software bugs, there are a few recurring
    themes. The reviewed code must be:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有考虑哪种类型的代码会通过审查，哪种代码会失败。描述良好代码的外观超出了本章的范围——本书的前15章描述了高质量代码的重要方面。当我们寻找不良代码设计和寻找软件错误时，有一些反复出现的主旨。审查的代码必须：
- en: '**Bug free**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**无错误**'
- en: Bugs are our enemy, the nemesis of good software development. We must be confident
    about the quality of our work and need to find faults as early as possible in
    the development process. The earlier we try to find problems, the more we are
    likely to find and fix and the less cost and hassle they incur (see "[THE ECONOMICS
    OF FAILURE](ch09s02.html#the_economics_of_failure "THE ECONOMICS OF FAILURE")"
    on page 157).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是我们的大敌，是良好软件开发的天敌。我们必须对我们的工作质量有信心，并需要在开发过程中尽早找出错误。我们越早尝试找出问题，就越有可能找到并修复，从而减少成本和麻烦（参见第157页的“[失败的经济学](ch09s02.html#the_economics_of_failure
    "失败的经济学")”）。
- en: '**Correct**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确**'
- en: The code must meet all relevant standards and its requirements. Ensure that
    all variables are of the correct type (e.g., there is no chance of numeric overflow).
    Comments must be completely accurate. The code must meet any memory size or performance
    requirements (especially important for embedded platforms). Check that there is
    appropriate use of libraries and that all function parameters are correct.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须满足所有相关标准和其要求。确保所有变量都是正确的类型（例如，没有数值溢出的可能性）。注释必须完全准确。代码必须满足任何内存大小或性能要求（特别是对于嵌入式平台尤为重要）。检查库的使用是否适当，以及所有函数参数是否正确。
- en: The code is validated to conform with its requirements and functional specifications.
    The content of its specification is taken to be correct; if it wasn't, then the
    task would be herculean! Sometimes code review comments might feed up to the specification
    (for example, where clarification is needed), but this is not our goal at code
    review—don't get sidetracked into discussions on whether the specification is
    wrong; the secretary should record the issue in the minutes, and the review should
    continue.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 代码经过验证，符合其要求和功能规范。其规范的内容被认为是正确的；如果不是这样，那么这项任务将是艰巨的！有时代码审查的评论可能会反馈到规范中（例如，需要澄清的地方），但这不是我们的目标——在代码审查中不要偏离讨论规范是否错误的话题；秘书应在会议记录中记录问题，审查应继续进行。
- en: '**Complete**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整**'
- en: The code must implement the entire functional specification. It must have been
    integrated and debugged satisfactorily and pass all test suites. The test suites
    must be comprehensive.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须实现整个功能规范。它必须经过满意地集成和调试，并通过所有测试套件。测试套件必须全面。
- en: '**Well structured**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构良好**'
- en: Check that the implementation's design is sound, that the code is easy tounderstand,
    and that there is no duplication or redundant code. Look for any obvious *cut-and-paste
    programming*, for example.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 检查实现的设计是否合理，代码是否易于理解，以及是否存在重复或冗余代码。寻找任何明显的“剪切和粘贴”编程，例如。
- en: '**Predictable**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**可预测**'
- en: There must be no unnecessary complexity and no unexpected surprises. The code
    should not be self-modifying, must not rely on magic default values, and must
    not contain the subtle chance of infinite loops or recursion.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 必须没有不必要的复杂性，也没有意外的惊喜。代码不应该自我修改，不得依赖于魔法默认值，并且不得包含可能导致无限循环或递归的微妙机会。
- en: '**Robust**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**健壮**'
- en: The code is defensive. Wherever possible, it protects against detectable run-time
    errors (divide by zero, number-out-of-range errors, etc.). All input should be
    checked (both function parameters and program input). The code handles all error
    conditions and is exception safe. All appropriate signals are caught.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 代码具有防御性。尽可能保护可检测的运行时错误（除以零、数值越界错误等）。所有输入都应该进行检查（包括函数参数和程序输入）。代码处理所有错误条件，并且是异常安全的。所有适当的信号都被捕获。
- en: '**Data checking**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据检查**'
- en: Bounds checking is performed on C-style array access. Other similarly insidious
    data access errors are avoided. Multithreaded code has correct use of mutexes
    to prevent race conditions and deadlock. The return values of *all* system/library
    calls are checked.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在C风格数组访问时执行边界检查。避免其他类似隐秘的数据访问错误。多线程代码正确使用互斥锁以防止竞争条件和死锁。检查所有系统/库调用的返回值。
- en: '**Maintainable**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**可维护**'
- en: The programmer has been wise in his or her use of comments. The code is kept
    under correct revision control. There is appropriate configuration information.
    The code formatting meets house standard. It compiles quietly, without spurious
    warnings.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在注释的使用上很明智。代码处于正确的版本控制之下。存在适当的配置信息。代码格式符合内部标准。编译时安静无声，没有虚假的警告。
- en: '**KEY CONCEPT**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*If you don''t know what good code looks like, then you can''t make a valid
    judgment of other people''s work*.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不知道好代码是什么样的，那么你就无法对别人的工作做出有效的判断*。'
- en: Beyond the Code Review
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查之外
- en: A review process is key to the production of any high-quality item, so it is
    not solely useful for source code development. A similar review process is used
    for specification documents, lists of requirements, and so on.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 审查过程对于生产任何高质量的项目至关重要，因此它不仅仅对源代码开发有用。类似的审查过程用于规范文档、需求列表等。
- en: In a Nutshell
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: It is easier to be critical than to be correct.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 批评比正确更简单。
- en: --Benjamin Disraeli
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: --本杰明·迪斯雷利
- en: Code reviews are an essential part of the software development process and help
    us to maintain a high quality of code. Just as an apprentice learns a trade from
    knowledge passed on, code reviews spread knowledge and teach coding capability.
    As more of a peer-to-peer than master-apprentice activity, they provide a learning
    opportunity for author andreviewer alike.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是软件开发过程中的一个重要部分，有助于我们保持代码的高质量。正如学徒从传授的知识中学习一门手艺一样，代码审查传播知识并教授编码能力。作为一种更侧重于同行之间的活动，它们为作者和审查者提供了学习的机会。
- en: Write your code to be reviewed. Remember that it's never just for you to read;
    other people must be able to maintain it as well. The author is always accountable
    for the quality of his or her work. A good programmer cares more about crafting
    great code than hisor her own pride.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以便进行审查。记住，这不仅仅是为了你自己阅读；其他人也必须能够维护它。作者对其工作的质量始终负责。一个好的程序员更关心编写优秀的代码，而不是自己的骄傲。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 优秀的程序员 . . . | 次等的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Desire code reviews and are confident in their code quality
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要代码审查并且对自己的代码质量有信心
- en: Accept others' opinions and learn from them
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受他人的意见并从中学习
- en: Can sensitively and accurately comment on other people's code
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够敏感且准确地评论他人的代码
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Are scared of code reviews and frightened of others' opinions
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 害怕代码审查，害怕他人的意见
- en: Take criticism badly; they are defensive and easily offended
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对批评反应不佳；他们具有防御性且容易受到冒犯
- en: Use reviews to demonstrate their superiority over lesser abled coders; their
    comments are unduly harsh and unconstructive
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用审查来展示他们相对于能力较弱的程序员的优势；他们的评论过于严厉且缺乏建设性
- en: '|'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看这里
- en: '**[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE") through [Chapter 15](ch15.html
    "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第1章](ch01.html "第1章。防御")至[第15章](ch15.html "第15章。软件进化或软件革命？")**'
- en: Each of the opening chapters of this book describes important aspects of good
    code.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章描述了良好代码的重要方面。
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。寻找错误")'
- en: A description of the types of bugs that may exist in your code.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对你代码中可能存在的错误类型的描述。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: Code is reviewed against its *specification*. The specification also requires
    careful reviewing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将与它的*规范*进行审阅。规范还要求进行仔细的审阅。
- en: '![See Also](tagoreillycom20080909nostarchimages207570.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207570.png)'
- en: Checklist
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单
- en: Many review processes involve a *checklist*—a set of characteristics of good
    (passable) code to check off as you go along. If your code doesn't meet these
    criteria, then it has failed the review. These checklists vary in detail, length,
    and subject matter.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 许多审阅过程涉及一个*清单*——在审阅过程中检查良好（可接受）代码特性的集合。如果你的代码不符合这些标准，那么它就没有通过审阅。这些清单在细节、长度和主题上有所不同。
- en: The following code review checklist is an example. You can use it to help direct
    your review work. Unlike some checklists, it doesn't systematically list every
    potential problem in every possible language; it just helps to guide the review
    process and figure out when to continue to the next review step.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码审阅清单是一个示例。你可以用它来帮助你指导审阅工作。与一些清单不同，它并没有系统地列出每种可能语言中每个可能的问题；它只是帮助指导审阅过程并确定何时继续到下一个审阅步骤。
- en: '![Checklist](tagoreillycom20080909nostarchimages207572.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![清单](tagoreillycom20080909nostarchimages207572.png)'
- en: Get Thinking
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开动脑筋
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 547.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的详细讨论可以在第547页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: Does the required number of reviewers depend on the size of the code being reviewed?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要的审阅者数量是否取决于被审阅的代码大小？
- en: Which tools are useful aids for code reviewing?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些工具对代码审阅有帮助？
- en: Should you perform a code review before or after running it through source code
    checking tools?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在运行源代码检查工具之前还是之后进行代码审阅？
- en: What preparation is required for a code review meeting?
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码审阅会议需要哪些准备工作？
- en: How do you differentiate review comments to be acted upon immediately from those
    to chalk up for experience on the next project?
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何区分需要立即采取行动的审阅评论和那些可以在下一个项目中积累经验的评论？
- en: How do you run a virtual review meeting?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何进行虚拟审阅会议？
- en: How useful are informal code reviews?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非正式代码审阅有多有用？
- en: Getting Personal
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: Does your project perform code reviews? Does it perform *enough* code reviews?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的项目进行代码审阅吗？它进行*足够的*代码审阅吗？
- en: Do you work with any programmers whose code is considered to be above review?
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否与任何被认为代码无需审阅的程序员合作？
- en: What percentage of your code has ever been subject to code review?
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码中有多少百分比曾经接受过代码审阅？
- en: Chapter 21. HOW LONG IS A PIECE OF STRING?
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。一根绳子有多长？
- en: '*The Black Art of Software Timescale Estimation*'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*软件时间尺度估计的黑魔法*'
- en: I never guess. It is a shocking habit—destructive to the logical faculty.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我从不猜测。这是一个令人震惊的习惯——对逻辑能力具有破坏性。
- en: --Sherlock Holmes (Sir Arthur Conan Doyle)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: --夏洛克·福尔摩斯（亚瑟·柯南·道尔爵士）
- en: How long *is* a piece of string? Or for our purposes, how long does a piece
    of string take? It's as simple a question to answer, and it makes about as much
    sense.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 一根绳子有多长？或者，就我们的目的而言，一根绳子需要多长时间？这是一个简单的问题，但它并没有多少意义。
- en: This chapter is about *software timescale estimation*, an important skill of
    the professional programmer. It's one of the mystical black arts of development,
    based more on hunches than science, with frequently inaccurate results. It's complicated,
    but an essential part of the software development process, and is something that
    every programmer must learn to do.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是*软件时间尺度估计*，这是专业程序员的重要技能。它是开发中的神秘黑魔法之一，更多地基于直觉而非科学，结果往往不准确。它很复杂，但软件开发过程中的一个基本部分，是每个程序员都必须学会做的事情。
- en: 'The rules of the software factory are necessarily governed by economics: the
    flow of money. Timing estimates are important, since the bulk of the cost of software
    development is manpower—programmers aren''t cheap. Development environments and
    hardware costs pale into insignificance. To make a software product, we must know
    how much work is involved, how many people are required to build it, and when
    it will be completed and ready to make money. This tells us how much construction
    will cost. The marketing department will predict how much it will make in sales.
    These two predictions go head-to-head in a dramatic fight to the death; the bean
    counters draw up budgets to work out whether a project is financially viable.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工厂的规则必然受经济学的支配：资金的流动。时间估计很重要，因为软件开发的大部分成本是人力——程序员并不便宜。开发环境和硬件成本微不足道。为了制作一个软件产品，我们必须知道涉及的工作量，需要多少人去构建它，以及何时完成并准备好盈利。这告诉我们建设成本是多少。市场营销部门将预测销售收益。这两个预测将进行一场戏剧性的生死之战；财务分析师制定预算来评估项目是否具有财务可行性。
- en: 'This is an odd thing called *planning*, something at which most programmers
    don''t excel. Don''t worry: That''s why we have managers. But you have to understand
    the rules of the game if you really want to play well. Writing commercially successful
    software requires a huge amount of foresight and planning. Oh, and nerves of steel.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件奇怪的事情，叫做“规划”，大多数程序员都不擅长。别担心：这就是为什么我们有经理。但如果你真的想玩得很好，你必须了解游戏规则。编写商业上成功的软件需要大量的预见性和规划。哦，还有钢铁般的神经。
- en: To construct a development plan, we perform a high-level design of the software
    system, break it into components, and estimate how long each component will take
    to write. There's rarely enough time to seriously scope and design each one, so
    this is a very rough science. Choosing a software development model (see "[Development
    Processes](ch22s03.html "Development Processes")" on page 425), we assemble the
    estimates on a plan, spread across a number of programmers, and use this to work
    out the economics. The quality of this plan is clearly founded on the quality
    of the timescale estimates. Catastrophically bad guesses could spell financial
    ruin, so it's important stuff!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个开发计划，我们进行软件系统的高级设计，将其分解为组件，并估计每个组件编写所需的时间。很少有足够的时间来认真规划和设计每一个，所以这是一个非常粗略的科学。选择一个软件开发模型（参见第425页的“[开发过程](ch22s03.html
    "Development Processes")”），我们将估计汇总到一个计划中，分配给多个程序员，并使用这个计划来计算经济性。这个计划的质量显然基于时间估计的质量。灾难性的错误猜测可能导致财务灾难，所以这是一件重要的事情！
- en: Without plans, you're creating products by luck, not on purpose. Estimation
    is an integral part of the project planning process—but that doesn't mean that
    it's done by the project planners! The only people able to provide timescale information
    are the programmers who have to do the work. That's you! This is part of the commercial
    reality of life in the software factory.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 没有计划，你是在靠运气创造产品，而不是有目的地。估计是项目规划过程的一个组成部分——但这并不意味着它是项目规划者完成的！能够提供时间尺度信息的人是必须完成工作的程序员。那就是你！这是软件工厂生活中的商业现实的一部分。
- en: A Stab in the Dark
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑暗中的一次刺杀
- en: 'In any company, on any project, at any point in time, software timescale estimates
    are nothing more than educated guesses—or else they wouldn''t be estimates. Guesswork
    doesn''t sound very professional, does it? But it''s the best you can do: You''ll
    never know exactly how long a task will take until it''s complete, when it''s
    generally too late for the information to be useful.^([[1](#ftn.CHP-21-FN-1)])'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何公司，任何项目，任何时间点，软件时间尺度估计不过是基于教育的猜测——否则它们就不是估计了。猜测听起来并不太专业，对吧？但这是你能做的最好的：直到任务完成，你永远不会确切知道它需要多长时间，那时通常为时已晚，信息已经没有用了。[^([1](#ftn.CHP-21-FN-1))]
- en: The quality of an estimate is primarily determined by how well you understand
    the task being estimated. That is, how well you *really* understand it, not how
    well you *think* you do. It also depends on how much time you have to create the
    estimate, and therefore how much effort you can put into a realistic design effort
    or feasibility review. With a very precise specification, you can make an estimate
    in a short time; with a vague specification, it could take ages. A reasonable,
    justified estimate might require several prototypes to investigate implementation
    choices—different options could have radically different time consequences and
    levels of inherent risk.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 估计的质量主要取决于你对被估计任务的了解程度。也就是说，你*真正*了解的程度，而不是你认为你了解的程度。这也取决于你有多少时间来创建估计，因此你可以在现实设计努力或可行性审查中投入多少努力。有了非常精确的规范，你可以在短时间内做出估计；有了模糊的规范，可能需要很长时间。一个合理、有根据的估计可能需要几个原型来调查实施选择——不同的选项可能会有截然不同的时间后果和固有的风险水平。
- en: Without enough time to do this, you need to concoct a worst-case figure that
    development should not exceed. The less effort you put into a timescale estimate,
    the less the confidence you may have in the figure, and the greater the likely
    variance of reality from the estimate. Development could take half of the estimate,
    the full period or—even worse—could require more time. We manage this risk by
    building *contingency* into the development plan to balance risky areas. How much
    contingency do you provide? You have to guess! We'll look at this later.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的时间来做这件事，你需要制定一个最坏情况的数字，开发工作不应超过这个数字。你投入的时间尺度估计的努力越少，你对这个数字的信心就越少，现实与估计之间的差异就越大。开发可能需要估计的一半时间，整个期限，甚至更糟——可能需要更多的时间。我们通过在开发计划中构建*应急计划*来管理这种风险，以平衡风险区域。你提供多少应急计划？你必须猜测！我们稍后会讨论这个问题。
- en: '**KEY CONCEPT**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Software timescale estimation requires* educated guesswork. *Each estimate
    should come with a gauge of your confidence in it*.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件时间尺度估计需要*有根据的猜测。*每个估计都应该伴随着你对它的信心度量*。'
- en: While good estimates are reasoned and justified, bad estimates are little more
    than a stab in the dark. This is a standard engineering issue, requiring a perceptive
    and flexible management. It has been an engineering issue for centuries.^([[2](#ftn.CHP-21-FN-2)])
    Managers and planners deal with estimations for the whole project. That's *exceptionally*
    hard. We'll just look at estimating single programming jobs. Thankfully, that's
    not exceptionally hard, just *really* hard.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然好的估计是有理有据的，但糟糕的估计不过是黑暗中的一击。这是一个标准的工程问题，需要敏锐和灵活的管理。这已经是一个持续了数百年的工程问题。[2](#ftn.CHP-21-FN-2)
    经理和规划者处理整个项目的估计。这*特别*困难。我们只看看估计单个编程工作。幸运的是，这并不特别困难，只是*真的*困难。
- en: '* * *'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-21-FN-1)]) Except, of course, as experience to base future estimates
    on.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-21-FN-1)]) 当然，除了作为基于未来估计的经验之外。
- en: ^([[2](#CHP-21-FN-2)]) For a Biblical example, see Luke 14:28!
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-21-FN-2)]) 对于一个圣经上的例子，请参阅路加福音第14章第28节！
- en: Why Is Estimation So Hard?
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么估计如此困难？
- en: 'I live in Cambridge, UK; my family lives in Bristol. Software timescale estimation
    is like estimating how long it will take me to visit them. Given a strong tailwind
    and no traffic, I can tell you how long the drive takes. But if there is road
    work or a traffic jam, if my car breaks down, I leave late, or I travel at rush
    hour, then this estimate becomes a lot less reliable. Foreseeing some of these
    problems, I will commit to a likely arrival window. I know the best-case journey
    time; I have an idea of the worst case (I''ve had some nightmare trips). I can
    judge an expected arrival time somewhere between the two. However, I can''t ever
    fully account for the unforeseen—if my car breaks down, I''m stuck. Mobile phones
    are helpful in this situation: If I''m going to be late, I can call and let my
    folks know to keep dinner heated (and preferably out of the dog''s bowl).'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我住在英国剑桥；我的家人住在布里斯托尔。软件时间尺度估计就像估计我拜访他们需要多长时间一样。如果有一个强风和没有交通，我可以告诉你开车需要多长时间。但是如果有道路施工或交通堵塞，如果我的车坏了，我出发晚了，或者我在高峰时段旅行，那么这个估计就变得不太可靠了。预见一些这些问题，我会承诺一个可能的到达时间窗口。我知道最佳行程时间；我对最坏情况有一个想法（我有过一些噩梦般的旅行）。我可以在两者之间判断一个预期的到达时间。然而，我永远无法完全考虑到不可预见的情况——如果我的车坏了，我就被困住了。在这种情况下，手机很有帮助：如果我会迟到，我可以打电话告诉我的家人把饭加热（最好是不要放在狗的碗里）。
- en: The software development process follows a similar pattern. When planning software,
    there are foreseeable potential problems to account for, third-party dependencies
    to manage, and a need for contingency to cope with the unforeseen. You can give
    a best-case development time for a slice of work, and you need to consider a worst-case
    time. Of course, the impact of a bad guess isn't just your dinner inside the family
    pet—it's the success or failure of a project, and possibly the solvency of your
    company.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发过程遵循类似的模式。在规划软件时，需要考虑到可预见的潜在问题，管理第三方依赖，以及应对不可预见情况的需要。你可以为工作的一部分给出最佳情况下的开发时间，并需要考虑最坏情况的时间。当然，错误估计的影响不仅仅是家庭宠物的晚餐——它关系到项目的成功或失败，甚至可能影响你公司的偿付能力。
- en: '**THE WEAKEST LINK**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**最薄弱的环节**'
- en: Unforeseen problems can trip you up in unexpected places. Recently, my linker
    couldn't cope with the size of executable image I was generating, and I needed
    to go off and fix the linker before I could run my code. The development time
    more than tripled its original estimate.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 不可预见的问题可能会在意想不到的地方让你陷入困境。最近，我的链接器无法处理我生成的可执行映像的大小，我需要离开去修复链接器，才能运行我的代码。开发时间超过了最初估计的三倍。
- en: 'This begins to show us why estimating the length of a development task is so
    hard and so crucial. There are plenty of things conspiring to make this a tricky
    task:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始让我们看到为什么估计开发任务的长度是如此困难且至关重要。有许多因素在共同作用，使得这项任务变得棘手：
- en: There are lots of variables to consider. They come with the inherent complexity
    of the problem, the implications of your code design, and the existing software
    ecosystem it must fit into. Some of those variables may change from day to day.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多变量需要考虑。它们伴随着问题的固有复杂性、你的代码设计的影响以及必须适应的现有软件生态系统。其中一些变量可能每天都会发生变化。
- en: Requirements will change under your feet, leading to software scope increases.
    As the feasibility of a project is investigated, new problems and user-level requirements
    are unearthed at a phenomenal rate. This makes the estimation job tricky—you've
    got to work hard to keep up with it all (see "[Requirements Specification](ch19s02.html#requirements_specification
    "Requirements Specification")" on page 371 for strategies to manage this).
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求会在你脚下发生变化，导致软件范围扩大。随着项目可行性的调查，新的问题和用户级需求以惊人的速度被挖掘出来。这使得估计工作变得复杂——你必须努力跟上这一切（参见第371页的"[需求规范](ch19s02.html#requirements_specification
    "需求规范")"，了解如何管理这些策略）。
- en: You can't give an accurate estimate without knowing *all* the work involved.
    Perhaps you'll need to rework existing libraries that don't provide enough functionality
    or refactor to enable safe extension of existing code. If you haven't discovered
    this, then your estimate will be too low.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不知道所有涉及的工作，你无法给出准确的估计。也许你需要重构现有库，因为它们提供的功能不足，或者重构以实现现有代码的安全扩展。如果你还没有发现这一点，那么你的估计将会太低。
- en: Few projects start on a blank canvas. You must learn the existing system before
    you can estimate how long work will take. You seldom have time to do this properly
    before the estimate is delivered.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少有项目是从一张白纸开始的。在估计工作需要多长时间之前，你必须了解现有系统。在提交估计之前，你很少有时间正确地完成这项工作。
- en: If the task is something that has not been attempted before, then it is harder
    to figure how long it will take. You have no prior experience to base the estimate
    on.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这项任务是一项以前从未尝试过的事情，那么确定它需要多长时间会更困难。你没有先前的经验可以据此进行估计。
- en: Many projects rely on third parties, and these dependencies can prove to be
    nightmarish. The source of the dependency could be an operating system vendor,
    a small but significant code library, an external specification, even the customer.
    You can't control the third-party delivery; your estimates depend on it shipping
    on time. This increases the risk of delay and must be monitored carefully.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多项目依赖于第三方，而这些依赖关系可能会变得非常糟糕。依赖关系的来源可能是操作系统供应商、一个小但重要的代码库、外部规范，甚至是客户。你无法控制第三方交付；你的估计依赖于它按时交付。这增加了延迟的风险，必须仔细监控。
- en: 'Estimation is hard. But that doesn''t absolve us from responsibility. We must
    account for the things that are genuinely foreseeable: Like road work or bad weather,
    we can reasonably expect some of these pitfalls. You need to find the right balance
    of pessimism, optimism, and—somewhere in the middle—realism.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 估计是困难的。但这并不能免除我们的责任。我们必须考虑到真正可预见的事情：就像道路施工或恶劣天气一样，我们可以合理地预期一些这些陷阱。你需要找到悲观、乐观以及——在中间某个地方——现实之间的正确平衡。
- en: '**KEY CONCEPT**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Creating timescale estimates is a genuinely hard task. Don''t underestimate
    how much work is involved. Appreciate the repercussions of making a bad estimate*.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建时间表估算是一项真正的困难任务。不要低估所涉及的工作量。欣赏做出糟糕估算的后果*。'
- en: 'The story doesn''t end there: It''s not just making the estimate that''s hard.
    Living with the consequences can be just as painful.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 故事还没有结束：不仅仅是做出估算很难。承受后果可能同样痛苦。
- en: Estimates become contractual, used to set delivery schedules with customers.
    Once set in concrete, these dates are hard to move and costly to get wrong.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算变成了合同，用于与客户设定交付时间表。一旦确定，这些日期就很难变动，一旦出错代价高昂。
- en: It is hard to work to someone else's estimate—were you not up to the task if
    you miss a deadline, or was the estimate wrong?
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照别人的估算工作很难——如果你错过了截止日期，是不是因为你没有完成任务，或者估算错误？
- en: New tasks are often discovered during development which need accounting for
    and slotting into the schedule, pushing everything else back. Similarly, you'll
    only discover specification problems once the development work is actually under
    way. These specification changes will affect the amount of work required, and
    therefore the time estimate.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中经常会发现新的任务，需要对其进行核算并安排到时间表中，这会将其他所有事情都推后。同样，你只有在开发工作真正开始后才会发现规格问题。这些规格变更将影响所需的工作量，因此也会影响时间估算。
- en: There are *always* unforeseen problems. You can absorb the impact of small problems
    by working a little harder to stay on schedule. You didn't need to sleep this
    month, did you? But large problems introduce buckets of extra work and cause schedule
    mayhem.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是会有意料之外的问题。你可以通过稍微努力一些来保持进度，从而吸收小问题的冲击。这个月你不需要睡觉，对吧？但是大问题会带来大量的额外工作，并导致进度混乱。
- en: 'The estimate is just *another* responsibility: You are not only accountable
    for creating the code, and for it to be good, well-designed, maintainable code;
    you also have to deliver it to a timescale that you have promised. Pity the poor
    programmers!'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算只是又一项责任：你不仅要对创建的代码负责，确保它是优秀的、设计良好的、可维护的代码，还要按照你承诺的时间表交付它。可怜的程序员们啊！
- en: Under Pressure
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力之下
- en: The software factory is not a reasonable place, and the temptation to give optimistic
    estimates is strong. Programmers new to the estimation game are particularly vulnerable.
    There is pressure from above to promise short schedules so that we can win contracts,
    announce new releases, maintain internal political stability, and so on. This
    is an understandable, sad reality; no company exists in a vacuum, and the shareholders
    want to be kept in caviar and champagne.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工厂不是一个合理的地方，给出乐观估算的诱惑很强。对于估算游戏新手来说，他们尤其容易受到压力。上面有压力要求承诺短时间表，以便我们可以赢得合同、宣布新版本、维持内部政治稳定等等。这是一个可以理解的、令人悲伤的现实；没有公司是孤立存在的，股东们希望得到鱼子酱和香槟。
- en: But the pressure isn't entirely from above. It also comes from a programmer's
    personal pride. Techies like to promise an optimistic timescale; we are motivated
    people who are proud of what we deliver and how fast we can do it. It's tempting
    to think, "Oh, it shouldn't take too long." But there's a very real difference
    between a quick code hack or prototype effort and a full, production-ready piece
    of work. Our timescales must be grounded in reality, not in hopeful ideals.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 但压力并不完全来自上面。它也来自程序员个人的骄傲。技术人员喜欢承诺乐观的时间表；我们是一群自豪于我们交付的内容和速度的人。认为“哦，这不应该花太多时间”是很诱人的。但是，快速代码修改或原型工作与完整、生产就绪的工作之间有很大的区别。我们的时间表必须基于现实，而不是基于希望的理想。
- en: '**KEY CONCEPT**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Everyone (including you) wants shorter development timescales. Don''t kid
    yourself about what is technically possible in the given development time. Don''t
    promise a hack timescale when you must deliver production code*.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个人都（包括你）都希望更短的开发时间表。不要自欺欺人，认为在给定的时间内技术上可能实现什么。当你必须交付生产代码时，不要承诺快速修改的时间表*。'
- en: We must be aware of this pressure and react to it carefully. Beware of the danger
    of an extreme opposite reaction. It is easy to be a pessimistic doom-sayer, to
    imagine a task lasting indefinitely, and compensating with a stupidly large timescale
    estimate. The very real danger of an overestimate is that projects inevitably
    expand to fit the available time! You'll always find bits of code to polish when
    there are a few days spare.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须意识到这种压力，并谨慎地做出反应。小心极端相反反应的危险。很容易成为一个悲观的末日预言家，想象任务会无限期地持续下去，并用愚蠢的大时间尺度估算来补偿。高估的真正危险是项目不可避免地会扩展以适应可用的时间！当有几天空闲时，你总会找到一些代码可以润色。
- en: 'In an ideal world, project deadlines are established *after* a feasibility
    review that proves the project is possible in reasonable time. The Real World
    is rarely that kind. Instead, you are given a deadline ("Get it shipping by Christmas"),
    and then have to figure out how to deliver. If the work doesn''t fit, you must
    negotiate how you''ll get there: Remove features, add programmers, outsource risky
    parts, or perhaps provide a later upgrade with more functionality. Sometimes this
    planning becomes more of a marketing exercise and gets quite creative!'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，项目截止日期是在可行性审查之后确定的，该审查证明项目在合理的时间内是可行的。现实世界很少是这样的。相反，你会被给予一个截止日期（“圣诞节前发货”），然后你必须想出如何实现。如果工作不合适，你必须协商如何到达那里：删除功能、增加程序员、外包风险部分，或者可能提供带有更多功能的后续升级。有时这种规划更像是一项营销活动，而且相当有创意！
- en: No one said that it was supposed to be easy.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人说过这应该很容易。
- en: '**A WAR STORY**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个战争故事**'
- en: 'The company had just taken the biggest and most strategically important order
    in its five-year history. This one was *make or break*. Sales fought hard to close
    the deal, agreeing to a hard customer deadline: The software *must* ship by the
    end of the year. With contracts signed, everyone patted themselves on the back.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 公司刚刚接到了其五年历史中最大、最重要的订单。这个订单是成败的关键。销售部门为了关闭这笔交易而奋力争取，同意了一个严格的客户截止日期：软件*必须*在年底前发货。合同签署后，每个人都互相拍手称赞。
- en: But no one had the time (or wit) to confer with the technical staff to ensure
    that the project was feasible. It wasn't. Managers started panicking, but with
    an immobile deadline and fixed feature set, there wasn't much they could do. The
    engineers complained and waved their project plans aloft, but were told to "just
    make it fit." They worked hard day after day, late into the night, and were soon
    exhausted. Each week saw them slip further away from the hopelessly optimistic
    schedule.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有人有时间（或智慧）与技术人员协商以确保项目可行。它并不可行。经理们开始恐慌，但由于截止日期固定且功能集不变，他们能做的事情并不多。工程师们抱怨并挥舞着他们的项目计划，但被告知“只需让它适应。”他们日复一日地努力工作，深夜仍在工作，很快就筋疲力尽。每周他们都发现自己离那绝望乐观的进度越来越远。
- en: In one last herculean effort, they completed the code by their deadline, only
    to be tripped up by an unforeseen hardware problem that delayed the project by
    two months. There was no contingency in the plan to account for this disaster.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的巨大努力中，他们按期完成了代码，但随后被一个未预见的硬件问题绊倒，导致项目延期两个月。计划中没有任何应对这种灾难的应急措施。
- en: The project was a failure, the engineers got burned out, nerves were fraught,
    and the customer was unhappy. Not long into the next project, most of the development
    team quit.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 项目失败了，工程师们疲惫不堪，神经紧张，客户也不满意。在下一个项目开始不久，大部分开发团队就辞职了。
- en: Practical Ways to Estimate
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估算的实际方法
- en: With the increasing pressure to be prophets as much as programmers, how do we
    meet expectations? Estimation, like many other skills, is something you get better
    at it with experience. It's not an old man's game, but if you don't work against
    a backdrop of schedules and set yourself targets to work toward, then you won't
    grow in the skill. Practice makes perfect.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对预言家和程序员的双重压力日益增加，我们如何满足期望？估算，就像许多其他技能一样，是你通过经验变得更好的东西。这不是老年人的游戏，但如果你不与进度和目标为背景工作，那么你在技能上就不会有所增长。熟能生巧。
- en: 'In the Real World, we rarely have the luxury of practice projects or a sandbox
    to experiment with timescale estimation. Somewhere along the road from junior
    programmer to guru, you have to pick up this skill! Sadly there is no magic formula
    or easy recipe for coming up with an estimate. But following these simple steps
    will immeasurably improve your accuracy:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们很少有机会进行实践项目或沙盒来实验时间估算。在从初级程序员到大师的道路上，你必须掌握这项技能！遗憾的是，没有神奇的公式或简单的食谱可以用来得出估算。但遵循这些简单的步骤将极大地提高你的准确性：
- en: Break the task down into the smallest blocks possible, effectively performing
    a first pass of system design.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任务分解成可能的最小块，有效地进行系统设计的第一遍。
- en: When you reach a fine resolution with suitably comprehensible parts, provide
    a timescale estimate for each block in *man-hours* or *man-days*.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你达到适当的分辨率并且部分内容易于理解时，为每个块提供一个以人时或人日为单位的时间估算。
- en: 'Once you''ve estimated all of the individual timescales, place them back-to-back,
    add up their durations, and voilà: an instant timescale estimate.'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你估算出所有个别的时间范围，将它们并排放置，加总它们的持续时间， voilà：立即得到时间估算。
- en: 'This strategy works because you can fully comprehend and accurately estimate
    a series of smaller activities more easily than one gargantuan task. Estimates
    should *never* be made in units larger than man-days: Such large tasks show that
    you don''t really understand the problem yet; your estimate cannot be at all reliable.
    Mercilessly decompose large tasks until you end up with fine-grained—estimatable—work
    units.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略有效，因为你可以更容易地完全理解并准确估计一系列较小的活动，而不是一个庞大的任务。估算不应使用大于人日的大单位：这样的大型任务表明你还没有真正理解问题；你的估算根本不可靠。无情地将大型任务分解，直到你得到细粒度——可估算的——工作单元。
- en: '**KEY CONCEPT**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Time estimates should be made for small tasks whose individual scope is easy
    to understand. The measurement should be in units of* man-hours *or* man-days.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间估算应针对小任务，这些任务的单独范围易于理解。测量应以人时或人日为单位*。'
- en: Of course, development work can often be parallelized between people; by breaking
    it into small comprehensible parts, we can juggle tasks around and work out how
    to run them concurrently, bringing forward the completion date. This becomes a
    project planning issue.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发工作通常可以在人们之间并行化；通过将其分解成小的、易于理解的部分，我们可以调整任务，并找出如何并行运行它们，从而提前完成日期。这成为一个项目规划问题。
- en: Set aside a reasonable amount of time to make an estimate. The requisite high-level
    design is not immediate; don't presume that timescales can be guessed easily.
    You'll fool yourself by producing a finger-in-the-air estimate with no foundation
    on prior experience and no basis in a system design.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 设定合理的时间来做出估算。所需的高级设计不是立即的；不要假设时间可以轻易猜测。如果你没有基于先前经验或系统设计的依据，仅凭直觉做出估算，你只会欺骗自己。
- en: 'It is vital to consider *every* activity that will be required to deliver the
    software. This means including time for:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到将交付软件所需的所有活动至关重要。这意味着包括以下时间：
- en: Performing adequate thoughtful design
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行充分的深思熟虑的设计
- en: Any exploratory work or prototyping required
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的任何探索性工作或原型设计
- en: The actual code implementation work
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的代码实现工作
- en: Debugging
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Writing unit tests
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Integration testing
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Writing the documentation
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文档
- en: Any research or training you'll be undertaking in the period
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在该期间进行的任何研究或培训
- en: This list shows that less time than you might expect is spent writing code,
    compared to other peripheral activities. Programming isn't just about cutting
    code; don't forget to include testing and documentation in your timescale estimates.
    They are essential. Without testing and documentation, you'll deliver code that
    doesn't work properly and can't be fixed later because no one knows how to use
    it.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表显示，与其他外围活动相比，编写代码所花费的时间比你预期的要少。编程不仅仅是编写代码；不要忘记在你的时间估算中包括测试和文档。它们是必不可少的。没有测试和文档，你将交付无法正常工作且无法修复的代码，因为没有人知道如何使用它。
- en: Don't try to calculate *elapsed time* (by incorporating distractions from other
    projects, reading email, browsing the web, drinking coffee, and answering the
    call of nature). It will inevitably be very different from the actual time spent
    on the task. The task may run concurrently with another, or be interrupted to
    provide space for another project. We deal with this on a project plan (described
    in "[The Planning Game](ch21s05.html "The Planning Game")" on page 409).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图计算*经过时间*（通过结合其他项目的干扰、阅读电子邮件、浏览网页、喝咖啡和回应生理需求）。这不可避免地会与实际花费在任务上的时间有很大不同。任务可能与另一个任务同时进行，或者被中断以腾出空间给另一个项目。我们在项目计划中处理这个问题（在409页的"[The
    Planning Game](ch21s05.html "The Planning Game")"中描述）。
- en: 'How conservative should your estimate be? Should you veer toward optimism or
    pessimism? The correct answer is: The estimate must be realistic. Anticipate likely
    problems and factor them in, but don''t invent 1,000 ways a simple task could
    fail and use it as an excuse to give an inflated estimate. Don''t overestimate
    just to cover your tracks, or to give yourself more slack to fill with games of
    solitaire. Our individual task estimates can''t mitigate for everything that can
    go wrong. Risk should be managed at the *project level*; the scheduler takes our
    estimates and works them into a reasonable plan with suitable contingency.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你的估算应该有多保守？你应该偏向乐观还是悲观？正确的答案是：估算必须是现实的。预测可能的问题并将它们考虑在内，但不要设想简单任务可能失败的1,000种方式，并以此作为给出膨胀估算的借口。不要为了掩盖自己的行踪或给自己更多打牌的时间而高估。我们的个人任务估算不能减轻所有可能出错的事情。风险应该在*项目层面*上管理；调度员将我们的估算纳入一个合理的计划中，并考虑适当的应急措施。
- en: 'To make more accurate estimates, consider these important issues:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出更准确的估算，考虑以下重要问题：
- en: The more concrete and specified a project is, the easier it is to estimate.
    Have you been given a good spec?
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目越具体、越明确，估算就越容易。你得到的是一个好的规范吗？
- en: Without a specification, there is no traceability, and a lot of the work involved
    in each package will be assumed. Two people could assume very different things
    about the project scope and expect different things at the project deadline. Rigorous
    specifications avoid this problem.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有规范，就没有可追溯性，每个软件包中涉及的大量工作都将被假设。两个人可能对项目范围有不同的假设，并在项目截止日期时期望不同的事情。严格的规范可以避免这个问题。
- en: Delivering the wrong system on time can be just as damaging as delivering the
    right one, late. If there is no specification, write one and get it approved by
    the task stakeholders.^([[3](#ftn.CHP-21-FN-3)]) At the very least, document all
    assumptions that you have made about the work.
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使按时交付错误的系统，其损害程度也可能与按时交付正确的系统一样严重。如果没有规范，就编写一个并得到任务利益相关者的批准。[^[[3](#ftn.CHP-21-FN-3)]]
    至少，记录下你对工作所做的所有假设。
- en: The more functionality requested, the harder the estimate is to make. Try to
    shave off all unnecessary work. An excellent approach is to stage the delivery
    of the software, giving estimates for each deliverable iteration.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的功能越多，估算就越困难。尽量削减所有不必要的任务。一个优秀的方法是将软件的交付分阶段进行，为每个可交付的迭代提供估算。
- en: Feed estimate information back upstream. The project decision-makers can then
    balance the importance of each requirement against its technical difficulty. It
    helps to see which small feature requests will double development time.
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将估算信息反馈给上游。项目决策者可以据此平衡每个需求的重要性与其技术难度。查看哪些小型功能请求将加倍开发时间是有帮助的。
- en: If you don't fully comprehend the entire problem, then you'll make a very bad
    estimate. Spend time getting to know exactly what the software must do. If you
    need more time to make an estimate, then ask for it, or indicate your confidence
    in the time values. Never guess an estimate and hope that it's about right—if
    you can't justify an estimate, then don't give it.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有完全理解整个问题，那么你将做出一个非常糟糕的估算。花时间了解软件必须做什么。如果你需要更多时间来做出估算，那么请要求，或者表明你对时间值的信心。永远不要猜测一个估算并希望它是正确的——如果你不能证明一个估算，那么不要给出它。
- en: If the task depends on third-party input, then it is harder to estimate. Who
    is responsible for chasing the third party for delivery? You may need to factor
    this into your development estimate. Get the third party's estimated delivery
    date, and then add time to integrate its work with your codebase (it never "just
    slots in"). Consider how much you trust the third party, and include a suitable
    amount of contingency as a buffer to accommodate problems.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务依赖于第三方输入，那么估计会更困难。谁负责追逐第三方以完成交付？你可能需要将这一点纳入你的开发估计中。获取第三方的估计交付日期，然后添加时间以将工作集成到你的代码库中（它永远不会“简单地插入”）。考虑你对第三方的信任程度，并包括适当的安全缓冲，以应对可能出现的问题。
- en: Different people will work on the same task at different rates. This is natural;
    everyone has a different set of skills, level of experience, confidence level,
    and relative number of distractions (e.g., older projects vying for attention
    or home commitments). You need to gauge how fast you work, and have a good understanding
    of the task you're embarking on. Estimation is personal.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的人将以不同的速度完成同一项任务。这是自然的；每个人都有不同的技能组合、经验水平、自信程度和相对的干扰数量（例如，争夺注意力的旧项目或家庭责任）。你需要评估你的工作效率，并对你即将着手进行的任务有一个良好的理解。估计是个人化的。
- en: '**KEY CONCEPT**'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Understand whether you''re creating an estimate for work that* you *will do
    (on a system you understand well) or that someone else will do (who might have
    to learn it first)*.'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*理解你是在为你要做的工作（在一个你非常了解的系统上）还是为别人要做的工作（可能需要先学习）创建估计*。'
- en: Don't accept pressure from above to be optimistic. Don't promise unrealistic
    timescales, thinking you can make it up if you work overtime. Have an appropriate
    response to managers who say, "It just has to be done faster."
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要接受来自上面的压力，要保持乐观。不要承诺不切实际的时间表，认为如果你加班就能弥补。对那些说“它必须更快完成”的经理有一个适当的回应。
- en: Perhaps most importantly, *never* plan up front on working overtime.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许最重要的是，*永远不要事先计划加班*。
- en: A simple way to improve your estimates is to ask for help with them. If you
    don't understand a problem, then find someone who does, and ask for his or her
    opinion. James Surowiecki's book *The Wisdom of Crowds* describes how large groups
    of people can be smarter than an elite few. Taking this extreme approach, get
    all the developers in your team to give rough estimates for all tasks on the plan,
    and then take the average of their individual estimates. That estimate might not
    be too far off!
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 改善你的估计的一个简单方法就是寻求帮助。如果你不理解一个问题，那么找到理解它的人，并征求他们的意见。詹姆斯·苏罗维基的书籍《群体的智慧》描述了大型群体如何比少数精英更聪明。采取这种极端方法，让你们团队的所有开发者对计划上的所有任务给出粗略估计，然后取他们个人估计的平均值。这个估计可能不会偏离太远！
- en: '**KEY CONCEPT**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Don''t make estimates in isolation. Solicit other people''s opinions to help
    improve your estimates*.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要孤立地做出估计。征求其他人的意见以帮助改进你的估计*。'
- en: '* * *'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-21-FN-3)]) Of course, that will take time you didn't plan for!
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-21-FN-3)]) 当然，这将占用你没有计划的时间！
- en: The Planning Game
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划游戏
- en: 'A few disconnected timescale estimates are no use to anyone. You have to join
    them up and convert them into something useful: a project plan with which you
    can manage the development schedule. Based on their individual timescale estimates,
    tasks are assembled on a timeline and allotted to developers. Dependencies between
    tasks are identified and factored in to the plan (obviously, dependent tasks cannot
    start before their dependencies have completed). The final result is a pictorial
    chart with time running along the horizontal axis and tasks positioned concurrently
    on it, looking something like [Figure 21-1](ch21s05.html#a_gantt_chart "Figure 21-1. A
    Gantt chart") (a variant of the classic *Gantt chart*).'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 几个孤立的时间尺度估计对任何人都没有用处。你必须将它们连接起来，并将它们转换成有用的东西：一个你可以用来管理开发进度的项目计划。根据他们各自的时间尺度估计，任务被安排在时间轴上，并分配给开发者。识别任务之间的依赖关系，并将其纳入计划中（显然，依赖的任务不能在它们的依赖完成之前开始）。最终结果是沿着水平轴运行的时间图，任务同时定位在其上，看起来就像[图21-1](ch21s05.html#a_gantt_chart
    "图21-1. 一个甘特图")（经典*甘特图*的一个变体）。
- en: '![A Gantt chart](tagoreillycom20080909nostarchimages207574.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![一个甘特图](tagoreillycom20080909nostarchimages207574.png)'
- en: '**Figure 21-1. A Gantt chart**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21-1. 一个甘特图**'
- en: Project planning is about allocating tasks to developers and working out how
    to schedule development effort. But that's the easy half of the game. The important
    part is *risk management*—creating a safe and sensible plan in the face of uncertainty
    and hidden traps.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 项目规划是关于将任务分配给开发者和制定如何安排开发工作。但这只是游戏的一半。重要的是 *风险管理*——在不确定性和隐藏陷阱面前制定一个安全和合理的计划。
- en: 'The safest project plans:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的计划：
- en: '**Reduce the** *`critical path`*'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少** *`关键路径`*'
- en: This is the single line of back-to-back tasks that trace from the start to the
    end of the project, shown by the darker blocks in the diagram above. A slip in
    any one of these tasks will force back all the tasks depending on it and push
    out the final deadline.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单行任务，从项目的开始到结束追踪，在上述图中以较暗的块表示。任何这些任务的任何失误都将迫使所有依赖它的任务推迟，并推后最终截止日期。
- en: There is always—by definition—a critical path on the plan. This is what gives
    project planners grey hair! We aim for the optimum juxtaposition of tasks to provide
    the smallest (or least risky) critical path.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，计划中始终存在一条关键路径。这正是让项目规划者头发变白的原因！我们的目标是提供最优的任务排列，以提供最短（或风险最小的）关键路径。
- en: '**Are not massively parallel**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**不是大规模并行**'
- en: The standard planning misconception when trying to compress a large project
    is that throwing more developers at a problem will speed it up. This rarely works.
    An extra burden is imposed when managing more people—there are more lines of communication,
    more people to coordinate, and more points of failure. This is the subject of
    Brooks's seminal essay, "The Mythical Man-Month." (Brooks 95)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试压缩大型项目时，标准的规划误解是投入更多的开发者可以加快进度。这很少有效。管理更多的人会带来额外的负担——有更多的沟通线路，更多的人需要协调，以及更多的故障点。这是Brooks的开创性论文“神话般的月份”（Brooks
    95）的主题。
- en: 'You mustn''t over-parallelize a project plan, and you shouldn''t parallelize
    individual developers, either. If you put one developer against two tasks concurrently,
    you can''t expect them to finish in the same length of time as those two tasks
    serialized. This sounds obvious, but it often happens in practice: You might be
    asked to support an old project and simultaneously start development work on another.
    Significant time is taken up switching between tasks, which reduces your overall
    efficiency. If you did the two tasks back to back, then you''d complete faster
    (but probably fail to meet the business requirements of your organization).'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能过度并行化项目计划，也不应该并行化个别开发者。如果你让一个开发者同时面对两个任务，你不能期望他们以与这两个任务串行相同的时间完成。这听起来很明显，但在实践中经常发生：你可能会被要求支持一个旧项目，并同时开始另一个项目的开发工作。在任务之间切换会占用大量时间，这会降低你的整体效率。如果你将两个任务连续完成，那么你会更快完成（但可能无法满足你组织的业务需求）。
- en: '**Are not too long**'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要太长**'
- en: A lengthy project plan is too ambitious. One small problem on the critical path
    at any point could jeopardize the entire project.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 过长的项目计划过于雄心勃勃。关键路径上的任何一点出现的小问题都可能危及整个项目。
- en: This is where iterative and incremental development (see "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432) brings benefits, by breaking large development
    schedules into smaller, less risky iterations that can be more easily managed.
    This makes the plan more dynamic; it is effectively re-created at each delivery
    point. Although this approach is inherently safer and will highlight problems
    earlier in the development process, it consequently involves more work overall.
    Many managers don't like this—they like the illusion of an up-front waterfall
    plan that cannot be deviated from.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是迭代和增量开发（参见第432页的“[迭代和增量开发](ch22s03.html#iterative_and_incremental_development
    "迭代和增量开发")”）带来的好处，通过将大型开发计划分解成更小、风险更低的迭代，这些迭代可以更容易地管理。这使得计划更加动态；它实际上在每个交付点都会被重新创建。尽管这种方法本质上更安全，并且会在开发过程中较早地突出显示问题，但它因此涉及更多的工作。许多管理者不喜欢这种方法——他们喜欢那种无法偏离的前置瀑布计划的错觉。
- en: 'Good plans don''t just butt timescale estimates back to back. They account
    for the reality of the software factory and build in important risk-reducing structures.
    This includes accounting for:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 好的计划不仅仅是将时间表估计并排在一起。它们考虑了软件工厂的现实情况，并建立了重要的风险降低结构。这包括：
- en: '**Vacation**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**休假**'
- en: The amount of vacation allocated to each developer is known in advance and must
    be built in to the schedule. We must also include public holidays and any company
    shutdown over a Christmas break. On average, a developer takes half a day a week
    as vacation.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者分配的假期数量是提前知道的，并且必须纳入日程安排。我们还必须包括公共假日和圣诞节期间的任何公司关闭。平均而言，开发者每周休假半天。
- en: '**Loading**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**负荷**'
- en: To be realistic, the plan must factor in normal interruptions (meetings, training,
    sickness, and so on). It's normal to employ an 80 percent loading on the plan
    for each developer to accommodate this. People who are in more demand are spread
    more thinly. You must be honest about this, or the "popular" developers will slip
    against the schedule, despite their hard work, and will quickly become frustrated.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 要现实，计划必须考虑到正常的干扰（会议、培训、疾病等）。通常，每个开发者的计划负荷为80%，以适应这些干扰。需求更高的人会被分配得更薄。你必须对此诚实，否则“受欢迎”的开发人员尽管努力工作，也会违背进度，并很快感到沮丧。
- en: '**Contingency**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**应急**'
- en: This is the biggie. You have to account for the problems seen looming on the
    horizon and provide space for the unforeseen disasters that might stand between
    you and your release date. This is where the risk management rubber hits the road.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重中之重。你必须考虑到即将出现的潜在问题，并为可能阻碍你与发布日期之间的不可预见灾难留出空间。这就是风险管理真正发挥作用的地方。
- en: Risk is best managed at this project level, rather than within individual timescale
    estimates. On a development plan, we can accommodate potential problems by making
    informed judgments in full sight of the whole development process. The alternative,
    a series of pessimistic estimates placed on a plan, will inevitably be wildly
    out.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 风险最好在项目层面管理，而不是在个人时间估计范围内。在开发计划中，我们可以通过在整个开发过程中进行明智的判断来容纳潜在的问题。另一种选择，即在计划上放置一系列悲观的估计，必然会导致结果大相径庭。
- en: 'The million dollar question is: How much contingency should you add in? You
    can''t simply multiply the plan by three and call it contingency! A good strategy
    is to give each task a confidence value. Based on this, provide an extra pseudo-task
    on the plan for the riskiest tasks as "danger time." Make this a fraction of the
    original task length, based on your confidence value.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 百万美元的问题：你应该增加多少应急时间？你不能简单地将计划乘以三，然后称之为应急时间！一个好的策略是为每个任务分配一个信心值。基于这个值，为最危险的任务在计划中提供额外的伪任务，作为“危险时间”。根据你的信心值，将其设置为原始任务长度的分数之一。
- en: '**Integration**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成**'
- en: A task is not done once a component is code complete and unit tested. Reserve
    adequate time to glue all of the components together, and to test that the entire
    system works as expected. There will be debugging required and issues that only
    surface when components meet (performance issues or interface mismatches, for
    example).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件完成编码和单元测试并不意味着任务已经完成。要预留足够的时间将所有组件粘合在一起，并测试整个系统是否按预期工作。这将需要调试，并且只有在组件相遇时才会出现的问题（例如性能问题或接口不匹配）。
- en: '**Support**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持**'
- en: The longer people have been within an organization, the more call there will
    be on them to support old projects, answer bug reports from the field, and so
    on. Ensure that this is incorporated into their loading, and that they then stick
    to the plan, highlighting when other projects are demanding more of their time.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在一个组织中的时间越长，他们就越有可能被要求支持旧项目、回答现场的错误报告等。确保这一点被纳入他们的负荷中，并且他们随后要遵守计划，突出显示当其他项目要求他们更多时间时。
- en: Projects slip subtly when key people are stretched in all directions.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当关键人员被拉向各个方向时，项目会微妙地滑落。
- en: '**Mopping up**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**清理**'
- en: Provide time to tidy up at the end of your plan. In the battle to release software,
    corners are cut to meet the deadline. This is known as amassing *technical debt*.
    Despite our preaching about good design and coding practices, this isn't necessarily
    evil; it's quite pragmatic. However, you must set aside time to tidy up and maintain
    a good, clean codebase. Otherwise, the next development iteration will build upon
    a broken, crufty codebase. Left unaddressed, this increasing pile of short-term
    hacks will become a burden to your programmers.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在计划结束时提供整理时间。在发布软件的战斗中，为了赶上截止日期，会牺牲一些角落。这被称为积累*技术债务*。尽管我们宣扬良好的设计和编码实践，但这并不一定是邪恶的；它相当实用。然而，你必须留出时间来整理和维护一个良好、干净的代码库。否则，下一个开发迭代将在一个破损、杂乱的代码库上构建。如果这个问题得不到解决，这不断增加的短期修补将变成程序员们的负担。
- en: Think of this exercise as part of the *previous* job (despite occurring after
    the release deadline), and not as the beginning of the next one. Pay off your
    debt in the project that accrued it.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 将这项练习视为*之前*工作的一部分（尽管发生在发布截止日期之后），而不是下一项工作的开始。偿还因项目而产生的债务。
- en: Never let these tidy-ups been viewed as optional extras; they are an important
    integral part of the project. In the frantic world of the software factory, optional
    tasks placed at the end of the schedule simply will not happen. Guard these tasks
    carefuly.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将这些整理工作视为可选的额外任务；它们是项目的重要组成部分。在软件工厂的繁忙世界中，放在日程表末尾的可选任务根本不会发生。小心保护这些任务。
- en: '**KEY CONCEPT**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Create development schedules that will leave your codebase in a clean state.
    Plan to repay your technical debt*.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建将使您的代码库保持干净的开发时间表。计划偿还您的技术债务*。'
- en: An in-depth investigation of project planning is outside the scope of this book;
    it's a large, complex task. But it is important to understand the basic principles.
    You must be able to develop software according to a plan, and must understand
    the rationale behind a plan to truly understand what you're asked to do.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 对项目规划的深入调查超出了本书的范围；这是一个庞大而复杂的任务。但是，理解基本原理是非常重要的。你必须能够根据计划开发软件，并且必须理解计划背后的理由，才能真正理解你所要做的任务。
- en: 'The are many planning models: formal methods of making educated guesses. *Program
    Evaluation and Review Technique (PERT)* is a classic planning method developed
    in the 1950s by the US Navy. It''s like my arrival window calculation when driving
    to Bristol. For each task, you estimate three times corresponding to different
    likelihoods of meeting delivery dates: a best case, worst case, and likely case.
    This ties into a scheduling procedure that identifies the critical path and calculates
    the best- and worst-case project completion time. The bigger the gap between each
    task''s estimate, the bigger the risk associated with the task. Perhaps it will
    need more careful management or to be given to a more experienced member of the
    staff.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多规划模型：这些是做出有根据的猜测的正式方法。*程序评估和审查技术（PERT）* 是一种经典的规划方法，由美国海军在20世纪50年代开发。它就像我开车去布里斯托尔时的到达时间计算。对于每个任务，你估计三个时间，对应于满足交付日期的不同可能性：最佳情况、最坏情况和可能情况。这涉及到一个确定关键路径并计算最佳和最坏情况项目完成时间的调度程序。每个任务估计之间的差距越大，与该任务相关的风险就越大。可能需要更仔细的管理，或者分配给更有经验的团队成员。
- en: Boehm's *Constructive Cost Model (COCOMO)* dates from 1981 and is an estimation
    model based on analysis of real software projects. It has evolved into *COCOMO
    II*, which more accurately reflects the nature of modern software projects. (Boehm
    81) *Projects in Controlled Environments* (known by the rather contrived acronym
    *PRINCE*) is a classic British piece of bureaucracy embodied in project management
    form; if it could mandate standing in queues, it would!^([[4](#ftn.CHP-21-FN-4)])
    Its scope is the entire project life cycle, from start to closure. The PRINCE
    planning process comprises seven steps, covering designing the plan, through estimation
    and scheduling, to plan completion. It too has evolved, into a method imaginatively
    called *PRINCE2*.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: Boehm的*构造性成本模型（COCOMO）*始于1981年，是基于对真实软件项目分析的一种估算模型。它已演变为*COCOMO II*，更准确地反映了现代软件项目的本质。（Boehm
    81）*受控环境中的项目*（以其相当牵强的缩写*PRINCE*而闻名）是项目管理形式中体现的经典英国官僚主义；如果它能强制排队，它就会！^([[4](#ftn.CHP-21-FN-4)])
    它的范围是整个项目生命周期，从开始到结束。PRINCE规划过程包括七个步骤，涵盖设计计划、估算和调度，到计划完成。它也经历了演变，变成了一种富有想象力的方法，称为*PRINCE2*。
- en: '* * *'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-21-FN-4)]) Queueing is a popular British pastime, like drinking
    tea and playing cricket.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-21-FN-4)]) 排队是英国人喜爱的消遣方式，就像喝茶和打板球一样。
- en: Keep Up!
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持进度！
- en: How does a project get to be a year late? . . . One day at a time.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目是如何推迟一年的？……一天又一天。
- en: --Frederick P. Brooks Jr.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: --弗雷德里克·P·布鲁克斯小
- en: As work slips and the project deadline looms, engineers work very hard and get
    little credit. The idea of rigorous testing is squeezed out in a mad rush to get
    something passable out the door on time. Bad estimates are a prime cause of this
    software circus. They foster managers' incorrect assumptions about the difficulty
    of the development work, since they have no way to know the schedule was incorrect
    in the first place. When we make an estimate, it is therefore essential to get
    it right.^([[5](#ftn.CHP-21-FN-5)])
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作进度滞后，项目截止日期临近时，工程师们非常努力地工作，却很少得到认可。在疯狂地赶工以按时推出可接受的产品时，严格的测试想法被挤掉了。不良的估计是这种软件杂技秀的主要原因。它们助长了管理者对开发工作难度的错误假设，因为他们根本不知道最初的进度计划是错误的。因此，当我们做出估计时，确保其准确性是至关重要的.^([[5](#ftn.CHP-21-FN-5)])
- en: '**IT''S ALL ABOUT PLANNING**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**一切关乎规划**'
- en: The development team was getting quite large, and our working space had become
    really cramped. After a lot of effort, a new office was found and the team was
    told on Friday that we'd be working in the new location on Monday. Over the weekend,
    all the computers, servers, cables, routers, printers—everything—would be manhandled
    into vans and transported to the new location. We were assured that it would be
    seamless and that everything would be ready on Monday morning.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队变得相当庞大，我们的工作空间变得非常拥挤。经过一番努力，找到了一个新的办公室，周五团队被告知我们将在周一在新地点工作。周末，所有的电脑、服务器、电缆、路由器、打印机——所有东西——都会被搬运到货车上，运送到新地点。我们被告知这将无缝进行，并且周一早上一切都会准备就绪。
- en: On Monday morning, we turned up at the new office and, sure enough, everything
    had been set up and worked perfectly! All the IT infrastructure had been installed.
    The servers were back online and fully operational. Everyone's workspace had been
    set up. A truly herculean effort.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 周一早上，我们到达新办公室，果然一切都已经设置好，并且运行得完美！所有的IT基础设施都已经安装。服务器已经上线并完全运行。每个人的工作空间都已经设置好。这是一项真正的艰巨努力。
- en: 'But there was one small problem: There were no chairs. Not one. They had somehow
    been forgotten in the move plan, had gotten lost, and couldn''t be found anywhere!
    We had no chairs for three days.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个小问题：没有椅子。一个也没有。它们在搬迁计划中不知怎么被遗忘了，丢失了，而且在哪里都找不到！我们三天没有椅子可用。
- en: Now that's what you call planning.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 那才是真正的规划。
- en: 'Given a realistic estimate for a software task, there are a few key ways to
    keep to schedule and prevent this kind of last-minute squeeze:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件任务的现实估计，有一些关键的方法可以保持进度并防止这种最后一刻的挤压：
- en: When starting a new task, check whether or not the allotted timescale really
    *is* practical—especially if you didn't have the luxury of making the estimate
    yourself. Even if you did make the estimate, start by verifying it. Don't rush
    headlong into a code editor, *hoping* that you can complete on time; be sure that
    you are genuinely able to deliver. A little sanity checking up front can save
    you from a world of pain and embarrassment later.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始一项新任务时，检查分配的时间表是否真的*可行*——尤其是如果你没有自己做出估计的奢侈。即使你做出了估计，也要先验证它。不要一头扎进代码编辑器，*希望*能按时完成；确保你真的能够交付。提前进行一点理智的检查可以让你避免后来的痛苦和尴尬。
- en: Refer to the schedule—it matters. Keep a constant eye on how long you're taking
    against scheduled time. Write down your timescales and keep them close at hand.
    Add personal estimates for any intermediate tasks that don't figure on the main
    software plan, and run yourself as a mini-project. If you hit your internal milestones,
    you'll have more chance of keeping on track with your externally visible timescales.
    Repeatedly review your list—at least once a day.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考进度表——这很重要。持续关注你与计划时间的差距。写下你的时间表，并随身携带。为任何在主要软件计划中未考虑的中间任务添加个人估计，并将自己作为一个迷你项目来运行。如果你达到了内部里程碑，你就有更大的机会与外部可见的时间表保持一致。反复审查你的清单——至少每天一次。
- en: If you discover that you won't hit the deadline, make this known as soon as
    possible so the plan can be adjusted. Like phoning ahead when I'm traveling to
    Bristol, it is better to get this fact out in the open as soon as possible. If
    the possibility of overrun is foreseen, then different scheduling decisions can
    be made to minimize the impact of the overrun.
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你发现你无法按时完成，尽可能早地让这个事实为人所知，以便调整计划。就像我旅行到布里斯托尔时提前打电话一样，最好是尽快公开这个事实。如果预见到了超出的可能性，那么可以做出不同的调度决策，以最小化超出的影响。
- en: This happens far too rarely in practice. If an important project has five programmers
    who must all report their progress, then none of them wants to be the first one
    to admit falling behind the schedule. This is known as playing *schedule chicken*.
    The result is everything seems to be fine, but then suddenly the project is hugely
    late. It was getting late one day at a time, but no wanted to admit it. Break
    this cycle and broadcast a warning as early as possible.
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上这种情况发生的频率太低了。如果一个重要的项目有五个程序员必须都报告他们的进度，那么没有人愿意成为第一个承认落后于进度的人。这被称为“进度鸡游戏”。结果是似乎一切都很顺利，但突然项目严重延误。它是一天天地晚下去的，但没有人愿意承认。打破这个循环，尽早发出警告。
- en: '**KEY CONCEPT**'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Continually monitor your progress against the plan. Then you will never be
    surprised that your task has slipped*.'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*持续监控你的进度与计划的对比。这样你就永远不会惊讶于你的任务已经落后了*。'
- en: Do as much work as necessary, and no more. It might be fun to add that cute
    extra feature. But don't. There are more important—planned—things to be done.
    Ask for important extras to be scheduled in later if they aren't *really* needed
    now. An ill-chosen detour on my route to Bristol will really set back my arrival
    time—even if it is a lovely scenic drive—so I take the sensible straight route
    to arrive on time.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做必要的工作，不要多做。添加那个可爱的额外功能可能很有趣。但不要这么做。有更重要——计划中的——事情要做。如果现在并不真的需要，请要求将重要的额外任务安排在以后。在我前往布里斯托尔的路上，选择一条不恰当的路线将会真正推迟我的到达时间——即使这是一段美丽的风景之旅——所以我选择合理的直线路线按时到达。
- en: Careful design exploiting modularity tends to reduce component dependency, and
    so reduces the ill effects of slippage and the bunching up of tasks on the schedule.
    Agree on component interfaces early on, and provide stub components so development
    can continue while others parts of the system are being built.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎的设计利用模块化往往可以减少组件依赖，从而减少进度延误和任务在时间表上集中带来的不良影响。尽早就组件接口达成一致，并提供占位组件，以便在构建系统的其他部分时继续开发。
- en: Write good code, with a thorough set of unit tests. As keen craftsmen, this
    should be self-evident! It helps to reduce debug and maintenance time radically.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写良好的代码，并附有一套彻底的单元测试。作为熟练的工匠，这一点应该是显而易见的！这有助于极大地减少调试和维护时间。
- en: Don't forget to finish coding with time to document and test thoroughly. Don't
    build up to a final coding sprint in the last few days of the schedule. You need
    time to prove that your code works. Otherwise, you'll slip as debugging inches
    out beyond your deadline. If you don't have time to complete all this work, say
    so and get the timescale extended. Don't skip these things—they'll bite you later.
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记在编码完成后留出时间来彻底地进行文档编写和测试。不要在计划最后几天进行最后的编码冲刺。你需要时间来证明你的代码是可行的。否则，你会在调试中超出截止日期。如果你没有时间完成所有这些工作，请说明并请求延长时间表。不要跳过这些事情——它们会在以后咬你。
- en: Watch out for changing requirements and specifications and track how this will
    affect your timescales. If it's an adverse change, report it immediately. Don't
    silently absorb functionality changes.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意变化的需求和规范，并跟踪这些变化将如何影响你的时间表。如果是一个不利的变化，立即报告。不要默默吸收功能变化。
- en: Be strict with distractions. Don't work on other tasks unless they are accounted
    for on a plan. Learn to say *no* to old projects, extra work from other departments,
    and intrusions from the phone and email.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对干扰要严格。除非计划中有安排，否则不要处理其他任务。学会对旧项目、其他部门的额外工作以及电话和电子邮件的干扰说“不”。
- en: Guard against these external distractions, even the short ones that seem harmless;
    they can really lower the quality of your work. It takes time to *get into the
    zone*, that productive place where your mind is on the task and the code is flowing
    freely from your fingertips (psychologists call this state *flow*). Even short
    distractions interrupt this effectiveness, and when you return to work, you must
    spend more time getting back into the zone. The impact of interruptions can be
    more than three times their duration. (DeMarco 99)
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 防止这些外部干扰，即使是看似无害的短暂干扰；它们实际上会降低你工作的质量。进入“状态”需要时间，这是那种你的心思专注于任务，代码从指尖自由流淌的地方（心理学家称之为“心流”）。即使是短暂的干扰也会打断这种有效性，当你回到工作状态时，你必须花费更多时间重新进入状态。中断的影响可能超过其持续时间的三倍。（DeMarco
    99）
- en: 'Foster a development culture that''s conducive to getting work done. Respect
    each other''s brain-space: a person''s time to think and work. Make sure that
    every meeting really is necessary—don''t pull developers into random, time-wasting
    get-togethers.'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 培养一种有利于完成工作的开发文化。尊重彼此的思考和工作空间：一个人的思考和工作的时机。确保每次会议都是必要的——不要把开发者拉进随意的、浪费时间的小聚会。
- en: Maintain a positive and optimistic approach. Believing a project is doomed is
    a surefire way to make that happen in reality.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持积极和乐观的态度。相信项目注定失败是确保它在现实中发生的好方法。
- en: '* * *'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[5](#CHP-21-FN-5)]) 5Ironically, good estimates can also cause this problem.
    DeMarco and Lister recount a genuine episode where a project lead reported their
    100 percent confidence that the project would complete on time and to budget.
    (DeMarco 99) The managers, taken aback by this unexpected piece of good news,
    consequently decided to bring the deadline forward! No matter how good the engineer,
    you can always build a better manager to destroy his or her hard work!
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-21-FN-5)]) 5具有讽刺意味的是，良好的估计也可能导致这个问题。DeMarco和Lister讲述了一个真实的事件，其中项目负责人报告他们对项目按时按预算完成的100%信心。（DeMarco
    99）管理人员对这意外的好消息感到惊讶，因此决定提前截止日期！无论工程师多么优秀，你都可以构建一个更好的经理来破坏他的或她的辛勤工作！
- en: In a Nutshell
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Good luck is a lazy man's estimate of a worker's success.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运是懒惰的人对工人成功的估计。
- en: --Anonymous
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: --匿名
- en: Timescale estimation and planning help us to develop commercially successful
    software. However, there is no rigorous method to accurately determine software
    timescale values. That's why it's *estimation*.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 时间尺度估计和规划有助于我们开发商业上成功的软件。然而，没有严格的方法可以准确确定软件时间尺度值。这就是为什么它是*估计*。
- en: Aim to develop your estimation techniques, and become wary of potential problems
    that can ruin your neatly scheduled development plan. Learn how to work to a schedule
    and to identify when your schedules are impractical.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 努力提高你的估计技巧，并警惕可能破坏你整洁开发计划的问题。学习如何按计划工作，并识别你的计划何时不切实际。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程者 . . . | 不擅长编程者 . . . |'
- en: '| --- | --- |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Create good timescale estimates by considering all parts of the development
    process, based on a sound component breakdown
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过考虑开发过程的各个方面，基于合理的组件分解来创建良好的时间尺度估计
- en: Try to produce tested code with full documentation, properly integrated within
    the timescales
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力编写经过测试且具有完整文档的代码，并在适当的时间尺度内正确集成
- en: Highlight timescale problems early on so that they can be dealt with
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期突出时间尺度问题，以便可以处理
- en: '|'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Produce hopeful estimates, based solely on hunches and gut feelings
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅基于直觉和直觉产生有希望的估计
- en: Can hack out some code within their timescale estimates but will not produce
    production quality, bug-free code
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在他们的时间尺度估计内编写一些代码，但不会产生生产质量、无错误的代码
- en: Think that admitting a timescale problem is a sign of weakness, and work themselves
    silly trying to catch up—when they fail, they look silly (and tired)
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认为承认时间尺度问题是软弱的表现，并疯狂地努力追赶，当他们失败时，看起来既愚蠢又疲惫
- en: '|'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟蓝图")'
- en: Good timescale estimates can only be based on a sound initial code design.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的时间尺度估计只能基于良好的初始代码设计。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: Making an estimate requires a well-defined scope of work, which must be captured
    unambiguously in a *specification*.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 制定估计需要明确的工作范围，这必须在*规范*中明确捕捉。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章。程序配方")'
- en: Development methodologies determine how tasks are slotted together and placed
    on a project plan.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 开发方法确定任务如何组合并放置在项目计划中。
- en: '![See Also](tagoreillycom20080909nostarchimages207576.png.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![参考内容](tagoreillycom20080909nostarchimages207576.png.jpg)'
- en: Get Thinking
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开动脑筋
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 550.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第550页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: How can you rescue a slipping project and bring it back on track?
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何拯救一个滑落的项目并将其重新纳入正轨？
- en: What's the correct response to having a deadline imposed on you before feasibility
    or planning work commences?
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可行性或规划工作开始之前，被强加截止日期的正确反应是什么？
- en: How do you ensure that a development plan is genuinely useful?
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保开发计划真正有用？
- en: Why do different programmers work at different rates? How can you reflect this
    on the plan?
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不同的程序员工作效率不同？你如何在计划中反映这一点？
- en: Getting Personal
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: What percentage of the projects that you've worked on have run to schedule?
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你参与的项目中有多少是按计划完成的？
- en: 'For those that did: What contributed to the success of the planning effort?'
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于那些成功的人来说：是什么因素促成了规划工作的成功？
- en: 'For those that failed: What were the main problems?'
  id: totrans-664
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于那些失败的人来说：主要问题是什么？
- en: How accurate are your timescale estimates? How far off target are you normally?
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的时间估计有多准确？你通常偏离目标有多远？
