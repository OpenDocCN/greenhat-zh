["```\nisBigGang :: Int -> Bool\nisBigGang x = x > 9\n```", "```\nisBigGang :: Int -> (Bool, String)\nisBigGang x = (x > 9, \"Compared gang size to 9.\")\n```", "```\nghci> isBigGang 3\n(False,\"Compared gang size to 9.\")\nghci> isBigGang 30\n(True,\"Compared gang size to 9.\")\n```", "```\napplyLog :: (a, String) -> (a -> (b, String)) -> (b, String)\napplyLog (x, log) f = let (y, newLog) = f x in (y, log ++ newLog)\n```", "```\nghci> (3, \"Smallish gang.\") `applyLog` isBigGang\n(False,\"Smallish gang.Compared gang size to 9.\")\nghci> (30, \"A freaking platoon.\") `applyLog` isBigGang\n(True,\"A freaking platoon.Compared gang size to 9.\")\n```", "```\nghci> (\"Tobin\", \"Got outlaw name.\") `applyLog` (\\x -> (length x, \"Applied length.\"))\n(5,\"Got outlaw name.Applied length.\")\nghci> (\"Bathcat\", \"Got outlaw name.\") `applyLog` (\\x -> (length x, \"Applied length.\"))\n(7,\"Got outlaw name.Applied length.\")\n```", "```\napplyLog :: (a, [c]) -> (a -> (b, [c])) -> (b, [c])\n```", "```\nghci> [1,2,3] `mappend` [4,5,6]\n[1,2,3,4,5,6]\nghci> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]\nChunk \"chi\" (Chunk \"huahua\" Empty)\n```", "```\napplyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)\napplyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)\n```", "```\nimport Data.Monoid\n\ntype Food = String\ntype Price = Sum Int\n\naddDrink :: Food -> (Food, Price)\naddDrink \"beans\" = (\"milk\", Sum 25)\naddDrink \"jerky\" = (\"whiskey\", Sum 99)\naddDrink _ = (\"beer\", Sum 30)\n```", "```\nghci> Sum 3 `mappend` Sum 9\nSum {getSum = 12}\n```", "```\nghci> (\"beans\", Sum 10) `applyLog` addDrink\n(\"milk\",Sum {getSum = 35})\nghci> (\"jerky\", Sum 25) `applyLog` addDrink\n(\"whiskey\",Sum {getSum = 124})\nghci> (\"dogmeat\", Sum 5) `applyLog` addDrink\n(\"beer\",Sum {getSum = 35})\n```", "```\nghci> (\"dogmeat\", Sum 5) `applyLog` addDrink `applyLog` addDrink\n(\"beer\",Sum {getSum = 65})\n```", "```\nnewtype Writer w a = Writer { runWriter :: (a, w) }\n```", "```\ninstance (Monoid w) => Monad (Writer w) where\n    return x = Writer (x, mempty)\n    (Writer (x, v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')\n```", "```\nghci> runWriter (return 3 :: Writer String Int)\n(3,\"\")\nghci> runWriter (return 3 :: Writer (Sum Int) Int)\n(3,Sum {getSum = 0})\nghci> runWriter (return 3 :: Writer (Product Int) Int)\n(3,Product {getProduct = 1})\n```", "```\nimport Control.Monad.Writer\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = writer (x, [\"Got number: \" ++ show x])\n\nmultWithLog :: Writer [String] Int multWithLog = do\n    a <- logNumber 3\n    b <- logNumber 5\n    return (a*b)\n```", "```\nghci> runWriter multWithLog\n(15,[\"Got number: 3\",\"Got number: 5\"])\n```", "```\nmultWithLog :: Writer [String] Int\nmultWithLog = do\n    a <- logNumber 3\n    b <- logNumber 5\n    tell [\"Gonna multiply these two\"]\n    return (a*b)\n```", "```\nghci> runWriter multWithLog\n(15,[\"Got number: 3\",\"Got number: 5\",\"Gonna multiply these two\"])\n```", "```\ngcd' :: Int -> Int -> Int gcd' a b\n    | b == 0    = a\n    | otherwise = gcd' b (a `mod` b)\n```", "```\nghci> gcd' 8 3\n1\n```", "```\ngcd' :: Int -> Int -> Writer [String] Int\n```", "```\nimport Control.Monad.Writer\n\ngcd' :: Int -> Int -> Writer [String] Int\ngcd' a b\n    | b == 0 = do\n        tell [\"Finished with \" ++ show a]\n        return a\n    | otherwise = do\n        tell [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)]\n        gcd' b (a `mod` b)\n```", "```\nwriter (a, [\"Finished with \" ++ show a])\n```", "```\nghci> fst $ runWriter (gcd' 8 3)\n1\n```", "```\nghci> mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)\n8 mod 3 = 2\n3 mod 2 = 1\n2 mod 1 = 0\nFinished with 1\n```", "```\na ++ (b ++ (c ++ (d ++ (e ++ f))))\n```", "```\n((((a ++ b) ++ c) ++ d) ++ e) ++ f\n```", "```\nimport Control.Monad.Writer\n\ngcdReverse :: Int -> Int -> Writer [String]\nInt gcdReverse a b\n    | b == 0 = do\n        tell [\"Finished with \" ++ show a]\n        return a\n    | otherwise = do\n        result <- gcdReverse b (a `mod` b)\n        tell [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)]\n        return result\n```", "```\nghci> mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)\nFinished with 1\n2 mod 1 = 0\n3 mod 2 = 1\n8 mod 3 = 2\n```", "```\nf `append` g = \\xs -> f (g xs)\n```", "```\n\\xs -> \"dog\" ++ (\"meat\" ++ xs)\n```", "```\nnewtype DiffList a = DiffList { getDiffList :: [a] -> [a] }\n```", "```\ntoDiffList :: [a] -> DiffList a\ntoDiffList xs = DiffList (xs++)\n\nfromDiffList :: DiffList a -> [a]\nfromDiffList (DiffList f) = f []\n```", "```\ninstance Monoid (DiffList a) where\n    mempty = DiffList (\\xs -> [] ++ xs)\n    (DiffList f) `mappend` (DiffList g) = DiffList (\\xs -> f (g xs))\n```", "```\nghci> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])\n[1,2,3,4,1,2,3]\n```", "```\nimport Control.Monad.Writer\n\ngcd' :: Int -> Int -> Writer (DiffList String) Int gcd' a b\n    | b == 0 = do\n        tell (toDiffList [\"Finished with \" ++ show a])\n        return a\n    | otherwise = do\n        result <- gcd' b (a `mod` b)\n        tell (toDiffList [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)])\n        return result\n```", "```\nghci> mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34\nFinished with 2\n8 mod 2 = 0\n34 mod 8 = 2\n110 mod 34 = 8\n```", "```\nfinalCountDown :: Int -> Writer (DiffList String) ()\nfinalCountDown 0 = do\n    tell (toDiffList [\"0\"])\nfinalCountDown x = do\n    finalCountDown (x-1)\n    tell (toDiffList [show x])\n```", "```\nghci> mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000\n0\n1\n2\n...\n```", "```\nfinalCountDown :: Int -> Writer [String] ()\nfinalCountDown 0 = do\n    tell [\"0\"]\nfinalCountDown x = do\n    finalCountDown (x-1)\n    tell [show x]\n```", "```\nghci> mapM_ putStrLn . snd . runWriter $ finalCountDown 500000\n```", "```\nghci> let f = (*5)\nghci> let g = (+3)\nghci> (fmap f g) 8\n55\n```", "```\nghci> let f = (+) <$> (*2) <*> (+10)\nghci> f 3\n19\n```", "```\ninstance Monad ((->) r) where\n    return x = \\_ -> x\n    h >>= f = \\w -> f (h w) w\n```", "```\nimport Control.Monad.Instances\n\naddStuff :: Int -> Int\naddStuff = do\n    a <- (*2)\n    b <- (+10)\n    return (a+b)\n```", "```\nghci> addStuff 3\n19\n```", "```\naddStuff :: Int -> Int\naddStuff x = let\n    a = (*2) x\n    b = (+10) x\n    in a+b\n```", "```\nthreeCoins :: StdGen -> (Bool, Bool, Bool)\nthreeCoins gen =\n    let (firstCoin, newGen) = random gen\n        (secondCoin, newGen') = random newGen\n        (thirdCoin, newGen'') = random newGen'\n    in  (firstCoin, secondCoin, thirdCoin)\n```", "```\ns -> (a, s)\n```", "```\ntype Stack = [Int]\n\npop :: Stack -> (Int, Stack)\npop (x:xs) = (x, xs)\n\npush :: Int -> Stack -> ((), Stack)\npush a xs = ((), a:xs)\n```", "```\nstackManip :: Stack -> (Int, Stack)\nstackManip stack = let\n    ((), newStack1) = push 3 stack\n    (a , newStack2) = pop newStack1\n    in pop newStack2\n```", "```\nghci> stackManip [5,8,2,1]\n(5,[8,2,1])\n```", "```\nstackManip = do\n    push 3\n    a <- pop\n    pop\n```", "```\nnewtype State s a = State { runState :: s -> (a, s) }\n```", "```\ninstance Monad (State s) where\n    return x = State $ \\s -> (x, s)\n    (State h) >>= f = State $ \\s -> let (a, newState) = h s\n                                        (State g) = f a\n                                    in  g newState\n```", "```\nimport Control.Monad.State\n\npop :: State Stack Int\npop = state $ \\(x:xs) -> (x, xs)\n\npush :: Int -> State Stack ()\npush a = state $ \\xs -> ((), a:xs)\n```", "```\nimport Control.Monad.State\n\nstackManip :: State Stack Int\nstackManip = do\n    push 3\n    a <- pop\n    pop\n```", "```\nghci> runState stackManip [5,8,2,1]\n(5,[8,2,1])\n```", "```\nstackManip :: State Stack Int\nstackManip = do\n    push 3\n    pop\n    pop\n```", "```\nstackStuff :: State Stack ()\nstackStuff = do\n    a <- pop\n    if a == 5\n        then push 5\n        else do\n            push 3\n            push 8\n```", "```\nghci> runState stackStuff [9,0,2,1,0]\n((),[8,3,0,2,1,0])\n```", "```\nmoreStack :: State Stack ()\nmoreStack = do\n    a <- stackManip\n    if a == 100\n        then stackStuff\n        else return ()\n```", "```\nget = state $ \\s -> (s, s)\n```", "```\nput newState = state $ \\s -> ((), newState)\n```", "```\nstackyStack :: State Stack ()\nstackyStack = do\n    stackNow <- get\n    if stackNow == [1,2,3]\n        then put [8,3,1]\n        else put [9,2,1]\n```", "```\npop :: State Stack Int\npop = do\n    (x:xs) <- get\n    put xs\n    return x\n```", "```\npush :: Int -> State Stack ()\npush x = do\n    xs <- get\n    put (x:xs)\n```", "```\n(>>=) :: State s a -> (a -> State s b) -> State s b\n```", "```\n(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\n```", "```\nrandom :: (RandomGen g, Random a) => g -> (a, g)\n```", "```\nimport System.Random\nimport Control.Monad.State\n\nrandomSt :: (RandomGen g, Random a) => State g a\nrandomSt = state random\n```", "```\nimport System.Random\nimport Control.Monad.State\n\nthreeCoins :: State StdGen (Bool, Bool, Bool)\nthreeCoins = do\n    a <- randomSt\n    b <- randomSt\n    c <- randomSt\n    return (a, b, c)\n```", "```\nghci> runState threeCoins (mkStdGen 33)\n((True,False,True),680029187 2103410263)\n```", "```\nghci> :t Right 4\nRight 4 :: (Num t) => Either a t\nghci> :t Left \"out of cheese error\"\nLeft \"out of cheese error\" :: Either [Char] b\n```", "```\ninstance (Error e) => Monad (Either e) where\n    return x = Right x\n    Right x >>= f = f x\n    Left err >>= f = Left err\n    fail msg = Left (strMsg msg)\n```", "```\nghci> :t strMsg\nstrMsg :: (Error a) => String -> a\nghci> strMsg \"boom!\" :: String\n\"boom!\"\n```", "```\nghci> Left \"boom\" >>= \\x -> return (x+1)\nLeft \"boom\"\nghci> Left \"boom \" >>= \\x -> Left \"no way!\"\nLeft \"boom \"\nghci> Right 100 >>= \\x -> Left \"no way!\"\nLeft \"no way!\"\n```", "```\nghci> Right 3 >>= \\x -> return (x + 100)\n\n<interactive>:1:0:\n    Ambiguous type variable `a' in the constraints:\n      `Error a' arising from a use of `it' at <interactive>:1:0-33\n      `Show a' arising from a use of `print' at <interactive>:1:0-33\n    Probable fix: add a type signature that fixes these type variable(s)\n```", "```\nghci> Right 3 >>= \\x -> return (x + 100) :: Either String Int\nRight 103\n```", "```\nliftM :: (Monad m) => (a -> b) -> m a -> m b\n```", "```\nfmap :: (Functor f) => (a -> b) -> f a -> f b\n```", "```\nghci> liftM (*3) (Just 8)\nJust 24\nghci> fmap (*3) (Just 8)\nJust 24\nghci> runWriter $ liftM not $ Writer (True, \"chickpeas\")\n(False,\"chickpeas\")\nghci> runWriter $ fmap not $ Writer (True, \"chickpeas\")\n(False,\"chickpeas\")\nghci> runState (liftM (+100) pop) [1,2,3,4]\n(101,[2,3,4])\nghci> runState (fmap (+100) pop) [1,2,3,4]\n(101,[2,3,4])\n```", "```\nliftM :: (Monad m) => (a -> b) -> m a -> m b\nliftM f m = m >>= (\\x -> return (f x))\n```", "```\nliftM :: (Monad m) => (a -> b) -> m a -> m b\nliftM f m = do\n    x <- m\n    return (f x)\n```", "```\nghci> (+) <$> Just 3 <*> Just 5\nJust 8\nghci> (+) <$> Just 3 <*> Nothing\nNothing\n```", "```\n(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b\n```", "```\nap :: (Monad m) => m (a -> b) -> m a -> m b\nap mf m = do\n    f <- mf\n    x <- m\n    return (f x)\n```", "```\nghci> Just (+3) <*> Just 4\nJust 7\nghci> Just (+3) `ap` Just 4\nJust 7\nghci> [(+1),(+2),(+3)] <*> [10,11]\n[11,12,12,13,13,14]\nghci> [(+1),(+2),(+3)] `ap` [10,11]\n[11,12,12,13,13,14]\n```", "```\nliftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f x y = f <$> x <*> y\n```", "```\njoin :: (Monad m) => m (m a) -> m a\n```", "```\nghci> join (Just (Just 9))\nJust 9\nghci> join (Just Nothing)\nNothing ghci> join Nothing\nNothing\n```", "```\nghci> join [[1,2,3],[4,5,6]]\n[1,2,3,4,5,6]\n```", "```\nghci> runWriter $ join (Writer (Writer (1, \"aaa\"), \"bbb\"))\n(1,\"bbbaaa\")\n```", "```\nghci> join (Right (Right 9)) :: Either String Int\nRight 9\nghci> join (Right (Left \"error\")) :: Either String Int\nLeft \"error\"\nghci> join (Left \"error\") :: Either String Int\nLeft \"error\"\n```", "```\nghci> runState (join (state $ \\s -> (push 10, 1:2:s))) [0,0,0]\n((),[10,1,2,0,0,0])\n```", "```\njoin :: (Monad m) => m (m a) -> m a\njoin mm = do\n    m <- mm\n    m\n```", "```\njoinedMaybes :: Maybe Int\njoinedMaybes = do\n    m <- Just (Just 8)\n    m\n```", "```\nfilter :: (a -> Bool) -> [a] -> [a]\n```", "```\nfilterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]\n```", "```\nghci> filter (\\x -> x < 4) [9,1,5,2,10,3]\n[1,2,3]\n```", "```\nkeepSmall :: Int -> Writer [String] Bool\nkeepSmall x\n    | x < 4 = do\n        tell [\"Keeping \" ++ show x]\n        return True\n    | otherwise = do\n        tell [show x ++ \" is too large, throwing it away\"]\n        return False\n```", "```\nghci> fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]\n[1,2,3]\n```", "```\nghci> mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]\n9 is too large, throwing it away\nKeeping 1\n5 is too large, throwing it away\nKeeping 2\n10 is too large, throwing it away\nKeeping 3\n```", "```\n[1,2,3]\n[1,2]\n[1,3]\n[1]\n[2,3]\n[2]\n[3]\n[]\n```", "```\npowerset :: [a] -> [[a]]\npowerset xs = filterM (\\x -> [True, False]) xs\n```", "```\nghci> powerset [1,2,3]\n[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]\n```", "```\nfoldl :: (a -> b -> a) -> a -> [b] -> a\n```", "```\nfoldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a\n```", "```\nghci> foldl (\\acc x -> acc + x) 0 [2,8,3,1]\n14\n```", "```\nbinSmalls :: Int -> Int -> Maybe Int\nbinSmalls acc x\n    | x > 9     = Nothing\n    | otherwise = Just (acc + x)\n```", "```\nghci> foldM binSmalls 0 [2,8,3,1]\nJust 14\nghci> foldM binSmalls 0 [2,11,3,1]\nNothing\n```", "```\nimport Data.List\n\nsolveRPN :: String -> Double\nsolveRPN = head . foldl foldingFunction [] . words\n```", "```\nfoldingFunction :: [Double] -> String -> [Double]\nfoldingFunction (x:y:ys) \"*\" = (y * x):ys\nfoldingFunction (x:y:ys) \"+\" = (y + x):ys\nfoldingFunction (x:y:ys) \"-\" = (y - x):ys\nfoldingFunction xs numberString = read numberString:xs\n```", "```\nfoldingFunction :: [Double] -> String -> Maybe [Double]\n```", "```\nreadMaybe :: (Read a) => String -> Maybe a\nreadMaybe st = case reads st of [(x, \"\")] -> Just x\n                                _ -> Nothing\n```", "```\nghci> readMaybe \"1\" :: Maybe Int\nJust 1\nghci> readMaybe \"GOTO HELL\" :: Maybe Int\nNothing\n```", "```\nfoldingFunction :: [Double] -> String -> Maybe [Double]\nfoldingFunction (x:y:ys) \"*\" = return ((y * x):ys)\nfoldingFunction (x:y:ys) \"+\" = return ((y + x):ys)\nfoldingFunction (x:y:ys) \"-\" = return ((y - x):ys)\nfoldingFunction xs numberString = liftM (:xs) (readMaybe numberString)\n```", "```\nghci> foldingFunction [3,2] \"*\"\nJust [6.0]\nghci> foldingFunction [3,2] \"-\"\nJust [-1.0]\nghci> foldingFunction [] \"*\"\nNothing ghci> foldingFunction [] \"1\"\nJust [1.0]\nghci> foldingFunction [] \"1 wawawawa\"\nNothing\n```", "```\nimport Data.List\n\nsolveRPN :: String -> Maybe Double\nsolveRPN st = do\n    [result] <- foldM foldingFunction [] (words st)\n    return result\n```", "```\nghci> solveRPN \"1 2 * 4 +\"\nJust 6.0\nghci> solveRPN \"1 2 * 4 + 5 *\"\nJust 30.0\nghci> solveRPN \"1 2 * 4\"\nNothing ghci> solveRPN \"1 8 wharglbllargh\"\nNothing\n```", "```\nghci> let f = (+1) . (*100)\nghci> f 4\n401\nghci> let g = (\\x -> return (x+1)) <=< (\\x -> return (x*100))\nghci> Just 4 >>= g\nJust 401\n```", "```\nghci> let f = foldr (.) id [(+1),(*100),(+1)]\nghci> f 1\n201\n```", "```\nin3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight\n```", "```\ncanReachIn3 :: KnightPos -> KnightPos -> Bool\ncanReachIn3 start end = end `elem` in3 start\n```", "```\nimport Data.List\n\ninMany :: Int -> KnightPos -> [KnightPos]\ninMany x start = return start >>= foldr (<=<) return (replicate x moveKnight)\n```", "```\ncanReachIn :: Int -> KnightPos -> KnightPos -> Bool\ncanReachIn x start end = end `elem` inMany x start\n```", "```\n[(3,0.5),(5,0.25),(9,0.25)]\n```", "```\nghci> 1%4\n1 % 4\nghci> 1%2 + 1%2\n1 % 1\nghci> 1%3 + 5%4\n19 % 12\n```", "```\nghci> [(3,1%2),(5,1%4),(9,1%4)]\n[(3,1 % 2),(5,1 % 4),(9,1 % 4)]\n```", "```\nimport Data.Ratio\n\nnewtype Prob a = Prob { getProb :: [(a, Rational)] } deriving Show\n```", "```\ninstance Functor Prob where\n    fmap f (Prob xs) = Prob $ map (\\(x, p) -> (f x, p)) xs\n```", "```\nghci> fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])\nProb {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}\n```", "```\nthisSituation :: Prob (Prob Char)\nthisSituation = Prob\n    [(Prob [('a',1%2),('b',1%2)], 1%4)\n    ,(Prob [('c',1%2),('d',1%2)], 3%4)\n    ]\n```", "```\nflatten :: Prob (Prob a) -> Prob a\nflatten (Prob xs) = Prob $ concat $ map multAll xs\n    where multAll (Prob innerxs, p) = map (\\(x, r) -> (x, p*r)) innerxs\n```", "```\ninstance Monad Prob where\n    return x = Prob [(x,1%1)]\n    m >>= f = flatten (fmap f m)\n    fail _ = Prob []\n```", "```\ndata Coin = Heads | Tails deriving (Show, Eq)\n\ncoin :: Prob Coin\ncoin = Prob [(Heads,1%2),(Tails,1%2)]\n\nloadedCoin :: Prob Coin\nloadedCoin = Prob [(Heads,1%10),(Tails,9%10)]\n```", "```\nimport Data.List (all)\n\nflipThree :: Prob Bool\nflipThree = do\n    a <- coin\n    b <- coin\n    c <- loadedCoin\n    return (all (==Tails) [a,b,c])\n```", "```\nghci> getProb flipThree\n[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),\n  (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]\n```"]