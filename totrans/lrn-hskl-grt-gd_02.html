<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Believe the Type"><div class="titlepage"><div><div><h1 class="title"><a id="believe_the_type"/>Chapter 2. Believe the Type</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e2497"/><img src="httpatomoreillycomsourcenostarchimages802524.png.jpg" alt="image with no caption"/></div></div><p>One of Haskell’s greatest strengths is its powerful type system.<a id="IDX-CHP-2-0001" class="indexterm"/></p><p>In Haskell, every expression’s type is known at compile time, which leads to safer code. If you write a program that tries to divide a Boolean type with a number, it won’t compile. This is good because it’s better to catch those kinds of errors at compile time, rather than having your program crash later on. Everything in Haskell has a type, so the compiler can reason quite a lot about your program before compiling it.</p><p>Unlike Java or Pascal, Haskell has type inference. If we write a number, for example, we don’t need to tell Haskell it’s a number, because it can infer that on its own.<a id="IDX-CHP-2-0002" class="indexterm"/></p><p>So far, we’ve covered some of the basics of Haskell with only a very superficial glance at types, but understanding the type system is a very important part of learning Haskell.</p><div class="sect1" title="Explicit Type Declaration"><div class="titlepage"><div><div><h1 class="title"><a id="explicit_type_declaration"/>Explicit Type Declaration</h1></div></div></div><p>We can use GHCi to examine the types of some expressions. We’ll do that by using the <code class="literal">:t</code> command which, followed by any valid expression, tells us its type. Let’s give it a whirl:<a id="IDX-CHP-2-0003" class="indexterm"/><a id="IDX-CHP-2-0004" class="indexterm"/><a id="IDX-CHP-2-0005" class="indexterm"/><a id="IDX-CHP-2-0006" class="indexterm"/><a id="IDX-CHP-2-0007" class="indexterm"/><a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/><a id="IDX-CHP-2-0010" class="indexterm"/><a id="IDX-CHP-2-0011" class="indexterm"/><a id="IDX-CHP-2-0012" class="indexterm"/><a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/></p><a id="I_programlisting2_d1e2575"/><pre class="programlisting">ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool</pre><p>The <code class="literal">::</code> operator here is read as “has type of.” Explicit types are always denoted with the first letter in uppercase. <code class="literal">'a'</code> has a type of <code class="literal">Char</code>, which stands for <span class="emphasis"><em>character</em></span>. <code class="literal">True</code> is a <code class="literal">Bool</code>, or a Boolean type. <code class="literal">"HELLO!"</code>, which is a string, shows its type as <code class="literal">[Char]</code>. The square brackets denote a list, so we read that as it being a list of characters. Unlike lists, each tuple length has its own type. So the tuple <code class="literal">(True, 'a')</code> has a type of <code class="literal">(Bool, Char)</code>, and <code class="literal">('a','b','c')</code> has a type of <code class="literal">(Char, Char, Char)</code>. <code class="literal">4 == 5</code> will always return <code class="literal">False</code>, so its type is <code class="literal">Bool</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e2627"/><img src="httpatomoreillycomsourcenostarchimages802526.png.jpg" alt="image with no caption"/></div></div><p>Functions also have types. When writing our own functions, we can choose to give them an explicit type declaration. This is generally considered to be good practice (except when writing very short functions). From here on, we’ll give all the functions that we make type declarations.<a id="IDX-CHP-2-0015" class="indexterm"/></p><p>Remember the list comprehension we made in <a class="xref" href="ch01.html" title="Chapter 1. Starting Out">Chapter 1</a>—the one that filters out a string’s lowercase letters? Here’s how it looks with a type declaration:</p><a id="I_programlisting2_d1e2641"/><pre class="programlisting">removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']]</pre><p>The <code class="literal">removeNonUppercase</code> function has a type of <code class="literal">[Char] -&gt; [Char]</code>, meaning that it takes one string as a parameter and returns another as a result.</p><p>But how do we specify the type of a function that takes several parameters? Here’s a simple function that takes three integers and adds them together:<a id="IDX-CHP-2-0016" class="indexterm"/><a id="IDX-CHP-2-0017" class="indexterm"/><a id="IDX-CHP-2-0018" class="indexterm"/><a id="IDX-CHP-2-0019" class="indexterm"/><a id="IDX-CHP-2-0020" class="indexterm"/><a id="IDX-CHP-2-0021" class="indexterm"/><a id="IDX-CHP-2-0022" class="indexterm"/><a id="IDX-CHP-2-0023" class="indexterm"/><a id="IDX-CHP-2-0024" class="indexterm"/></p><a id="I_programlisting2_d1e2690"/><pre class="programlisting">addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z</pre><p>The parameters and the return type are separated by <code class="literal">-&gt;</code> characters, with the return type always coming last in the declaration. (In <a class="xref" href="ch05.html" title="Chapter 5. Higher-Order Functions">Chapter 5</a>, you’ll see why they’re all separated with <code class="literal">-&gt;</code>, instead of having a more explicit distinction.)</p><p>If you want to give your function a type declaration, but are unsure as to what it should be, you can always just write the function without it, and then check it with <code class="literal">:t</code>. Since functions are expressions, <code class="literal">:t</code> works on them in the same way as you saw at the beginning of this section.</p></div></div>
<div class="sect1" title="Common Haskell Types"><div class="titlepage"><div><div><h1 class="title"><a id="common_haskell_types"/>Common Haskell Types</h1></div></div></div><p>Let’s take a look at some common Haskell types, which are used for representing basic things like numbers, characters, and Boolean values. Here’s an overview:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">Int</code> stands for integer. It’s used for whole numbers. <code class="literal">7</code> can be an <code class="literal">Int</code>, but <code class="literal">7.2</code> cannot. <code class="literal">Int</code> is <span class="emphasis"><em>bounded</em></span>, which means that it has a minimum value and a maximum value.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We’re using the GHC compiler, where the range of <code class="literal">Int</code> is determined by the size of a machine word on your computer. So if you have a 64-bit CPU, it’s likely that the lowest <code class="literal">Int</code> on your system is -2<sup>63</sup>, and the highest is 2<sup>63</sup>.</p></div></li><li class="listitem"><p><code class="literal">Integer</code> is also used to store integers, but it’s not bounded, so it can be used to represent really big numbers. (And I mean <span class="emphasis"><em>really</em></span> big!) However, <code class="literal">Int</code> is more efficient. As an example, try saving the following function to a file:</p><a id="I_programlisting2_d1e2763"/><pre class="programlisting">factorial :: Integer -&gt; Integer
factorial n = product [1..n]</pre><p>Then load it into GHCi with <code class="literal">:l</code> and test it:</p><a id="I_programlisting2_d1e2770"/><pre class="programlisting">ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000</pre></li><li class="listitem"><p><code class="literal">Float</code> is a real floating-point number with single precision. Add the following function to the file you’ve been working in:</p><a id="I_programlisting2_d1e2777"/><pre class="programlisting">circumference :: Float -&gt; Float
circumference r = 2 * pi * r</pre><p>Then load and test it:<a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/><a id="IDX-CHP-2-0028" class="indexterm"/><a id="IDX-CHP-2-0029" class="indexterm"/><a id="IDX-CHP-2-0030" class="indexterm"/><a id="IDX-CHP-2-0031" class="indexterm"/><a id="IDX-CHP-2-0032" class="indexterm"/><a id="IDX-CHP-2-0033" class="indexterm"/><a id="IDX-CHP-2-0034" class="indexterm"/><a id="IDX-CHP-2-0035" class="indexterm"/></p><a id="I_programlisting2_d1e2825"/><pre class="programlisting">ghci&gt; circumference 4.0
25.132742</pre></li><li class="listitem"><p><code class="literal">Double</code> is a real floating-point number with double the precision. Double-precision numeric types use twice as many bits to represent numbers. The extra bits increase their precision at the cost of hogging more memory. Here’s another function to add to your file:</p><a id="I_programlisting2_d1e2832"/><pre class="programlisting">circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r</pre><p>Now load and test it. Pay particular attention to the difference in precision between <code class="literal">circumference</code> and <code class="literal">circumference'</code>.</p><a id="I_programlisting2_d1e2842"/><pre class="programlisting">ghci&gt; circumference' 4.0
25.132741228718345</pre></li><li class="listitem"><p><code class="literal">Bool</code> is a Boolean type. It can have only two values: <code class="literal">True</code> and <code class="literal">False</code>.</p></li><li class="listitem"><p><code class="literal">Char</code> represents a Unicode character. It’s denoted by single quotes. A list of characters is a string.</p></li><li class="listitem"><p>Tuples are types, but their definition depends on their length as well as the types of their components. So, theoretically, there is an infinite number of tuple types. (In practice, tuples can have at most 62 elements—far more than you’ll ever need.) Note that the empty tuple <code class="literal">()</code> is also a type, which can have only a single value: <code class="literal">()</code>.</p></li></ul></div></div>
<div class="sect1" title="Type Variables"><div class="titlepage"><div><div><h1 class="title"><a id="type_variables"/>Type Variables</h1></div></div></div><p>It makes sense for some functions to be able to operate on various types. For instance, the <code class="literal">head</code> function takes a list and returns the head element of that list. It doesn’t really matter if the list contains numbers, characters, or even more lists! The function should be able to work with lists that contain just about anything.</p><p>What do you think the type of the <code class="literal">head</code> function is? Let’s check with the <code class="literal">:t</code> function:</p><a id="I_programlisting2_d1e2885"/><pre class="programlisting">ghci&gt; :t head
head :: [a] -&gt; a</pre><p>What is this <code class="literal">a</code>? Remember that type names start with capital letters, so it can’t be a type. This is actually an example of a <span class="emphasis"><em>type variable</em></span>, which means that <code class="literal">a</code> can be of any type.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e2899"/><img src="httpatomoreillycomsourcenostarchimages802528.png.jpg" alt="image with no caption"/></div></div><p>Type variables allow functions to operate on values of various types in a type-safe manner. This is a lot like <span class="emphasis"><em>generics</em></span> in other programming languages. However, Haskell’s version is much more powerful, since it allows us to easily write very general functions.<a id="IDX-CHP-2-0036" class="indexterm"/><a id="IDX-CHP-2-0037" class="indexterm"/><a id="IDX-CHP-2-0038" class="indexterm"/><a id="IDX-CHP-2-0039" class="indexterm"/><a id="IDX-CHP-2-0040" class="indexterm"/></p><p>Functions that use type variables are called <span class="emphasis"><em>polymorphic functions</em></span>. The type declaration of <code class="literal">head</code> states that it takes a list of any type and returns one element of that type.<a id="IDX-CHP-2-0041" class="indexterm"/><a id="IDX-CHP-2-0042" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although type variables can have names that are longer than one character, we usually give them names like <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, <code class="literal">d</code>, and so on.</p></div><p>Remember <code class="literal">fst</code>? It returns the first item in a pair. Let’s examine its type:</p><a id="I_programlisting2_d1e2962"/><pre class="programlisting">ghci&gt; :t fst
fst :: (a, b) -&gt; a</pre><p>You can see that <code class="literal">fst</code> takes a tuple and returns an element that is of the same type as its first item. That’s why we can use <code class="literal">fst</code> on a pair that contains items of any two types. Note that even though <code class="literal">a</code> and <code class="literal">b</code> are different type variables, they don’t necessarily need to be different types. This just means that the first item’s type and the return value’s type will be the same.</p></div>
<div class="sect1" title="Type Classes 101"><div class="titlepage"><div><div><h1 class="title"><a id="type_classes_101"/>Type Classes 101</h1></div></div></div><p>A <span class="emphasis"><em>type class</em></span> is an interface that defines some behavior. If a type is an <span class="emphasis"><em>instance</em></span> of a type class, then it supports and implements the behavior the type class describes.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e2991"/><img src="httpatomoreillycomsourcenostarchimages802530.png.jpg" alt="image with no caption"/></div></div><p>More specifically, a type class specifies a bunch of functions, and when we decide to make a type an instance of a type class, we define what those functions mean for that type.</p><p>A type class that defines equality is a good example. The values of many types can be compared for equality by using the <code class="literal">==</code> operator. Let’s check the type signature of this operator:</p><a id="I_programlisting2_d1e3003"/><pre class="programlisting">ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</pre><p>Note that the equality operator (<code class="literal">==</code>) is actually a function. So are <code class="literal">+</code>, <code class="literal">*</code>, <code class="literal">-</code>, <code class="literal">/</code>, and almost every other operator. If a function is composed of only special characters, it’s considered an infix function by default. If we want to examine its type, pass it to another function, or call it as a prefix function, we need to surround it in parentheses, as in the preceding example.<a id="IDX-CHP-2-0043" class="indexterm"/><a id="IDX-CHP-2-0044" class="indexterm"/><a id="IDX-CHP-2-0045" class="indexterm"/><a id="IDX-CHP-2-0046" class="indexterm"/><a id="IDX-CHP-2-0047" class="indexterm"/><a id="IDX-CHP-2-0048" class="indexterm"/><a id="IDX-CHP-2-0049" class="indexterm"/><a id="IDX-CHP-2-0050" class="indexterm"/></p><p>This example shows something new: the <code class="literal">=&gt;</code> symbol. Everything before this symbol is called a <span class="emphasis"><em>class constraint</em></span>. We can read this type declaration like this: The equality function takes any two values that are of the same type and returns a <code class="literal">Bool</code>. The type of those two values must be an instance of the <code class="literal">Eq</code> class.<a id="IDX-CHP-2-0051" class="indexterm"/></p><p>The <code class="literal">Eq</code> type class provides an interface for testing for equality. If it makes sense for two items of a particular type to be compared for equality, then that type can be an instance of the <code class="literal">Eq</code> type class. All standard Haskell types (except for input/output types and functions) are instances of <code class="literal">Eq</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>It’s important to note that type classes are <span class="emphasis"><em>not</em></span> the same as classes in object-oriented programming languages.</p></div><p>Let’s look at some of the most common Haskell type classes, which enable our types to be easily compared for equality and order, printed as strings, and so on.</p><div class="sect2" title="The Eq Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_eq_type_class"/>The Eq Type Class</h2></div></div></div><p>As we’ve discussed, <code class="literal">Eq</code> is used for types that support equality testing. The functions its instances implement are <code class="literal">==</code> and <code class="literal">/=</code>. This means that if there’s an <code class="literal">Eq</code> class constraint for a type variable in a function, it uses <code class="literal">==</code> or <code class="literal">/=</code> somewhere inside its definition. When a type implements a function, that means it defines what the function does when used with that particular type. Here are some examples of performing these operations on various instances of <code class="literal">Eq</code>:<a id="IDX-CHP-2-0052" class="indexterm"/></p><a id="I_programlisting2_d1e3124"/><pre class="programlisting">ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True</pre></div><div class="sect2" title="The Ord Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_ord_type_class"/>The Ord Type Class</h2></div></div></div><p><code class="literal">Ord</code> is a type class for types whose values can be put in some order. For example, let’s look at the type of the greater-than (<code class="literal">&gt;</code>) operator:</p><a id="I_programlisting2_d1e3136"/><pre class="programlisting">ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool</pre><p>The type of <code class="literal">&gt;</code> is similar to the type of <code class="literal">==</code>. It takes two items as parameters and returns a <code class="literal">Bool</code>, which tells us if some relation between those two things holds or not.<a id="IDX-CHP-2-0053" class="indexterm"/><a id="IDX-CHP-2-0054" class="indexterm"/><a id="IDX-CHP-2-0055" class="indexterm"/><a id="IDX-CHP-2-0056" class="indexterm"/><a id="IDX-CHP-2-0057" class="indexterm"/><a id="IDX-CHP-2-0058" class="indexterm"/><a id="IDX-CHP-2-0059" class="indexterm"/><a id="IDX-CHP-2-0060" class="indexterm"/><a id="IDX-CHP-2-0061" class="indexterm"/><a id="IDX-CHP-2-0062" class="indexterm"/></p><p>All the types we’ve covered so far (again, except for functions) are instances of <code class="literal">Ord</code>. <code class="literal">Ord</code> covers all the standard comparison functions such as <code class="literal">&gt;</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;=</code>, and <code class="literal">&lt;=</code>.</p><p>The <code class="literal">compare</code> function takes two values whose type is an <code class="literal">Ord</code> instance and returns an <code class="literal">Ordering</code>. <code class="literal">Ordering</code> is a type that can be <code class="literal">GT</code>, <code class="literal">LT</code>, or <code class="literal">EQ</code>, which represent greater than, lesser than, or equal, respectively.</p><a id="I_programlisting2_d1e3235"/><pre class="programlisting">ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
ghci&gt; 'b' &gt; 'a'
True</pre></div><div class="sect2" title="The Show Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_show_type_class"/>The Show Type Class</h2></div></div></div><p>Values whose types are instances of the <code class="literal">Show</code> type class can be represented as strings. All the types we’ve covered so far (except for functions) are instances of <code class="literal">Show</code>. The most commonly used function that operates on instances of this type class is <code class="literal">show</code>, which prints the given value as a string:</p><a id="I_programlisting2_d1e3251"/><pre class="programlisting">ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"</pre></div><div class="sect2" title="The Read Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_read_type_class"/>The Read Type Class</h2></div></div></div><p><code class="literal">Read</code> can be considered the opposite type class of <code class="literal">Show</code>. Again, all the types we’ve covered so far are instances of this type class. The <code class="literal">read</code> function takes a string and returns a value whose type is an instance of <code class="literal">Read</code>:</p><a id="I_programlisting2_d1e3269"/><pre class="programlisting">ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]</pre><p>So far so good. But what happens if we try entering <code class="literal">read "4"</code>?<a id="IDX-CHP-2-0063" class="indexterm"/><a id="IDX-CHP-2-0064" class="indexterm"/><a id="IDX-CHP-2-0065" class="indexterm"/><a id="IDX-CHP-2-0066" class="indexterm"/><a id="IDX-CHP-2-0067" class="indexterm"/></p><a id="I_programlisting2_d1e3295"/><pre class="programlisting">ghci&gt; read "4"
&lt;interactive&gt;:1:0:
    Ambiguous type variable 'a' in the constraint:
      'Read a' arising from a use of 'read' at &lt;interactive&gt;:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)</pre><p>GHCi is telling us that it doesn’t know what we want in return. Notice that in the previous uses of <code class="literal">read</code>, we did something with the result afterward, which let GHCi infer the kind of result we wanted. If we used it as a Boolean, for example, it knew it had to return a <code class="literal">Bool</code>. But now it knows we want some type that is part of the <code class="literal">Read</code> class, but it doesn’t know which one. Let’s take a look at the type signature of <code class="literal">read</code>:</p><a id="I_programlisting2_d1e3311"/><pre class="programlisting">ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a</pre><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">String</code> is just another name for <code class="literal">[Char]</code>. <code class="literal">String</code> and <code class="literal">[Char]</code> can be used interchangeably, but we’ll mostly be sticking to <code class="literal">String</code> from now on because it’s easier to write and more readable.</p></div><p>We can see that the <code class="literal">read</code> function returns a value whose type is an instance of <code class="literal">Read</code>, but if we use that result in some way, it has no way of knowing which type. To solve this problem, we can use <span class="emphasis"><em>type annotations</em></span>.</p><p>Type annotations are a way to explicitly tell Haskell what the type of an expression should be. We do this by adding <code class="literal">::</code> to the end of the expression and then specifying a type:</p><a id="I_programlisting2_d1e3346"/><pre class="programlisting">ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')</pre><p>The compiler can infer the type of most expressions by itself. However, sometimes the compiler doesn’t know whether to return a value of type <code class="literal">Int</code> or <code class="literal">Float</code> for an expression like <code class="literal">read "5"</code>. To see what the type is, Haskell would need to actually evaluate <code class="literal">read "5"</code>. But since Haskell is a statically typed language, it needs to know all the types before the code is compiled (or in the case of GHCi, evaluated). So we need to tell Haskell, “Hey, this expression should have this type, in case you didn’t know!”<a id="IDX-CHP-2-0068" class="indexterm"/><a id="IDX-CHP-2-0069" class="indexterm"/><a id="IDX-CHP-2-0070" class="indexterm"/><a id="IDX-CHP-2-0071" class="indexterm"/><a id="IDX-CHP-2-0072" class="indexterm"/><a id="IDX-CHP-2-0073" class="indexterm"/></p><p>We can give Haskell only the minimum amount of information it needs to figure out which type of value <code class="literal">read</code> should return. For instance, if we’re using <code class="literal">read</code> and then cramming its result into a list, Haskell can use the list to figure out which type we want by looking at the other elements of the list:</p><a id="I_programlisting2_d1e3394"/><pre class="programlisting">ghci&gt; [read "True", False, True, False]
[True, False, True, False]</pre><p>Since we used <code class="literal">read "True"</code> as an element in a list of <code class="literal">Bool</code> values, Haskell sees that the type of <code class="literal">read "True"</code> must also be <code class="literal">Bool</code>.</p></div><div class="sect2" title="The Enum Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_enum_type_class"/>The Enum Type Class</h2></div></div></div><p><code class="literal">Enum</code> instances are sequentially ordered types—their values can be enumerated. The main advantage of the <code class="literal">Enum</code> type class is that we can use its values in list ranges. They also have defined successors and predecessors, which we can get with the <code class="literal">succ</code> and <code class="literal">pred</code> functions. Some examples of types in this class are <code class="literal">()</code>, <code class="literal">Bool</code>, <code class="literal">Char</code>, <code class="literal">Ordering</code>, <code class="literal">Int</code>, <code class="literal">Integer</code>, <code class="literal">Float</code>, and <code class="literal">Double</code>.</p><a id="I_programlisting2_d1e3451"/><pre class="programlisting">ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ 'B'
'C'</pre></div><div class="sect2" title="The Bounded Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_bounded_type_class"/>The Bounded Type Class</h2></div></div></div><p>Instances of the <code class="literal">Bounded</code> type class have an upper bound and a lower bound, which can be checked by using the <code class="literal">minBound</code> and <code class="literal">maxBound</code> functions:</p><a id="I_programlisting2_d1e3467"/><pre class="programlisting">ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False</pre><p>The <code class="literal">minBound</code> and <code class="literal">maxBound</code> functions are interesting because they have a type of <code class="literal">(Bounded a) =&gt; a</code>. In a sense, they are polymorphic constants.</p><p>Note that tuples whose components are all instances of <code class="literal">Bounded</code> are also considered to be instances of <code class="literal">Bounded</code> themselves:<a id="IDX-CHP-2-0074" class="indexterm"/><a id="IDX-CHP-2-0075" class="indexterm"/><a id="IDX-CHP-2-0076" class="indexterm"/><a id="IDX-CHP-2-0077" class="indexterm"/></p><a id="I_programlisting2_d1e3504"/><pre class="programlisting">ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')</pre></div><div class="sect2" title="The Num Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_num_type_class"/>The Num Type Class</h2></div></div></div><p><code class="literal">Num</code> is a numeric type class. Its instances can act like numbers. Let’s examine the type of a number:</p><a id="I_programlisting2_d1e3513"/><pre class="programlisting">ghci&gt; :t 20
20 :: (Num t) =&gt; t</pre><p>It appears that whole numbers are also polymorphic constants. They can act like any type that’s an instance of the <code class="literal">Num</code> type class (<code class="literal">Int</code>, <code class="literal">Integer</code>, <code class="literal">Float</code>, or <code class="literal">Double</code>):</p><a id="I_programlisting2_d1e3532"/><pre class="programlisting">ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0</pre><p>For example, we can examine the type of the <code class="literal">*</code> operator:</p><a id="I_programlisting2_d1e3539"/><pre class="programlisting">ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a</pre><p>This shows that <code class="literal">*</code> accepts two numbers and returns a number of the same type. Because of this type constraint, <code class="literal">(5 :: Int) * (6 :: Integer)</code> will result in a type error, while <code class="literal">5 * (6 :: Integer)</code> will work just fine. <code class="literal">5</code> can act like either an <code class="literal">Integer</code> or an <code class="literal">Int</code>, but not both at the same time.</p><p>To be an instance of <code class="literal">Num</code>, a type must already be in <code class="literal">Show</code> and <code class="literal">Eq</code>.</p></div><div class="sect2" title="The Floating Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_floating_type_class"/>The Floating Type Class</h2></div></div></div><p>The <code class="literal">Floating</code> type class includes the <code class="literal">Float</code> and <code class="literal">Double</code> types, which are used to store floating-point numbers.</p><p>Functions that take and return values that are instances of the <code class="literal">Floating</code> type class need their results to be represented with floating-point numbers in order to do meaningful computations. Some examples are <code class="literal">sin</code>, <code class="literal">cos</code>, and <code class="literal">sqrt</code>.</p></div><div class="sect2" title="The Integral Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_integral_type_class"/>The Integral Type Class</h2></div></div></div><p><code class="literal">Integral</code> is another numeric type class. While <code class="literal">Num</code> includes all numbers, including real number integers, the <code class="literal">Integral</code> class includes <span class="emphasis"><em>only</em></span> integral (whole) numbers. This type class includes the <code class="literal">Int</code> and <code class="literal">Integer</code> types.<a id="IDX-CHP-2-0078" class="indexterm"/><a id="IDX-CHP-2-0079" class="indexterm"/></p><p>One particularly useful function for dealing with numbers is <code class="literal">fromIntegral</code>. It has the following type declaration:</p><a id="I_programlisting2_d1e3637"/><pre class="programlisting">fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Notice that <code class="literal">fromIntegral</code> has several class constraints in its type signature. That’s completely valid—multiple class constraints are separated by commas inside the parentheses.</p></div><p>From its type signature, we can see that <code class="literal">fromIntegral</code> takes an integral number and turns it into a more general number. This is very useful when you want integral and floating-point types to work together nicely. For instance, the <code class="literal">length</code> function has this type declaration:</p><a id="I_programlisting2_d1e3653"/><pre class="programlisting">length :: [a] -&gt; Int</pre><p>This means that if we try to get the length of a list and add it to <code class="literal">3.2</code>, we’ll get an error (because we tried to add an <code class="literal">Int</code> to a floating-point number). To get around this, we can use <code class="literal">fromIntegral</code>, like this:</p><a id="I_programlisting2_d1e3666"/><pre class="programlisting">ghci&gt; fromIntegral (length [1,2,3,4]) + 3.2
7.2</pre></div><div class="sect2" title="Some Final Notes on Type Classes"><div class="titlepage"><div><div><h2 class="title"><a id="some_final_notes_on_type_classes"/>Some Final Notes on Type Classes</h2></div></div></div><p>Because a type class defines an abstract interface, one type can be an instance of many type classes, and one type class can have many types as instances. For example, the <code class="literal">Char</code> type is an instance of many type classes, two of them being <code class="literal">Eq</code> and <code class="literal">Ord</code>, because we can check if two characters are equal as well as compare them in alphabetical order.<a id="IDX-CHP-2-0080" class="indexterm"/></p><p>Sometimes a type must first be an instance of one type class to be allowed to become an instance of another. For example, to be an instance of <code class="literal">Ord</code>, a type must first be an instance of <code class="literal">Eq</code>. In other words, being an instance of <code class="literal">Eq</code> is a <span class="emphasis"><em>prerequisite</em></span> for being an instance of <code class="literal">Ord</code>. This makes sense if you think about it, because if you can compare two things for ordering, you should also be able to tell if those things are equal.</p></div></div></body></html>