- en: Chapter 6. Functionalism with Blocks and Procs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ruby has two main ancestors: Smalltalk and Lisp.^([[16](#ftn.CHP-6-FNOTE-1)])
    From Smalltalk, Ruby gets its heavy object orientation, which we’ve explored in
    some depth up to this point. From Lisp it derives several ideas from *functional
    programming*, which is a very mathematically inclined approach to programming
    with a few notable characteristics. First, variables tend to be defined once,
    without having their values changed later on. Additionally, functions tend to
    be simple, abstract, and used as building blocks for other functions; the line
    between *functions*, which perform operations, and *data*, on which functions
    operate, is often blurry, compared with non-functional approaches. Functions also
    tend to do their work by returning values, rather than having side effects—in
    Ruby terms, methods that end with an exclamation point are less common.'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s support for functional programming is extensive and exciting. Let’s dive
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '#20 Our First lambda (make_incrementer.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script explores how Ruby creates functions that should be treated as objects.
    Every “thing” in Ruby is an object, so the notion of treating functions as objects
    is not conceptually odd. In Ruby, we do this with the command `lambda`, which
    takes a block. Let’s look at that in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see by the return value of line one that the result of calling `lambda`
    is an instance of class *Proc*. Proc is short for *procedure*, and while most
    objects are defined by what they *are*, Procs can be thought of primarily as defined
    by what they *do*. Procs have a method called *call*, which tells that Proc instance
    to do whatever it does. In our irb example, we have a Proc instance called `double_me`
    that takes an argument and returns that argument, times two. On line two, we see
    that feeding the number *5* into `double_me.call` results in a return value of
    *10*, just as you would expect. It is easy to create other Procs that do other
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since Procs are objects, just like everything else in Ruby, we can treat them
    like any other object. They can be the returned value of a method, either the
    key or value of a Hash, arguments to other methods, and whatever else any object
    can be. Let’s look at the script that demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At ❶ we define a method called `make_incrementer`. It takes a single argument
    called `delta` and returns a Proc (created via `lambda`) that adds `delta` to
    something else, represented by *`x`*. What is that something else? We don’t know
    yet. That is precisely the point of this method—it allows us to define an operation
    that can be performed multiple times using different parameters, just like any
    other function.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how this is useful in the rest of this script. At ❷ we define a new
    Hash called `incrementer_proc_of`. For each of the values `10` and `20`, we make
    an incrementer (using either `10` or `20` for the value of `delta` in the `make_incrementer`
    method) and assign the resulting Proc into the `incrementer_proc_of` Hash. Starting
    at ❸, we read each `delta` and Proc pair out of the Hash using the `each_pair`
    method and then use `puts` to print a line describing that `delta` value and the
    result of calling its Proc with the argument of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: We ❹ print a spacer with `puts` (just for ease of reading the output), and finally
    ❺ output another set of data. This time we add another loop for a value called
    `other_addend`; this is a variable that serves a role analogous to our static
    value of `5` in the loop (❸). Let’s run this program with `ruby -w make_incrementer.rb`
    and look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines before the empty line show the output of the first loop
    (with the static value of `5` for the addend), while the rest of the output shows
    the result of the second loop, which uses the `other_addend` variable. Notice
    also that `each_pair` does not order by key, which is why my output has the delta
    value of `20` appearing first. Depending on your implementation of Ruby, you might
    see a `delta` of `10` first.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to create Procs. Let’s learn how to use them for something
    more useful than just demonstrating themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#CHP-6-FNOTE-1)]) This is a potentially contentious statement. At a
    RubyConf, I once asked Matz which other languages he thought were most influential
    on Ruby. His response was “Smalltalk and Common Lisp”. Other folks in the Ruby
    community (many of them ex-Perl users) stress Ruby’s clear similarity to Perl.
    Probably the safest statement is that Ruby descends from Smalltalk and Lisp, and
    while it’s a lot like Perl, Perl is more like an aunt or uncle.
  prefs: []
  type: TYPE_NORMAL
- en: '#21 Using Procs for Filtering (matching_members.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve seen that to create a Proc, we call `lambda` with a block describing
    what that Proc should do. This would lead you to believe that there is a special
    relationship between Procs and blocks, which there is. Our next script demonstrates
    how to use Procs in place of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this script, we open the Array class in order to add a new method called
    `matching_members` (❶). It takes a Proc (creatively called `some_proc`—see the
    note below) as an argument and returns the result of calling `find_all`, which
    (as its name suggests) finds all members for which the block is true. In this
    case, the condition in the block is the result of calling the Proc argument on
    the Array with the Array member in question as the argument to `call`. After we
    finish defining our new method, we set up our `digits` Array and our Procs with
    appropriate names in the `lambdas` Hash at ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some of my co-workers make fun of the variable and method names I use—like
    *`some_proc`*, for example. I think names should either be very specific, like
    *`save_rates_to_local_file!`*, or explicitly generic, like *`some_proc`*. For
    truly generic operations, I often use variable names like *`any_proc`* or *`any_hash`*,
    which tell you explicitly that the operations being performed on them are meant
    to be useful for any Proc or Hash*.'
  prefs: []
  type: TYPE_NORMAL
- en: At ❸, we loop through each sorted `lambda_name`, and at ❹ we extract each Proc
    out as a variable called `lambda_proc`. We then `find_all` members of the `digits`
    Array that match the condition described by that Proc at ❺ and `puts` an appropriate
    message at ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see it in action with `ruby -w matching_members.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we filter the members of the `digits` Array based on some specific
    conditions. Hopefully, you’ll find that the names I chose for each Proc match
    what that Proc does. The `five+` Proc returns `true` for any argument that is
    five or greater.^([[17](#ftn.CHP-6-FNOTE-2)]) We see that the results of calling
    `five+` on each digit in turn returns the correct digits. Similarly, the `is_even`
    Proc filters its input, only returning `true` for arguments that are even, where
    *evenness* is defined as having a modulus two equal to zero. Again, we get the
    correct numbers.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we want to filter based on multiple criteria? We could filter
    once with one Proc, assign that result into an Array, and then filter that result
    by the second criterion. That’s perfectly valid, but what if we have an unknown
    number of filtering conditions? We want a version of `matching_members` that can
    take an arbitrary number of Procs. That’s our next script.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#CHP-6-FNOTE-2)]) It does this by implicit Boolean evaluation of the
    expression `i >= 5`.
  prefs: []
  type: TYPE_NORMAL
- en: '#22 Using Procs for Compounded Filtering (matching_compound_members.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this script, we’ll filter Arrays using an arbitrary number of Procs. As before,
    we’ll open up the Array class, this time adding two methods. Again, we’ll filter
    digits based on simple mathematical tests. Let’s take a look at the source code
    and see what’s different.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by defining a method called `matching_members` (❶), just as before.
    However, this time our argument is called `some_block` instead of `some_proc`,
    and it is preceded by an ampersand. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Blocks, Procs, and the Ampersand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ampersand (`&`) is Ruby’s way of expressing blocks and Procs in terms of
    each other. It’s very useful for arguments to methods, as you might imagine. *Blocks*,
    you may remember, are simply bits of code between delimiters such as braces (`{
    “I’m a block!” }`) or the `do` and `end` keywords (`do “I’m also a block!” end`).
    *Procs* are objects made from blocks via the `lambda` method. Either of them can
    be passed into methods, and the ampersand is the way to use one as the other.
    Let’s test this in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We open the Array class and add a method called `matches_block`; this method
    takes a block (with an ampersand prefix), effectively duplicating the behavior
    of the existing `find_all` method, which it calls. We also add another method
    called `matches_proc` that calls `find_all` again, but takes a Proc this time.
    Then we try them out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `matches_block` method dutifully takes a block and passes it along to the
    `find_all` method, transforming it along the way with the ampersand—once on input
    and again when passed to `find_all`. The `matches_proc` method takes a Proc and
    passes that on to `find_all`, but it only needs to transform with the ampersand
    once.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that we could omit the ampersand and just treat a block argument
    as a standard variable, like in irb below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That doesn’t work, as you see. Ruby keeps track of the number of arguments that
    a given method, block, or Proc expects (a concept called *arity*) and complains
    when there is a mismatch. Our irb example expected a “real” argument, not just
    a block, and complained when it didn’t get one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The gist of the ArgumentError is that blocks are akin to “partial” or “unborn”
    blocks and need the *`lambda`* method to be made into full-fledged Procs, which
    can be used as real arguments to methods. Some methods, like *`find_all`*, can
    handle block arguments, but these block arguments are treated differently than
    regular arguments and don’t count toward the number of “real” arguments. We’ll
    cover this later when we discuss the *`willow_and_anya.rb`* script. For now, note
    that our new version of *`matching_members`* takes a block instead of a Proc*.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with Each Proc via map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also define a new method called `matching_compound_members` at ❷. The `matching_compound_members`
    method takes an Array argument called `procs_array` and maps a call to `matching_members`
    onto each of `procs_array`’s Proc elements; this transforms the elements into
    blocks with the ampersand at ❸ while doing the mapping. This results in an Array,
    each of whose members is an Array containing all members of the original Array
    that match the conditions defined by the Proc. Confused? Take a look in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On lines one through seven, we add a shortened version of `matching_members`
    to all Arrays. We call it on line eight, and find that the result is an Array
    of Arrays. The first sub-array is all digits greater than five—the result of the
    first Proc. The second sub-array is all even digits—the result of the second Proc.
    That’s what we have at the end of the `map` (❹) inside `matching_compound_members`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Intersections with inject
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t stop there. Next we call our old friend the `inject` method on that
    Array of Arrays. You may remember that `inject` performs an operation successively
    and has a memory for intermediate results. That will be very useful for us. The
    `inject` method takes an optional non-block element for the initial state of its
    memory. In our script we use `self` (❹), meaning that the memory state will be
    the `self` Array as it exists prior to any filtering. We also say that each member
    of the Array resulting from the `map` operation will be called `matches`. This
    makes sense because the `matches` variable represents members of the initial Array
    that were found to match the Proc used for that particular stage of the `map`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Array Intersections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At ❺, we call a method we haven’t seen before on `memo`. This method happens
    to be expressed with the ampersand character, but it has nothing to do with converting
    blocks and Procs into each other; it has more to do with set math.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess what this ampersand means? It represents the intersection of two
    composite data sets. It basically means *Find all members of myself that also
    belong to this other thing*. When we call it within our `inject`, we ensure that
    once a given Array element fails one test, it no longer appears as a candidate
    for the next test. This happens because the memory of the `inject` method (represented
    by the variable called `memo`) is automatically set to the return value of each
    iteration of the `inject` method. At ❻, when we’re done with all of our `map`
    ping and `inject`ing, we’re left with only those members of the original Array
    that pass the tests defined by every single Proc in the `procs_array` argument.
    Since Ruby returns the last expression evaluated in a method, `matching_compound_members`
    returns an Array of all members of `self` that pass every test represented by
    the members of `procs_array`.
  prefs: []
  type: TYPE_NORMAL
- en: After some setup at ❼ similar to that for the previous script, we output results
    using `puts` at both ❽ and ❾. Let’s see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We call each of these filtering Procs on the digits from zero to nine, getting
    the correct members each time. We finally output the prefix `ALL` followed by
    the members that pass all the tests. The number six is the only digit from zero
    to nine that is divisible by three, is greater than or equal to five, and is even.
    Therefore, it is the only member of the final output.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try defining your own Procs using `lambda`. You can add them to the section
    at ❼ or replace some of the existing Procs. Feel free to alter the range used
    to create the `digits` Array as well. A larger range of values in `digits` could
    help demonstrate more complex relationships among a greater number of filtering
    Procs.
  prefs: []
  type: TYPE_NORMAL
- en: '#23 Returning Procs as Values (return_proc.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at a further demonstration of how to use Procs as data generated
    by another function. It’s very similar to the `make_incrementer.rb` script.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we call this with the command `ruby -w return_proc.rb`, we get the following
    output, all of which is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We define a method called `return_proc` starting at ❶ that takes a mandatory
    `criterion` and an optional `further_criterion`, assumed to be one. It then defines
    a Hash called `proc_of_criterion` with keys that match a specific criterion and
    values that are Procs corresponding to each criterion. It then allows a caller
    to use an alias `is_even` to mean *Divisible by two* at ❷. It does this by recursively
    calling itself with the arguments `div_by?` and `2` when the alias is used.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the `is_even` alias is not used, the method tries to read the
    appropriate Proc to use at ❸; it fails if it gets a criterion it doesn’t understand.^([[18](#ftn.CHP-6-FNOTE-3)])
    If it gets past this point, we know that the method understands its criteria,
    because it found a Proc to use. It then returns that Proc, appropriately called
    `proc_to_return`.
  prefs: []
  type: TYPE_NORMAL
- en: We now know that `return_proc` lives up to its name and returns a Proc. Let’s
    use it. At ❹, we `require` one of our first scripts, `boolean_golf.rb`. You may
    recall that that script adds the methods `true?` and `false?` to every object.
    This will come in handy for our next few lines. At ❺, we define three Procs that
    can test numbers for certain conditions. We then use those Procs within the `each`
    block starting at ❻. For each of the Integers `4, 5`, and `6`, we test for evenness,
    being divisible by three, and being equal to ten. We also use both the `printf`
    command that we saw in the `line_num.rb` script and the main ternary operator,
    both of which happen at ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Proc.call(args) vs. Proc[args]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we call our Procs with a different syntax here—we don’t use the
    `call` method at all. We can simply put whatever arguments we would use inside
    square brackets, and it’s just like using the `call` method. Let’s verify this
    in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I chose to use the bracket syntax in these examples for the sake of brevity.
    So far, I’ve shown how to use Procs that have been returned directly from the
    `return_proc` method. But we can also do other things, such as converting between
    blocks and Procs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Procs as Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From ❽ to the end of the script, we see how we can cast the output of `return_proc`
    (which we know to be a Proc) into a block with the ampersand without ever storing
    the Proc in a variable. After defining our usual `digits` Array, we call `find_all`
    twice, assigning the results into `even_results` and `div3_results`, respectively.
    Remember that `find_all` takes a block. The ampersand can convert any expression
    that evaluates to a Proc into a block, and `(return_proc(‘is_even’)` is an expression
    that returns (evaluates to) a Proc. Therefore, we can coerce (or cast) the expression
    `(return_proc(‘is_even’)` into a perfectly valid block for `find_all`. We do this,
    outputting the results via `puts` at ❾.
  prefs: []
  type: TYPE_NORMAL
- en: The inspect Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we call a new method called `inspect` on each set of results to
    retain the brackets and commas that we normally associate with members of Arrays.
    The `inspect` method returns a String representation of whatever object it’s called
    on. It is slightly different from the `to_s` method we’ve already seen. Let’s
    check that out in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the output of `inspect` is a bit prettier than the output of
    `to_s`. It also retains more information about what type of object it was called
    on.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be pretty comfortable with calling Procs, passing them around,
    reading them out of Hashes, and converting them to and from blocks, whether with
    a `lambda` or when passing around to methods. Now let’s look at nesting `lambda`s
    within other `lambda`s.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#CHP-6-FNOTE-3)]) Were you to modify or extend this method, you could
    simply add more options to the `proc_of_criterion` Hash.
  prefs: []
  type: TYPE_NORMAL
- en: '#24 Nesting lambdas'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review Procs for a bit. Procs are just functions that can be treated as
    data, what functional programming languages call *first-class functions*. Functions
    can create Procs; we saw that both `make_incrementer` and `return_proc` return
    Procs of different sorts. Given all that, what prevents us from making a Proc
    that returns another Proc when called? Nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: In the `make_exp` example below, we create specific versions of Procs that raise
    an argument to some specified power. That power is the `exp` argument taken by
    the outer `lambda`, which is described as a *free variable* because it is not
    an explicit argument to the inner `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: The inner `lambda`, which is returned, has a *bound variable* called *`x`*.
    It is bound because it is an explicit argument to that inner `lambda`. That variable
    *`x`* is the number that will be raised to the specified power. This example is
    short, and the returned value at each stage is very important, so we’ll do this
    entirely in irb.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We see up to this point that `make_exp_proc` is a Proc, which returns a Proc
    when called. That resulting Proc raises its argument to the exponent used in the
    initial call of `make_exp_proc`. Since in our example, we called `make_exp_proc`
    with `2`, we created a Proc that squares its argument, appropriately calling it
    `square_proc`. We also see that the squaring Proc can be used in a mapping operation
    onto the digits Array, and that it returns the correct squared values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We also see in the rest of the example that `make_exp_proc` is flexible and
    can take arguments other than `2`. It works perfectly well with an argument of
    `3`, producing a cubing Proc, which we can use in the same ways as the squaring
    Proc.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, our Procs have tended to implement simple mathematical operations,
    like addition, multiplication, or exponentiation. But Procs are functions like
    any other, and they can output any type of value. Let’s move on to the next script,
    which uses Procs that manipulate Strings.
  prefs: []
  type: TYPE_NORMAL
- en: '#25 Procs for Text (willow_and_anya.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I was planning the functional programming chapter of this book, I was watching
    DVDs of Joss Whedon’s *Buffy the Vampire Slayer*. I mention this because I had
    Procs and blocks on my brain, and I happened to encounter two very good candidates
    for text-based examples of `lambda` operations. In an episode called “Him,” there
    is discussion of a “love spell”, an “anti-(love spell) spell”, and an “anti-(anti-(love
    spell) spell) spell”. That’s a great example of successive modifications via a
    simple function. In another episode called “Same Time, Same Place,” there is a
    conversation that demonstrates simple variable substitution. Both are great examples
    of simple functions and are good venues to explore how Procs in Ruby differ based
    on how we choose to create them. Here’s the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You obviously don’t need to like Buffy to benefit from reading about these
    examples. The specific content that the scripts modify is essentially arbitrary*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code consists of three distinct files: one each for the two necessary
    classes, and one separate script meant to be directly executed.'
  prefs: []
  type: TYPE_NORMAL
- en: The Him Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The SameTimeSamePlace Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The willow_and_anya.rb Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script performs some complex operations. Let’s consider each class individually
    and then look at the separate script that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Him Class: Creating Procs with lambda'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define a class called `Him` at ❶. It has three constants: its own `EPISODE_NAME`,
    a `BASE` item, and a `lambda` operation to create an `ANTIDOTE_FOR` something.^([[19](#ftn.CHP-6-FNOTE-4)])
    It has one class method called `Him.describe` (❷) that returns a long String constructed
    via a `here doc`. Remember that you can call a Proc with either `some_proc.call(args)`
    or `some_proc[args]`. In this case, we’ll use the shorter bracket version again.
    We’ll report that the character named Willow refers to the antidote for the base
    spell. Her associate Anya then mentions the antidote for that antidote. Whedon
    avoided yet another call to the antidote-creating Proc in his show, but our method
    will continue, outputting the antidote for the antidote for the antidote.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SameTimeSamePlace Class: Alternatives to lambda for Creating Procs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next class explores more options. `SameTimeSamePlace` starts at ❸ and it
    defines a Hash constant called `QUESTIONS` right away at ❹. Its keys are Symbols,
    and its values are Procs. Up until now, we’ve always created Procs with the `lambda`
    method, but we know that Procs are instances of the class Proc. Traditionally,
    you can create an instance by calling the new method on a class. Let’s try that
    in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That seems to work fine, and each Proc behaves as expected. In actual practice,
    there is little difference between Procs created via `lambda` and Procs created
    via `Proc.new`. `Proc.new` is a bit more flexible about how it handles arguments,
    which we’ll soon see. For now, note that the value for the key `:ternary` in our
    `QUESTIONS` Hash at ❹ is a Proc that asks if someone named Spike has a certain
    `state` (which is neither already known nor static) in a certain `location` (which
    is also neither already known nor static).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Don’t be fooled by this script’s surface-level silliness. It actually clarifies
    some very interesting behavior in Ruby’s Procs with regard to arguments and arity.
    Later scripts that use these techniques for tasks that are more useful in the
    real world include scripts that convert temperatures and play audio files for
    a radio station*.'
  prefs: []
  type: TYPE_NORMAL
- en: Flexible Arity for Proc.new
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll start exploring `Proc.new` more for the `:unless0th` Symbol key.
    You’ll notice that the `*args` argument to this Proc has a preceding asterisk.
    This option is available to Procs created with `Proc.new`, but not to Procs created
    with `lambda`. It indicates that the argument with the asterisk is optional. Immediately
    inside the `:unless0th` Proc, we set the value of `args` if it has no value at
    the zeroth index; then we output the same question as the `:ternary` version.
    The only difference is that the `args` Array is optional for this version. Note
    also that we create our double `“what”` default Array with a `%w` with slash delimiters.
    This is a very handy way to create single-word Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For the `:nitems` Symbol key, we use an optional `*args` with `Proc.new` again.
    The only difference between this version and the `:unless0th` version is the way
    this tests `args`. In this version, we call the `nitems` method on the `args`
    Array, which returns the number of non-`nil` items. That number needs to be two
    or greater; if it isn’t, that means we don’t have enough elements, and so we will
    replace `args` with our default set of two `“what”`s, just as in the previous
    Procs.
  prefs: []
  type: TYPE_NORMAL
- en: For the `:second_or` Symbol key, we see yet another Proc within optional `args`
    created with `Proc.new`. This version simply tests whether or not the second item
    in the `args` Array can be read. If it cannot be read, we replace `args` just
    as in the `:nitems` version.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a Proc the way we always have, using `lambda`. Since arguments
    to `lambda` Procs are not optional, we identify this one with the Symbol `:needs_data`.
    Note that this makes the internals of the Proc simpler. It returns its output
    value, and we assume that it gets what it needs. After defining our Procs, the
    last of which needs data, we should probably have some data. Our source is Anya
    again, and we define her `DATA_FROM_ANYA` Array at ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'On to the method `SameTimeSamePlace.describe` at ❻. It takes no arguments and
    defines a local Array variable called `same_as_procs`. Its first element is the
    return value of calling `SameTimeSamePlace.yield_block` (defined at ❽) with an
    argument that is the Proc associated with the `:nitems` key in the `QUESTIONS`
    Hash. All of this is cast into a block with the ampersand. We haven’t seen the
    `yield_block` method yet, but it takes two arguments: `*args` and `&block`. The
    first of these indicates *All of your regular arguments*, and the second means
    *Whatever block you got*.'
  prefs: []
  type: TYPE_NORMAL
- en: Blocks, Arguments, and yield
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember how I mentioned that blocks are not considered “real” arguments? Using
    an ampersand is the way to explicitly refer to the block used to call a method.
    Since we have the group of arguments, whatever they may be, and we have the block,
    we could call it via `block.call(*args)`. That approach would work, but we have
    yet another alternative. Ruby has a method called `yield` that means *Call whichever
    block you received with whichever arguments are passed to* *`yield`*. When you
    get comfortable with this script, try replacing the `yield` line in `yield_block`
    with `block.call(*args)`. It will not change the script’s behavior at all. Let’s
    verify some of this in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Handy, isn’t it? The `yield_block` method is completely generic, taking any
    number of regular arguments and any block and executing (or `yield`ing) that block
    with those arguments. It’s a very powerful technique.
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand how our script is using the `yield_block` method within `SameTimeSamePlace.describe`
    (❻). The next two elements of `same_as_procs` are the return values of Procs pulled
    out of the `QUESTIONS` Hash with the `call` method. Our last element is the return
    value of `SameTimeSamePlace.willow_ask` (❼). This method provides a workaround
    for Procs created with `lambda` that need a specific number of arguments. `willow_ask`
    wraps a call to such a Proc within a traditional method that takes an optional
    argument. That argument is forcibly set to whatever the Proc expects before it
    ever gets to the Proc. This is another alternative for dealing with the arguments
    to a Proc.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the elements of our `same_as_procs` Array. Now let’s use it. We
    `return` a long `here doc` String inside `SameTimeSamePlace.describe` (❻). This
    `here doc` String consists of several lines. The first calls the `QUESTIONS[:ternary]`
    Proc with one explicitly `nil` argument. This will cause our `state` and `location`
    variables to be set to their default values within the Proc. The next four lines
    of output are the result of mapping a String outputter onto the elements of `same_as_procs`.
    Remember that those elements are the `return` values of their respective Procs,
    not the Procs themselves. They have already been evaluated before being put into
    the Array.
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines of the `here doc` report the data provided by Anya, which
    is defined as the constant Array `DATA_FROM_ANYA` (❺). We call the `yield_block`
    method, passing in `DATA_FROM_ANYA` as the “real” arguments and the value returned
    from `QUESTIONS[:needs_data]`, cast from a Proc into a block. Then we close our
    `here doc` and end the `SameTimeSamePlace.describe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using Both Him and SameTimeSamePlace in willow_and_anya.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we do in the main running script, `willow_and_anya.rb`, is `require`
    each `lib_file` needed. Then we cycle through each class, referred to by the name
    `episode`, and describe that episode (❾), implemented in each specific case, as
    already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at the output returned by executing `ruby -w willow_and_anya.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of data about some pretty esoteric programming topics. Congratulations
    for sticking with me this far. If you’re genuinely curious about how this all
    works, I have some questions for you to ponder.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How would you duplicate just the successive `lambda` outputs of `Him.describe`
    using `inject`? Here’s what I came up with. Maybe you can find a better alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Another question you may find interesting is why the `describe` methods are
    attached to classes, rather than instances. The reason is that the `episode` variable
    at ❾ represents a class, not an instance. If we wanted to use instance methods,
    we would need to create an instance of either `Him` or `SameTimeSamePlace`, rather
    than just calling the `describe` method on each class directly.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#CHP-6-FNOTE-4)]) I mentioned earlier in the book that `lambda`s can
    make excellent Class Constants. Now you can see that in action.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Creating Procs with `lambda`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Procs as arguments to methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocks as arguments to methods, including your own new methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Procs as first-class functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inspect` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting `lambda`s within other `lambda`s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proc.new`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `yield` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have a confession to make. I love object orientation for many programming
    tasks, but this chapter about Ruby’s functional heritage was the most fun to write
    so far. Functional programming has been respected in academia for decades, and
    it is starting to get some well-deserved attention from folks in the computer
    programming industry and others who are just curious about what it can do. Now
    that we know some functional programming techniques, let’s put them to use and
    even try to optimize them, which is the subject of our next chapter.
  prefs: []
  type: TYPE_NORMAL
