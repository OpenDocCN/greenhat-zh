- en: Chapter 6. Functionalism with Blocks and Procs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 使用块和 Procs 的函数式编程
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: 'Ruby has two main ancestors: Smalltalk and Lisp.^([[16](#ftn.CHP-6-FNOTE-1)])
    From Smalltalk, Ruby gets its heavy object orientation, which we’ve explored in
    some depth up to this point. From Lisp it derives several ideas from *functional
    programming*, which is a very mathematically inclined approach to programming
    with a few notable characteristics. First, variables tend to be defined once,
    without having their values changed later on. Additionally, functions tend to
    be simple, abstract, and used as building blocks for other functions; the line
    between *functions*, which perform operations, and *data*, on which functions
    operate, is often blurry, compared with non-functional approaches. Functions also
    tend to do their work by returning values, rather than having side effects—in
    Ruby terms, methods that end with an exclamation point are less common.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有两个主要祖先：Smalltalk 和 Lisp.^([[16](#ftn.CHP-6-FNOTE-1)]) 从 Smalltalk，Ruby
    获得了其强大的面向对象特性，我们在此之前已经深入探讨了。从 Lisp，Ruby 得到了几个来自 *函数式编程* 的想法，这是一种非常数学化的编程方法，具有一些显著的特点。首先，变量往往只定义一次，之后不会改变它们的值。此外，函数往往简单、抽象，并用作其他函数的构建块；与非函数式方法相比，*函数*（执行操作）和
    *数据*（函数操作的对象）之间的界限通常模糊。函数还倾向于通过返回值来完成工作，而不是产生副作用——在 Ruby 术语中，以感叹号结尾的方法较少见。
- en: Ruby’s support for functional programming is extensive and exciting. Let’s dive
    in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 对函数式编程的支持广泛且令人兴奋。让我们深入探讨。
- en: '#20 Our First lambda (make_incrementer.rb)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#20 我们的第一条 lambda (make_incrementer.rb)'
- en: This script explores how Ruby creates functions that should be treated as objects.
    Every “thing” in Ruby is an object, so the notion of treating functions as objects
    is not conceptually odd. In Ruby, we do this with the command `lambda`, which
    takes a block. Let’s look at that in irb.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本探讨了 Ruby 如何创建应被视为对象的函数。在 Ruby 中，每个“事物”都是一个对象，因此将函数视为对象的概念在概念上并不奇特。在 Ruby
    中，我们使用 `lambda` 命令来做到这一点，它接受一个块。让我们在 irb 中看看这个例子。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see by the return value of line one that the result of calling `lambda`
    is an instance of class *Proc*. Proc is short for *procedure*, and while most
    objects are defined by what they *are*, Procs can be thought of primarily as defined
    by what they *do*. Procs have a method called *call*, which tells that Proc instance
    to do whatever it does. In our irb example, we have a Proc instance called `double_me`
    that takes an argument and returns that argument, times two. On line two, we see
    that feeding the number *5* into `double_me.call` results in a return value of
    *10*, just as you would expect. It is easy to create other Procs that do other
    operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过第一行的返回值看到，调用 `lambda` 的结果是类 *Proc* 的一个实例。Proc 是 *procedure* 的缩写，虽然大多数对象是由它们
    *是什么* 来定义的，但 Procs 可以主要被认为是根据它们 *做什么* 来定义的。Procs 有一个名为 *call* 的方法，它告诉 Proc 实例执行其操作。在我们的
    irb 示例中，我们有一个名为 `double_me` 的 Proc 实例，它接受一个参数并返回该参数的两倍。在第二行，我们看到将数字 *5* 输入到 `double_me.call`
    中，结果返回值为 *10*，正如您所期望的那样。创建其他执行其他操作的 Procs 很容易。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since Procs are objects, just like everything else in Ruby, we can treat them
    like any other object. They can be the returned value of a method, either the
    key or value of a Hash, arguments to other methods, and whatever else any object
    can be. Let’s look at the script that demonstrates this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Procs 是对象，就像 Ruby 中的其他一切一样，我们可以像对待任何其他对象一样对待它们。它们可以是方法的返回值，可以是 Hash 的键或值，可以是其他方法的参数，以及任何对象可以成为的其他东西。让我们看看演示这一点的脚本。
- en: The Code
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How It Works
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: At ❶ we define a method called `make_incrementer`. It takes a single argument
    called `delta` and returns a Proc (created via `lambda`) that adds `delta` to
    something else, represented by *`x`*. What is that something else? We don’t know
    yet. That is precisely the point of this method—it allows us to define an operation
    that can be performed multiple times using different parameters, just like any
    other function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 我们定义了一个名为 `make_incrementer` 的方法。它接受一个名为 `delta` 的单个参数，并返回一个 Proc（通过 `lambda`
    创建），该 Proc 将 `delta` 添加到其他某个东西上，用 *`x`* 表示。那是什么东西？我们尚不清楚。这正是此方法的精确点——它允许我们定义一个可以多次使用不同参数执行的操作，就像任何其他函数一样。
- en: We can see how this is useful in the rest of this script. At ❷ we define a new
    Hash called `incrementer_proc_of`. For each of the values `10` and `20`, we make
    an incrementer (using either `10` or `20` for the value of `delta` in the `make_incrementer`
    method) and assign the resulting Proc into the `incrementer_proc_of` Hash. Starting
    at ❸, we read each `delta` and Proc pair out of the Hash using the `each_pair`
    method and then use `puts` to print a line describing that `delta` value and the
    result of calling its Proc with the argument of `5`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在脚本的其他部分看到这是如何有用的。在 ❷ 我们定义了一个名为 `incrementer_proc_of` 的新 Hash。对于 `10` 和
    `20` 这两个值，我们使用 `10` 或 `20`（在 `make_incrementer` 方法中作为 `delta` 的值）创建一个增量器，并将结果
    Proc 分配给 `incrementer_proc_of` Hash。从 ❸ 开始，我们使用 `each_pair` 方法从 Hash 中读取每个 `delta`
    和 Proc 对，然后使用 `puts` 打印一行，描述该 `delta` 值以及调用其 Proc 并以 `5` 作为参数的结果。
- en: We ❹ print a spacer with `puts` (just for ease of reading the output), and finally
    ❺ output another set of data. This time we add another loop for a value called
    `other_addend`; this is a variable that serves a role analogous to our static
    value of `5` in the loop (❸). Let’s run this program with `ruby -w make_incrementer.rb`
    and look at the output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `puts` 打印一个空格（只是为了便于阅读输出），最后输出另一组数据。这次我们为名为 `other_addend` 的值添加了另一个循环；这是一个变量，其作用类似于循环中的静态值
    `5`（❸）。让我们用 `ruby -w make_incrementer.rb` 运行这个程序并查看输出。
- en: The Results
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two lines before the empty line show the output of the first loop
    (with the static value of `5` for the addend), while the rest of the output shows
    the result of the second loop, which uses the `other_addend` variable. Notice
    also that `each_pair` does not order by key, which is why my output has the delta
    value of `20` appearing first. Depending on your implementation of Ruby, you might
    see a `delta` of `10` first.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在空行之前的两行显示了第一个循环（使用静态值 `5` 作为加数）的输出，而其余的输出显示了第二个循环的结果，该循环使用 `other_addend` 变量。注意，`each_pair`
    不会按键排序，这就是为什么我的输出中 `delta` 值为 `20` 出现在第一位。根据你实现的 Ruby 版本，你可能会先看到一个 `delta` 值为
    `10`。
- en: Now you know how to create Procs. Let’s learn how to use them for something
    more useful than just demonstrating themselves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建 Procs。让我们学习如何使用它们做一些比仅仅展示自己更有用的事情。
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[16](#CHP-6-FNOTE-1)]) This is a potentially contentious statement. At a
    RubyConf, I once asked Matz which other languages he thought were most influential
    on Ruby. His response was “Smalltalk and Common Lisp”. Other folks in the Ruby
    community (many of them ex-Perl users) stress Ruby’s clear similarity to Perl.
    Probably the safest statement is that Ruby descends from Smalltalk and Lisp, and
    while it’s a lot like Perl, Perl is more like an aunt or uncle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#CHP-6-FNOTE-1)]) 这是一个可能存在争议的陈述。在 RubyConf 上，我曾问过 Matz 他认为哪些语言对 Ruby
    影响最大。他的回答是“Smalltalk 和 Common Lisp”。Ruby 社区的其他人（其中许多人是前 Perl 用户）强调 Ruby 与 Perl
    的明显相似性。可能最安全的说法是，Ruby 源自 Smalltalk 和 Lisp，虽然它与 Perl 很像，但 Perl 更像是一个阿姨或叔叔。
- en: '#21 Using Procs for Filtering (matching_members.rb)'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#21 使用 Procs 进行过滤（matching_members.rb）'
- en: So far, we’ve seen that to create a Proc, we call `lambda` with a block describing
    what that Proc should do. This would lead you to believe that there is a special
    relationship between Procs and blocks, which there is. Our next script demonstrates
    how to use Procs in place of blocks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，要创建一个 Proc，我们需要用描述该 Proc 应该做什么的块调用 `lambda`。这会让你认为 Procs 和块之间存在特殊的关系，确实如此。我们的下一个脚本演示了如何用
    Procs 代替块。
- en: The Code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How It Works
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: In this script, we open the Array class in order to add a new method called
    `matching_members` (❶). It takes a Proc (creatively called `some_proc`—see the
    note below) as an argument and returns the result of calling `find_all`, which
    (as its name suggests) finds all members for which the block is true. In this
    case, the condition in the block is the result of calling the Proc argument on
    the Array with the Array member in question as the argument to `call`. After we
    finish defining our new method, we set up our `digits` Array and our Procs with
    appropriate names in the `lambdas` Hash at ❷.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们打开 Array 类以添加一个名为 `matching_members`（❶）的新方法。它接受一个名为 `some_proc` 的 Proc（见下面的注释）作为参数，并返回调用
    `find_all` 的结果，正如其名称所暗示的，它会找到所有满足块条件的成员。在这种情况下，块中的条件是调用 Proc 参数并将数组成员作为 `call`
    的参数传递给数组的结果。在我们完成新方法的定义后，我们在 `lambdas` Hash 中设置了适当的名称，并在 ❷ 处设置了我们的 `digits` 数组和
    Procs。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '*Some of my co-workers make fun of the variable and method names I use—like
    *`some_proc`*, for example. I think names should either be very specific, like
    *`save_rates_to_local_file!`*, or explicitly generic, like *`some_proc`*. For
    truly generic operations, I often use variable names like *`any_proc`* or *`any_hash`*,
    which tell you explicitly that the operations being performed on them are meant
    to be useful for any Proc or Hash*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些同事嘲笑我使用的变量和方法名称——比如 *`some_proc`*。我认为名称应该是非常具体的，比如 *`save_rates_to_local_file!`*，或者明确通用，比如
    *`some_proc`*。对于真正通用的操作，我经常使用像 *`any_proc`* 或 *`any_hash`* 这样的变量名，这明确地告诉你对这些操作进行的操作旨在对任何进程或哈希表都很有用*。'
- en: At ❸, we loop through each sorted `lambda_name`, and at ❹ we extract each Proc
    out as a variable called `lambda_proc`. We then `find_all` members of the `digits`
    Array that match the condition described by that Proc at ❺ and `puts` an appropriate
    message at ❻.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❸ 处，我们遍历每个排序的 `lambda_name`，在 ❹ 处，我们将每个进程提取出来作为名为 `lambda_proc` 的变量。然后我们在
    ❺ 处根据该进程描述的条件 `find_all` `digits` 数组的成员，并在 ❻ 处输出适当的消息。
- en: Running the Script
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s see it in action with `ruby -w matching_members.rb`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `ruby -w matching_members.rb` 来看看它的实际效果。
- en: The Results
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In each case, we filter the members of the `digits` Array based on some specific
    conditions. Hopefully, you’ll find that the names I chose for each Proc match
    what that Proc does. The `five+` Proc returns `true` for any argument that is
    five or greater.^([[17](#ftn.CHP-6-FNOTE-2)]) We see that the results of calling
    `five+` on each digit in turn returns the correct digits. Similarly, the `is_even`
    Proc filters its input, only returning `true` for arguments that are even, where
    *evenness* is defined as having a modulus two equal to zero. Again, we get the
    correct numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们根据一些特定的条件过滤 `digits` 数组的成员。希望你会发现我为每个进程选择的名称与该进程所做的工作相匹配。`five+` 进程对任何大于或等于五的参数返回
    `true`.^([[17](#ftn.CHP-6-FNOTE-2)]) 我们可以看到，对每个数字依次调用 `five+` 都返回正确的数字。同样，`is_even`
    进程过滤其输入，只对偶数返回 `true`，其中 *偶数* 定义为模二等于零。同样，我们得到了正确的数字。
- en: What happens when we want to filter based on multiple criteria? We could filter
    once with one Proc, assign that result into an Array, and then filter that result
    by the second criterion. That’s perfectly valid, but what if we have an unknown
    number of filtering conditions? We want a version of `matching_members` that can
    take an arbitrary number of Procs. That’s our next script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要根据多个标准进行过滤时会发生什么？我们可以用一个进程进行一次过滤，将结果赋给一个数组，然后根据第二个标准过滤那个结果。这是完全有效的，但如果我们有未知数量的过滤条件怎么办？我们想要一个
    `matching_members` 的版本，它可以接受任意数量的进程。这就是我们的下一个脚本。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#CHP-6-FNOTE-2)]) It does this by implicit Boolean evaluation of the
    expression `i >= 5`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-6-FNOTE-2)]) 它通过表达式 `i >= 5` 的隐式布尔评估来完成这个操作。
- en: '#22 Using Procs for Compounded Filtering (matching_compound_members.rb)'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#22 使用进程进行复合过滤（matching_compound_members.rb）'
- en: In this script, we’ll filter Arrays using an arbitrary number of Procs. As before,
    we’ll open up the Array class, this time adding two methods. Again, we’ll filter
    digits based on simple mathematical tests. Let’s take a look at the source code
    and see what’s different.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们将使用任意数量的进程来过滤数组。和之前一样，我们将打开数组类，这次添加两个方法。再次，我们将基于简单的数学测试过滤数字。让我们看看源代码，看看有什么不同。
- en: The Code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How It Works
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: We start by defining a method called `matching_members` (❶), just as before.
    However, this time our argument is called `some_block` instead of `some_proc`,
    and it is preceded by an ampersand. Why?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为 `matching_members` 的方法（❶），就像之前一样。然而，这次我们的参数被命名为 `some_block` 而不是
    `some_proc`，并且它前面有一个与（&）。为什么？
- en: Blocks, Procs, and the Ampersand
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块、进程和与（&）
- en: The ampersand (`&`) is Ruby’s way of expressing blocks and Procs in terms of
    each other. It’s very useful for arguments to methods, as you might imagine. *Blocks*,
    you may remember, are simply bits of code between delimiters such as braces (`{
    “I’m a block!” }`) or the `do` and `end` keywords (`do “I’m also a block!” end`).
    *Procs* are objects made from blocks via the `lambda` method. Either of them can
    be passed into methods, and the ampersand is the way to use one as the other.
    Let’s test this in irb.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与（&）是 Ruby 表达块和进程的方式，这在方法参数中非常有用。你可能记得，*块*只是分隔符（如花括号 `{ “I’m a block!” }` 或
    `do` 和 `end` 关键字 `do “I’m also a block!” end`）之间的代码片段。*进程*是通过 `lambda` 方法从块创建的对象。它们中的任何一个都可以传递给方法，而与（&）就是用来将一个用作另一个的方式。让我们在
    irb 中测试一下。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We open the Array class and add a method called `matches_block`; this method
    takes a block (with an ampersand prefix), effectively duplicating the behavior
    of the existing `find_all` method, which it calls. We also add another method
    called `matches_proc` that calls `find_all` again, but takes a Proc this time.
    Then we try them out.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开 Array 类并添加一个名为 `matches_block` 的方法；这个方法接收一个带有 `&` 前缀的块，实际上复制了现有 `find_all`
    方法的功能，并调用它。我们还添加了另一个名为 `matches_proc` 的方法，它再次调用 `find_all`，但这次接收一个 Proc。然后我们尝试使用它们。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `matches_block` method dutifully takes a block and passes it along to the
    `find_all` method, transforming it along the way with the ampersand—once on input
    and again when passed to `find_all`. The `matches_proc` method takes a Proc and
    passes that on to `find_all`, but it only needs to transform with the ampersand
    once.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`matches_block` 方法尽职尽责地接收一个块并将其传递给 `find_all` 方法，在传递过程中使用 `&` 符号进行转换——一次是在输入时，再次是在传递给
    `find_all` 时。`matches_proc` 方法接收一个 Proc 并将其传递给 `find_all`，但它只需要使用 `&` 符号转换一次。'
- en: You might think that we could omit the ampersand and just treat a block argument
    as a standard variable, like in irb below.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为我们可以省略 `&` 符号，只需将块参数视为标准变量，就像下面的 irb 例子中那样。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That doesn’t work, as you see. Ruby keeps track of the number of arguments that
    a given method, block, or Proc expects (a concept called *arity*) and complains
    when there is a mismatch. Our irb example expected a “real” argument, not just
    a block, and complained when it didn’t get one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样是不行的，正如你所看到的。Ruby 会跟踪给定方法、块或 Proc 期望的参数数量（称为 *arity*），当出现不匹配时会抱怨。我们的 irb
    示例期望一个“真实”参数，而不仅仅是块，当它没有得到一个参数时会抱怨。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The gist of the ArgumentError is that blocks are akin to “partial” or “unborn”
    blocks and need the *`lambda`* method to be made into full-fledged Procs, which
    can be used as real arguments to methods. Some methods, like *`find_all`*, can
    handle block arguments, but these block arguments are treated differently than
    regular arguments and don’t count toward the number of “real” arguments. We’ll
    cover this later when we discuss the *`willow_and_anya.rb`* script. For now, note
    that our new version of *`matching_members`* takes a block instead of a Proc*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*`ArgumentError` 的核心是块类似于“部分”或“未出生”的块，需要使用 `*lambda`* 方法将其转换为完整的 Proc，这样才能作为方法的真实参数使用。一些方法，如
    `*find_all`*，可以处理块参数，但这些块参数与常规参数的处理方式不同，并且不计入“真实”参数的数量。我们将在讨论 `*willow_and_anya.rb`*
    脚本时再详细说明。现在，请注意，我们新的 `*matching_members`* 版本接收一个块而不是 Proc*。'
- en: Filtering with Each Proc via map
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 `map` 使用每个 Proc 进行过滤
- en: We also define a new method called `matching_compound_members` at ❷. The `matching_compound_members`
    method takes an Array argument called `procs_array` and maps a call to `matching_members`
    onto each of `procs_array`’s Proc elements; this transforms the elements into
    blocks with the ampersand at ❸ while doing the mapping. This results in an Array,
    each of whose members is an Array containing all members of the original Array
    that match the conditions defined by the Proc. Confused? Take a look in irb.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 ❷ 处定义了一个名为 `matching_compound_members` 的新方法。`matching_compound_members`
    方法接收一个名为 `procs_array` 的 Array 参数，并将对 `matching_members` 的调用映射到 `procs_array`
    的每个 Proc 元素上；在映射的同时，将元素转换为带有 `&` 符号的块。这导致了一个 Array，其每个成员都是一个包含所有与 Proc 定义的条件匹配的原始
    Array 成员的 Array。困惑吗？看看 irb。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On lines one through seven, we add a shortened version of `matching_members`
    to all Arrays. We call it on line eight, and find that the result is an Array
    of Arrays. The first sub-array is all digits greater than five—the result of the
    first Proc. The second sub-array is all even digits—the result of the second Proc.
    That’s what we have at the end of the `map` (❹) inside `matching_compound_members`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行到第七行，我们将 `matching_members` 的简短版本添加到所有 Array 中。我们在第八行调用它，发现结果是包含多个 Array
    的 Array。第一个子数组是所有大于五的数字——第一个 Proc 的结果。第二个子数组是所有偶数数字——第二个 Proc 的结果。这就是 `matching_compound_members`
    内部的 `map` (❹) 结尾时的内容。
- en: Finding the Intersections with inject
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `inject` 寻找交集
- en: We don’t stop there. Next we call our old friend the `inject` method on that
    Array of Arrays. You may remember that `inject` performs an operation successively
    and has a memory for intermediate results. That will be very useful for us. The
    `inject` method takes an optional non-block element for the initial state of its
    memory. In our script we use `self` (❹), meaning that the memory state will be
    the `self` Array as it exists prior to any filtering. We also say that each member
    of the Array resulting from the `map` operation will be called `matches`. This
    makes sense because the `matches` variable represents members of the initial Array
    that were found to match the Proc used for that particular stage of the `map`
    operation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有就此止步。接下来，我们在那个数组数组上调用我们的老朋友`inject`方法。你可能记得`inject`会连续执行操作并具有中间结果的记忆。这对我们非常有用。`inject`方法接受一个可选的非块元素作为其记忆的初始状态。在我们的脚本中，我们使用`self`（❹），这意味着记忆状态将是过滤之前的`self`数组。我们还说，`map`操作结果中的每个成员都将被称为`matches`。这很有意义，因为`matches`变量代表在`map`操作的特定阶段找到匹配的Proc的初始数组成员。
- en: Array Intersections
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组交集
- en: At ❺, we call a method we haven’t seen before on `memo`. This method happens
    to be expressed with the ampersand character, but it has nothing to do with converting
    blocks and Procs into each other; it has more to do with set math.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在❺处，我们在`memo`上调用一个之前未见过的方法。这个方法恰好是用和号字符表示的，但它与将块和Proc相互转换无关；它更多地与集合数学有关。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Can you guess what this ampersand means? It represents the intersection of two
    composite data sets. It basically means *Find all members of myself that also
    belong to this other thing*. When we call it within our `inject`, we ensure that
    once a given Array element fails one test, it no longer appears as a candidate
    for the next test. This happens because the memory of the `inject` method (represented
    by the variable called `memo`) is automatically set to the return value of each
    iteration of the `inject` method. At ❻, when we’re done with all of our `map`
    ping and `inject`ing, we’re left with only those members of the original Array
    that pass the tests defined by every single Proc in the `procs_array` argument.
    Since Ruby returns the last expression evaluated in a method, `matching_compound_members`
    returns an Array of all members of `self` that pass every test represented by
    the members of `procs_array`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个和号代表什么吗？它代表两个复合数据集的交集。这基本上意味着*找出属于我自己的同时也属于这个其他东西的所有成员*。当我们在这个`inject`方法中调用它时，我们确保一旦一个给定的数组元素未能通过一个测试，它就不再作为下一个测试的候选者。这是因为`inject`方法的记忆（由名为`memo`的变量表示）会自动设置为每次`inject`方法迭代的返回值。在❻处，当我们完成所有的`map`和`inject`操作后，我们只剩下那些通过`procs_array`参数中每个Proc定义的测试的原数组成员。由于Ruby返回方法中评估的最后表达式，`matching_compound_members`返回一个包含`self`中通过每个由`procs_array`成员表示的测试的所有成员的数组。
- en: After some setup at ❼ similar to that for the previous script, we output results
    using `puts` at both ❽ and ❾. Let’s see it in action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了一些与上一个脚本类似的设置后，我们在❽和❾处使用`puts`输出结果。让我们看看它是如何工作的。
- en: The Results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We call each of these filtering Procs on the digits from zero to nine, getting
    the correct members each time. We finally output the prefix `ALL` followed by
    the members that pass all the tests. The number six is the only digit from zero
    to nine that is divisible by three, is greater than or equal to five, and is even.
    Therefore, it is the only member of the final output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对从零到九的数字调用每个过滤Proc，每次都得到正确的成员。我们最终输出前缀`ALL`，后面跟着通过所有测试的成员。数字六是唯一一个从零到九能被三整除、大于或等于五且为偶数的数字。因此，它是最终输出中的唯一成员。
- en: Hacking the Script
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: Try defining your own Procs using `lambda`. You can add them to the section
    at ❼ or replace some of the existing Procs. Feel free to alter the range used
    to create the `digits` Array as well. A larger range of values in `digits` could
    help demonstrate more complex relationships among a greater number of filtering
    Procs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`lambda`定义你自己的Proc。你可以将它们添加到❺处的部分，或者替换一些现有的Proc。你也可以自由地更改创建`digits`数组时使用的范围。`digits`中的更大值范围可以帮助展示更多过滤Proc之间的复杂关系。
- en: '#23 Returning Procs as Values (return_proc.rb)'
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#23 返回Proc作为值（return_proc.rb）'
- en: Let’s look at a further demonstration of how to use Procs as data generated
    by another function. It’s very similar to the `make_incrementer.rb` script.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看看如何使用由另一个函数生成的数据来使用Proc。它与`make_incrementer.rb`脚本非常相似。
- en: The Code
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Results
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: If we call this with the command `ruby -w return_proc.rb`, we get the following
    output, all of which is true.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用命令`ruby -w return_proc.rb`来调用它，我们会得到以下输出，所有这些都是正确的。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How It Works
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: We define a method called `return_proc` starting at ❶ that takes a mandatory
    `criterion` and an optional `further_criterion`, assumed to be one. It then defines
    a Hash called `proc_of_criterion` with keys that match a specific criterion and
    values that are Procs corresponding to each criterion. It then allows a caller
    to use an alias `is_even` to mean *Divisible by two* at ❷. It does this by recursively
    calling itself with the arguments `div_by?` and `2` when the alias is used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从❶开始定义了一个名为`return_proc`的方法，它接受一个必需的`criterion`和一个可选的`further_criterion`，假设为单个值。然后它定义了一个名为`proc_of_criterion`的哈希，其键与特定的标准匹配，值是与每个标准对应的Proc。然后它允许调用者使用别名`is_even`在❷中表示*能被二整除*。它是通过在别名使用时递归地调用自身，并使用参数`div_by?`和`2`来实现的。
- en: Assuming that the `is_even` alias is not used, the method tries to read the
    appropriate Proc to use at ❸; it fails if it gets a criterion it doesn’t understand.^([[18](#ftn.CHP-6-FNOTE-3)])
    If it gets past this point, we know that the method understands its criteria,
    because it found a Proc to use. It then returns that Proc, appropriately called
    `proc_to_return`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有使用`is_even`别名，该方法尝试读取在❸处使用的适当Proc；如果它得到一个它不理解的标准，则失败.^([[18](#ftn.CHP-6-FNOTE-3)])
    如果它通过了这一点，我们知道该方法理解了它的标准，因为它找到了一个要使用的Proc。然后它返回这个Proc，适当地称为`proc_to_return`。
- en: We now know that `return_proc` lives up to its name and returns a Proc. Let’s
    use it. At ❹, we `require` one of our first scripts, `boolean_golf.rb`. You may
    recall that that script adds the methods `true?` and `false?` to every object.
    This will come in handy for our next few lines. At ❺, we define three Procs that
    can test numbers for certain conditions. We then use those Procs within the `each`
    block starting at ❻. For each of the Integers `4, 5`, and `6`, we test for evenness,
    being divisible by three, and being equal to ten. We also use both the `printf`
    command that we saw in the `line_num.rb` script and the main ternary operator,
    both of which happen at ❼.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道`return_proc`名副其实，它返回一个Proc。让我们使用它。在❹处，我们`require`了我们第一个脚本之一，`boolean_golf.rb`。你可能还记得，那个脚本为每个对象添加了`true?`和`false?`方法。这将在我们接下来的几行中很有用。在❺处，我们定义了三个可以测试数字特定条件的Proc。然后我们在❻开始的`each`块中使用这些Proc。对于整数`4,
    5`和`6`，我们测试了偶数性、能被三整除以及等于十。我们还使用了在`line_num.rb`脚本中看到的`printf`命令和主要的三元运算符，这两者都发生在❷。
- en: Proc.call(args) vs. Proc[args]
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Proc.call(args) 与 Proc[args]
- en: Notice that we call our Procs with a different syntax here—we don’t use the
    `call` method at all. We can simply put whatever arguments we would use inside
    square brackets, and it’s just like using the `call` method. Let’s verify this
    in irb.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在调用我们的Proc时使用了不同的语法——我们根本不使用`call`方法。我们可以简单地使用方括号内我们本应使用的任何参数，这就像使用`call`方法一样。让我们在irb中验证这一点。
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I chose to use the bracket syntax in these examples for the sake of brevity.
    So far, I’ve shown how to use Procs that have been returned directly from the
    `return_proc` method. But we can also do other things, such as converting between
    blocks and Procs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这些例子中使用方括号语法是为了简洁。到目前为止，我已经展示了如何使用直接从`return_proc`方法返回的Proc。但我们可以做其他事情，例如在块和Proc之间进行转换。
- en: Using Procs as Blocks
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Proc作为块
- en: From ❽ to the end of the script, we see how we can cast the output of `return_proc`
    (which we know to be a Proc) into a block with the ampersand without ever storing
    the Proc in a variable. After defining our usual `digits` Array, we call `find_all`
    twice, assigning the results into `even_results` and `div3_results`, respectively.
    Remember that `find_all` takes a block. The ampersand can convert any expression
    that evaluates to a Proc into a block, and `(return_proc(‘is_even’)` is an expression
    that returns (evaluates to) a Proc. Therefore, we can coerce (or cast) the expression
    `(return_proc(‘is_even’)` into a perfectly valid block for `find_all`. We do this,
    outputting the results via `puts` at ❾.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从❽到脚本的结尾，我们看到我们可以将`return_proc`的输出（我们知道它是一个Proc）转换为带有&的块，而无需在任何地方存储这个Proc。在定义了我们常用的`digits`数组之后，我们两次调用`find_all`，分别将结果赋值给`even_results`和`div3_results`。记住，`find_all`接受一个块。&可以将任何求值结果为Proc的表达式转换为块，而`(return_proc('is_even'))`就是一个返回（求值）为Proc的表达式。因此，我们可以将表达式`(return_proc('is_even'))`强制转换为`find_all`的有效块。我们这样做，通过`puts`输出结果在❾。
- en: The inspect Method
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: inspect方法
- en: Notice that we call a new method called `inspect` on each set of results to
    retain the brackets and commas that we normally associate with members of Arrays.
    The `inspect` method returns a String representation of whatever object it’s called
    on. It is slightly different from the `to_s` method we’ve already seen. Let’s
    check that out in irb.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在每一组结果上调用一个新的方法`inspect`，以保留我们通常与数组成员关联的括号和逗号。`inspect`方法返回被调用对象的字符串表示形式。它与我们已经看到的`to_s`方法略有不同。让我们在irb中检查一下。
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that the output of `inspect` is a bit prettier than the output of
    `to_s`. It also retains more information about what type of object it was called
    on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`inspect`的输出比`to_s`的输出更漂亮一些。它还保留了更多关于它被调用对象的类型信息。
- en: You should now be pretty comfortable with calling Procs, passing them around,
    reading them out of Hashes, and converting them to and from blocks, whether with
    a `lambda` or when passing around to methods. Now let’s look at nesting `lambda`s
    within other `lambda`s.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经非常熟悉调用进程（Procs），将它们传递给其他函数，从哈希中读取它们，以及将它们转换为块，无论是使用`lambda`还是传递给方法。现在让我们来看看在其他的`lambda`中嵌套`lambda`。
- en: '* * *'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[18](#CHP-6-FNOTE-3)]) Were you to modify or extend this method, you could
    simply add more options to the `proc_of_criterion` Hash.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#CHP-6-FNOTE-3)]) 如果你要修改或扩展这个方法，你只需向`proc_of_criterion`哈希中添加更多选项即可。
- en: '#24 Nesting lambdas'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#24 嵌套lambda'
- en: Let’s review Procs for a bit. Procs are just functions that can be treated as
    data, what functional programming languages call *first-class functions*. Functions
    can create Procs; we saw that both `make_incrementer` and `return_proc` return
    Procs of different sorts. Given all that, what prevents us from making a Proc
    that returns another Proc when called? Nothing at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下进程。进程只是可以被当作数据的函数，这是函数式编程语言所说的*一等函数*。函数可以创建进程；我们看到了`make_incrementer`和`return_proc`都返回不同类型的进程。考虑到所有这些，什么阻止我们创建一个在被调用时返回另一个进程的进程呢？什么都没有。
- en: In the `make_exp` example below, we create specific versions of Procs that raise
    an argument to some specified power. That power is the `exp` argument taken by
    the outer `lambda`, which is described as a *free variable* because it is not
    an explicit argument to the inner `lambda`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`make_exp`例子中，我们创建了将参数提升到某个指定幂的特定版本的进程。这个幂是外部`lambda`接受的`exp`参数，它被描述为*自由变量*，因为它不是内部`lambda`的显式参数。
- en: The inner `lambda`, which is returned, has a *bound variable* called *`x`*.
    It is bound because it is an explicit argument to that inner `lambda`. That variable
    *`x`* is the number that will be raised to the specified power. This example is
    short, and the returned value at each stage is very important, so we’ll do this
    entirely in irb.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的内部`lambda`有一个名为`x`的*绑定变量*。它是绑定因为它是内部`lambda`的显式参数。这个变量`x`是将会被提升到指定幂的数字。这个例子很短，每个阶段的返回值都非常重要，所以我们将整个操作都在irb中完成。
- en: The Code
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How It Works
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: We see up to this point that `make_exp_proc` is a Proc, which returns a Proc
    when called. That resulting Proc raises its argument to the exponent used in the
    initial call of `make_exp_proc`. Since in our example, we called `make_exp_proc`
    with `2`, we created a Proc that squares its argument, appropriately calling it
    `square_proc`. We also see that the squaring Proc can be used in a mapping operation
    onto the digits Array, and that it returns the correct squared values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到到目前为止，`make_exp_proc`是一个进程，它在被调用时返回一个进程。这个返回的进程将它的参数提升到`make_exp_proc`初始调用中使用的指数。由于在我们的例子中，我们用`2`调用`make_exp_proc`，我们创建了一个将它的参数平方的进程，恰当地称它为`square_proc`。我们还看到，平方进程可以在映射操作中用于数字数组，并且返回正确的平方值。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We also see in the rest of the example that `make_exp_proc` is flexible and
    can take arguments other than `2`. It works perfectly well with an argument of
    `3`, producing a cubing Proc, which we can use in the same ways as the squaring
    Proc.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在例子中的其他部分看到，`make_exp_proc`是灵活的，可以接受除了`2`之外的参数。它用`3`作为参数时工作得很好，产生一个立方进程，我们可以像使用平方进程一样使用它。
- en: Up to this point, our Procs have tended to implement simple mathematical operations,
    like addition, multiplication, or exponentiation. But Procs are functions like
    any other, and they can output any type of value. Let’s move on to the next script,
    which uses Procs that manipulate Strings.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的进程（Procs）倾向于实现简单的数学运算，比如加法、乘法或指数运算。但进程和其他函数一样，可以输出任何类型的值。让我们继续到下一个脚本，它使用处理字符串的进程。
- en: '#25 Procs for Text (willow_and_anya.rb)'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#25 文本进程（willow_and_anya.rb）'
- en: As I was planning the functional programming chapter of this book, I was watching
    DVDs of Joss Whedon’s *Buffy the Vampire Slayer*. I mention this because I had
    Procs and blocks on my brain, and I happened to encounter two very good candidates
    for text-based examples of `lambda` operations. In an episode called “Him,” there
    is discussion of a “love spell”, an “anti-(love spell) spell”, and an “anti-(anti-(love
    spell) spell) spell”. That’s a great example of successive modifications via a
    simple function. In another episode called “Same Time, Same Place,” there is a
    conversation that demonstrates simple variable substitution. Both are great examples
    of simple functions and are good venues to explore how Procs in Ruby differ based
    on how we choose to create them. Here’s the source code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我计划这本书的函数式编程章节时，我正在观看乔斯·韦登的《Buffy the Vampire Slayer》的DVD。我提到这一点是因为我脑子里想着进程和块，我恰好遇到了两个很好的基于文本的
    `lambda` 操作的例子。在一个名为“Him”的集中，讨论了一个“爱情咒语”、“反-(爱情咒语)咒语”和“反-(反-(爱情咒语)咒语)咒语”。这是一个通过简单函数进行连续修改的绝佳例子。在另一个名为“Same
    Time, Same Place”的集中，有一个对话展示了简单的变量替换。这两个都是简单函数的绝佳例子，是探索 Ruby 中进程如何根据我们选择创建它们而有所不同的好场所。以下是源代码。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You obviously don’t need to like Buffy to benefit from reading about these
    examples. The specific content that the scripts modify is essentially arbitrary*.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然，你不需要喜欢《Buffy the Vampire Slayer》就能从阅读这些例子中受益。脚本修改的具体内容基本上是任意的*。'
- en: The Code
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: 'This code consists of three distinct files: one each for the two necessary
    classes, and one separate script meant to be directly executed.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码由三个不同的文件组成：两个必要的类各一个，以及一个单独的脚本，该脚本可以直接执行。
- en: The Him Class
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Him` 类'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The SameTimeSamePlace Class
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SameTimeSamePlace` 类'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The willow_and_anya.rb Script
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`willow_and_anya.rb` 脚本'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How It Works
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This script performs some complex operations. Let’s consider each class individually
    and then look at the separate script that uses them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本执行一些复杂的操作。让我们逐个考虑每个类，然后再看看使用它们的单独脚本。
- en: 'The Him Class: Creating Procs with lambda'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Him` 类：使用 `lambda` 创建进程'
- en: 'We define a class called `Him` at ❶. It has three constants: its own `EPISODE_NAME`,
    a `BASE` item, and a `lambda` operation to create an `ANTIDOTE_FOR` something.^([[19](#ftn.CHP-6-FNOTE-4)])
    It has one class method called `Him.describe` (❷) that returns a long String constructed
    via a `here doc`. Remember that you can call a Proc with either `some_proc.call(args)`
    or `some_proc[args]`. In this case, we’ll use the shorter bracket version again.
    We’ll report that the character named Willow refers to the antidote for the base
    spell. Her associate Anya then mentions the antidote for that antidote. Whedon
    avoided yet another call to the antidote-creating Proc in his show, but our method
    will continue, outputting the antidote for the antidote for the antidote.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在❶处定义了一个名为 `Him` 的类。它有三个常量：自己的 `EPISODE_NAME`、一个 `BASE` 项目和一个用于创建 `ANTIDOTE_FOR`
    某物的 `lambda` 操作.^([[19](#ftn.CHP-6-FNOTE-4)]) 它有一个类方法 `Him.describe` (❷)，该方法通过
    `here doc` 返回一个长字符串。记住，你可以用 `some_proc.call(args)` 或 `some_proc[args]` 来调用一个进程。在这种情况下，我们再次使用较短的括号版本。我们将报告名为
    Willow 的角色指的是基础咒语的解毒剂。她的同伴 Anya 然后提到了那个解毒剂的解毒剂。Whedon 在他的节目中避免了另一个调用创建解毒剂的进程，但我们的方法将继续，输出解毒剂的解毒剂的解毒剂。
- en: 'The SameTimeSamePlace Class: Alternatives to lambda for Creating Procs'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SameTimeSamePlace` 类：创建进程的 `lambda` 替代方案'
- en: Our next class explores more options. `SameTimeSamePlace` starts at ❸ and it
    defines a Hash constant called `QUESTIONS` right away at ❹. Its keys are Symbols,
    and its values are Procs. Up until now, we’ve always created Procs with the `lambda`
    method, but we know that Procs are instances of the class Proc. Traditionally,
    you can create an instance by calling the new method on a class. Let’s try that
    in irb.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的类将探索更多选项。`SameTimeSamePlace` 从❸开始，并在❹处立即定义了一个名为 `QUESTIONS` 的哈希常量。它的键是符号，值是进程。到目前为止，我们总是使用
    `lambda` 方法创建进程，但我们知道进程是 `Proc` 类的实例。传统上，你可以通过在类上调用 `new` 方法来创建一个实例。让我们在 irb 中试试。
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That seems to work fine, and each Proc behaves as expected. In actual practice,
    there is little difference between Procs created via `lambda` and Procs created
    via `Proc.new`. `Proc.new` is a bit more flexible about how it handles arguments,
    which we’ll soon see. For now, note that the value for the key `:ternary` in our
    `QUESTIONS` Hash at ❹ is a Proc that asks if someone named Spike has a certain
    `state` (which is neither already known nor static) in a certain `location` (which
    is also neither already known nor static).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来工作得很好，每个 Proc 都按预期工作。在实际应用中，通过 `lambda` 和通过 `Proc.new` 创建的 Proc 之间几乎没有区别。`Proc.new`
    在处理参数方面更为灵活，我们很快就会看到这一点。现在，请注意，在 `QUESTIONS` 哈希中，`:ternary` 键的值是一个 Proc，它会询问名叫
    Spike 的人是否在某个 `location`（这个位置也不是已经知道的或静态的）有某种 `state`（这个状态也不是已经知道的或静态的）。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*Don’t be fooled by this script’s surface-level silliness. It actually clarifies
    some very interesting behavior in Ruby’s Procs with regard to arguments and arity.
    Later scripts that use these techniques for tasks that are more useful in the
    real world include scripts that convert temperatures and play audio files for
    a radio station*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要被这个脚本的表面上的愚蠢所迷惑。实际上，它澄清了 Ruby 的 Proc 在参数和参数数量方面的某些非常有趣的行为。后来使用这些技术在现实世界中有用任务的脚本包括转换温度和为广播电台播放音频文件的脚本*。'
- en: Flexible Arity for Proc.new
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Proc.new` 的灵活参数'
- en: Next, we’ll start exploring `Proc.new` more for the `:unless0th` Symbol key.
    You’ll notice that the `*args` argument to this Proc has a preceding asterisk.
    This option is available to Procs created with `Proc.new`, but not to Procs created
    with `lambda`. It indicates that the argument with the asterisk is optional. Immediately
    inside the `:unless0th` Proc, we set the value of `args` if it has no value at
    the zeroth index; then we output the same question as the `:ternary` version.
    The only difference is that the `args` Array is optional for this version. Note
    also that we create our double `“what”` default Array with a `%w` with slash delimiters.
    This is a very handy way to create single-word Arrays.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始探索 `Proc.new` 在 `:unless0th` 符号键上的更多用途。你会注意到这个 Proc 的 `*args` 参数前面有一个星号。这个选项适用于使用
    `Proc.new` 创建的 Proc，但不适用于使用 `lambda` 创建的 Proc。它表示带星号的参数是可选的。在 `:unless0th` Proc
    中立即设置 `args` 的值，如果它在零索引处没有值；然后我们输出与 `:ternary` 版本相同的问题。唯一的区别是，这个版本的 `args` 数组是可选的。注意，我们使用带有斜杠分隔符的
    `%w` 创建双 `"what"` 默认数组。这是一种创建单词数组的非常方便的方法。
- en: For the `:nitems` Symbol key, we use an optional `*args` with `Proc.new` again.
    The only difference between this version and the `:unless0th` version is the way
    this tests `args`. In this version, we call the `nitems` method on the `args`
    Array, which returns the number of non-`nil` items. That number needs to be two
    or greater; if it isn’t, that means we don’t have enough elements, and so we will
    replace `args` with our default set of two `“what”`s, just as in the previous
    Procs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `:nitems` 符号键，我们再次使用可选的 `*args` 与 `Proc.new`。这个版本与 `:unless0th` 版本之间的唯一区别在于测试
    `args` 的方式。在这个版本中，我们在 `args` 数组上调用 `nitems` 方法，它返回非 `nil` 项的数量。这个数字需要是两个或更多；如果不是，这意味着我们没有足够的元素，因此我们将
    `args` 替换为之前 Procs 中的默认两套 `"what"`，就像之前一样。
- en: For the `:second_or` Symbol key, we see yet another Proc within optional `args`
    created with `Proc.new`. This version simply tests whether or not the second item
    in the `args` Array can be read. If it cannot be read, we replace `args` just
    as in the `:nitems` version.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `:second_or` 符号键，我们看到在可选的 `args` 中使用 `Proc.new` 创建的另一个 Proc。这个版本只是测试 `args`
    数组中的第二个项目是否可以读取。如果无法读取，我们将像在 `:nitems` 版本中那样替换 `args`。
- en: Finally, we create a Proc the way we always have, using `lambda`. Since arguments
    to `lambda` Procs are not optional, we identify this one with the Symbol `:needs_data`.
    Note that this makes the internals of the Proc simpler. It returns its output
    value, and we assume that it gets what it needs. After defining our Procs, the
    last of which needs data, we should probably have some data. Our source is Anya
    again, and we define her `DATA_FROM_ANYA` Array at ❺.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们像以前一样使用 `lambda` 创建一个 Proc。由于 `lambda` Proc 的参数不是可选的，我们用符号 `:needs_data`
    来标识这个 Proc。注意，这使得 Proc 的内部结构更简单。它返回其输出值，我们假设它得到了它需要的东西。在定义了我们的 Proc 之后，最后一个需要数据，我们可能需要一些数据。我们的来源仍然是
    Anya，我们在 ❺ 处定义了她的 `DATA_FROM_ANYA` 数组。
- en: 'On to the method `SameTimeSamePlace.describe` at ❻. It takes no arguments and
    defines a local Array variable called `same_as_procs`. Its first element is the
    return value of calling `SameTimeSamePlace.yield_block` (defined at ❽) with an
    argument that is the Proc associated with the `:nitems` key in the `QUESTIONS`
    Hash. All of this is cast into a block with the ampersand. We haven’t seen the
    `yield_block` method yet, but it takes two arguments: `*args` and `&block`. The
    first of these indicates *All of your regular arguments*, and the second means
    *Whatever block you got*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`SameTimeSamePlace.describe`方法（❻）。它不接受任何参数，并定义了一个名为`same_as_procs`的局部数组变量。它的第一个元素是通过将`QUESTIONS`哈希中与`:nitems`键关联的进程作为参数调用`SameTimeSamePlace.yield_block`（定义在❽）的返回值。所有这些都通过&符号转换成了一个块。我们还没有看到`yield_block`方法，但它接受两个参数：`*args`和`&block`。第一个表示*所有你的常规参数*，第二个表示*你得到的任何块*。
- en: Blocks, Arguments, and yield
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块、参数和yield
- en: Remember how I mentioned that blocks are not considered “real” arguments? Using
    an ampersand is the way to explicitly refer to the block used to call a method.
    Since we have the group of arguments, whatever they may be, and we have the block,
    we could call it via `block.call(*args)`. That approach would work, but we have
    yet another alternative. Ruby has a method called `yield` that means *Call whichever
    block you received with whichever arguments are passed to* *`yield`*. When you
    get comfortable with this script, try replacing the `yield` line in `yield_block`
    with `block.call(*args)`. It will not change the script’s behavior at all. Let’s
    verify some of this in irb.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到过块不被视为“真实”参数吗？使用&符号是显式引用用于调用方法的块的方式。由于我们有参数组，无论它们是什么，我们也有块，我们可以通过`block.call(*args)`来调用它。这种方法是可行的，但我们还有另一种选择。Ruby有一个名为`yield`的方法，意味着*使用传递给`yield`的任何参数调用你收到的任何块*。当你对这个脚本感到舒适时，尝试用`block.call(*args)`替换`yield_block`中的`yield`行。这根本不会改变脚本的行为。让我们在irb中验证一些内容。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Handy, isn’t it? The `yield_block` method is completely generic, taking any
    number of regular arguments and any block and executing (or `yield`ing) that block
    with those arguments. It’s a very powerful technique.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 方便吧？`yield_block`方法完全通用，接受任意数量的常规参数和任意块，并使用这些参数执行（或`yield`）该块。这是一个非常强大的技术。
- en: Now we understand how our script is using the `yield_block` method within `SameTimeSamePlace.describe`
    (❻). The next two elements of `same_as_procs` are the return values of Procs pulled
    out of the `QUESTIONS` Hash with the `call` method. Our last element is the return
    value of `SameTimeSamePlace.willow_ask` (❼). This method provides a workaround
    for Procs created with `lambda` that need a specific number of arguments. `willow_ask`
    wraps a call to such a Proc within a traditional method that takes an optional
    argument. That argument is forcibly set to whatever the Proc expects before it
    ever gets to the Proc. This is another alternative for dealing with the arguments
    to a Proc.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了我们的脚本如何在`SameTimeSamePlace.describe`（❻）中使用`yield_block`方法。`same_as_procs`的下一个两个元素是从`QUESTIONS`哈希中通过`call`方法提取的进程的返回值。我们的最后一个元素是`SameTimeSamePlace.willow_ask`（❼）的返回值。这个方法为使用`lambda`创建的、需要特定数量参数的进程提供了一个解决方案。`willow_ask`将此类进程的调用包裹在一个传统方法中，该方法接受一个可选参数。该参数被强制设置为进程期望的任何值，在它到达进程之前。这是处理进程参数的另一种选择。
- en: That’s it for the elements of our `same_as_procs` Array. Now let’s use it. We
    `return` a long `here doc` String inside `SameTimeSamePlace.describe` (❻). This
    `here doc` String consists of several lines. The first calls the `QUESTIONS[:ternary]`
    Proc with one explicitly `nil` argument. This will cause our `state` and `location`
    variables to be set to their default values within the Proc. The next four lines
    of output are the result of mapping a String outputter onto the elements of `same_as_procs`.
    Remember that those elements are the `return` values of their respective Procs,
    not the Procs themselves. They have already been evaluated before being put into
    the Array.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`same_as_procs`数组元素的结束。现在让我们使用它。我们在`SameTimeSamePlace.describe`（❻）中返回一个长的`here
    doc`字符串。这个`here doc`字符串由几行组成。第一行调用`QUESTIONS[:ternary]`进程，并显式传递一个`nil`参数。这将导致我们的`state`和`location`变量在进程内部被设置为默认值。接下来的四行输出是将字符串输出器映射到`same_as_procs`的元素的结果。记住，这些元素是它们各自进程的返回值，而不是进程本身。它们已经在被放入数组之前被评估过了。
- en: The last few lines of the `here doc` report the data provided by Anya, which
    is defined as the constant Array `DATA_FROM_ANYA` (❺). We call the `yield_block`
    method, passing in `DATA_FROM_ANYA` as the “real” arguments and the value returned
    from `QUESTIONS[:needs_data]`, cast from a Proc into a block. Then we close our
    `here doc` and end the `SameTimeSamePlace.describe` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`here doc`的最后几行报告了Anya提供的数据，定义为常量数组`DATA_FROM_ANYA`（❺）。我们调用`yield_block`方法，传入`DATA_FROM_ANYA`作为“真实”参数，以及从Proc转换成块并返回的`QUESTIONS[:needs_data]`的值。然后我们关闭`here
    doc`并结束`SameTimeSamePlace.describe`方法。
- en: Using Both Him and SameTimeSamePlace in willow_and_anya.rb
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`willow_and_anya.rb`中使用Him和SameTimeSamePlace
- en: The first thing we do in the main running script, `willow_and_anya.rb`, is `require`
    each `lib_file` needed. Then we cycle through each class, referred to by the name
    `episode`, and describe that episode (❾), implemented in each specific case, as
    already discussed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在主运行脚本`willow_and_anya.rb`中，我们首先做的是`require`每个需要的`lib_file`。然后我们遍历每个类，通过`episode`这个名字来引用，并描述这个场景（❾），正如之前讨论的那样，在每个具体案例中实现。
- en: Running the Script
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s look at the output returned by executing `ruby -w willow_and_anya.rb`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行`ruby -w willow_and_anya.rb`返回的输出。
- en: The Results
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s a lot of data about some pretty esoteric programming topics. Congratulations
    for sticking with me this far. If you’re genuinely curious about how this all
    works, I have some questions for you to ponder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这关于一些相当深奥的编程主题的数据有很多。恭喜你一直坚持到现在。如果你真的对这一切是如何工作的感到好奇，我有一些问题要你思考。
- en: Hacking the Script
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: How would you duplicate just the successive `lambda` outputs of `Him.describe`
    using `inject`? Here’s what I came up with. Maybe you can find a better alternative.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何使用`inject`来复制`Him.describe`的连续`lambda`输出？以下是我想到的。也许你能找到更好的替代方案。
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Another question you may find interesting is why the `describe` methods are
    attached to classes, rather than instances. The reason is that the `episode` variable
    at ❾ represents a class, not an instance. If we wanted to use instance methods,
    we would need to create an instance of either `Him` or `SameTimeSamePlace`, rather
    than just calling the `describe` method on each class directly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题你可能觉得很有趣，那就是为什么`describe`方法被附加到类上，而不是实例上。原因是第❾处的`episode`变量代表一个类，而不是一个实例。如果我们想使用实例方法，我们需要创建`Him`或`SameTimeSamePlace`的实例，而不是直接在每个类上调用`describe`方法。
- en: '* * *'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[19](#CHP-6-FNOTE-4)]) I mentioned earlier in the book that `lambda`s can
    make excellent Class Constants. Now you can see that in action.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#CHP-6-FNOTE-4)]) 我在书中提到过，`lambda`可以成为优秀的类常量。现在你可以看到它是如何实现的。
- en: Chapter Recap
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: What was new in this chapter?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有什么新内容？
- en: Creating Procs with `lambda`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lambda`创建Proc
- en: Using Procs as arguments to methods
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Proc作为方法的参数
- en: Using blocks as arguments to methods, including your own new methods
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将块作为方法的参数，包括你自己的新方法
- en: Using Procs as first-class functions
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Proc作为一等函数使用
- en: The `inspect` method
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`方法'
- en: Nesting `lambda`s within other `lambda`s
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他`lambda`中嵌套`lambda`
- en: '`Proc.new`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proc.new`'
- en: The `yield` method
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`方法'
- en: I have a confession to make. I love object orientation for many programming
    tasks, but this chapter about Ruby’s functional heritage was the most fun to write
    so far. Functional programming has been respected in academia for decades, and
    it is starting to get some well-deserved attention from folks in the computer
    programming industry and others who are just curious about what it can do. Now
    that we know some functional programming techniques, let’s put them to use and
    even try to optimize them, which is the subject of our next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个坦白要讲。我非常喜欢面向对象编程，但关于Ruby函数式遗产的这一章是我迄今为止写得最有意思的。函数式编程在学术界已经受到尊重几十年了，它开始从计算机编程行业的人和其他对它感兴趣的人那里获得一些应得的关注。现在我们知道了函数式编程的一些技术，让我们来使用它们，甚至尝试优化它们，这是我们下一章的主题。
