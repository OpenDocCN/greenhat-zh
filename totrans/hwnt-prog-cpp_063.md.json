["```\n  1 /************************************************\n  2  * find_word -- find a word in the dictionary.  *\n  3  *                                              *\n  4  * Usage:                                       *\n  5  *     find_word <word-start> [<word-start>...] *\n  6  ************************************************/\n  7 #include <iostream>\n  8 #include <fstream>\n  9 #include <iomanip>\n 10 #include <cctype>\n 11 #include <cstring>\n 12 #include <cstdlib>\n 13\n 14 /************************************************\n 15  * tree -- A simple binary tree class           *\n 16  *                                              *\n 17  * Member functions:                            *\n 18  *      enter -- Add an entry to the tree       *\n 19  *      find -- See if an entry is in the tree. *\n 20  ************************************************/\n 21 class tree\n 22 {\n 23     private:\n 24         // The basic node of a tree\n 25         class node {\n 26             private:\n 27                 // tree to the right\n 28                 node    *right;\n 29\n 30                 // tree to the left\n 31                 node    *left;\n 32             public:\n 33                 // data for this tree\n 34                 char    *data;\n 35\n 36             public:\n 37                 node() :\n 38                     right(NULL), left(NULL),\n 39                     data(NULL) {}\n 40                 // Destructor defaults\n 41             private:\n 42                 // No copy constructor\n 43                 node(const node &);\n 44\n 45                 // No assignment operator\n 46                 node & operator = (const node &);\n 47\n 48             // Let tree manipulate our data\n 49             friend class tree;\n 50\n 51         };\n 52\n 53         // the top of the tree\n 54         node *root;\n 55\n 56         // Enter a new node into a tree or\n 57         // sub-tree\n 58         void enter_one(\n 59            // Node of sub-tree to look at\n 60            node *&node,\n 61\n 62            // Word to add\n 63            const char *const data\n 64         );\n 65\n 66         // Find an item in the tree\n 67         void find_one(\n 68             // Prefix to search for\n 69             const char start[],\n 70\n 71             // Node to start search\n 72             const node *const node,\n 73\n 74             // Keep looking flag\n 75             const bool look\n 76         );\n 77     public:\n 78         tree(void) { root = NULL;}\n 79         // Destructor defaults\n 80     private:\n 81         // No copy constructor\n 82         tree(const tree &);\n 83\n 84         // No assignment operator\n 85         tree & operator = (const tree &);\n 86\n 87     public:\n 88         // Add a new data to our tree\n 89         void enter(\n 90             // Data to add\n 91             const char *const data\n 92         ) {\n 93             enter_one(root, data);\n 94         }\n 95\n 96         // Find all words that start\n 97         // with the given prefix\n 98         void find(\n 99             const char start[]  // Starting string\n100         )\n101         {\n102             find_one(start, root, true);\n103         }\n104 };\n105\n106 /************************************************\n107  * tree::enter_one -- enter a data into         *\n108  *      the tree                                *\n109  ************************************************/\n110 void tree::enter_one(\n111    node *&new_node,       // Sub-tree to look at\n112    const char *const data // Word to add\n113 )\n114 {\n115     int  result;        // result of strcmp\n116\n117     // see if we have reached the end\n118     if (new_node == NULL) {\n119         new_node = new node;\n120\n121         new_node->left = NULL;\n122         new_node->right = NULL;\n123         new_node->data = strdup(data);\n124     }\n125\n126     result = strcmp(new_node->data, data);\n127     if (result == 0) {\n128         return;\n129     }\n130\n131     if (result < 0)\n132         enter_one(new_node->right, data);\n133     else\n134         enter_one(new_node->left, data);\n135 }\n136\n137 /************************************************\n138  * tree::find_one -- find words that match this *\n139  *                      one in the tree.        *\n140  ************************************************/\n141 void tree::find_one(\n142         const char start[],   // Start of the work\n143         const node *const top,// Top node\n144         const bool look       // Keep looking\n145 )\n146 {\n147     if (top == NULL)\n148         return;                 // short tree\n149\n150     // Result of checking our prefix\n151     // against the word\n152     int cmp = strncmp(start,\n153             top->data, strlen(start));\n154\n155     if ((cmp < 0) && (look))\n156         find_one(start, top->left, true);\n157     else if ((cmp > 0) && (look))\n158         find_one(start, top->right, true);\n159\n160     if (cmp != 0)\n161         return;\n162\n163     /*\n164      * We found a string that starts this one.\n165      * Keep searching and print things.\n166      */\n167     find_one(start, top->left, false);\n168     std::cout << top->data << '\\n';\n169     find_one(start, top->right, false);\n170 }\n171\n172 int main(int argc, char *argv[])\n173 {\n174     // A tree to hold a set of words\n175     tree dict_tree;\n176\n177     // The dictionary to search\n178     std::ifstream dict_file(\"/usr/dict/words\");\n179\n180     if (dict_file.bad()) {\n181         std::cerr <<\n182             \"Error: Unable to open \"\n183             \"dictionary file\\n\";\n184         exit (8);\n185     }\n186\n187     /*\n188      * Read the dictionary and construct the tree\n189      */\n190     while (1) {\n191         char line[100]; // Line from the file\n192\n193         dict_file.getline(line, sizeof(line));\n194\n195         if (dict_file.eof())\n196             break;\n197\n198         dict_tree.enter(strdup(line));\n199     }\n200     /*\n201      * Search for each word\n202      */\n203     while (argc > 1) {\n204         std::cout << \"------ \" << argv[1] << '\\n';\n205         dict_tree.find(argv[1]);\n206         ++argv;\n207         --argc;\n208     }\n209     return (0);\n210 }\n\n```"]