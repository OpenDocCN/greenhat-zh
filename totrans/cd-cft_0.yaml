- en: Part I. AT THE CODEFACE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。代码面
- en: 'Programmers write programs. It doesn''t take a genius to figure that one out.
    But there is a more subtle distinction: Only good programmers habitually write
    good code. Bad programmers . . . *don''t*. They create messes that take more effort
    to fix than they did to write.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写程序。这不需要天才就能想明白。但有一个更微妙的区别：只有优秀的程序员才会习惯性地编写优秀的代码。糟糕的程序员……*不会*。他们制造出的混乱需要比编写时更多的努力来修复。
- en: Which would you rather be?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你更愿意成为哪种人？
- en: Code craft starts at the codeface; it's where we love to be. We programmers
    are never happier than when immersed in an editor, bashing out line after line
    of perfectly formed and well-executed source code. We'd be quite happy if the
    world around us disappeared in a puff of boolean logic. Sadly, the Real World
    isn't going anywhere—and it doesn't seem willing to keep itself to itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码工艺从代码面开始；这是我们最喜欢的地方。我们程序员只有在沉浸在编辑器中，一行行地敲打出完美形成和执行良好的源代码时，才会感到最快乐。如果我们周围的世界在一阵布尔逻辑的烟雾中消失，我们会非常高兴。遗憾的是，现实世界不会走开——它似乎不愿意将自己局限在自身之内。
- en: 'Around your carefully crafted code, the world is in a chaotic state of change.
    Almo st every software project is characterized by flux: changing requirements,
    changing budgets, changing deadlines, changing priorities, and changing teams.
    These all conspire to make writing good code a very difficult job. Welcome to
    the Real World.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你精心编写的代码周围，世界正处于混乱的变化状态。几乎每个软件项目都以其变化性为特征：不断变化的需求、不断变化的预算、不断变化的截止日期、不断变化的优先级和不断变化的团队。所有这些因素都使得编写优秀的代码变得非常困难。欢迎来到现实世界。
- en: Good programmers naturally write neat code when left to their own devices. But
    theyalso have an array of battle tactics to help write robust code *on the front
    line*. They know how to defend themselves against the harsh realities of the software
    factory and write code that can survive the whirlwinds of change.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的程序员在不受干扰的情况下自然会编写整洁的代码。但他们也有一系列的战斗策略来帮助他们在前线编写健壮的代码 *。他们知道如何保护自己免受软件工厂残酷现实的侵害，并编写能够经受住变化旋风的代码。
- en: That's what we're looking at here. This first section delves into the painfully
    practical, gory details of code construction, the nuts and bolts of writing source
    code statements. You'll learn strategies to keep yourself afloat on the turbulent
    software development ocean and will be challenged to improve your code-writing
    skills.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里要探讨的内容。本节深入探讨了痛苦而实用的代码构建细节，编写源代码语句的螺丝和螺母。你将学习策略来帮助你在波涛汹涌的软件开发海洋中保持浮力，并挑战你提高代码编写技能。
- en: 'These chapters focus on the following issues:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节关注以下问题：
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。防御")'
- en: 'Defensive programming: How to write robust code when the world is conspiring
    against you.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程：当世界与你为敌时，如何编写健壮的代码。
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。最佳计划")'
- en: 'Good presentation: why it''s important and how to present code well.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的展示：为什么它很重要以及如何展示代码。
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。名字的含义")'
- en: Choosing clear names for the parts of your program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为程序的部分选择清晰的名称。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。写作技巧")'
- en: Self-documenting code. Practical strategies to explain code when you can't write
    a whole novel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自我文档化的代码。当你无法写出一整本小说时，解释代码的实际策略。
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。评论")'
- en: Effective techniques for writing the most appropriate code comments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写最合适的代码注释的有效技巧。
- en: '[Chapter 6](ch06.html "Chapter 6. TO ERR IS HUMAN")'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章。人非圣贤，孰能无过")'
- en: 'Handling errors: How to manage operations that *might* go wrong, and what to
    do when they do.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误：如何管理可能出错的操作，以及出错时应该做什么。
- en: These form the path to sound code in an unsound world; they are solid code-writing
    techniques that should become second nature. If you don't write clear, understandable,
    defensive, easily testable, easily maintainable software, then you'll be distracted
    by tedious code-related problems when you should be preparing for what the software
    factory willthrow at you next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构成了在混乱世界中编写良好代码的道路；它们是坚实的代码编写技巧，应该成为第二本能。如果你不编写清晰、易懂、防御性、易于测试和易于维护的软件，那么当你应该为软件工厂接下来会抛出的东西做准备时，你会被繁琐的代码相关问题所困扰。
- en: Chapter 1. ON THE DEFENSIVE
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。防御
- en: '*Defensive Programming Techniques for Robust Code*'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*健壮代码的防御性编程技巧*'
- en: We have to distrust each other. It's our only defense against betrayal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须相互不信任。这是我们对抗背叛的唯一防御。
- en: --Tennessee Williams
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ——田纳西·威廉姆斯
- en: When my daughter was 10 months old, she liked playing with wooden bricks. Well,
    she liked playing with wooden bricks and *me*. I'd build a tower as high as I
    could, and then with a gentle nudge of the bottom brick, she'd topple the whole
    thing and let out a little whoop of delight. I didn't build these towers for their
    strength—it would have been pointless if I did. If I had really wanted a sturdy
    tower, then I'd have built it in a very different way. I'd have shorn up a foundation
    and started with a wide base, rather than just quickly stacking blocks upon each
    other and building as high as possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的女儿十个月大时，她喜欢玩木制积木。嗯，她喜欢和木制积木还有*我*一起玩。我会尽可能堆砌一个高塔，然后轻轻地推一下底部的积木，她就会让整个塔倒塌，并发出一声高兴的尖叫。我建这些塔不是为了它们的强度——如果那样做的话就毫无意义了。如果我真的想要一个坚固的塔，我会用完全不同的方式来建造。我会削平基础，从宽基开始，而不是仅仅快速堆叠积木，尽可能堆得高。
- en: Too many programmers write their code like flimsy towers of bricks; a gentle
    unexpected prod to the base, and the whole thing falls over. Code builds up in
    layers, and we need to use techniques that ensure that each layer is sound so
    that we can build upon it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 太多的程序员编写代码就像易倒的积木塔；轻轻一推底部，整个塔就会倒塌。代码层层叠加，我们需要使用确保每一层都稳固的技术，这样我们才能在此基础上构建。
- en: Toward Good Code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向着优秀的代码迈进
- en: 'There is a huge difference between code that *seems* to work,*correct* code,
    and *good* code. M.A. Jackson wrote, "The beginning of wisdom for a software engineer
    is to recognize the difference between getting a program to work, and getting
    it *right*." ( Jackson 75) There is a difference:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来似乎能工作、*正确的*代码和*好的*代码之间有很大的区别。M.A.杰克逊写道：“软件工程师智慧的起点是认识到让程序工作与让它*正确*之间的区别。”（杰克逊
    75）这里有一个区别：
- en: It is easy to write code that *works* most of the time. You feed it the usual
    set of inputs; it gives the usual set of outputs. But give it something surprising,
    and it might just fall over.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出大多数时候都能工作的代码很容易。你给它通常的输入集；它给出通常的输出集。但是给它一些意想不到的东西，它可能就会倒塌。
- en: '*Correct* code won''t fall over. For all possible sets of input, the output
    will be correct. But usually the set of all possible inputs is ridiculously large
    and hard to test.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正确的*代码不会倒塌。对于所有可能的输入集，输出都将正确。但通常所有可能的输入集非常大，难以测试。'
- en: However, not all correct code is *good* code—the logic may be hard to follow,
    the code may be contrived, and it may be practically impossible to maintain.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，并非所有正确的代码都是*好的*代码——逻辑可能难以理解，代码可能很复杂，而且可能实际上无法维护。
- en: By these definitions, good code is what we should aim for. It is robust, efficient
    enough and, of course, correct. Industrial strength code will not crash or produce
    incorrect results when given unusual inputs. It will also satisfy all other requirements,
    including thread safety, timing constraints, and re-entrancy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，我们应该追求的是好的代码。它健壮、足够高效，当然，是正确的。工业强度的代码在接收到非寻常输入时不会崩溃或产生错误的结果。它还将满足所有其他要求，包括线程安全、时间约束和可重入性。
- en: It's one thing to write this good code in the comfort of your own home, a carefully
    controlled environment. It's an entirely different prospect to do so in the heat
    of the software factory, where the world is changing around you, the codebase
    is rapidly evolving, and you're constantly being faced with grotesque *legacy
    code* —archaic programs written by code monkeys that are now long gone. Try writing
    good code when the world is conspiring to stop you!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己舒适的家中编写这种好的代码是一回事，在一个精心控制的环境中。但在软件工厂的热潮中这样做就完全不同了，那里世界在你周围变化，代码库正在迅速演变，你不断地面临那些怪异的*遗留代码*——由早已消失的代码猴子编写的陈旧程序。当世界联合起来阻止你时，尝试编写好的代码！
- en: In this torturous environment, how do you ensure that your code is industrial
    strength? *Defensive programming* helps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个痛苦的环境中，你如何确保你的代码是工业强度的？*防御性编程*有所帮助。
- en: While there are many ways to construct code (object-oriented approaches, component
    based models, structured design, Extreme Programming, etc.), defensive programming
    is an approach that can be applied universally. It's not so much a formal methodology
    as an informal set of basic guidelines. Defensive programming is not a magical
    cure-all, but a practical way to prevent a pile of potential coding problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多构建代码的方法（面向对象的方法、基于组件的模型、结构化设计、极限编程等），但防御性编程是一种可以普遍应用的方法。它与其说是一种正式的方法论，不如说是一套非正式的基本指南。防御性编程不是万能的灵丹妙药，而是一种预防潜在编码问题的实用方法。
- en: Assume the Worst
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设最坏的情况
- en: When you write code, it's all too easy to make a set of assumptions about how
    it should run, how it will be called, what the valid inputs are, and so on. You
    won't even realize that you've assumed anything, because it all seems obvious
    to you. You'll spend months happily crafting code, as these assumptions fade and
    distort in your mind.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，很容易对它应该如何运行、如何被调用、有效的输入是什么等等做出一系列假设。你可能甚至都没有意识到自己已经做出了假设，因为这一切对你来说似乎都很明显。你可能会快乐地花几个月的时间编写代码，而这时这些假设在你的脑海中逐渐消失和扭曲。
- en: Or you might pick up some old code to make a vital last-minute fix when the
    product's going out the door in 10 minutes. With only enough time for a brief
    glance at its structure, you'll make assumptions about how the code works. There's
    no time to perform full literary criticism, and until you get a chance to prove
    the code is *actually* doing what you think it's doing, assumptions are all you
    have.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能会在产品即将在10分钟内出厂时，捡起一些旧代码进行关键的最后一刻修复。你只有足够的时间匆匆浏览其结构，你将假设代码是如何工作的。没有时间进行全面的文学批评，直到你有机会证明代码实际上正在做你所认为的事情之前，假设就是你拥有的全部。
- en: 'Assumptions cause us to write flawed software. It''s easy to assume:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设会导致我们编写有缺陷的软件。做出假设很容易：
- en: The function won't *ever* be called like that. I will always be passed valid
    parameters only.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数*永远不会*以那种方式被调用。我总是只会传递有效的参数。
- en: This piece of code will *always* work; it will never generate an error.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码将*始终*正常工作；它永远不会产生错误。
- en: '*No one* will ever try to access this variable if I document it *For internal
    use only*.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有人*会尝试访问这个变量，如果我只将其标记为*仅限内部使用*。'
- en: When we program defensively, we shouldn't make *any* assumptions. We should
    never assume that *it can't happen*. We should never assume that the world works
    as we'd expect it to work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行防御性编程时，我们不应该做出*任何*假设。我们永远不应该假设*它不可能发生*。我们永远不应该假设世界会按照我们期望的方式运行。
- en: 'Experience tells us that the only thing you *can* be certain about is this:
    Your code *will* somehow, someday, go wrong. Someone *will* do a dumb thing. Murphy''s
    Law puts it this way: "If it can be used incorrectly, it will." Listen to that
    man—he spoke from experience.^([[1](#ftn.CHP-1-FN-1)]) Defensive programming prevents
    these accidents by foreseeing them, or at least fore-guessing them—figuring out
    what might go wrong at each stage in the code, and guarding against it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经验告诉我们，唯一可以确定的事情是：你的代码*将*以某种方式，在某个时候出错。有人*会*做愚蠢的事情。墨菲定律是这样说的：“如果可以用错，它就会。”听听那个人的话——他是从经验中说的。[1](#ftn.CHP-1-FN-1)]
    防御性编程通过预见这些事故，或者至少预先猜测它们——弄清楚代码每个阶段可能出错的地方，并加以防范，来防止这些事故的发生。
- en: Is this paranoid? Perhaps. But it doesn't hurt to be a *little* paranoid. In
    fact, it makes a lot of sense. As your code evolves, you will forget the original
    set of assumptions you made (and real code does evolve—see [Chapter 15](ch15.html
    "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")). Other programmers
    won't have any knowledge of the assumptions in your head, or else they will just
    make their own invalid assumptions about what your code can do. Software evolution
    exposes weaknesses, and code growth hides original simple assumptions. A little
    paranoia at the outset can makecode a lot more robust in the long run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不是太偏执了？也许吧。但有点偏执并不会伤害到任何人。事实上，这很有道理。随着你的代码的发展，你将忘记最初做出的假设集合（真正的代码确实会发展——参见[第15章](ch15.html
    "第15章。软件演变或软件革命？")）。其他程序员不会了解你头脑中的假设，或者他们只是对你代码能做什么做出自己无效的假设。软件演变会暴露弱点，代码的增长会隐藏原始的简单假设。一开始有点偏执可以使代码在长期运行中更加健壮。
- en: '**KEY CONCEPT**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Assume nothing. Unwritten assumptions continually cause faults, particularly
    as code grows*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要假设任何东西。未写出的假设会不断导致错误，尤其是在代码增长时*。'
- en: 'Add to this the fact that things neither you nor your users have any control
    over can go wrong: Disks fill up, networks fail, and computers crash. Bad things
    happen. Remember, it''s never actually your program that fails—the software always
    does what you told it to. The actual algorithms, or perhaps the client code, are
    what introduce faults into the system.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上这样一个事实：你和你用户都无法控制的事情也可能出错：磁盘满了，网络失败了，计算机崩溃了。坏事发生了。记住，实际上失败的不是你的程序——软件总是按照你告诉它的那样去做。真正的算法，或者可能是客户端代码，是引入系统错误的原因。
- en: As you write more code, and as you work through it faster and faster, the likelihood
    of making mistakes grows and grows. Without adequate time to verify each assumption,
    you can't write robust code. Unfortunately, on the programming front line, there's
    rarely any opportunity to slow down, take stock, and linger over a piece of code.
    The world is just moving too fast, and programmers need to keep up. Therefore,
    we should grasp every opportunity to reduce errors, and defensive practices are
    one of our main weapons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你编写更多的代码，并且以越来越快的速度工作，犯错的几率越来越大。如果没有足够的时间来验证每个假设，你就无法编写健壮的代码。不幸的是，在编程前线，很少有机会放慢速度，审视一下，仔细研究一段代码。世界变化得太快，程序员需要跟上。因此，我们应该抓住每一个减少错误的机会，而防御性实践是我们的主要武器之一。
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) Edward Murphy Jr. was a US Air Force engineer. He coined
    this infamous law after discovering a technician had systematically connected
    a whole row of devices upside down. Symmetric connectors permitted thisavoidable
    mistake; afterward, he chose a different connector design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) 爱德华·墨菲中士是一位美国空军工程师。他在发现一名技术人员系统地错误地将一整排设备颠倒连接后，提出了这个臭名昭著的法律。对称的连接器允许这种可避免的错误发生；之后，他选择了不同的连接器设计。
- en: What Is Defensive Programming?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是防御性编程？
- en: As the name suggests, defensive programming is careful, guarded programming.
    To construct reliable software, we design every component in the system so that
    it *protects* itself as much as possible. We smash unwritten assumptions by explicitly
    checking for them in the code. This is an attempt to prevent, or at least observe,
    when our code is called in a way that will exhibit incorrect behavior.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，防御性编程是谨慎、守卫的编程。为了构建可靠的软件，我们设计系统中的每个组件，使其尽可能自我保护。我们通过在代码中明确检查它们来打破未写明的假设。这是尝试防止，或者至少观察我们的代码以某种方式被调用时将表现出不正确行为的一种尝试。
- en: 'Defensive programming enables us to detect minor problems early on, rather
    than get bitten by them later when they''ve escalated into major disasters. All
    too often, you''ll see "professional" developers rush out code without thinking.
    The story goes something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程使我们能够及早发现小问题，而不是等到它们演变成大灾难时才被咬。过于常见的是，你会看到“专业”的开发者匆忙推出代码而不加思考。故事可能就像这样：
- en: '![What Is Defensive Programming?](tagoreillycom20080909nostarchimages207431.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![什么是防御性编程？](tagoreillycom20080909nostarchimages207431.png)'
- en: 'They are continually tripped up by the incorrect assumptions that they never
    took the time to validate. Hardly a promotion for modern day software engineering,
    but it''s happening all the time. Defensive programming helps us to write correct
    software from the start and move away from the *code-it*, *try-it*, *code-it*,
    *try-it* . . . cycle. With defensive programming, the story looks more like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不断地被那些他们从未花时间验证的错误假设所困扰。这几乎不是对现代软件工程的宣传，但它却时常发生。防御性编程帮助我们从一开始就编写正确的软件，并摆脱*编写它*，*尝试它*，*编写它*，*尝试它*……的循环。使用防御性编程，故事看起来更像这样：
- en: '![What Is Defensive Programming?](tagoreillycom20080909nostarchimages207435.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![什么是防御性编程？](tagoreillycom20080909nostarchimages207435.png)'
- en: Okay, defensive programming won't remove program failures altogether. But problems
    will become less of a hassle and easier to fix. Defensive programmers catch falling
    snowflakes rather than get buried under an avalanche of errors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，防御性编程并不能完全消除程序故障。但问题将变得不那么麻烦，更容易解决。防御性程序员捕捉到的是飘落的雪花，而不是被错误的大雪崩所掩埋。
- en: Defensive programming is a method of prevention, rather than a form of cure.
    Compare this to debugging—the act of removing bugs *after* they've bitten. Debugging
    is all about finding a cure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程是一种预防方法，而不是一种治疗方法。将其与调试进行比较——在虫子咬人之后移除虫子的行为。调试完全是关于寻找治疗方法。
- en: '**WHAT DEFENSIVE PROGRAMMING ISN''T**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御性编程不是什么**'
- en: 'There are a few common misconceptions about defensive programming. Defensive
    programming is not:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于防御性编程有一些常见的误解。防御性编程不是：
- en: '**Error checking**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误检查**'
- en: If there are error conditions that might arise in your code, you should be checking
    for them anyway. This is not defensive code. It's just plain good practice—a part
    of writing *correct* code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码中可能出现错误条件，你应该检查它们。这不是防御性代码。这只是良好的实践——编写*正确*代码的一部分。
- en: '**Testing**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: Testing your code is not defensive. It's another normal part of our development
    work. Test harnesses aren't defensive; they can prove the code is correct now,
    butwon't prove that it will stand up to future modification. Even with the best
    test suite in the world, anyone can make a change and slip it past untested.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的代码不是防御性的。它是我们开发工作中的另一个正常部分。测试工具不是防御性的；它们可以证明代码现在是正确的，但不会证明它能够经受未来的修改。即使拥有世界上最好的测试套件，任何人都可以做出更改，并使其通过未经测试的审查。
- en: '**Debugging**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**'
- en: You might add some defensive code during a spell of debugging, but debugging
    is something you do after your program has failed. Defensive programming is somethingyou
    do to *prevent* your program from failing in the first place (or to detect failures
    early before they manifest in incomprehensible ways, demanding all-night debugging
    sessions).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试期间，你可能需要添加一些防御性代码，但调试是在你的程序失败之后进行的。防御性编程是你为了*防止*程序一开始就失败（或者及早检测到失败，在它们以难以理解的方式显现之前，需要整夜调试）而采取的措施。
- en: 'Is defensive programming really worth the hassle? There are arguments for and
    against:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程真的值得麻烦吗？有赞成和反对的论点：
- en: '**The case** against'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**反对的案例**'
- en: Defensive programming consumes resources, both yours and the computer's.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程消耗资源，包括你的和电脑的。
- en: It eats into the efficiency of your code; even a little extra code requires
    a little extra execution. For a single function or class, this might not matter,
    but when you have a system made up of 100,000 functions, you may have more of
    a problem.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会降低你代码的效率；即使是额外的少量代码也需要额外的执行。对于一个函数或类来说，这可能无关紧要，但当你有一个由100,000个函数组成的系统时，你可能会有更多的问题。
- en: Each defensive practice requires some extra work. Why should you follow any
    of them? You have enough to do already, right? Just make sure people use your
    code correctly. If they don't, then any problems are their own fault.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每项防御性实践都需要一些额外的工作。你为什么应该遵循其中任何一项？你已经有很多事情要做，对吧？只需确保人们正确使用你的代码。如果他们不这样做，那么任何问题都是他们自己的责任。
- en: '**The case** for'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例**为'
- en: The counterargument is compelling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 反驳论点是很有说服力的。
- en: 'Defensive programming saves you literally hours of debugging and lets you do
    more fun stuff instead. Remember Murphy: If your code *can* be used incorrectly,
    it will be.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程可以为你节省大量的调试时间，让你有更多的时间去做有趣的事情。记住墨菲定律：如果你的代码*可能*被错误使用，它就会。
- en: Working code that runs properly, but ever-so-slightly slower, is *far* superior
    to code that works most of the time but occasionally collapses in a shower of
    brightly colored sparks.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行正常但稍微慢一点的代码，与大多数时候运行但偶尔会崩溃，散发出五彩斑斓的火花相比，要好得多。
- en: We can design some defensive code to be physically removed in release builds,
    circumventing the performance issue. The majority of the items we'll consider
    here don't have any significant overhead, anyway.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以设计一些防御性代码，在发布版本中物理移除，绕过性能问题。我们在这里考虑的大多数项目实际上并没有任何显著的额外开销。
- en: Defensive programming avoids a large number of security problems—a serious issue
    in modern software development. More on this follows.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程避免了大量安全问题——这是现代软件开发中的一个严重问题。更多内容将在后面讨论。
- en: As the market demands software that's built faster and cheaper, we need to focus
    on techniques that deliver results. Don't skip the bit of extra work up front
    that will prevent a whole world of pain and delay later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着市场对更快、更便宜软件的需求增加，我们需要关注能够产生结果的技术。不要跳过前端额外的努力，这可以防止以后的痛苦和延误。
- en: The Big, Bad World
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 险恶的大千世界
- en: Someone once said, "Never ascribe to malice that which is adequately explained
    by stupidity."^([[2](#ftn.CHP-1-FN-2)]) Most of the time we are defending against
    stupidity, against invalid and unchecked assumptions. However there *are* malicious
    users, and they will try to bend and break your code to suit their vicious purposes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说：“不要把可以由愚蠢解释的事情归咎于恶意。”^([[2](#ftn.CHP-1-FN-2)]) 大多数时候，我们是在防御愚蠢，防御无效和未经检查的假设。然而，确实存在恶意用户，他们会试图扭曲和破坏你的代码，以适应他们邪恶的目的。
- en: Defensive programming helps with program security, guarding against this kind
    of willful misuse. Crackers and virus writers routinely exploit sloppy code to
    gain control of an application and then weave whatever wicked schemes they desire.
    This is a serious threat in the modern world of software development; it has huge
    implications in terms of the loss of productivity, money, and privacy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程有助于提高程序安全性，防止这种故意的滥用。黑客和病毒编写者通常会利用马虎的代码来控制应用程序，然后编织他们想要的任何邪恶计划。在当今软件开发的世界中，这是一个严重的威胁；它对生产力、金钱和隐私的损失有着巨大的影响。
- en: Software abusers range from the opportunistic user exploiting a small program
    quirk to the hard-core cracker who spends his time deliberately trying to gain
    illicit access to your systems. Too many unwitting programmers leave gaping holes
    for these people to walk through. With the rise of the networked computer, the
    consequences of sloppiness become more and more significant.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 软件滥用者从利用小程序的小缺陷的机会主义者到花费时间故意试图非法访问你系统的硬核黑客都有。太多的无意识程序员为这些人留下了巨大的漏洞。随着网络化计算机的兴起，粗心大意的后果变得越来越严重。
- en: Many large development corporations are finally waking up to this threat and
    are beginning to take the problem seriously, investing time and resources into
    serious defensive code work. In reality, it's hard to graft in defenses *after*
    an attack. We look at software security in more detail in [Chapter 12](ch12.html
    "Chapter 12. AN INSECURITY COMPLEX").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型开发公司终于开始意识到这个威胁，并开始认真对待这个问题，投入时间和资源进行严肃的防御性代码工作。实际上，攻击发生后很难再添加防御措施。我们将在[第12章](ch12.html
    "第12章。不安全复杂")中更详细地探讨软件安全。
- en: Techniques for Defensive Programming
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御性编程技术
- en: Enough of the background. What does all this mean to programmers working in
    the software factory?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 背景介绍就到这里。这一切对在软件工厂工作的程序员意味着什么呢？
- en: There are a number of common sense rules under the defensive programming umbrella.
    People usually think of *assertions* when they think of defensive programming,
    and rightly so. We'll talk about those later. But there's also a pile of simple
    programming habits that will immeasurably improve the safety of your code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在防御性编程的范畴下，有许多常识性规则。人们通常在想到防御性编程时会想到**断言**，这是正确的。我们稍后会讨论这些。但还有一些简单的编程习惯可以极大地提高你代码的安全性。
- en: Despite seeming common sense, these rules are often ignored—hence the low standard
    of most software at large in the world. Tighter security and reliable development
    can be achieved surprisingly easily, as long as programmers are alert and well
    informed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些规则看起来是常识，但它们通常被忽视——这就是世界上大多数软件标准低的原因。只要程序员保持警觉并充分了解信息，更严格的安全和可靠的开发可以出人意料地容易实现。
- en: The next few pages list the rules of defensive programming. We'll start off
    by painting with broad strokes, looking at high-level defensive techniques, processes,
    and procedures. As we progress, we'll fill in finer detail, looking more deeply
    at individual code statements. Some of these defensive techniques are language
    specific. This is natural—you have to put on bulletproof shoes if your language
    lets you shoot yourself in the foot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几页列出了防御性编程的规则。我们将从宏观的角度开始，探讨高级防御技术、流程和程序。随着我们的进展，我们将填充更详细的细节，更深入地查看单个代码语句。其中一些防御技术是针对特定语言的。这是自然的——如果你的语言允许你自伤，你就必须穿上防弹鞋。
- en: As you read this list, evaluate yourself. How many of these rules do you currently
    follow? Which ones will you now adopt?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这个列表时，评估一下自己。你目前遵循了多少条规则？你将现在采用哪几条？
- en: Employ a Good Coding Style and Sound Design
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用良好的编码风格和可靠的设计
- en: We can prevent most coding mistakes by adopting a good coding style. This naturally
    dovetails with the other chapters in this section. Simple things like choosing
    meaningful variable names and using parentheses judiciously can increase clarity
    and reduce the likelihood of faults slipping past unnoticed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用良好的编码风格，我们可以防止大多数编码错误。这自然与这一节的其他章节相吻合。简单的事情，比如选择有意义的变量名和恰当地使用括号，可以提高清晰度并减少错误未被注意到的可能性。
- en: Similarly, considering the larger-scale design before ploughing into the code
    is key. "The best documentation of a computer program is a clean structure." (Kernighan
    Plaugher 78) Starting off with a set of clear APIs to implement, a logical system
    structure, and well-defined component roles and responsibilities will avoid headaches
    further down the line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在深入代码之前考虑更大的设计规模是关键。“计算机程序的最佳文档是清晰的结构。”（Kernighan Plaugher 78）从一组清晰的API开始实现，一个逻辑的系统结构，以及定义良好的组件角色和责任，将避免在以后遇到麻烦。
- en: Don't Code in a Hurry
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要急于编码
- en: It's all too common to see hit-and-run programming. Programmers quickly hack
    out a function, shove it through the compiler to check syntax, run it once to
    see if it works, and then move on to the next task. This approach is fraught with
    peril.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看到程序员快速编写函数，将其推入编译器检查语法，运行一次看是否工作，然后继续下一个任务的“击跑式编程”现象非常普遍。这种方法充满了危险。
- en: Instead, think about each line as you write it. What errors could arise? Have
    you considered every logical twist that might occur? Slow, methodical programming
    seems mundane—but it really does cut down on the number of faults introduced.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在编写每一行时都要思考。可能会出现哪些错误？你是否考虑了所有可能发生的逻辑转折？缓慢而细致的编程看似平凡，但实际上可以减少引入的错误数量。
- en: '**KEY CONCEPT**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*More haste, less speed. Always think carefully about what you''re typing as
    you typeit*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲速则不达。在输入时始终仔细思考你所键入的内容*。'
- en: A particular C-family gotcha that snares speedy programmers is mistyping `==`
    as just `=`. The former is a test for equality; the latter a variable assignment.
    With an unhelpful compiler (or with warnings switched off) there will be no indication
    that the program behavior is not what was intended.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 某个C家族的陷阱会捕捉到快速编程者，那就是将`==`误写成`=`。前者是相等测试；后者是变量赋值。在没有帮助的编译器（或者关闭了警告）的情况下，不会有任何迹象表明程序行为不是你所期望的。
- en: Always do *all* of the tasks involved in completing a code section before rushing
    on. For example, if you decide to write the main flow first and the error checking/handling
    second, you must be sure you have the discipline to do both. Be very wary of deferring
    the error checking and moving straight on to the main flow of three more code
    sections. Your intention to return later may be sincere, but later can easily
    become much later, by which time you will have forgotten much of the context,
    making it take longer and be more of a chore. (And of course, by then there will
    be some artificially urgent deadline.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在匆忙进行之前，始终完成完成代码部分所涉及的所有任务。例如，如果你决定首先编写主流程，然后是错误检查/处理，你必须确保你有纪律去做这两件事。对于推迟错误检查并直接进入三个更多代码部分的主流程要非常小心。你打算稍后返回的意图可能是真诚的，但“稍后”可能很快就会变得非常晚，到那时你可能会忘记很多上下文，使得工作变得耗时且更加繁琐。（当然，那时可能还会有一些人为的紧急截止日期。）
- en: Discipline is a habit that needs to be learned and reinforced. Every time you
    don't do the right thing now, you become more likely to continue not doing the
    right thing in the future. Do it now; don't leave it for a rainy day in the Sahara.
    Doing it later actually requires *more* discipline than doing it now!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 纪律是一种需要学习和加强的习惯。每次你没有做正确的事情，你将来继续不做正确事情的可能性就更大。现在就做；不要把它留到撒哈拉沙漠的雨天。稍后做实际上需要*更多*的纪律！
- en: Trust No One
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信任无人
- en: Your mother told you never to talk to strangers. Unfortunately, good software
    development requires even more cynicism and less faith in human nature. Even well-intentioned
    code users could cause problems in your program; being defensive means you can't
    trust anybody.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你的母亲曾告诉你不要和陌生人说话。不幸的是，良好的软件开发需要更多的怀疑和更少对人性本身的信任。即使是好意的代码使用者也可能在你的程序中引起问题；采取防御性措施意味着你不能信任任何人。
- en: 'You might suffer problems because of:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会因为以下原因遇到问题：
- en: '**Genuine users** accidentally giving bogus input or operating the program
    incorrectly.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实用户**意外地输入了无效的输入或错误地操作程序。'
- en: '**Malicious users** trying to consciously provoke bad program behavior.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意用户**试图有意识地引发不良的程序行为。'
- en: '**Client code** calling your function with the wrong parameters or supplying
    inconsistent input.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端代码**使用错误的参数调用你的函数或提供不一致的输入。'
- en: '**The operating environment** failing to provide adequate service to the program.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统环境**未能为程序提供足够的服务。'
- en: '**External libraries** behaving badly and failing to honor interface contracts
    that you rely on.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部库**表现不佳，未能遵守你依赖的接口合同。'
- en: You might even make a silly coding mistake in one function or forget how some
    three-year-old code is supposed to work and then use it badly. Don't assume that
    all will go well or that all code will operate correctly. Put safety checks in
    place throughout your work. Constantly watch for weak spots, and guard against
    them with extra-defensive code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能在某个函数中犯下愚蠢的编码错误，或者忘记了一些三年前的代码应该如何工作，然后错误地使用它。不要假设一切都会顺利，或者所有代码都会正确运行。在整个工作中设置安全检查。始终警惕弱点，并用额外的防御性代码来防范它们。
- en: '**KEY CONCEPT**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Trust no one. Absolutely anyone—including yourself—can introduce flaws into
    your program logic. Treat all inputs and all results with suspicion until you
    can prove that they are valid*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要相信任何人。绝对任何人——包括你自己——都可能将缺陷引入你的程序逻辑。在证明它们有效之前，对所有的输入和所有的结果都持怀疑态度*。'
- en: Write Code for Clarity, Not Brevity
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了清晰，而不是简洁，编写代码
- en: Whenever you can choose between concise (but potentially confusing) code and
    clear (but potentially tedious) code, use code that *reads* as intended, even
    if it's less elegant. For example, split complex arithmetic operations into a
    series of separate statements to make the logic clearer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以选择简洁（但可能令人困惑）的代码和清晰（但可能令人厌烦）的代码时，使用看起来是意图的代码，即使它不那么优雅。例如，将复杂的算术运算分解成一系列单独的语句，以使逻辑更清晰。
- en: Think about who might read your code. It might require maintenance work by a
    junior coder, and if he can't understand the logic, then he's bound to make mistakes.
    Complicated constructs or unusual language tricks might prove your encyclopedic
    knowledge of operator precedence, but it really butchers code maintainability.
    *Keep it simple*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑谁可能会阅读你的代码。它可能需要由初级程序员进行维护工作，如果他不能理解逻辑，那么他肯定会犯错误。复杂的结构或非同寻常的语言技巧可能证明了你对运算符优先级的百科全书式知识，但它实际上破坏了代码的可维护性。*保持简单*。
- en: If it can't be maintained, your code is not safe. In really extreme cases, overly
    complex expressions can cause the compiler to generate incorrect code—many compiler
    optimization errors come to light this way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它无法维护，你的代码就不安全。在极端情况下，过于复杂的表达式可能导致编译器生成不正确的代码——许多编译器优化错误就是这样暴露出来的。
- en: '**KEY CONCEPT**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Simplicity is a virtue. Never make code more complex than necessary*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单是一种美德。永远不要使代码比必要的更复杂*。'
- en: Don't Let Anyone Tinker with Stuff They Shouldn't
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要让任何人随意修改他们不应该修改的东西
- en: Things that are internal should stay on the inside. Things that are private
    should be kept under lock and key. Don't display your code's dirty laundry in
    public. No matter how politely you ask, people *will* fiddle with your data when
    you're not looking if given half a chance, and they *will* try to call "implementation-only"
    routines for their own reasons. Don't let them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的东西应该保持在内部。私有的东西应该被锁起来。不要在公共场合展示你代码的“脏衣服”。无论你多么礼貌地请求，如果有机会，人们 *都会* 在你不注意的时候摆弄你的数据，并且
    *会* 尝试出于他们自己的原因调用“仅实现”例程。不要让他们这样做。
- en: In object-oriented languages, prevent access to internal class data by making
    it private. In C++, consider the Cheshire cat (or pimpl) idiom—a common technique
    for keeping a class's internal structure out of its public header file. (Meyers
    97)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象的编程语言中，通过将其设置为私有来防止对内部类数据的访问。在C++中，考虑使用“猫脸”（或pimpl）惯用用法——这是一种常见的技巧，用于将类的内部结构排除在其公共头文件之外。（Meyers
    97）
- en: In procedural languages, you can still employ object-oriented (OO) packaging
    concepts, by wrapping private data behind opaque types and providing well-defined
    public operations on them.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过程式语言中，你仍然可以通过将私有数据封装在不可见类型后面，并为其提供定义良好的公共操作来使用面向对象（OO）封装概念。
- en: Keep all variables in the tightest scope necessary; don't declare variables
    globally when you don't have to. Don't put them at file scope when they can be
    function-local. Don't place them at function scope when they can be loop-local.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有变量保持在最必要的紧密作用域内；当你不需要时不要全局声明变量。当它们可以是函数局部变量时，不要将它们放在文件作用域。当它们可以是循环局部变量时，不要将它们放在函数作用域。
- en: '**SAY "WHEN"**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**说“何时”**'
- en: '*When* do you program defensively? Do you start when things go wrong? Or when
    you pick up some code you don''t understand?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*何时*进行防御性编程？你是当事情出错时开始吗？还是当你遇到你不理解的代码时？'
- en: No, these defensive programming techniques should be used *all the time*. They
    shouldbe second nature. Mature programmers have learned from experience—they've
    been bitten enough times that they know to put sensible safeguards in place.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这些防御性编程技术应该始终使用。它们应该成为第二天性。成熟的程序员已经从经验中学习——他们已经被咬了很多次，知道要设置合理的防护措施。
- en: Defensive strategies are much easier to apply as you start writing code, rather
    than retrofitting them into existentcode. You can't be thorough and accurate if
    you try to shoehorn in this stuff late in theday. If you start adding defensive
    code once something has gone wrong, you are essentially debugging—being reactive,
    notpreventative and proactive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 防御策略在你开始编写代码时更容易应用，而不是将它们添加到现有代码中。如果你试图在一天晚些时候强行加入这些内容，你将无法做到彻底和准确。如果你在出现问题后开始添加防御代码，你实际上是在进行调试——是反应性的，而不是预防性和主动性的。
- en: However, during the course of debugging, or even when adding new functionalityyou'll
    discover conditions that you'd like to verify. It's always a good time to adddefensive
    code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在调试过程中，甚至在添加新功能时，你会发现你想要验证的条件。添加防御代码总是好的时机。
- en: Compile with All Warnings Switched On
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全部启用警告进行编译
- en: Most languages' compilers draw on a vast selection of error messages when you
    hurt their feelings. They will also spit out various *warnings* when they encounter
    potentially flawed code, like the use of a C or C++ variable before its assignment.^([[3](#ftn.CHP-1-FN-3)])
    These warnings can usually be selectively enabled and disabled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言的编译器在你伤害它们的感情时，会引用大量的错误信息。当它们遇到可能存在缺陷的代码时，如在使用C或C++变量之前没有对其进行赋值时，它们也会发出各种*警告*。[^[[3](#ftn.CHP-1-FN-3)])
    这些警告通常可以单独启用和禁用。
- en: If your code is full of dangerous constructs, you'll get pages and pages of
    warnings. Sadly, the common response is to disable compiler warnings or just ignore
    the messages. Don't do either.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码充满了危险的结构，你会得到一页又一页的警告。遗憾的是，常见的反应是禁用编译器警告或者只是忽略这些信息。不要这样做。
- en: '*Always* enable your compiler''s warnings. And if your code generates any warnings,
    fix the code immediately to silence the compiler''s screams. Never be satisfied
    with code that doesn''t compile quietly when warnings are enabled. The warnings
    are there for a reason. Even if there''s a particular warning you think doesn''t
    matter, don''t leave it in, or one day it will obscure one that *does* matter.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*始终*启用你的编译器的警告。如果你的代码产生了任何警告，立即修复代码以平息编译器的尖叫。不要满足于在启用警告时无法静默编译的代码。警告存在是有原因的。即使你认为某个特定的警告不重要，也不要留下它，否则有一天它可能会掩盖一个真正重要的警告。'
- en: '**KEY CONCEPT**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Compiler warnings catch many silly coding errors. Always enable them. Make
    sure your code compiles silently*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译器警告可以捕捉到许多愚蠢的编码错误。始终启用它们。确保你的代码在启用警告的情况下静默编译*。'
- en: Use Static Analysis Tools
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态分析工具
- en: Compiler warnings are the result of a limited *static analysis* of your code,
    a code inspection performed *before* the program is run.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器警告是你代码的有限*静态分析*的结果，这是一种在程序运行之前进行的代码检查。
- en: There are many separate static analysis tools available, like `lint` (and its
    more modern derivatives) for C and FxCop for .NET assemblies. Your daily programming
    routine should include use of these tools to check your code. They will pick up
    many more errors than your compiler alone.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的独立静态分析工具有很多，例如用于C语言的`lint`（及其更现代的衍生工具）和用于.NET组件的FxCop。你的日常编程流程应该包括使用这些工具来检查你的代码。它们能发现比单独的编译器更多的错误。
- en: Use Safe Data Structures
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全数据结构
- en: Or failing that, use dangerous data structures safely.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果没有成功，请安全地使用危险的数据结构。
- en: Perhaps the most common security vulnerability results from *buffer overrun*.
    This is triggered by the careless use of fixed-size data structures. If your code
    writes into a buffer without checking its size first, then there is always potential
    for writing past the end of the buffer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常见的安全漏洞源于*缓冲区溢出*。这通常是由于对固定大小数据结构的粗心使用而触发的。如果你的代码在写入缓冲区之前没有先检查其大小，那么总是有可能写入到缓冲区的末尾之外。
- en: 'It''s frighteningly easy to do, as this small snippet of C++ code demonstrates:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常容易做到，就像这个小的C++代码片段所展示的那样：
- en: '[PRE0]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the length of the data in `source` is greater than 10 characters, its copy
    will extend beyond the end of `buffer`'s reserved memory. Then anything could
    happen. In the best case, the result would be data corruption—some other data
    structure's contents will be overwritten. In the worst case, a malicious user
    could exploit this simple error to put executable code on the program stack and
    use it to run his own arbitrary program, effectively hijacking the computer. These
    kinds of flaw are regularly exploited by system crackers—serious stuff.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`source`中的数据长度大于10个字符，它的副本将超出`buffer`预留内存的末尾。然后可能发生任何事情。在最好的情况下，结果是数据损坏——其他数据结构的某些内容将被覆盖。在最坏的情况下，恶意用户可能利用这个简单的错误在程序堆栈上放置可执行代码，并使用它来运行他自己的任意程序，从而有效地劫持计算机。这类漏洞经常被系统破解者利用——这是严重的事情。
- en: 'It''s easy to avoid being bitten by these vulnerabilities: Don''t write such
    bad code! Use safer data structures that don''t allow you to corrupt the program—use
    a managed buffer like C++''s `string` class. Or systematically use safe operations
    on unsafe data types. The C++ code above can be secured by swapping `strcpy` for
    `strncpy`, a size-limited string copy operation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些漏洞被咬很容易：不要编写如此糟糕的代码！使用更安全的数据结构，这些数据结构不允许你破坏程序——使用C++的`string`类这样的管理缓冲区。或者系统地使用对不安全数据类型的安全操作。上面的C++代码可以通过将`strcpy`替换为`strncpy`（一个大小受限的字符串复制操作）来得到保护：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Check Every Return Value
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查每个返回值
- en: If a function returns a value, it does so for a reason. Check that return value.
    If it is an error code, you *must* inspect it and handle any failure. Don't let
    errors silently invade your program; swallowing an error can lead to unpredictable
    behavior.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回一个值，那么它有它的原因。检查这个返回值。如果它是一个错误代码，你*必须*检查它并处理任何失败。不要让错误默默地侵入你的程序；吞下错误可能导致不可预测的行为。
- en: This applies to user-defined functions as well as standard library ones. Most
    of the insidious bugs you'll find arise when a programmer fails to check a return
    value. Don't forget that some functions may return errors through a different
    mechanism (i.e., the standard C library's *errno*). Always catch and handle appropriate
    exceptions at the appropriate level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于用户定义的函数以及标准库函数。大多数你发现的隐蔽错误都是在程序员未能检查返回值时出现的。不要忘记，一些函数可能通过不同的机制返回错误（即标准C库的*errno*）。始终在适当的级别捕获并处理适当的异常。
- en: Handle Memory (and Other Precious Resources) Carefully
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨慎处理内存（以及其他宝贵资源）
- en: Be thorough and release any resource that you acquire during execution. Memory
    is the example of this cited most often, but it is not the only one. Files and
    thread locks are other precious resources that we must use carefully. Be a good
    steward.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要彻底，并在执行过程中释放你获取的任何资源。内存是这种被引用最多的例子，但并非唯一。文件和线程锁也是我们必须谨慎使用的宝贵资源。做一个好的管家。
- en: Don't neglect to close files or release memory because you think that the OS
    will clean up your program when it exits. You really don't know how long your
    code will be left running, eating up all file handles or consuming all the memory.
    You can't even be sure that the OS will cleanly release your resources—some OSes
    don't.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视关闭文件或释放内存，因为你认为操作系统会在程序退出时清理你的程序。你真的不知道你的代码会运行多长时间，消耗所有文件句柄或消耗所有内存。你甚至不能确定操作系统会干净地释放你的资源——一些操作系统不会。
- en: There is a school of thought that says, "Don't worry about freeing memory until
    you know your program works in the first place; only then add all the relevant
    releases." Just say no. This is a ludicrously dangerous practice. It will lead
    to many, many errors in your memory usage; you *will* inevitably forget to free
    memory in some places.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种观点认为：“不要担心释放内存，直到你知道你的程序首先能正常工作；只有那时才添加所有相关的释放。”只是说“不”。这是一种极其危险的做法。它会导致你在内存使用中犯许多错误；你*不可避免地*会忘记在某些地方释放内存。
- en: '**KEY CONCEPT**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Treat all scarce resources with respect. Manage their acquisition and release
    carefully*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*对待所有稀缺资源都要表示尊重。谨慎管理它们的获取和释放*。'
- en: Java and .NET employ a garbage collector to do all this tedious tidying up for
    you, so you can just "forget" about freeing resources. Let them drop to the floor,
    since the run time sweeps up every now and then. It's a nice luxury, but don't
    be lulled into a false sense of security. You still have to think. You have to
    explicitly drop references to objects you no longer care about, or they won't
    be cleaned up; don't accidentally hold on to an object reference. Less advanced
    garbage collectors are also easily fooled by circular references (e.g., A refers
    to *B*, and *B* refers to *A*, but no one else cares about them). This could cause
    objects to never be swept up; a subtle form of memory leak.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Java和.NET使用垃圾回收器为你完成所有这些繁琐的清理工作，因此你可以“忘记”释放资源。让它们掉到地上，因为运行时会不时地清理。这是一个美好的奢侈，但不要被虚假的安全感所迷惑。你仍然需要思考。你必须明确地删除你不再关心的对象的引用，否则它们不会被清理；不要意外地保留对象引用。较不先进的垃圾回收器也容易被循环引用（例如，A引用B，B引用A，但没有人关心它们）所欺骗。这可能导致对象永远不会被清理；这是一种微妙的内存泄漏形式。
- en: Initialize All Variables at Their Points of Declaration
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在声明变量的地方初始化所有变量
- en: This is a clarity issue. The intent of each variable is explicit if you initialize
    it. It's not safe to rely on rules of thumb like *If I don't initialize it, I
    don't care about the initial value*. The code will evolve. The uninitialized value
    may turn into a problem further down the line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个清晰度问题。如果你初始化了变量，每个变量的意图都是明确的。依靠诸如“如果我没有初始化它，我就不关心初始值”这样的经验法则是不安全的。代码会演变。未初始化的值可能会在未来的某个时刻变成问题。
- en: C and C++ compound this issue. If you accidentally use a variable without having
    initialized it, you'll get different results each time your program runs, depending
    on what garbage was in memory at the time. Declaring a variable in one place,
    assigning it later on, and then using it even later opens up a window for errors.
    If the assignment is ever skipped, you'll spend ages hunting down random behavior.
    Close the window by initializing every variable as you declare it; even if the
    value's wrong, the behavior will at least be predictably wrong.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++使这个问题更加复杂。如果你意外地使用了一个未初始化的变量，每次程序运行时你都会得到不同的结果，这取决于当时内存中的垃圾是什么。在一个地方声明一个变量，稍后分配它，然后更晚些时候使用它，这为错误打开了窗口。如果分配被省略，你将花费大量时间寻找随机行为。通过在声明时初始化每个变量来关闭这个窗口；即使值是错误的，行为至少是可预测地错误的。
- en: Safer languages (like Java and C#) sidestep this pitfall by defining an initial
    value for all variables. It's still good practice to initialize a variable as
    you declare it, which improves code clarity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的语言（如Java和C#）通过为所有变量定义一个初始值来避免这个陷阱。在声明变量时初始化变量仍然是良好的实践，这可以提高代码的可读性。
- en: Declare Variables as Late as Possible
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能晚地声明变量
- en: By doing this, you place the variable as close as possible to its use, preventing
    it from confusing other parts of the code. It also clarifies the code using the
    variable. You don't have to hunt around to find the variable's type and initialization;
    a nearby declaration makes it obvious.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你将变量放置得尽可能靠近其使用位置，防止它混淆代码的其他部分。这也通过变量澄清了代码。你不必四处寻找变量的类型和初始化信息；附近的声明使其一目了然。
- en: Don't reuse the same temporary variable in a number of places, even if each
    use is in a logically separate area. It makes later reworking of the code awfully
    complicated. Create a new variable each time—the compiler will sort out any efficiency
    concerns.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在多个地方重复使用相同的临时变量，即使每次使用都在逻辑上独立的区域。这会使代码的后期重构变得极其复杂。每次都创建一个新的变量——编译器会处理任何效率问题。
- en: Use Standard Language Facilities
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准语言功能
- en: C and C++ are nightmares in this respect. They suffer from many different revisions
    of their specifications, with more obscure cases left as implementation-specific
    *undefined behavior*. Today there are many compilers, each with subtly different
    behavior. They are mostly compatible, but there is still plenty of rope to hang
    yourself with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，C和C++是噩梦。它们经历了许多不同的规范修订，其中一些较为隐晦的情况被留为特定实现的*未定义行为*。如今有众多编译器，每个编译器都有细微不同的行为。它们大多数是兼容的，但仍然存在很多可能导致错误的隐患。
- en: Clearly define which language version you are using. Unless mandated by your
    project (and there had better be a good reason), *don't* rely on compiler weirdness
    or any nonstandard extensions to the language. If there is an area of the language
    that is undefined, don't rely on the behavior of your particular compiler (e.g.,
    don't rely on your C compiler treating `char` as a `signed` value—others won't).
    Doing so leads to very brittle code. What happens when you update the compiler?
    What happens when a new programmer joins the team who doesn't understand the extensions?
    Relying on a particular compiler's odd behavior leads to *really* subtle bugs
    later in life.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义你正在使用的语言版本。除非你的项目有要求（并且最好有一个很好的理由），*不要*依赖于编译器的怪异行为或语言的非标准扩展。如果语言中有未定义的区域，不要依赖于你特定编译器的行为（例如，不要依赖于你的C编译器将`char`视为`signed`值——其他人不会这样做）。这样做会导致非常脆弱的代码。当你更新编译器时会发生什么？当一个新的程序员加入团队而不理解这些扩展时会发生什么？依赖于特定编译器的怪异行为会导致以后出现*真正*微妙的错误。
- en: Use a Good Diagnostic Logging Facility
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用良好的诊断日志工具
- en: When you write some new code, you'll often include a lot of diagnostics to check
    what's going on. Should these really be removed after the event? Leaving them
    in will make life easier when you have to revisit the code, especially if they
    can be selectively disabled in the meantime.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一些新的代码时，你通常会包含大量的诊断信息来检查正在发生的事情。这些诊断信息在事件发生后真的应该被移除吗？保留它们会在你需要重新访问代码时使生活变得更轻松，特别是如果它们可以在同时被选择性地禁用的话。
- en: There are a number of diagnostic logging systems available to facilitate this.
    Many can be used in such a way that diagnostics have no overhead if not needed;
    they can be conditionally compiled out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多诊断日志系统可供使用，以简化这一过程。许多系统可以在不需要时无额外开销地使用；它们可以被条件性地编译出来。
- en: Cast Carefully
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心类型转换
- en: Most languages allow you to *cast* (or convert) data from one type to another.
    This operation is some times more successful than others. If you try to convert
    a 64-bit integer into a smaller 8-bit data type, what will happen to the other
    56 bits? Your execution environment might suddenly throw an exception or silently
    degrade your data's integrity. Many programmers don't think about this kind of
    thing, and so their programs behave in unnatural ways.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言允许你将数据从一种类型转换为另一种类型（或转换）。这种操作有时比其他操作更成功。如果你尝试将64位整数转换为较小的8位数据类型，其他56位会发生什么？你的执行环境可能会突然抛出一个异常或默默地降低数据完整性。许多程序员没有考虑这类事情，因此他们的程序以不自然的方式运行。
- en: 'If you really want to use a cast, think carefully about it. What you''re saying
    to the compiler is, "Forget your type checking: I know what this variable is,
    you don''t." You''re ripping a big hole into the type system and walking straight
    through it. It''s unstable ground; if you make any kind of mistake, the compiler
    will just sit there quietly and mutter, "I told you so," under its breath. If
    you''re lucky (e.g., using Java or C#) the run time might throw an exception to
    let you know, but this depends on exactly what you''re trying to convert.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想使用类型转换，请仔细考虑。你对编译器说的是：“忘记你的类型检查：我知道这个变量的类型，你不知道。”你正在在类型系统中撕开一个大洞，然后直接穿过它。这是不稳定的地带；如果你犯任何错误，编译器会静静地坐在那里，低声咕哝，“我早就告诉你了。”如果你很幸运（例如，使用Java或C#），运行时可能会抛出一个异常来让你知道，但这取决于你试图转换的确切内容。
- en: C and C++ are particularly vague about the precision of data types, so don't
    make assumptions about data type interchangeability. Don't presume that int and
    `long` are the same size and can be assigned to one another, even if you can get
    away with it on *your* platform. Code migrates platforms, but bad code migrates
    badly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++在数据类型的精度方面特别模糊，因此不要假设数据类型可以互换。不要假设int和`long`具有相同的大小并且可以相互赋值，即使你在自己的平台上可以这样做。代码会迁移到不同的平台，但糟糕的代码会以糟糕的方式迁移。
- en: The Fine Print
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细节说明
- en: 'There are many low-level defensive construction techniques, all part of a sensible
    coding routine and a healthy distrust of the Real World. Consider:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多低级别的防御性构建技术，这些都是合理的编码惯例和对现实世界健康怀疑的一部分。考虑：
- en: '**Providing default behavior**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供默认行为**'
- en: Most languages provide a `switch` statement; they document what happens in the
    `default` case. If the default case is erroneous, make that explicit in the code.
    If nothing happens, make *that* explicit in the code—that way the maintenance
    programmer will understand.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都提供了`switch`语句；它们记录了`default`情况下的行为。如果`default`情况是错误的，请在代码中明确指出。如果没有发生任何操作，请明确在代码中说明——这样维护程序员才能理解。
- en: Similarly, if you write an `if` statement without an `else` clause, stop for
    a moment and consider whether you should handle the logical default case.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你编写了一个没有`else`子句的`if`语句，请停下来片刻，考虑你是否应该处理逻辑默认情况。
- en: '**Following language idioms**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**遵循语言习惯**'
- en: This simple piece of advice will ensure that your readers understand all of
    the code you have written. They'll make fewer bad assumptions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这条简单的建议将确保你的读者理解你编写的所有代码。他们会做出更少的错误假设。
- en: '**Checking numeric limits**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查数值限制**'
- en: Even the most basic calculations may cause numeric variables to overflow or
    underflow. Be on the lookout for this. Language specifications or core libraries
    provide mechanisms for determining the capacity of standard types—use them. Make
    sure you know all the available numeric types, and what each is most suitable
    for.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最基本的计算也可能导致数值变量溢出或下溢。请注意这一点。语言规范或核心库提供了确定标准类型容量的机制——使用它们。确保你知道所有可用的数值类型，以及每种类型最适合什么。
- en: Check that each calculation is sound. For example, make sure you can't use values
    that would cause a *divide by zero* error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确认每个计算都是合理的。例如，确保你不会使用会导致**除以零**错误的值。
- en: '**Beingconst-***`correct`*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**const-***`正确`*'
- en: 'C/C++ programmers should be really vigilant about this—it will make life much
    easier. Make everything as `const` as you possibly can. It does two things: `const`
    qualifications act as code documentation, and `const` allows the compiler to spot
    silly mistakes that you make. It prevents you from modifying data that''s off-limits.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++程序员应该对此非常警觉——这将使生活更加容易。尽可能地将一切设置为`const`。它做两件事：`const`修饰符充当代码文档，并且`const`允许编译器发现你犯的愚蠢错误。它阻止你修改受限的数据。
- en: Constraints
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束
- en: We've thought about the set of assumptions we make as we program. But how can
    we physically incorporate these assumptions into our software so they're not illusive
    problems waiting to emerge? Simply write a little extra code to check for each
    condition. This code acts as the documentation of each assumption, making it explicit
    rather than implicit.^([[4](#ftn.CHP-1-FN-4)]) In doing so, we're codifying the
    *constraints* on program functionality and behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了我们编程时做出的假设集合。但我们如何将这些假设物理地纳入我们的软件中，使它们不再是即将出现的隐性问题？只需编写一些额外的代码来检查每个条件。这段代码充当每个假设的文档，使其明确而不是隐含。[^[[4](#ftn.CHP-1-FN-4)])
    在这样做的时候，我们正在将程序功能和行为的**约束**编码化。
- en: 'What do we want the program to do if a constraint is broken? Since this kind
    of constraint will be more than a simple detectable and correctable run-time error
    (we should already be checking for and handling those), it must be a flaw in the
    program logic. There are few possibilities for the program''s reaction:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约束被违反，我们希望程序做什么？由于这种约束将不仅仅是简单的可检测和可纠正的运行时错误（我们本应该已经检查并处理这些错误），它必须是程序逻辑中的缺陷。程序的反应可能性很少：
- en: Turn a blind eye to the problem, and hope that nothing will go wrong as a consequence.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对问题视而不见，并希望不会因此发生任何问题。
- en: Give it an on-the-spot fine and allow the program to continue (e.g., print a
    diagnostic warning or log the error).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场罚款并允许程序继续（例如，打印诊断警告或记录错误）。
- en: Go directly to jail; do not pass go (e.g., abort the program immediately, in
    a controlled or uncontrolled manner).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接进入监狱；不要通过（例如，立即以控制或不受控制的方式终止程序）。
- en: For example, it is invalid to call C's `strlen` function with a string pointer
    set to zero, because the pointer will be immediately dereferenced, so the latter
    two options are the most plausible candidates. It's probably most appropriate
    to abort the program immediately, since derefencing a null pointer can lead to
    all sorts of catastrophes on unprotected operating systems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用设置为零的字符串指针调用C的`strlen`函数是不合法的，因为指针将被立即解引用，所以后两种选择是最可能的候选。最合适的做法可能是立即终止程序，因为解引用空指针可能导致在未受保护的操作系统上发生各种灾难。
- en: 'There are a number of different scenarios in which constraints are used:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多不同的场景中都会使用约束：
- en: '**Preconditions**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**前置条件**'
- en: These are conditions that must hold true *before* a section of code is entered.
    If a precondition fails, it's due to a fault in the client code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在进入代码段之前必须成立的条件。如果前置条件失败，那是因为客户端代码中的错误。
- en: '**Postconditions**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**后置条件**'
- en: These must hold true *after* a code block is left. If a postcondition fails,
    it's due to a fault in the supplier code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必须在代码块离开后仍然成立。如果后置条件失败，那是因为供应商代码中的错误。
- en: '**Invariants**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**不变量**'
- en: 'These are conditions that hold true every time the program''s execution reaches
    a particular point: between loop passes, across method calls, and so on. Failure
    of an invariant implies a fault in the program logic.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在程序执行达到特定点时始终成立的条件：在循环迭代之间、方法调用之间等等。不变量的失败意味着程序逻辑中的错误。
- en: '**Assertions**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**'
- en: Any other statement about a program's state at a given point in time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序在特定时间点的任何其他状态声明。
- en: The first two listed here are frustrating to implement without language support—if
    a function has multiple exit points,^([[5](#ftn.CHP-1-FN-5)]) then inserting a
    postcondition gets messy. Eiffel supports pre- and postconditions in the core
    language and can also ensure that constraint checks don't have any side effects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的前两项在没有语言支持的情况下实现起来很令人沮丧——如果一个函数有多个退出点，^([[5](#ftn.CHP-1-FN-5)]) 那么插入后置条件会变得混乱。Eiffel支持核心语言中的前置和后置条件，并且还可以确保约束检查没有副作用。
- en: However tedious, good constraints expressed in code make your program clearer
    and more maintainable. This technique is also known as *design by contract*, since
    constraints form an immutable contract between sections of code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些繁琐，但用代码表达的良好约束可以使你的程序更清晰、更易于维护。这种技术也被称为*设计合同*，因为约束在代码的不同部分之间形成了一个不可变的合同。
- en: What to Constrain
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**要约束的内容**'
- en: 'There are a number of different problems you can guard against with constraints.
    For example, you can:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用约束来保护多种不同的问题。例如，你可以：
- en: Check all array accesses are within bounds.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有数组访问都在范围内。
- en: Assert that pointers are not zero before dereferencing them.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解引用指针之前断言指针不是零。
- en: Ensure that function parameters are valid.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数参数有效。
- en: Sanity check function results before returning them.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在返回之前对函数结果进行合理性检查。
- en: Prove that an object's state is consistent before operating on it.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作对象之前证明对象的状态是一致的。
- en: Guard any place in the code where you'd write the comment *We should never get
    here*.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护代码中任何可能写入注释*我们不应该到达这里*的地方。
- en: The first two of these examples are particularly C/C++ focused. Java and C#
    have their own ways of avoiding some of these pitfalls in the core language, as
    do other languages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例特别关注C/C++。Java和C#有它们自己的方式来避免核心语言中的一些这些陷阱，其他语言也是如此。
- en: 'Just how much constraint checking should you do? Placing a check on every other
    line is a bit extreme. As with many things, the correct balance becomes clear
    as the programmer gets more mature. Is it better to have too much or too little?
    It is possible for too many constraint checks to obscure the code''s logic. "Readability
    is the best single criterion of program quality: If a program is easy to read,
    it is probably a good program; if it is hard to read, it probably isn''t good."
    (Kernighan Plaugher 76)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该进行多少约束检查呢？每行都进行检查有些过于极端。就像许多事情一样，正确的平衡随着程序员经验的增长而变得清晰。是过多还是过少更好？过多的约束检查可能会掩盖代码的逻辑。
    "可读性是程序质量的最佳单一标准：如果一个程序易于阅读，那么它可能是一个好程序；如果它难以阅读，那么它可能不是一个好程序。" (Kernighan Plaugher
    76)
- en: Realistically, putting pre- and postconditions in major functions plus invariants
    in the key loops is sufficient.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将前置和后置条件放入主要函数以及将不变量放入关键循环中就足够了。
- en: Removing Constraints
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除约束
- en: This kind of constraint checking is usually only required during the development
    and debugging stages of program construction. Once we have used the constraints
    to convince ourselves (rightly or wrongly) that the program logic is correct,
    we would ideally remove them so as not to incur an unnecessary run-time overhead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的约束检查通常只在程序构建的开发和调试阶段需要。一旦我们使用约束来确信（无论正确与否）程序逻辑是正确的，我们理想上会移除它们，以避免不必要的运行时开销。
- en: 'Thanks to the wonders of modern technology, all of this is perfectly possible.
    The C and C++ standard libraries provide a common mechanism to implement constraints—`assert.
    assert` acts as a procedural firewall, testing the logic of its argument. It is
    provided as an alarm for the developer to show incorrect program behavior and
    should not be allowed to trigger in customer-facing code. If the assertion''s
    constraint is satisfied execution continues. Otherwise, the program aborts, producing
    an error message looking something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了现代技术的奇迹，所有这些都完全可能。C 和 C++ 标准库提供了一个通用的机制来实现约束—`assert`。`assert` 作为过程防火墙，测试其参数的逻辑。它被提供为开发者的警报，以显示程序的不正确行为，并且不应允许在面向客户的代码中触发。如果断言的约束得到满足，则执行继续。否则，程序将终止，并产生类似以下错误信息的消息：
- en: '[PRE2]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`assert` is implemented as a preprocessor macro, which means it sits more naturally
    in C than in C++. There are a number of more C++-sympathetic assertion libraries
    available.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 被实现为一个预处理宏，这意味着它在 C 中比在 C++ 中更自然。有一些更符合 C++ 风格的断言库可用。'
- en: To use `assert` you must `#include <assert.h>.` You can then write something
    like `assert(ptr != 0);` in your function. Preprocessor magic allows us to strip
    out assertions in a production build by specifying the `NDEBUG` flag to the compiler.
    All `asserts` will be removed, and their arguments will not be evaluated. This
    means that in production builds `asserts` have no overhead at all.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `assert`，你必须 `#include <assert.h>.` 你可以在你的函数中编写类似 `assert(ptr != 0);` 的内容。预处理器的魔法允许我们通过向编译器指定
    `NDEBUG` 标志来在生产构建中删除断言。所有 `asserts` 都将被移除，并且它们的参数将不会评估。这意味着在生产构建中 `asserts` 完全没有开销。
- en: Whether or not assertions *should* be completely removed, as opposed to just
    being made nonfatal, is a debatable issue. There is a school of thought that says
    after you remove them, you are testing a *completely different* piece of code.^([[6](#ftn.CHP-1-FN-6)])
    Others say that the overhead of assertions is not acceptable in a release build,
    so they must be eliminated. (But how often do people profile execution to prove
    this?)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与其说断言 `应该` 完全移除，不如说只是使其非致命，这是一个有争议的问题。有一种观点认为，在移除它们之后，你正在测试的是 *完全不同的* 代码片段.^([[6](#ftn.CHP-1-FN-6)])
    另一些人认为，断言的开销在发布构建中是不可接受的，因此必须消除。（但人们多久会分析执行来证明这一点？）
- en: 'Either way, our assertions must not have any side effects. What would happen,
    for example, if you mistakenly wrote:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们的断言都不能有任何副作用。例如，如果你错误地编写了：
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The assertion will clearly never trigger in a debug build; its value is 6 (near
    enough *true* for C). However, in a release build, the `assert` line will be removed
    completely and the `printf` will produce different output. This can be the cause
    of subtle problems late in product development. It's quite hard to guard against
    bugs in the bug-checking code!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 断言在调试构建中显然永远不会触发；其值是 6（对于 C 来说足够接近 *true*）。然而，在发布构建中，`assert` 行将被完全移除，`printf`
    将产生不同的输出。这可能是产品开发后期出现微妙问题的原因。保护调试代码中的错误非常困难！
- en: It's not difficult to envision situations where assertions might have even more
    subtle side effects. For example, if you `assert`(`invariants()`);, yet the `invariants()`
    function has a side effect, it's not easy to spot.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 容易想象出断言可能产生更微妙副作用的情况。例如，如果你 `assert`(`invariants()`);，而 `invariants()` 函数有副作用，那么很难发现。
- en: Since assertions can be removed in production code, it is vital that only constraint
    testing is done with `assert`. Real error-condition testing, like memory allocation
    failure or filesystem problems, should be dealt with in ordinary code. You wouldn't
    want to compile that out of your program! Justifiable run-time errors (no matter
    how undesirable) should be detected with defensive code that can never be removed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断言可以在生产代码中移除，因此仅使用 `assert` 进行约束测试至关重要。真正的错误条件测试，如内存分配失败或文件系统问题，应在普通代码中处理。你不会希望从程序中编译掉这些内容！合理的运行时错误（无论多么不希望）应通过无法移除的防御性代码来检测。
- en: Java has a `similar` assert mechanism.^([[7](#ftn.CHP-1-FN-7)]) It can be enabled
    and disabled by controls on the JVM, and throws an exception (`java.lang.AssertionError`)
    instead of causing an instant program abort. .NET provides an assertion mechanism
    in the framework's `Debug` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有一个 `类似` 的断言机制^([[7](#ftn.CHP-1-FN-7)])。它可以通过 JVM 上的控制来启用和禁用，并且会抛出异常（`java.lang.AssertionError`），而不是导致程序立即终止。.NET
    在框架的 `Debug` 类中提供了断言机制。
- en: '**OFFENSIVE PROGRAMMING?**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击性编程？**'
- en: '*The best defense is a good offense*.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*最好的防御就是进攻*。'
- en: —*Proverb*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: —*谚语*
- en: While writing this chapter, I wondered, *What's the opposite of defensive programming?*
    It's *offensive programming*, of course!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这一章时，我 wonder，*防御性编程的反面是什么？* 当然是*进攻性编程*！
- en: There are a number of people I know who you could call offensive programmers.
    But I think there's more to this than swearing at your computer and never taking
    baths
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我认识一些人，你可以称他们为进攻性程序员。但我想这不仅仅是对着电脑咒骂，从不洗澡那么简单。
- en: It stands to reason that an offensive programming approach would be actively
    trying to *break* things in the code, rather than defending against problems.
    That is, actively attacking the code rather than securing it. I'd call that *testing*.
    As we'll see later in "[Who, What, When, and Why?](ch08s02.html "Who, What, When,
    and Why?")" on page 132, testing, when done properly, has an incredibly positive
    effect on your software construction. It improves code quality greatly and brings
    stability to the development process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上讲，进攻性编程方法会积极尝试*破坏*代码，而不是防御问题。也就是说，积极攻击代码而不是保护它。我称之为*测试*。正如我们将在第132页的"[谁，什么，何时，为什么？](ch08s02.html
    "Who, What, When, and Why?")"中看到的那样，当正确执行时，测试对你的软件构建有极其积极的影响。它极大地提高了代码质量，并为开发过程带来了稳定性。
- en: We should be all offensive programmers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都应该成为进攻性程序员。
- en: When you discover and fix a fault, it is good practice to slip in an assertion
    where the fault was fixed. Then you can ensure that you won't be bitten twice.
    If nothing else, this would act as a warning sign to people maintaining the code
    in the future.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现并修复一个故障时，一个好的做法是在修复故障的地方插入一个断言。这样你就可以确保你不会再次被咬。至少，这会作为警告标志提醒未来维护代码的人。
- en: A common C++/Java technique for writing class constraints is to add a single
    memberfunction called `bool invariant()` to each class. (Naturally this function
    should have no side effects.) Now an `assert` can be put at the beginning and
    end of each member function calling this invariant. (There should be no assertion
    at the beginning of a constructor or at the end of the destructor, for obvious
    reasons.) For example, a `circle` class's invariant may check that `radius !=
    0`; that would be invalid object state and could cause later calculations to fail
    (perhaps with a divide by zero error).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: C++/Java编写类约束的常见技术是为每个类添加一个名为`bool invariant()`的单个成员函数。（自然，这个函数应该没有副作用。）现在可以在每个调用此不变量的成员函数的开始和结束处放置一个`assert`。显然，构造函数的开始或析构函数的结束不应有断言。（出于明显的原因。）例如，一个`circle`类的不变量可能检查`radius
    != 0`；这将是一个无效的对象状态，可能导致后续计算失败（可能是因为除以零错误）。
- en: '* * *'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-1-FN-2)]) Some historians attribute this quote to Napoleon Bonaparte.
    Now there's a guy who knew something about defense.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) 一些历史学家将这句话归功于拿破仑·波拿巴。现在有一个 guy，他对防御之道颇有了解。
- en: ^([[3](#CHP-1-FN-3)]) Many languages (like Java and C#) classify this as an
    error.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) 许多语言（如Java和C#）将此视为错误。
- en: ^([[4](#CHP-1-FN-4)]) This doesn't replace writing good documentation, though.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) 虽然如此，这并不能取代编写良好的文档。
- en: ^([[5](#CHP-1-FN-5)]) There is a theological debate about whether functions
    *should* have multiple exit points.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) 关于函数*是否*应该有多个出口点，存在神学上的争论。
- en: ^([[6](#CHP-1-FN-6)]) In practice, more may change between development and release
    builds of software—compiler optimization levels and the inclusion of debugging
    symbols, for example. Both of these can make subtle differences to execution and
    may obscure the manifestation of other faults. During even the earliest stages
    of development, testing should be performed equally with development and release
    builds.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-1-FN-6)]) 实际上，在软件开发和发布构建之间可能会有更多变化——例如编译器优化级别和调试符号的包含。这两者都可能对执行产生微妙的影响，并可能掩盖其他错误的迹象。即使在开发的最早期阶段，也应该与开发和发布构建一样进行测试。
- en: ^([[7](#CHP-1-FN-7)]) It was added in JDK 1.4 and is not available in earlier
    versions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-1-FN-7)]) 它是在JDK 1.4中添加的，在早期版本中不可用。
- en: In a Nutshell
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Draw water for the siege, strengthen your defenses! Work the clay, tread the
    mortar, repair the brickwork!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为围攻取水，加强你的防御！揉泥，踩灰浆，修补砖墙！
- en: --Nahum 3:14
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: --纳胡姆 3:14
- en: It is important to craft code that is not just correct but is also good. It
    needs to document all the assumptions made. This will make it easier to maintain,
    and it will harbor fewer bugs. Defensive programming is a method of expecting
    the worst and being prepared for it. It's a technique that prevents simple faults
    from becoming elusive bugs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不仅正确而且优秀的代码很重要。它需要记录所有做出的假设。这将使其更容易维护，并且会减少错误。防御性编程是一种预期最坏情况并为此做好准备的方法。这是一种防止简单错误变成难以捉摸的bug的技术。
- en: The use of codified constraints alongside defensive code will make your software
    far more robust. Like many other good coding practices (*unit testing*, for example—see
    "[The Types of Test](ch08s04.html "The Types of Test")" on page 138), defensive
    programming is about spending a little extra time wisely (and early) in order
    to save much more time, effort, and cost later. Believe me, this *can* save an
    entire project from ruin.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在防御性代码旁边使用编码约束会使你的软件更加健壮。像许多其他良好的编码实践（例如——见第138页的"[测试类型](ch08s04.html "测试类型")"）一样，防御性编程是关于明智地（并且尽早）花一点额外的时间，以便在以后节省更多的时间、精力和成本。相信我，这*可以*拯救整个项目免于毁灭。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员…… | 坏程序员…… |'
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Care that their code is robust
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关心他们的代码是否健壮
- en: Make sure every assumption is explicitly captured in defensive code
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在防御性代码中明确捕捉到每个假设
- en: Want well-defined behavior for garbage input
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望对垃圾输入有明确的行为定义
- en: Think carefully about the code they write, as they write it
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写代码时仔细思考他们所写的代码
- en: Write code that protects itself from other people's (or their own) stupidity
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写能够保护自己免受他人（或他们自己）愚蠢行为的代码
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Would rather not think about what could go wrong in their code
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不愿意思考他们的代码中可能出错的地方
- en: Release code for integration that may fail and hope that someone else will sort
    it out
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布可能失败的代码以供集成，并希望其他人会将其解决
- en: Leave important information about how their code should be used locked in their
    heads, ready to be lost
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有关他们代码如何使用的的重要信息锁在他们脑海中，随时可能丢失
- en: Apply little thought to the code they are writing, resulting in unpredictable
    and unreliable software
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对他们所编写的代码思考不多，导致软件不可预测且不可靠
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试时刻")'
- en: '*Offensive programming*—say no more.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*进攻性编程*——无需多言。'
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。寻找错误")'
- en: When faults breach your careful defenses, you'll need a strategy to round them
    up.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当错误突破你精心设置的防线时，你需要一个策略来收拾它们。
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。不安全感复杂")'
- en: Defensive programming is a key technique for writing secure software systems.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程是编写安全软件系统的一项关键技术。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: You must document pre- and postconditions; how else will anyone know they exist?
    If you have any constraints specified, then you can add defensive code to assert
    them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记录预先条件和后续条件；否则，任何人如何知道它们存在？如果你指定了任何约束，则可以添加防御性代码来断言它们。
- en: '![See Also](tagoreillycom20080909nostarchimages207440.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![另请参阅](tagoreillycom20080909nostarchimages207440.png)'
- en: Get Thinking
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 463.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第463页的"[附录A](apa.html "附录A。答案与讨论")"部分可以找到对这些问题的详细讨论。
- en: Mull It Over
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: Can you have *too much* defensive programming?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以有*太多*的防御性编程吗？
- en: Should you add an assertion to your code for every bug you find and fix?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该在代码中为每个找到和修复的错误添加断言？
- en: Should assertions conditionally compile away to nothing in production builds?
    If not, which assertions should remain in release builds?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言是否应该在生产构建中条件性地编译为空？如果不是，哪些断言应该保留在发布构建中？
- en: Are exceptions a better form of defensive barrier than C-style assertions?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常是否是比C风格断言更好的防御性屏障？
- en: Should the defensive checking of pre- and postconditions be put *inside* each
    function, or around each important function *call*?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预先条件和后续条件的防御性检查应该放在每个函数*内部*，还是围绕每个重要的函数*调用*？
- en: Are constraints a perfect defensive tool? What are their drawbacks?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约束是完美的防御工具吗？它们有什么缺点？
- en: Can you *avoid* defensive programming?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以*避免*防御性编程吗？
- en: If you designed a *better* language, would defensive programming still be necessary?
    How could you do this?
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你设计了一种*更好*的语言，防御性编程仍然有必要吗？你该如何做到这一点？
- en: Does this show that C and C++ are flawed because they have so many areas for
    problems to manifest?
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是否表明C和C++因为存在许多问题表现的地方而存在缺陷？
- en: What sort of code do you not need to worry about writing defensively?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不需要担心编写防御性代码的代码类型是什么？
- en: Getting Personal
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: How carefully do you consider each statement that you type? Do you relentlessly
    check every function return code, even if you're *sure* a function will not return
    an error?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在键入每个语句时考虑得有多仔细？你是否不懈地检查每个函数的返回代码，即使你*确信*一个函数不会返回错误？
- en: When you document a function, do you state the pre- and postconditions?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你记录一个函数时，你是否声明了前置和后置条件？
- en: Are they always implicit in the description of what the function does?
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们在函数功能的描述中是否总是隐含的？
- en: If there are no pre- or postconditions, do you explicitly document this?
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有前置或后置条件，你是否明确地记录了这一点？
- en: Many companies pay lip service to defensive programming. Does your team recommend
    it? Take a look at the codebase—do they really? How widely are constraints codified
    in assertions? How thorough is the error checking in each function?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多公司只是口头上提到防御性编程。你的团队推荐它吗？看看代码库——他们真的这样做吗？约束在断言中是如何编码的？每个函数中的错误检查有多彻底？
- en: Are you naturally paranoid enough? Do you look both ways before crossing the
    road? Do you eat your greens? Do you check for every potential error in your code,
    no matter how unlikely?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否足够偏执？在过马路之前你是否会两边都看？你是否吃你的绿色蔬菜？你是否检查代码中的每一个潜在错误，无论可能性有多小？
- en: How easy is it to do this thoroughly? Do you forget to think about errors?
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全做到这一点有多容易？你是否忘记了考虑错误？
- en: Are there any ways to help yourself write more thorough defensive code?
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有方法可以帮助你写出更全面的防御性代码？
- en: Chapter 2. THE BEST LAID PLANS
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章　最佳计划
- en: '*The Layout and Presentation of Source Code*'
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*源代码的布局和展示*'
- en: Stop judging by mere appearances, and make a right judgment.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 停止仅仅根据外表进行评判，做出正确的判断。
- en: --John 7:24
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: --约翰7:24
- en: Coding style has been, is, and will continue to be the subject of holy wars
    among programmers—professional, amateur, and student—where, unfortunately, intense
    disagreements degrade into mere name-calling. *I'll show you where to stick your
    stupid brackets*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 编码风格一直是，现在是，并将继续是程序员（专业、业余和学生的）之间圣战的课题——不幸的是，激烈的分歧降级为仅仅互相叫骂。*我会让你看看你的愚蠢括号该放哪里*。
- en: The first company I ever worked for kick-started a process to define its internal
    coding standard. The guidelines were supposed to encompass several languages,
    defining common conventions and best practices. Months later, the group compiling
    the guidelines was still arguing about where to put brackets in C. I'm not sure
    if anyone ever followed the standard that was eventually produced.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经工作的第一家公司启动了一个过程来定义其内部编码标准。这些指南本应涵盖几种语言，定义共同的约定和最佳实践。几个月后，编译指南的小组仍在争论C语言中括号应该放在哪里。我不确定是否有人最终遵循了产生的标准。
- en: Why *do* people get so worked up about this? As we'll see, presentation dramatically
    affects the readability of code—no one wants to work with code that isn't easy
    to read. Presentation is also a very subjective and personal thing—*you* may not
    like the style that turns *me* on. Familiarity breeds comfort, and an alien style
    puts you on edge.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么人们对此如此激动？正如我们将看到的，展示方式极大地影响了代码的可读性——没有人愿意与难以阅读的代码一起工作。展示也是一个非常主观和个人化的事情——*你*可能不喜欢让我兴奋的风格。熟悉带来舒适，而陌生的风格会让你感到紧张。
- en: Programmers are passionate about code, so presentation stirs deep emotions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员对代码充满热情，因此展示方式会引发强烈的情感。
- en: What's the Big Deal?
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这有什么大不了的？
- en: The layout and presentation of code is an issue in most modern programming languages.
    The freedom of formatting that permits individual artistic expression came *en
    vogue* in the early 1960s with the language Algol; the previously available Fortran
    versions had been more restricted in format. Since then, very few languages have
    deviated from that free-form approach.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的布局和展示在现代大多数编程语言中都是一个问题。允许个人艺术表达的格式自由在20世纪60年代初随着Algol语言的出现而流行起来；之前可用的Fortran版本在格式上更为受限。从那时起，很少有语言偏离了这种自由形式的处理方法。
- en: A code presentation style governs a surprisingly large number of things; brace
    positioning is the most obvious^([[1](#ftn.CHP-2-FN-1)]) and perhaps the most
    contentious issue. The wider aspects of code style, like conventions for function
    and variable naming, tie in with other coding concerns such as program structure
    (e.g.,*Don't use* *`gotos`*, or *Only write Single Entry, Single Exit functions*)
    to dictate the style in which you write a program. Altogether, this constitutes
    your *coding standard*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示风格控制着许多事情；大括号的位置是最明显的^([[1](#ftn.CHP-2-FN-1)])，也许是最有争议的问题。代码风格的更广泛方面，如函数和变量命名的约定，与其他编码关注点（例如程序结构，例如*不要使用*
    *`gotos`*，或*只编写单入口、单出口函数*）相结合，以规定你编写程序的风格。总的来说，这构成了你的*编码标准*。
- en: Although there are many individual choices to make when you define a code presentation
    format, all are aesthetic. By definition, presentation has no syntactic or semantic
    meaning at all; the compiler ignores it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在定义代码展示格式时有很多个人选择要做，但所有这些都是审美上的。按照定义，展示没有任何语法或语义意义；编译器会忽略它。
- en: 'However, presentation makes a real impact on the quality of code. Programmers
    read meaning into code based on its layout. It can illuminate and support your
    code''s structure, helping the reader understand what''s going on. Or it can confuse,
    mislead, and hide the code''s intent. It doesn''t matter how well designed your
    program is; if it looks like a thrown-together mess, it will be unpleasant to
    work with. But bad formatting not only makes code harder to follow; it may actually
    *hide* bugs from you. As a simple example of this, consider the following C code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码的展示方式对代码质量有着实际的影响。程序员会根据代码的布局来解读其含义。它可以阐明并支持你的代码结构，帮助读者理解正在发生的事情。或者它可能会造成混淆、误导并隐藏代码的意图。不管你的程序设计得多好；如果它看起来像一团糟，那么使用起来将会很不愉快。但糟糕的格式化不仅会使代码难以追踪；它甚至可能实际上*隐藏*了错误。作为一个简单的例子，考虑以下C代码：
- en: '[PRE4]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The layout shows what the author meant to happen, but he'll be surprised when
    the code actually runs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 布局显示了作者想要发生的事情，但当他看到代码实际运行时，他会感到惊讶。
- en: Since we're conscientious craftsmen committed to high-quality code, we strive
    for clear presentation. There are already plenty of stumbling blocks in software
    development; we shouldn't let basic code presentation become one of them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是有责任感的工匠，致力于高质量的代码，我们努力追求清晰的展示。软件开发中已经有很多障碍；我们不应该让基本的代码展示成为其中之一。
- en: '* * *'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-2-FN-1)]) *Brace* is a common name for the curly bracket (that is,
    { and }) so common in C-style programming languages.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-2-FN-1)]) *大括号*是花括号（即{和}）的常见名称，这在C风格编程语言中非常常见。
- en: Know Your Audience
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解你的受众
- en: 'To write effective source code, it''s important to know *who* you''re presenting
    it to. If you''re going to confuse someone, you''d better know who deserves the
    apology. There are, in fact, three audiences for our source code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写有效的源代码，了解*你*向谁展示代码非常重要。如果你要让人困惑，你最好知道谁应该得到道歉。实际上，我们的源代码有三个受众：
- en: '**Ourselves**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们自己**'
- en: My handwriting is so bad that sometimes even *I* can't read it. It's practically
    useless unless I concentrate on writing clearly. It's the same with code. You
    have to be able to read what you've written immediately after you write it, but
    also perhaps years later when you come back to it. Who would have expected to
    come back to archaic (relatively speaking) COBOL code to fix a Y2K bug?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我的书法如此糟糕，有时甚至*我*自己都读不懂。除非我专注于清晰地写作，否则它几乎毫无用处。代码也是如此。你必须能够立即阅读你所写的内容，也许在多年后当你再次回到它时也是如此。谁能预料到会回到古老的（相对而言）COBOL代码去修复Y2K错误？
- en: '**The compiler**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器**'
- en: The compiler doesn't care what your code looks like, as long as it doesn't have
    any syntactic errors. The *intent* of the code is completely ignored. You can
    write detailed comments explaining what you *want* a function to do, but the compiler
    won't tell you if the instructions don't actually do what your comments say. As
    long as it's valid code, your development environment will be happy.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不在乎你的代码看起来如何，只要它没有语法错误。代码的*意图*完全被忽略。你可以写详细的注释来解释你希望函数做什么，但编译器不会告诉你指令是否实际上做了你注释中说的。只要它是有效的代码，你的开发环境就会满意。
- en: '**Others**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他人**'
- en: This is the most important audience and often the least considered.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的受众，但往往是最少被考虑的。
- en: So you're working in a team, but you're the only person who will ever see your
    bit of code, right? Wrong. It never works that way.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你在一个团队中工作，但你是唯一会看到你代码片段的人，对吧？错。事情永远不会是这样。
- en: You're at home writing some code for fun; no one will ever see it. You don't
    need to worry about making it neat, do you? No, you don't; but how would that
    benefit you? You aren't developing skills that will make you a professional. This
    is the perfect opportunity to practice really good discipline on a project with
    no external pressures. A chance to get into good habits. If you blow it here,
    is it any wonder you have no discipline on "real" projects?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你在家编写一些代码以娱乐自己；没有人会看到它。你不需要担心让它整洁，对吧？不，你不需要；但这对你有何好处？你并没有在培养让你成为专业人士的技能。这是在一个没有外部压力的项目上练习真正良好纪律的完美机会。这是一个养成良好习惯的机会。如果你在这里失败了，你在“真实”项目上没有纪律难道不是令人惊讶的吗？
- en: Your source code is a document, describing the program you are creating. It
    needs to read clearly to whoever might come back to it. This will include those
    auditing (code reviewing) the work you have done and anyone who maintains it later.
    Be kind to people who have to look after your code—just imagine yourself in their
    shoes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你的源代码是一份文档，描述了你正在创建的程序。它需要清晰地供任何可能回来查看它的人阅读。这包括审计（代码审查）你所做的工作的人以及后来维护它的人。对那些不得不照顾你代码的人来说要友好——想象一下你自己站在他们的位置上。
- en: We tailor the elements of presentation style with our audiences in mind. How
    does the audience affect how we lay out code? Surprisingly, we care least of all
    about the compiler. Its job is to ignore all that unnecessary whitespace and get
    down to the serious business of interpreting our syntax. Presentation is not about
    syntactic meaning, and the compiler can cope with whatever freakish layout we
    throw at it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据我们的受众调整演示风格元素。受众如何影响我们布局代码？令人惊讶的是，我们最不关心的是编译器。它的任务是忽略所有不必要的空白，并专注于解释我们的语法。演示不是关于语法意义的，编译器可以处理我们抛给它的任何古怪布局。
- en: Rather, we use layout to emphasize the *logical structure* of the code to human
    readers. It's about communication, and the clearer the better.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用布局来强调代码对人类读者的*逻辑结构*。这是关于沟通的，越清晰越好。
- en: '**KEY CONCEPT**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Understand the real audience for your source code: other programmers. Write
    for their benefit*.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解你的源代码的真实受众：其他程序员。为他们写作*。'
- en: What Is Good Presentation?
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是好的演示？
- en: As you can see, good presentation means more than just being neat. Tidy code
    certainly gives an impression of high quality, but code can be both tidy *and*
    misleading. We strive for *clear* layout; the code structure must be *enhanced*
    by an indentation strategy, not hidden by it. If a particular flow of control
    is necessarily complex, the layout should be helping you to read the code. (If
    you've written a flow of control that is unnecessarily complex, you should change
    it immediately.)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，好的演示不仅仅是整洁。整洁的代码确实给人留下高质量的印象，但代码可以是既整洁又具有误导性的。我们追求的是*清晰的布局*；代码结构必须通过缩进策略来*增强*，而不是被其隐藏。如果某个控制流程必然是复杂的，布局应该帮助你阅读代码。（如果你编写了一个不必要的复杂控制流程，你应该立即更改它。）
- en: Our code layout must convey meaning, rather than disguise it. I suggest the
    following as good metrics for the quality of a presentation style.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码布局必须传达意义，而不是隐藏意义。我建议以下作为衡量演示风格质量的好指标。
- en: '**Consistent**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致**'
- en: The indentation strategy must be consistent across the project. Don't change
    styles halfway through a source file. Not only does this look unprofessional,
    it can confuse and give the impression that your source files are not really related.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进策略必须在整个项目中保持一致。不要在源文件中间改变风格。这不仅看起来不专业，还可能造成混淆，给人留下你的源文件实际上并不相关的印象。
- en: The individual presentation rules should be internally consistent. The positioning
    of braces, brackets, and so on in different situations should all follow a single
    convention. The number of spaces of indent should always be the same.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 单个演示规则应该是内部一致的。在大括号、括号等不同情况下的位置都应该遵循单一约定。缩进空格的数量始终相同。
- en: 'Kernighan and Ritchie—the fathers of C—say, after stressing the importance
    of having good indentation: "The position of braces is less important, although
    people hold passionate beliefs. We have chosen one of several popular styles.
    Pick a style that suits you, then use it consistently." (Kernighan Ritchie 88)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**Conventional**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: It's sensible to adopt one of the major styles currently in use in the industry
    rather than invent your own indentation rules. You can be sure of it being accessible
    to others who are reading your code. And you're less likely to make people vomit.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**Concise**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Can you concisely describe your indentation strategy? Think about it. If you
    do *this* unless *such-and-such*, in which caseyou do *this* if *X* holds; otherwise
    you do something else which depends on . . .
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Someone may eventually need to extend the code you've written and should do
    so in the same style. If it's not easy to pick up, then is it really a useful
    presentation style?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Brace Yourself
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the impact presentation has on source code and the trade-offs
    involved in choosing a particular style, this case study investigates an important
    C-related layout issue. By looking at the variation in this one simple area, we'll
    see how important presentation is and what a profound impact it has on your code.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '*Brace positioning* is a big concern for the curly bracket languages, although
    it''s really only a fraction of the total code layout problem. As the most immediately
    visible artifact, it generates about 80 percent of the fuss. Other languages have
    their own similar layout concerns.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of conventional brace positioning styles. Which you pick
    comes down to your sense of aesthetics, the culture you code in, and what you're
    used to. Different styles are appropriate in different contexts—consider a magazine
    article versus a source editor (see "[WELL PRESENTED](ch02s04.html#well_presented
    "WELL PRESENTED")" on page 28). You may prefer the exdented style, but in a magazine
    you're forced to use K&R to maximize use of the printed page.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: K&R Brace Style
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*K&R* style is the oldest flavor, established by the fathers of C Kernighan
    and Ritchie in their book *The C Programming Language*. (Kernighan Ritchie 88)
    For this reason, it is often considered the *original and best*. It was driven
    by the need to display the most information possible on a small screen. It''s
    probably the dominant style for Java code.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Pros**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Takes up little room, so you can get more code on screen at once
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing brace lines up with the statement it matches, so you can scan up
    to find the construct being terminated
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The braces don't line up, so it's hard to visually match them
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might not notice if an opening brace goes off the right of the page
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code statements appear very densely packed
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exdented Brace Style
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more spacious approach is the so-called *exdented* (or sometimes *Allman*)
    style. This is my personal favorite.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Pros**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: A clear and uncluttered format
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to scan code for opening braces since they're distinct; this makes each
    code block more obvious
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于开括号是独特的，因此更容易扫描代码；这使得每个代码块更加明显
- en: '**Cons**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: Takes up more vertical space
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 占用更多的垂直空间
- en: Looks wasteful when you have lots of blocks containing only one statement
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有包含仅有一个语句的大量块时看起来很浪费
- en: Too much like Pascal for some hackers
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些黑客来说，太像Pascal了
- en: '**WELL PRESENTED**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的展示**'
- en: 'How you present code depends on the context in which it will be read. There
    are more contexts than you might think. When you''re reading some code, it''s
    important to appreciate the forces that drove its presentation. The common code
    habitats are:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何展示代码取决于它将被阅读的上下文。比你想的上下文要多。当你阅读一些代码时，重要的是要欣赏推动其展示的力量。常见的代码栖息地包括：
- en: '**Source editor**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**源编辑器**'
- en: This is most code's natural habitat. It raises all the presentation concerns
    programmers automatically think about. The code is read on a computer screen,
    usually in some dedicated editor or IDE. You scroll or navigate through a file
    to places of particular interest. It's an interactive world—more often than not,
    you're reading code to *make modifications*. This means that the code has to be
    malleable.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是代码的自然栖息地。它引发了程序员自动思考的所有展示问题。代码通常在计算机屏幕上阅读，通常是在某个专门的编辑器或IDE中。你通过滚动或导航到文件中特定感兴趣的地方。这是一个交互式世界——大多数情况下，你阅读代码是为了*进行修改*。这意味着代码必须具有可塑性。
- en: The editor may have horizontal scrollbars for long lines or may limit the page
    width and wrap them. Usually there's syntax coloring to aid comprehension. As
    you type, the editor performs some formatting work for you. For example, it intelligently
    positions the cursor on new lines.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器可能有水平滚动条以处理长行，或者可能限制页面宽度并将它们换行。通常有语法着色来帮助理解。当你输入时，编辑器会为你执行一些格式化工作。例如，它智能地将光标定位在新行上。
- en: '**Published code**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**已发布代码**'
- en: 'Unless you live in a lonely, isolated little world, you''ll regularly read
    published code. There are plenty of forums: listings in books and magazines, snippets
    fromlibrary documentation, or even lines in postings to newsgroups. These are
    formatted forclarity, but also favor a more compact representation since space
    is not cheap. Lines arecompressed vertically to get the most code into a short
    space, and they are compressed horizontally to fit into narrow print margins.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你生活在一个孤独、孤立的小世界里，否则你将定期阅读已发布的代码。有大量的论坛：书籍和杂志中的列表、库文档中的片段，甚至新闻组中的帖子。这些格式是为了清晰，但也倾向于更紧凑的表示，因为空间并不便宜。行被垂直压缩以在短空间内放入最多的代码，并且它们被水平压缩以适应狭窄的打印边距。
- en: This sort of code tends to omit error handling and anything not pertinent to
    the main idea of the example. It only serves to convey a point, not to be thorough.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这类代码往往省略错误处理以及与示例主要思想无关的任何内容。它只用于传达一个观点，而不是详尽无遗。
- en: You may never have to write code for this medium, but you'll certainly see plenty
    of it (you're reading code snippets in this *book*, at least). You need to understand
    the trade-offs and differences from normal code, so you don't unwittingly pick
    up any bad habits.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不需要为这种媒体编写代码，但你肯定会看到很多（至少你在这本书中阅读代码片段）。你需要了解权衡和与正常代码的差异，这样你就不会无意中养成任何坏习惯。
- en: '**Printouts**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**打印输出**'
- en: When you print out project code you run into new issues. Column widths become
    a problem. Should you reformat before you print, scale pages down and cope with
    small fonts, or have haphazard line wrapping? There's no syntax coloring to enhance
    presentation (unless you're rich enough for a color printer and all that ink),
    so messy commenting or code disabled by large comment blocks suddenlybecomes less
    obvious.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印项目代码时，会遇到新的问题。列宽成为问题。你应该在打印前重新格式化，缩小页面并处理小字体，还是随意换行？没有语法着色来增强展示（除非你足够富有，可以拥有彩色打印机以及所有墨水），因此混乱的注释或被大注释块禁用的代码突然变得不那么明显。
- en: Although you may never print out a page of source, these are valid concerns
    that you should consider.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能永远不会打印出源代码的一页，但这些是你应该考虑的有效问题。
- en: Indented Brace Style
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进括号风格
- en: Less common but still used is the *indented* style. Here the braces are indented
    with the code. It's also known as the *Whitesmith* style, since example code for
    the early Whitesmith's C compiler used it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 较不常见但仍然使用的是*缩进*风格。在这里，括号与代码缩进。它也被称为*Whitesmith*风格，因为早期Whitesmith C编译器的示例代码使用了它。
- en: '[PRE7]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Pro**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**'
- en: Links code blocks to the braces that contain them
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码块链接到包含它们的括号
- en: '**Con**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: Many people don't like their blocks linked to their braces
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人不喜欢他们的模块与他们的支架相连接
- en: Other Brace Styles
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他支架样式
- en: 'There are others. For example, the *GNU* style is sandwiched between exdented
    and indented; braces are placed halfway between each level of indent. There are
    also hybrids; the Linux kernel coding style is half K&R, half exdented. Most C#
    programmers also combine layout styles. If you''re really perverse, you''ll like
    this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的。例如，*GNU*风格介于缩进和展开之间；括号放置在每个缩进级别之间的一半。还有混合风格；Linux内核编码风格是K&R的一半，展开的一半。大多数C#程序员也结合布局风格。如果你真的很古怪，你会喜欢这个：
- en: '[PRE8]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I've seen plenty of surreal code like it, and I'm sure you could concoct something
    of equally nightmarish proportions if you tried.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到了很多类似的超现实代码，我确信如果你尝试，你也能创造出同样噩梦般的规模。
- en: '**KEY CONCEPT**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Recognize the common code layout styles for your chosen language, and become
    familiar working with each of them. Appreciate their advantages and disadvantages*.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*识别你选择的语言的常见代码布局风格，并熟悉与每个风格一起工作。欣赏它们的优缺点*。'
- en: One Style to Rule Them All
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种风格统治一切
- en: Having seen seen what constitutes a good coding style, what it governs, and
    why it's necessary, you must now actually choose one. This is where the fights
    begin. Disciples of one presentation religion clash with the evangelists of the
    next, leading to programmer civil war. But the craftsman steps back from these
    petty squabbles and takes a more balanced view.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到构成良好编码风格的因素、它所管辖的内容以及为什么它是必要的之后，你现在必须实际上选择一个。这就是战斗开始的地方。一个展示宗教的追随者与下一个布道者的冲突，导致程序员内战。但工匠从这些琐事中退后一步，采取更平衡的观点。
- en: As long as you write in a style that's good, it doesn't matter what style that
    is. And there's no point in arguing about it. There is more than one good style;
    the quality and applicability of each will depend on context and culture.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你的写作风格是好的，那就不重要是什么风格。而且争论它也没有意义。有不止一种好的风格；每种风格的质量和适用性将取决于上下文和文化。
- en: '**KEY CONCEPT**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Pick a single* good *coding style, and stick to it*.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择一种单一的*良好*编码风格，并坚持下去*。'
- en: It could be argued that if your language standard defined the One True Presentation
    Style, the world would be a better place. After all, all code would look the same.
    The arguments would cease, and we'd all move on to something more useful instead.
    You could pick up anyone's code and get to grips with it immediately. Sounds pretty
    good, doesn't it?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，如果你的语言标准定义了唯一的正确展示风格，世界将会变得更好。毕竟，所有的代码看起来都会一样。争论将停止，我们都会转向更有用的事情。你可以拿起任何人的代码，立即掌握它。听起来很不错，不是吗？
- en: 'The counterargument is *competition is a Good Thing*. If we had a single monopoly
    coding style, who would be able to say that it was the best one? By having more
    than one coding style, we are encouraged to think and improve the way we apply
    a style. It encourages style guidelines to improve. The upshot: It makes us write
    better code.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 反论是**竞争是一件好事**。如果我们有一个单一的垄断编码风格，谁又能说它是最好的呢？通过有多种编码风格，我们被鼓励去思考和改进我们应用风格的方式。这鼓励风格指南的改进。结果是：它让我们写出更好的代码。
- en: That argument is *not* a license to code in your own particular style, though.
    Remember that good presentation is *conventional*—a layout that readers expect.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种论点并不是允许你按照自己的特定风格编码的许可证。记住，好的展示是**传统**的——一个读者预期的布局。
- en: '**COMMON CODING STANDARDS**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见编码标准**'
- en: A number of well-known coding standards are generally used.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的编码标准通常被使用。
- en: '**Indian Hill**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**Indian Hill**'
- en: The full title of this famous document is Indian *Hill Recommended C Styleand
    Coding Standards*. It has nothing to do with Native Americans standing on mounds
    of earth; instead, it came from the renowned Indian Hill AT&T Bell lab.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这份著名文件的完整标题是“Indian *Hill 推荐的C风格和编码标准*”。它与美洲原住民站在土堆上无关；相反，它来自著名的Indian Hill
    AT&T Bell实验室。
- en: '**GNU**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU**'
- en: '*The GNU''s Coding Standards* are important since they influence most of the
    commonly used open source or free software out there. You can find them on the
    GNU Project''s website ([www.gnu.org](http://www.gnu.org)).'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU编码标准*非常重要，因为它们影响了大多数常用的开源或免费软件。你可以在GNU项目的网站上找到它们（[www.gnu.org](http://www.gnu.org)）。'
- en: '**MISRA**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**MISRA**'
- en: The UK's *Motor Industry Software Reliability Association (MISRA)* has defined
    a well-known set of standards for writing safety critical embedded software in
    C. It consists of 127 guidelines, and a number of tools exist to validate your
    code against them. These guidelines are focused more on language use than code
    layout.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 英国*汽车工业软件可靠性协会（MISRA）*为用C语言编写安全关键嵌入式软件定义了一套知名的标准。它包括127条指南，并且存在一些工具可以用来验证你的代码是否符合这些指南。这些指南更多地关注语言使用而不是代码布局。
- en: '**Project foo**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目foo**'
- en: Most every project under the sun defines its own pet coding style. Just go on
    a hunt, and you'll find literally thousands. The Linux kernel, for example, has
    its own guidelines, as does the Mozilla project.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上几乎每个项目都有自己的专属编码风格。只需进行一番搜索，你就能找到成千上万种。例如，Linux内核有自己的指导方针，Mozilla项目也是如此。
- en: House Styles (and Where to Stick Them)
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 房屋风格（以及它们的应用）
- en: Many software companies have an internal (*house* ) coding stylethat defines,
    among other things, its code presentation rules. But why bother—code that's been
    written in any good style is easy to read and maintain. If no one will have ahard
    time following it, do we really need this extra level of bureaucracy?
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件公司都有一个内部（*房屋*）编码风格，它定义了代码的展示规则等。但为什么要麻烦——任何用良好风格编写的代码都易于阅读和维护。如果没有人会感到难以遵循，我们真的需要这个额外的官僚层级吗？
- en: 'House styles *are* important and useful for a number of reasons. If everyone
    sings from the same hymn book (perhaps that should be *writes* on the same hymn
    book), then all source code will be consistent and homogenized. What value does
    this bring? It increases the code quality and makes software development safer.
    Here''s how:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 房屋风格*确实*重要且有用，原因有很多。如果每个人都唱同一首赞美诗（或许应该是*在同一个赞美诗上写*），那么所有源代码都将保持一致和统一。这有什么价值？它提高了代码质量，并使软件开发更安全。以下是方法：
- en: Any code released outside the organization will be neatly presented and coherent,
    appearing to be well thought out. Having many conflicting styles in one project
    looks careless and unprofessional.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何在组织外部发布的代码都将整洁有序，看起来经过深思熟虑。一个项目中存在许多相互冲突的风格看起来既粗心又不够专业。
- en: The company can be assured that programs are written up to a certain standard,
    thanks to common idioms and methodologies. This doesn't guarantee good code, but
    it does help to protect against bad code.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于有共同的习语和方法论，公司可以确信程序是按照一定标准编写的。这并不能保证代码质量良好，但它确实有助于防止编写出糟糕的代码。
- en: It makes up for poor tools; IDEs set in different ways will fight against each
    other, pulling code apart and generally molesting the layout. A standard provides
    level ground (and a common enemy for all the programmers).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它弥补了工具的不足；不同方式设置的IDE之间会相互斗争，拆分代码，并通常破坏布局。一个标准提供了一个公平的起点（以及所有程序员共同的敌人）。
- en: The appeal of being able to instantly recognize the shape of your peers' code
    and to quickly make appropriate maintenance alterations is clear. It saves reading
    time and therefore the company's money.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够立即识别你同事代码的形状并快速进行适当的维护更改的吸引力是显而易见的。这节省了阅读时间，因此也节省了公司的钱。
- en: Since the programmers won't be continually reformatting the code to suit their
    particular aesthetic fetishes, your version control history is very useful. If
    Fred reformats Bert's code to "his" style, what happens when, a bit later on,
    you look at a diff? Many diff tools are pretty crude and will now display a plethora
    of trivial whitespace and brace differences.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于程序员不会不断地重新格式化代码以适应他们个人的审美偏好，你的版本控制历史非常有用。如果弗雷德将伯特的代码格式化为“他的”风格，那么当你稍后查看差异时会发生什么？许多差异工具相当原始，现在会显示大量琐碎的空白和括号差异。
- en: These house coding standards are a Good Thing. Even if you don't actually agree
    with the rules they mandate—if, for example, your indentation strategy is much
    prettier and easier to understand (in your opinion)—it shouldn't matter one iota.
    The benefits of everyone sharing the same style outweigh the burden on you to
    have to conform. If you don't agree with the standard, you should still work to
    it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些房屋编码标准是好事。即使你并不完全同意它们规定的规则——例如，如果你的缩进策略在你看来更漂亮、更容易理解——那也无关紧要。大家共享相同风格的好处超过了你需要遵守的负担。如果你不同意标准，你仍然应该按照它来工作。
- en: '**KEY CONCEPT**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*If your team already has a coding standard, then use it. Don''t use your own
    pet style*.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的团队已经有了编码标准，那么就使用它。不要使用你自己的个人风格*。'
- en: You may be surprised to find how much of your coding style is bred from familiarity
    and practice. If you use a house style for a while, it soon becomes second nature
    and seems perfectly normal.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，你的编码风格中有多少是从熟悉和实践中培养出来的。如果你使用公司风格一段时间，它很快就会变得习以为常，看起来非常正常。
- en: What happens if you're working on code that originated from outside the company
    and doesn't conform to your house style? In this case, it makes more sense to
    write code conforming to the *existing* style of that source file. (This is why
    writing to a style that's easy to pick up is important.) The only other real alternative
    is to convert the file (and any others) into your house style. For most Real World
    projects, this latter course of action isn't feasible, especially if you are continually
    being fed with external source code updates.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理来自公司外部的代码，并且不符合你的公司风格，会发生什么？在这种情况下，编写符合该源文件现有风格的代码更有意义。（这就是为什么写一个易于遵循的风格很重要。）唯一的其他实际选择是将文件（以及任何其他文件）转换为你的公司风格。对于大多数现实世界的项目来说，这种做法并不可行，尤其是如果你不断地收到外部源代码更新。
- en: Conform to the style of a given file or project, conform to your house style
    where this doesn't conflict, and sacrifice your own preferences. Don't surrender
    your style blindly, though; understand the benefits weighed against the costs.
    And what if your company doesn't have a house style? Push for one. . . .
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守给定文件或项目的风格，在不冲突的情况下遵守你的公司风格，并牺牲你的个人偏好。不过，不要盲目地放弃你的风格；理解权衡利弊。如果你的公司没有公司风格，那就争取一个……。
- en: '![House Styles (and Where to Stick Them)](tagoreillycom20080909nostarchimages207444.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![房屋风格（以及它们应该放在哪里）](tagoreillycom20080909nostarchimages207444.png)'
- en: Setting the Standard
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定标准
- en: You've been tasked to draw up a code presentation style where there currently
    is none. Good luck! You can be sure that everyone will have an opinion on what
    the style should contain and that no one will be completely satisfied with the
    end result. Techies are helpful like that.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你被分配了一个任务，即制定一个目前尚无的代码展示风格。祝你好运！你可以确信，每个人都会对应该包含哪些内容有自己的看法，并且没有人会对最终结果完全满意。技术人员就是这样有帮助。
- en: Creating a coding standard is a delicate task, and it should be approached tactfully
    but firmly. Why? Dumping edicts upon a group of programmers will neither make
    you nor your standard popular. But if you don't emphasize how important it is,
    programmers will not embrace it and will continue coding in their own peculiar
    ways.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 制定编码标准是一项微妙的工作，应该谨慎而坚定地处理。为什么？向一群程序员发布命令既不会使你或你的标准受欢迎。但如果你不强调它的重要性，程序员就不会接受它，并会继续以他们独特的方式编码。
- en: 'The difficulty of this task depends on the people in the team:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这项任务的难度取决于团队中的人：
- en: How many programmers there are
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少程序员
- en: How they code as individuals
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们作为个人是如何编码的
- en: How similar their coding styles are already
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的编码风格有多相似
- en: Whether they actually *want* a standard or not
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们是否真的*想要*一个标准
- en: Whether they are prepared to change their styles at all
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们是否愿意改变自己的风格
- en: 'If their coding styles are all reasonably similar, then the job''s a breeze.
    If they vary wildly, you''re in for a bumpy ride. While people seldom agree on
    the best style, they will generally agree that some styles are better than others.
    You must aim to provide a sufficiently detailed set of layout directives while
    trying to satisfy as many programmers as possible—*and* produce something that
    will help them to work better as a team. Here''s a collection of pragmatic advice
    for this herculean task:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们的编码风格已经相当相似，那么这项工作就会变得轻松。如果它们差异很大，你将面临一段颠簸的旅程。虽然人们很少就最佳风格达成一致，但他们通常会同意某些风格比其他风格更好。你必须旨在提供一套足够详细的布局指令，同时尽可能满足尽可能多的程序员——*并且*产生一些有助于他们作为团队更好地工作的东西。以下是针对这项艰巨任务的一些建议：
- en: '**What''s it for?**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**这究竟是为了什么？**'
- en: Start off with a clear idea of the scope of the work—is the coding standard
    just for your immediate team, the department, or the whole company? This makes
    a big difference in how you'll develop and implement it.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要有一个明确的工作范围——编码标准是仅针对你的直接团队、部门还是整个公司？这将在你开发和实施它时产生重大差异。
- en: 'Remember: What makes a good personal style is not necessarily the best for
    a whole team of programmers. You are creating something that shouldn''t just serve
    *your* aesthetic fetishes; it should be a standard that will unite team code and
    avoid common problems. Keep this goal in mind as your develop the standard.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：一个好的个人风格不一定适合整个程序员的团队。你正在创造的东西不应该只是满足你个人的审美偏好；它应该是一个能够统一团队代码并避免常见问题的标准。在制定标准的过程中，要牢记这个目标。
- en: 'Determine the level of detail you intend to go into. Is this just a code layout
    document, or will it also touch on language usage concerns? It''s best to keep
    it simple: Write one document for presentation and a different document for language
    use.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 确定你打算达到的详细程度。这是否只是一个代码布局文档，还是也会涉及语言使用问题？最好是保持简单：写一个用于展示的文档和一个用于语言使用的不同文档。
- en: '**Get buy-in**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**获得支持**'
- en: Involve everyone on the team, so *they* own it. If the programmers feel like
    they contributed, they'll be more likely to follow the standard.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让团队中的每个人都参与进来，这样他们才会拥有它。如果程序员觉得自己做出了贡献，他们更有可能遵循标准。
- en: Get everyone to agree that a standard is needed *before* you start working on
    it. Make sure the team understands the benefits of code consistency and the perils
    of ad-hoc code presentation.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始工作之前，让每个人都同意需要一个标准。确保团队理解代码一致性的好处和临时代码展示的危险。
- en: If you have more than a few programmers, *don't* try to design the standard
    by committee. Well, not unless you hide all the sharp objects in the office first.
    Select a small crack team to get the work done.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有多于几个程序员，不要试图通过委员会来设计标准。好吧，除非你首先把办公室里所有的锐器都藏起来。选择一个小团队来完成这项工作。
- en: When the standard nears completion, review it with a panel of adopters. Make
    sure that you have a chairman who can make a final decision though, or everything
    will stall while 15 programmers sidetrack themselves in religious disputes.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当标准接近完成时，与采用者小组进行审查。确保你有一个能够做出最终决定的主席，否则，一切都会因为15个程序员的宗教争论而停滞不前。
- en: '**Produce something**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**产出成果**'
- en: The end product should be an accessible document, not just a fuzzy set of agreed
    conventions. You should be able to refer to the document later, and point newcomers
    at it. The document contains a list of the rules, perhaps with justification for
    the more contentious decisions.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最终产品应该是一个易于访问的文档，而不仅仅是一套模糊的共识惯例。你应该能够以后参考这个文档，并将新来者引向它。文档包含了一组规则，也许还有对更具争议性决策的说明。
- en: '**Standardize best practice**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准化最佳实践**'
- en: Make sure the standard embodies the team's current best practices—let them know
    that they're doing things right. If there's nothing that comes out of the blue,
    they will be more likely to adopt it. However, if you include random conventions
    from outside the team's experience, they'll revolt.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 确保标准体现了团队当前的最佳实践——让他们知道他们正在做正确的事情。如果没有突然出现的东西，他们更有可能接受它。然而，如果你包括团队经验之外的随机惯例，他们可能会反抗。
- en: '**Focus on what matters**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注重点**'
- en: Concentrate your efforts on the things that really matter and will make the
    biggest improvements to your team's code. Don't try to create a presentation standard
    for C, C++, *and* Java if you only ever use C.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的精力集中在真正重要的事情上，这将使你的团队代码得到最大的改进。如果你只使用C语言，就不要试图为C、C++和Java制定一个展示标准。
- en: '**Avoid hotspots**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免热点**'
- en: Leave rare-but-tedious cases to individual taste if they won't actually make
    much difference. If people get really worked up over the layout of split lines
    in an `if` statement, give up and let them do what they want.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些罕见但繁琐的情况实际上不会带来太多差异，就留给个人品味。如果人们真的对`if`语句中拆分行的布局感到过分激动，那就放弃，让他们做他们想做的事情。
- en: Don't be too restrictive; allow the rules to be broken if a violation can genuinely
    be justified.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于限制；如果违规行为有正当理由，允许规则被违反。
- en: '**Do it in pieces**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**分步骤进行**'
- en: A sensible approach is to develop your house style *a bit at a time*. Start
    by agreeing on brace layout and indent size. Just that. It will be difficult enough!
    Once you have that in place, progress will be *much* easier; any change is just
    more of the same. At some point, it won't be worth adding new rules, since the
    code will be sufficiently regular.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明智的方法是逐步发展你的风格。首先就花括号布局和缩进大小达成一致。仅此而已。这已经足够困难了！一旦你有了这个基础，进步将会容易得多；任何变化都只是更多相同的事情。在某个时候，添加新规则可能不再值得，因为代码已经足够规范。
- en: '**Plan for adoption**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**制定采用计划**'
- en: Have a clear idea how this coding standard will be adopted. Be realistic. People
    have to be happier *with* it, or they won't use it. Adoption will have to be based
    on some form of majority rule; if Fred still thinks that `switch` statements look
    better his way when everyone else managed to compromise, *too bad, Fred*. Don't
    be tempted to make it a democratic process, though. That just won't work.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 明确了解如何采用这个编码标准。要现实。人们必须对它感到满意，否则他们不会使用它。采用必须基于某种形式的多数规则；如果弗雷德仍然认为当其他人都能妥协时，他的`switch`语句看起来更好，那么就“太糟糕了，弗雷德”。不过，不要被诱惑让它成为一个民主过程，那根本行不通。
- en: Don't threaten people with the standard or induce punishments for not using
    it. That's not going to go down well. Instead, offer incentives—even if it's just
    public kudos in a code review.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用标准威胁人们，也不要因为不使用它而诱导惩罚。那不会受欢迎。相反，提供激励——即使只是代码审查中的公开赞誉。
- en: Ultimately, the take-up of a standard depends on the authority with which it
    is introduced. Either the programmers themselves authorize it or the process gets
    management to back it. Or it's a big waste of time.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，标准的采用取决于其引入的权威性。要么程序员自己授权它，要么过程得到管理层的支持。否则，就是浪费时间。
- en: Does this sound like trying to persuade a load of school children to get along
    and play nicely? Funny, isn't it. . . . Still, you'll wade your way through a
    religious quagmire, emerging on the other side with a house style that will genuinely
    improve your team's code. Once the wounds heal, it will have been worth it.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是在试图说服一群小学生和睦相处、友好玩耍吗？有趣，不是吗……然而，你将跋涉过宗教的泥潭，在另一边出现，带着一种真正能改善你团队代码的房屋风格。一旦伤口愈合，这一切都将是值得的。
- en: Righteous Wars?
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正义之战？
- en: The quickest way of ending a war is to lose it.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 结束战争最快的方式就是输掉它。
- en: --George Orwell
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: --乔治·奥威尔
- en: Engaging in holy wars over code layout is unproductive and a waste of time;
    there are far more important things to focus our attention on. But beware—code
    layout is not the only hot potato in the programming community. You could extend
    this to cover editors, compilers, methodologies, the One True Language,^([[2](#ftn.CHP-2-FN-2)])
    and beyond.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码布局上进行圣战是不切实际且浪费时间的行为；有更多重要的事情需要我们关注。但要注意——代码布局并不是编程社区中唯一的烫手山芋。你可以将其扩展到包括编辑器、编译器、方法、唯一真正的语言，^([[2](#ftn.CHP-2-FN-2)])
    以及更多。
- en: These little commotions have been going on for years. They'll continue to go
    on. And no one will *ever* win. No one will ever manage to establish the *right*
    answer, because there is no right answer. These arguments are just an opportunity
    for one person to try to enforce his or her particular (carefully formed) opinion
    on others, and vice versa. After all, my opinion *must* be right, because it's
    *mine*. It's like trying to knit spaghetti—amusing for a while, but messy and
    totally pointless. It's usually only ever immature programmers that get involved.
    (The old-timers are already argued out.)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小骚动已经持续了多年。它们将继续进行。而且没有人会*永远*赢。没有人会设法确立*正确*的答案，因为没有正确答案。这些争论只是一个人试图将自己的特定（精心形成的）观点强加给他人，反之亦然的机会。毕竟，我的观点*必须是*正确的，因为它是*我的*。这就像尝试编织意大利面——一开始很有趣，但很混乱，完全没有意义。通常只有不成熟的程序员才会参与。（老手们已经争论过了。）
- en: 'The key point to learn is: Holy wars are a waste of effort. As a professional,
    you should step back from such petty arguments. Of course, have an educated personal
    opinion, but don''t arrogantly presume that it''s correct.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习的关键点是：圣战是徒劳的。作为一名专业人士，你应该从这样的小争执中退出来。当然，要有经过教育的个人观点，但不要傲慢地假设它是正确的。
- en: '**KEY CONCEPT**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Holy wars*: Just say no. *Don''t get involved. Walk away*.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '*圣战*：说不。*不要参与。走开*。'
- en: '* * *'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-2-FN-2)]) This brings to mind a C/C++ programming conference I attended
    some years ago. A speaker presented his discovery that you get fewer bugs (which
    are easier to fix) using Pascal rather than C, while the most difficult to fix
    and numerous bugs occur in C++. The reaction was wonderful—everyone's feathers
    were ruffled!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-2-FN-2)]) 这让我想起了几年前参加的一个C/C++编程会议。一位演讲者展示了他的一项发现，即使用Pascal而不是C，你可以得到更少的错误（更容易修复），而在C++中，最难以修复的错误和数量众多的错误发生。反应是热烈的——每个人的羽毛都竖起来了！
- en: In a Nutshell
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Nothing succeeds like the appearance of success.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比成功的表象更成功。
- en: --Christopher Lasch
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: --克里斯托弗·拉斯ch
- en: Presentation is one of the key features differentiating good code from bad code.
    Programmers glean a lot from code's appearance, so it *is* right to worry about
    layout. It's an important skill to be able to sensitively lay out code for maximum
    clarity, within the guidelines of any company coding standard that may exist.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 展示是区分好代码和坏代码的关键特征之一。程序员从代码的外观中汲取了很多东西，所以担心布局是正确的。在可能存在的任何公司编码标准指导下，能够敏感地布局代码以实现最大清晰度是一项重要的技能。
- en: '**LOOKING FOR A FIGHT**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找战斗**'
- en: 'Code layout is not the only excuse for a programmer flame war. There are many
    religious subjects that you''d best tactfully dodge for the sake of your blood
    pressure. Watch out for:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 代码布局不是程序员之间发生争执的唯一借口。有许多宗教主题，为了你的血压，你最好巧妙地避开。小心以下：
- en: '**My OS is better than yours**'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的操作系统比你的好**'
- en: . . . because it scales from a wristwatch to an alien mothership, only requires
    rebooting once every epoch, and performs most operations with a single two letter
    command.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 因为它可以从手表扩展到外星母船，每个时代只需要重启一次，并且大多数操作只需要一个两个字母的命令。
- en: But *mine's* better than yours because you'll never see a single piece of text
    using it, it's tastefully color coordinated, and it can be operated by a blind
    squirrel. Anything you can't do with it is illegal in most civilized countries,
    anyway.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 但**我的**比你的好，因为你永远不会看到任何一段使用它的文本，它色彩搭配得体，而且连瞎猴子都能操作。任何你不能用它做到的事情，在大多数文明国家都是非法的。
- en: '**My editor is better than yours**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的编辑器比你的好**'
- en: . . . because it recognizes more than a million different syntax schemes, can
    edit files written in hieroglyphics, and each of its 400 operations are accessible
    with fewer than 10 simultaneous keystrokes. You can use it on the desktop, from
    a command line, over a modem, through a rising main, and over 128-bit encrypted
    smoke signals.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 因为它能够识别超过一百万种不同的语法方案，可以编辑用象形文字写的文件，并且它的400个操作都可以用不到10个同时按键完成。你可以在桌面上使用它，从命令行，通过调制解调器，通过上升的主干道，以及通过128位加密的烟雾信号。
- en: But *mine's* better than yours because it integrates with my underwear and knows
    what I want to type before I've even thought of it myself.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 但**我的**比你的好，因为它可以与我的内衣集成，并且在我自己还没想出来之前就知道我想写什么。
- en: '**My language is better than yours**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的语言比你的好**'
- en: . . . because it implements the artificial intelligence of most major governmentsand
    is clever enough to interpret random gesticulations as meaningful sequences instructions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 因为它实现了大多数主要政府的人工智能，并且足够聪明，能够将随意的手势解释为有意义的指令序列。
- en: But *mine's* better than yours because it allows you to write in haiku and encodes
    information in combinations of whitespace characters.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 但**我的**比你的好，因为它允许你写俳句，并且用空白字符的组合来编码信息。
- en: It's reasonable to assume that code that has been carefully laid out will have
    been carefully designed. It's even more reasonable to assume that sloppily presented
    code hasn't been designed with much care. But there's more to this story than
    formatting source code.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由假设经过精心布局的代码已经被精心设计。更有理由假设展示粗糙的代码并没有得到很多关注。但这个故事不仅仅是关于格式化源代码。
- en: 'Besides presentation skills, there are certain *attitudes* that separate good
    programmers from bad programmers. The moral is simple: *Avoid creating hot air*.
    Computers will do that for you (we don''t need in-office heating because ours
    belch out so much heat). Know what you like and be *prepared* to defend it, to
    put your view across—but don''t presume that you have to win or that you have
    to be right, and don''t arrogantly do your own thing anyway.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示技巧之外，还有一些**态度**将好程序员和差程序员区分开来。道德很简单：**避免制造空洞的言论**。电脑会为你做这件事（我们不需要办公室供暖，因为我们的设备会散发出大量的热量）。了解你喜欢什么，并准备好为之辩护，以表达你的观点——但不要假设你必须赢，或者你必须是对的，而且无论如何都不要傲慢地做自己想做的事情。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员 . . . | 差程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Avoid pointless arguments and are sensitive to others' opinions
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免无意义的争论，并对他人的观点敏感
- en: Are humble enough to know that they're not right all the time
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够谦逊，知道他们并不总是对的
- en: Know how code layout impacts readability and strive for the clearest code possible
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解代码布局如何影响可读性，并努力追求尽可能清晰的代码
- en: Will adopt a house style even if it contradicts their personal preferences
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使与个人偏好相矛盾，也会采用房屋风格
- en: '|'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Are close-minded and opinionated—*My view isthe right one*
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭关自守且固执己见——**我的观点是正确的**
- en: Argue with anyone over the most trivial things; it's a chance to prove their
    superiority
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就最琐碎的事情与人争论；这是证明他们优越性的机会
- en: Have no consistent personal coding style
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有一致的个性化编码风格
- en: Trample over others' code in their own style
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在他人自己的风格中践踏他们的代码
- en: '|'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](ch03.html "第三章。名字的意义")'
- en: A coding standard may mandate how you create names.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范可能规定你如何创建名称。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](ch04.html "第四章。写作技巧")'
- en: Good presentation is key to writing code that's self-documenting.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的展示是编写自文档化代码的关键。
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.html "第五章。简短评论")'
- en: Describes how we write comments; some comment use relates to source code layout.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 描述我们如何编写注释；一些注释的使用与源代码布局相关。
- en: '![See Also](tagoreillycom20080909nostarchimages207448.png.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207448.png.jpg)'
- en: Get Thinking
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 466.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第466页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: Should you alter the layout of legacy code to conform to your latest code style?
    Is this a valuable use of code reformatting tools?
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该调整旧代码的布局以符合最新的代码风格？这是代码重格式化工具的有价值用途吗？
- en: A common layout convention is to split source lines at a set number of columns.
    What are the pros and cons of this? Is it useful?
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个常见的布局约定是在固定数量的列中拆分源行。这种做法的优点和缺点是什么？它有用吗？
- en: How detailed should a *reasonable* coding standard be?
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个合理的编码规范应该有多详细？
- en: How serious are deviations from the style? How many limbs should be amputated
    for not following it?
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对风格的偏离有多严重？为了不遵守它，应该截掉多少肢体？
- en: Can a standard become too detailed and restrictive? What would happen if it
    did?
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个标准可以过于详细和限制性吗？如果它这样做会发生什么？
- en: When defining a new presentation style, how many items or cases need layout
    rules? What other presentation rules must be provided? List them.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当定义一个新的展示风格时，需要多少项或案例来布局规则？还需要提供哪些其他展示规则？列出它们。
- en: Which is more important—good code *presentation* or good code *design*? Why?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个更重要——良好的代码**展示**还是良好的代码**设计**？为什么？
- en: Getting Personal
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: Do you write in a consistent style?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否以一致的风格写作？
- en: When you work with other people's code, which layout style do you adopt—theirs
    or your own?
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你与其他人的代码一起工作时，你采用哪种布局风格——他们的还是你自己的？
- en: How much of your coding style is dictated by your editor's auto-formatting?
    Is this an adequate reason for adopting a particular style?
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的编码风格有多少是由编辑器的自动格式化决定的？这是采用特定风格的一个充分理由吗？
- en: 'Tabs: Are they a work of the devil, or the best thing since sliced bread? Explain
    why.'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制表符：它们是魔鬼的作品，还是自切片面包以来最好的东西？解释原因。
- en: Do you know if your editor inserts tabs automatically? Do you know what your
    editor's tab stop is?
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道你的编辑器是否自动插入制表符吗？你知道你的编辑器的制表符停止位置吗？
- en: Some *hugely* popular editors indent with a mixture of tabs and spaces. Does
    this make the code any less maintainable?
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些**非常**受欢迎的编辑器使用制表符和空格的混合缩进。这会使代码的维护性降低吗？
- en: How many spaces should a tab correspond to?
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个制表符应该对应多少个空格？
- en: Do you have a preferred layout style?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有偏好的布局风格吗？
- en: Describe it in a series of simple statements. Be complete. Include, for example,
    how you format `switch` statements and split up long lines.
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一系列简单陈述来描述它。要完整。例如，说明你如何格式化`switch`语句和拆分长行。
- en: How many statements did it take? Is that what you expected?
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要多少个语句？这是你预期的吗？
- en: Does your company have a coding standard?
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的公司是否有编码规范？
- en: Do you know where it is? Is it advertised? Have you read it?
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道它在哪吗？它是如何宣传的？你读过它吗？
- en: 'If yes: Is it any good? Perform an honest critique, and feed your comments
    back to the document owners.'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是：它好吗？进行诚实的批评，并将你的评论反馈给文档所有者。
- en: 'If no: Should it? ( Justify your answer.) Is there a common unwritten code
    style that everyone adopts? Can you drive the adoption of a standard?'
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是：它应该吗？（证明你的答案。）是否存在一个普遍的未写成的代码风格，每个人都采用？你能推动标准的采用吗？
- en: Is there *more* than one standard used, perhaps one per project? If so, how
    is code shared among projects?
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有多个标准被使用，也许每个项目一个？如果是这样，项目之间是如何共享代码的？
- en: How many different layout styles have you followed?
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你遵循过多少种不同的布局风格？
- en: Which did you feel most comfortable with?
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你觉得哪个最舒服？
- en: Which was the most rigorously defined?
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个定义得最严格？
- en: Is there a link?
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有链接吗？
- en: Chapter 3. WHAT'S IN A NAME?
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。名字的意义
- en: '*Giving Meaningful Things Meaningful Names*'
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*赋予事物有意义的名称*'
- en: When I use a word, Humpty Dumpty said, in a rather scornful tone, it means just
    what I choose it to mean—neither more nor less.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用一个词时，Humpty Dumpty以一种相当轻蔑的语气说，它意味着我选择的意思——不多也不少。
- en: --Lewis Carroll
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: --刘易斯·卡罗尔
- en: Ancient civilizations knew that to name something was to have power over it.
    This was more than a simple claim to possession. Some believed so strongly in
    the power of names that they would never give their own names to strangers, for
    fear the strangers might use it to inflict harm against them.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 古代文明知道，给某物命名就是对其拥有权力。这不仅仅是对占有的一种简单主张。有些人对名字的力量深信不疑，以至于他们永远不会将自己的名字告诉陌生人，因为他们害怕陌生人可能会用它来对他们造成伤害。
- en: 'Names mean an awful lot. You may not live in fear of them, but don''t underestimate
    the power of a name. A name describes:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 名字意味着很多。你可能不会因为它们而生活在恐惧中，但不要低估名字的力量。一个名称描述了：
- en: '**Identity**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份**'
- en: Names are fundamental to our concept of identity. There are examples throughout
    history—even before 2000 Bc, there are Biblical examples of meaningful place names
    and children named to reflect circumstances. In most cultures it's still convention
    for a woman to change her last name when she gets married, although the fact that
    some women choose not to shows how they attribute significant meaning to their
    names.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 名字是我们对身份概念的基本组成部分。历史上有很多例子——甚至在公元前2000年之前，就有反映特定情况的具有意义的地名和被命名的孩子的圣经例子。在大多数文化中，女性在结婚时更改姓氏仍然是一种惯例，尽管一些女性选择不这样做的事实表明她们对自己的名字赋予了重要的意义。
- en: '**Behavior**'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**'
- en: 'A name not only promotes identity, but also implies behavior. Obviously, a
    name doesn''t dictate what an object does, but it will influence how you interact
    with it and how the outside world interprets it. We''re never fixed to one name
    per object. I''m known by different monikers in different contexts: the name my
    wife calls me,^([[1](#ftn.CHP-3-FN-1)]) the name my daughters know me by, the
    nickname I use in chat rooms, and so on. These names indicate different relationships
    and interactions with me and the roles I fulfil.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名称不仅促进身份，还暗示行为。显然，名称并不规定一个对象做什么，但它将影响你如何与之互动以及外界如何解释它。我们永远不会固定一个对象只有一个名称。在不同的环境中，我以不同的名字为人所知：我妻子叫我的名字，^([[1](#ftn.CHP-3-FN-1)])
    我女儿们知道我的名字，我在聊天室中使用的昵称，等等。这些名字表明了与我以及我扮演的角色不同的关系和互动。
- en: '**Recognition**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别**'
- en: 'A name marks something as a distinct entity. It elevates it from ethereal concept
    to well-defined reality. Before someone put a name to electricity, no one would
    have understood what it was, although they might have some vague idea of its effects
    by watching lightning or Benjamin Franklin''s demonstrations. Once named, it became
    identifiable as a distinct force and, consequently, easier to reason about. The
    Basque culture believes that naming something proves its existence: *Izena duen
    guzia omen da* —That which has a name exists. (Kurlansky 99)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名称将某个事物标记为一个独特的实体。它将其从虚幻的概念提升到明确的现实。在有人给电起名之前，没有人会理解它是什么，尽管他们可能通过观察闪电或本杰明·富兰克林的演示而对它的效果有一些模糊的认识。一旦命名，它就成为了可以识别的独立力量，因此更容易进行推理。巴斯克文化认为，给某物命名证明了它的存在：*Izena
    duen guzia omen da* ——有名字的东西是存在的。（库兰斯基 99）
- en: Today the act of naming has become a multimillion-dollar business, used (with
    varying degrees of success) by small firms, the largest multinational corporations,
    and everything in between. To launch, rebrand, and publicize products, these organizations
    need newer, ever more catchy names. These names help to build awareness of products
    and services.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，命名已经成为一个价值数百万美元的产业，被小型公司、最大的跨国公司以及介于两者之间的所有企业所使用（成功率各不相同）。为了推出、重新命名和宣传产品，这些组织需要更新、更吸引人的名称。这些名称有助于建立产品和服务意识。
- en: Clearly, names are of immense importance.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，名字具有极其重要的意义。
- en: 'As programmers, we wield this enormous power over our constructs when we name
    them. A badly named entity can be more than just inconvenient; it can be misleading
    and even downright dangerous. As a very simplistic example, consider the following
    C++ code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们在命名我们的构造时拥有这种巨大的权力。一个命名不当的实体不仅可能是不方便的；它可能是误导的，甚至可能是危险的。作为一个非常简单的例子，考虑以下C++代码：
- en: '[PRE9]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameter name is clearly a lie, or at least its sense is the opposite of
    what you'd expect. The function will not perform as anticipated and, as a consequence,
    your program will abort—a reasonably dire result from a single misnamed variable.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称显然是一个谎言，或者至少它的意义与你的预期相反。该函数将不会按预期执行，结果，你的程序将崩溃——一个由单个错误命名的变量引起的相当糟糕的结果。
- en: '*Sticks and stones may break my bones, but names will never hurt me*. Not true.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*棍子和石头可以打断我的骨头，但名字永远不会伤害我*。这不是真的。'
- en: Why Should We Name Well?
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们应该好好命名？
- en: We need to carefully consider the names we give things. Remember that writing
    source code is all about clear communication. A name creates a channel of understanding,
    control, and mastery. Appropriate naming means that *to know the name is to know
    the object*.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要仔细考虑我们赋予事物的名称。记住，编写源代码全部关于清晰的沟通。一个名称创建了一个理解、控制和掌握的渠道。适当的命名意味着*知道名称就是知道对象*。
- en: Good names really matter. The human brain can only hold about seven pieces of
    information concurrently^([[2](#ftn.CHP-3-FN-2)]) (although I'm sure I have a
    couple of defective slots, reducing this capacity). It's already hard enough to
    cram all the information about a program into your head; we should not add complexnaming
    schemes or require obscure references to make this task even harder.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 好的名称真的很重要。人脑一次只能同时处理大约七条信息（尽管我相信我有一些缺陷插槽，减少了这种容量）。将所有关于程序的信息塞进你的大脑已经很困难了；我们不应该添加复杂的命名方案或要求晦涩的引用，使这项任务更加困难。
- en: Clear naming is one of the hallmarks of well-crafted code. The ability to name
    things well is an important skill of the code craftsman—he'll work hard to write
    easy-to-read code.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的命名是精心制作的代码的一个显著特征。命名事物的能力是代码工匠的重要技能——他会努力编写易于阅读的代码。
- en: '**KEY CONCEPT**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Learn to name things* transparently—*an object''s name should describe it
    clearly*.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '*学会透明地命名事物*——*对象的名称应该清楚地描述它*。'
- en: '* * *'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-3-FN-1)]) Which depends on whether she's in a good or bad mood at
    the time!
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-3-FN-1)]) 这取决于她当时的心情是好是坏！
- en: ^([[2](#CHP-3-FN-2)]) This is known as the *Miller number*, after George A.
    Miller's psychological research. (Miller 56)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-3-FN-2)]) 这被称为*米勒数*，以乔治·A·米勒的心理研究命名。（Miller 56）
- en: What Do We Name?
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要命名什么？
- en: 'In this chapter we''ll spend some time thinking, as programmers, about what
    we name and how we name it. First: *What?* The things we name most often while
    writing code are:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将花一些时间思考，作为程序员，我们如何命名以及如何命名。首先：*什么？* 在编写代码时，我们最常命名的事物是：
- en: Variables
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Functions
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Types (classes, `enum`s, `struct`s, `typedef`s)
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型（类、`enum`s、`struct`s、`typedef`s）
- en: C++ namespaces and Java packages
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++命名空间和Java包
- en: Macros
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Source files
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件
- en: 'This list is by no means exhaustive—there are other, higher-level entities
    we''ll give meaningful names to: states of a state machine, parts of messaging
    protocols, database elements, application executables, and so on. But these six
    are enough to start with.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝对不是详尽的——我们还会为其他更高级别的实体赋予有意义的名称：状态机的状态、消息协议的部分、数据库元素、应用程序可执行文件等等。但这六个就足够开始了。
- en: Name Games
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名游戏
- en: '*How* do you name? The naming technique for each of these items will depend
    on any coding standard you''re working to. However, while a standard might mandate
    certain naming conventions, it won''t be specific enough to guide the *appropriate*
    naming of each and every part of a program.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何*命名？每个这些项目的命名技术将取决于你正在遵循的任何编码标准。然而，尽管标准可能要求某些命名约定，但它不会足够具体，以指导程序每个部分的*适当*命名。'
- en: In order to name well, it's essential to know exactly what you're naming before
    you think up a name for it. If you don't know what you're naming, how it will
    be used, and why it actually exists, how can you give it a meaningful name? Bad
    names are often a sign of poor understanding.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 为了命名得好，在你为它想出一个名称之前，确切地知道你要命名的内容是至关重要的。如果你不知道你要命名的内容、它的用途以及它为什么存在，你怎么能给它一个有意义的名称？坏名字往往是理解不足的迹象。
- en: '**KEY CONCEPT**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The key to good naming is to understand exactly what you''re naming. Only
    then can you give a meaningful name. If you can''t invent a good name for something,
    do you really know what it is, or even if it should exist at all?*'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '*良好的命名关键在于准确理解你要命名的内容。只有在这种情况下，你才能给出一个有意义的名称。如果你不能为某物想出一个好名字，你真的了解它吗，甚至它是否应该存在？*'
- en: Before we look in detail at the specific categories of names we create, it's
    important to understand the forces that drive our choice of names and exactly
    what constitutes a good name. The next few sections explain the qualities of a
    good name.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细探讨我们创建的具体名称类别之前，了解推动我们选择名称的驱动力以及什么构成一个好名称是很重要的。接下来的几节将解释一个好名称的特质。
- en: Descriptive
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述性
- en: Obviously a name must be descriptive. That's what you use it for—to describe
    something. Yet it's common to see puzzling identifiers that bear little resemblance
    to the data they describe.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个名称必须是描述性的。这就是你用它来描述某物的目的。然而，常见到一些令人困惑的标识符，它们与它们描述的数据几乎没有相似之处。
- en: Even an accurate name can be limiting. People often stick to their initial perceptions
    of a concept, despite the proverb about judging books by their covers. Therefore,
    it's important to convey the right first impression through careful naming. Choose
    names from the perspective of an inexperienced reader, not from your internal,
    knowledgeable perspective.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个准确的名字也可能有限制。人们常常坚持他们对一个概念的最初印象，尽管有关于不要以貌取人的谚语。因此，通过仔细的命名传达正确的第一印象是很重要的。从没有经验的读者的角度选择名称，而不是从你内部的知识角度。
- en: Sometimes finding a good description is difficult. If you can't come up with
    a good name, then you might need to change your design. It's an indication that
    something might be wrong.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 有时找到一个好的描述是困难的。如果你想不出一个好的名称，那么你可能需要改变你的设计。这是一个可能表明某些事情可能出错的迹象。
- en: Technically Correct
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术正确
- en: Modern programming languages impose some rules on how we name things. Most allow
    case-sensitive names, don't allow *whitespace* (spaces, tabs, newlines), and allow
    just alphanumeric characters plus certain symbols (like the underscore). These
    days, there are no appreciable limits on identifier length.^([[3](#ftn.CHP-3-FN-3)])
    Although many languages permit use of Unicode identifiers, it's still common to
    select from the ISO8859-1 (ASCII) character set for simplicity.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言对我们如何命名事物施加了一些规则。大多数允许大小写敏感的名称，不允许*空白字符*（空格、制表符、换行符），并且允许仅限字母数字字符加上某些符号（如下划线）。如今，标识符的长度没有明显的限制.^([[3](#ftn.CHP-3-FN-3)])
    尽管许多语言允许使用Unicode标识符，但出于简单起见，仍然常见的是从ISO8859-1（ASCII）字符集中选择。
- en: 'There may be other technical restrictions. The C/C++ standards reserve specific
    ranges of names: You should not use any global identifier beginning with `str`
    followed by a lowercase letter, or beginning with an underscore, and anything
    in a namespace called `std`. It''s important to be aware of these kinds of restrictions
    so we can write robust, correct code.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他技术限制。C/C++标准保留了特定的名称范围：你不应该使用任何以`str`开头后跟小写字母或以下划线开头的全局标识符，或者在任何名为`std`的命名空间中的任何内容。了解这些类型的限制很重要，这样我们才能编写健壮、正确的代码。
- en: Idiomatic
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 习语性
- en: 'Just because a language permits certain combinations of characters doesn''t
    meant they''re automatically good names. Clear names follow conventions that the
    reader expects: the language''s *idioms*. Just as fluency in a natural language
    depends on understanding its idioms, fluency in a programming language requires
    idiomatic usage.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为一种语言允许某些字符组合并不意味着它们自动就是好的名称。清晰的名字遵循读者期望的约定：语言的*习语*。就像在自然语言中流利地使用取决于理解其习语一样，在编程语言中使用习语性用法也需要流利。
- en: Some languages have a single, common naming convention—the vast Java library
    establishes a prior art that is hard to ignore—while C and C++ have a lesser degree
    of convergence. There are several cultures, each with their own foibles; the standard
    libraries use one convention, Windows Win32 APIs another.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言有单一的、常见的命名约定——庞大的Java库建立了一种难以忽视的先例——而C和C++的收敛程度较低。有几个文化，每个文化都有自己的特点；标准库使用一种约定，Windows
    Win32 API使用另一种。
- en: '**KEY CONCEPT**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Know your language''s naming rules. But more importantly, know the language''s
    idiomsw. What are the common naming conventions? Use them*.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解你语言的命名规则。但更重要的是，了解你语言的习语。常见的命名约定有哪些？使用它们*。'
- en: Appropriate
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当
- en: 'An *appropriate* name strikes a good balance in several areas:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*适当*的名称在几个方面都取得了良好的平衡：
- en: '**Length**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**长度**'
- en: To create clear, descriptive names, we must use natural language words. Programmers
    have a built-in urge to abbreviate and shorten these words, but this leads to
    confused, messy names. It doesn't matter that a name is long if its meaning is
    unambiguous. `a` is not a realistic replacement for `apple_count`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建清晰、描述性的名字，我们必须使用自然语言单词。程序员有内置的缩写和缩短这些单词的冲动，但这会导致混乱、杂乱无章的名字。如果名字的含义不明确，那么名字的长短无关紧要。`a`
    不能作为 `apple_count` 的现实替代。
- en: '**KEY CONCEPT**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When naming, favor clarity over brevity*.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名时，优先考虑清晰度而非简洁性**。'
- en: 'However, there is a case for short (even one letter) variable names: as loop
    counters. They actually make sense in *small* loops where variable names like
    `loop_counter` are not just overly verbose but can quickly become tedious.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，短变量名（甚至是一个字母）有其合理性：作为循环计数器。在**小**循环中，变量名如`loop_counter`不仅过于冗长，而且很快就会变得令人厌烦。
- en: '**KEY CONCEPT**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Understand the trade-offs between short and long names—how they depend on
    the scope of the variable''s use*.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解短名和长名之间的权衡——它们如何取决于变量的使用范围**。'
- en: '**Tone**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**语气**'
- en: The tone of a name *is* important. Just as a rude joke isn't appropriate at
    a funeral, an ill-judged name ruins the professionalism of your code. Is this
    serious? Yes—silly names make the reader doubt the ability of the original author.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**名字的**语气**很重要。就像粗鲁的笑话不适合葬礼一样，不恰当的名字会破坏你代码的专业性。这是认真的吗？是的——愚蠢的名字会让读者怀疑原作者的能力。'
- en: Avoid jokey names like *blah* or *wibble*, or the bigger geek snares *foo* and
    *bar*. They can easily creep in, and while amusing at first, they just create
    confusion later on. (Objects given these names are usually quick temporary hacks
    that outlast their expected lifetime.) And, obviously, being professional means
    that you don't use expletives when naming.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用像**blah**或**wibble**这样的玩笑名字，或者更大的技术陷阱**foo**和**bar**。它们很容易悄悄进入，虽然一开始可能很有趣，但后来只会造成混淆。（这些名字的对象通常是快速临时修补，寿命超过了预期。）显然，专业意味着在命名时不要使用咒骂。
- en: '**FOOD FOR THOUGHT**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**思考**'
- en: 'So what''s with all this *foo* and *bar* business? These words are a bit of
    geek humor, utterly meaningless and yet full of purpose. They are usually used
    as placeholders to represent arbitrary things. You might write: *for some variable*
    *`foo`*, *increment it by* *`++foo`*;.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有这些**foo**和**bar**是怎么回事呢？这些词是一种技术幽默，毫无意义，却又充满目的。它们通常用作占位符来表示任意事物。你可能这样写：**对于某个变量**
    **`foo`**，**增加它的值** **`++foo`**；。
- en: The words generally come in a series. There are several variant series, but
    you'll see *foo*, *bar*, and baz *`quite`* universally. What comes next may be
    up to the fickle finger of fate or to whatever geek folklore you prefer.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这些词通常成系列出现。有几个变体系列，但你将看到 *foo*、*bar* 和 baz **`相当**普遍。接下来是什么可能取决于命运的无常或你偏爱的任何技术传说。
- en: The etymology of these terms is debatable. Some trace them back to the World
    War II army slang FUBAR (Mucked Up Beyond All Repair). Needless to say, you should
    never use these names in production code.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这些词的词源有争议。有些人将其追溯到二战时期的军队俚语 FUBAR（Mucked Up Beyond All Repair）。不用说，你永远不应该在生产代码中使用这些名字。
- en: '**KEY CONCEPT**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Name things well the first time, all the time*.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终第一次就给事物起一个好名字**。'
- en: '* * *'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: ^([[3](#CHP-3-FN-3)]) Be aware that older versions of C limited external unique
    linkage to the first six characters, and case was not *necessarily* significant.
    You need to understand exactly what the target of your code is when you write
    it.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-3-FN-3)]) 请注意，C语言的老版本将外部唯一链接限制在前六个字符，并且大小写**不一定**重要。当你编写代码时，你需要确切地了解你的代码目标是什么。
- en: The Nuts and Bolts
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**坚果和螺栓**'
- en: The following sections investigate how to name each category of item we listed
    earlier. Even if you've been programming for years, this is a useful review of
    the broad spectrum of naming conventions.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将探讨如何命名我们之前列出的每一类项目。即使你已经编程多年，这也是对命名约定广泛范围的 useful 回顾。
- en: Naming Variables
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名变量
- en: If a variable wasn't just an electronic entity, it would be the sort of thing
    you could hold in your hand, the software equivalent of a physical object. A name
    that reflects this will usually be a noun. For example, variable names in a GUI
    application might be `ok_button` and `main_window`. Even variables that don't
    correspond to Real World objects can be given noun names; consider `elapsed_time`
    or `exchange_rate`.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量不是一个电子实体，它将是你可以用手拿的东西，是物理对象的软件等价物。反映这种特性的名称通常将是名词。例如，GUI应用程序中的变量名可能是`ok_button`和`main_window`。即使不对应现实世界对象的变量也可以给予名词名称；考虑`elapsed_time`或`exchange_rate`。
- en: If not a noun, a variable will usually be a "noun-ized" verb, for example, `count`.
    A numeric variable's name describes the interpretation of the value, as in `widget_length`.
    A boolean variable name is often the name of a conditional statement, which is
    natural, considering the value will either be true or false.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量不是一个名词，它通常会被“名词化”成动词，例如，`count`。数值变量的名称描述了值的解释，如`widget_length`。布尔变量的名称通常是条件语句的名称，这是自然的，因为值将是真或假。
- en: There are a number of object-oriented language conventions for adorning member
    variables to show they are members, not ordinary local variables or (evil) global
    variables. This is a mild form of *Hungarian Notation*, which some programmers
    find useful.^([[1](#ftn.CHP-3-FN-4)]) For example, C++ members are commonly prefixed
    with an underscore, suffixed with an underscore, or prefixed with `m_`. The first
    method is frowned upon because it is somewhat risky and distasteful.^([[5](#ftn.CHP-3-FN-5)])
    Besides, a leading or trailing underscore makes the variable pretty unnatural
    to read.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 对于装饰成员变量以表明它们是成员而不是普通局部变量或（邪恶的）全局变量，面向对象的语言有许多约定。这是一种温和的匈牙利命名法，一些程序员认为它很有用.^([[1](#ftn.CHP-3-FN-4)])
    例如，C++成员通常以下划线开头，以下划线结尾，或以`m_`开头。第一种方法不太受欢迎，因为它有一定的风险，并且令人不快.^([[5](#ftn.CHP-3-FN-5)])
    此外，前导或尾随的下划线使得变量看起来不太自然。
- en: Some programmers adorn pointer types with a suffix like `_ptr` and reference
    types with one like `_ref`. This is another subtle infiltration of Hungarian Notation,
    and it is redundant. The fact the variable is a pointer is implicit in its type.
    If your function is so large that you think this adornment is useful, then it's
    probably too large!
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员会在指针类型后加上像`_ptr`这样的后缀，在引用类型后加上像`_ref`这样的后缀。这是匈牙利命名法的另一种微妙渗透，而且它是多余的。变量是指针的事实隐含在其类型中。如果你的函数如此之大，以至于你认为这种装饰是有用的，那么它可能太大了！
- en: 'Another common variable-naming practice is using acronyms as concise, "meaningful"
    names. For example, you might declare a variable like this: `SomeTypeWithMeaningfulNaming
    stwmn(10);`. If the scope of use is small, this kind of name may be clearer than
    a long-winded variant.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的变量命名实践是使用缩写作为简洁、有意义的名称。例如，你可能这样声明一个变量：`SomeTypeWithMeaningfulNaming stwmn(10);`。如果使用的范围较小，这种名称可能比冗长的变体更清晰。
- en: 'Conventions that distinguish type names from variable names are generally best.
    Type names often have an uppercase initial letter, while variables have a lowercase
    one. This way, it''s not unusual to see variables declared like this: `Window
    window;`.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 区分类型名和变量名的约定通常是最好的。类型名通常以大写字母开头，而变量名则以小写字母开头。这样，看到变量声明如下：`Window window;`并不罕见。
- en: '**KEY CONCEPT**'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Employ a helpful naming convention that differentiates variable names from
    type names*.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '*采用有助于区分变量名和类型名的命名约定*。'
- en: '**HUNGARIAN NOTATION**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**匈牙利命名法**'
- en: Hungarian Notation is a controversial naming convention that encodes information
    about a variable or function's type in its name with the belief that it will make
    the code more readable and maintainable. It originated at Microsoft in the 1980s
    and is widely used in the company's public Win32 APIs and the MFC library, which
    is the main reason for its popularity.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法是一种有争议的命名约定，它通过在名称中编码有关变量或函数类型的信息，相信这将使代码更易于阅读和维护。它起源于20世纪80年代的微软，在公司的公共Win32
    API和MFC库中得到广泛应用，这也是它受欢迎的主要原因。
- en: 'It is called Hungarian Notation because it was pioneered by Charles Simonyi,
    a Hungarian programmer. It''s also called that because variable names look like
    they may as well have been written in Hungarian: Non-Windows programmers get confused
    by surreal names like `lpszFile`, `rdParam`, and `hwndItem`.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为匈牙利命名法，因为它是匈牙利程序员查尔斯·西莫尼（Charles Simonyi）首创的。它也被称为这样，因为变量名看起来就像是用匈牙利语写的：非Windows程序员会被像`lpszFile`、`rdParam`和`hwndItem`这样的超现实名称搞糊涂。
- en: There are many subtly different and not-quite-compatible dialects of Hungarian
    Notation, which don't help matters.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多细微不同且不完全兼容的匈牙利符号方言，这并没有帮助解决问题。
- en: Naming Functions
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名函数
- en: If a variable is like something you could hold in your hand, the *function*
    is what you do with it—you don't want to hold it forever. Since a function is
    an action, its name will most logically be (or will at least include) a verb.
    A function with a noun for a name wouldn't be clear; for example, what does the
    function `apples()` do? Does it return a number of apples, does it convert something
    into apples, or does it make apples out of thin air?
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量像你可以用手拿的东西，那么 *函数* 就是你要做的——你不想永远拿着它。由于函数是一个动作，它的名字将最合理地是（或者至少包括）一个动词。以名词为名的函数不会很清晰；例如，`apples()`
    这个函数做什么？它是返回苹果的数量，还是将某物转换为苹果，或者是从无到有地制造苹果？
- en: Meaningful function names avoid the words *be*, *do*, and *perform*. These are
    classic traps for beginners trying to consciously include verbs (*this function*
    does *XXX* . . .). They are just noise and don't add any value to the name.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义的函数名应避免使用单词 *be*、*do* 和 *perform*。这些是初学者试图有意识地包含动词（*这个函数*做*XXX* ...）的经典陷阱。它们只是噪音，不会给名字增加任何价值。
- en: A function should always be named from the viewpoint of the user, hiding all
    the internal implementation stuff neatly away. (That's the point of a function—it's
    a level of compression and abstraction.) Who cares if, behind the scenes, it stores
    an element in a list, makes calls over a network, or builds a new computer and
    installs a word processor on it? If the user only sees the function count apples,
    the function should be called `countApples()`.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该始终从用户的角度命名，将所有内部实现细节整洁地隐藏起来。（这就是函数的目的——它是一种压缩和抽象的层次。）幕后它是否在列表中存储元素，是否通过网络进行调用，或者构建一台新计算机并在其上安装文字处理器？如果用户只看到函数
    count apples，那么这个函数应该被命名为 `countApples()`。
- en: '**KEY CONCEPT**'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Name functions from an external viewpoint, with a doing phrase. Describe the
    logical operation, not the implementation*.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '*从外部视角命名函数，使用动作短语。描述逻辑操作，而不是实现*。'
- en: The only time you might choose to break this rule is for simple query functions
    that request information. For these accessors, you can sensibly name the function
    after the data being requested. For an example of this, see the answer to question
    9 in this chapter's "[Mull It Over](ch02s11.html#mull_it_over-id1 "Mull It Over")"
    section on page 478.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能唯一选择打破这条规则的时间是对于简单的查询函数，这些函数请求信息。对于这些访问器，你可以合理地根据请求的数据来命名函数。例如，参见本章第 9 个问题的答案
    "[Mull It Over](ch02s11.html#mull_it_over-id1 "Mull It Over")" 部分，在第 478 页。
- en: When you write a function, it should be well documented (either in a specification
    or using some literate programming method). However, the name should still be
    a clear statement of what the function does; it is part of the function's contract.
    What does `void a()` do? It could be anything.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个函数时，它应该有良好的文档（无论是规范还是使用某种文献编程方法）。然而，函数名仍然应该是函数所做事情的清晰陈述；它是函数契约的一部分。`void
    a()` 这个函数做什么？它可以是任何事情。
- en: '**CAPITALIZATION CONVENTIONS**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小写约定**'
- en: 'Most languages prohibit us from using whitespace and punctuation in our identifiers,
    so we adopt a convention for joining up multiple words. These capitalization conventionscause
    as many programmer fist fights as the eternal Holy Editor Wars. There are a number
    of common methods that you''ll see in modern code:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言禁止我们在标识符中使用空格和标点符号，因此我们采用一种将多个单词连接起来的约定。这些大小写约定引发了与永恒的圣洁编辑战一样多的程序员争吵。在现代代码中，你会看到一些常见的做法：
- en: '**camelCase**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**camelCase**'
- en: camelCase is used extensively by the Java language libraries and also in many
    C++ codebases. It is so called because the capitalization resembles a camel's
    humps and was probably first used in Smalltalk in the early 1970s.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: camelCase 在 Java 语言库中广泛使用，也在许多 C++ 代码库中使用。之所以称为 camelCase，是因为其首字母大写类似于骆驼的驼峰，可能最早在
    20 世纪 70 年代初的 Smalltalk 中使用。
- en: '**ProperCase**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProperCase**'
- en: This is a close relative of camelCase, its only difference being that the first
    letter is also capitalized. It is sometimes known as *PascalCase*. Often the two
    conventions are used together. For example, Java class names are written in ProperCase
    and members in camelCase. The Windows API and .NET methods use ProperCase.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 camelCase 非常相似，唯一的区别是第一个字母也大写。有时也称为 *PascalCase*。通常这两种约定会一起使用。例如，Java 类名使用
    ProperCase，成员使用 camelCase。Windows API 和 .NET 方法使用 ProperCase。
- en: '**using_underscores**'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用下划线**'
- en: Proponents of this style are the implementers of the C++ standard library(look
    at all the names in the `std` namespace) and the GNU foundation.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格的倡导者是C++标准库的实现者（看看`std`命名空间中的所有名称）和GNU基金会。
- en: There are also many other forms. How many can you think of? You can start by
    mixing ProperCase with underscores, or by dropping uppercase characters entirely.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他形式。你能想到多少种？你可以从将正确的大小写与下划线混合开始，或者完全省略大写字母。
- en: Naming Types
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名类型
- en: Which types you can create depends on the language you're using. C provides
    `typedef`s, which are synonyms for other type names. You use them to provide easier,
    more convenient names. It stands to reason, then, that a `typedef` should be clearly
    named. Even if it's only a local `typedef` in a function body, it should still
    have a descriptive name.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建哪些类型取决于你使用的语言。C语言提供了`typedef`，它是其他类型名称的同义词。你使用它们来提供更简单、更方便的名称。因此，一个`typedef`应该有一个清晰的名称。即使它只是一个函数体内的局部`typedef`，也应该有一个描述性的名称。
- en: Java, C++, and other OO languages are profoundly based on the creation of new
    types (*classes*). C also allows you to define compound types called `structs`.
    Just as good variable and function names are vital to the readability of the code,
    good type names are paramount. There aren't too many rigid heuristics for naming
    classes, though, because different classes serve different purposes.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Java、C++和其他面向对象的语言深刻地基于新类型的创建（*类*）。C语言也允许你定义复合类型，称为`struct`。就像好的变量和函数名对代码的可读性至关重要一样，好的类型名也是至关重要的。然而，对于命名类并没有太多严格的启发式规则，因为不同的类服务于不同的目的。
- en: A class may describe some stateful data object. In that case, its name will
    probably be a noun.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可能描述了一些有状态的数据对象。在这种情况下，它的名称可能是一个名词。
- en: It may be a function object (a *functor*) or a class implementing some virtual
    callback interface. Here the name will probably be a verb, perhaps including the
    name of a recognized design pattern. (Gamma et al. 94)
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它可能是一个函数对象（一个*函数式对象*）或实现某些虚拟回调接口的类。在这里，名称可能是一个动词，可能包括一个公认的设计模式的名称。（Gamma等人94）
- en: If the class is a combination of both, then it's probably hard to name and possibly
    designed badly.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类是两者的组合，那么它可能很难命名，并且可能设计得不好。
- en: '*Interface classes* (e.g., abstract C++ classes with pure virtual functions
    or `interface`s in Java and .NET) tend to be named according to the interface
    facility. Names like `Printable` and `Serializable` are common. .NET adds a Hungarian
    wart, prefixing all interface names with `I`, resulting in names like `IPrintable`.'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*接口类*（例如，具有纯虚拟函数的抽象C++类或Java和.NET中的`interface`）通常根据接口功能命名。像`Printable`和`Serializable`这样的名称很常见。.NET添加了一个匈牙利标记，将所有接口名称前缀为`I`，结果产生像`IPrintable`这样的名称。'
- en: 'Earlier, we discussed words to avoid in function names; there is similar quicksand
    here. For example, `DataObject` is a bad name: The class may very well contain
    data, and it''s obviously going to be used to create an object—this doesn''t need
    to be restated.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了在函数名中要避免的词汇；这里也有类似的陷阱。例如，`DataObject`是一个糟糕的名称：这个类可能确实包含数据，并且显然将被用来创建对象——这不需要重申。
- en: '**KEY CONCEPT**'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Avoid redundant words in names. Specifically, avoid these words in type names*:
    class, data, object, *and* type.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免在名称中使用冗余的词汇。特别是，在类型名称中避免以下词汇*：class、data、object以及*type*。'
- en: Ensure that you describe the *class of data* and not an *actual object*. That's
    a subtle, but important distinction.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你描述的是*数据类别*而不是*实际对象*。这是一个微妙但重要的区别。
- en: '**A CLASS OF BAD NAMES**'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**不良命名类别**'
- en: A bad class name can serve to really confuse programmers. I once worked on an
    application that contained a state machine implementation. For some historical
    reason, the base class of each state was called `Window`, rather than something
    sensible like `State`. It was very confusing and threw off several programmers
    when they first saw it. To add insult to injury, the base class of a command pattern
    was called `Strategy`, when it wasn't actually implementing a strategy design
    pattern. It was never easy to figure out what was going on. Better naming would
    have provided a clear route into the code's logic.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一个糟糕的类名可能会真正让程序员感到困惑。我曾经参与过一个包含状态机实现的程序。由于某些历史原因，每个状态的基础类被命名为`Window`，而不是像`State`这样的合理名称。这非常令人困惑，并且当一些程序员第一次看到它时，会让他们感到困惑。更糟糕的是，命令模式的基础类被命名为`Strategy`，但实际上并没有实现策略设计模式。要弄清楚发生了什么从来都不容易。更好的命名会为代码的逻辑提供一个清晰的路径。
- en: Naming Namespaces
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名命名空间
- en: What name do you give something specifically designed to collate names? C++
    and C# `namespace`s and Java `package`s are like bags, acting primarily as grouping
    mechanisms.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 你会给专门用于整理名称的东西起什么名字？C++和C#的`namespace`和Java的`package`就像袋子，主要起分组机制的作用。
- en: They are also used to prevent *name collisions*. When two programmers create
    different things with the same name and their code gets glued together, whatwill
    happen is anyone's guess. At best, the code will fail to link; at worst, all sorts
    of run-time carnage will ensue. Putting items into different namespaces avoids
    the danger of polluting the global namespace. This makes them valuable naming
    tools.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还用于防止*名称冲突*。当两个程序员用相同的名称创建不同的事物，并且他们的代码被粘合在一起时，会发生什么任何人都可以猜测。最好的情况是代码无法链接；最坏的情况是会发生各种运行时破坏。将项目放入不同的命名空间可以避免污染全局命名空间的风险。这使得它们成为有价值的命名工具。
- en: But namespaces on their own do not prevent collisions; your `utils` namespace
    could still clash with someone else's `utils`. To remedy this, we employ a *naming
    scheme*. Java defines a hierarchy of package names, nested like Internet domain
    names—you'll place code in your own uniquely named package. This neatly avoids
    the problem of collisions. Without such a convention, namespaces reduce, but do
    not eliminate, the likelihood of problems.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅凭命名空间本身并不能防止冲突；你的`utils`命名空间仍然可能与别人的`utils`冲突。为了解决这个问题，我们采用了一种*命名方案*。Java定义了一个包名称的层次结构，就像互联网域名一样嵌套——你将代码放入你自己的唯一命名的包中。这巧妙地避免了冲突的问题。如果没有这样的约定，命名空间可以减少问题发生的可能性，但并不能消除。
- en: When picking a name for your namespace, choose something that describes the
    relationship of the contents. If they are all part of a library's interface, make
    it the library name. If the contents are a single section of a larger system,
    choose a name that describes this section; `UI`, `filesystem`, or `controls` are
    good names. Don't choose a name that redundantly implies a collection of items—`controls_group`
    is a bad name.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 当为命名空间选择名称时，选择一个描述内容关系的名称。如果它们都是库接口的一部分，那么就使用库的名称。如果内容是更大系统的一个单独部分，那么选择一个描述这个部分的名称；`UI`、`filesystem`或`controls`都是好的名称。不要选择一个冗余地暗示一组项目的名称——`controls_group`是一个不好的名称。
- en: '**KEY CONCEPT**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Give namespaces and packages names that reflect the logical relationships
    of their contents*.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*为命名空间和包命名时，应反映其内容的逻辑关系*。'
- en: Naming Macros
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名宏
- en: Macros are the walnut-cracking sledgehammers of the C/C++ world. They are search-and-replace
    tools for basic text that don't respect scope or visibility. They're tactless.
    However, there are some walnuts that just won't crack without them.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是C/C++世界的核桃敲击大锤。它们是用于基本文本的搜索和替换工具，不尊重作用域或可见性。它们很无礼。然而，有些核桃没有它们是无法敲开的。
- en: 'Macros have very drastic effects, so there is a well-established tradition
    for naming macros in a maximally obvious way: using CAPITAL LETTERS. Follow this
    without fail, and don''t make any other name entirely capitalized. This makes
    macros stand out like sore thumbs, which is basically what they are.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 宏具有非常显著的影响，因此有一个非常成熟的传统，即以最明显的方式命名宏：使用大写字母。务必遵循这一点，不要将任何其他名称完全大写。这使得宏像突出的拇指一样显眼，这正是它们的目的。
- en: Since they are simple text replacement tools, give macros names that are unique
    enough to not appear elsewhere in the code. Otherwise, carnage and confusion will
    ensue.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是简单的文本替换工具，因此给宏命名时，要足够独特，以免在代码的其他地方出现。否则，将会发生混乱和破坏。
- en: A unique file or project name prefix will help here. The macro name `PROJECTFOO_MY_MACRO`
    is much safer than `MY_MACRO`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独特的文件或项目名称前缀在这里会有所帮助。宏名称`PROJECTFOO_MY_MACRO`比`MY_MACRO`更安全。
- en: '**KEY CONCEPT**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Macros in C/C++ are always capitalized to make them stand out and carefully
    named to avoid collisions. Don''t capitalize anything else. Ever*.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '*C/C++中的宏总是大写以使其突出，并且命名仔细以避免冲突。永远不要大写其他任何内容*。'
- en: Naming Files
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名文件
- en: The names of your source files can have a real impact on the ease of coding.
    Some languages have strict filename requirements—Java source filenames must correspond
    to the contained public class name. On the other hand, C and C++ are lax, with
    no restrictions at all.^([[6](#ftn.CHP-3-FN-6)])
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 你的源文件名称可以对编码的容易程度产生真正的影响。一些语言有严格的文件名要求——Java源文件名必须与包含的公共类名称相对应。另一方面，C和C++则比较宽松，没有任何限制。[^6](#ftn.CHP-3-FN-6)
- en: To make choosing filenames easy and obvious, each file should contain a single
    conceptual unit. Putting more stuff into one file is asking for trouble in the
    long run. Split your code into the maximum number of files you can; not only will
    it make them easier to name, but it will reduce coupling and make the project's
    structure clearer.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使选择文件名变得简单明了，每个文件应包含一个单一的概念单元。将更多内容放入一个文件中，从长远来看可能会带来麻烦。将你的代码拆分成尽可能多的文件；这不仅会使它们更容易命名，而且会减少耦合，使项目的结构更加清晰。
- en: A C/C++ file that defines the interface for a *widget* should becalled `widget.h`,
    not `widget_interface.h`, `widget_decls.h`, or any other variation. You should
    conventionally balance each `widget.h` with a matching `widget.cpp` or `widget.c`
    (see "[ALL THAT ENDS WELL](ch03s05.html#all_that_ends_well "ALL THAT ENDS WELL")"
    on page 50) that implements whatever the `widget.h` declares. The shared base
    name ties them together logically. This is both obvious and conventional.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*小部件*接口的C/C++文件应该命名为`widget.h`，而不是`widget_interface.h`、`widget_decls.h`或任何其他变体。你应该按照惯例，为每个`widget.h`配对一个匹配的`widget.cpp`或`widget.c`（参见第50页的"[ALL
    THAT ENDS WELL](ch03s05.html#all_that_ends_well "ALL THAT ENDS WELL")"），该文件实现`widget.h`声明的任何内容。共享的基本名称将它们在逻辑上联系起来。这是既明显又符合惯例的。
- en: 'There are many other subtle, but important issues when naming files:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名文件时，还有很多其他微妙但重要的问题：
- en: Be aware of capitalization. Some filesystems can't get this right and ignore
    case when looking up filenames. But when porting to platforms where case *is*
    important, your code won't compile unless you've observed capitalization carefully.
    Perhaps the easiest way to avoid being tripped up is to mandate that all filenamesbe
    lowercase; as they say, *If you can't be good, be careful*. (Of course, that won't
    work for Java, which uses the PascalCase naming style for its classes and interfaces.)
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意大小写。一些文件系统无法正确处理大小写，在查找文件名时忽略大小写。但是，当移植到大小写*确实*重要的平台时，除非你仔细观察了大小写，否则你的代码将无法编译。也许避免被绊倒的最简单方法就是强制所有文件名都使用小写；正如他们所说，*如果你不能做得好，那就小心点*。（当然，这不会适用于Java，Java为其类和接口使用PascalCase命名风格。）
- en: For the same reason, if your filesystem considers the filenames `foo.h` and
    `Foo.h` to be different, *don't* exploit it. Make sure that filenames in the same
    directory differ by more than just case.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于同样的原因，如果你的文件系统认为`foo.h`和`Foo.h`是不同的文件名，*不要*利用这一点。确保同一目录下的文件名在大小写之外还有所不同。
- en: If you mix languages in a single project, don't create `foo.c`, `foo.cpp`, and
    `foo.java` in the same directory. It's messy—which file is used to create the
    object file `foo.o`, and which creates the executable called `foo`?
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个项目中混合使用多种语言，不要在同一个目录中创建`foo.c`、`foo.cpp`和`foo.java`。这会变得很混乱——哪个文件用于创建名为`foo.o`的目标文件，哪个用于创建名为`foo`的可执行文件？
- en: Try to ensure that all the files you create have a distinct names, even if they're
    all spread across different directories. This makes it easier to reason about
    which file is which. It's obvious which header file you mean when you `#include
    "foo.h"`. If there were two files with the same name, then a newcomer to the codebase
    would be confused. This becomes more of an issue as a system grows.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量确保你创建的所有文件都有独特的名称，即使它们分布在不同的目录中。这样做可以更容易地推断出哪个文件是哪个。当你`#include "foo.h"`时，很明显你指的是哪个头文件。如果有两个文件具有相同的名称，那么对于代码库的新手来说可能会感到困惑。随着系统的增长，这个问题会变得更加严重。
- en: One valid approach is to add some path information to the logical filename.
    Arrange your files so that you can include `library_one/version.h` and `library_two/version.h`
    without confusion.
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种有效的方法是在逻辑文件名中添加一些路径信息。安排你的文件，以便你可以不混淆地包含`library_one/version.h`和`library_two/version.h`。
- en: File naming seriously impacts ease of coding. I once worked on a C++ project
    where the majority of the filenames matched the class names exactly; the class
    `Daffodil` was defined in `Daffodil.h` (names have been changed to protect the
    guilty). However, a handful of files were named in a *slightly* different manner,
    usually abbreviated, so `HerbaciousBorder` was held in `HerbBdr.h`. That made
    finding the right filename to `#include` complex and time consuming. On top of
    this, not all of the `Daffodil` class implementation was necessarily in `Daffodil.cpp`—some
    of it might have been in a shared `FlowerStuff.cpp` and perhaps also in `Yogurt.cpp`,
    for no adequately explained reason. As you can imagine, this made finding particular
    bits of code a nightmare. Source code browsers help in situations like this, but
    they are no substitute for plain old, well-named code.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 文件命名对编码的便捷性有严重影响。我曾经在一个C++项目中工作，其中大多数文件名与类名完全匹配；类`Daffodil`在`Daffodil.h`中定义（为了保护无辜者，已更改名称）。然而，一些文件以*略微*不同的方式命名，通常是缩写，所以`HerbaciousBorder`被放在`HerbBdr.h`中。这使得找到正确的文件名来`#include`变得复杂且耗时。更不用说，`Daffodil`类的所有实现并不一定都在`Daffodil.cpp`中——其中一些可能在一个共享的`FlowerStuff.cpp`中，也许还在`Yogurt.cpp`中，没有任何合理的解释。正如你可以想象的那样，这使得找到特定的代码片段变得像噩梦一样。源代码浏览器在这种情况下有所帮助，但它们不能替代清晰、命名良好的代码。
- en: '* * *'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-3-FN-4)]) Of course, this kind of naming convention won't have any
    impact on a class's public API because all of your member variables are private,
    aren't they?
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-3-FN-4)]) 当然，这种命名约定对类的公共API没有任何影响，因为你的所有成员变量都是私有的，对吧？
- en: ^([[5](#CHP-3-FN-5)]) You can't have global identifiers beginning with an underscore
    followed by a capital letter. The archaic C naming rules make many such odd demands.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-3-FN-5)]) 你不能以下划线开头，后面跟着大写字母的全局标识符。古老的C命名规则提出了许多这样的奇怪要求。
- en: ^([[6](#CHP-3-FN-6)]) Except those imposed by your operating system or filesystem.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-3-FN-6)]) 除了操作系统或文件系统强加的之外。
- en: A Rose by Any Other Name
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个玫瑰，无论叫什么名字
- en: There is more to the name game than you'd first think, and there are clearly
    a lot of considerations for naming bits of code. What are the main principles
    to pull out?
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 命名游戏比你想象的要复杂得多，命名代码片段有很多考虑因素。主要的命名原则有哪些？
- en: 'To invent a good name, do the following:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 要发明一个好的名称，请遵循以下步骤：
- en: Be consistent
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持一致性
- en: Exploit content
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用内容
- en: Use names to your advantage
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用名称的优势
- en: '**ALL THAT ENDS WELL**'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '**皆大欢喜**'
- en: Choosing a suffix is integral to file naming. Java's build system insists that
    source filenames end in `.java`. C and C++ compilers are suffix agnostic, but
    calling header files something.h is such a universal convention that it would
    be like sticking pins in your eyes not to do it. We do feel some pain from the
    lack of rigid definition; there are several conventions for C++ implementation
    filenames, like the common suffixes `.C`, `.cc`, `.cpp`, `.cxx`, and `.c`++. Less
    common, but still seen, are C++ headers files suffixed with `.hpp`. Your choice
    may depend on the compiler, personal preference, and/or a coding standard. Consistency
    is the key; pick a file suffix scheme and use it consistently.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后缀对于文件命名至关重要。Java的构建系统坚持要求源文件以`.java`结尾。C和C++编译器对后缀不敏感，但将头文件命名为`.h`是一种普遍的约定，不这样做就像是在你的眼睛上扎针。我们确实对缺乏严格定义感到一些痛苦；C++实现文件名有几种约定，如常见的后缀`.C`、`.cc`、`.cpp`、`.cxx`和`.c`++.
    较不常见，但仍然存在，是C++头文件后缀为`.hpp`。你的选择可能取决于编译器、个人偏好和/或编码标准。一致性是关键；选择一个文件后缀方案并始终如一地使用它。
- en: I have even worked on a platform that didn't support filename suffixes. Determiningthe
    filetype was a complex and messy business.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至在一个不支持文件名后缀的平台工作过。确定文件类型是一项复杂且混乱的业务。
- en: Be Consistent
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持一致性
- en: 'This is perhaps the most important naming principle. Be *consistent*—not just
    within your own work, but with respect to company-wide practices. I have no confidence
    in the quality of a class interface if it looks like this:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最重要的命名原则。要*保持一致性*——不仅在你自己的工作中，而且在公司范围内的实践中。如果一个类的接口看起来像这样，我对其质量没有信心：
- en: '[PRE10]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When a lot of people work together, it's very easy to end up with code like
    this—about as internally consistent as a random number generator. It's often a
    symptom of a more serious problem—perhaps that the programmers aren't respecting
    the fundamental design of the code they're simultaneously working on. This is
    where mandated coding standards and central design documents can be a big help.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 当很多人一起工作时，很容易得到这样的代码——就像随机数生成器一样内部不一致。这通常是更严重问题的症状——可能是程序员没有尊重他们同时工作的代码的基本设计。这就是强制编码标准和中心设计文档可以大有帮助的地方。
- en: Naming consistency goes beyond capitalization and formatting to the way you
    *create* names. A name establishes an implicit metaphor. Across a program or project,
    these metaphors should be consistent. Your naming approach should be holistic.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 命名一致性不仅限于大小写和格式，还在于你*创建*名字的方式。一个名字建立了一个隐含的隐喻。在整个程序或项目中，这些隐喻应该是统一的。你的命名方法应该是全面的。
- en: '**KEY CONCEPT**'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Choose a consistent naming convention—and use it consistently*.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择一个一致的命名约定，并且始终如一地使用它*。'
- en: With consistent naming, we get code that is intuitive and therefore easier to
    work with, easier to extend, and easier to maintain. In the long run, it's much
    cheaper to manage.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一致的命名，我们得到直观的代码，因此更容易工作，更容易扩展，也更容易维护。从长远来看，管理成本会大大降低。
- en: Exploit Context
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用上下文
- en: Every name should make perfect sense when read in context. A name will only
    ever be read in its context, so you can delete all the superfluous bits that duplicate
    contextual information. We strive for succinct, descriptive names, without unnecessary
    baggage.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名字在上下文中阅读时都应该完美合理。一个名字只会在其上下文中被阅读，所以你可以删除所有重复上下文信息的冗余部分。我们追求简洁、描述性的名字，没有不必要的负担。
- en: 'This contextual information may come from:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这种上下文信息可能来自：
- en: '**Scope**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域**'
- en: 'Things either live in a top-level, global scope or exist within some namespace,
    class, or function. Choose a name that makes sense in the context of that scope.
    The smaller and more specific a scope is, the easier it is to create a name within
    it and the easier it is for the reader to understand what that name really means.
    If a function counts the number of apples in a tree and is defined in a class
    `Tree`, then it needn''t be called `countApplesInTree()`. Its fully qualified
    name would be an unambiguous description: `Tree::countApples()`. Put things in
    the smallest (and therefore most descriptive) scope you can.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 事物要么存在于顶级、全局作用域中，要么存在于某个命名空间、类或函数中。选择一个在该作用域中合理的名字。作用域越小、越具体，在其中创建名字就越容易，读者理解这个名字真正含义也就越容易。如果一个函数在`Tree`类中计算树上的苹果数量，那么它不需要被命名为`countApplesInTree()`。它的完全限定名将是一个明确的描述：`Tree::countApples()`。将事物放在你能够的最小（因此是最具描述性）的作用域中。
- en: 'The French language, like most other Romance languages, has two forms of the
    word *you*: *tu* and *vous*. Which one you use depends on how familiar you are
    with the person you''re addressing. Similarly, the name you call a variable may
    depend on the context in which you''re using it. You may see a variable named
    differently in a function''s public declaration than in the function implementation.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 法语，像大多数其他罗曼语族的语言一样，有两种形式的“你”：*tu*和*vous*。你使用哪一个取决于你与你要称呼的人的熟悉程度。同样，你给变量取的名字可能取决于你使用它的上下文。你可能会在函数的公共声明中看到不同命名的变量，而在函数实现中则不同。
- en: '**Type**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: Everything has a type, and you'll know what that type is. A name doesn't need
    to restate this type information. (Restating this *is* the purpose of Hungarian
    Notation and is why it's an often derided convention.)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 每件事都有类型，你将知道那个类型是什么。一个名字不需要重申这个类型信息。（重申这一点正是匈牙利命名法的用途，也是为什么它经常受到诟病的原因。）
- en: An inexperienced programmer will name his address `string` variable `address_string`.
    What good does the `_string` suffixdo? Nothing, so get rid of it.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺乏经验的程序员可能会将他的地址`string`变量命名为`address_string`。这个`_string`后缀有什么好处？没有，所以去掉它吧。
- en: '**KEY CONCEPT**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The detail required in a name depends on its context. Use contextual information
    to your advantage when naming*.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个名字所需的细节取决于其上下文。在命名时利用上下文信息*。'
- en: Use Names to Your Advantage
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用名字的优势
- en: There is power in a name—power that allows you to be more expressive than a
    language's syntax alone might allow. Think about how you can use similar names
    to group things together, using a common prefix. Or consider how you can imply
    which of a function's parameters are input or output by including this information
    in their names.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 名字中蕴含着力量——这种力量让你能够比仅仅使用语言的语法表达得更多。想想你如何可以使用类似的名字通过共同的词缀来分组事物。或者考虑如何通过在名字中包含这些信息来暗示函数参数是输入还是输出。
- en: In a Nutshell
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: In your name I will hope, for your name is good.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的名字中，我会寄予希望，因为你的名字是好的。
- en: --Psalms 52:9
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: --诗篇 52:9
- en: 'Our ancient ancestors knew it, and good programmers know it: It''s crucial
    to name things well. Good names serve more than just an aesthetic purpose; they
    convey information about the structure of code. They are an essential tool to
    aid comprehensibility and maintainability.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的祖先早已知道，优秀的程序员也知道：给事物命名至关重要。好的命名不仅仅是为了美观，它们还能传达关于代码结构的更多信息。它们是帮助理解性和可维护性的基本工具。
- en: The main reason we write code in high-level languages is to communicate, and
    that communication is to an audience of code readers—other programmers—rather
    than to the compiler. Bad names have the potential to mislead. There *is* power
    in a name, and experienced programmers understand the balance of concerns involved
    when naming any part of their code.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以用高级语言编写代码，主要目的是为了沟通，而这种沟通是面向代码读者——其他程序员——而不是编译器。糟糕的命名可能会误导。名字确实有力量，经验丰富的程序员在命名代码的任何部分时都理解所涉及的权衡。
- en: '**GENERAL DOS AND DON''TS**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用的“应该做”和“不应该做”的事项**'
- en: 'We can condense a lot of the advice in this chapter into some general dos and
    don''ts. *Don''t* create names that are:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将本章中的许多建议归纳为一些通用的“应该做”和“不应该做”的事项。*不要*创建以下类型的名字：
- en: '**Cryptic**'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**晦涩难懂**'
- en: You can create inexplicable names in a number of ways. Acronyms and abbreviations
    can appear quite random, and single letter names are far too magical.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式创建难以解释的名字。首字母缩略词和缩写可能会显得相当随机，单个字母的名字也过于神奇。
- en: '**Verbose**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**冗长**'
- en: Avoid terse names, but don't create a variable called `the_number_of_apples_before_I_started_eating`,
    either. It's neither remotely useful nor funny.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 避免简短的名字，但也不应该创建一个名为`the_number_of_apples_before_I_started_eating`的变量。这既不实用也不幽默。
- en: '**Inaccurate or misleading**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**不准确或误导**'
- en: As obvious as it seems, make your names accurate. Don't call something a `widget_list`
    if it has nothing to do with lists. Don't call something `widget` if it's a container
    of widgets.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很明显，但请确保你的命名准确无误。如果某个东西与列表无关，就不要称其为`widget_list`。如果某个东西是组件的容器，就不要称其为`widget`。
- en: 'Misspelling opens a minefield of confusion: *I thought the variable was called*
    *`ignoramus`*, *but I can''t find it anywhere*. *Oops, it was misspelled* *`ignoramous`*.
    Sigh.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 拼写错误会引发一片混乱：*我以为这个变量叫做* *`ignoramus`*，*但我到处都找不到它*。*哎呀，它拼错了* *`ignoramous`*。唉。
- en: '**Ambiguous or vague**'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**含糊不清或模糊**'
- en: Don't use a name that could be interpreted in several ways. Don't use a hopelessly
    vague name like `data` or `value` unless it's perfectly clear what it represents.
    Avoid the vague `temp` or `tmp` unless you *really* need it.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用可能被解释为几种不同含义的名字。除非非常清楚它代表什么，否则不要使用像`data`或`value`这样毫无希望模糊的名字。除非你真的需要，否则避免使用模糊的`temp`或`tmp`。
- en: Don't differentiate names by capitalization or by changes of a single character.
    Be wary of names that sound similar.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 不要通过大小写或单个字符的变化来区分名字。要警惕听起来相似的名字。
- en: Don't gratuitously create local variables with the same name as something in
    an outer scope.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 不要随意创建与外部作用域中某个东西具有相同名称的局部变量。
- en: '**Too cute**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**过于可爱**'
- en: Sexy little abbreviations, clever shortenings that are hard to remember, and
    interpretive use of numerals should be avoided. *i18n*, a common abbreviation
    for *internationalization*, reads like nonsense to the uninitiated.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 那些性感的缩写，难以记住的巧妙缩写，以及对数字的解释性使用都应该避免。*i18n*，这是*国际化*的常见缩写，对于外行人来说听起来像是无意义的。
- en: On the other hand, *do* create appropriate names that are clear, specific, concise,
    accurate, and unambiguous. *Do* use common terms and frames of reference. Use
    words from the problem domain, and draw on descriptive design pattern names.(Gamma
    et al. 94)
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*应该*创建清晰、具体、简洁、准确且无歧义的名字。*应该*使用常见的术语和参考框架。使用问题域中的词汇，并借鉴描述性设计模式的名字。（Gamma
    等人 94）
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| 优秀的程序员 . . . | 糟糕的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Realize the importance of names and treat them with respect
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到命名的重要性，并尊重它们。
- en: Think about naming and choose appropriate names for everything they create
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑命名，并为他们创建的每一件事选择合适的名称
- en: 'Hold many forces in balance: name length, clarity, context, and so on'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名称长度、清晰度、上下文等方面保持平衡
- en: Keep a view of the bigger picture, so their names hold together across a project
    (or projects)
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持对整体图景的观察，这样它们的命名可以在整个项目（或多个项目）中保持一致
- en: '|'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Care little for the clarity of their code
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对他们代码的清晰度不太关心
- en: Produce *write-once* code that is quick to write and poorly thought out
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生*一次性*代码，这种代码易于编写但思考不足
- en: Ignore the language's natural idioms
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略语言的天然习语
- en: Are inconsistent in naming
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名不一致
- en: Don't think holistically, failing to consider how their piece of code fits into
    the whole
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从整体上思考，未能考虑他们的代码片段如何融入整体
- en: '|'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-747
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. 最佳计划")'
- en: Discusses coding standards, which may guide you in naming things. Also talks
    about *holy wars*, which Hungarian Notation is definitely a cause of.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论编码标准，这些标准可能会指导你在命名时的选择。还讨论了*圣战*，匈牙利命名法无疑是其起因之一。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 写作技巧")'
- en: Good names don't replace well-documented code—but they are an integral part
    of code documentation.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 好的命名不能替代文档齐全的代码——但它们是代码文档的一个基本组成部分。
- en: '![See Also](tagoreillycom20080909nostarchimages207452.png.jpg)'
  id: totrans-752
  prefs: []
  type: TYPE_IMG
  zh: '![另请参阅](tagoreillycom20080909nostarchimages207452.png.jpg)'
- en: Get Thinking
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 474.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题的详细讨论可以在第474页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: Are these good variable names? Answer with either *yes* (explain why, and in
    what context), *no* (explain why), or *can't tell* (explain why).
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是好的变量名称吗？用*是*（解释原因，以及上下文），*否*（解释原因），或*无法判断*（解释原因）来回答。
- en: '`int apple_count`'
  id: totrans-757
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int apple_count`'
- en: '`char foo`'
  id: totrans-758
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`char foo`'
- en: '`bool apple_count`'
  id: totrans-759
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bool apple_count`'
- en: '`char *string`'
  id: totrans-760
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`char *string`'
- en: '`int loop_counter`'
  id: totrans-761
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int loop_counter`'
- en: When would these be appropriate function names? Which return types or parameters
    might you expect? Which return types would make them nonsensical?
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下这些是合适的函数名称？你可能会期望哪些返回类型或参数？哪些返回类型会使它们变得没有意义？
- en: '`doIt(...)`'
  id: totrans-763
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doIt(...)`'
- en: '`value(...)`'
  id: totrans-764
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`value(...)`'
- en: '`sponge(...)`'
  id: totrans-765
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sponge(...)`'
- en: '`isApple(...)`'
  id: totrans-766
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isApple(...)`'
- en: Should a naming scheme favor the easy reading or easy writing of code? How would
    you make either easy?
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名方案应该优先考虑代码的易读性还是易写性？你将如何使其中之一变得容易？
- en: How many times do you write a single piece of code? (Think about it.) How many
    times do you read it? Your answers should give some indication as to the relative
    importances.
  id: totrans-768
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会写多少次同一块代码？（想想看。）你会读多少次？你的答案应该能给出一些关于相对重要性的指示。
- en: What do you do when naming conventions collide? Say you're working on camelCase
    C++ code and need to do STL (using_underscore) library work. What's the best way
    to handle this situation?
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命名约定冲突时，你会怎么做？比如说，你正在编写驼峰式C++代码，并且需要进行STL（使用下划线）库的工作。处理这种情况的最佳方法是什么？
- en: How long should a loop be before you need to give a meaningful loop counter
    name?
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你需要给出有意义的循环计数器名称之前，循环应该有多长？
- en: In C, if `assert` is a macro, why is its name lowercase? Why should we name
    macros so they stand out?
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C语言中，如果`assert`是一个宏，为什么它的名称是小写的？我们为什么应该给宏起名，使其突出？
- en: What are the pros and cons of following your language's standard library naming
    conventions?
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循你语言的标准库命名约定的优缺点是什么？
- en: Can you wear out a name? Is it okay to repeat a local variable name in many
    different functions? Is it okay to use local names that override (and hide) global
    names? Why?
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否用完一个名称？在许多不同的函数中重复局部变量名称是否可以？使用会覆盖（并隐藏）全局名称的局部名称是否可以？为什么？
- en: Describe the mechanics of Hungarian Notation. What are the pros and cons of
    this naming convention? Does it have a place in modern code design?
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述匈牙利命名法的机制。这种命名约定的优缺点是什么？它是否在现代代码设计中有一席之地？
- en: We see many classes containing member functions acting as *getters* and *setters*;
    reading and writing the value of certain properties. What are the common naming
    conventions for these functions, and which is the best?
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到许多包含作为*获取器*和*设置器*的成员函数的类；读取和写入某些属性的值。这些函数的常见命名约定是什么，哪一个最好？
- en: Getting Personal
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化思考
- en: How good are you at naming? How many of these heuristics do you follow already?
    Do you consciously think about your naming and these sorts of rules, or do you
    just *do it* all naturally? In which areas can you improve?
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在命名方面有多擅长？你已经遵循了多少这样的启发式方法？你是否会自觉地思考你的命名和这类规则，或者你只是自然而然地*做它*？在哪些方面你可以改进？
- en: Does your coding standard mention naming at all?
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的编码标准是否提到了命名？
- en: Does it cover all the cases we've looked at here? Is it *sufficient*? Is it
    useful, or just superficial?
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否涵盖了我们在这里讨论的所有情况？是否足够*充分*？它是有用的，还是只是表面的？
- en: How much naming detail *is* appropriate in a coding standard?
  id: totrans-780
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编码标准中，有多少命名细节是合适的？
- en: What's the worst name you've come across recently? How have names ever misled
    you? How would you have changed them to avoid future confusion?
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最近遇到的最糟糕的名字是什么？名字是如何误导你的？你会如何修改它们以避免未来的混淆？
- en: Do you have to port code between platforms? How has this affected filenames,
    other names, and the overall code structure?
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否需要在平台之间移植代码？这对文件名、其他名称和整体代码结构有何影响？
- en: Chapter 4. THE WRITESTUFF
  id: totrans-783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 THE WRITESTUFF
- en: '*Techniques for Writing "Self-Documenting" Code*'
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*编写“自文档化”代码的技术*'
- en: Real seriousness in regard to writing is one of two absolute necessities. The
    other, unfortunately, is talent.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 对写作的真正认真是两个绝对必要条件之一。不幸的是，另一个是天赋。
- en: --Ernest Hemingway
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: ——欧内斯特·海明威
- en: Modern self-assembly ( *flat-pack*) furniture is remarkable, leaving even the
    seasoned carpenter in a state of awe and confusion. Generally, it's cleverly designed
    and will *eventually* build into what you expect it to.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 现代自组装（*flat-pack*）家具非常出色，即使是经验丰富的木匠也会感到敬畏和困惑。通常，它们设计得很巧妙，最终会变成你期望的样子。
- en: When assembling it, you have to rely on the supplied instructions—you'll build
    something more like modern art than furniture without them. The quality of the
    instructions drastically affects how easy construction is. Bad instructions make
    you sweat, swear, and continually take apart pieces of wood that should never
    have been attached in the first place.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装时，你必须依赖提供的说明——没有它们，你将建造出更多像现代艺术而不是家具的东西。说明的质量极大地影响了施工的难易程度。糟糕的说明会让你大汗淋漓，咒骂不已，并不断地拆解那些本不应该连接在一起的木块。
- en: It's a shame they don't make things like they used to.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 真遗憾，他们不再像以前那样制造东西了。
- en: Source code suffers from similar problems. It's true, they don't make it like
    they used to, but no one was ever *that* fond of punched cards or COBOL anyway.
    More importantly, without good instructions that explain how the code fits together,
    working with some programs can make you sweat, swear, and continually take apart
    pieces of code that should never have been attached in the first place.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码也面临着类似的问题。诚然，他们不再像以前那样制造它了，但没有人真的*那么*喜欢穿孔卡片或COBOL。更重要的是，没有好的说明来解释代码是如何组合在一起的，使用一些程序可能会让你大汗淋漓，咒骂不已，并不断地拆解那些本不应该连接在一起的代码片段。
- en: Creating good code means creating *well-documented* code. The reason we write
    code is to communicate clear sets of instructions—not just to the computer, but
    also to the poor fools who have to fix or extend those instructions later on.
    Code in the Real World is never written and then forgotten about. It will be modified,
    extended, and maintained over the life of the software product. To do this we
    need instructions, a user guide—documentation.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好的代码意味着创建*良好文档化的*代码。我们编写代码的原因是为了传达一组清晰的指令——不仅是对计算机，也是对那些后来必须修复或扩展这些指令的可怜傻瓜。现实世界中的代码永远不会被写下来然后被遗忘。它将在软件产品的整个生命周期中被修改、扩展和维护。为此，我们需要说明，用户指南——文档。
- en: Common wisdom for documenting code is that you should either write tons of documents
    *about* the code or write tons of comments *in* the code.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写代码的常见智慧是，你应该要么写大量的文档*关于*代码，要么在代码中写大量的注释*。
- en: Both ideas are nonsense. Most programmers have an aversion to word processors
    and get bored with writing too many comments. Writing code *is* hard work. Documenting
    it shouldn't be more hard work. In the heat of the software factory, anything
    that requires extra work tends not to be done. Or if it is, it is done badly.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个想法都是无意义的。大多数程序员都讨厌文字处理器，对写太多注释感到厌烦。编写代码*确实是*一项艰苦的工作。编写文档不应该比这更辛苦。在软件工厂的热潮中，任何需要额外工作的事情往往都不会做。或者如果做了，也往往做得不好。
- en: 'I''ve seen software systems propped up by design specifications, implementation
    notes, maintenance guides, and style guides. Unsurprisingly, this is the kind
    of code that''s really tedious to work with. The problem with all of this supporting
    documentation is:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过软件系统依靠设计规范、实现笔记、维护指南和风格指南来支撑。不出所料，这种代码真的很令人厌烦。所有这些辅助文档的问题在于：
- en: We don't need extra work to do. Writing documentation takes a lot of time; so
    does reading it. Programmers would rather spend that time programming.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要额外的工作去做。编写文档需要花费很多时间；阅读它也是如此。程序员更愿意把时间花在编程上。
- en: All these separate documents must be kept up to date with any code changes.
    In a large project, that's an awful lot of work. The common alternative (never
    updating any documentation) leads to dangerously inaccurate and misleading information.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些单独的文档都必须与任何代码更改保持更新。在一个大型项目中，这是一项巨大的工作量。常见的替代方案（从不更新任何文档）会导致危险的不准确和误导性信息。
- en: A forest of documentation is hard to manage. It's not easy to find the right
    document or to locate a particular piece of information that could be in one of
    several places within a document. Like code, documentation has to be held under
    revision control, and you must make sure you're reading the corresponding document
    version for the version of source code you're working on.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一大堆文档难以管理。很难找到正确的文档，或者找到文档中可能分散在几个地方的信息。就像代码一样，文档也需要受到版本控制的约束，你必须确保你阅读的是与你在工作的源代码版本相对应的文档版本。
- en: Important information in separate documents can easily be missed. If it's not
    beside the code, and there are no helpful pointers, things are overlooked.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要信息分散在单独的文档中很容易被忽略。如果它不在代码旁边，而且没有有用的提示，事情就会被忽视。
- en: '**KEY CONCEPT**'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Don''t write code that needs to be propped up by external documentation. It''s
    flimsy. Ensure that your code reads clearly on its own*.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要编写需要外部文档支撑的代码。这是脆弱的。确保你的代码在没有外部文档的情况下也能读得清楚*。'
- en: The common alternative—documenting your code with detailed code comments—can
    be just as bad, if not worse. Reams of slavishly detailed comments obstruct good
    code. You'll end up writing poorly formatted documentation rather than a good
    program.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的替代方案——用详细的代码注释来编写代码文档——可能同样糟糕，甚至更糟。大量的详细注释会阻碍好代码。你最终会写出格式糟糕的文档，而不是一个好的程序。
- en: How do we avoid this nightmare? We write *self-documenting* code.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免这个噩梦？我们编写*自文档*代码。
- en: Self-Documenting Code
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自文档代码
- en: 'It sounds like a good idea, doesn''t it? But what *is* self-documenting code?
    This program is self-documenting:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是个好主意，不是吗？但什么是自文档代码？这个程序是自文档的：
- en: '[PRE11]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's not anything to be proud of, though. A more complicated, more useful self-documenting
    program requires a great deal of skill. Computer programs tend to be much harder
    to read than they are to write. Anyone who has used Perl will understand this;
    it has been described as the ultimate write-once language. Indeed, old Perl code
    can be truly unfathomable, but you can write opaque code in any language, and
    it doesn't take much effort.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是什么值得骄傲的事情。一个更复杂、更有用的自文档程序需要大量的技能。计算机程序往往比编写它们更难阅读。任何使用过Perl的人都会理解这一点；它被描述为终极的一次性编写语言。确实，旧的Perl代码可能真的难以理解，但你可以在任何语言中编写晦涩的代码，而且这并不需要太多的努力。
- en: The only document that describes your code completely and correctly is the code
    itself. That doesn't automatically mean it's the best description possible, but
    more often than not, it's the *only* documentation you'll have available.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 完全且正确描述你代码的唯一文档就是代码本身。这并不意味着它是可能的最佳描述，但往往，它就是你所拥有的唯一文档。
- en: You should, therefore, do everything you can to make it good documentation,
    the kind of documentation that anyone can read. By necessity, code is something
    that more people than just the author must be able to understand. Programming
    languages are our communication medium. Clear communication is vital. With clarity,
    your code gains quality because you're less likely to make mistakes (since errors
    are more obvious), and it is cheapter to maintain the code—it takes less time
    to learn.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该尽一切可能使其成为好的文档，任何人都能阅读的文档。出于必要性，代码是除了作者之外更多的人必须能够理解的东西。编程语言是我们的交流媒介。清晰的沟通至关重要。有了清晰性，你的代码质量会提高，因为你不太可能犯错误（因为错误更明显），维护代码也更便宜——学习它所需的时间更少。
- en: Self-documenting code is easily readable code. It is comprehensible on its own,
    without relying on external documentation. We can improve the clarity of our code
    in many ways. Some techniques are very basic and have been drilled into us since
    we were taught to program. Others are more subtle and come with experience.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 自文档化的代码易于阅读。它本身就可以理解，无需依赖外部文档。我们可以通过许多方式提高代码的清晰度。一些技术非常基础，自从我们学习编程以来就被我们熟知。其他技术则更为微妙，需要经验。
- en: '**KEY CONCEPT**'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Write your code to be read. By humans. Easily. The compiler will be able to
    cope*.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写易于人类阅读的代码。简单。编译器能够应对*。'
- en: Here's an example of a simple function that's about as far from self-documenting
    as you can get. What do you think it does?
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，一个简单的函数，它离自文档化最远。你认为它做什么？
- en: '[PRE12]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**DON''T JUDGE A BOOK . . .**'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要以貌取书……**'
- en: 'A file of self-documenting code reads a lot like a good reference book. Such
    a bookis carefully structured, sectioned, and laid out. It reads naturally from
    front to back and top to bottom, but you can just as easily dive into it as a
    reference. That''s how our code should work. Let''s compare the parts:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自文档化的代码文件读起来就像一本好的参考书。这样的书结构严谨，分章节，布局合理。它从前到后、从上到下自然阅读，但也可以作为参考书直接查阅。我们的代码应该就是这样。让我们比较一下这些部分：
- en: '**Introduction**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '**引言**'
- en: A book's introduction explains what's inside, sets the tone, and explainshow
    it fits into the bigger picture. A source file should begin with a code comment
    header. It explains what's in the file and specifies to which project the source
    file belongs.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书的引言解释了书中的内容，设定了基调，并解释了它如何融入更大的图景。源文件应该以代码注释头部开始。它解释了文件的内容，并指定了源文件属于哪个项目。
- en: '**Table of contents**'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: Although some argue that the file header should include a list of all thecontained
    functions, I strongly advise against this. It will rapidly become out of date.
    You can, however, list the contents of the file (all types and classes, functions,
    variables) with most modern editors or IDEs, providing useful directions to specific
    pieces of code.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有人认为文件头部应该包含所有包含的函数列表，但我强烈建议不要这样做。它会迅速过时。然而，你可以使用大多数现代编辑器或IDE列出文件的内容（所有类型和类、函数、变量），为特定代码片段提供有用的指导。
- en: '**Sections**'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节**'
- en: This book is divided into several parts. Source files may also split intomajor
    sections; perhaps a single file contains several classes or logical groups of
    functions. This is where breakwater comments help. Extravagant ASCII art is generally
    a Bad Thing, but these kinds of comments help to logically break up the file for
    easy navigation.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 本书分为几个部分。源文件也可能分为主要章节；可能一个文件包含几个类或函数的逻辑组。这就是防波堤注释发挥作用的地方。过度的ASCII艺术通常是一件坏事，但这类注释有助于逻辑上分割文件，便于导航。
- en: Beware, though. Putting too many things in a single source file is not a good
    idea. A simple one-to-one file/class correspondence is best. Large, multipurpose
    files are confusing to understand and very hard to navigate. (If this advice leaves
    you with too many source files, then you need to improve the higher-level code
    structure.)
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要注意。在一个源文件中放入太多东西不是一个好主意。简单的文件/类一对一对应是最好的。大型、多用途的文件难以理解，也很难导航。（如果这条建议让你有太多的源文件，那么你需要改进更高层次的代码结构。）
- en: '**Chapters**'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节**'
- en: Each chapter of a book is a self-contained and well-named chunk. Source files
    typically contain a number of well-named functions.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书的每一章都是一个自包含且命名良好的部分。源文件通常包含多个命名良好的函数。
- en: '**Paragraphs**'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '**段落**'
- en: Within each function, you'll group code into blocks of statements. The initial
    variable declarations will be in one logical block, separated from the following
    code by a blank line (well, at least they will be in older C code). This isn't
    a syntactic thing, just layout that helps you read the code.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数中，你将把代码分组为语句块。初始变量声明将位于一个逻辑块中，通过空白行与后续代码隔开（嗯，至少在较老的C代码中是这样的）。这并不是一个语法问题，而是一种有助于你阅读代码的布局。
- en: '**Sentences**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**句子**'
- en: Sentences naturally correspond to each single code statement.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 句子自然对应于每个单独的代码语句。
- en: '**Cross-references and index**'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**交叉引用和索引**'
- en: Again, this isn't a part of your source file markup, but a good editor orIDE
    will provide cross-referencing capabilities. Learn how to use them.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不是你源文件标记的一部分，但一个好的编辑器或IDE将提供交叉引用功能。学习如何使用它们。
- en: This is an interesting analogy, but what difference does it make for writing
    code?Many good book-writing techniques translate into good code-writing techniques.
    Learn them to make your code more readable. Split code into sections, chapters,
    and paragraphs. Use layout to emphasize the code's logical structure. Use simple,
    short code statements—just like short sentences, they're more readable.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的类比，但它对编写代码有什么区别呢？许多优秀的书籍写作技巧可以转化为优秀的代码编写技巧。学习它们可以使你的代码更具可读性。将代码分成部分、章节和段落。使用布局来强调代码的逻辑结构。使用简单、简短的代码语句——就像简短的句子一样，它们更易读。
- en: That's a realistic example; countless millions of lines in production software
    look like that, and programmers on the front line suffer because of it. In contrast,
    the following code *is* self-documenting. You can probably work out what it does
    by just reading the first line.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个现实例子；无数百万行生产软件中的代码看起来都像这样，而一线程序员因此遭受痛苦。相比之下，下面的代码**确实是**自文档化的。你只需阅读第一行就能大概了解它做了什么。
- en: '[PRE13]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's one thing you should notice about that function—the lack of comments.
    It's obvious what's going on without any. Comments would just add more stuff to
    be read. They'd be unnecessary noise and would make the function harder to maintain
    in the future. That's important—because even the smallest, most beautiful functions
    *will* need later maintenance.^([[1](#ftn.CHP-4-FN-1)])
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意关于那个函数的一件事——注释的缺失。没有注释也很明显发生了什么。注释只会增加更多需要阅读的内容。它们会成为不必要的噪音，并使函数在未来更难维护。这很重要——因为即使是最小、最漂亮的函数**也**需要后续维护.^([[1](#ftn.CHP-4-FN-1)])
- en: '* * *'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-4-FN-1)]) Did you work out what that first example did? Both functions
    compute a value in the Fibonacci sequence. Which would you prefer to read?
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-4-FN-1)]) 你是否弄清楚了这个第一个示例做了什么？这两个函数都在计算斐波那契数列中的值。你更愿意阅读哪一个？
- en: Techniques for Self-Documenting Code
  id: totrans-837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自文档化代码的技巧
- en: Writing self-documenting code is traditionally thought to involve adding a copious
    amount of comments. Good commenting certainly is an important technique, but there's
    muchmore to it than that. In fact, we should actively *avoid* comments bywriting
    clear code that doesn't need them.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上认为编写自文档化代码需要添加大量的注释。良好的注释当然是一项重要的技术，但其中还有更多。事实上，我们应该通过编写不需要注释的清晰代码来**积极避免**注释。
- en: The following sections list important self-documenting code techniques. You'll
    notice that they cover similar ground to the other chapters in this first part
    of the book. That's not entirely surprising—there are many overlapping characteristics
    of good code; the benefits of one technique will be seen in several areas of code
    quality.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节列出了重要的自文档化代码技巧。你会注意到，它们与本书第一部分其他章节的内容相似。这并不完全令人惊讶——优秀的代码有许多重叠的特征；一种技术的益处将在代码质量的多个方面体现。
- en: Write Simple Code with Good Presentation
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写具有良好展示的简单代码
- en: Presentation has an enormous impact on the clarity of code. Thoughtful layout
    conveys the structure of the code; it makes functions, loops, and conditional
    statements clearer.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 展示对代码的清晰度有巨大的影响。深思熟虑的布局传达了代码的结构；它使函数、循环和条件语句更清晰。
- en: Make the "normal" path through your code obvious. Error cases should not confuse
    the normal flow of execution. Your *if-then-else* constructs should be ordered
    consistently (i.e., always place the "normal" case before the "error" case, or
    vice versa).
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的代码中的“正常”路径明显。错误情况不应该混淆正常的执行流程。你的**if-then-else**结构应该有序排列（即，始终将“正常”情况放在“错误”情况之前，或者反之亦然）。
- en: 'Avoid too many nested statements. They lead to complex code that needs lengthy
    explanation. Common wisdom claims that each function should have one and *only*
    one exit point; this is known as *Single Entry, Single Exit (SESE)* code. But
    this is actually too restrictive for readable code and leads to deep levels of
    nesting. I prefer the `fibonacci` example we saw previously to this SESE variant:'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过多的嵌套语句。它们会导致需要长时间解释的复杂代码。常识认为每个函数应该只有一个并且**只有**一个出口点；这被称为**单入口单出口（SESE）**代码。但实际上，这对可读代码来说过于严格，会导致深层嵌套。我更喜欢我们之前看到的`fibonacci`示例，而不是这种SESE变体：
- en: '[PRE14]'
  id: totrans-844
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For the sake of an extra `return` statement, I'd rather avoid that gratuitous
    nesting—it has made the function much harder to read. `return`s deep in the middle
    of a function's logic *are* questionable, but simple short circuits at the top
    aid function readability immensely.
  id: totrans-845
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了一个额外的`return`语句，我宁愿避免这种无谓的嵌套——它使得函数的阅读变得非常困难。函数逻辑中间的`return`是可疑的，但顶部的简单短路对函数的可读性有很大帮助。
- en: Be wary of optimizing code so that it's no longer a clear expression of abasic
    algorithm. *Never* optimize code unless you've proved that it *is* a bottleneck
    to acceptable program function. Optimize only then, and clearly comment about
    what's going on.
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎优化代码，使其不再是基本算法的清晰表达。*永远*不要优化代码，除非你已经证明它*确实是*程序功能可接受的瓶颈。只有在那时才进行优化，并清楚地注释正在发生的事情。
- en: Choose Meaningful Names
  id: totrans-847
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择有意义的名字
- en: All variable, type, file, and function names should be meaningful, not misleading.
    A name should faithfully describe what it represents. If you can't name something
    meaningfully, then do you really understand what it's doing? Your naming scheme
    should be consistent so that there are no nasty surprises. Make sure that a variable
    is only ever used for what its name implies.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量、类型、文件和函数名都应该是有意义的，而不是误导性的。一个名字应该忠实描述其所代表的内容。如果你不能有意义地命名某物，那么你真的理解它在做什么吗？你的命名方案应该是连贯的，以便没有令人不快的惊喜。确保变量只用于其名字所暗示的内容。
- en: Good names are probably our best way of avoiding gratuitous comments. They are
    the nearest thing we have in code to the expressiveness of natural language.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 好的命名可能是我们避免无谓注释的最好方式。它们是我们在代码中接近自然语言表达性的东西。
- en: Decompose into Atomic Functions
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解为原子函数
- en: The way that you split the code into functions and the names you give those
    functions can either add meaning to code or totally strip it of sense.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 你将代码分割成函数以及给这些函数命名的做法，要么可以为代码增加意义，要么完全剥夺其意义。
- en: '*One function, one action*. Make that your mantra. Don''t write complex functions
    that make coffee, clean shoes, *and* guess the number you first thought of. In
    one function, do one action. Choose a name that unambiguously explains that action.
    A good name means that no extra documentation is needed.'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个函数，一个动作*。把这当作你的座右铭。不要编写复杂的函数，既做咖啡，又擦鞋，*还*猜测你最初想到的数字。在一个函数中，只做一项动作。选择一个明确解释该动作的名字。好的名字意味着不需要额外的文档。'
- en: Minimize any surprising *side effects*, no matter how benign they appear. They
    require extra documentation.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化任何意外的*副作用*，无论它们看起来多么无害。它们需要额外的文档。
- en: Keep it short. Short functions are easy to understand. You can get your head
    around a complex algorithm if it's broken into small pieces with descriptive names,
    but you can't if it's a sprawling mess of code on the page.
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简短。简短的功能易于理解。如果你将复杂算法分解成带有描述性名字的小块，你就可以理解它，但如果它是一页上杂乱无章的代码，你就不能。
- en: Choose Descriptive Types
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择描述性类型
- en: 'As much as possible, describe constraints or behavior with the available language
    features. For example:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，使用可用的语言特性来描述约束或行为。例如：
- en: If you are defining a value that will never change, enforce it as a constant
    type (use `const` in C).
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在定义一个永远不会改变的值，强制它为常量类型（在C中使用`const`）。
- en: If a variable should not contain a negative value, use an unsigned type (if
    your language provides one).
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个变量不应该包含负值，使用无符号类型（如果你的语言提供了的话）。
- en: Use enumerations to describe a related set of values.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举来描述一组相关的值。
- en: Select appropriate types. In C/C++, put sizes in `size_t` variables and pointer
    arithmetic results in `ptrdiff_t` variables.
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的类型。在C/C++中，将大小放入`size_t`变量中，将指针运算的结果放入`ptrdiff_t`变量中。
- en: Name Constants
  id: totrans-861
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名常量
- en: Stumbling over some code that reads `if (counter == 76)` will leave you scratching
    your head. What is the magic significance of the number 76? What is the intent
    of that test?
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到一些看起来像 `if (counter == 76)` 的代码，会让你感到困惑。数字76有什么神奇的意义？那个测试的意图是什么？
- en: These so-called *magic numbers* are evil. They hide meaning. Writing
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这些所谓的*魔法数字*是邪恶的。它们隐藏了意义。编写
- en: '[PRE15]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'is much clearer. If you use the constant `76` (sorry, `bananas_per_cake`) a
    lot in your code, you gain an additional benefit: When you need to change the
    banana-to-cake ratio, you only need to make one code change, rather than perform
    an error-prone search-and-replace for every `76` in the project.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 要清晰得多。如果你在代码中大量使用常数`76`（抱歉，`bananas_per_cake`），你将获得额外的好处：当你需要更改香蕉与蛋糕的比例时，你只需要进行一次代码更改，而不是在项目中为每个`76`执行错误易发的搜索和替换。
- en: '**KEY CONCEPT**'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Avoid magic numbers. Use well-named constants instead*.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免使用魔法数字。使用有良好命名的常量代替*。'
- en: This holds true for constant strings as well as numbers. Question the use of
    *any* literal in your code, especially when you use it several times over—can
    you use a more maintainable named constant instead?
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于常量字符串和数字。质疑代码中 *任何* 文本的用途，尤其是当你多次使用它时——你能使用一个更易于维护的命名常量吗？
- en: Emphasize Important Code
  id: totrans-869
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强调重要代码
- en: Make important stuff stand out from mundane stuff. Draw the reader's attention
    to the right places. There are many coding opportunities to do this.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 让重要内容与平凡内容区分开来。将读者的注意力引向正确的位置。有许多编码机会可以做到这一点。
- en: 'For example:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: Order the declarations in a class helpfully. Public information should come
    first, since this is what the class user needs to see. Put the private implementation
    details at the end, since they are less important to most readers.
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于排序类中的声明。公共信息应该放在前面，因为这是类用户需要看到的内容。将私有实现细节放在最后，因为它们对大多数读者来说不太重要。
- en: Wherever possible, hide all nonessential information. Don't clutter the global
    namespace with unnecessary cruft. In C++ you can use the pimpl idiom to hide class
    implementation details (Meyers 97).
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，隐藏所有非必要信息。不要让全局命名空间充斥着不必要的冗余。在 C++ 中，你可以使用 pimpl 习语来隐藏类的实现细节（Meyers
    97）。
- en: Don't hide important code. Write only one statement per line, and keep each
    statement simple. You *can* write very clever `for` loops, putting all the logic
    on one line with an assortment of commas, but it's not easy to read. Don't do
    it.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要隐藏重要的代码。每行只写一个语句，并保持每个语句简单。你 *可以* 写出非常巧妙的 `for` 循环，将所有逻辑放在一行中，并用一系列逗号分隔，但这不容易阅读。不要这样做。
- en: Limit the number of nested conditional statements. If you don't, the handling
    of important conditions will become hidden by a nest of `if`s and braces.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制嵌套条件语句的数量。如果不这样做，重要条件的处理将被一系列的 `if` 和花括号所隐藏。
- en: '**KEY CONCEPT**'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Make sure all important code stands out and is easy to read. Hide anything
    that the client audience doesn''t care about*.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保所有重要的代码都突出显示，并且易于阅读。隐藏客户端受众不关心的任何内容*。'
- en: Group-Related Information
  id: totrans-878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组相关信息
- en: Present all related information in one place. Otherwise, you'll not only make
    the reader jump through hoops, you'll require him to know via ESP where the hoops
    are. The API for a single component should be presented in a single file. If there
    is so much related information that it becomes messy to present it all together,
    question the code's design.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个地方呈现所有相关信息。否则，你不仅会让读者跳过许多障碍，而且还需要他通过 ESP 知道障碍在哪里。单个组件的 API 应该在一个文件中呈现。如果有如此多的相关信息，以至于一起呈现变得混乱，那么质疑代码的设计。
- en: Whenever possible, group items by a language construct. In C++ and C# we can
    group items within a `namespace`. Java provides `package`s as grouping mechanisms.
    Related constant values can be defined in an `enum`.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过语言结构对项目进行分组。在 C++ 和 C# 中，我们可以在 `namespace` 内部对项目进行分组。Java 提供了 `package`
    作为分组机制。相关的常量值可以在 `enum` 中定义。
- en: '**KEY CONCEPT**'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Group information together intentionally. Use language features to make this
    grouping explicit*.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '*有意地将信息分组在一起。使用语言特性来明确这种分组*。'
- en: Provide a File Header
  id: totrans-883
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供文件头
- en: Place a comment block at the top of a file to describe its contents and the
    project to which it belongs. This takes only a little effort, but it can make
    a big difference. When someone comes to maintain that file, they'll have a good
    idea what to expect.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部放置一个注释块来描述其内容和所属的项目。这只需要一点努力，但可以产生很大的影响。当有人来维护该文件时，他们会很好地了解可以期待什么。
- en: 'This header can be important: Most companies mandate that every source file
    contains a visible copyright notice for legal reasons. File headers commonly look
    something like the following.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件可能很重要：大多数公司出于法律原因要求每个源文件都包含一个可见的版权声明。文件头通常看起来像以下这样。
- en: '[PRE16]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Handle Errors Appropriately
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当处理错误
- en: Handle any error in the most appropriate context. If there is a disk I/O problem,
    you should handle it in code that accesses the disk. Perhaps handling this error
    would mean raising a different error (like a "couldn't load file" exception) to
    a higher level. This means that at each level in the program, an error is an accurate
    description of what the problem is *in that context*. Don't handle hard disk corruption
    in the user interface code—it doesn't make sense.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在最合适的环境中处理任何错误。如果有磁盘 I/O 问题，你应该在访问磁盘的代码中处理它。也许处理这个错误意味着向更高层次抛出一个不同的错误（如“无法加载文件”异常）。这意味着在程序的每个级别，错误都是对在那个环境中问题的准确描述。不要在用户界面代码中处理硬盘损坏——这没有意义。
- en: Self-documenting code helps the reader to understand where an error came from,
    whatit means, and its implications for the program at that point.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 自文档化代码有助于读者理解错误从何而来，它的含义以及它对当时程序的影响。
- en: '**KEY CONCEPT**'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Don''t return nonsensical errors. Present the appropriate information in each
    context*.'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要返回无意义的错误。在每种情况下呈现适当的信息*。'
- en: Write Meaningful Comments
  id: totrans-892
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有意义的注释
- en: As you can see, we've tried to avoid writing comments by using other implicit
    code documentation techniques. However, once you've written the clearest code
    you can, you need to comment what remains. Clear code contains an *appropriate*
    amount of commenting. What is this appropriate amount?
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们试图通过使用其他隐式代码文档技术来避免编写注释。然而，一旦你写出了尽可能清晰的代码，你需要注释剩下的部分。清晰的代码包含适量的注释。这个适量的注释是多少？
- en: '**KEY CONCEPT**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Only add comments if you can''t improve the clarity of the code in any other
    way*.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*只有在你无法以其他方式提高代码清晰度时才添加注释*。'
- en: Think about all these other techniques first. Would a name change or a new subordinate
    function make the code clearer and avoid a comment?
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑所有这些其他技巧。更改名称或添加新的从属函数会使代码更清晰并避免注释吗？
- en: '**SELF-IMPROVEMENT**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**自我提升**'
- en: How do you get better at writing self-documenting code? Let's head back into
    bookwriting territory for some clues.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何提高编写自文档化代码的能力？让我们回到书籍写作领域，寻找一些线索。
- en: 'There''s a simple principle for improving your writing skills: *If you read
    a lot, you become a better writer*. Critically reading the works of recognized
    authors teaches you what works and what doesn''t. You pick up new techniques and
    idioms to add to your arsenal.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 提高写作技能的简单原则是：*如果你读得多，你将成为一个更好的作家*。批判性地阅读知名作者的作品会教你什么有效，什么无效。你将学会新的技巧和习语，以丰富你的工具箱。
- en: Similarly, if you read a lot of code, you'll become a better programmer. If
    you immerse yourself in *good* code, you'll soon be able to smell bad code a mile
    away. Customs officials see so many passports each day that a forged one stands
    out like a sore thumb. Even clever imitations become obvious. Bad code becomes
    so much more striking when you're sensitive to the warning signs.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你阅读了很多代码，你将成为一个更好的程序员。如果你沉浸在 *良好* 的代码中，你很快就能在远处嗅出糟糕的代码。海关官员每天看到那么多护照，伪造的护照就像一个明显的痛处。即使是巧妙的模仿也会变得明显。当你对警告信号敏感时，糟糕的代码会变得更加引人注目。
- en: With this experience you'll naturally find yourself using good techniques in
    yourown code. You'll begin to spot when you write bad code; it will feel uncomfortable.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次经历，你自然会发现自己开始在代码中使用良好的技巧。你将开始注意到你编写糟糕的代码时；这会让人感到不舒服。
- en: Practical Self-Documentation Methodologies
  id: totrans-902
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际的自文档化方法
- en: We'll conclude this chapter by comparing two specific code documentation methods.
    Remember that these methods come *after* the techniques we've just seen. Kernighan
    and Plaugher said, "Don't document bad code—rewrite it." (Kernighan Plaugher 78)
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过比较两种特定的代码文档方法来结束本章。记住，这些方法是在我们刚刚看到的技巧之后出现的。Kernighan 和 Plaugher 说：“不要文档化糟糕的代码——重写它。”（Kernighan
    Plaugher 78）
- en: Literate Programming
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档化编程
- en: '*Literate programming* is an extreme self-documenting code technique, conceived
    by the renowned computer scientist Donald Knuth. He wrote a book by this name
    that described it. (Knuth 92) It is a radical alternative to the traditional programming
    model, although some people think the literate programming episode of Knuth''s
    careerwas a large and unfortunate sidetrack. Even if it''s not the One True Way
    to code, there are still things we can learn from it.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档化编程* 是一种极端的自文档化代码技术，由著名的计算机科学家 Donald Knuth 提出。他写了一本以这个名称描述它的书。（Knuth 92）它是对传统编程模型的激进替代，尽管有些人认为
    Knuth 职业生涯中的文档化编程阶段是一个大而遗憾的偏离。即使它不是编码的“唯一正确方式”，我们仍然可以从中学到一些东西。'
- en: 'The idea behind literate programming is simple: You don''t write a program,
    you write a document. The documentation language is bound up tightly with the
    programming language. Your document is primarily a description of *what* is being
    programmed, but also happens to compile *into* that program. The source code is
    the documentation, and vice versa.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 文献化编程背后的想法很简单：你不是编写程序，而是编写文档。文档语言与编程语言紧密绑定。你的文档主要是对正在编程的*什么*的描述，但碰巧也能编译成那个程序。源代码是文档，反之亦然。
- en: A literate program is written almost as a story; it is easy for the human reader
    tofollow, perhaps even enjoyable to read. It is not ordered or constrained for
    a language parser. This is more than just a language with inverted comments; it's
    an inverted method for programming. Literate programming is a whole different
    way of thinking.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 文献化的程序几乎像是一个故事一样编写；对于人类读者来说，它很容易跟随，甚至可能读起来很有趣。它不是为语言解析器排序或约束的。这不仅仅是一个带有反转注释的语言；这是一种反转的编程方法。文献化编程是一种全新的思维方式。
- en: Knuth originally mixed TEX (a markup language for document typesetting) and
    C in a system called *WEB*. A literate programming tool parses the program file
    and generates either formatted documentation or source code that can be fed into
    a traditional compiler.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth最初在名为*WEB*的系统中混合了TeX（一种文档排版标记语言）和C。文献化编程工具解析程序文件，并生成格式化的文档或可以输入传统编译器的源代码。
- en: Of course, this is just another programming technique, like structured programming
    or object-oriented programming. It doesn't *guarantee* quality documentation.
    That is, as ever, up to the programmer. However, literate programming shifts the
    emphasis toward writing a description of the program rather than just writing
    code that implements it.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是另一种编程技术，就像结构化编程或面向对象编程一样。它不能保证高质量的文档。也就是说，这始终取决于程序员。然而，文献化编程将重点转向编写程序的描述，而不仅仅是编写实现它的代码。
- en: Literate programming really comes into its own during a product's maintenance
    phase. With good quality (and quantity of ) documentation directly on hand, it
    becomes much easier to maintain the source.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 文献化编程在产品的维护阶段真正发挥其作用。有了高质量的（以及数量的）文档直接在手，维护源代码变得容易得多。
- en: 'There are many useful qualities of literate programming:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 文献化编程有许多有用的特性：
- en: Literate programming places emphasis back on writing documentation.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文献化编程将重点重新放在编写文档上。
- en: It makes you think about your code in a different way since you write explanations
    and justifications as you go along.
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这让你在编写解释和论证的同时，以不同的方式思考你的代码。
- en: You are more likely to update the documentation when you make changes to the
    code, since it's situated conveniently nearby.
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你对代码进行更改时，你更有可能更新文档，因为它们方便地位于附近。
- en: You are guaranteed to only have one document for the whole codebase. You'll
    always be able to view the correct version for the code you're working on—it *is*
    the code you're working on.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保证整个代码库只有一个文档。你总是能够查看你正在工作的代码的正确版本——它就是你在工作的代码。
- en: 'Literate programming encourages the inclusion of items not normally foundin
    source comments. For example: a description of the algorithms used, proofs of
    correctness, and the justification of design decisions.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文献化编程鼓励包含通常在源代码注释中找不到的项目。例如：算法描述、正确性证明以及设计决策的合理性论证。
- en: 'However, literate programming isn''t a magical cure-all. It has some serious
    drawbacks:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文献化编程并不是万能的灵丹妙药。它有一些严重的缺点：
- en: Literate programs are harder to write, because most programmers don't find it
    natural. We tend not to think of code as a printed document that needs formatting.
    Rather, we mentally model control flows and interacting objects.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文献化的程序更难编写，因为大多数程序员并不觉得这样做很自然。我们往往不把代码看作是需要格式化的打印文档。相反，我们心理上模拟控制流和交互对象。
- en: Extra compilation steps are required, which make literate programs slowerto
    work with. There is still no *really* good tool support.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要额外的编译步骤，这使得文献化的程序在操作时速度较慢。目前还没有真正好的工具支持。
- en: It's quite difficult to process a literate program, since the compiler needs
    to extract all the program fragments and reassemble them, in the correct order.
    Whileit's nice to write the document in any order, C can be quite specific about
    how it wants to see code; `#includes` must come first, for example. This leads
    to some practical compromises.
  id: totrans-920
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理文学程序相当困难，因为编译器需要提取所有程序片段并按正确顺序重新组装它们。虽然按照任何顺序编写文档很方便，但 C 语言对代码的顺序有相当具体的要求；例如，`#includes`
    必须首先出现。这导致了一些实际上的妥协。
- en: You might end up documenting some code that doesn't really need it. And the
    alternative, not documenting swathes of simple code, often happens too. This is
    no longer a good literate program; you may as well not have bothered.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会记录一些实际上并不需要文档的代码。而另一种情况，即不记录大量简单代码，也经常发生。这已经不再是一个好的文学程序；你甚至可以不费那个功夫。
- en: When *everything* is being written about, you can miss the few important bits
    of documentation in all the noise.
  id: totrans-922
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当**所有内容**都在被记录时，你可能会在所有噪音中错过一些重要的文档。
- en: Knuth talked about *the programmer as essayist*. Many a programmer couldn't
    write an essay to save his life, but he can write the most exquisite code. Maybe
    these guys are exceptions to the rule, but not every good programmer is a capable
    literate programmer.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knuth 讨论了**程序员作为散文家**的观点。许多程序员可能连一篇论文都写不出来，但他们能写出最精致的代码。也许这些人是对规则的例外，但并不是每个优秀的程序员都能成为有能力的文学程序员。
- en: 'Tying documentation intimately to code can be problematic. You may have frozen
    your code for a major release—no changes are allowed—but you still need to work
    on the documentation. Altering the documentation means altering the source code.
    Now you have an executable-release version and a documentation-release version
    of the same codebase that you have to tie together: a management nightmare.'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文档与代码紧密关联可能会出现问题。你可能已经冻结了代码以进行主要发布——不允许有任何更改——但你仍然需要更新文档。修改文档意味着修改源代码。现在你有了同一代码库的可执行版本和文档版本，你必须将它们结合起来：这是一个管理的噩梦。
- en: A later chapter discusses software specifications; how does literate programming
    relate to specifications? A literate program will never replace a functional specification
    describing what work needs to be done. However, it should be possible to develop
    a literate program from such a specification. The literate program really is more
    of a combination of traditional code with a design and implementation specification.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将讨论软件规范；文学编程如何与规范相关？文学程序永远不会取代描述需要完成的工作的功能规范。然而，应该可以从这样的规范中开发出一个文学程序。文学程序实际上更多的是传统代码与设计和实现规范的结合。
- en: Documentation Tools
  id: totrans-926
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档工具
- en: There is a breed of programming tool that sits halfway between the literate
    programming approach and writing external specifications. These tools generate
    documentation from your source code by pulling out blocks of specially formatted
    comments. This technique has become particularly fashionable since Sun introduced
    Javadoc as a core component of the Java platform. All ofthe Java API documentation
    is generated by Javadoc.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种编程工具，它介于文学编程方法和编写外部规范之间。这些工具通过提取特别格式化的注释块来从你的源代码中生成文档。自从 Sun 将 Javadoc 作为
    Java 平台的核心组件引入以来，这种技术变得特别流行。所有的 Java API 文档都是由 Javadoc 生成的。
- en: 'To understand exactly how this works, we''ll look at an example. The exact
    comment formats may differ, but to document a `Widget` class, you''d write something
    like:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确了解其工作原理，我们将通过一个示例来探讨。确切的注释格式可能不同，但为了记录一个 `Widget` 类，你可能需要写一些像这样的内容：
- en: '[PRE17]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The documentation tool will parse each of your project's files, extract the
    documentation, build a cross-referenced database of all the information it finds
    on the way, andspit out a pretty document containing this information.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 文档工具将解析你项目中的每个文件，提取文档，构建一个包含所有信息的交叉引用数据库，并输出一个包含这些信息的漂亮文档。
- en: 'You can document pretty much any code you write: classes, types, functions,
    parameters, flags, variables, namespaces, packages, and so on. There are facilities
    to capture alot of information, including the ability to:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以记录你写的任何代码：类、类型、函数、参数、标志、变量、命名空间、包等等。有设施可以捕获大量信息，包括以下能力：
- en: Specify copyright information
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定版权信息
- en: Document the date of creation
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录创建日期
- en: Cross-reference information
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉引用信息
- en: Mark old code as deprecated
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记旧代码为已弃用
- en: Provide a short synopsis for quick reference
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供简短的摘要以供快速参考
- en: Present a description of each function parameter
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供每个函数参数的描述
- en: There are many documentation tools available, both open source and commercial.
    We've already mentioned Javadoc; other popular tools are C#'s NDoc and the excellent
    Doxygen ([www.doxygen.org](http://www.doxygen.org)).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的文档工具很多，既有开源的也有商业的。我们已经提到了Javadoc；其他流行的工具包括C#的NDoc和优秀的Doxygen ([www.doxygen.org](http://www.doxygen.org))).
- en: This is an excellent approach to documentation, allowing you to document code
    at a sensible level of detail without writing a separate specification. You can
    easily read your documentation in the source files too, which can be very helpful.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种出色的文档方法，允许您在不编写单独规范的情况下，以合理的详细程度记录代码。您还可以轻松地在源文件中阅读文档，这可能会非常有帮助。
- en: 'Documentation tools offer many benefits:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 文档工具提供了许多好处：
- en: Like literate programming, this approach encourages you to write documentation
    and keep it up to date.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文献化编程一样，这种方法鼓励您编写文档并保持其更新。
- en: No separate step is required to get compilable code.
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取可编译的代码不需要单独的步骤。
- en: It's more natural, not requiring massive adjustments or a steep learning curve.
    While the code can be used to generate a document, you don't have to artificially
    make your code look like a book or worry about tedious text layout concerns.
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法更自然，不需要大规模的调整或陡峭的学习曲线。虽然代码可以用来生成文档，但您不需要人为地使代码看起来像一本书，也不必担心繁琐的文本布局问题。
- en: The documentation tools support rich searching, cross-referencing, and code-outlining
    features.
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档工具支持丰富的搜索、交叉引用和代码大纲功能。
- en: 'However, it is important to understand the consequences of comment-based code
    documentation:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解基于注释的代码文档的后果是很重要的：
- en: Unlike literate programming, it's really only useful for API documentation,
    not internal code documentation. You must use regular comments at the statement
    level.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文献化编程不同，它实际上仅适用于API文档，而不是内部代码文档。您必须在语句级别使用常规注释。
- en: It's hard to glance at a source file and get an overview of the contents, since
    they are spaced out by reams of documentation comments. You'd have to use the
    overview output of the tool instead. This may be beautifully formatted, but it's
    inconvenient to view when you're immersed in the world of the code editor.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文档注释的间隔，很难快速浏览源文件并了解其内容概览。您必须使用工具的概览输出。这可能格式得很好，但在您沉浸在代码编辑器世界中时查看可能不方便。
- en: '**KEY CONCEPT**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Use literate documentation tools to automatically generate documentation from
    your code*.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用文献化的文档工具自动从您的代码生成文档*。'
- en: 'Although this is a powerful way to write documentation, you *can* still write
    bad documentation using it. These are some helpful heuristics for getting it right:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种编写文档的强大方式，但您仍然可以使用它编写出糟糕的文档。以下是一些有助于正确编写文档的有用启发式方法：
- en: For each publicly visible item, write a one- or two-sentence description;don't
    go overboard with reams of text. A slew of prose is slow to read and hard to update.
    Don't waffle.
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个公开可见的项目，写上一句或两句描述；不要过度使用大量的文本。一大堆散文读起来很慢，而且难以更新。不要犹豫不决。
- en: Document variables or parameters if it's not clear what they're used for, but
    don't document them if their names make it obvious. You don't need to document
    every last detail if it doesn't add any value. The tool's output will still include
    the item, just with no textual explanation.
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不清楚变量或参数的用途，请对其进行文档说明，但如果它们的名称已经很明显，则无需文档化。如果它们不增加任何价值，您不需要记录每一个细节。工具的输出仍然会包含这些项目，只是没有文本说明。
- en: If some of a function's parameters are used for input and some for output, make
    this clear in their descriptions. Few languages provide a syntactic mechanism
    to express this, so you must document it explicitly.
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数的一些参数用于输入，而另一些用于输出，请在它们的描述中明确这一点。很少有语言提供语法机制来表达这一点，因此您必须明确地记录它。
- en: Document any function pre- or postconditions, what exceptions might be thrown,
    and any of a function's side effects.
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录任何函数的前置条件和后置条件，可能抛出的异常以及函数的任何副作用。
- en: In a Nutshell
  id: totrans-955
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: '*The skill of writing is to create a context in which other people can think*.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*写作的技巧是创造一个其他人在其中可以思考的语境*。'
- en: --Edwin Schlossberg
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: --Edwin Schlossberg
- en: We write code primarily to communicate. Code without documentation is a perilous
    thing, hardly communicative. It is a high-maintenance problem. *Bad* documentation
    is no better, either misleading the reader or resulting in a flimsy program that
    relies on external explanation.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写代码主要是为了沟通。没有文档的代码是危险的，几乎无法沟通。这是一个高维护问题。*差的*文档也好不到哪里去，要么误导读者，要么导致一个依赖外部解释的脆弱程序。
- en: Often the only documentation we have for a piece of code *is* that code itself.
    Making the code self-documenting and clear to read goes some way to remedy this
    situation. Self-documenting code doesn't happen magically, you have to carefully
    think about it. The result is code that looks like it *was* easy to write.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一段代码，我们通常拥有的唯一文档就是代码本身。使代码自我文档化并易于阅读可以在一定程度上解决这个问题。自我文档化的代码并非神奇出现，你必须仔细思考。结果是看起来像很容易编写的代码。
- en: Literate programming is one (quite extreme) method of writing self-documenting
    code. Another less extreme method employs documentation tools. These tools can
    generate API documentation very easily, but they don't necessarily replace all
    written specifications.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 文档化编程是一种（相当极端）编写自我文档化代码的方法。另一种不那么极端的方法是使用文档工具。这些工具可以非常容易地生成API文档，但它们并不一定取代所有书面规范。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员…… | 坏程序员…… |'
- en: '| --- | --- |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Seek to write clear, self-documenting code
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力编写清晰、自我文档化的代码
- en: Try to write the least amount of documentation necessary
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量编写最少的文档
- en: Think about the needs of programmers who will maintain their code
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑那些将维护他们代码的程序员的需求
- en: '|'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Are proud that they write unfathomable spaghetti
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为他们编写难以理解的意大利面代码而感到自豪
- en: Try to avoid writing any documentation
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免编写任何文档
- en: Don't care about updating documentation
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不关心更新文档
- en: Think, "If it was hard for me to write, it should be hard for anyone else to
    understand."
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考，“如果对我来说编写困难，那么对其他人来说也应该难以理解。”
- en: '|'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207456.png.jpg)'
  id: totrans-973
  prefs: []
  type: TYPE_IMG
  zh: '![总结](tagoreillycom20080909nostarchimages207456.png.jpg)'
- en: See Also
  id: totrans-974
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考信息
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。名字的意义是什么？")'
- en: Good names are powerful tools when writing self-documenting code.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 好的命名是编写自我文档化代码的有力工具。
- en: '**A Passing Comment**'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '**随口一提**'
- en: When you do resort to writing comments, this is how to do it correctly.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确实需要编写注释时，这是正确的方式。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: Code should document itself, but we still need separate specifications for many
    reasons.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该自我文档化，但出于许多原因，我们仍然需要单独的规范。
- en: Get Thinking
  id: totrans-981
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 480.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在第480页的"[附录A](apa.html "附录A. 答案和讨论")"部分可以找到对这些问题的详细讨论。
- en: Mull It Over
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: Grouping related code will make its relationships clear. How can we perform
    this grouping? Which methods document the relationships most strongly?
  id: totrans-984
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相关的代码分组可以使它们之间的关系变得清晰。我们如何进行这种分组？哪些方法最能体现这些关系？
- en: We should avoid using *magic numbers* in our code. Is zero a magic number? What
    should you call a constant value representing zero?
  id: totrans-985
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该避免在我们的代码中使用*魔法数字*。零是魔法数字吗？你应该怎么称呼代表零的常量值？
- en: Self-documenting code makes good use of context to convey information. Show
    how you do this, and give an example of how a particular name would lead to a
    different interpretation in different functions?
  id: totrans-986
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自我文档化的代码很好地利用上下文来传达信息。展示你是如何做到这一点的，并给出一个特定名称在不同函数中导致不同解释的例子？
- en: Is it realistic to expect a newcomer to pick up some self-documenting code and
    understand it totally?
  id: totrans-987
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个新手来说，能否完全理解一些自我文档化的代码是现实的吗？
- en: If code is truly self-documenting, how much other documentation is required?
  id: totrans-988
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码确实是自我文档化的，那么还需要多少其他文档？
- en: Why must more people than the original author understand any piece of code?
  id: totrans-989
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么除了原作者之外，更多的人必须理解任何一段代码？
- en: This simple C *bubblesort* function could use some improvement. What specific
    things are wrong with it? Write an improved, self-documenting version.
  id: totrans-990
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个简单的C语言*bubblesort*函数可能需要一些改进。它具体有哪些问题？请写一个改进的、自我文档化的版本。
- en: '[PRE18]'
  id: totrans-991
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Working with code documentation tools brings up some interesting issues. What's
    your opinion on these?
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与代码文档工具一起工作会引发一些有趣的问题。你对这些有什么看法？
- en: When you review the documentation, should you perform a *code review*, looking
    at the comments in the source files, or a *specification review*, looking at the
    generated documents?
  id: totrans-993
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你审查文档时，你应该进行*代码审查*，查看源文件中的注释，还是进行*规范审查*，查看生成的文档？
- en: Where do you put documentation of protocols and other non-API issues?
  id: totrans-994
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将协议和其他非 API 问题的文档放在哪里？
- en: Do you document private/internal functions? In C/C++, where do you place this
    documentation—in the header file or implementation file?
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否文档化了私有/内部函数？在 C/C++ 中，你将这种文档放在头文件还是实现文件中？
- en: In a large system, should you create a single, large API document or several
    smaller documents, one per area? What are the advantages of each approach?
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个大型系统中，你应该创建一个单一的、大的 API 文档，还是创建几个较小的文档，每个区域一个？每种方法的优点是什么？
- en: If you're working on a codebase that isn't literately documented, and you need
    to alter or add new methods or functions, is it a good idea to give them literate
    documentation comments, or should you leave them undocumented?
  id: totrans-997
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在处理一个没有良好文档的代码库，并且需要修改或添加新的方法或函数，提供有文档注释是否是一个好主意，还是应该保持它们未文档化？
- en: Is it possible to write self-documenting assembly code?
  id: totrans-998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能否编写自文档化的汇编代码？
- en: Getting Personal
  id: totrans-999
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: What do you consider to be the best documented code you've come across? What
    made it so?
  id: totrans-1000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为你遇到的最佳文档化的代码是什么？是什么让它如此？
- en: Did this code have a large number of external specifications? How many of them
    did you read? How can you be sure you knew enough about the code without reading
    them all?
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码是否有大量的外部规范？你阅读了多少？你如何确保在不阅读所有内容的情况下对代码有足够的了解？
- en: How much of this do you think was due to the author's programming style, and
    how much was because of any house style or guidelines he or she worked to?
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为其中有多少是由于作者的编程风格造成的，又有多少是由于他或她遵循的任何 house style 或指南？
- en: If you write in more than one language, how does your documentation strategy
    differ in each?
  id: totrans-1003
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用多种语言编写文档，你的文档策略在每种语言中是如何不同的？
- en: In the last code you wrote, how did you make the important stuff stand out?
    Did you hide private information away appropriately?
  id: totrans-1004
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你编写的最后一段代码中，你是如何使重要的内容突出显示的？你是否适当地隐藏了私有信息？
- en: If you're working on a team, how often do others come to you to ask you how
    something works? Could you avoid this with better-documented code?
  id: totrans-1005
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个团队中工作，其他人多久会来问你某个功能是如何工作的？你能通过更好的文档来避免这种情况吗？
- en: Chapter 5. A PASSING COMMENT
  id: totrans-1006
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。一个简单的评论
- en: '*How to Write Code Comments*'
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*如何编写代码注释*'
- en: Comments are free but facts are sacred.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是免费的，但事实是神圣的。
- en: --Charles Prestwich Scott
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: --查尔斯·普雷斯蒂奇·斯科特
- en: Comments are a lot like opinions. You're free to make them, but just because
    you do doesn't mean they're right. In this chapter, we'll spend a little time
    thinking about the details of writing these things. There's a lot more to writing
    comments than you'd think.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 注释很像意见。你可以自由地发表它们，但仅仅因为你发表了，并不意味着它们是正确的。在本章中，我们将花一些时间思考编写这些细节。编写注释比你想象的要复杂得多。
- en: Probably one of the first things you learned when you were taught to program
    was how to write comments. You were told that comments aid the readability of
    code, and you were probably encouraged to write lots of them. But in this game,
    we need to be thinking more about *quality* than *quantity*. Comments are our
    lifelines, memory jogs, and guides through code. We should treat them with the
    respect they deserve.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能在你被教授编程时，你首先学到的是如何编写注释。你被告知注释有助于代码的可读性，你很可能被鼓励写很多注释。但在这个游戏中，我们需要更多地考虑*质量*而不是*数量*。注释是我们的生命线，记忆的提醒，以及代码的指南。我们应该以应有的尊重对待它们。
- en: I set my syntax-highlighting code editor to display comments in green. This
    way, I get an immediate feeling for the quality of a piece of code and how easy
    it's going to be to work with as soon as I load up a source file. A nice proportion
    of green spread through in the right pattern makes me feel good about the world.
    The opposite makes me stroll to the kitchen for a strong coffee before going any
    further.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的语法高亮代码编辑器的注释设置为绿色显示。这样，当我加载源文件时，我就能立即感受到代码的质量以及它将有多容易工作。在正确的模式中散布的绿色比例让我对世界感到满意。相反，我会去厨房喝一杯浓咖啡，然后再继续。
- en: Comments can make the difference between bad code and good code, between a grossly
    complex and unfathomable morass of logic and a nice set of clear algorithms. But
    let's not overstate the case—there are things far more important to get right
    than comments. When you've written truly good code, your comments are the *icing
    on the cake*, delicately placed to add aesthetics and value, rather than liberally
    slapped on to cover up all the cracks and blemishes.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以使代码从糟糕变为优秀，从复杂难懂的逻辑泥潭变成清晰易懂的算法集。但让我们不要过分强调这一点——还有比注释更重要的事情要正确处理。当你真正写出了优秀的代码时，你的注释就像是蛋糕上的糖霜，精致地放置以增添美观和价值，而不是随意涂抹以掩盖所有的裂缝和瑕疵。
- en: Good commenting is a strategy to avoid intimidating code. Comments aren't a
    magic additive to turn sour code sweet.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 好的注释是一种避免让代码令人畏惧的策略。注释不是一种魔法添加剂，可以转变糟糕的代码为甜美的代码。
- en: What Is a Code Comment?
  id: totrans-1015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是代码注释？
- en: Don't skip this section! Admittedly, this is an excruciating place to start.
    We all know what a code comment is, right? But it is more philosophical than you
    might think.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跳过这一节！诚然，这是一个令人痛苦的开端。我们都知道代码注释是什么，对吧？但它的哲学性比你想象的要强。
- en: Syntactically, a comment is a block of source that the compiler will ignore.
    Put what you like in it, the names of your grandchildren or the color of your
    favorite shirt; the compiler won't bat an eye as it merrily parses its way through
    the file.^([[1](#ftn.CHP-5-FN-1)])
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，注释是编译器会忽略的源代码块。你可以放任何你喜欢的进去，比如你孙子的名字或者你最喜欢的衬衫的颜色；编译器在愉快地解析文件时，对此不会眨一下眼。[^1]
- en: Semantically, a comment is the difference between a dingy dirt track and a well-lit
    highway. The comment is an annotation of the code it's situated by. You can use
    it as a highlighter to make a particular problem area stand out or as a documentation
    medium in your header file. You might use comments to describe the shape of an
    algorithm, to aid the maintenance programmer (which could be you later on), or
    to mark the space between each function to help you navigate through a source
    file more quickly.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，注释是泥泞的小径和明亮的公路之间的区别。注释是对其所在代码的注释。你可以用它作为高亮工具，使特定的问题区域突出，或者作为头文件中的文档媒介。你可能使用注释来描述算法的形状，以帮助维护程序员（可能是未来的你），或者标记每个函数之间的空间，帮助你更快地浏览源文件。
- en: Comments are aimed at the human reader, not the computer. In this sense, comments
    are the most human-focused brick in the programming wall. They are ornately molded
    bricks, as opposed to structural breeze blocks. If we want to improve the quality
    of our comments, we need to look at and address what the human really needs as
    he reads code.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 注释的目标是面向人类读者，而不是计算机。在这个意义上，注释是编程墙中最以人为本的砖块。它们是精心塑造的砖块，而不是结构性的轻质砖。如果我们想提高注释的质量，我们需要看看并解决人类在阅读代码时真正需要的东西。
- en: Code comments are not the only documentation that you should put in your code.
    Comments are not specifications. They are not design documents. They are not API
    references.^([[2](#ftn.CHP-5-FN-2)]) However, they are an invaluable form of documentation
    that will always be physically attached to the code (unless someone maliciously
    hits DELETE). Their close proximity means they're more likely to be updated and
    more likely to be read in context. It's an internal documentation mechanism.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释不是你应该放入代码中的唯一文档。注释不是规范。它们不是设计文档。它们不是API参考。[^2] 然而，它们是一种非常有价值的文档形式，始终会物理地附加到代码上（除非有人恶意按下DELETE键）。它们的紧密邻近性意味着它们更有可能被更新，更有可能在上下文中被阅读。这是一个内部文档机制。
- en: As responsible programmers, we have a duty to comment well.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 作为负责任的程序员，我们有责任做好注释。
- en: '* * *'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-5-FN-1)]) Of course, the thing that chews up and spits out the comments
    differs with the kind of language you're using. In C/C++, the monstrous *preprocessor*
    beast devours comments before the compile stage begins. In other languages, the
    compiler itself throws away comments as it tokenizes the source. In interpreted
    languages, your intense commenting may slow down execution, since the interpreter
    has to jump over the names of all your grandchildren.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: ^[[1](#CHP-5-FN-1)]) 当然，处理注释的东西会根据你使用的语言类型而有所不同。在C/C++中，庞大的**预处理器**野兽在编译阶段开始之前吞噬注释。在其他语言中，编译器本身在标记源代码时会丢弃注释。在解释型语言中，你的密集注释可能会减慢执行速度，因为解释器必须跳过你所有孙子的名字。
- en: ^([[2](#CHP-5-FN-2)]) Well, unless you use a literate programming tool, discussed
    in "[Literate Programming](ch04s03.html#literate_programming "Literate Programming")"
    on page 66.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-5-FN-2)]) 嗯，除非你使用一种文献编程工具，这在第66页的"[文献编程](ch04s03.html#literate_programming
    "文献编程")"中讨论过。
- en: What Do Comments Look Like?
  id: totrans-1025
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释看起来是什么样子？
- en: Well, they're green aren't they? At least they are for me.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它们是绿色的，对吧？至少对我来说是这样的。
- en: C comments come in blocks between `/*` and `*/` and can span any number of lines.
    C++, C99, C#, and Java add the single line comment that follows `//`. Other languages
    provide similar *block* and *line* comment facilities, but with different syntaxes.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的注释在`/*`和`*/`之间成块出现，可以跨越任意多行。C++、C99、C#和Java增加了`//`之后的单行注释。其他语言提供了类似的*块*和*行*注释功能，但语法不同。
- en: Again, this is elementary subject matter. But the different comment markers
    are often used in subtly different ways. We'll see examples as we go along. However,
    any commenting scheme that makes cute use of subtle syntax differentiations should
    be viewed warily.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是基础性的主题。但是，不同的注释标记经常以微妙不同的方式使用。我们将随着讨论的进行看到例子。然而，任何巧妙利用微妙语法差异的注释方案都应该谨慎对待。
- en: How Many Comments?
  id: totrans-1029
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要多少注释？
- en: Vigorous writing is concise.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 精力充沛的写作是简洁的。
- en: --William Strunk Jr.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: --威廉·斯特伦克
- en: We need to focus on comment quality, not quantity, so more important than the
    amount of comments we write are the contents of those comments. The next section
    discusses this.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注注释的质量，而不是数量，因此，我们写的注释内容比注释的数量更重要。下一节将讨论这一点。
- en: Student programmers are taught to write comments, and lots of them. But there
    is such a thing as *too much* commenting—you can obscure important sections of
    code in a dense forest of words. Code quality suffers when you have to spend more
    time wading through complex paragraphs of comments than the actual code that you
    need to read.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 学生程序员被教导要写注释，而且要写很多。但是，注释过多确实存在——你可以在密集的文字森林中隐藏重要的代码部分。当你不得不花更多的时间阅读复杂的注释段落而不是实际需要阅读的代码时，代码质量就会受到影响。
- en: I liken this skill to being a good musician. Playing in a band is not about
    how much noise you can make at every conceivable opportunity. The more you play
    your instrument, the more complex the overall sound, and the worse the music.
    Likewise, too many comments muddle the code. A good musician doesn't have to think,
    *When should I stop playing and let someone else have a chance?* A good musician
    only plays when it will really add something. It's about playing the *minimum*
    you can to create the best sound possible. The beauty is in the space. We should
    only be writing comments when they really add something.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这种技能比作成为一名优秀的音乐家。在乐队中演奏不是关于你能在每一个可能的机会制造多少噪音。你演奏乐器越多，整体的声音就越复杂，音乐就越糟糕。同样，过多的注释会使代码变得混乱。优秀的音乐家不需要思考，*我应该何时停止演奏，让其他人有机会？*
    优秀的音乐家只在真正能增加价值的时候演奏。美在于空间。我们只有在真正需要的时候才应该写注释。
- en: '**KEY CONCEPT**'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Learn to write* enough *comments, and no more. Favor quality, not quantity*.'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '*学会写足够的注释，但不要过多。重视质量，而不是数量*。'
- en: The people who will read your comments can also read the code, so try to document
    as much as possible *in the code itself*, rather than in comments. It's what they'll
    believe, anyway—comments have a nasty tendency to lie. Consider your code statements
    the first level of comment, and make them self-documenting.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读你注释的人也能阅读代码，所以尽量在代码本身中尽可能多地记录，而不是在注释中。毕竟——注释有说谎的恶习。考虑你的代码语句是注释的第一层，并使它们自我说明。
- en: Well-written code doesn't actually need comments, because everything should
    be self-explanatory. Function names like `f()` and `g()` scream out for comments
    to describe them, but `someGoodExample()` doesn't ask for a comment at all. You
    can see it's a good example function name.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 编写得好的代码实际上不需要注释，因为一切都应该不言自明。像`f()`和`g()`这样的函数名大声呼唤着需要注释来描述它们，但`someGoodExample()`根本不需要注释。你可以看到它是一个好的示例函数名。
- en: '**KEY CONCEPT**'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Spend your time writing code that doesn''t need to be propped up by tons of
    comments*.'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '*花费你的时间编写不需要大量注释支撑的代码*。'
- en: The fewer comments you write, the less chance you have of writing bad comments.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的注释越少，你写出糟糕注释的机会就越小。
- en: What Goes Inside Our Comments?
  id: totrans-1042
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在注释中放什么？
- en: Of writing well the source and fountainhead is wise thinking.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 写作的高效源泉是明智的思维。
- en: --Horace
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: --贺拉斯
- en: 'Bad comments are worse than no comments at all—they will misinform and mislead
    the reader. So what sort of thing should you write in comments? Here are a few
    basic steps to improve the quality of your comment content:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 坏的注释比没有注释更糟——它们会误导读者。那么，你应该在注释中写些什么呢？以下是一些基本步骤来提高注释内容的质量：
- en: Explain Why, Not How
  id: totrans-1046
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释为什么，而不是如何
- en: This is a key point, so read this paragraph twice. Then eat the page. Your comments
    should not describe *how* the program works. You can see that by reading the code.
    After all, the code is the definitive description of how the code works. And it
    has been written clearly and comprehensibly, hasn't it? You should instead focus
    on describing *why* something is written the way it is or what the next block
    of statements ultimately achieves.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键点，所以请读这段话两遍。然后吃掉这一页。你的注释不应该描述*如何*程序工作。你可以通过阅读代码来看到这一点。毕竟，代码是代码如何工作的最终描述。而且它已经被写得清晰易懂，不是吗？相反，你应该专注于描述*为什么*某物被写成这样，或者下一个代码块最终实现了什么。
- en: Constantly check whether you're writing `/* update WidgetList structure from
    GlbWLRegistry */` or `/* cache widget information for later */`. They might equate
    to the same thing, but the latter conveys the intent of the code, while the former
    just tells you what it's doing.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 不断检查你是否在写`/* 从 GlbWLRegistry 更新 WidgetList 结构 */`或`/* 缓存小部件信息以供以后使用 */`。它们可能等同于同一件事，但后者传达了代码的意图，而前者只是告诉你它在做什么。
- en: As you maintain a section of code, the reason *why* it exists will change less
    often than *how* it achieves that purpose, making this sort of comment's maintenance
    much easier.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 当你维护一段代码时，它存在的原因*为什么*会改变得比*如何*实现这个目的要少，这使得这种注释的维护要容易得多。
- en: '**KEY CONCEPT**'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Good comments explain* why *not* how.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '*好的注释解释的是为什么，而不是如何*。'
- en: You might also use a comment to explain why you have made a particular implementation
    choice. If you have two possible implementation strategies and you decide on one
    over the other, then consider whether it is worth adding a comment explaining
    this rationale.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用注释来解释你为什么做出了特定的实现选择。如果你有两个可能的实现策略，而你决定选择其中一个，那么考虑是否值得添加一个注释来解释这个理由。
- en: Don't Describe the Code
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要描述代码
- en: 'Worthless descriptive comments can be obvious: `++i; // increment i`. They
    can also be more subtle: a lengthy comment description of a complex algorithm,
    followed by the implementation of the algorithm. There is no need to restate code
    laboriously in English unless you''re documenting a really complex algorithm that''s
    impenetrable without it. And then you should probably worry more about rewriting
    the algorithm than the comment.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 无价值的描述性注释可能是明显的：`++i; // increment i`。它们也可能更微妙：一个关于复杂算法的冗长注释，然后是算法的实现。除非你正在记录一个没有它就无法理解的非常复杂的算法，否则没有必要费力地将代码用英语重新表述。那时，你可能更应该担心重写算法而不是注释。
- en: '**KEY CONCEPT**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Honor the golden rule*: One fact—one source. *Don''t duplicate code in a comment*.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '*遵守黄金法则*：一个事实——一个来源。*不要在注释中重复代码*。'
- en: Don't Replace Code
  id: totrans-1057
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要替换代码
- en: If you see a comment stating something that could be enforced by the language
    itself (e.g., `// this variable should only be accessed by class foo`), then look
    to express it in concrete syntax.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一条注释表明某些内容可以通过语言本身强制执行（例如，`// 这个变量应该只由类 foo 访问`），那么考虑用具体语法来表示它。
- en: If you find yourself writing reams of comments to explain how a complex algorithm
    works, stop. First pat yourself on the back for trying to document what's going
    on. But then consider whether you could change the code or the algorithm to make
    it clearer.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己写了很多注释来解释一个复杂算法的工作原理，那就停下来。首先，为自己尝试记录正在发生的事情而鼓掌。但随后考虑是否可以通过更改代码或算法来使其更清晰。
- en: Perhaps you could split the code into several well-named functions to reflect
    the program logic.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许你可以将代码拆分成几个命名良好的函数，以反映程序逻辑。
- en: Don't write comments to describe the use of a variable; rename the variable.
    The comment you were going to write will often tell you what the name of the variable
    should be!
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要写注释来描述变量的用途；重命名变量。你本来要写的注释通常会告诉你变量的名字应该是什么！
- en: If you are documenting a condition that should always hold, perhaps you should
    be writing an assertion.
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在记录一个始终应该成立的条件，也许你应该写一个断言。
- en: Remember that you don't need to prematurely optimize (and thus obfuscate) your
    code.
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，你不需要过早地优化（从而使代码晦涩难懂）。
- en: '**KEY CONCEPT**'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When you find yourself writing dense comments to explain your code, step back.
    Is there a bigger problem to solve?*'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你发现自己正在写密集的注释来解释你的代码时，退一步。有没有更大的问题要解决？*'
- en: Keep It Useful
  id: totrans-1066
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持实用性
- en: 'A good comment usually takes several iterations to move up the quality ladder,
    just like code. Make sure your comments:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 一条好的注释通常需要经过几次迭代才能提升到质量等级，就像代码一样。确保你的注释：
- en: '**Document the unexpected**'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录意外情况**'
- en: If any bits of code are unusual, unexpected, or surprising, document them with
    a comment. You'll thank yourself when you come back later, having forgotten all
    about the problem. If there are specific work-arounds, say for an operating system
    issue, then mention this in a comment.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何代码片段是不寻常的、意外的或令人惊讶的，请用注释记录下来。当你后来回来，忘记了所有关于问题的事情时，你会感谢自己。如果有具体的解决方案，比如针对操作系统的问题，那么在注释中提及这一点。
- en: 'The flip side of this is that you don''t need to document the obvious. Remember:
    *Don''t repeat the code!*'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 这的另一面是，你不需要记录明显的事情。记住：**不要重复代码**！
- en: '**Tell the truth**'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '**说出真相**'
- en: When is a comment not a comment? When it's a lie. Okay, you'll never deliberately
    write lies, but it's easy to accidentally introduce mistruths, especially when
    modifying code that has already been commented. Later code changes can easily
    render a comment inaccurate; "[Working with Comments](ch05s07.html "Working with
    Comments")" on page 84 describes tactics to cope with this.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 当注释不是注释时是什么时候？当它是谎言时。好吧，你永远不会故意写谎言，但很容易无意中引入错误信息，尤其是在修改已经注释过的代码时。后来的代码更改很容易使注释不准确；“[与注释一起工作](ch05s07.html
    "与注释一起工作")”在第84页描述了应对这种情况的策略。
- en: '**Are worthwhile**'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '**有价值**'
- en: Little witty cryptic comments may be witty, and they might be little, but *don't*
    put them in. They get in the way and cause confusion. Avoid expletives, inside
    jokes that only you understand, and comments that are unnecessarily critical—you
    never know where your code will end up in a month or year's time, so don't write
    comments that could cause you embarrassment later.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 一些俏皮而隐晦的注释可能很有趣，而且可能很小，但**不要**把它们放进去。它们会妨碍视线并造成混淆。避免使用粗俗的言语、只有你自己能理解的内部笑话，以及不必要的批评性评论——你永远不知道你的代码在一个月或一年后会在哪里，所以不要写那些可能会让你以后尴尬的注释。
- en: '**Are clear**'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '**清晰**'
- en: Your comment serves to annotate and explain the code. Don't be ambiguous. Be
    as specific as you can (without writing a thesis about each line). If someone
    reads your comment and is left wondering what it means, then you have made the
    code *worse* and slowed down their comprehension.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 你的注释是用来注释和解释代码的。不要含糊其辞。尽可能具体（而不必为每一行写一篇论文）。如果有人阅读你的注释后仍然不知道它的意思，那么你就已经使代码**更糟**并减慢了他们的理解速度。
- en: '**Are comprehensible**'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**可理解**'
- en: You don't need to write complete, grammatically correct English sentences inside
    every comment you write. However, the comment *must* be readable. Cute abbreviations
    of words usually only serve to confuse the reader—especially if English is not
    his or her first language.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在写的每个注释中都写完整的、语法正确的英语句子。然而，注释**必须**是可读的。单词的可爱缩写通常只会让读者感到困惑——尤其是如果英语不是他们的第一语言。
- en: '**KEY CONCEPT**'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Think about what you''re writing in a comment; don''t type without using your
    brain. Read it back again in the context of the code. Does it contain the* right
    *information?*'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '*思考你在注释中写的内容；不要不用大脑就打字。在代码的上下文中再次阅读它。它包含正确的信息吗？*'
- en: '**A WAR STORY**'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个战争故事**'
- en: 'I once did some consulting work for a company that had a mixture of programmers:
    some were native English speakers, some native Greek speakers. The Greeks could
    all speak excellent English, but not one of the English speakers could speak Greek
    (no surprise there).'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经为一家拥有混合程序员的公司做过一些咨询工作：一些是英语母语者，一些是希腊语母语者。希腊人都能说一口流利的英语，但没有任何一个英语母语者能说希腊语（这并不奇怪）。
- en: One of the Greek programmers wrote comments in Greek and, when politely asked,
    refused to change this practice. The English programmers couldn't read these comments
    because they were, quite literally, *all Greek to me*!
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一位希腊程序员用希腊语写注释，当被礼貌地要求改变这种做法时，他拒绝了。英语程序员无法阅读这些注释，因为它们对他来说，字面上就是**全希腊语**！
- en: Avoid Distractions
  id: totrans-1084
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免干扰
- en: 'Comments serve to illuminate the surrounding code, so we must avoid anything
    that distracts from it. Comments should only *add value*. Avoid comments that
    include:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 注释的作用是阐明周围的代码，因此我们必须避免任何分散注意力的东西。注释应该只**增加价值**。避免包含以下内容的注释：
- en: '**The past**'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '**过去**'
- en: We don't need to keep a record of how we *used* to do something. The revision
    control system does that. We don't need to see old code reproduced in comments,
    nor a description of an old algorithm.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要记录我们过去是如何做的。版本控制系统会做这件事。我们不需要在注释中看到旧的代码重现，也不需要看到对旧算法的描述。
- en: '**Code you don''t want**'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**不想要的代码**'
- en: Don't knock out code by enclosing it in comments. It's confusing. Even when
    debugging *commando style* (no pants, no debugger, and no `printf`s), *don't*
    hide code you need to remove in a comment block. Use C's `#ifdef 0` . . . `#endif`
    or some equivalent. These constructs nest and have clearer intent (especially
    important if you forget to come back later and tidy up).
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 不要通过在注释中包围代码来删除代码。这很令人困惑。即使在*指挥官风格*（不穿裤子，没有调试器，没有`printf`）调试时，*也不要*在注释块中隐藏你需要删除的代码。使用C的`#ifdef
    0` ... `#endif`或一些等效的结构。这些结构可以嵌套，并且意图更清晰（特别是如果你忘记回来整理的话）。
- en: '**ASCII art**'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASCII艺术**'
- en: 'Avoid ASCII art pictures or anything else that tries to highlight code in clever
    ways. This, for example, is a bad idea:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用ASCII艺术图片或任何试图以巧妙方式突出代码的东西。例如，这是一个坏主意：
- en: '[PRE19]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It won't make sense in editors with variable width display fonts. Comments are
    not supposed to double maintenance effort!
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有可变宽度显示字体的编辑器中，这不会有意义。注释不应该增加维护工作量！
- en: '**End of blocks**'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '**块结束**'
- en: Some programmers comment the end of every control block, for example putting
    `// end if (a < 1)` after the closing brace of an `if` statement. This is a redundant
    form of comment; it needs to be filtered out before real comprehension can occur.
    The bottom of a block should be visible on the same page as the top, and the code
    layout should make its start and end clear. All extra verbiage should be avoided.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员会在每个控制块的末尾添加注释，例如在`if`语句的闭合括号后放置`// end if (a < 1)`。这是一种多余的注释形式；在真正理解之前需要将其过滤掉。块的底部应该与顶部在同一页上可见，代码布局应该清楚地显示其开始和结束。应避免所有额外的冗词。
- en: In Practice
  id: totrans-1096
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中
- en: The following example illustrates these commenting principles. Consider the
    following snippet of C++ code. Idiomatic criticisms aside, it is not at all clear
    what's going on.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这些注释原则。考虑以下C++代码片段。不考虑惯用语的批评，它根本不清楚发生了什么。
- en: '[PRE20]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Yuck. There''s some room for improvement here, so let''s improve. The code
    can be made less cryptic by applying sensible layout rules and adding a few comments:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 不好。这里有一些改进的空间，所以让我们改进。通过应用合理的布局规则和添加一些注释，可以使代码不那么晦涩：
- en: '[PRE21]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Much better! Now it''s entirely clear what the code snippet is supposed to
    be doing. I''m still not entirely happy, though. With appropriate function and
    variable names, we no longer need any comments at all, since the code describes
    itself:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 更好！现在代码片段的意图完全清晰。尽管如此，我仍然不完全满意。有了适当的功能和变量名，我们不再需要任何注释，因为代码本身就说明了：
- en: '[PRE22]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that I didn't rename `i` to something more long-winded. It's a loop variable
    with a very small scope. Calling it `loopCounter` would have been overkill and
    would arguably have made the code *harder* to read.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有将`i`重命名为更长的名字。它是一个具有非常小作用域的循环变量。将其命名为`loopCounter`可能是过度设计，并且可能会使代码*更难阅读*。
- en: 'It shouldn''t be surprising that we ended up with no comments at all. Remember
    Kernighan and Plaugher''s advice: "Don''t document bad code—rewrite it." (Kernighan
    Plaugher 78)'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终没有注释并不令人惊讶。记住Kernighan和Plaugher的建议：“不要记录糟糕的代码——重写它。”（Kernighan Plaugher
    78）
- en: A Comment on Aesthetics
  id: totrans-1105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于美学的注释
- en: You've no doubt heard people religiously touting about how you should format
    your comments. I'm not going to prescribe the One True Way to format (there is
    no such thing), but there are a few important aspects to consider. Interpret these
    as guidelines, according to your personal taste, rather than as rigid dictates.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 你无疑已经听到过人们虔诚地宣扬如何格式化注释。我不会规定一种真正的格式化方式（没有这样的事情），但有一些重要的方面需要考虑。将这些视为根据你个人品味而不是作为严格规定的指南。
- en: Consistency
  id: totrans-1107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: All commenting should be clear and consistent. Choose a specific way to lay
    out your comments, and use it throughout. Every programmer has a different sense
    of aesthetics, so choose what works for you. *Do* use a house style if one exists,
    or examine (good) existing code and follow the styles you see there.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的注释都应该清晰且一致。选择一种特定的方式来布局你的注释，并在整个文档中使用它。每个程序员对美学的理解都不同，所以选择对你来说合适的方式。*确实*使用现有的风格指南，或者检查（好的）现有的代码，并遵循你看到那里的风格。
- en: Small formatting issues in comment writing may seem trivial—for example, should
    each comment start with a capital letter or not? However, if all your comments
    are randomly capitalized, it conveys a lack of cohesion in the code, as if the
    programmer didn't really think all that carefully when he crafted it.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 注释写作中的小格式问题可能看似微不足道——例如，每个注释是否应该以大写字母开头？然而，如果你的所有注释都是随机大写的，这会传达出代码缺乏连贯性的感觉，就像程序员在构建它时并没有真正仔细思考一样。
- en: Clear Block Comments
  id: totrans-1110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰的块注释
- en: Syntax highlighting editors are great because they help comments to stand out.
    But don't rely on them too much. Your code might be read from a monochrome printout
    or viewed in an editor without syntax coloring. The comment work should still
    be easily readable.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 语法高亮编辑器很棒，因为它们有助于使注释突出。但不要过于依赖它们。你的代码可能来自单色打印件或在没有语法着色的编辑器中查看。注释工作仍然应该易于阅读。
- en: 'A few strategies can help here, especially regarding block comments. Placing
    the start and end markers (e.g., `/*` and `*/` in C and C++) on their own lines
    makes them stand out. Placing a margin character down the left side of a block
    comment also helps to make it appear as a single item:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些策略可以在这里有所帮助，特别是关于块注释。将开始和结束标记（例如，C和C++中的`/*`和`*/`）放在它们自己的行上，使它们更加突出。在块注释的左侧放置一个边距字符也有助于使其看起来像是一个单独的项目：
- en: '[PRE23]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is much better than the alternative:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 这比替代方案要好得多：
- en: '[PRE24]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At the very least, line up the comment text so it's not a jagged mess.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，对齐注释文本，使其不是参差不齐的一团糟。
- en: Indenting Comments
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进注释
- en: 'A comment shouldn''t cut across the code and break up the logical flow. Keep
    it at the same level of indentation as the code around it. That way, the comment
    appears to apply to the correct level of the code. I always have to stare hard
    at code like this:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不应该横穿代码并打断逻辑流程。保持它与周围代码相同的缩进级别。这样，注释看起来就像适用于代码的正确级别。我总是不得不仔细地看这样的代码：
- en: '[PRE25]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In a loop without braces (which isn't a good idea anyway), *don't* put a comment
    before the single loop body statement—this can lead to all sorts of distaster.
    If you want a comment in there, wrap up the whole thing in braces. It's a far
    safer strategy.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有花括号的循环中（这本身就不是个好主意），*不要*在单个循环体语句之前放置注释——这可能导致各种灾难。如果你想在其中添加注释，请将整个内容用花括号括起来。这是一个更安全的策略。
- en: End-of-Line Comments
  id: totrans-1121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行尾注释
- en: 'Most comments are written on lines of their own, but sometimes a short single
    line comment can *follow* a code statement. In this case, it''s good practice
    to space out the comment to mark it as clearly apart from the code. For example:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数注释都是单独成行的，但有时一个简短的单一行注释可以*跟随*一个代码语句。在这种情况下，将注释间隔开来，清楚地将其与代码区分开来是一个好的做法。例如：
- en: '[PRE26]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is a good example of using comment layout to improve the appearance of
    your code. If each end-of-line comment came directly after the variable declaration,
    they'd look jagged, messy, and require more squinting to read.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用注释布局来改善代码外观的好例子。如果每行末尾的注释直接跟在变量声明之后，它们看起来会参差不齐、杂乱无章，需要更仔细地阅读。
- en: Helping You to Read the Code
  id: totrans-1125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助你阅读代码
- en: Comments are usually written *above* the code that they describe, not below
    it. This way, the source code reads downward, almost like a book. The comment
    serves to prepare the reader for what is to come.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 注释通常写在与它们描述的代码*上方*，而不是下方。这样，源代码就像一本书一样向下阅读。注释的作用是为读者准备即将到来的内容。
- en: Used with whitespace, commenting helps to break the code up into "paragraphs."
    A comment introduces a few lines, explaining what they intend to achieve; the
    code immediately follows, then a blank line, then the next block. This is such
    a convention that a comment with a blank line before it feels like a paragraph
    start, whereas a comment sandwiched in the middle of two code lines feels more
    like a statement in brackets or a footnote.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空白字符，注释有助于将代码分成“段落”。注释引入几行，解释它们打算实现的内容；然后是代码，接着是一个空行，然后是下一个块。这是一个如此常见的约定，以至于在注释之前有一个空行的注释感觉像是一个段落的开始，而夹在两个代码行之间的注释则更像是一个括号中的语句或脚注。
- en: '**KEY CONCEPT**'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Comments are part of the code narrative. Use them in a way that reads naturally*.'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释是代码叙述的一部分。以自然的方式使用它们*。'
- en: Choose a Low-Maintenance Style
  id: totrans-1130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一种低维护性风格
- en: It's sensible to choose a low-maintenance comment style, or you'll waste time
    fiddling with comments when you should be writing code.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一种低维护性的注释风格是明智的，否则你会在应该编写代码的时候浪费时间调整注释。
- en: 'Some C coders create comment blocks with a column of asterisks in the left
    margin *and* a column of asterisks as a right margin. Arguably this looks very
    pretty, but the amount of work required to adjust a paragraph of text within such
    margins is immense. When you could have moved on to the next task at hand, you
    have to manually realign all the asterisks on the right. If the programmer used
    tabs, then things get even nastier: If someone with a different-sized tab stop
    opens the file, he or she will wonder what the original programmer was up to—all
    the asterisks will look incredibly ugly and badly lined up.'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C语言程序员在左边缘创建带有星号列的注释块*和*右边缘带有星号的列。可以说这看起来非常漂亮，但调整这种边距内的段落文本所需的工作量是巨大的。当你本可以继续处理下一个任务时，你必须手动重新对齐右侧的所有星号。如果程序员使用了制表符，那么事情变得更糟：如果有人使用不同大小的制表符打开文件，他会想知道原始程序员在做什么——所有的星号看起来都非常丑陋且排列不当。
- en: The end-of-line comments we saw above are an example of alignment that requires
    some effort. How much work you're prepared to spend is up to you. There is always
    a balance between good-looking source code and maintenance effort. I suppose I
    prefer a little bit of effort to ugly code.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的行尾注释是一个需要一些努力的对齐示例。你愿意投入多少工作量取决于你。在美观的源代码和维护工作量之间总是有一个平衡。我想我更倾向于一点努力而不是丑陋的代码。
- en: Breakwaters
  id: totrans-1134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防波堤
- en: 'Comments are often used as *breakwaters* between sections of code. This is
    where people''s artistic sensibilities take over; programmers use different schemes
    to differentiate major comments (*this is a new section of code*) from minor comments
    (*this describes a few of lines of a function*). A source file implementing several
    classes may have something like this between each major section:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 注释通常被用作代码各部分之间的*防波堤*。这就是人们艺术感发挥作用的时刻；程序员使用不同的方案来区分主要注释（*这是代码的新部分*）和次要注释（*这描述了函数的几行代码*）。实现多个类的源文件可能在每个主要部分之间有类似的内容：
- en: '[PRE27]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some programmers insert large blocks of comment art between each function. Some
    use a long, single-line comment as a rule-off. I just place a couple of blank
    lines between functions. If your functions are so large that you need visual clues
    to see where they start and end, then you need to revise your code.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员在函数之间插入大块的注释艺术。有些人使用长单行注释作为规则。我只是在每个函数之间放置几行空白。如果你的函数非常大，以至于你需要视觉线索来看到它们的开始和结束，那么你需要修改你的代码。
- en: Avoid using these large rules to emphasize every comment in sight. Otherwise,
    nothing gets emphasized. Good indentation and structure, not impressive ASCII
    art, should group code together.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用这些大规则来强调每个可见的注释。否则，就没有什么会被强调。良好的缩进和结构，而不是令人印象深刻的ASCII艺术，应该将代码分组在一起。
- en: All that being said, well-chosen breakwater comments can help you to quickly
    navigate around a file.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，精心挑选的防波堤注释可以帮助你快速在文件中导航。
- en: Flags
  id: totrans-1140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志
- en: Comments can also be used as inline *flags* in the code. There are a number
    of common conventions. You'll see `//XXX`, `//FIXME`, or `//TODO` littered though
    files that are still works in progress. Good syntax-highlighting editors display
    these comments prominently by default. `XXX` is used to mark troublesome code
    or something that needs to be reworked. `TODO` often marks missing pieces of functionality
    for a later return.^([[3](#ftn.CHP-5-FN-3)]) `FIXME` indicates something that's
    known to be broken.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也可以用作代码中的内联*标志*。存在许多常见的约定。你会在仍在进行中的文件中看到`//XXX`、`//FIXME`或`//TODO`散布其中。好的语法高亮编辑器默认会突出显示这些注释。`XXX`用于标记有问题的代码或需要重工作的内容。`TODO`通常标记了以后返回的功能缺失部分.^([[3](#ftn.CHP-5-FN-3)])
    `FIXME`表示已知有问题的内容。
- en: File Header Comments
  id: totrans-1142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件头部注释
- en: Every source file should begin with a comment block that describes its contents.
    This is just a quick overview, a preface, providing some essential information
    that you always want displayed as soon as a file is opened. If such a header exists,
    then any programmer who opens the file will have confidence in the contents; it
    shows the file was thoughtfully created rather than just hacked up as a dumping
    ground for some new code.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个源文件都应该以一个描述其内容的注释块开始。这只是一个快速概述，一个前言，提供一些你总是希望一打开文件就显示的基本信息。如果存在这样的标题，那么任何打开文件的程序员都会对内容有信心；它表明文件是经过深思熟虑创建的，而不是仅仅作为一个新代码的垃圾场。
- en: '**KEY CONCEPT**'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Give every source file a comment prologue*.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '*为每个源文件提供一个注释序言*。'
- en: Some people advocate that this header should provide a list of every function,
    class, global variable, and so on that is defined in the file. This is a maintenance
    disaster; such a comment would rapidly become out of date. The kind of information
    this file header *should* contain is the purpose of the file (e.g., *implementation
    of foo interface*) and a copyright statement describing ownership and copying
    rights.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人主张这个标题应该提供一个列表，列出文件中定义的每个函数、类、全局变量等等。这是一个维护灾难；这样的注释会迅速过时。这个文件标题**应该**包含的信息是文件的目的（例如，*实现foo接口*）和一个描述所有权和复制权利的版权声明。
- en: If a source file is automatically generated during the build process, then you
    must arrange for this file to receive a comment header that states very clearly
    (in BIG SCARY CAPITAL LETTERS) where it originated. This will prevent someone
    from mistakenly editing it, only to have the contents regenerated at the next
    build.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建过程中自动生成了源文件，那么你必须安排这个文件接收一个注释标题，清楚地（用大写字母）说明它的来源。这将防止有人错误地编辑它，结果在下次构建时内容被重新生成。
- en: The header should *not* contain information that could easily become out of
    date, like the author(s), modifiers, or the date the file was last modified. This
    probably wouldn't be updated often, and would become misleading. Version control
    tells you this anyway. It also needn't contain a source file history describing
    every modification ever made. That information exists in your source control system
    and doesn't need to be duplicated here. Moreover, if you have to scroll through
    10 pages of modification history to get to the first line of code, then the file
    becomes tedious to work with. For this reason, some programmers put it at the
    end of the file instead, but this will still make the file unreasonably large,
    slow to load, and bothersome to work with.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 标题**不应**包含容易过时的信息，如作者、修改者或文件最后修改的日期。这可能不会经常更新，并且会误导。版本控制会告诉你这些信息。它也不需要包含描述所有修改的源文件历史。这些信息存在于你的源控制系统中，不需要在这里重复。此外，如果你必须滚动10页的修改历史才能到达代码的第一行，那么文件就会变得难以工作。因此，一些程序员将其放在文件末尾，但这仍然会使文件变得不合理地大，加载缓慢，并且难以工作。
- en: '**A WELL-PLACED COMMENT**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**恰当的注释**'
- en: 'We''re focusing on *code* comments in this chapter, what we actually type into
    source code. But different breeds of comment graze in neighboring pastures:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中关注的是**代码注释**，我们实际上在源代码中输入的内容。但不同类型的注释在邻近的牧场中觅食：
- en: '**Check in/out comments**'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**签入/签出注释**'
- en: Your revision control system maintains a history of how each file was modified
    over the life of the project. It associates *metadata* with each revision—at the
    very least, programmer-supplied *check-in comments*. It may also record *checkout
    comments* if it keeps tabs on which files are currently in use. You use these
    comments to describe what you are changing, as a record for posterity.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的版本控制系统维护着项目生命周期中每个文件的修改历史。它将**元数据**与每个版本关联——至少是程序员提供的**提交注释**。如果它跟踪当前正在使用的文件，它也可能记录**签出注释**。你使用这些注释来描述你正在更改的内容，作为对后世的记录。
- en: 'Such comments are invaluable, and should be created carefully. They should
    be:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的注释非常有价值，应该仔细创建。它们应该是：
- en: Short (so you can quickly browse a log of all modifications)
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短的（这样你可以快速浏览所有修改的日志）
- en: Accurate (don't get information wrong, or the history is worthless)
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确的（不要弄错信息，否则历史就毫无价值）
- en: Complete (so you can see all that has happened in a file without manually *diffing*
    revisions)
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的（这样你可以在不手动**diff**版本的情况下看到文件中发生的一切）
- en: Document *what* has changed and *why*, not *how* it has changed. You can use
    the file revision differences to work out how you modified the code.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 记录**更改了什么**和**为什么**，而不是**如何**更改。你可以使用文件修订差异来找出你如何修改了代码。
- en: 'This is where comments about the past belong. It''s also the right place for
    bugtracking references. Don''t be tempted to put information that belongs here
    into source code comments. Remember: *One fact—one source*.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于过去的注释应该放的地方。这也是放置错误跟踪引用的正确位置。不要诱惑将属于这里的资料放入源代码注释中。记住：*一个事实——一个来源*。
- en: '**README files**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**README文件**'
- en: These are plaintext files that live in the directories alongside source code
    files. They are useful documentation, falling somewhere between formal specifications
    and code comments. They often contain practical information, perhaps on what each
    file does or on the structure of the file hierarchy; they are basically short
    notes.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是存在于源代码文件旁边的目录中的纯文本文件。它们是有用的文档，介于正式规范和代码注释之间。它们通常包含实用信息，可能是关于每个文件做什么，或者关于文件层次结构的结构；它们基本上是简短的笔记。
- en: READMEs tend to be either haphazard and poorly thought out or badly maintained
    and out of date—which is a shame. When you come across a README file, you naturally
    load it up to see what helpful information it contains. The presence of a README
    shows someone was thinking when they collected the source files together; there
    was something worth documenting and something worthwhile to say about it.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: README文件往往要么是杂乱无章且思考不周，要么是维护不善且过时——这真是个遗憾。当你遇到一个README文件时，你自然会打开它，看看它包含哪些有用的信息。README的存在表明有人在收集源文件时思考过；有一些值得记录的东西，有一些值得说的东西。
- en: '* * *'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-5-FN-3)]) Be careful with `TODO` comments. You might be better off
    throwing a `TODO` exception instead, which cannot be missed. That way, if you
    forget to implement the missing code, your program will fail in a well-defined
    way.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-5-FN-3)]) 在使用`TODO`注释时要小心。你可能更愿意抛出一个`TODO`异常，这样就不会被忽略。这样，如果你忘记实现缺失的代码，你的程序将以定义良好的方式失败。
- en: Working with Comments
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与注释一起工作
- en: Comments are convenient tools to use while you are writing code. But be careful
    not to abuse them.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是在编写代码时使用的方便工具。但要注意不要滥用它们。
- en: Helping You to Write Routines
  id: totrans-1166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助你编写程序
- en: A common routine-writing approach is to fashion its structure in comments first
    and then fill in the code underneath each comment line. If you work this way,
    you should ask yourself, once finished, whether the remaining comments are still
    useful. Evaluate them against the criteria just discussed, and revise or remove
    them if necessary. Don't just leave them and move on.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的编写常规方法是在注释中首先构建其结构，然后填充每个注释行下面的代码。如果你这样工作，完成之后，你应该问问自己，剩余的注释是否仍然有用。根据刚才讨论的标准进行评估，并在必要时进行修改或删除。不要只是留下它们就继续前进。
- en: The alternative is to write the new routine freehand, and then add any necessary
    comments afterward. The danger is that you'll forget to finish the job, or that
    you might not write the best comments—now knowing almost too well how the code
    works. The experienced programmer comments *as he goes along*. Practice shows
    you the right amount of commenting to use.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是手写编写新的常规程序，然后添加任何必要的注释。危险在于你可能会忘记完成这项工作，或者你可能不会写出最好的注释——现在几乎太清楚代码是如何工作的了。经验丰富的程序员会边走边注释。实践表明，你应该使用多少注释。
- en: Don't be afraid of using the flags we saw earlier, like `TODO`, as markers to
    yourself. It will avoid the embarrassment of forgetting to tie up pesky little
    loose ends. You can easily search your entire codebase for these comments to find
    out what still needs to be completed.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕使用我们之前看到的标志，如`TODO`，作为给自己标记的标记。这将避免忘记解决那些讨厌的小尾巴的尴尬。你可以轻松地在整个代码库中搜索这些注释，以找出还需要完成什么。
- en: Bug-Fix Notices
  id: totrans-1170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误修复通知
- en: 'A common, but questionable, comment practice is placing notices where faults
    have been fixed. You may stumble over a comment like this in the middle of a function:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见但值得怀疑的注释实践是在修复错误的地方放置通知。你可能会在函数中间遇到这样的注释：
- en: '[PRE28]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although written with the best intentions (to help you see what's happened in
    the course of development), these comments often do more harm than good. To understand
    the real problem, you'd have to look up the fault in your fault-tracking system
    and pull out the previous revision of the file to investigate what changed. Few
    bug fixes require that kind of reading, so the newcomer can probably live in blissful
    ignorance. These comments proliferate in the later stages of development and during
    maintenance and litter the source code with sidelines, stale information, and
    distractions from the main thread of execution.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些注释的初衷是好的（帮助你了解开发过程中的变化），但它们往往弊大于利。要理解真正的问题，你不得不在你的错误跟踪系统中查找故障，并提取文件的上一版本来调查发生了什么变化。很少的错误修复需要这种阅读，所以新来者可能可以生活在无忧无虑的无知中。这些注释在开发的后期阶段和维护期间大量出现，并在源代码中散布旁白、过时信息和执行主线的干扰。
- en: There *is* an argument for inserting a comment when you make a non-obvious fix—to
    prevent someone who is revising the code later from reintroducing the bug. However,
    in these well-chosen cases, you are actually *documenting the unexpected* rather
    than placing a bug-fix notice.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行一个非显而易见的修复时，插入一个注释是有道理的——以防止后来修订代码的人重新引入错误。然而，在这些精心挑选的案例中，你实际上是在**记录意外**而不是放置一个错误修复通知。
- en: '**KEY CONCEPT**'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Comments should live in the* present, *not the past. Don''t describe things
    that have changed, or tell what something used to do*.'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释应该活在**现在**，而不是**过去**。不要描述已经改变的事情，或者告诉某物曾经做过什么*。'
- en: Comment Rot
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释腐烂
- en: Comments rot. Well, all carelessly maintained code tends to rot, acquiring unsightly
    blemishes and losing the original neat design. However, comments seem to rot much
    more quickly than any other piece of code. They become out of date with the code
    they describe. This can be profoundly annoying.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 注释会腐烂。好吧，所有粗心维护的代码都会腐烂，获得丑陋的瑕疵，并失去原始的整洁设计。然而，注释似乎比任何其他代码腐烂得更快。它们与它们描述的代码脱节。这可能会非常令人烦恼。
- en: '**A WAR STORY**'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个战争故事**'
- en: I once worked on a section of code containing the comment *Features A and B
    not yet implemented*. I needed both these facilities, so I wrote them. Only after
    having done so did I discover that feature B *had* already been implemented—I
    had just wasted effort—and feature A was redundant, since the implementation of
    B handled it as well. If the programmer who did this had removed the incorrect
    comment, I would have been spared a *lot* of work.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经处理过一个包含注释“功能A和B尚未实现”的代码段。我需要这两个功能，所以我创建了它们。只有在完成之后，我才意识到功能B**已经**实现了——我白费了力气——而且功能A是多余的，因为B的实现已经处理了它。如果做这个的程序员移除了错误的注释，我就不会浪费那么多工作了。
- en: 'The simple solution is this: When you fix, add, or modify any code, fix, add,
    or modify any comments around it. Don''t just fiddle with a couple of lines and
    move on. Make sure that any code changes don''t turn comments into lies. The corollary
    is: We must make comments easy to keep up to date, or they won''t be updated.
    Comments must be clearly related to their section of code, not placed in obscure
    locations.'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是这样的：当你修复、添加或修改任何代码时，修复、添加或修改其周围的任何注释。不要只是摆弄几行代码然后继续。确保任何代码更改都不会使注释变成谎言。相应的，我们必须使注释易于更新，否则它们就不会被更新。注释必须与它们的代码部分清晰相关，不要放在晦涩难懂的位置。
- en: '**KEY CONCEPT**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When you alter code, maintain any comments around it*.'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你修改代码时，保持其周围的注释不变*。'
- en: Another bad habit is leaving blocks of code commented out. This will confuse
    you when you come back in a year's time, or when any other programmer stumbles
    across them. If you encounter some code in a comment block, you'll wonder why
    it's there. Was it a fix that was never completed? Is it still a work in progress?
    Did that code never work? Is the rest of the code functionally complete?
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个坏习惯是留下注释掉的代码块。当你一年后回来，或者当任何其他程序员偶然发现它们时，这会令你困惑。如果你遇到一个注释块中的代码，你会想知道为什么它在那里。这是一个从未完成的修复吗？它仍然是一个正在进行的工作吗？这段代码从未工作过吗？其余的代码功能是否完整？
- en: Either leave a note explaining why you have commented the code out or remove
    it completely—you can always get it back from the source control system. Even
    if you think you're only knocking something out temporarily, leave yourself a
    note; you may forget to finish it off.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 要么留下一个说明你为什么注释掉代码的便条，要么完全删除它——你总是可以从源代码控制系统中恢复它。即使你认为你只是暂时移除了一些代码，也给自己留个便条；你可能会忘记完成它。
- en: Maintenance and the Inane Comment
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护和无用注释
- en: As you wade though an old codebase, it's best not to remove any inane comments
    you find unless they are downright dangerous. Leave them as a warning for future
    maintenance programmers—they give a useful insight into the (lack of) quality
    of the surrounding code. Of course, if you're actually trying to improve that
    piece of code, then do rework the comments as you go! If you find a comment that
    *is* factually wrong or misleading, then you should rewrite it as a part of your
    maintenance of the code.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览一个旧代码库时，最好不要删除你发现的任何无用注释，除非它们是直接危险的。把它们留作未来维护程序员的警告——它们提供了对周围代码（缺乏）质量的宝贵见解。当然，如果你实际上正在尝试改进那块代码，那么在改进过程中就重新编写注释！如果你发现一个**确实**是事实错误或误导性的注释，那么你应该在维护代码的过程中重新编写它。
- en: Learn the interesting area flags like `XXX`, and treat them with respect and
    caution. Also watch for output statements that have been commented out. These
    are a sure sign that there has been a problem area here in the past—treat the
    code with care!
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 学习有趣的区域标志，如`XXX`，并以尊重和谨慎的态度对待它们。同时注意那些被注释掉的输出语句。这些都是过去这里存在问题的明确迹象——要小心处理代码！
- en: Be aware of comment rot. Just because a comment says *this is defined in foo.c*
    doesn't mean that it is anymore. Always have faith in code and doubt comments.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意注释腐烂。仅仅因为注释说“这定义在foo.c中”并不意味着它现在是这样。始终相信代码，怀疑注释。
- en: In a Nutshell
  id: totrans-1190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: In a Nutshell
- en: Major writing is to say what has been seen, so that it need never be said again.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 主要写作是说已经看到的东西，这样它就永远不需要再说了。
- en: --Delmore Schwartz
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: --Delmore Schwartz
- en: We write a lot of comments. That's because we write a lot of code. Learning
    to write the right sort of comment is important, or our code may keel over under
    the weight of inappropriate and outdated commenting.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写了很多注释。那是因为我们写了大量的代码。学会写正确的注释类型非常重要，否则我们的代码可能会因为不适当和过时的注释而变得难以维护。
- en: Comments are no more important than the code they annotate—you can't make bad
    code good using comments. Your aim should be self-documenting code that requires
    no comments at all.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 注释的重要性不亚于它们所注释的代码——你不能通过注释使糟糕的代码变得好。你的目标应该是无需注释的自文档化代码。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-1195
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员…… | 坏程序员…… |'
- en: '| --- | --- |'
  id: totrans-1196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Try to write a *few* really good comments
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量写一些真正优秀的注释
- en: Write comments explaining *why*
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出解释*为什么*的注释
- en: Concentrate on writing good code rather than a plethora of comments
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于编写好的代码，而不是大量注释
- en: Write helpful comments that make sense
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出有意义的、合理的注释
- en: '|'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Can't tell the difference between good and bad comments
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法区分好注释和坏注释
- en: Write comments explaining *how*
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写出解释*如何*的注释
- en: Don't mind if comments only make sense to themselves
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果注释只对自己有意义，那就没关系
- en: Bolster bad code with many comments
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用许多注释来加强糟糕的代码
- en: Fill their source files with redundant information (revision history, etc.)
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源文件中填充冗余信息（修订历史等）
- en: '|'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207458.png.jpg)'
  id: totrans-1209
  prefs: []
  type: TYPE_IMG
  zh: '![In a Nutshell](tagoreillycom20080909nostarchimages207458.png.jpg)'
- en: See Also
  id: totrans-1210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. 最佳计划")'
- en: Code layout and presentation schemes will affect how you lay out your comments.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码布局和展示方案将影响你如何布局你的注释。
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 名称的含义")'
- en: 'Another aspect of self-commenting code: choosing good names.'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 自我注释代码的另一个方面：选择好的名称。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 写作技巧")'
- en: Discusses *self-documenting code*, a tactic that makes heavy commenting redundant.
    Also describes *literate programming* techniques.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了*自文档化代码*，这是一种使大量注释变得不必要的策略。还描述了*文学编程*技术。
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章. 实践安全源代码")'
- en: Revision control systems hold file history so you don't need to explain it in
    comments.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统保存文件历史，因此你不需要在注释中解释它。
- en: Get Thinking
  id: totrans-1219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 485.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第485页的"[附录A](apa.html "附录A. 答案和讨论")"部分可以找到对以下问题的详细讨论。
- en: Mull It Over
  id: totrans-1221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考
- en: 'How might the *need for* and the *content of* comments differ in the following
    types of code:'
  id: totrans-1222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下类型的代码中，注释的*需要*和*内容*可能会有何不同：
- en: Low-level assembly language (machine code)
  id: totrans-1223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器语言（低级汇编语言）
- en: Shell scripts
  id: totrans-1224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shell脚本
- en: A single-file test harness
  id: totrans-1225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单文件测试框架
- en: A large C/C++ project
  id: totrans-1226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型C/C++项目
- en: You can run tools to calculate what percentage of your source code lines are
    comments. How useful are these tools? How accurate a measure is this of comment
    quality?
  id: totrans-1227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以运行工具来计算你的源代码行中有多少是注释。这些工具有多有用？这种对注释质量的衡量有多准确？
- en: 'If you come across some incomprehensible code, which is the better way to factor
    in some intelligibility: adding comments to document what you think is going on,
    or renaming variables/functions/types with more descriptive names? Which approach
    will most likely be easier? Which approach will be safer?'
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到一些难以理解的代码，哪种方法更好地增加可读性：添加注释来记录你认为正在发生的事情，还是用更具描述性的名称重命名变量/函数/类型？哪种方法最有可能更容易？哪种方法更安全？
- en: When you document a C/C++ API with a code comment block, should it go in the
    public header file that declares the function or the source file containing the
    implementation? What are the pros and cons of each location?
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你用代码注释块记录C/C++ API时，它应该放在声明函数的公共头文件中，还是放在包含实现的源文件中？每个位置的优缺点是什么？
- en: Getting Personal
  id: totrans-1230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: Look carefully at the source files you've recently worked on. Inspect your commenting.
    Is it honestly any good? (I bet as you read through the code you'll find yourself
    making a few changes!)
  id: totrans-1231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细看看你最近工作的源文件。检查你的注释。它真的好吗？（我打赌当你阅读代码时，你会发现自己做了一些修改！）
- en: How do you ensure that your comments are genuinely valuable and not just personal
    ramblings that only you can understand?
  id: totrans-1232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保你的注释真正有价值，而不仅仅是只有你自己能理解的个人杂谈？
- en: Do the people you work with all comment to the same standard, in about the same
    way?
  id: totrans-1233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你合作的人是否都按照相同的标准，以大约相同的方式进行注释？
- en: Who's the best at writing comments? Why do you think that? Who's the worst?
    How much of a correlation does this bear to these individuals' general quality
    of coding?
  id: totrans-1234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁最擅长写注释？你为什么这么认为？谁最差？这与这些个人的一般编码质量有多少相关性？
- en: Do you think any imposed coding standards could raise the quality of the comments
    written by your team?
  id: totrans-1235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为任何强加的编码标准能提高你团队编写的注释质量吗？
- en: 'Do you include history logging information in each source file? If yes:'
  id: totrans-1236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否在每个源文件中包含历史记录信息？如果是的话：
- en: Do you do maintain it manually? Why, if your revision control system will insert
    this for you automatically? Is the history kept particularly accurate?
  id: totrans-1237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否手动维护它？为什么，如果你的版本控制系统会自动为你插入这些信息？历史记录是否保持得特别准确？
- en: Is this *really* a sensible practice? How often is this information needed?
    Why is it better if placed in the source file than in another, separate mechanism?
  id: totrans-1238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这*真的*是一种明智的做法吗？这种信息需要多频繁？为什么将它放在源文件中比放在另一个单独的机制中更好？
- en: Do you add your initials to or otherwise mark the comments you make in other
    people's code? Do you ever date comments? When and why do you do this—is it a
    useful practice? Has it ever been useful to find someone else's initials and timestamping?
  id: totrans-1239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否在其他人代码中添加你的首字母或以其他方式标记你做出的注释？你是否给注释加日期？你什么时候以及为什么这么做——这是否是一种有用的做法？有人找到别人的首字母和日期标记是否曾经有用过？
- en: Chapter 6. TO ERR IS HUMAN
  id: totrans-1240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 TO ERR IS HUMAN
- en: '*Dealing with the Inevitable— Error Conditions in Code*'
  id: totrans-1241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*处理不可避免的事情——代码中的错误条件*'
- en: We know that the only way to avoid error is to detect it, that the only way
    to detect it is to be free to enquire.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，避免错误的唯一方法是检测它，而检测它的唯一方法是能够自由地询问。
- en: --J. Robert Oppenheimer
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: --J. Robert Oppenheimer
- en: 'At some point in life, everyone has this epiphany: *The world doesn''t work
    as you expect it to*. My one-year-old friend Tom learned this when climbing a
    chair four times his size. He expected to get to the top. The actual result surprised
    him: He ended up under a pile of furniture.'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在生活的某个时刻，每个人都会有这样的顿悟：*世界不会像你期望的那样运作*。我的一个一岁的朋友汤姆在爬一个四倍于他身高的椅子时学到了这一点。他期望能到达顶部。实际的结果让他惊讶：他最终掉进了一堆家具下面。
- en: 'Is the world broken? Is it wrong? No. The world has plodded happily along its
    way for the last few million years and looks set to continue for the foreseeable
    future. It''s *our expectations* that are wrong and need to be adjusted. As they
    say: *Bad things happen, so deal with it*. We must write code that deals with
    the Real World and its unexpected ways.'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 世界是破碎的吗？它是错误的吗？不。在过去几百万年中，世界一直在快乐地沿着自己的道路前进，并且看起来在可预见的未来将继续如此。是*我们的期望*是错误的，需要调整。正如他们所说：*坏事会发生，所以处理它*。我们必须编写处理真实世界及其意外方式的代码。
- en: This is particularly difficult because the world *mostly* works as we'd expect
    it to, constantly lulling us into a false sense of security. The human brain is
    wired to cope, with built-in fail-safes. If someone bricks up your front door,
    your brain will process the problem, and you'll stop before walking into an unexpected
    wall. But programs are not so clever; we have to tell them where the brick walls
    are and what to do when they hit one.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其困难，因为世界*大部分*像我们期望的那样运作，不断地让我们陷入一种虚假的安全感。人类的大脑被设计来应对，有内置的安全措施。如果有人堵住了你的前门，你的大脑会处理这个问题，你会在撞上意外的墙之前停下来。但是程序并不那么聪明；我们必须告诉它们哪里有砖墙，以及它们撞上时应该做什么。
- en: 'Don''t presume that everything in your program will always run smoothly. The
    world doesn''t always work as you''d expect it to: You *must* handle all possible
    error conditions in your code. It sounds simple enough, but that statement leads
    to a world of pain.'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 不要假设你的程序中的所有内容都会一直顺利运行。世界并不总是按照你预期的那样运作：你必须处理代码中所有可能出现的错误条件。这听起来很简单，但这个陈述会导致无尽的痛苦。
- en: From Whence It Came
  id: totrans-1248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它从何而来
- en: To expect the unexpected shows a thoroughly modern intellect.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 预期意外的事情，显示出一种彻底的现代智慧。
- en: --Oscar Wilde
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: --奥斯卡·王尔德
- en: Errors can and will occur. Undersirable results can arise from almost any operation.
    They are distinct from bugs in a faulty program because you *know* beforehand
    that an error can occur. For example, the database file you want to open might
    have been deleted, a disk could fill up at any time and your next save operation
    might fail, or the web service you're accessing might not currently be available.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生，并且将会发生。几乎所有操作都可能产生不良结果。它们与有缺陷程序中的bug不同，因为你在事先就知道错误可能会发生。例如，你想要打开的数据库文件可能已经被删除，磁盘可能随时会满，你的下一次保存操作可能会失败，或者你正在访问的Web服务可能目前不可用。
- en: If you don't write code to handle these error conditions, you will almost certainly
    end up with a *bug*; your program will not always work as you intend it to. But
    if the error happens only rarely, it will probably be a very subtle bug! We'll
    look at bugs in [Chapter 9](ch09.html "Chapter 9. FINDING FAULT").
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有编写代码来处理这些错误条件，你几乎肯定会遇到一个*bug*；你的程序不会总是按照你的意图工作。但如果错误很少发生，它可能是一个非常微妙的错误！我们将在[第9章](ch09.html
    "第9章。寻找错误")中探讨错误。
- en: 'An error may occur for one of a thousand reasons, but it will fall into one
    of these three categories:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能由于一千种原因之一发生，但它将落入以下三个类别之一：
- en: '**User error**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户错误**'
- en: The stupid user manhandled your lovely program. Perhaps he provided the wrong
    input or attempted an operation that's absolutely absurd. A good program will
    point out the mistake and help the user rectify it. It won't insult him or whine
    in an incomprehensible manner.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 愚蠢的用户错误地操作了你的可爱程序。也许他提供了错误输入或尝试了绝对荒谬的操作。一个好的程序会指出错误并帮助用户纠正它。它不会侮辱他或以难以理解的方式抱怨。
- en: '**Programmer error**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序员错误**'
- en: The user pushed all the right buttons, but the code is broken. This is the consequence
    of a bug elsewhere, a fault the programmer introduced that the user can do nothing
    about (except to try and avoid it in the future). This kind of error should (ideally)
    never occur.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下了所有正确的按钮，但代码却出了问题。这是其他地方的一个错误的后果，是程序员引入的错误，用户对此无能为力（除了尝试在未来避免它）。这种错误（理想情况下）永远不会发生。
- en: 'There''s a cycle here: Unhandled errors can cause bugs. And those bugs might
    result in further error conditions occurring elsewhere in your code. This is why
    we consider defensive programming an important practice.'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个循环：未处理的错误会导致bug。而这些bug可能会导致你的代码其他地方出现进一步的错误条件。这就是为什么我们认为防御性编程是一个重要的实践。
- en: Exceptional circumstances
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况
- en: The user pushed all the right buttons, and the programmer didn't mess up. Fate's
    fickle finger intervened, and we ran into something that couldn't be avoided.
    Perhaps a network connection failed, we ran out of printer ink, or there's no
    hard disk space left.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下了所有正确的按钮，程序员也没有出错。命运的变幻无常的手指介入了，我们遇到了无法避免的事情。也许网络连接失败了，我们用完了打印机墨水，或者硬盘空间已经满了。
- en: 'We need a well-defined strategy to manage each kind of error in our code. An
    error may be detected and reported to the user in a pop-up message box, or it
    may be detected by a middle-tier code layer and signaled to the client code programmatically.
    The same principles apply in both cases: whether a human chooses how to handle
    the problem or your code makes a decision—*someone* is responsible for acknowledging
    and acting on errors.'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个明确定义的策略来管理代码中每种类型的错误。错误可能通过弹出消息框检测并报告给用户，或者可能由中间层代码层检测并通过程序方式通知客户端代码。在这两种情况下，原则是相同的：无论是人类选择如何处理问题还是你的代码做出决定——*有人*负责承认并采取行动处理错误。
- en: '**KEY CONCEPT**'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Take error handling seriously. The stability of your code rests on it*.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '*认真对待错误处理。你代码的稳定性依赖于它*。'
- en: 'Errors are raised by subordinate components and communicated upward, to be
    dealt with by the caller. They are reported in a number of ways; we''ll look at
    these in the next section. To take control of program execution, we must be able
    to:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 错误由从属组件引发并向上传递，由调用者处理。它们以多种方式报告；我们将在下一节中探讨这些内容。为了控制程序执行，我们必须能够：
- en: Raise an error when something goes wrong
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当出现问题时抛出错误
- en: Detect all possible error reports
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测所有可能的错误报告
- en: Handle them appropriately
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地处理它们
- en: Propagate errors we can't handle
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传播我们无法处理的错误
- en: Errors are hard to deal with. The error you encounter is often not related to
    what you were doing at the time (most fall under the "exceptional circumstances"
    category). They are also tedious to deal with—we want to focus on what our program
    *should* be doing, not on how it may go wrong. However, without good error management,
    your program will be brittle—built upon sand, not rock. At the first sign of wind
    or rain, it will collapse.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 错误很难处理。你遇到的错误通常与你当时所做的事情无关（大多数属于“异常情况”类别）。它们也令人厌烦——我们希望专注于我们的程序*应该*做什么，而不是它可能出错的方式。然而，如果没有良好的错误管理，你的程序将会脆弱——建立在沙子上，而不是岩石上。一旦有风或雨的迹象，它就会倒塌。
- en: Error-Reporting Mechanisms
  id: totrans-1270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误报告机制
- en: There are several common strategies for propagating error information to client
    code. You'll run into code that uses each of them, so you must know how to speak
    every dialect. Observe how these error-reporting techniques compare, and notice
    which situations call for each mechanism.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的策略用于将错误信息传播到客户端代码。你可能会遇到使用其中每一种的代码，所以你必须知道如何使用每种方言。观察这些错误报告技术之间的比较，并注意哪些情况需要哪种机制。
- en: Each mechanism has different implications for the *locality of error*. An error
    is local in *time* if it is discovered very soon after it is created. An error
    is local in *space* if it is identified very close to (or even *at*) the site
    where it actually manifests. Some approaches specifically aim to reduce the locality
    of error to make it easier to see what's going on (e.g., error codes). Others
    aim to extend the locality of error so that normal code doesn't get entwined with
    error-handling logic (e.g., exceptions).
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 每种机制对错误的*局部性*有不同的影响。如果错误在创建后不久被发现，则错误在*时间*上是局部的。如果错误在实际上表现的地方非常接近（甚至*就是*）被识别，则错误在*空间*上是局部的。一些方法专门旨在减少错误的局部性，使其更容易看到正在发生的事情（例如，错误代码）。其他方法旨在扩展错误的局部性，以便正常代码不会与错误处理逻辑纠缠在一起（例如，异常）。
- en: The favored reporting mechanism is often an architectural decision. The architect
    might consider it important to define a homogeneous hierarchy of exception classes
    or a central list of shared reason codes to unify error-handling code.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的报告机制通常是架构决策。架构师可能会认为定义一个同质的异常类层次结构或一个共享原因代码的中央列表来统一错误处理代码很重要。
- en: No Reporting
  id: totrans-1274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不报告
- en: The simplest error-reporting mechanism is *don't bother*. This works wonderfully
    in cases where you want your program to behave in bizarre and unpredictable ways
    and to crash randomly.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的错误报告机制是*不麻烦*。在你想让你的程序以奇特和不可预测的方式行为并随机崩溃的情况下，这效果非常好。
- en: If you encounter an error and don't know what to do about it, blindly ignoring
    it is *not* a viable option. You probably can't continue the function's work,
    but returning without fulfilling your function's contract will leave the world
    in an undefined and inconsistent state.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误并且不知道如何处理它，盲目地忽略它*不是*一个可行的选择。你可能无法继续函数的工作，但如果没有履行你的函数合同就返回，将会使世界处于未定义和不一致的状态。
- en: '**KEY CONCEPT**'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Never ignore an error condition. If you don''t know how to handle the problem,
    signal a failure back up to the calling code. Don''t sweep an error under the
    rug and hope for the best*.'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不要忽略错误条件。如果你不知道如何处理问题，向调用代码发出失败信号。不要把错误扫到地毯下，寄希望于最好的结果*。'
- en: An alternative to ignoring errors is to instantly abort the program upon encountering
    a problem. It's easier than handling errors throughout the code, but hardly a
    well-engineered solution!
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略错误的替代方案是在遇到问题时立即终止程序。这比在代码中处理错误要容易，但几乎不是一个经过良好设计的解决方案！
- en: Return Values
  id: totrans-1280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: The next most simple mechanism is to return a success/failure value from your
    function. A boolean return value provides a simple yes or no answer. A more advanced
    approach enumerates all the possible exit statuses and returns a corresponding
    *reason code*. One value means *success*; the rest represent the many and varied
    abortive cases. This enumeration may be shared across the whole codebase, in which
    case your function returns a subset of the available values. You should therefore
    document what the caller can expect.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最简单的机制是从你的函数返回成功/失败值。布尔返回值提供了一个简单的“是”或“否”答案。更高级的方法列举所有可能的退出状态，并返回相应的 *原因码*。一个值表示
    *成功*；其余的表示许多不同的中止情况。这种枚举可以在整个代码库中共享，在这种情况下，你的函数返回可用值的子集。因此，你应该记录调用者可以期待的内容。
- en: 'While this works well for procedures that don''t return data, passing error
    codes back *with* returned data gets messy. If `int count()` walks down a linked
    list and returns the number of elements, how can it signify a list structure corruption?
    There are three approaches:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种方法对于不返回数据的程序有效时，将错误码与返回数据一起返回会变得混乱。如果 `int count()` 沿着链表向下遍历并返回元素数量，它如何表示列表结构的损坏？有三种方法：
- en: Return a compound data type (or *tuple*) containing both the return value and
    an error code. This is rather clumsy in the popular C-like languages and is seldom
    seen in them.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个包含返回值和错误码的复合数据类型（或称 *元组*）。这在流行的类似 C 的语言中相当笨拙，并且很少见。
- en: Pass the error code back through a function parameter. In C++ or .NET, this
    parameter would be passed by reference. In C you'd direct the variable access
    through pointers. This approach is ugly and nonintuitive; there is no syntactic
    way to distinguish a return value from a parameter.
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数参数传递错误码。在 C++ 或 .NET 中，此参数将通过引用传递。在 C 中，你会通过指针直接访问变量。这种方法既丑陋又难以理解；没有语法方式可以区分返回值和参数。
- en: Alternatively, reserve a range of return values to signify failure. The `count`
    example can nominate all negative numbers as error reason codes; they'd be meaningless
    answers anyway. Negative numbers are a common choice for this. Pointer return
    values may be given a specific invalid value, which by convention is zero (or
    `NULL`). In Java and C#, you can return a `null` object reference.
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，预留一个返回值范围以表示失败。例如，`count` 可以指定所有负数作为错误原因码；它们本来就没有意义。负数是这种选择的常见选择。指针返回值可以赋予一个特定的无效值，按照惯例是零（或
    `NULL`）。在 Java 和 C# 中，你可以返回一个 `null` 对象引用。
- en: This technique doesn't always work well. Sometimes it's hard to reserve an error
    range—all return values are equally meaningful and equally likely. It also has
    the side effect of reducing the available range of success values; the use of
    negative values reduces the possible positive values by an order of magnitude.^([[1](#ftn.CHP-6-FN-1)])
  id: totrans-1286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术并不总是有效。有时很难预留一个错误范围——所有返回值都同样有意义且同样可能。它还会产生副作用，减少成功值的可用范围；使用负值将可能的正值减少了一个数量级.^([[1](#ftn.CHP-6-FN-1)])
- en: Error Status Variables
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误状态变量
- en: This method attempts to manage the contention between a function's return value
    and its error status report. Rather than return a reason code, the function sets
    a shared global error variable. After calling the function, you must then inspect
    this status variable to find out whether or not it completed successfully.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法试图管理函数返回值与其错误状态报告之间的竞争。而不是返回一个原因码，函数设置一个共享的全局错误变量。在调用函数之后，你必须检查这个状态变量以确定是否成功完成。
- en: The shared variable reduces confusion and clutter in the function's signature,
    and it doesn't restrict the return value's data range at all. However, errors
    signaled through a separate channel are much easier to miss or willfully ignore.
    A shared global variable also has nasty thread safety implications.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 共享变量减少了函数签名中的混淆和杂乱，并且根本不会限制返回值的数据范围。然而，通过单独通道发出的错误信号更容易被忽略或故意忽视。共享的全局变量还有讨厌的线程安全问题。
- en: 'The C standard library employs this technique with its `errno` variable. It
    has very subtle semantics: Before using any standard library facility, you must
    manually clear `errno`. Nothing ever sets a succeeded value; only failures touch
    `errno`. This is a common source of bugs, and it makes calling each library function
    tedious. To add insult to injury, not all C standard library functions use `errno`,
    so it is less than consistent.'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库使用`errno`变量采用这种技术。它具有非常微妙的语义：在使用任何标准库功能之前，你必须手动清除`errno`。没有任何东西会设置成功值；只有失败会触及`errno`。这是常见的错误来源，它使得调用每个库函数变得繁琐。更糟糕的是，并非所有C标准库函数都使用`errno`，因此它并不一致。
- en: This technique is functionally equivalent to using return values, but it has
    enough disadvantages to make you avoid it. Don't write your own error reports
    this way, and use existing implementations with the utmost care.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与使用返回值在功能上是等效的，但它有足够的缺点，以至于让你避免使用它。不要以这种方式编写自己的错误报告，并且在使用现有实现时要极其小心。
- en: Exceptions
  id: totrans-1292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions are a language facility for managing errors; not all languages support
    exceptions. Exceptions help to distinguish the normal flow of execution from *exceptional*
    cases—when a function has failed and cannot honor its contract. When your code
    encounters a problem that it can't handle, it stops dead and throws up an *exception*—an
    object representing the error. The language run time then automatically steps
    back up the call stack until it finds some exception-handling code. The error
    lands there, for the program to deal with.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是管理错误的语言功能；并非所有语言都支持异常。异常有助于区分正常的执行流程和*异常*情况——当函数失败且无法履行其合同时。当你的代码遇到它无法处理的问题时，它会立即停止并抛出一个*异常*——一个表示错误的对象。然后，语言运行时会自动向上回溯调用栈，直到找到一些异常处理代码。错误会落在那里，由程序来处理。
- en: 'There are two operational models, distinguished by what happens after an exception
    is handled:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种操作模型，它们通过处理异常后发生的事情来区分：
- en: '**The termination model**'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止模型**'
- en: Execution continues after the handler that caught the exception. This behavior
    is provided by C++, .NET, and Java.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获异常的处理程序之后继续执行。这种行为由C++、.NET和Java提供。
- en: '**The resumption model**'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复模型**'
- en: Execution resumes where the exception was raised.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从异常抛出的地方恢复。
- en: The former model is easier to reason about, but it doesn't give ultimate control.
    It only allows *error handling* (you can execute code when you notice an error),
    not *fault rectification* (a chance to fix the problem and try again).
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 前者模型更容易推理，但它不提供最终控制权。它只允许*错误处理*（当你注意到错误时可以执行代码），而不是*故障纠正*（修复问题并再次尝试的机会）。
- en: An exception cannot be ignored. If it isn't caught and handled, it will propagate
    to the very top of the call stack and will usually stop the program dead in its
    tracks. The language run time automatically cleans up as it unwinds the call stack.
    This makes exceptions a tidier and safer alternative to handcrafted error-handling
    code. However, throwing exceptions through sloppy code can lead to memory leaks
    and problems with resource cleanup.^([[2](#ftn.CHP-6-FN-2)]) You must take care
    to write *exception-safe* code. The sidebar explains what this means in more detail.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 异常不能被忽略。如果没有被捕获和处理，它将传播到调用栈的顶部，通常会导致程序立即停止。语言运行时会自动清理，在回溯调用栈时。这使得异常成为一个比手工错误处理代码更整洁、更安全的替代方案。然而，通过糟糕的代码抛出异常可能会导致内存泄漏和资源清理问题。[^2](#ftn.CHP-6-FN-2)]你必须小心编写*异常安全*的代码。侧边栏将更详细地解释这意味着什么。
- en: '**WHISTLE-STOP TOUR OF EXCEPTION SAFETY**'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常安全性的快速浏览**'
- en: Resilient code must be *exception safe*. It must work correctly (for some definition
    of *correctly*, which we'll investigate below), no matter what exceptions come
    its way. This is true regardless of whether or not the code catches any exceptions
    itself.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性代码必须是*异常安全*的。无论遇到什么异常，它都必须正确工作（对于*正确*的定义，我们将在下面探讨），无论代码本身是否捕获任何异常。
- en: '*Exception-neutral* code propagates all exceptions up to the caller; it won''t
    consume or change anything. This is an important concept for generic programs
    like C++ template code—the template types may generate all sorts of exceptions
    that template implementors don''t understand.'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常中立*的代码将所有异常传播到调用者；它不会消费或改变任何东西。这对于像C++模板代码这样的通用程序是一个重要的概念——模板类型可能会生成各种异常，而模板实现者可能不理解。'
- en: 'There are several different levels of exception safety. They are described
    in terms of guarantees to the calling code. These guarantees are:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 异常安全性有几个不同的级别。它们是用调用代码的保证来描述的。这些保证是：
- en: '**Basic guarantee**'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本保证**'
- en: 'If exceptions occur in a function (resulting from an operation you perform
    or the call of another function), it will not leak resources. The code state will
    be *consistent* (i.e., it can still be used correctly), but it will not necessarily
    leave in a known state. For example: A member function should add 10 items to
    a container, but an exception propagates through it. The container is still usable;
    maybe no objects were inserted, maybe all 10 were, or perhaps every other object
    was added.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数中发生异常（由你执行的操作或另一个函数的调用引起），它将不会泄露资源。代码状态将是**一致的**（即它仍然可以正确使用），但它不一定留下一个已知的状态。例如：一个成员函数应该向容器中添加10个项目，但异常通过它传播。容器仍然可用；可能没有插入对象，可能所有10个都插入了，或者可能每隔一个对象就添加了一个。
- en: '**Strong guarantee**'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '**强保证**'
- en: This is far more strict than the basic guarantee. If an exception propagates
    through your code, the program state remains completely unchanged. No object is
    altered, no global variables changed, nothing. In the example above, nothing was
    inserted into the container.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 这比基本保证要严格得多。如果一个异常在你的代码中传播，程序状态将完全保持不变。没有任何对象被改变，没有全局变量被更改，什么都没有。在上面的例子中，容器中没有插入任何内容。
- en: '**Nothrow guarantee**'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '**无异常保证**'
- en: 'The final guarantee is the most restrictive: that an operation can *never*
    throw an exception. If we are exception neutral, then this implies the function
    cannot do anything else that might throw an exception.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的保证是最为严格的：即一个操作**永远**不能抛出异常。如果我们是异常中立的话，那么这就意味着该函数不能做任何可能抛出异常的其他事情。
- en: Which guarantee you provide is entirely your choice. The more restrictive the
    guarantee, the more widely (re)usable the code is. In order to implement the strong
    guarantee, you will generally need a number of functions providing the nothrow
    guarantee.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供哪种保证完全取决于你。保证越严格，代码的可重用性就越广。为了实现强保证，你通常需要一系列提供无异常保证的函数。
- en: Most notably, every destructor you write *must* honor the nothrow guarantee.^([[3](#ftn.CHP-6-FN-3)])
    Otherwise, all exception handling bets are off. In the presence of an exception,
    object destructors are called automatically as the stack is unwound. Raising an
    exception while handling an exception is not permissible.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的是，你写的每个析构函数**必须**遵守无异常保证^([[3](#ftn.CHP-6-FN-3)])。否则，所有的异常处理赌注都失效了。在异常存在的情况下，对象析构函数会自动在栈回溯时被调用。在处理异常时抛出异常是不允许的。
- en: The code that handles an exception is distinct from the code that raises it,
    and it may be arbitrarily far away. Exceptions are usually provided by OO languages,
    where errors are defined by a hierarchy of exception classes. A handler can elect
    to catch a quite specific class of error (by accepting a leaf class) or a more
    general category of error (by accepting a base class). Exceptions are particularly
    useful for signaling errors in a constructor.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常的代码与引发异常的代码是不同的，并且可能相隔很远。异常通常由面向对象的语言提供，其中错误由异常类层次结构定义。处理器可以选择捕获一个相当具体的错误类（通过接受一个叶类）或一个更一般的错误类别（通过接受一个基类）。异常在向构造函数中传递错误信号时尤其有用。
- en: Exceptions don't come for free; the language support incurs a performance penalty.
    In practice, this isn't significant and only manifests around exception-handling
    statements—exception handlers reduce the compiler's optimization opportunities.
    This doesn't mean that exceptions are flawed; their expense is justified compared
    to the cost of not doing any error handling!
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 异常不是免费的；语言支持会带来性能惩罚。在实践中，这并不显著，并且仅在异常处理语句周围表现出来——异常处理器减少了编译器的优化机会。这并不意味着异常有缺陷；与不做任何错误处理相比，它们的成本是合理的！
- en: Signals
  id: totrans-1315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Signals are a more extreme reporting mechanism, largely used for errors sent
    by the execution environment to the running program. The operating system traps
    a number of exceptional events, like a *floating point exception* triggered by
    the maths coprocessor. These well-defined error events are delivered to the application
    in signals that interrupt the program's normal flow of execution, jumping into
    a nominated *signal handler* function. Your program could receive a signal at
    any time, and the code must be able to cope with this. When the signal handler
    completes, program execution continues at the point it was interrupted.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一种更极端的汇报机制，主要用于执行环境向运行中的程序发送的错误。操作系统会捕捉到许多异常事件，例如由数学协处理器触发的*浮点异常*。这些定义良好的错误事件通过信号传递给应用程序，这些信号会中断程序的正常执行流程，跳转到指定的*信号处理函数*。你的程序可能在任何时候接收到信号，代码必须能够应对这种情况。当信号处理函数完成后，程序将在被中断的地方继续执行。
- en: Signals are the software equivalent of a hardware interrupt. They are a Unix
    concept, now provided on most platforms (a basic version is part of the ISO C
    standard [ISO99]). The operating system provides sensible default handlers for
    each signal, some of which do nothing, others of which abort the program with
    a neat error message. You can override these with your own handler.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是软件中断的等效物。这是一个Unix概念，现在在大多数平台上都提供了（基本版本是ISO C标准[ISO99]的一部分）。操作系统为每个信号提供了合理的默认处理程序，其中一些什么都不做，而另一些则通过整洁的错误消息终止程序。你可以用你自己的处理程序来覆盖这些处理程序。
- en: The defined C signal events include program termination, execution suspend/continue
    requests, and math errors. Some environments extend the basic list with many more
    events.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的C信号事件包括程序终止、执行挂起/继续请求以及数学错误。一些环境通过许多更多的事件扩展了基本列表。
- en: '* * *'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-6-FN-1)]) If you used an `unsigned int` then the number of values
    available would increase by a power of two, reusing the `signed int`'s sign bit.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-6-FN-1)]) 如果你使用了`unsigned int`，那么可用的值的数量将增加2的幂次方，重用`signed int`的符号位。
- en: ^([[2](#CHP-6-FN-2)]) For example, you could allocate a block of memory and
    then exit early as an exception propagates through. The allocated memory would
    leak. This kind of problem makes writing code in the face of exceptions a complex
    business.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-6-FN-2)]) 例如，你可以在分配了一块内存后，在异常传播过程中提前退出。分配的内存将会泄漏。这类问题使得在异常面前编写代码变得复杂。
- en: ^([[3](#CHP-6-FN-3)]) That's the case in C++ and Java, at least. C# stupidly
    called ~X() a destructor, even though it was a finalizer in disguise. Throwing
    an exception in a C# destructor has different implications.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-6-FN-3)]) 至少在C++和Java中是这样的。C#愚蠢地将~X()称为析构函数，尽管它实际上是一个伪装的终结器。在C#析构函数中抛出异常有不同的含义。
- en: Detecting Errors
  id: totrans-1323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误检测
- en: 'How you detect an error obviously depends on the mechanism reporting it. In
    practical terms, this means:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何检测错误显然取决于报告它的机制。在实践中，这意味着：
- en: '**Return values**'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: You determine whether a function failed by looking at its return code. This
    failure test is bound tightly to the act of calling the function; by making the
    call, you are implicitly checking its success. Whether or not you do anything
    with that information is up to you.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过查看函数的返回码来确定函数是否失败。这种失败测试与调用函数的行为紧密相关；通过调用函数，你隐式地检查了它的成功。你是否有必要处理这些信息取决于你自己。
- en: '**Error status variables**'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误状态变量**'
- en: After calling a function, you must inspect the error status variable. If it
    follows C's `errno` model of operation, you don't actually need to test for errors
    after every single function call. First reset `errno`, and then call any number
    of standard library functions back-to-back. Afterward, inspect `errno`. If it
    contains an error value, then one of those functions failed. Of course, you don't
    know what fell over, but if you don't care, then this is a streamlined error-detection
    approach.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数之后，你必须检查错误状态变量。如果它遵循C的`errno`操作模型，你实际上不需要在每次函数调用后都测试错误。首先重置`errno`，然后连续调用任意数量的标准库函数。之后，检查`errno`。如果它包含错误值，那么这些函数中的某一个失败了。当然，你不知道哪个失败了，但如果你不在乎，那么这是一种简化的错误检测方法。
- en: '**Exceptions**'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常**'
- en: If an exception propagates out of a subordinate function, you can choose to
    catch and handle it or to ignore it and let the exception flow up a level. You
    can only make an informed choice when you know what kinds of exceptions might
    be thrown. You'll only know this if it has been documented (and if you trust the
    documentation).
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常从一个从属函数中传播出来，你可以选择捕获并处理它，或者忽略它并让异常向上传播一个级别。只有当你知道可能会抛出哪些类型的异常时，你才能做出明智的选择。你只有在它被记录（并且你信任该记录）的情况下才会知道这一点。
- en: Java's exception implementation places this documentation in the code itself.
    The programmer has to write an *exception specification* for every method, describing
    what it can throw; it is a part of the function's signature. Java is the only
    mainstream language to enforce this approach. You cannot leak an exception that
    isn't in the list, because the compiler performs static checking to prevent it.^([[4](#ftn.CHP-6-FN-4)])
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: Java的异常实现将此类文档放置在代码本身中。程序员必须为每个方法编写一个*异常规范*，描述它可以抛出什么；这是函数签名的一部分。Java是唯一强制执行这种方法的主流语言。你不能泄露不在列表中的异常，因为编译器执行静态检查以防止这种情况发生.^([[4](#ftn.CHP-6-FN-4)])
- en: '**Signals**'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**'
- en: 'There''s only one way to detect a signal: Install a hander for it. There''s
    no obligation. You can also choose not to install any signal handlers at all and
    accept the default behavior.'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 检测信号只有一种方法：安装一个处理程序。没有义务。你也可以选择不安装任何信号处理程序，并接受默认行为。
- en: 'As various pieces of code converge in a large system, you will probably need
    to detect errors in more than one way, even within a single function. Whichever
    detection mechanism you use, the key point is this:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 当各种代码片段在一个大系统中汇聚时，你可能需要以多种方式检测错误，甚至在单个函数内部也是如此。无论你使用哪种检测机制，关键点如下：
- en: '**KEY CONCEPT**'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Never ignore* any *errors that might be reported to you. If an error report
    channel exists, it''s there for a reason*.'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不要忽略*任何可能报告给你的*错误。如果存在错误报告通道，它存在是有原因的*。'
- en: It is good practice to always write error-detection scaffolding—even if an error
    has no implication for the rest of your code. This makes it clear to a maintenance
    programmer that you know a function may fail and have consciously chosen to ignore
    any failures.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 总是编写错误检测脚本是良好的实践——即使错误对其他代码没有影响。这使维护程序员清楚，你知道一个函数可能会失败，并且已经有意选择忽略任何失败。
- en: When you let an exception propagate through your code, you are not ignoring
    it—you *can't* ignore an exception. You are allowing it to be handled by a higher
    level. The philosophy of exception handling is quite different in this respect.
    It's less clear what the most appropriate way to document this is—should you write
    a `try`/`catch` block that simply re`throw`s the exception, should you write a
    comment claiming that the code *is* exception safe, or should you do nothing?
    I'd favor documenting the exception behavior.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让异常在你的代码中传播时，你并不是在忽略它——你*不能*忽略异常。你是在允许它被更高层次处理。在异常处理方面，这种哲学相当不同。关于如何记录这一点最合适，你应该写一个简单的`try`/`catch`块来重新抛出异常，你应该写一个注释声称代码*是*异常安全的，还是你应该什么都不做？我倾向于记录异常行为。
- en: '* * *'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-6-FN-4)]) C++ also supports exception specifications, but leaves
    their use optional. It's idiomatic to avoid them—for performance reasons, among
    others. Unlike Java, they are enforced at run time.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-6-FN-4)]) C++也支持异常规范，但将其使用留作可选。出于性能和其他原因，避免使用它们是惯例。与Java不同，它们在运行时强制执行。
- en: Handling Errors
  id: totrans-1341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: Love truth, and pardon error.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 热爱真理，宽恕错误。
- en: --Voltaire
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: --伏尔泰
- en: 'Errors happen. We''ve seen how to discover them and when to do so. The question
    now is: What do you do about them? This is the hard part. The answer largely depends
    on circumstance and the gravity of an error—whether it''s possible to rectify
    the problem and retry the operation or to carry on regardless. Often there is
    no such luxury; the error may even herald the beginning of the end. The best you
    can do is clean up and exit sharply, before anything else goes wrong.'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生。我们已经看到了如何发现它们以及何时这样做。现在的问题是：你对它们怎么办？这是难点。答案在很大程度上取决于情况以及错误的严重性——是否有可能纠正问题并重试操作，或者是否可以继续进行。通常没有这样的奢侈；错误甚至可能预示着结束的开始。你能做的最好的事情是在其他事情出错之前清理并迅速退出。
- en: 'To make this kind of decision, you must be informed. You need to know a few
    key pieces of information about the error:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 要做出这种决定，你必须了解情况。你需要了解一些关于错误的关键信息：
- en: '**Where it came from**'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误来源**'
- en: This is quite distinct from where it's going to be handled. Is the source a
    core system component or a peripheral module? This information may be encoded
    in the error report; if not, you can figure it out manually.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 这与将要处理的地方截然不同。源是核心系统组件还是外围模块？这种信息可能包含在错误报告中；如果没有，你可以手动找出。
- en: '**What you were trying to do**'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '**你试图做什么**'
- en: What provoked the error? This may give a clue toward any remedial action. Error
    reporting seldom contains this kind of information, but you can figure out which
    function was called from the context.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 什么引发了错误？这可能为任何补救措施提供线索。错误报告很少包含这类信息，但你可以从上下文中找出被调用的函数。
- en: '**Why it went wrong**'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么出错**'
- en: What is the nature of the problem? You need to know exactly what happened, not
    just a general *class* of error. How much of the erroneous operation completed?
    *All* or *none* are nice answers, but generally, the program will be in some indeterminate
    state between the two.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的本质是什么？你需要确切地知道发生了什么，而不仅仅是错误的一般*类别*。错误操作完成了多少？*全部*或*没有*都是很好的答案，但通常，程序会在这两种状态之间处于某种不确定的状态。
- en: '**When it happened**'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误发生时**'
- en: This is the locality of the error in time. Has the system only just failed,
    or is a problem two hours old finally being felt?
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误在时间上的局部性。系统刚刚失败，还是问题已经存在两小时终于被感觉到？
- en: '**The severity of the error**'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误的严重性**'
- en: Some problems are more serious than others, but when detected, one error is
    equivalent to another—you can't continue without understanding and managing the
    problem. Error severity is usually determined by the caller, based on how easy
    it will be to recover or work around the error.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题比其他问题更严重，但一旦检测到，一个错误就等同于另一个错误——你不理解和管理问题就无法继续。错误严重性通常由调用者根据恢复或绕过错误的难易程度来确定。
- en: '**How to fix it**'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何修复它**'
- en: This may be obvious (e.g., insert a floppy disk and retry) or not (e.g., you
    need to modify the function parameters so they are consistent). More often than
    not, you have to infer this knowledge from the other information you have.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很明显（例如，插入软盘并重试）或不是（例如，你需要修改函数参数以确保它们一致）。更常见的是，你必须从其他信息中推断出这种知识。
- en: Given this depth of information, you can formulate a strategy to handle each
    error. Forgetting to insert a handler for any potential error will lead to a bug,
    and it might turn out to be a bug that is hard to exercise and hard to track down—so
    think about every error condition carefully.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种信息深度，你可以制定一个策略来处理每个错误。忘记为任何潜在的错误插入处理程序将导致错误，并且可能是一个难以练习和难以追踪的错误——所以仔细思考每个错误条件。
- en: When to Deal with Errors
  id: totrans-1359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当处理错误
- en: '*When* should you handle each error? This can be separate from when it''s detected.
    There are two schools of thought.'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '*何时*处理每个错误？这可以与检测时间分开。有两种不同的观点。'
- en: '**As soon as possible**'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽可能早**'
- en: Handle each error *as* you detect it. Since the error is handled near to its
    cause, you retain important contextual information, making the error-handling
    code clearer. This is a well-known self-documenting code technique. Managing each
    error near its source means that control passes through less code in an invalid
    state.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到每个错误时*立即*处理。由于错误是在其源头附近处理的，因此你保留了重要的上下文信息，使得错误处理代码更加清晰。这是一种众所周知的自文档化代码技术。在错误源头附近管理每个错误意味着在无效状态下通过更少的代码进行控制。
- en: This is usually the best option for functions that return error codes.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是返回错误代码的函数的最佳选择。
- en: '**As late as possible**'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽可能晚**'
- en: 'Alternatively, you could defer error handling for as long as possible. This
    recognizes that code detecting an error rarely knows what to do about it. It often
    depends on the context in which it is used: A missing file error may be reported
    to the user when loading a document but silently swallowed when hunting for a
    preferences file.'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以尽可能晚地推迟错误处理。这认识到检测错误的代码很少知道如何处理它。它通常取决于它被使用的上下文：在加载文档时报告的缺失文件错误可能在查找首选项文件时被静默吞没。
- en: Exceptions are ideal for this; you can pass an exception through each level
    until you know how to deal with the error. This separation of detection and handling
    may be clearer, but it can make code more complex. It's not obvious that you are
    deliberately deferring error handling, and it's not clear where an error came
    from when you do finally handle it.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 异常非常适合这种情况；你可以将异常传递到每一层，直到你知道如何处理错误。这种检测和处理之间的分离可能更清晰，但它可能会使代码更复杂。当你最终处理错误时，并不明显你是有意推迟错误处理的，而且也不清楚错误是从哪里来的。
- en: 'In theory, it''s nice to separate "business logic" from error handling. But
    often you can''t, as cleanup is necessarily entwined with that business logic,
    and it can be more tortuous to write the two separately. However, centralized
    error-handling code has advantages: You know where to look for it, and you can
    put the abort/continue policy in one place rather than scatter it through many
    functions.'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，将“业务逻辑”与错误处理分开是很好的。但通常你无法做到，因为清理必然与那种业务逻辑交织在一起，而且将两者分开编写可能更加复杂。然而，集中式的错误处理代码有优势：你知道在哪里查找它，并且可以将中止/继续策略放在一个地方，而不是分散在许多函数中。
- en: Thomas Jefferson once declared, "Delay is preferable to error." There is truth
    there; the actual *existence* of error handling is far more important than *when*
    an error is handled. Nevertheless, choose a compromise that's close enough to
    prevent obscure and out-of-context error handling, while being far enough away
    to not cloud normal code with roundabout paths and error handling dead ends.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 托马斯·杰斐逊曾说过，“拖延胜于错误。”这里有一定的道理；错误处理的实际*存在*比处理错误的时间更重要。尽管如此，选择一个折衷方案，既足够接近以防止模糊和脱离上下文的错误处理，又足够远离以不使正常代码被迂回路径和错误处理死胡同所混淆。
- en: '**KEY CONCEPT**'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Handle each error in the most appropriate context, as soon as you know enough
    about it to deal with it correctly*.'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你足够了解错误以正确处理它，就立即在最适合的上下文中处理每个错误*。'
- en: Possible Reactions
  id: totrans-1371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的反应
- en: You've caught an error. You're poised to handle it. What are you going to do
    now? Hopefully, whatever is required for correct program operation. While we can't
    list every recovery technique under the sun, here are the common reactions to
    consider.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经捕获了一个错误。你准备处理它。接下来你打算做什么？希望是进行正确的程序操作。虽然我们无法列出所有可能的恢复技术，但以下是一些常见的反应供你考虑。
- en: '**Logging**'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志记录**'
- en: Any reasonably large project should already be employing a logging facility.
    It allows you to collect important trace information, and is an entry point for
    the investigation of nasty problems.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理规模的项目都应该已经采用了日志记录设施。它允许你收集重要的跟踪信息，并且是调查棘手问题的入口点。
- en: The log exists to record interesting events in the life of the program, to allow
    you to delve into its inner workings and reconstruct paths of execution. For this
    reason, all errors you encounter should be detailed in the program log; they are
    some of the most interesting and telling events of all. Aim to capture all pertinent
    information—as much of the previous list as you can.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 日志存在是为了记录程序生活中的有趣事件，以便你深入了解其内部工作原理并重建执行路径。因此，你遇到的所有错误都应该详细记录在程序日志中；它们是所有事件中最有趣和最有说明性的。目标是捕捉所有相关信息——尽可能多的上一列表中的信息。
- en: For really obscure errors that predict catastrophic disaster, it may be a good
    idea to get the program to "phone home"—to transmit either a snapshot of itself
    or a copy of the error log to the developers for further investigation.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能预测灾难性灾难的非常隐蔽的错误，让程序“打电话回家”——发送其自身的快照或错误日志的副本给开发者进行进一步调查，可能是个好主意。
- en: What you do *after* logging is another matter.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录之后你要做什么是另一回事。
- en: '**Reporting**'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告**'
- en: A program should only report an error to the user when there's nothing left
    to do. The user does not need to be bombarded by a thousand small nuggets of useless
    information or badgered by a raft of pointless questions. Save the interaction
    for when it's really vital. Don't report when you encounter a recoverable situation.
    By all means, log the event, but keep quiet about it. Provide a mechanism that
    enables users to read the event log if you think one day they might care.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序只有在没有其他事情可做时才应该向用户报告错误。用户不需要被成千上万的小块无用信息轰炸，或者被一大堆无意义的问题困扰。只有在真正关键的时候才进行交互。当你遇到可恢复的情况时，不要报告。无论如何，记录下事件，但对此保持沉默。如果你认为将来他们可能会关心，提供一种机制让用户能够阅读事件日志。
- en: There *are* some problems that only the user can fix. For these, it is good
    practice to report the problem immediately, in order to allow the user the best
    chance to resolve the situation or else decide how to continue.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题只有用户才能解决。对于这些问题，立即报告问题是一个好的做法，以便给用户最好的机会来解决问题或者决定如何继续。
- en: Of course, this kind of reporting depends on whether or not the program is interactive.
    Deeply embedded systems are expected to cope on their own; it's hard to pop up
    a dialog box on a washing machine.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种报告取决于程序是否是交互式的。深度嵌入的系统预计可以自行处理；在洗衣机上弹出对话框是很困难的。
- en: '**Recovery**'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复**'
- en: Sometimes your only course of action is to stop immediately. But not all errors
    spell doom. If your program saves a file, one day the disk will fill up, and the
    save operation will fail. The user expects your program to continue happily, so
    be prepared.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你唯一能做的就是立即停止。但并非所有错误都意味着灾难。如果你的程序保存文件，有一天磁盘会满，保存操作会失败。用户期望你的程序继续愉快地运行，所以要做好准备。
- en: If your code encounters an error and doesn't know what to do about it, pass
    the error upward. It's more than likely your caller will have the ability to recover.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码遇到错误并且不知道如何处理它，向上传递错误。很可能调用者有恢复的能力。
- en: '**Ignore**'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '**忽略**'
- en: I only include this for completeness. Hopefully by now you've learned to scorn
    the very suggestion of ignoring an error. If you choose to forget all about handling
    it and to just continue with your fingers crossed, *good luck*. This is where
    most of the bugs in any software package will come from. Ignoring an error whose
    occurrence may cause the system to misbehave inevitably leads to hours of debugging.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 我只包括这一点以示完整。希望到现在你已经学会了蔑视忽略错误的建议。如果你选择忘记处理它，只是继续交叉手指，那么祝你好运。大多数软件包中的大多数错误都来自这里。忽略可能引起系统行为异常的错误不可避免地会导致数小时的调试。
- en: You can, however, write code that allows you to *do nothing* when an error crops
    up. Is that a blatant contradiction? No. It is possible to write code that copes
    with an inconsistent world, that can carry on correctly in the face of an error—but
    it often gets quite convoluted. If you adopt this approach, you must make it obvious
    in the code. Don't risk having it misinterpreted as ignorant and incorrect.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以编写代码，当出现错误时，你可以什么也不做。这是明显的矛盾吗？不。可以编写代码来处理不一致的世界，面对错误时可以正确继续——但这通常会很复杂。如果你采用这种方法，必须在代码中明确表示。不要冒险让它被误解为无知和不正确。
- en: '**KEY CONCEPT**'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Ignoring errors does not save time. You''ll spend far longer working out the
    cause of bad program behavior than you ever would have spent writing the error
    handler*.'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '*忽略错误并不能节省时间。你将花费更多的时间来解决糟糕的程序行为的原因，而不是编写错误处理程序*。'
- en: '**Propagate**'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '**传播**'
- en: 'When a subordinate function call fails, you probably can''t carry on, but you
    might not know what else to do. The only option is to clean up and propagate the
    error report upward. You have options. There are two ways to propagate an error:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个从属函数调用失败时，你可能无法继续，但你可能不知道还能做什么。唯一的选择是清理并向上传播错误报告。你有选择。传播错误有两种方式：
- en: Export the same error information you were fed (return the same reason code
    or propagate exceptions).
  id: totrans-1392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出你被提供相同的错误信息（返回相同的原因代码或传播异常）。
- en: Reinterpret the information, sending a more meaningful message to the next level
    up (return a different reason code or catch and wrap up exceptions).
  id: totrans-1393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新解释信息，向更高一级发送更有意义的消息（返回不同的原因代码或捕获并封装异常）。
- en: 'Ask yourself this question: Does the error relate to a concept exposed through
    the module interface? If so, it''s okay to propagate that same error. Otherwise,
    recast it in the appropriate light, choosing an error report that makes sense
    in the context of your module''s interface. This is a good self-documenting code
    technique.'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己这个问题：错误是否与通过模块接口公开的概念相关？如果是这样，传播相同的错误是可以的。否则，将其重新塑造成适当的光环，选择在模块接口上下文中合理的错误报告。这是一种良好的自文档化代码技术。
- en: Code Implications
  id: totrans-1395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码影响
- en: '*Show me the code!* Let''s spend some time investigating the implications of
    error handling in our code. As we''ll see, it is not easy to write good error
    handling that doesn''t twist and warp the underlying program logic.'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '*给我看看代码!* 让我们花些时间调查我们代码中错误处理的影响。正如我们将看到的，编写不扭曲和扭曲底层程序逻辑的良好错误处理并不容易。'
- en: 'The first piece of code we''ll look at is a common error handling structure.
    Yet it isn''t a particularly intelligent approach for writing error-tolerant code.
    The aim is to call three functions sequentially—each of which may fail—and perform
    some intermediate calculations along the way. Spot the problems with this:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一段代码是一个常见的错误处理结构。然而，它并不是编写容错代码的特别明智的方法。目标是依次调用三个函数——每个函数都可能失败——并在过程中执行一些中间计算。找出这个结构的问题：
- en: '[PRE29]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Syntactically it's fine; the code will work. Practically, it's an unpleasant
    style to maintain. The more operations you need to perform, the more deeply nested
    the code gets and the harder it is to read. This kind of error handling quickly
    leads to a rat's nest of conditional statements. It doesn't reflect the actions
    of the code very well; each intermediate calculation could be considered the same
    level of importance, yet they are nested at different levels.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，代码没问题；代码会正常工作。但从实际维护的角度来看，这种风格并不令人愉快。你需要执行的操作越多，代码嵌套得越深，阅读起来就越困难。这种错误处理方式很快就会导致条件语句变得一团糟。它并不能很好地反映代码的行为；每个中间计算都可以被认为是同等重要，但它们被嵌套在不同的层级。
- en: '**CRAFTING ERROR MESSAGES**'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建错误消息**'
- en: Inevitably, your code will encounter errors that the user must sort out. Human
    intervention may be the only option; your code can't insert a floppy disk or switch
    on the printer by itself. (If it can, you'll make a fortune!)
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免地，你的代码会遇到用户必须解决的错误。人工干预可能是唯一的选择；你的代码不能自己插入软盘或打开打印机。（如果它能，你将发大财！）
- en: 'If you''re going to whine at the user, there are a few general points to bear
    in mind:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算向用户抱怨，有几个一般性要点需要记住：
- en: 'Users don''t think like programmers, so present information the way *they''d
    expect*. When displaying the free space on a disk, you might report `Disk space:
    10K`. But if there''s no space left, a zero could be misread as OK—and the user
    will not be able to fathom why he can''t save a file when the program says everything''s
    fine.'
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户思考方式与程序员不同，所以以*他们期望的方式*呈现信息。当显示磁盘上的可用空间时，你可能会报告`磁盘空间：10K`。但如果空间已满，零可能会被误读为正常——并且用户将无法理解为什么当程序说一切正常时，他无法保存文件。
- en: Make sure your messages aren't too cryptic. You might understand them, but can
    your computer-illiterate granny? (It doesn't matter if your granny won't use this
    program—someone with a lower intellect almost certainly will.)
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的消息不要太晦涩。你可能能理解它们，但你的电脑盲奶奶能理解吗？（即使你的奶奶不会使用这个程序——几乎肯定会有智力较低的人会使用。）
- en: Don't present meaningless error codes. No user knows what to do when faced with
    an `Error code 707E`. It is, however, valuable to provide such codes as "additional
    info"—they can be quoted to tech support or looked up more easily on a web search.
  id: totrans-1405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要展示无意义的错误代码。没有用户知道面对`错误代码 707E`时该怎么做。然而，将这些代码作为“附加信息”提供是有价值的——它们可以被引用给技术支持，或者在网络上更容易地搜索到。
- en: 'Distinguish dire errors from mere warnings. Incorporate this information in
    the message text (perhaps with an `Error`: prefix), and emphasize it in message
    boxes with an accompanying icon.'
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分严重错误和普通警告。在消息文本中包含这些信息（可能使用`Error`：前缀），并在消息框中使用伴随图标强调。
- en: 'Only ask a question (even a simple one like *Continue: Yes/No?*) if the user
    fully understands the ramifications of each choice. Explain it if necessary, and
    make it clear what the consequence of each answer is.'
  id: totrans-1407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当用户完全理解每个选择的后果时，才提出问题（即使是一个简单的问题，如*继续：是/否？*）。如果需要，解释它，并清楚地说明每个答案的后果。
- en: What you present to the user will be determined by interface constraints and
    application or OS style guides. If your company has user interface engineers,
    then it's their job to make these decisions. Work with them.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 你向用户展示的内容将由界面约束和应用程序或操作系统风格指南决定。如果你的公司有用户界面工程师，那么这是他们的职责来做出这些决定。与他们合作。
- en: 'Can we avoid these problems? Yes—there are a few alternatives. The first variant
    flattens the nesting. It is semantically equivalent, but it introduces *some*
    new complexity, since flow control is now dependent on the value of a new status
    variable, `ok`:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能避免这些问题吗？是的——有几个替代方案。第一个变体简化了嵌套。它在语义上是等价的，但它引入了*一些*新的复杂性，因为流程控制现在依赖于一个新的状态变量`ok`的值：
- en: '[PRE30]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ve also added an opportunity to clean up after any errors. Is that sufficient
    to mop up all failures? Probably not; the necessary cleanup may depend on how
    far we got through the function before lightening struck. There are two cleanup
    approaches:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增加了一个在出现任何错误后进行清理的机会。这足以清理所有失败吗？可能不够；必要的清理可能取决于我们在闪电击中之前在函数中走了多远。有两种清理方法：
- en: Perform a little cleanup after each operation that may fail, then return early.
    This inevitably leads to duplication of cleanup code. The more work you've done,
    the more you have to clean up, so each exit point will need to do gradually more
    unpicking.
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次可能失败的运算之后进行一点清理，然后提前返回。这不可避免地导致清理代码的重复。你完成的工作越多，需要清理的也就越多，因此每个退出点都需要逐渐进行解包。
- en: If each operation in our example allocates some memory, each early-exit point
    will have to release all allocations made to date. The further in, the more releases.
    That will lead to some quite dense and repetitive error-handling code, which makes
    the function far larger and far harder to understand.
  id: totrans-1413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们示例中的每个操作都分配了一些内存，每个提前退出的点都必须释放迄今为止所做的所有分配。越往里，释放的次数就越多。这将导致一些相当密集和重复的错误处理代码，使得函数变得更大，更难以理解。
- en: Write the cleanup code once, at the end of the function, but write it in such
    a way as to only clean up what's dirty. This is neater, but if you inadvertently
    insert an early return in the middle of the function, the cleanup code will be
    bypassed.
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将清理代码一次性写在函数的末尾，但要写成只清理脏东西的样子。这样更整洁，但如果你在函数中间不小心插入了一个提前返回，清理代码就会被绕过。
- en: 'If you''re not overly concerned about writing *Single Entry, Single Exit (SESE)*
    functions, this next example removes the reliance on a separate control flow variable.^([[5](#ftn.CHP-6-FN-5)])
    We do lose the cleanup code again, though. Simplicity renders this a better description
    of the actual intent:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太关心编写*单入口，单出口（SESE）*函数，接下来的例子就消除了对单独控制流变量的依赖.^([[5](#ftn.CHP-6-FN-5)]) 尽管如此，我们再次失去了清理代码。简单性使得这成为对实际意图的更好描述：
- en: '[PRE31]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A combination of this short-circuit exit with the requirement for cleanup leads
    to the following approach, especially seen in low-level systems code. Some people
    advocate it as the *only* valid use for the maligned `goto`. I'm still not convinced.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 这种短路退出与清理要求的结合导致以下方法，尤其是在底层系统代码中尤为常见。有些人提倡这是被诟病的`goto`的唯一有效用途。我仍然不这么认为。
- en: '[PRE32]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can avoid such monstrous code in C++ using *Resource Acquisition Is Initialization
    (RAII)* techniques like smart pointers. (Stroustrup 97) This has the bonus of
    providing exception safety—when an exception terminates your function prematurely,
    resources are automatically deallocated. These techniques avoid a lot of the problems
    we've seen above, moving complexity to a separate flow of control.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用C++中的*资源获取即初始化（RAII）*技术，如智能指针，来避免这样的糟糕代码。（Stroustrup 97）这有一个好处，就是提供异常安全性——当异常提前终止你的函数时，资源会自动释放。这些技术避免了我们上面看到的大多数问题，将复杂性转移到单独的控制流中。
- en: 'The same example using exceptions would look like this (in C++, Java, and C#),
    presuming that all subordinate functions do not return error codes but instead
    throw exceptions:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常的相同示例如下（在C++、Java和C#中），假设所有从属函数都不返回错误代码，而是抛出异常：
- en: '[PRE33]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is only a basic exception example, but it shows just how neat exceptions
    can be. A sound code design might not need the `try`/`catch` block at all if it
    ensures that no resource is leaked and leaves error handling to a higher level.
    But alas, writing good code in the face of exceptions requires an understanding
    of principles beyond the scope of this chapter.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的异常示例，但它展示了异常可以多么整洁。良好的代码设计可能根本不需要`try`/`catch`块，如果它确保没有资源泄漏并将错误处理留给更高层次。但遗憾的是，面对异常编写好代码需要理解本章范围之外的原理。
- en: '* * *'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[5](#CHP-6-FN-5)]) Although this clearly isn't SESE, I contend that the previous
    example isn't, either. There *is* only one exit point, at the end, but the contrived
    control flow is simulating early exit—it *might as well* have multiple exits.
    This is a good example of how being bound by a rule like SESE can lead to bad
    code, unless you think carefully about what you're doing.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-6-FN-5)]) 虽然这显然不是SESE，但我认为先前的例子也不是。只有一个退出点，在最后，但人为的控制流模拟了提前退出——它*几乎可以*有多个退出。这是一个很好的例子，说明了受规则如SESE的约束可能导致糟糕的代码，除非你仔细思考你在做什么。
- en: Raising Hell
  id: totrans-1425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撒野
- en: 'We''ve put up with other people''s errors for long enough. It''s time to turn
    the tables and play the bad guy: Let''s raise some errors. When writing a function,
    erroneous things will happen that you''ll need to signal to your caller. Make
    sure you do—don''t silently swallow any failure. Even if you''re sure that the
    caller won''t know what to do in the face of the problem, it *must* remain informed.
    Don''t write code that lies and pretends to be doing something it''s not.'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经忍受了别人的错误很长时间了。是时候扭转局面，扮演坏人了：让我们引发一些错误。在编写函数时，会发生错误的事情，你需要通知你的调用者。确保你这样做——不要默默地吞下任何失败。即使你确信调用者面对问题不知道该怎么办，它**必须**保持知情。不要编写撒谎并假装正在做它没有做的事情的代码。
- en: Which reporting mechanism should you use? It's largely an architectural choice;
    obey the project conventions and the common language idioms. In languages with
    the facility, it is common to favor exceptions, but only use them if the rest
    of the project does. Java and C# really leave you with no choice; exceptions are
    buried deep in their execution run times. A C++ architecture may choose to forego
    this facility to achieve portability with platforms that have no exception support
    or to interface with older C code.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪种报告机制？这主要是一个架构选择；遵守项目约定和通用语言习惯。在具有此功能的语言中，通常倾向于使用异常，但只有当整个项目使用它们时才使用。Java和C#实际上让你别无选择；异常深深地埋藏在它们的执行运行时中。C++架构可能选择放弃此功能，以与没有异常支持的平台或与旧C代码接口的便携性。
- en: 'We''ve already seen strategies for propagating errors from subordinate function
    calls. Our main concern here is reporting fresh problems encountered during execution.
    How you determine these errors is your own business, but when reporting them,
    consider the following:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了从从属函数调用中传播错误的策略。我们在这里的主要关注点是报告执行过程中遇到的新问题。你如何确定这些错误是你的事，但在报告它们时，考虑以下因素：
- en: Have you cleaned up appropriately first? Reliable code doesn't leak resources
    or leave the world in an inconsistent state, even when an error occurs, unless
    it's *really* unavoidable. If you do either of these things, it must be documented
    carefully. Consider what will happen the next time your code is called if this
    error has manifested. Ensure it will still work.
  id: totrans-1429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否首先适当地清理了？可靠的代码不会泄露资源或使世界处于不一致的状态，即使在发生错误的情况下，除非它是**真的**不可避免的。如果你做了这两件事中的任何一件，你必须仔细记录。考虑如果这个错误再次发生，你的代码下次被调用时会发生什么。确保它仍然可以工作。
- en: Don't leak inappropriate information to the outside world in your error reports.
    Only return useful information that the caller understands and can act on.
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在错误报告中向外界泄露不适当的信息。只返回调用者理解并可以采取行动的有用信息。
- en: Use exceptions correctly. Don't throw an exception for unusual return values—the
    rare but not erroneous cases. Only use exceptions to signal circumstances where
    a function is not able to meet its contract. Don't use them non-idiomatically
    (i.e., for flow control).
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用异常。不要为不寻常的返回值抛出异常——罕见但不是错误的案例。只使用异常来表示函数无法满足其合同的情况。不要非习惯性地使用它们（即用于流程控制）。
- en: Consider using assertions (see "[Constraints](ch01s04.html#constraints "Constraints")"
    on page 16) if you're trapping an error that should never happen in the normal
    course of program execution, a genuine programming error. Exceptions are a valid
    choice for this too—some assertion mechanisms can be configured to throw exceptions
    when they trigger.
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在捕获在程序执行过程中不应该发生的错误，即真正的编程错误，考虑使用断言（见第16页的“[约束](ch01s04.html#constraints
    "约束")”）。异常也是这个问题的有效选择——一些断言机制可以在触发时配置为抛出异常。
- en: If you can pull forward any tests to compile time, then do so. The sooner you
    detect and rectify an error, the less hassle it can cause.
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以在编译时提前提取任何测试，那么就这样做。你越早检测和纠正错误，它造成的麻烦就越少。
- en: Make it hard for people to ignore your errors. Given half a chance, someone
    *will* use your code badly. Exceptions are good for this—you have to act deliberately
    to hide an exception.
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让人们难以忽视你的错误。给半点机会，有人**会**糟糕地使用你的代码。异常在这方面很好——你必须故意行动才能隐藏异常。
- en: 'What kind of errors should you be looking out for? This obviously depends on
    what the function is doing. Here''s a checklist of the general kinds of error
    checks you should make in each function:'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意哪些类型的错误？这显然取决于函数正在做什么。以下是在每个函数中你应该进行的通用错误检查清单：
- en: Check all function parameters. Ensure you have been given correct and consistent
    input. Consider using assertions for this, depending on how strictly your contract
    was written. (Is it an offense to supply bad parameters?)
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有函数参数。确保你得到了正确和一致输入。根据你的合同写得有多严格，考虑使用断言。 （提供错误的参数是违法的吗？）
- en: Check that invariants are satisfied at interesting points in execution.
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查在执行过程中的有趣点是否满足不变性。
- en: Check all values from external sources for validity before you use them. File
    contents and interactive input must be sensible, with no missing pieces.
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用之前，检查所有来自外部源的数据的有效性。文件内容和交互式输入必须是合理的，不能有缺失的部分。
- en: Check the return status of all system and other subordinate function calls.
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有系统和其他从属函数调用的返回状态。
- en: '**AN EXCEPTION TO THE RULE**'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则的一个例外**'
- en: Exceptions are a powerful error reporting mechanism. Used well, they can simplify
    your code greatly while helping you to write robust software. In the wrong hands,
    though, they are a deadly weapon.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一个强大的错误报告机制。使用得当，它们可以极大地简化你的代码，同时帮助你编写健壮的软件。然而，如果落入错误之手，它们则可能成为致命的武器。
- en: 'I once worked on a project where it was routine for programmers to break a
    `while` loop or end recursion by throwing an exception, using it as a non-local
    `goto`. It''s an intersting idea, and kind of cute when you first see it. But
    this behavior is nothing more than an abuse of exceptions: It isn''t what exceptions
    are idiomatically used for. More than one critical bug was caused by a maintenance
    programmer not understanding the flow of control through a complex, magically
    terminated loop.'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经在一个项目中工作，程序员们习惯于通过抛出异常来打破 `while` 循环或结束递归，将其用作非局部 `goto`。这是一个有趣的想法，当你第一次看到它时，它有点可爱。但这种行为不过是滥用异常：这不是异常习惯用法所用的。由于维护程序员没有理解通过一个复杂、神奇终止的循环的控制流，导致了一个以上的关键错误。
- en: Follow the idioms of your language, and don't write cute code for the sake of
    it.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循你语言的习语，不要为了追求花哨而编写代码。
- en: Managing Errors
  id: totrans-1444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误管理
- en: 'The common principle uniting the raising and handling of errors is to have
    a consistent strategy for dealing with failure, wherever it manifests. These are
    general considerations for managing the occurrence, detection, and handling of
    program errors:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误抛出和处理统一的原则是，无论错误在哪里显现，都要有一个一致的策略来处理失败。这些是管理程序错误发生、检测和处理的一般性考虑：
- en: Avoid things that *could* cause errors. Can you do something that is guaranteed
    to work, instead? For example, avoid allocation errors by reserving enough resource
    beforehand. With an assured pool of memory, your routine cannot suffer memory
    restrictions. Naturally, this will only work when you know how much resource you
    need up front, but you often do.
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免可能导致错误的事情。你能做的是保证一定能成功的事情吗？例如，通过事先预留足够的资源来避免分配错误。有了确保的内存池，你的程序不会受到内存限制。当然，这只有在你知道你需要多少资源的情况下才会有效，但你通常都知道。
- en: Define the program or routine's expected behavior under abnormal circumstances.
    This determines how robust the code needs to be and therefore how thorough your
    error handling should be. Can a function silently generate bad output, subscribing
    to the historic *GIGO* principle?^([[6](#ftn.CHP-6-FN-6)])
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义程序或例程在异常情况下的预期行为。这决定了代码需要有多健壮，因此决定了你的错误处理应该有多彻底。一个函数能否默默地生成错误的输出，遵循历史上的 *GIGO*
    原则？^([[6](#ftn.CHP-6-FN-6)])
- en: Clearly define which components are responsible for handling which errors. Make
    it explicit in the module's interface. Ensure that your client knows what will
    always work and what may one day fail.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确定义哪些组件负责处理哪些错误。在模块的接口中明确指出。确保你的客户端知道什么总是会工作，什么可能会有一天失败。
- en: 'Check your programming practice: *When* do you write error-handling code? Don''t
    put it off until later; you''ll forget to handle something. Don''t wait until
    your development testing highlights problems before writing handlers—that''s not
    an engineering approach.'
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的编程实践：你什么时候编写错误处理代码？不要推迟到以后；你可能会忘记处理某些事情。不要等到开发测试揭示了问题才编写处理程序——这不是一种工程方法。
- en: '**KEY CONCEPT**'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Write all error detection and handling* now, *as you write the code that may
    fail. Don''t put it off until later. If you must be evil and defer handling, at
    least write the detection scaffolding now*.'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在就编写所有错误检测和处理代码，就像你编写可能失败的代码一样。不要推迟到以后。如果你必须邪恶并推迟处理，至少现在就编写检测框架*。'
- en: When trapping an error, have you found a symptom or a cause? Consider whether
    you've discovered the source of a problem that needs to be rectified here or if
    you've discovered a symptom of an earlier problem. If it's the latter, then don't
    write reams of handling code here, put that in a more appropriate (earlier) error
    handler.
  id: totrans-1452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当捕获错误时，你是否发现了症状或原因？考虑你是否已经发现了需要在此处纠正的问题根源，或者你是否发现了早期问题的症状。如果是后者，那么不要在这里编写大量的处理代码，而应该将其放入更合适（更早）的错误处理程序中。
- en: '* * *'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-6-FN-6)]) That is, *Garbage In, Garbage Out*—feed it trash, and
    it will happily spit out trash.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-6-FN-6)]) 即，*垃圾输入，垃圾输出*——给它垃圾，它会高兴地吐出垃圾。
- en: In a Nutshell
  id: totrans-1455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: To err is human; to repent, divine; to persist, devilish.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 犯错误是人类的天性；悔改是神圣的；坚持是魔鬼般的。
- en: --Benjamin Franklin
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: --本杰明·富兰克林
- en: To err *is* human (but computers seem quite good at it, too). To handle these
    errors is divine.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 人类会犯错误（但计算机似乎也很擅长这一点）。处理这些错误是神圣的。
- en: Every line of code you write must be balanced by appropriate and thorough error
    checking and handling. A program without rigorous error handling will not be stable.
    One day an obscure error may occur, and the program will fall over as a result.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的每一行代码都必须通过适当的和彻底的错误检查和处理来平衡。没有严格错误处理的程序将不会稳定。总有一天会发生一个难以捉摸的错误，程序将因此崩溃。
- en: Handling errors and failure cases is hard work. It bogs programming down in
    the mundane details of the Real World. However, it's absolutely essential. As
    much as 90 percent of the code you write handles exceptional circumstances. (Bentley
    82) That's a surprising statistic, so write code *expecting* to put far more effort
    into the things that can go wrong than the things that will go right.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误和失败情况是项艰巨的工作。它使编程陷入现实世界的平凡细节。然而，这是绝对必要的。你编写的代码中高达90%处理的是异常情况。（Bentley 82）这是一个令人惊讶的统计数据，因此编写代码时*预期*将更多精力投入到可能出错的事情上，而不是那些可能正确的事情上。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
  zh: '| 优秀的程序员... | 次要的程序员... |'
- en: '| --- | --- |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Combine their good intentions with good coding practices
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将他们的良好意图与良好的编码实践相结合
- en: Write the error-handling code *as* they write the main code
  id: totrans-1465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写主要代码的同时编写错误处理代码
- en: Are *thorough* in the code they write, covering every error possibility
  id: totrans-1466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在他们编写的代码中，*彻底*地处理，覆盖每一个错误可能性
- en: '|'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Take a haphazard approach to writing code, with neither thought to nor review
    of what they're doing
  id: totrans-1468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以随意的方式编写代码，既不考虑他们正在做什么，也不进行审查
- en: Ignore the errors that arise as they write code
  id: totrans-1469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略在编写代码时出现的错误
- en: End up conducting lengthy debugging sessions to track down program crashes,
    because they never considered error conditions in the first place
  id: totrans-1470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终会进行漫长的调试会话来追踪程序崩溃，因为他们从未首先考虑错误条件。
- en: '|'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-1472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 防御性编程")'
- en: Handing errors in context is one of the many defensive programming techniques.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中处理错误是许多防御性编程技术之一。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 写作技巧")'
- en: Self-documenting code ensures that error handling is integral to the code narrative.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 自文档化的代码确保错误处理是代码叙述的组成部分。
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章. 寻找错误")'
- en: Unhandled error conditions will manifest as bugs in the code. Here's how to
    squash them. (It's best to avoid them in the first place, though.)
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的错误条件将表现为代码中的错误。这是如何消除它们的。（最好一开始就避免它们。）
- en: '![See Also](tagoreillycom20080909nostarchimages207460.png.jpg)'
  id: totrans-1479
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207460.png.jpg)'
- en: Get Thinking
  id: totrans-1480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 487.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 在第487页的"[附录A](apa.html "附录A. 答案与讨论")"部分可以找到对这些问题的详细讨论。
- en: Mull It Over
  id: totrans-1482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: Are *return values* and *exceptions* equivalent error reporting mechanisms?
    Prove it.
  id: totrans-1483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回值*和*异常*是否是等效的错误报告机制？证明它。'
- en: What different implementations of *tuple* return types can you think of ? Don't
    limit yourself to a single programming language. What are the pros and cons of
    using tuples as a return value?
  id: totrans-1484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到哪些不同实现的*元组*返回类型？不要局限于单一编程语言。使用元组作为返回值的优缺点是什么？
- en: How do exception implementations differ between languages?
  id: totrans-1485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同语言中的异常实现有何不同？
- en: Signals are an old-school Unix mechanism. Are they still needed now that we
    have modern techniques like exceptions?
  id: totrans-1486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号是一种老式的Unix机制。现在我们有像异常这样的现代技术，它们仍然需要吗？
- en: What is the best code structure for error handling?
  id: totrans-1487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理的最佳代码结构是什么？
- en: How should you handle errors that occur in your error-handling code?
  id: totrans-1488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何处理在错误处理代码中发生的错误？
- en: Getting Personal
  id: totrans-1489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个性化
- en: How thorough is the error handling in your current codebase? How does this contribute
    to the stability of the program?
  id: totrans-1490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你当前代码库中的错误处理有多彻底？这如何有助于程序的稳定性？
- en: Do you naturally consider error handling as you write code, or do you find it
    a distraction, preferring to come back to it later?
  id: totrans-1491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在编写代码时自然地考虑错误处理，还是觉得它是一种干扰，更愿意稍后再回来处理？
- en: Go to the last (reasonably sized) function you wrote or worked on, and perform
    a careful review of the code. Find every abnormal occurence and potential error
    situation. How many of these were actually handled in your code?
  id: totrans-1492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去查看你最近（合理大小）编写的或参与工作的函数，并对代码进行仔细审查。找出每一个异常情况及潜在的错误情况。这些中有多少在你的代码中得到了处理？
- en: Now get someone else to review it. Don't be shy! Did they find any more? Why?
    What does this tell you about the code you're working on?
  id: totrans-1493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让其他人来审查它。不要害羞！他们发现了更多吗？为什么？这对你正在工作的代码有什么启示？
- en: Do you find it easier to manage and reason about error conditions using *return
    values* or *exceptions*? Are you sure you know what is involved in writing exception-safe
    code?
  id: totrans-1494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你觉得使用*返回值*还是*异常*来管理错误条件更容易，更合理吗？你确定你知道编写异常安全代码涉及哪些内容吗？
