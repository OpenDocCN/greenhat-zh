- en: Part I. AT THE CODEFACE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programmers write programs. It doesn''t take a genius to figure that one out.
    But there is a more subtle distinction: Only good programmers habitually write
    good code. Bad programmers . . . *don''t*. They create messes that take more effort
    to fix than they did to write.'
  prefs: []
  type: TYPE_NORMAL
- en: Which would you rather be?
  prefs: []
  type: TYPE_NORMAL
- en: Code craft starts at the codeface; it's where we love to be. We programmers
    are never happier than when immersed in an editor, bashing out line after line
    of perfectly formed and well-executed source code. We'd be quite happy if the
    world around us disappeared in a puff of boolean logic. Sadly, the Real World
    isn't going anywhere—and it doesn't seem willing to keep itself to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Around your carefully crafted code, the world is in a chaotic state of change.
    Almo st every software project is characterized by flux: changing requirements,
    changing budgets, changing deadlines, changing priorities, and changing teams.
    These all conspire to make writing good code a very difficult job. Welcome to
    the Real World.'
  prefs: []
  type: TYPE_NORMAL
- en: Good programmers naturally write neat code when left to their own devices. But
    theyalso have an array of battle tactics to help write robust code *on the front
    line*. They know how to defend themselves against the harsh realities of the software
    factory and write code that can survive the whirlwinds of change.
  prefs: []
  type: TYPE_NORMAL
- en: That's what we're looking at here. This first section delves into the painfully
    practical, gory details of code construction, the nuts and bolts of writing source
    code statements. You'll learn strategies to keep yourself afloat on the turbulent
    software development ocean and will be challenged to improve your code-writing
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'These chapters focus on the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defensive programming: How to write robust code when the world is conspiring
    against you.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Good presentation: why it''s important and how to present code well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing clear names for the parts of your program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: Self-documenting code. Practical strategies to explain code when you can't write
    a whole novel.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  prefs: []
  type: TYPE_NORMAL
- en: Effective techniques for writing the most appropriate code comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. TO ERR IS HUMAN")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling errors: How to manage operations that *might* go wrong, and what to
    do when they do.'
  prefs: []
  type: TYPE_NORMAL
- en: These form the path to sound code in an unsound world; they are solid code-writing
    techniques that should become second nature. If you don't write clear, understandable,
    defensive, easily testable, easily maintainable software, then you'll be distracted
    by tedious code-related problems when you should be preparing for what the software
    factory willthrow at you next.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1. ON THE DEFENSIVE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Defensive Programming Techniques for Robust Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have to distrust each other. It's our only defense against betrayal.
  prefs: []
  type: TYPE_NORMAL
- en: --Tennessee Williams
  prefs: []
  type: TYPE_NORMAL
- en: When my daughter was 10 months old, she liked playing with wooden bricks. Well,
    she liked playing with wooden bricks and *me*. I'd build a tower as high as I
    could, and then with a gentle nudge of the bottom brick, she'd topple the whole
    thing and let out a little whoop of delight. I didn't build these towers for their
    strength—it would have been pointless if I did. If I had really wanted a sturdy
    tower, then I'd have built it in a very different way. I'd have shorn up a foundation
    and started with a wide base, rather than just quickly stacking blocks upon each
    other and building as high as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Too many programmers write their code like flimsy towers of bricks; a gentle
    unexpected prod to the base, and the whole thing falls over. Code builds up in
    layers, and we need to use techniques that ensure that each layer is sound so
    that we can build upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Toward Good Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a huge difference between code that *seems* to work,*correct* code,
    and *good* code. M.A. Jackson wrote, "The beginning of wisdom for a software engineer
    is to recognize the difference between getting a program to work, and getting
    it *right*." ( Jackson 75) There is a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to write code that *works* most of the time. You feed it the usual
    set of inputs; it gives the usual set of outputs. But give it something surprising,
    and it might just fall over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Correct* code won''t fall over. For all possible sets of input, the output
    will be correct. But usually the set of all possible inputs is ridiculously large
    and hard to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, not all correct code is *good* code—the logic may be hard to follow,
    the code may be contrived, and it may be practically impossible to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By these definitions, good code is what we should aim for. It is robust, efficient
    enough and, of course, correct. Industrial strength code will not crash or produce
    incorrect results when given unusual inputs. It will also satisfy all other requirements,
    including thread safety, timing constraints, and re-entrancy.
  prefs: []
  type: TYPE_NORMAL
- en: It's one thing to write this good code in the comfort of your own home, a carefully
    controlled environment. It's an entirely different prospect to do so in the heat
    of the software factory, where the world is changing around you, the codebase
    is rapidly evolving, and you're constantly being faced with grotesque *legacy
    code* —archaic programs written by code monkeys that are now long gone. Try writing
    good code when the world is conspiring to stop you!
  prefs: []
  type: TYPE_NORMAL
- en: In this torturous environment, how do you ensure that your code is industrial
    strength? *Defensive programming* helps.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many ways to construct code (object-oriented approaches, component
    based models, structured design, Extreme Programming, etc.), defensive programming
    is an approach that can be applied universally. It's not so much a formal methodology
    as an informal set of basic guidelines. Defensive programming is not a magical
    cure-all, but a practical way to prevent a pile of potential coding problems.
  prefs: []
  type: TYPE_NORMAL
- en: Assume the Worst
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write code, it's all too easy to make a set of assumptions about how
    it should run, how it will be called, what the valid inputs are, and so on. You
    won't even realize that you've assumed anything, because it all seems obvious
    to you. You'll spend months happily crafting code, as these assumptions fade and
    distort in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: Or you might pick up some old code to make a vital last-minute fix when the
    product's going out the door in 10 minutes. With only enough time for a brief
    glance at its structure, you'll make assumptions about how the code works. There's
    no time to perform full literary criticism, and until you get a chance to prove
    the code is *actually* doing what you think it's doing, assumptions are all you
    have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assumptions cause us to write flawed software. It''s easy to assume:'
  prefs: []
  type: TYPE_NORMAL
- en: The function won't *ever* be called like that. I will always be passed valid
    parameters only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This piece of code will *always* work; it will never generate an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No one* will ever try to access this variable if I document it *For internal
    use only*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we program defensively, we shouldn't make *any* assumptions. We should
    never assume that *it can't happen*. We should never assume that the world works
    as we'd expect it to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experience tells us that the only thing you *can* be certain about is this:
    Your code *will* somehow, someday, go wrong. Someone *will* do a dumb thing. Murphy''s
    Law puts it this way: "If it can be used incorrectly, it will." Listen to that
    man—he spoke from experience.^([[1](#ftn.CHP-1-FN-1)]) Defensive programming prevents
    these accidents by foreseeing them, or at least fore-guessing them—figuring out
    what might go wrong at each stage in the code, and guarding against it.'
  prefs: []
  type: TYPE_NORMAL
- en: Is this paranoid? Perhaps. But it doesn't hurt to be a *little* paranoid. In
    fact, it makes a lot of sense. As your code evolves, you will forget the original
    set of assumptions you made (and real code does evolve—see [Chapter 15](ch15.html
    "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")). Other programmers
    won't have any knowledge of the assumptions in your head, or else they will just
    make their own invalid assumptions about what your code can do. Software evolution
    exposes weaknesses, and code growth hides original simple assumptions. A little
    paranoia at the outset can makecode a lot more robust in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Assume nothing. Unwritten assumptions continually cause faults, particularly
    as code grows*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add to this the fact that things neither you nor your users have any control
    over can go wrong: Disks fill up, networks fail, and computers crash. Bad things
    happen. Remember, it''s never actually your program that fails—the software always
    does what you told it to. The actual algorithms, or perhaps the client code, are
    what introduce faults into the system.'
  prefs: []
  type: TYPE_NORMAL
- en: As you write more code, and as you work through it faster and faster, the likelihood
    of making mistakes grows and grows. Without adequate time to verify each assumption,
    you can't write robust code. Unfortunately, on the programming front line, there's
    rarely any opportunity to slow down, take stock, and linger over a piece of code.
    The world is just moving too fast, and programmers need to keep up. Therefore,
    we should grasp every opportunity to reduce errors, and defensive practices are
    one of our main weapons.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-1-FN-1)]) Edward Murphy Jr. was a US Air Force engineer. He coined
    this infamous law after discovering a technician had systematically connected
    a whole row of devices upside down. Symmetric connectors permitted thisavoidable
    mistake; afterward, he chose a different connector design.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Defensive Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, defensive programming is careful, guarded programming.
    To construct reliable software, we design every component in the system so that
    it *protects* itself as much as possible. We smash unwritten assumptions by explicitly
    checking for them in the code. This is an attempt to prevent, or at least observe,
    when our code is called in a way that will exhibit incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defensive programming enables us to detect minor problems early on, rather
    than get bitten by them later when they''ve escalated into major disasters. All
    too often, you''ll see "professional" developers rush out code without thinking.
    The story goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What Is Defensive Programming?](tagoreillycom20080909nostarchimages207431.png)'
  prefs: []
  type: TYPE_IMG
- en: 'They are continually tripped up by the incorrect assumptions that they never
    took the time to validate. Hardly a promotion for modern day software engineering,
    but it''s happening all the time. Defensive programming helps us to write correct
    software from the start and move away from the *code-it*, *try-it*, *code-it*,
    *try-it* . . . cycle. With defensive programming, the story looks more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What Is Defensive Programming?](tagoreillycom20080909nostarchimages207435.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, defensive programming won't remove program failures altogether. But problems
    will become less of a hassle and easier to fix. Defensive programmers catch falling
    snowflakes rather than get buried under an avalanche of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming is a method of prevention, rather than a form of cure.
    Compare this to debugging—the act of removing bugs *after* they've bitten. Debugging
    is all about finding a cure.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT DEFENSIVE PROGRAMMING ISN''T**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few common misconceptions about defensive programming. Defensive
    programming is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error checking**'
  prefs: []
  type: TYPE_NORMAL
- en: If there are error conditions that might arise in your code, you should be checking
    for them anyway. This is not defensive code. It's just plain good practice—a part
    of writing *correct* code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your code is not defensive. It's another normal part of our development
    work. Test harnesses aren't defensive; they can prove the code is correct now,
    butwon't prove that it will stand up to future modification. Even with the best
    test suite in the world, anyone can make a change and slip it past untested.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: You might add some defensive code during a spell of debugging, but debugging
    is something you do after your program has failed. Defensive programming is somethingyou
    do to *prevent* your program from failing in the first place (or to detect failures
    early before they manifest in incomprehensible ways, demanding all-night debugging
    sessions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Is defensive programming really worth the hassle? There are arguments for and
    against:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The case** against'
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming consumes resources, both yours and the computer's.
  prefs: []
  type: TYPE_NORMAL
- en: It eats into the efficiency of your code; even a little extra code requires
    a little extra execution. For a single function or class, this might not matter,
    but when you have a system made up of 100,000 functions, you may have more of
    a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each defensive practice requires some extra work. Why should you follow any
    of them? You have enough to do already, right? Just make sure people use your
    code correctly. If they don't, then any problems are their own fault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The case** for'
  prefs: []
  type: TYPE_NORMAL
- en: The counterargument is compelling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defensive programming saves you literally hours of debugging and lets you do
    more fun stuff instead. Remember Murphy: If your code *can* be used incorrectly,
    it will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working code that runs properly, but ever-so-slightly slower, is *far* superior
    to code that works most of the time but occasionally collapses in a shower of
    brightly colored sparks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can design some defensive code to be physically removed in release builds,
    circumventing the performance issue. The majority of the items we'll consider
    here don't have any significant overhead, anyway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defensive programming avoids a large number of security problems—a serious issue
    in modern software development. More on this follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the market demands software that's built faster and cheaper, we need to focus
    on techniques that deliver results. Don't skip the bit of extra work up front
    that will prevent a whole world of pain and delay later.
  prefs: []
  type: TYPE_NORMAL
- en: The Big, Bad World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Someone once said, "Never ascribe to malice that which is adequately explained
    by stupidity."^([[2](#ftn.CHP-1-FN-2)]) Most of the time we are defending against
    stupidity, against invalid and unchecked assumptions. However there *are* malicious
    users, and they will try to bend and break your code to suit their vicious purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming helps with program security, guarding against this kind
    of willful misuse. Crackers and virus writers routinely exploit sloppy code to
    gain control of an application and then weave whatever wicked schemes they desire.
    This is a serious threat in the modern world of software development; it has huge
    implications in terms of the loss of productivity, money, and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Software abusers range from the opportunistic user exploiting a small program
    quirk to the hard-core cracker who spends his time deliberately trying to gain
    illicit access to your systems. Too many unwitting programmers leave gaping holes
    for these people to walk through. With the rise of the networked computer, the
    consequences of sloppiness become more and more significant.
  prefs: []
  type: TYPE_NORMAL
- en: Many large development corporations are finally waking up to this threat and
    are beginning to take the problem seriously, investing time and resources into
    serious defensive code work. In reality, it's hard to graft in defenses *after*
    an attack. We look at software security in more detail in [Chapter 12](ch12.html
    "Chapter 12. AN INSECURITY COMPLEX").
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for Defensive Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough of the background. What does all this mean to programmers working in
    the software factory?
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of common sense rules under the defensive programming umbrella.
    People usually think of *assertions* when they think of defensive programming,
    and rightly so. We'll talk about those later. But there's also a pile of simple
    programming habits that will immeasurably improve the safety of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Despite seeming common sense, these rules are often ignored—hence the low standard
    of most software at large in the world. Tighter security and reliable development
    can be achieved surprisingly easily, as long as programmers are alert and well
    informed.
  prefs: []
  type: TYPE_NORMAL
- en: The next few pages list the rules of defensive programming. We'll start off
    by painting with broad strokes, looking at high-level defensive techniques, processes,
    and procedures. As we progress, we'll fill in finer detail, looking more deeply
    at individual code statements. Some of these defensive techniques are language
    specific. This is natural—you have to put on bulletproof shoes if your language
    lets you shoot yourself in the foot.
  prefs: []
  type: TYPE_NORMAL
- en: As you read this list, evaluate yourself. How many of these rules do you currently
    follow? Which ones will you now adopt?
  prefs: []
  type: TYPE_NORMAL
- en: Employ a Good Coding Style and Sound Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can prevent most coding mistakes by adopting a good coding style. This naturally
    dovetails with the other chapters in this section. Simple things like choosing
    meaningful variable names and using parentheses judiciously can increase clarity
    and reduce the likelihood of faults slipping past unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, considering the larger-scale design before ploughing into the code
    is key. "The best documentation of a computer program is a clean structure." (Kernighan
    Plaugher 78) Starting off with a set of clear APIs to implement, a logical system
    structure, and well-defined component roles and responsibilities will avoid headaches
    further down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Don't Code in a Hurry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's all too common to see hit-and-run programming. Programmers quickly hack
    out a function, shove it through the compiler to check syntax, run it once to
    see if it works, and then move on to the next task. This approach is fraught with
    peril.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, think about each line as you write it. What errors could arise? Have
    you considered every logical twist that might occur? Slow, methodical programming
    seems mundane—but it really does cut down on the number of faults introduced.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*More haste, less speed. Always think carefully about what you''re typing as
    you typeit*.'
  prefs: []
  type: TYPE_NORMAL
- en: A particular C-family gotcha that snares speedy programmers is mistyping `==`
    as just `=`. The former is a test for equality; the latter a variable assignment.
    With an unhelpful compiler (or with warnings switched off) there will be no indication
    that the program behavior is not what was intended.
  prefs: []
  type: TYPE_NORMAL
- en: Always do *all* of the tasks involved in completing a code section before rushing
    on. For example, if you decide to write the main flow first and the error checking/handling
    second, you must be sure you have the discipline to do both. Be very wary of deferring
    the error checking and moving straight on to the main flow of three more code
    sections. Your intention to return later may be sincere, but later can easily
    become much later, by which time you will have forgotten much of the context,
    making it take longer and be more of a chore. (And of course, by then there will
    be some artificially urgent deadline.)
  prefs: []
  type: TYPE_NORMAL
- en: Discipline is a habit that needs to be learned and reinforced. Every time you
    don't do the right thing now, you become more likely to continue not doing the
    right thing in the future. Do it now; don't leave it for a rainy day in the Sahara.
    Doing it later actually requires *more* discipline than doing it now!
  prefs: []
  type: TYPE_NORMAL
- en: Trust No One
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your mother told you never to talk to strangers. Unfortunately, good software
    development requires even more cynicism and less faith in human nature. Even well-intentioned
    code users could cause problems in your program; being defensive means you can't
    trust anybody.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might suffer problems because of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Genuine users** accidentally giving bogus input or operating the program
    incorrectly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malicious users** trying to consciously provoke bad program behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client code** calling your function with the wrong parameters or supplying
    inconsistent input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The operating environment** failing to provide adequate service to the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External libraries** behaving badly and failing to honor interface contracts
    that you rely on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might even make a silly coding mistake in one function or forget how some
    three-year-old code is supposed to work and then use it badly. Don't assume that
    all will go well or that all code will operate correctly. Put safety checks in
    place throughout your work. Constantly watch for weak spots, and guard against
    them with extra-defensive code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Trust no one. Absolutely anyone—including yourself—can introduce flaws into
    your program logic. Treat all inputs and all results with suspicion until you
    can prove that they are valid*.'
  prefs: []
  type: TYPE_NORMAL
- en: Write Code for Clarity, Not Brevity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you can choose between concise (but potentially confusing) code and
    clear (but potentially tedious) code, use code that *reads* as intended, even
    if it's less elegant. For example, split complex arithmetic operations into a
    series of separate statements to make the logic clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Think about who might read your code. It might require maintenance work by a
    junior coder, and if he can't understand the logic, then he's bound to make mistakes.
    Complicated constructs or unusual language tricks might prove your encyclopedic
    knowledge of operator precedence, but it really butchers code maintainability.
    *Keep it simple*.
  prefs: []
  type: TYPE_NORMAL
- en: If it can't be maintained, your code is not safe. In really extreme cases, overly
    complex expressions can cause the compiler to generate incorrect code—many compiler
    optimization errors come to light this way.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simplicity is a virtue. Never make code more complex than necessary*.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't Let Anyone Tinker with Stuff They Shouldn't
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Things that are internal should stay on the inside. Things that are private
    should be kept under lock and key. Don't display your code's dirty laundry in
    public. No matter how politely you ask, people *will* fiddle with your data when
    you're not looking if given half a chance, and they *will* try to call "implementation-only"
    routines for their own reasons. Don't let them.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented languages, prevent access to internal class data by making
    it private. In C++, consider the Cheshire cat (or pimpl) idiom—a common technique
    for keeping a class's internal structure out of its public header file. (Meyers
    97)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In procedural languages, you can still employ object-oriented (OO) packaging
    concepts, by wrapping private data behind opaque types and providing well-defined
    public operations on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep all variables in the tightest scope necessary; don't declare variables
    globally when you don't have to. Don't put them at file scope when they can be
    function-local. Don't place them at function scope when they can be loop-local.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAY "WHEN"**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When* do you program defensively? Do you start when things go wrong? Or when
    you pick up some code you don''t understand?'
  prefs: []
  type: TYPE_NORMAL
- en: No, these defensive programming techniques should be used *all the time*. They
    shouldbe second nature. Mature programmers have learned from experience—they've
    been bitten enough times that they know to put sensible safeguards in place.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive strategies are much easier to apply as you start writing code, rather
    than retrofitting them into existentcode. You can't be thorough and accurate if
    you try to shoehorn in this stuff late in theday. If you start adding defensive
    code once something has gone wrong, you are essentially debugging—being reactive,
    notpreventative and proactive.
  prefs: []
  type: TYPE_NORMAL
- en: However, during the course of debugging, or even when adding new functionalityyou'll
    discover conditions that you'd like to verify. It's always a good time to adddefensive
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Compile with All Warnings Switched On
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most languages' compilers draw on a vast selection of error messages when you
    hurt their feelings. They will also spit out various *warnings* when they encounter
    potentially flawed code, like the use of a C or C++ variable before its assignment.^([[3](#ftn.CHP-1-FN-3)])
    These warnings can usually be selectively enabled and disabled.
  prefs: []
  type: TYPE_NORMAL
- en: If your code is full of dangerous constructs, you'll get pages and pages of
    warnings. Sadly, the common response is to disable compiler warnings or just ignore
    the messages. Don't do either.
  prefs: []
  type: TYPE_NORMAL
- en: '*Always* enable your compiler''s warnings. And if your code generates any warnings,
    fix the code immediately to silence the compiler''s screams. Never be satisfied
    with code that doesn''t compile quietly when warnings are enabled. The warnings
    are there for a reason. Even if there''s a particular warning you think doesn''t
    matter, don''t leave it in, or one day it will obscure one that *does* matter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Compiler warnings catch many silly coding errors. Always enable them. Make
    sure your code compiles silently*.'
  prefs: []
  type: TYPE_NORMAL
- en: Use Static Analysis Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiler warnings are the result of a limited *static analysis* of your code,
    a code inspection performed *before* the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: There are many separate static analysis tools available, like `lint` (and its
    more modern derivatives) for C and FxCop for .NET assemblies. Your daily programming
    routine should include use of these tools to check your code. They will pick up
    many more errors than your compiler alone.
  prefs: []
  type: TYPE_NORMAL
- en: Use Safe Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Or failing that, use dangerous data structures safely.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common security vulnerability results from *buffer overrun*.
    This is triggered by the careless use of fixed-size data structures. If your code
    writes into a buffer without checking its size first, then there is always potential
    for writing past the end of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s frighteningly easy to do, as this small snippet of C++ code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the length of the data in `source` is greater than 10 characters, its copy
    will extend beyond the end of `buffer`'s reserved memory. Then anything could
    happen. In the best case, the result would be data corruption—some other data
    structure's contents will be overwritten. In the worst case, a malicious user
    could exploit this simple error to put executable code on the program stack and
    use it to run his own arbitrary program, effectively hijacking the computer. These
    kinds of flaw are regularly exploited by system crackers—serious stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to avoid being bitten by these vulnerabilities: Don''t write such
    bad code! Use safer data structures that don''t allow you to corrupt the program—use
    a managed buffer like C++''s `string` class. Or systematically use safe operations
    on unsafe data types. The C++ code above can be secured by swapping `strcpy` for
    `strncpy`, a size-limited string copy operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check Every Return Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a function returns a value, it does so for a reason. Check that return value.
    If it is an error code, you *must* inspect it and handle any failure. Don't let
    errors silently invade your program; swallowing an error can lead to unpredictable
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to user-defined functions as well as standard library ones. Most
    of the insidious bugs you'll find arise when a programmer fails to check a return
    value. Don't forget that some functions may return errors through a different
    mechanism (i.e., the standard C library's *errno*). Always catch and handle appropriate
    exceptions at the appropriate level.
  prefs: []
  type: TYPE_NORMAL
- en: Handle Memory (and Other Precious Resources) Carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be thorough and release any resource that you acquire during execution. Memory
    is the example of this cited most often, but it is not the only one. Files and
    thread locks are other precious resources that we must use carefully. Be a good
    steward.
  prefs: []
  type: TYPE_NORMAL
- en: Don't neglect to close files or release memory because you think that the OS
    will clean up your program when it exits. You really don't know how long your
    code will be left running, eating up all file handles or consuming all the memory.
    You can't even be sure that the OS will cleanly release your resources—some OSes
    don't.
  prefs: []
  type: TYPE_NORMAL
- en: There is a school of thought that says, "Don't worry about freeing memory until
    you know your program works in the first place; only then add all the relevant
    releases." Just say no. This is a ludicrously dangerous practice. It will lead
    to many, many errors in your memory usage; you *will* inevitably forget to free
    memory in some places.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Treat all scarce resources with respect. Manage their acquisition and release
    carefully*.'
  prefs: []
  type: TYPE_NORMAL
- en: Java and .NET employ a garbage collector to do all this tedious tidying up for
    you, so you can just "forget" about freeing resources. Let them drop to the floor,
    since the run time sweeps up every now and then. It's a nice luxury, but don't
    be lulled into a false sense of security. You still have to think. You have to
    explicitly drop references to objects you no longer care about, or they won't
    be cleaned up; don't accidentally hold on to an object reference. Less advanced
    garbage collectors are also easily fooled by circular references (e.g., A refers
    to *B*, and *B* refers to *A*, but no one else cares about them). This could cause
    objects to never be swept up; a subtle form of memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize All Variables at Their Points of Declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a clarity issue. The intent of each variable is explicit if you initialize
    it. It's not safe to rely on rules of thumb like *If I don't initialize it, I
    don't care about the initial value*. The code will evolve. The uninitialized value
    may turn into a problem further down the line.
  prefs: []
  type: TYPE_NORMAL
- en: C and C++ compound this issue. If you accidentally use a variable without having
    initialized it, you'll get different results each time your program runs, depending
    on what garbage was in memory at the time. Declaring a variable in one place,
    assigning it later on, and then using it even later opens up a window for errors.
    If the assignment is ever skipped, you'll spend ages hunting down random behavior.
    Close the window by initializing every variable as you declare it; even if the
    value's wrong, the behavior will at least be predictably wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Safer languages (like Java and C#) sidestep this pitfall by defining an initial
    value for all variables. It's still good practice to initialize a variable as
    you declare it, which improves code clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Declare Variables as Late as Possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By doing this, you place the variable as close as possible to its use, preventing
    it from confusing other parts of the code. It also clarifies the code using the
    variable. You don't have to hunt around to find the variable's type and initialization;
    a nearby declaration makes it obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Don't reuse the same temporary variable in a number of places, even if each
    use is in a logically separate area. It makes later reworking of the code awfully
    complicated. Create a new variable each time—the compiler will sort out any efficiency
    concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Use Standard Language Facilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and C++ are nightmares in this respect. They suffer from many different revisions
    of their specifications, with more obscure cases left as implementation-specific
    *undefined behavior*. Today there are many compilers, each with subtly different
    behavior. They are mostly compatible, but there is still plenty of rope to hang
    yourself with.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly define which language version you are using. Unless mandated by your
    project (and there had better be a good reason), *don't* rely on compiler weirdness
    or any nonstandard extensions to the language. If there is an area of the language
    that is undefined, don't rely on the behavior of your particular compiler (e.g.,
    don't rely on your C compiler treating `char` as a `signed` value—others won't).
    Doing so leads to very brittle code. What happens when you update the compiler?
    What happens when a new programmer joins the team who doesn't understand the extensions?
    Relying on a particular compiler's odd behavior leads to *really* subtle bugs
    later in life.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Good Diagnostic Logging Facility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write some new code, you'll often include a lot of diagnostics to check
    what's going on. Should these really be removed after the event? Leaving them
    in will make life easier when you have to revisit the code, especially if they
    can be selectively disabled in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of diagnostic logging systems available to facilitate this.
    Many can be used in such a way that diagnostics have no overhead if not needed;
    they can be conditionally compiled out.
  prefs: []
  type: TYPE_NORMAL
- en: Cast Carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most languages allow you to *cast* (or convert) data from one type to another.
    This operation is some times more successful than others. If you try to convert
    a 64-bit integer into a smaller 8-bit data type, what will happen to the other
    56 bits? Your execution environment might suddenly throw an exception or silently
    degrade your data's integrity. Many programmers don't think about this kind of
    thing, and so their programs behave in unnatural ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you really want to use a cast, think carefully about it. What you''re saying
    to the compiler is, "Forget your type checking: I know what this variable is,
    you don''t." You''re ripping a big hole into the type system and walking straight
    through it. It''s unstable ground; if you make any kind of mistake, the compiler
    will just sit there quietly and mutter, "I told you so," under its breath. If
    you''re lucky (e.g., using Java or C#) the run time might throw an exception to
    let you know, but this depends on exactly what you''re trying to convert.'
  prefs: []
  type: TYPE_NORMAL
- en: C and C++ are particularly vague about the precision of data types, so don't
    make assumptions about data type interchangeability. Don't presume that int and
    `long` are the same size and can be assigned to one another, even if you can get
    away with it on *your* platform. Code migrates platforms, but bad code migrates
    badly.
  prefs: []
  type: TYPE_NORMAL
- en: The Fine Print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many low-level defensive construction techniques, all part of a sensible
    coding routine and a healthy distrust of the Real World. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Providing default behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: Most languages provide a `switch` statement; they document what happens in the
    `default` case. If the default case is erroneous, make that explicit in the code.
    If nothing happens, make *that* explicit in the code—that way the maintenance
    programmer will understand.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you write an `if` statement without an `else` clause, stop for
    a moment and consider whether you should handle the logical default case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Following language idioms**'
  prefs: []
  type: TYPE_NORMAL
- en: This simple piece of advice will ensure that your readers understand all of
    the code you have written. They'll make fewer bad assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking numeric limits**'
  prefs: []
  type: TYPE_NORMAL
- en: Even the most basic calculations may cause numeric variables to overflow or
    underflow. Be on the lookout for this. Language specifications or core libraries
    provide mechanisms for determining the capacity of standard types—use them. Make
    sure you know all the available numeric types, and what each is most suitable
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Check that each calculation is sound. For example, make sure you can't use values
    that would cause a *divide by zero* error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beingconst-***`correct`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'C/C++ programmers should be really vigilant about this—it will make life much
    easier. Make everything as `const` as you possibly can. It does two things: `const`
    qualifications act as code documentation, and `const` allows the compiler to spot
    silly mistakes that you make. It prevents you from modifying data that''s off-limits.'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've thought about the set of assumptions we make as we program. But how can
    we physically incorporate these assumptions into our software so they're not illusive
    problems waiting to emerge? Simply write a little extra code to check for each
    condition. This code acts as the documentation of each assumption, making it explicit
    rather than implicit.^([[4](#ftn.CHP-1-FN-4)]) In doing so, we're codifying the
    *constraints* on program functionality and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we want the program to do if a constraint is broken? Since this kind
    of constraint will be more than a simple detectable and correctable run-time error
    (we should already be checking for and handling those), it must be a flaw in the
    program logic. There are few possibilities for the program''s reaction:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn a blind eye to the problem, and hope that nothing will go wrong as a consequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give it an on-the-spot fine and allow the program to continue (e.g., print a
    diagnostic warning or log the error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go directly to jail; do not pass go (e.g., abort the program immediately, in
    a controlled or uncontrolled manner).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, it is invalid to call C's `strlen` function with a string pointer
    set to zero, because the pointer will be immediately dereferenced, so the latter
    two options are the most plausible candidates. It's probably most appropriate
    to abort the program immediately, since derefencing a null pointer can lead to
    all sorts of catastrophes on unprotected operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of different scenarios in which constraints are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preconditions**'
  prefs: []
  type: TYPE_NORMAL
- en: These are conditions that must hold true *before* a section of code is entered.
    If a precondition fails, it's due to a fault in the client code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Postconditions**'
  prefs: []
  type: TYPE_NORMAL
- en: These must hold true *after* a code block is left. If a postcondition fails,
    it's due to a fault in the supplier code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Invariants**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are conditions that hold true every time the program''s execution reaches
    a particular point: between loop passes, across method calls, and so on. Failure
    of an invariant implies a fault in the program logic.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Any other statement about a program's state at a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: The first two listed here are frustrating to implement without language support—if
    a function has multiple exit points,^([[5](#ftn.CHP-1-FN-5)]) then inserting a
    postcondition gets messy. Eiffel supports pre- and postconditions in the core
    language and can also ensure that constraint checks don't have any side effects.
  prefs: []
  type: TYPE_NORMAL
- en: However tedious, good constraints expressed in code make your program clearer
    and more maintainable. This technique is also known as *design by contract*, since
    constraints form an immutable contract between sections of code.
  prefs: []
  type: TYPE_NORMAL
- en: What to Constrain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of different problems you can guard against with constraints.
    For example, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Check all array accesses are within bounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert that pointers are not zero before dereferencing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that function parameters are valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanity check function results before returning them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove that an object's state is consistent before operating on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard any place in the code where you'd write the comment *We should never get
    here*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two of these examples are particularly C/C++ focused. Java and C#
    have their own ways of avoiding some of these pitfalls in the core language, as
    do other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just how much constraint checking should you do? Placing a check on every other
    line is a bit extreme. As with many things, the correct balance becomes clear
    as the programmer gets more mature. Is it better to have too much or too little?
    It is possible for too many constraint checks to obscure the code''s logic. "Readability
    is the best single criterion of program quality: If a program is easy to read,
    it is probably a good program; if it is hard to read, it probably isn''t good."
    (Kernighan Plaugher 76)'
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, putting pre- and postconditions in major functions plus invariants
    in the key loops is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of constraint checking is usually only required during the development
    and debugging stages of program construction. Once we have used the constraints
    to convince ourselves (rightly or wrongly) that the program logic is correct,
    we would ideally remove them so as not to incur an unnecessary run-time overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the wonders of modern technology, all of this is perfectly possible.
    The C and C++ standard libraries provide a common mechanism to implement constraints—`assert.
    assert` acts as a procedural firewall, testing the logic of its argument. It is
    provided as an alarm for the developer to show incorrect program behavior and
    should not be allowed to trigger in customer-facing code. If the assertion''s
    constraint is satisfied execution continues. Otherwise, the program aborts, producing
    an error message looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`assert` is implemented as a preprocessor macro, which means it sits more naturally
    in C than in C++. There are a number of more C++-sympathetic assertion libraries
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: To use `assert` you must `#include <assert.h>.` You can then write something
    like `assert(ptr != 0);` in your function. Preprocessor magic allows us to strip
    out assertions in a production build by specifying the `NDEBUG` flag to the compiler.
    All `asserts` will be removed, and their arguments will not be evaluated. This
    means that in production builds `asserts` have no overhead at all.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not assertions *should* be completely removed, as opposed to just
    being made nonfatal, is a debatable issue. There is a school of thought that says
    after you remove them, you are testing a *completely different* piece of code.^([[6](#ftn.CHP-1-FN-6)])
    Others say that the overhead of assertions is not acceptable in a release build,
    so they must be eliminated. (But how often do people profile execution to prove
    this?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, our assertions must not have any side effects. What would happen,
    for example, if you mistakenly wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The assertion will clearly never trigger in a debug build; its value is 6 (near
    enough *true* for C). However, in a release build, the `assert` line will be removed
    completely and the `printf` will produce different output. This can be the cause
    of subtle problems late in product development. It's quite hard to guard against
    bugs in the bug-checking code!
  prefs: []
  type: TYPE_NORMAL
- en: It's not difficult to envision situations where assertions might have even more
    subtle side effects. For example, if you `assert`(`invariants()`);, yet the `invariants()`
    function has a side effect, it's not easy to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Since assertions can be removed in production code, it is vital that only constraint
    testing is done with `assert`. Real error-condition testing, like memory allocation
    failure or filesystem problems, should be dealt with in ordinary code. You wouldn't
    want to compile that out of your program! Justifiable run-time errors (no matter
    how undesirable) should be detected with defensive code that can never be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Java has a `similar` assert mechanism.^([[7](#ftn.CHP-1-FN-7)]) It can be enabled
    and disabled by controls on the JVM, and throws an exception (`java.lang.AssertionError`)
    instead of causing an instant program abort. .NET provides an assertion mechanism
    in the framework's `Debug` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**OFFENSIVE PROGRAMMING?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The best defense is a good offense*.'
  prefs: []
  type: TYPE_NORMAL
- en: —*Proverb*
  prefs: []
  type: TYPE_NORMAL
- en: While writing this chapter, I wondered, *What's the opposite of defensive programming?*
    It's *offensive programming*, of course!
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of people I know who you could call offensive programmers.
    But I think there's more to this than swearing at your computer and never taking
    baths
  prefs: []
  type: TYPE_NORMAL
- en: It stands to reason that an offensive programming approach would be actively
    trying to *break* things in the code, rather than defending against problems.
    That is, actively attacking the code rather than securing it. I'd call that *testing*.
    As we'll see later in "[Who, What, When, and Why?](ch08s02.html "Who, What, When,
    and Why?")" on page 132, testing, when done properly, has an incredibly positive
    effect on your software construction. It improves code quality greatly and brings
    stability to the development process.
  prefs: []
  type: TYPE_NORMAL
- en: We should be all offensive programmers.
  prefs: []
  type: TYPE_NORMAL
- en: When you discover and fix a fault, it is good practice to slip in an assertion
    where the fault was fixed. Then you can ensure that you won't be bitten twice.
    If nothing else, this would act as a warning sign to people maintaining the code
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: A common C++/Java technique for writing class constraints is to add a single
    memberfunction called `bool invariant()` to each class. (Naturally this function
    should have no side effects.) Now an `assert` can be put at the beginning and
    end of each member function calling this invariant. (There should be no assertion
    at the beginning of a constructor or at the end of the destructor, for obvious
    reasons.) For example, a `circle` class's invariant may check that `radius !=
    0`; that would be invalid object state and could cause later calculations to fail
    (perhaps with a divide by zero error).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-1-FN-2)]) Some historians attribute this quote to Napoleon Bonaparte.
    Now there's a guy who knew something about defense.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-1-FN-3)]) Many languages (like Java and C#) classify this as an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-1-FN-4)]) This doesn't replace writing good documentation, though.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-1-FN-5)]) There is a theological debate about whether functions
    *should* have multiple exit points.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-1-FN-6)]) In practice, more may change between development and release
    builds of software—compiler optimization levels and the inclusion of debugging
    symbols, for example. Both of these can make subtle differences to execution and
    may obscure the manifestation of other faults. During even the earliest stages
    of development, testing should be performed equally with development and release
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-1-FN-7)]) It was added in JDK 1.4 and is not available in earlier
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw water for the siege, strengthen your defenses! Work the clay, tread the
    mortar, repair the brickwork!
  prefs: []
  type: TYPE_NORMAL
- en: --Nahum 3:14
  prefs: []
  type: TYPE_NORMAL
- en: It is important to craft code that is not just correct but is also good. It
    needs to document all the assumptions made. This will make it easier to maintain,
    and it will harbor fewer bugs. Defensive programming is a method of expecting
    the worst and being prepared for it. It's a technique that prevents simple faults
    from becoming elusive bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The use of codified constraints alongside defensive code will make your software
    far more robust. Like many other good coding practices (*unit testing*, for example—see
    "[The Types of Test](ch08s04.html "The Types of Test")" on page 138), defensive
    programming is about spending a little extra time wisely (and early) in order
    to save much more time, effort, and cost later. Believe me, this *can* save an
    entire project from ruin.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Care that their code is robust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure every assumption is explicitly captured in defensive code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want well-defined behavior for garbage input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think carefully about the code they write, as they write it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code that protects itself from other people's (or their own) stupidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Would rather not think about what could go wrong in their code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release code for integration that may fail and hope that someone else will sort
    it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave important information about how their code should be used locked in their
    heads, ready to be lost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply little thought to the code they are writing, resulting in unpredictable
    and unreliable software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Offensive programming*—say no more.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: When faults breach your careful defenses, you'll need a strategy to round them
    up.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming is a key technique for writing secure software systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: You must document pre- and postconditions; how else will anyone know they exist?
    If you have any constraints specified, then you can add defensive code to assert
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207440.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 463.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can you have *too much* defensive programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you add an assertion to your code for every bug you find and fix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should assertions conditionally compile away to nothing in production builds?
    If not, which assertions should remain in release builds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are exceptions a better form of defensive barrier than C-style assertions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should the defensive checking of pre- and postconditions be put *inside* each
    function, or around each important function *call*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are constraints a perfect defensive tool? What are their drawbacks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you *avoid* defensive programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you designed a *better* language, would defensive programming still be necessary?
    How could you do this?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does this show that C and C++ are flawed because they have so many areas for
    problems to manifest?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What sort of code do you not need to worry about writing defensively?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How carefully do you consider each statement that you type? Do you relentlessly
    check every function return code, even if you're *sure* a function will not return
    an error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you document a function, do you state the pre- and postconditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are they always implicit in the description of what the function does?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no pre- or postconditions, do you explicitly document this?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Many companies pay lip service to defensive programming. Does your team recommend
    it? Take a look at the codebase—do they really? How widely are constraints codified
    in assertions? How thorough is the error checking in each function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are you naturally paranoid enough? Do you look both ways before crossing the
    road? Do you eat your greens? Do you check for every potential error in your code,
    no matter how unlikely?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How easy is it to do this thoroughly? Do you forget to think about errors?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any ways to help yourself write more thorough defensive code?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2. THE BEST LAID PLANS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Layout and Presentation of Source Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stop judging by mere appearances, and make a right judgment.
  prefs: []
  type: TYPE_NORMAL
- en: --John 7:24
  prefs: []
  type: TYPE_NORMAL
- en: Coding style has been, is, and will continue to be the subject of holy wars
    among programmers—professional, amateur, and student—where, unfortunately, intense
    disagreements degrade into mere name-calling. *I'll show you where to stick your
    stupid brackets*.
  prefs: []
  type: TYPE_NORMAL
- en: The first company I ever worked for kick-started a process to define its internal
    coding standard. The guidelines were supposed to encompass several languages,
    defining common conventions and best practices. Months later, the group compiling
    the guidelines was still arguing about where to put brackets in C. I'm not sure
    if anyone ever followed the standard that was eventually produced.
  prefs: []
  type: TYPE_NORMAL
- en: Why *do* people get so worked up about this? As we'll see, presentation dramatically
    affects the readability of code—no one wants to work with code that isn't easy
    to read. Presentation is also a very subjective and personal thing—*you* may not
    like the style that turns *me* on. Familiarity breeds comfort, and an alien style
    puts you on edge.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers are passionate about code, so presentation stirs deep emotions.
  prefs: []
  type: TYPE_NORMAL
- en: What's the Big Deal?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The layout and presentation of code is an issue in most modern programming languages.
    The freedom of formatting that permits individual artistic expression came *en
    vogue* in the early 1960s with the language Algol; the previously available Fortran
    versions had been more restricted in format. Since then, very few languages have
    deviated from that free-form approach.
  prefs: []
  type: TYPE_NORMAL
- en: A code presentation style governs a surprisingly large number of things; brace
    positioning is the most obvious^([[1](#ftn.CHP-2-FN-1)]) and perhaps the most
    contentious issue. The wider aspects of code style, like conventions for function
    and variable naming, tie in with other coding concerns such as program structure
    (e.g.,*Don't use* *`gotos`*, or *Only write Single Entry, Single Exit functions*)
    to dictate the style in which you write a program. Altogether, this constitutes
    your *coding standard*.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are many individual choices to make when you define a code presentation
    format, all are aesthetic. By definition, presentation has no syntactic or semantic
    meaning at all; the compiler ignores it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, presentation makes a real impact on the quality of code. Programmers
    read meaning into code based on its layout. It can illuminate and support your
    code''s structure, helping the reader understand what''s going on. Or it can confuse,
    mislead, and hide the code''s intent. It doesn''t matter how well designed your
    program is; if it looks like a thrown-together mess, it will be unpleasant to
    work with. But bad formatting not only makes code harder to follow; it may actually
    *hide* bugs from you. As a simple example of this, consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The layout shows what the author meant to happen, but he'll be surprised when
    the code actually runs.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're conscientious craftsmen committed to high-quality code, we strive
    for clear presentation. There are already plenty of stumbling blocks in software
    development; we shouldn't let basic code presentation become one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-2-FN-1)]) *Brace* is a common name for the curly bracket (that is,
    { and }) so common in C-style programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Know Your Audience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write effective source code, it''s important to know *who* you''re presenting
    it to. If you''re going to confuse someone, you''d better know who deserves the
    apology. There are, in fact, three audiences for our source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ourselves**'
  prefs: []
  type: TYPE_NORMAL
- en: My handwriting is so bad that sometimes even *I* can't read it. It's practically
    useless unless I concentrate on writing clearly. It's the same with code. You
    have to be able to read what you've written immediately after you write it, but
    also perhaps years later when you come back to it. Who would have expected to
    come back to archaic (relatively speaking) COBOL code to fix a Y2K bug?
  prefs: []
  type: TYPE_NORMAL
- en: '**The compiler**'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler doesn't care what your code looks like, as long as it doesn't have
    any syntactic errors. The *intent* of the code is completely ignored. You can
    write detailed comments explaining what you *want* a function to do, but the compiler
    won't tell you if the instructions don't actually do what your comments say. As
    long as it's valid code, your development environment will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Others**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most important audience and often the least considered.
  prefs: []
  type: TYPE_NORMAL
- en: So you're working in a team, but you're the only person who will ever see your
    bit of code, right? Wrong. It never works that way.
  prefs: []
  type: TYPE_NORMAL
- en: You're at home writing some code for fun; no one will ever see it. You don't
    need to worry about making it neat, do you? No, you don't; but how would that
    benefit you? You aren't developing skills that will make you a professional. This
    is the perfect opportunity to practice really good discipline on a project with
    no external pressures. A chance to get into good habits. If you blow it here,
    is it any wonder you have no discipline on "real" projects?
  prefs: []
  type: TYPE_NORMAL
- en: Your source code is a document, describing the program you are creating. It
    needs to read clearly to whoever might come back to it. This will include those
    auditing (code reviewing) the work you have done and anyone who maintains it later.
    Be kind to people who have to look after your code—just imagine yourself in their
    shoes.
  prefs: []
  type: TYPE_NORMAL
- en: We tailor the elements of presentation style with our audiences in mind. How
    does the audience affect how we lay out code? Surprisingly, we care least of all
    about the compiler. Its job is to ignore all that unnecessary whitespace and get
    down to the serious business of interpreting our syntax. Presentation is not about
    syntactic meaning, and the compiler can cope with whatever freakish layout we
    throw at it.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, we use layout to emphasize the *logical structure* of the code to human
    readers. It's about communication, and the clearer the better.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Understand the real audience for your source code: other programmers. Write
    for their benefit*.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is Good Presentation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, good presentation means more than just being neat. Tidy code
    certainly gives an impression of high quality, but code can be both tidy *and*
    misleading. We strive for *clear* layout; the code structure must be *enhanced*
    by an indentation strategy, not hidden by it. If a particular flow of control
    is necessarily complex, the layout should be helping you to read the code. (If
    you've written a flow of control that is unnecessarily complex, you should change
    it immediately.)
  prefs: []
  type: TYPE_NORMAL
- en: Our code layout must convey meaning, rather than disguise it. I suggest the
    following as good metrics for the quality of a presentation style.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistent**'
  prefs: []
  type: TYPE_NORMAL
- en: The indentation strategy must be consistent across the project. Don't change
    styles halfway through a source file. Not only does this look unprofessional,
    it can confuse and give the impression that your source files are not really related.
  prefs: []
  type: TYPE_NORMAL
- en: The individual presentation rules should be internally consistent. The positioning
    of braces, brackets, and so on in different situations should all follow a single
    convention. The number of spaces of indent should always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernighan and Ritchie—the fathers of C—say, after stressing the importance
    of having good indentation: "The position of braces is less important, although
    people hold passionate beliefs. We have chosen one of several popular styles.
    Pick a style that suits you, then use it consistently." (Kernighan Ritchie 88)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conventional**'
  prefs: []
  type: TYPE_NORMAL
- en: It's sensible to adopt one of the major styles currently in use in the industry
    rather than invent your own indentation rules. You can be sure of it being accessible
    to others who are reading your code. And you're less likely to make people vomit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concise**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you concisely describe your indentation strategy? Think about it. If you
    do *this* unless *such-and-such*, in which caseyou do *this* if *X* holds; otherwise
    you do something else which depends on . . .
  prefs: []
  type: TYPE_NORMAL
- en: Someone may eventually need to extend the code you've written and should do
    so in the same style. If it's not easy to pick up, then is it really a useful
    presentation style?
  prefs: []
  type: TYPE_NORMAL
- en: Brace Yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the impact presentation has on source code and the trade-offs
    involved in choosing a particular style, this case study investigates an important
    C-related layout issue. By looking at the variation in this one simple area, we'll
    see how important presentation is and what a profound impact it has on your code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Brace positioning* is a big concern for the curly bracket languages, although
    it''s really only a fraction of the total code layout problem. As the most immediately
    visible artifact, it generates about 80 percent of the fuss. Other languages have
    their own similar layout concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of conventional brace positioning styles. Which you pick
    comes down to your sense of aesthetics, the culture you code in, and what you're
    used to. Different styles are appropriate in different contexts—consider a magazine
    article versus a source editor (see "[WELL PRESENTED](ch02s04.html#well_presented
    "WELL PRESENTED")" on page 28). You may prefer the exdented style, but in a magazine
    you're forced to use K&R to maximize use of the printed page.
  prefs: []
  type: TYPE_NORMAL
- en: K&R Brace Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*K&R* style is the oldest flavor, established by the fathers of C Kernighan
    and Ritchie in their book *The C Programming Language*. (Kernighan Ritchie 88)
    For this reason, it is often considered the *original and best*. It was driven
    by the need to display the most information possible on a small screen. It''s
    probably the dominant style for Java code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Pros**'
  prefs: []
  type: TYPE_NORMAL
- en: Takes up little room, so you can get more code on screen at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing brace lines up with the statement it matches, so you can scan up
    to find the construct being terminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**'
  prefs: []
  type: TYPE_NORMAL
- en: The braces don't line up, so it's hard to visually match them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might not notice if an opening brace goes off the right of the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code statements appear very densely packed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exdented Brace Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more spacious approach is the so-called *exdented* (or sometimes *Allman*)
    style. This is my personal favorite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Pros**'
  prefs: []
  type: TYPE_NORMAL
- en: A clear and uncluttered format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to scan code for opening braces since they're distinct; this makes each
    code block more obvious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**'
  prefs: []
  type: TYPE_NORMAL
- en: Takes up more vertical space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looks wasteful when you have lots of blocks containing only one statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much like Pascal for some hackers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WELL PRESENTED**'
  prefs: []
  type: TYPE_NORMAL
- en: 'How you present code depends on the context in which it will be read. There
    are more contexts than you might think. When you''re reading some code, it''s
    important to appreciate the forces that drove its presentation. The common code
    habitats are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source editor**'
  prefs: []
  type: TYPE_NORMAL
- en: This is most code's natural habitat. It raises all the presentation concerns
    programmers automatically think about. The code is read on a computer screen,
    usually in some dedicated editor or IDE. You scroll or navigate through a file
    to places of particular interest. It's an interactive world—more often than not,
    you're reading code to *make modifications*. This means that the code has to be
    malleable.
  prefs: []
  type: TYPE_NORMAL
- en: The editor may have horizontal scrollbars for long lines or may limit the page
    width and wrap them. Usually there's syntax coloring to aid comprehension. As
    you type, the editor performs some formatting work for you. For example, it intelligently
    positions the cursor on new lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Published code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you live in a lonely, isolated little world, you''ll regularly read
    published code. There are plenty of forums: listings in books and magazines, snippets
    fromlibrary documentation, or even lines in postings to newsgroups. These are
    formatted forclarity, but also favor a more compact representation since space
    is not cheap. Lines arecompressed vertically to get the most code into a short
    space, and they are compressed horizontally to fit into narrow print margins.'
  prefs: []
  type: TYPE_NORMAL
- en: This sort of code tends to omit error handling and anything not pertinent to
    the main idea of the example. It only serves to convey a point, not to be thorough.
  prefs: []
  type: TYPE_NORMAL
- en: You may never have to write code for this medium, but you'll certainly see plenty
    of it (you're reading code snippets in this *book*, at least). You need to understand
    the trade-offs and differences from normal code, so you don't unwittingly pick
    up any bad habits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Printouts**'
  prefs: []
  type: TYPE_NORMAL
- en: When you print out project code you run into new issues. Column widths become
    a problem. Should you reformat before you print, scale pages down and cope with
    small fonts, or have haphazard line wrapping? There's no syntax coloring to enhance
    presentation (unless you're rich enough for a color printer and all that ink),
    so messy commenting or code disabled by large comment blocks suddenlybecomes less
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may never print out a page of source, these are valid concerns
    that you should consider.
  prefs: []
  type: TYPE_NORMAL
- en: Indented Brace Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less common but still used is the *indented* style. Here the braces are indented
    with the code. It's also known as the *Whitesmith* style, since example code for
    the early Whitesmith's C compiler used it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: Links code blocks to the braces that contain them
  prefs: []
  type: TYPE_NORMAL
- en: '**Con**'
  prefs: []
  type: TYPE_NORMAL
- en: Many people don't like their blocks linked to their braces
  prefs: []
  type: TYPE_NORMAL
- en: Other Brace Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are others. For example, the *GNU* style is sandwiched between exdented
    and indented; braces are placed halfway between each level of indent. There are
    also hybrids; the Linux kernel coding style is half K&R, half exdented. Most C#
    programmers also combine layout styles. If you''re really perverse, you''ll like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I've seen plenty of surreal code like it, and I'm sure you could concoct something
    of equally nightmarish proportions if you tried.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recognize the common code layout styles for your chosen language, and become
    familiar working with each of them. Appreciate their advantages and disadvantages*.'
  prefs: []
  type: TYPE_NORMAL
- en: One Style to Rule Them All
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen seen what constitutes a good coding style, what it governs, and
    why it's necessary, you must now actually choose one. This is where the fights
    begin. Disciples of one presentation religion clash with the evangelists of the
    next, leading to programmer civil war. But the craftsman steps back from these
    petty squabbles and takes a more balanced view.
  prefs: []
  type: TYPE_NORMAL
- en: As long as you write in a style that's good, it doesn't matter what style that
    is. And there's no point in arguing about it. There is more than one good style;
    the quality and applicability of each will depend on context and culture.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pick a single* good *coding style, and stick to it*.'
  prefs: []
  type: TYPE_NORMAL
- en: It could be argued that if your language standard defined the One True Presentation
    Style, the world would be a better place. After all, all code would look the same.
    The arguments would cease, and we'd all move on to something more useful instead.
    You could pick up anyone's code and get to grips with it immediately. Sounds pretty
    good, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The counterargument is *competition is a Good Thing*. If we had a single monopoly
    coding style, who would be able to say that it was the best one? By having more
    than one coding style, we are encouraged to think and improve the way we apply
    a style. It encourages style guidelines to improve. The upshot: It makes us write
    better code.'
  prefs: []
  type: TYPE_NORMAL
- en: That argument is *not* a license to code in your own particular style, though.
    Remember that good presentation is *conventional*—a layout that readers expect.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON CODING STANDARDS**'
  prefs: []
  type: TYPE_NORMAL
- en: A number of well-known coding standards are generally used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indian Hill**'
  prefs: []
  type: TYPE_NORMAL
- en: The full title of this famous document is Indian *Hill Recommended C Styleand
    Coding Standards*. It has nothing to do with Native Americans standing on mounds
    of earth; instead, it came from the renowned Indian Hill AT&T Bell lab.
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The GNU''s Coding Standards* are important since they influence most of the
    commonly used open source or free software out there. You can find them on the
    GNU Project''s website ([www.gnu.org](http://www.gnu.org)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**MISRA**'
  prefs: []
  type: TYPE_NORMAL
- en: The UK's *Motor Industry Software Reliability Association (MISRA)* has defined
    a well-known set of standards for writing safety critical embedded software in
    C. It consists of 127 guidelines, and a number of tools exist to validate your
    code against them. These guidelines are focused more on language use than code
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project foo**'
  prefs: []
  type: TYPE_NORMAL
- en: Most every project under the sun defines its own pet coding style. Just go on
    a hunt, and you'll find literally thousands. The Linux kernel, for example, has
    its own guidelines, as does the Mozilla project.
  prefs: []
  type: TYPE_NORMAL
- en: House Styles (and Where to Stick Them)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many software companies have an internal (*house* ) coding stylethat defines,
    among other things, its code presentation rules. But why bother—code that's been
    written in any good style is easy to read and maintain. If no one will have ahard
    time following it, do we really need this extra level of bureaucracy?
  prefs: []
  type: TYPE_NORMAL
- en: 'House styles *are* important and useful for a number of reasons. If everyone
    sings from the same hymn book (perhaps that should be *writes* on the same hymn
    book), then all source code will be consistent and homogenized. What value does
    this bring? It increases the code quality and makes software development safer.
    Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: Any code released outside the organization will be neatly presented and coherent,
    appearing to be well thought out. Having many conflicting styles in one project
    looks careless and unprofessional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company can be assured that programs are written up to a certain standard,
    thanks to common idioms and methodologies. This doesn't guarantee good code, but
    it does help to protect against bad code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes up for poor tools; IDEs set in different ways will fight against each
    other, pulling code apart and generally molesting the layout. A standard provides
    level ground (and a common enemy for all the programmers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appeal of being able to instantly recognize the shape of your peers' code
    and to quickly make appropriate maintenance alterations is clear. It saves reading
    time and therefore the company's money.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the programmers won't be continually reformatting the code to suit their
    particular aesthetic fetishes, your version control history is very useful. If
    Fred reformats Bert's code to "his" style, what happens when, a bit later on,
    you look at a diff? Many diff tools are pretty crude and will now display a plethora
    of trivial whitespace and brace differences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These house coding standards are a Good Thing. Even if you don't actually agree
    with the rules they mandate—if, for example, your indentation strategy is much
    prettier and easier to understand (in your opinion)—it shouldn't matter one iota.
    The benefits of everyone sharing the same style outweigh the burden on you to
    have to conform. If you don't agree with the standard, you should still work to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your team already has a coding standard, then use it. Don''t use your own
    pet style*.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to find how much of your coding style is bred from familiarity
    and practice. If you use a house style for a while, it soon becomes second nature
    and seems perfectly normal.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you're working on code that originated from outside the company
    and doesn't conform to your house style? In this case, it makes more sense to
    write code conforming to the *existing* style of that source file. (This is why
    writing to a style that's easy to pick up is important.) The only other real alternative
    is to convert the file (and any others) into your house style. For most Real World
    projects, this latter course of action isn't feasible, especially if you are continually
    being fed with external source code updates.
  prefs: []
  type: TYPE_NORMAL
- en: Conform to the style of a given file or project, conform to your house style
    where this doesn't conflict, and sacrifice your own preferences. Don't surrender
    your style blindly, though; understand the benefits weighed against the costs.
    And what if your company doesn't have a house style? Push for one. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '![House Styles (and Where to Stick Them)](tagoreillycom20080909nostarchimages207444.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've been tasked to draw up a code presentation style where there currently
    is none. Good luck! You can be sure that everyone will have an opinion on what
    the style should contain and that no one will be completely satisfied with the
    end result. Techies are helpful like that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a coding standard is a delicate task, and it should be approached tactfully
    but firmly. Why? Dumping edicts upon a group of programmers will neither make
    you nor your standard popular. But if you don't emphasize how important it is,
    programmers will not embrace it and will continue coding in their own peculiar
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difficulty of this task depends on the people in the team:'
  prefs: []
  type: TYPE_NORMAL
- en: How many programmers there are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How they code as individuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How similar their coding styles are already
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether they actually *want* a standard or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether they are prepared to change their styles at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If their coding styles are all reasonably similar, then the job''s a breeze.
    If they vary wildly, you''re in for a bumpy ride. While people seldom agree on
    the best style, they will generally agree that some styles are better than others.
    You must aim to provide a sufficiently detailed set of layout directives while
    trying to satisfy as many programmers as possible—*and* produce something that
    will help them to work better as a team. Here''s a collection of pragmatic advice
    for this herculean task:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s it for?**'
  prefs: []
  type: TYPE_NORMAL
- en: Start off with a clear idea of the scope of the work—is the coding standard
    just for your immediate team, the department, or the whole company? This makes
    a big difference in how you'll develop and implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: What makes a good personal style is not necessarily the best for
    a whole team of programmers. You are creating something that shouldn''t just serve
    *your* aesthetic fetishes; it should be a standard that will unite team code and
    avoid common problems. Keep this goal in mind as your develop the standard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the level of detail you intend to go into. Is this just a code layout
    document, or will it also touch on language usage concerns? It''s best to keep
    it simple: Write one document for presentation and a different document for language
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get buy-in**'
  prefs: []
  type: TYPE_NORMAL
- en: Involve everyone on the team, so *they* own it. If the programmers feel like
    they contributed, they'll be more likely to follow the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Get everyone to agree that a standard is needed *before* you start working on
    it. Make sure the team understands the benefits of code consistency and the perils
    of ad-hoc code presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have more than a few programmers, *don't* try to design the standard
    by committee. Well, not unless you hide all the sharp objects in the office first.
    Select a small crack team to get the work done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the standard nears completion, review it with a panel of adopters. Make
    sure that you have a chairman who can make a final decision though, or everything
    will stall while 15 programmers sidetrack themselves in religious disputes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Produce something**'
  prefs: []
  type: TYPE_NORMAL
- en: The end product should be an accessible document, not just a fuzzy set of agreed
    conventions. You should be able to refer to the document later, and point newcomers
    at it. The document contains a list of the rules, perhaps with justification for
    the more contentious decisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Standardize best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the standard embodies the team's current best practices—let them know
    that they're doing things right. If there's nothing that comes out of the blue,
    they will be more likely to adopt it. However, if you include random conventions
    from outside the team's experience, they'll revolt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on what matters**'
  prefs: []
  type: TYPE_NORMAL
- en: Concentrate your efforts on the things that really matter and will make the
    biggest improvements to your team's code. Don't try to create a presentation standard
    for C, C++, *and* Java if you only ever use C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid hotspots**'
  prefs: []
  type: TYPE_NORMAL
- en: Leave rare-but-tedious cases to individual taste if they won't actually make
    much difference. If people get really worked up over the layout of split lines
    in an `if` statement, give up and let them do what they want.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be too restrictive; allow the rules to be broken if a violation can genuinely
    be justified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do it in pieces**'
  prefs: []
  type: TYPE_NORMAL
- en: A sensible approach is to develop your house style *a bit at a time*. Start
    by agreeing on brace layout and indent size. Just that. It will be difficult enough!
    Once you have that in place, progress will be *much* easier; any change is just
    more of the same. At some point, it won't be worth adding new rules, since the
    code will be sufficiently regular.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plan for adoption**'
  prefs: []
  type: TYPE_NORMAL
- en: Have a clear idea how this coding standard will be adopted. Be realistic. People
    have to be happier *with* it, or they won't use it. Adoption will have to be based
    on some form of majority rule; if Fred still thinks that `switch` statements look
    better his way when everyone else managed to compromise, *too bad, Fred*. Don't
    be tempted to make it a democratic process, though. That just won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Don't threaten people with the standard or induce punishments for not using
    it. That's not going to go down well. Instead, offer incentives—even if it's just
    public kudos in a code review.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the take-up of a standard depends on the authority with which it
    is introduced. Either the programmers themselves authorize it or the process gets
    management to back it. Or it's a big waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound like trying to persuade a load of school children to get along
    and play nicely? Funny, isn't it. . . . Still, you'll wade your way through a
    religious quagmire, emerging on the other side with a house style that will genuinely
    improve your team's code. Once the wounds heal, it will have been worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Righteous Wars?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quickest way of ending a war is to lose it.
  prefs: []
  type: TYPE_NORMAL
- en: --George Orwell
  prefs: []
  type: TYPE_NORMAL
- en: Engaging in holy wars over code layout is unproductive and a waste of time;
    there are far more important things to focus our attention on. But beware—code
    layout is not the only hot potato in the programming community. You could extend
    this to cover editors, compilers, methodologies, the One True Language,^([[2](#ftn.CHP-2-FN-2)])
    and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: These little commotions have been going on for years. They'll continue to go
    on. And no one will *ever* win. No one will ever manage to establish the *right*
    answer, because there is no right answer. These arguments are just an opportunity
    for one person to try to enforce his or her particular (carefully formed) opinion
    on others, and vice versa. After all, my opinion *must* be right, because it's
    *mine*. It's like trying to knit spaghetti—amusing for a while, but messy and
    totally pointless. It's usually only ever immature programmers that get involved.
    (The old-timers are already argued out.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point to learn is: Holy wars are a waste of effort. As a professional,
    you should step back from such petty arguments. Of course, have an educated personal
    opinion, but don''t arrogantly presume that it''s correct.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Holy wars*: Just say no. *Don''t get involved. Walk away*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-2-FN-2)]) This brings to mind a C/C++ programming conference I attended
    some years ago. A speaker presented his discovery that you get fewer bugs (which
    are easier to fix) using Pascal rather than C, while the most difficult to fix
    and numerous bugs occur in C++. The reaction was wonderful—everyone's feathers
    were ruffled!
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing succeeds like the appearance of success.
  prefs: []
  type: TYPE_NORMAL
- en: --Christopher Lasch
  prefs: []
  type: TYPE_NORMAL
- en: Presentation is one of the key features differentiating good code from bad code.
    Programmers glean a lot from code's appearance, so it *is* right to worry about
    layout. It's an important skill to be able to sensitively lay out code for maximum
    clarity, within the guidelines of any company coding standard that may exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOKING FOR A FIGHT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code layout is not the only excuse for a programmer flame war. There are many
    religious subjects that you''d best tactfully dodge for the sake of your blood
    pressure. Watch out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**My OS is better than yours**'
  prefs: []
  type: TYPE_NORMAL
- en: . . . because it scales from a wristwatch to an alien mothership, only requires
    rebooting once every epoch, and performs most operations with a single two letter
    command.
  prefs: []
  type: TYPE_NORMAL
- en: But *mine's* better than yours because you'll never see a single piece of text
    using it, it's tastefully color coordinated, and it can be operated by a blind
    squirrel. Anything you can't do with it is illegal in most civilized countries,
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '**My editor is better than yours**'
  prefs: []
  type: TYPE_NORMAL
- en: . . . because it recognizes more than a million different syntax schemes, can
    edit files written in hieroglyphics, and each of its 400 operations are accessible
    with fewer than 10 simultaneous keystrokes. You can use it on the desktop, from
    a command line, over a modem, through a rising main, and over 128-bit encrypted
    smoke signals.
  prefs: []
  type: TYPE_NORMAL
- en: But *mine's* better than yours because it integrates with my underwear and knows
    what I want to type before I've even thought of it myself.
  prefs: []
  type: TYPE_NORMAL
- en: '**My language is better than yours**'
  prefs: []
  type: TYPE_NORMAL
- en: . . . because it implements the artificial intelligence of most major governmentsand
    is clever enough to interpret random gesticulations as meaningful sequences instructions.
  prefs: []
  type: TYPE_NORMAL
- en: But *mine's* better than yours because it allows you to write in haiku and encodes
    information in combinations of whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: It's reasonable to assume that code that has been carefully laid out will have
    been carefully designed. It's even more reasonable to assume that sloppily presented
    code hasn't been designed with much care. But there's more to this story than
    formatting source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides presentation skills, there are certain *attitudes* that separate good
    programmers from bad programmers. The moral is simple: *Avoid creating hot air*.
    Computers will do that for you (we don''t need in-office heating because ours
    belch out so much heat). Know what you like and be *prepared* to defend it, to
    put your view across—but don''t presume that you have to win or that you have
    to be right, and don''t arrogantly do your own thing anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid pointless arguments and are sensitive to others' opinions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are humble enough to know that they're not right all the time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know how code layout impacts readability and strive for the clearest code possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will adopt a house style even if it contradicts their personal preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Are close-minded and opinionated—*My view isthe right one*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argue with anyone over the most trivial things; it's a chance to prove their
    superiority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have no consistent personal coding style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trample over others' code in their own style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  prefs: []
  type: TYPE_NORMAL
- en: A coding standard may mandate how you create names.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: Good presentation is key to writing code that's self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  prefs: []
  type: TYPE_NORMAL
- en: Describes how we write comments; some comment use relates to source code layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207448.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 466.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should you alter the layout of legacy code to conform to your latest code style?
    Is this a valuable use of code reformatting tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common layout convention is to split source lines at a set number of columns.
    What are the pros and cons of this? Is it useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How detailed should a *reasonable* coding standard be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How serious are deviations from the style? How many limbs should be amputated
    for not following it?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a standard become too detailed and restrictive? What would happen if it
    did?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When defining a new presentation style, how many items or cases need layout
    rules? What other presentation rules must be provided? List them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is more important—good code *presentation* or good code *design*? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you write in a consistent style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you work with other people's code, which layout style do you adopt—theirs
    or your own?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How much of your coding style is dictated by your editor's auto-formatting?
    Is this an adequate reason for adopting a particular style?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tabs: Are they a work of the devil, or the best thing since sliced bread? Explain
    why.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you know if your editor inserts tabs automatically? Do you know what your
    editor's tab stop is?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Some *hugely* popular editors indent with a mixture of tabs and spaces. Does
    this make the code any less maintainable?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many spaces should a tab correspond to?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have a preferred layout style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe it in a series of simple statements. Be complete. Include, for example,
    how you format `switch` statements and split up long lines.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many statements did it take? Is that what you expected?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does your company have a coding standard?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you know where it is? Is it advertised? Have you read it?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If yes: Is it any good? Perform an honest critique, and feed your comments
    back to the document owners.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If no: Should it? ( Justify your answer.) Is there a common unwritten code
    style that everyone adopts? Can you drive the adoption of a standard?'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there *more* than one standard used, perhaps one per project? If so, how
    is code shared among projects?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many different layout styles have you followed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which did you feel most comfortable with?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which was the most rigorously defined?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a link?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3. WHAT'S IN A NAME?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Giving Meaningful Things Meaningful Names*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I use a word, Humpty Dumpty said, in a rather scornful tone, it means just
    what I choose it to mean—neither more nor less.
  prefs: []
  type: TYPE_NORMAL
- en: --Lewis Carroll
  prefs: []
  type: TYPE_NORMAL
- en: Ancient civilizations knew that to name something was to have power over it.
    This was more than a simple claim to possession. Some believed so strongly in
    the power of names that they would never give their own names to strangers, for
    fear the strangers might use it to inflict harm against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Names mean an awful lot. You may not live in fear of them, but don''t underestimate
    the power of a name. A name describes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**'
  prefs: []
  type: TYPE_NORMAL
- en: Names are fundamental to our concept of identity. There are examples throughout
    history—even before 2000 Bc, there are Biblical examples of meaningful place names
    and children named to reflect circumstances. In most cultures it's still convention
    for a woman to change her last name when she gets married, although the fact that
    some women choose not to shows how they attribute significant meaning to their
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A name not only promotes identity, but also implies behavior. Obviously, a
    name doesn''t dictate what an object does, but it will influence how you interact
    with it and how the outside world interprets it. We''re never fixed to one name
    per object. I''m known by different monikers in different contexts: the name my
    wife calls me,^([[1](#ftn.CHP-3-FN-1)]) the name my daughters know me by, the
    nickname I use in chat rooms, and so on. These names indicate different relationships
    and interactions with me and the roles I fulfil.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recognition**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A name marks something as a distinct entity. It elevates it from ethereal concept
    to well-defined reality. Before someone put a name to electricity, no one would
    have understood what it was, although they might have some vague idea of its effects
    by watching lightning or Benjamin Franklin''s demonstrations. Once named, it became
    identifiable as a distinct force and, consequently, easier to reason about. The
    Basque culture believes that naming something proves its existence: *Izena duen
    guzia omen da* —That which has a name exists. (Kurlansky 99)'
  prefs: []
  type: TYPE_NORMAL
- en: Today the act of naming has become a multimillion-dollar business, used (with
    varying degrees of success) by small firms, the largest multinational corporations,
    and everything in between. To launch, rebrand, and publicize products, these organizations
    need newer, ever more catchy names. These names help to build awareness of products
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, names are of immense importance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we wield this enormous power over our constructs when we name
    them. A badly named entity can be more than just inconvenient; it can be misleading
    and even downright dangerous. As a very simplistic example, consider the following
    C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The parameter name is clearly a lie, or at least its sense is the opposite of
    what you'd expect. The function will not perform as anticipated and, as a consequence,
    your program will abort—a reasonably dire result from a single misnamed variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sticks and stones may break my bones, but names will never hurt me*. Not true.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Should We Name Well?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to carefully consider the names we give things. Remember that writing
    source code is all about clear communication. A name creates a channel of understanding,
    control, and mastery. Appropriate naming means that *to know the name is to know
    the object*.
  prefs: []
  type: TYPE_NORMAL
- en: Good names really matter. The human brain can only hold about seven pieces of
    information concurrently^([[2](#ftn.CHP-3-FN-2)]) (although I'm sure I have a
    couple of defective slots, reducing this capacity). It's already hard enough to
    cram all the information about a program into your head; we should not add complexnaming
    schemes or require obscure references to make this task even harder.
  prefs: []
  type: TYPE_NORMAL
- en: Clear naming is one of the hallmarks of well-crafted code. The ability to name
    things well is an important skill of the code craftsman—he'll work hard to write
    easy-to-read code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn to name things* transparently—*an object''s name should describe it
    clearly*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-3-FN-1)]) Which depends on whether she's in a good or bad mood at
    the time!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-3-FN-2)]) This is known as the *Miller number*, after George A.
    Miller's psychological research. (Miller 56)
  prefs: []
  type: TYPE_NORMAL
- en: What Do We Name?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we''ll spend some time thinking, as programmers, about what
    we name and how we name it. First: *What?* The things we name most often while
    writing code are:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types (classes, `enum`s, `struct`s, `typedef`s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ namespaces and Java packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This list is by no means exhaustive—there are other, higher-level entities
    we''ll give meaningful names to: states of a state machine, parts of messaging
    protocols, database elements, application executables, and so on. But these six
    are enough to start with.'
  prefs: []
  type: TYPE_NORMAL
- en: Name Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*How* do you name? The naming technique for each of these items will depend
    on any coding standard you''re working to. However, while a standard might mandate
    certain naming conventions, it won''t be specific enough to guide the *appropriate*
    naming of each and every part of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to name well, it's essential to know exactly what you're naming before
    you think up a name for it. If you don't know what you're naming, how it will
    be used, and why it actually exists, how can you give it a meaningful name? Bad
    names are often a sign of poor understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The key to good naming is to understand exactly what you''re naming. Only
    then can you give a meaningful name. If you can''t invent a good name for something,
    do you really know what it is, or even if it should exist at all?*'
  prefs: []
  type: TYPE_NORMAL
- en: Before we look in detail at the specific categories of names we create, it's
    important to understand the forces that drive our choice of names and exactly
    what constitutes a good name. The next few sections explain the qualities of a
    good name.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously a name must be descriptive. That's what you use it for—to describe
    something. Yet it's common to see puzzling identifiers that bear little resemblance
    to the data they describe.
  prefs: []
  type: TYPE_NORMAL
- en: Even an accurate name can be limiting. People often stick to their initial perceptions
    of a concept, despite the proverb about judging books by their covers. Therefore,
    it's important to convey the right first impression through careful naming. Choose
    names from the perspective of an inexperienced reader, not from your internal,
    knowledgeable perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes finding a good description is difficult. If you can't come up with
    a good name, then you might need to change your design. It's an indication that
    something might be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Technically Correct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern programming languages impose some rules on how we name things. Most allow
    case-sensitive names, don't allow *whitespace* (spaces, tabs, newlines), and allow
    just alphanumeric characters plus certain symbols (like the underscore). These
    days, there are no appreciable limits on identifier length.^([[3](#ftn.CHP-3-FN-3)])
    Although many languages permit use of Unicode identifiers, it's still common to
    select from the ISO8859-1 (ASCII) character set for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be other technical restrictions. The C/C++ standards reserve specific
    ranges of names: You should not use any global identifier beginning with `str`
    followed by a lowercase letter, or beginning with an underscore, and anything
    in a namespace called `std`. It''s important to be aware of these kinds of restrictions
    so we can write robust, correct code.'
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just because a language permits certain combinations of characters doesn''t
    meant they''re automatically good names. Clear names follow conventions that the
    reader expects: the language''s *idioms*. Just as fluency in a natural language
    depends on understanding its idioms, fluency in a programming language requires
    idiomatic usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Some languages have a single, common naming convention—the vast Java library
    establishes a prior art that is hard to ignore—while C and C++ have a lesser degree
    of convergence. There are several cultures, each with their own foibles; the standard
    libraries use one convention, Windows Win32 APIs another.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Know your language''s naming rules. But more importantly, know the language''s
    idiomsw. What are the common naming conventions? Use them*.'
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *appropriate* name strikes a good balance in several areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Length**'
  prefs: []
  type: TYPE_NORMAL
- en: To create clear, descriptive names, we must use natural language words. Programmers
    have a built-in urge to abbreviate and shorten these words, but this leads to
    confused, messy names. It doesn't matter that a name is long if its meaning is
    unambiguous. `a` is not a realistic replacement for `apple_count`.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When naming, favor clarity over brevity*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a case for short (even one letter) variable names: as loop
    counters. They actually make sense in *small* loops where variable names like
    `loop_counter` are not just overly verbose but can quickly become tedious.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Understand the trade-offs between short and long names—how they depend on
    the scope of the variable''s use*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tone**'
  prefs: []
  type: TYPE_NORMAL
- en: The tone of a name *is* important. Just as a rude joke isn't appropriate at
    a funeral, an ill-judged name ruins the professionalism of your code. Is this
    serious? Yes—silly names make the reader doubt the ability of the original author.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid jokey names like *blah* or *wibble*, or the bigger geek snares *foo* and
    *bar*. They can easily creep in, and while amusing at first, they just create
    confusion later on. (Objects given these names are usually quick temporary hacks
    that outlast their expected lifetime.) And, obviously, being professional means
    that you don't use expletives when naming.
  prefs: []
  type: TYPE_NORMAL
- en: '**FOOD FOR THOUGHT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what''s with all this *foo* and *bar* business? These words are a bit of
    geek humor, utterly meaningless and yet full of purpose. They are usually used
    as placeholders to represent arbitrary things. You might write: *for some variable*
    *`foo`*, *increment it by* *`++foo`*;.'
  prefs: []
  type: TYPE_NORMAL
- en: The words generally come in a series. There are several variant series, but
    you'll see *foo*, *bar*, and baz *`quite`* universally. What comes next may be
    up to the fickle finger of fate or to whatever geek folklore you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: The etymology of these terms is debatable. Some trace them back to the World
    War II army slang FUBAR (Mucked Up Beyond All Repair). Needless to say, you should
    never use these names in production code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Name things well the first time, all the time*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-3-FN-3)]) Be aware that older versions of C limited external unique
    linkage to the first six characters, and case was not *necessarily* significant.
    You need to understand exactly what the target of your code is when you write
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The Nuts and Bolts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections investigate how to name each category of item we listed
    earlier. Even if you've been programming for years, this is a useful review of
    the broad spectrum of naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a variable wasn't just an electronic entity, it would be the sort of thing
    you could hold in your hand, the software equivalent of a physical object. A name
    that reflects this will usually be a noun. For example, variable names in a GUI
    application might be `ok_button` and `main_window`. Even variables that don't
    correspond to Real World objects can be given noun names; consider `elapsed_time`
    or `exchange_rate`.
  prefs: []
  type: TYPE_NORMAL
- en: If not a noun, a variable will usually be a "noun-ized" verb, for example, `count`.
    A numeric variable's name describes the interpretation of the value, as in `widget_length`.
    A boolean variable name is often the name of a conditional statement, which is
    natural, considering the value will either be true or false.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of object-oriented language conventions for adorning member
    variables to show they are members, not ordinary local variables or (evil) global
    variables. This is a mild form of *Hungarian Notation*, which some programmers
    find useful.^([[1](#ftn.CHP-3-FN-4)]) For example, C++ members are commonly prefixed
    with an underscore, suffixed with an underscore, or prefixed with `m_`. The first
    method is frowned upon because it is somewhat risky and distasteful.^([[5](#ftn.CHP-3-FN-5)])
    Besides, a leading or trailing underscore makes the variable pretty unnatural
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers adorn pointer types with a suffix like `_ptr` and reference
    types with one like `_ref`. This is another subtle infiltration of Hungarian Notation,
    and it is redundant. The fact the variable is a pointer is implicit in its type.
    If your function is so large that you think this adornment is useful, then it's
    probably too large!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common variable-naming practice is using acronyms as concise, "meaningful"
    names. For example, you might declare a variable like this: `SomeTypeWithMeaningfulNaming
    stwmn(10);`. If the scope of use is small, this kind of name may be clearer than
    a long-winded variant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conventions that distinguish type names from variable names are generally best.
    Type names often have an uppercase initial letter, while variables have a lowercase
    one. This way, it''s not unusual to see variables declared like this: `Window
    window;`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Employ a helpful naming convention that differentiates variable names from
    type names*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HUNGARIAN NOTATION**'
  prefs: []
  type: TYPE_NORMAL
- en: Hungarian Notation is a controversial naming convention that encodes information
    about a variable or function's type in its name with the belief that it will make
    the code more readable and maintainable. It originated at Microsoft in the 1980s
    and is widely used in the company's public Win32 APIs and the MFC library, which
    is the main reason for its popularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is called Hungarian Notation because it was pioneered by Charles Simonyi,
    a Hungarian programmer. It''s also called that because variable names look like
    they may as well have been written in Hungarian: Non-Windows programmers get confused
    by surreal names like `lpszFile`, `rdParam`, and `hwndItem`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many subtly different and not-quite-compatible dialects of Hungarian
    Notation, which don't help matters.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a variable is like something you could hold in your hand, the *function*
    is what you do with it—you don't want to hold it forever. Since a function is
    an action, its name will most logically be (or will at least include) a verb.
    A function with a noun for a name wouldn't be clear; for example, what does the
    function `apples()` do? Does it return a number of apples, does it convert something
    into apples, or does it make apples out of thin air?
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful function names avoid the words *be*, *do*, and *perform*. These are
    classic traps for beginners trying to consciously include verbs (*this function*
    does *XXX* . . .). They are just noise and don't add any value to the name.
  prefs: []
  type: TYPE_NORMAL
- en: A function should always be named from the viewpoint of the user, hiding all
    the internal implementation stuff neatly away. (That's the point of a function—it's
    a level of compression and abstraction.) Who cares if, behind the scenes, it stores
    an element in a list, makes calls over a network, or builds a new computer and
    installs a word processor on it? If the user only sees the function count apples,
    the function should be called `countApples()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Name functions from an external viewpoint, with a doing phrase. Describe the
    logical operation, not the implementation*.'
  prefs: []
  type: TYPE_NORMAL
- en: The only time you might choose to break this rule is for simple query functions
    that request information. For these accessors, you can sensibly name the function
    after the data being requested. For an example of this, see the answer to question
    9 in this chapter's "[Mull It Over](ch02s11.html#mull_it_over-id1 "Mull It Over")"
    section on page 478.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a function, it should be well documented (either in a specification
    or using some literate programming method). However, the name should still be
    a clear statement of what the function does; it is part of the function's contract.
    What does `void a()` do? It could be anything.
  prefs: []
  type: TYPE_NORMAL
- en: '**CAPITALIZATION CONVENTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most languages prohibit us from using whitespace and punctuation in our identifiers,
    so we adopt a convention for joining up multiple words. These capitalization conventionscause
    as many programmer fist fights as the eternal Holy Editor Wars. There are a number
    of common methods that you''ll see in modern code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**camelCase**'
  prefs: []
  type: TYPE_NORMAL
- en: camelCase is used extensively by the Java language libraries and also in many
    C++ codebases. It is so called because the capitalization resembles a camel's
    humps and was probably first used in Smalltalk in the early 1970s.
  prefs: []
  type: TYPE_NORMAL
- en: '**ProperCase**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a close relative of camelCase, its only difference being that the first
    letter is also capitalized. It is sometimes known as *PascalCase*. Often the two
    conventions are used together. For example, Java class names are written in ProperCase
    and members in camelCase. The Windows API and .NET methods use ProperCase.
  prefs: []
  type: TYPE_NORMAL
- en: '**using_underscores**'
  prefs: []
  type: TYPE_NORMAL
- en: Proponents of this style are the implementers of the C++ standard library(look
    at all the names in the `std` namespace) and the GNU foundation.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many other forms. How many can you think of? You can start by
    mixing ProperCase with underscores, or by dropping uppercase characters entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which types you can create depends on the language you're using. C provides
    `typedef`s, which are synonyms for other type names. You use them to provide easier,
    more convenient names. It stands to reason, then, that a `typedef` should be clearly
    named. Even if it's only a local `typedef` in a function body, it should still
    have a descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: Java, C++, and other OO languages are profoundly based on the creation of new
    types (*classes*). C also allows you to define compound types called `structs`.
    Just as good variable and function names are vital to the readability of the code,
    good type names are paramount. There aren't too many rigid heuristics for naming
    classes, though, because different classes serve different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: A class may describe some stateful data object. In that case, its name will
    probably be a noun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be a function object (a *functor*) or a class implementing some virtual
    callback interface. Here the name will probably be a verb, perhaps including the
    name of a recognized design pattern. (Gamma et al. 94)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the class is a combination of both, then it's probably hard to name and possibly
    designed badly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interface classes* (e.g., abstract C++ classes with pure virtual functions
    or `interface`s in Java and .NET) tend to be named according to the interface
    facility. Names like `Printable` and `Serializable` are common. .NET adds a Hungarian
    wart, prefixing all interface names with `I`, resulting in names like `IPrintable`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Earlier, we discussed words to avoid in function names; there is similar quicksand
    here. For example, `DataObject` is a bad name: The class may very well contain
    data, and it''s obviously going to be used to create an object—this doesn''t need
    to be restated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid redundant words in names. Specifically, avoid these words in type names*:
    class, data, object, *and* type.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you describe the *class of data* and not an *actual object*. That's
    a subtle, but important distinction.
  prefs: []
  type: TYPE_NORMAL
- en: '**A CLASS OF BAD NAMES**'
  prefs: []
  type: TYPE_NORMAL
- en: A bad class name can serve to really confuse programmers. I once worked on an
    application that contained a state machine implementation. For some historical
    reason, the base class of each state was called `Window`, rather than something
    sensible like `State`. It was very confusing and threw off several programmers
    when they first saw it. To add insult to injury, the base class of a command pattern
    was called `Strategy`, when it wasn't actually implementing a strategy design
    pattern. It was never easy to figure out what was going on. Better naming would
    have provided a clear route into the code's logic.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What name do you give something specifically designed to collate names? C++
    and C# `namespace`s and Java `package`s are like bags, acting primarily as grouping
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: They are also used to prevent *name collisions*. When two programmers create
    different things with the same name and their code gets glued together, whatwill
    happen is anyone's guess. At best, the code will fail to link; at worst, all sorts
    of run-time carnage will ensue. Putting items into different namespaces avoids
    the danger of polluting the global namespace. This makes them valuable naming
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: But namespaces on their own do not prevent collisions; your `utils` namespace
    could still clash with someone else's `utils`. To remedy this, we employ a *naming
    scheme*. Java defines a hierarchy of package names, nested like Internet domain
    names—you'll place code in your own uniquely named package. This neatly avoids
    the problem of collisions. Without such a convention, namespaces reduce, but do
    not eliminate, the likelihood of problems.
  prefs: []
  type: TYPE_NORMAL
- en: When picking a name for your namespace, choose something that describes the
    relationship of the contents. If they are all part of a library's interface, make
    it the library name. If the contents are a single section of a larger system,
    choose a name that describes this section; `UI`, `filesystem`, or `controls` are
    good names. Don't choose a name that redundantly implies a collection of items—`controls_group`
    is a bad name.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Give namespaces and packages names that reflect the logical relationships
    of their contents*.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros are the walnut-cracking sledgehammers of the C/C++ world. They are search-and-replace
    tools for basic text that don't respect scope or visibility. They're tactless.
    However, there are some walnuts that just won't crack without them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros have very drastic effects, so there is a well-established tradition
    for naming macros in a maximally obvious way: using CAPITAL LETTERS. Follow this
    without fail, and don''t make any other name entirely capitalized. This makes
    macros stand out like sore thumbs, which is basically what they are.'
  prefs: []
  type: TYPE_NORMAL
- en: Since they are simple text replacement tools, give macros names that are unique
    enough to not appear elsewhere in the code. Otherwise, carnage and confusion will
    ensue.
  prefs: []
  type: TYPE_NORMAL
- en: A unique file or project name prefix will help here. The macro name `PROJECTFOO_MY_MACRO`
    is much safer than `MY_MACRO`.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Macros in C/C++ are always capitalized to make them stand out and carefully
    named to avoid collisions. Don''t capitalize anything else. Ever*.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The names of your source files can have a real impact on the ease of coding.
    Some languages have strict filename requirements—Java source filenames must correspond
    to the contained public class name. On the other hand, C and C++ are lax, with
    no restrictions at all.^([[6](#ftn.CHP-3-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: To make choosing filenames easy and obvious, each file should contain a single
    conceptual unit. Putting more stuff into one file is asking for trouble in the
    long run. Split your code into the maximum number of files you can; not only will
    it make them easier to name, but it will reduce coupling and make the project's
    structure clearer.
  prefs: []
  type: TYPE_NORMAL
- en: A C/C++ file that defines the interface for a *widget* should becalled `widget.h`,
    not `widget_interface.h`, `widget_decls.h`, or any other variation. You should
    conventionally balance each `widget.h` with a matching `widget.cpp` or `widget.c`
    (see "[ALL THAT ENDS WELL](ch03s05.html#all_that_ends_well "ALL THAT ENDS WELL")"
    on page 50) that implements whatever the `widget.h` declares. The shared base
    name ties them together logically. This is both obvious and conventional.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other subtle, but important issues when naming files:'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of capitalization. Some filesystems can't get this right and ignore
    case when looking up filenames. But when porting to platforms where case *is*
    important, your code won't compile unless you've observed capitalization carefully.
    Perhaps the easiest way to avoid being tripped up is to mandate that all filenamesbe
    lowercase; as they say, *If you can't be good, be careful*. (Of course, that won't
    work for Java, which uses the PascalCase naming style for its classes and interfaces.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the same reason, if your filesystem considers the filenames `foo.h` and
    `Foo.h` to be different, *don't* exploit it. Make sure that filenames in the same
    directory differ by more than just case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you mix languages in a single project, don't create `foo.c`, `foo.cpp`, and
    `foo.java` in the same directory. It's messy—which file is used to create the
    object file `foo.o`, and which creates the executable called `foo`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to ensure that all the files you create have a distinct names, even if they're
    all spread across different directories. This makes it easier to reason about
    which file is which. It's obvious which header file you mean when you `#include
    "foo.h"`. If there were two files with the same name, then a newcomer to the codebase
    would be confused. This becomes more of an issue as a system grows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One valid approach is to add some path information to the logical filename.
    Arrange your files so that you can include `library_one/version.h` and `library_two/version.h`
    without confusion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: File naming seriously impacts ease of coding. I once worked on a C++ project
    where the majority of the filenames matched the class names exactly; the class
    `Daffodil` was defined in `Daffodil.h` (names have been changed to protect the
    guilty). However, a handful of files were named in a *slightly* different manner,
    usually abbreviated, so `HerbaciousBorder` was held in `HerbBdr.h`. That made
    finding the right filename to `#include` complex and time consuming. On top of
    this, not all of the `Daffodil` class implementation was necessarily in `Daffodil.cpp`—some
    of it might have been in a shared `FlowerStuff.cpp` and perhaps also in `Yogurt.cpp`,
    for no adequately explained reason. As you can imagine, this made finding particular
    bits of code a nightmare. Source code browsers help in situations like this, but
    they are no substitute for plain old, well-named code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-3-FN-4)]) Of course, this kind of naming convention won't have any
    impact on a class's public API because all of your member variables are private,
    aren't they?
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-3-FN-5)]) You can't have global identifiers beginning with an underscore
    followed by a capital letter. The archaic C naming rules make many such odd demands.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-3-FN-6)]) Except those imposed by your operating system or filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: A Rose by Any Other Name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is more to the name game than you'd first think, and there are clearly
    a lot of considerations for naming bits of code. What are the main principles
    to pull out?
  prefs: []
  type: TYPE_NORMAL
- en: 'To invent a good name, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Be consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use names to your advantage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALL THAT ENDS WELL**'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a suffix is integral to file naming. Java's build system insists that
    source filenames end in `.java`. C and C++ compilers are suffix agnostic, but
    calling header files something.h is such a universal convention that it would
    be like sticking pins in your eyes not to do it. We do feel some pain from the
    lack of rigid definition; there are several conventions for C++ implementation
    filenames, like the common suffixes `.C`, `.cc`, `.cpp`, `.cxx`, and `.c`++. Less
    common, but still seen, are C++ headers files suffixed with `.hpp`. Your choice
    may depend on the compiler, personal preference, and/or a coding standard. Consistency
    is the key; pick a file suffix scheme and use it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: I have even worked on a platform that didn't support filename suffixes. Determiningthe
    filetype was a complex and messy business.
  prefs: []
  type: TYPE_NORMAL
- en: Be Consistent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is perhaps the most important naming principle. Be *consistent*—not just
    within your own work, but with respect to company-wide practices. I have no confidence
    in the quality of a class interface if it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When a lot of people work together, it's very easy to end up with code like
    this—about as internally consistent as a random number generator. It's often a
    symptom of a more serious problem—perhaps that the programmers aren't respecting
    the fundamental design of the code they're simultaneously working on. This is
    where mandated coding standards and central design documents can be a big help.
  prefs: []
  type: TYPE_NORMAL
- en: Naming consistency goes beyond capitalization and formatting to the way you
    *create* names. A name establishes an implicit metaphor. Across a program or project,
    these metaphors should be consistent. Your naming approach should be holistic.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Choose a consistent naming convention—and use it consistently*.'
  prefs: []
  type: TYPE_NORMAL
- en: With consistent naming, we get code that is intuitive and therefore easier to
    work with, easier to extend, and easier to maintain. In the long run, it's much
    cheaper to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Exploit Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every name should make perfect sense when read in context. A name will only
    ever be read in its context, so you can delete all the superfluous bits that duplicate
    contextual information. We strive for succinct, descriptive names, without unnecessary
    baggage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This contextual information may come from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Things either live in a top-level, global scope or exist within some namespace,
    class, or function. Choose a name that makes sense in the context of that scope.
    The smaller and more specific a scope is, the easier it is to create a name within
    it and the easier it is for the reader to understand what that name really means.
    If a function counts the number of apples in a tree and is defined in a class
    `Tree`, then it needn''t be called `countApplesInTree()`. Its fully qualified
    name would be an unambiguous description: `Tree::countApples()`. Put things in
    the smallest (and therefore most descriptive) scope you can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The French language, like most other Romance languages, has two forms of the
    word *you*: *tu* and *vous*. Which one you use depends on how familiar you are
    with the person you''re addressing. Similarly, the name you call a variable may
    depend on the context in which you''re using it. You may see a variable named
    differently in a function''s public declaration than in the function implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Everything has a type, and you'll know what that type is. A name doesn't need
    to restate this type information. (Restating this *is* the purpose of Hungarian
    Notation and is why it's an often derided convention.)
  prefs: []
  type: TYPE_NORMAL
- en: An inexperienced programmer will name his address `string` variable `address_string`.
    What good does the `_string` suffixdo? Nothing, so get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The detail required in a name depends on its context. Use contextual information
    to your advantage when naming*.'
  prefs: []
  type: TYPE_NORMAL
- en: Use Names to Your Advantage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is power in a name—power that allows you to be more expressive than a
    language's syntax alone might allow. Think about how you can use similar names
    to group things together, using a common prefix. Or consider how you can imply
    which of a function's parameters are input or output by including this information
    in their names.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your name I will hope, for your name is good.
  prefs: []
  type: TYPE_NORMAL
- en: --Psalms 52:9
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ancient ancestors knew it, and good programmers know it: It''s crucial
    to name things well. Good names serve more than just an aesthetic purpose; they
    convey information about the structure of code. They are an essential tool to
    aid comprehensibility and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we write code in high-level languages is to communicate, and
    that communication is to an audience of code readers—other programmers—rather
    than to the compiler. Bad names have the potential to mislead. There *is* power
    in a name, and experienced programmers understand the balance of concerns involved
    when naming any part of their code.
  prefs: []
  type: TYPE_NORMAL
- en: '**GENERAL DOS AND DON''TS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can condense a lot of the advice in this chapter into some general dos and
    don''ts. *Don''t* create names that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptic**'
  prefs: []
  type: TYPE_NORMAL
- en: You can create inexplicable names in a number of ways. Acronyms and abbreviations
    can appear quite random, and single letter names are far too magical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbose**'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid terse names, but don't create a variable called `the_number_of_apples_before_I_started_eating`,
    either. It's neither remotely useful nor funny.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inaccurate or misleading**'
  prefs: []
  type: TYPE_NORMAL
- en: As obvious as it seems, make your names accurate. Don't call something a `widget_list`
    if it has nothing to do with lists. Don't call something `widget` if it's a container
    of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Misspelling opens a minefield of confusion: *I thought the variable was called*
    *`ignoramus`*, *but I can''t find it anywhere*. *Oops, it was misspelled* *`ignoramous`*.
    Sigh.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambiguous or vague**'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use a name that could be interpreted in several ways. Don't use a hopelessly
    vague name like `data` or `value` unless it's perfectly clear what it represents.
    Avoid the vague `temp` or `tmp` unless you *really* need it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't differentiate names by capitalization or by changes of a single character.
    Be wary of names that sound similar.
  prefs: []
  type: TYPE_NORMAL
- en: Don't gratuitously create local variables with the same name as something in
    an outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: '**Too cute**'
  prefs: []
  type: TYPE_NORMAL
- en: Sexy little abbreviations, clever shortenings that are hard to remember, and
    interpretive use of numerals should be avoided. *i18n*, a common abbreviation
    for *internationalization*, reads like nonsense to the uninitiated.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, *do* create appropriate names that are clear, specific, concise,
    accurate, and unambiguous. *Do* use common terms and frames of reference. Use
    words from the problem domain, and draw on descriptive design pattern names.(Gamma
    et al. 94)
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Realize the importance of names and treat them with respect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about naming and choose appropriate names for everything they create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hold many forces in balance: name length, clarity, context, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a view of the bigger picture, so their names hold together across a project
    (or projects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Care little for the clarity of their code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce *write-once* code that is quick to write and poorly thought out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the language's natural idioms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are inconsistent in naming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't think holistically, failing to consider how their piece of code fits into
    the whole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  prefs: []
  type: TYPE_NORMAL
- en: Discusses coding standards, which may guide you in naming things. Also talks
    about *holy wars*, which Hungarian Notation is definitely a cause of.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: Good names don't replace well-documented code—but they are an integral part
    of code documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207452.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 474.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are these good variable names? Answer with either *yes* (explain why, and in
    what context), *no* (explain why), or *can't tell* (explain why).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int apple_count`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`char foo`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bool apple_count`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`char *string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int loop_counter`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When would these be appropriate function names? Which return types or parameters
    might you expect? Which return types would make them nonsensical?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`doIt(...)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`value(...)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sponge(...)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isApple(...)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Should a naming scheme favor the easy reading or easy writing of code? How would
    you make either easy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many times do you write a single piece of code? (Think about it.) How many
    times do you read it? Your answers should give some indication as to the relative
    importances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you do when naming conventions collide? Say you're working on camelCase
    C++ code and need to do STL (using_underscore) library work. What's the best way
    to handle this situation?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How long should a loop be before you need to give a meaningful loop counter
    name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In C, if `assert` is a macro, why is its name lowercase? Why should we name
    macros so they stand out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the pros and cons of following your language's standard library naming
    conventions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you wear out a name? Is it okay to repeat a local variable name in many
    different functions? Is it okay to use local names that override (and hide) global
    names? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the mechanics of Hungarian Notation. What are the pros and cons of
    this naming convention? Does it have a place in modern code design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We see many classes containing member functions acting as *getters* and *setters*;
    reading and writing the value of certain properties. What are the common naming
    conventions for these functions, and which is the best?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How good are you at naming? How many of these heuristics do you follow already?
    Do you consciously think about your naming and these sorts of rules, or do you
    just *do it* all naturally? In which areas can you improve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does your coding standard mention naming at all?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does it cover all the cases we've looked at here? Is it *sufficient*? Is it
    useful, or just superficial?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How much naming detail *is* appropriate in a coding standard?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the worst name you've come across recently? How have names ever misled
    you? How would you have changed them to avoid future confusion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have to port code between platforms? How has this affected filenames,
    other names, and the overall code structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4. THE WRITESTUFF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Techniques for Writing "Self-Documenting" Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real seriousness in regard to writing is one of two absolute necessities. The
    other, unfortunately, is talent.
  prefs: []
  type: TYPE_NORMAL
- en: --Ernest Hemingway
  prefs: []
  type: TYPE_NORMAL
- en: Modern self-assembly ( *flat-pack*) furniture is remarkable, leaving even the
    seasoned carpenter in a state of awe and confusion. Generally, it's cleverly designed
    and will *eventually* build into what you expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: When assembling it, you have to rely on the supplied instructions—you'll build
    something more like modern art than furniture without them. The quality of the
    instructions drastically affects how easy construction is. Bad instructions make
    you sweat, swear, and continually take apart pieces of wood that should never
    have been attached in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: It's a shame they don't make things like they used to.
  prefs: []
  type: TYPE_NORMAL
- en: Source code suffers from similar problems. It's true, they don't make it like
    they used to, but no one was ever *that* fond of punched cards or COBOL anyway.
    More importantly, without good instructions that explain how the code fits together,
    working with some programs can make you sweat, swear, and continually take apart
    pieces of code that should never have been attached in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating good code means creating *well-documented* code. The reason we write
    code is to communicate clear sets of instructions—not just to the computer, but
    also to the poor fools who have to fix or extend those instructions later on.
    Code in the Real World is never written and then forgotten about. It will be modified,
    extended, and maintained over the life of the software product. To do this we
    need instructions, a user guide—documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Common wisdom for documenting code is that you should either write tons of documents
    *about* the code or write tons of comments *in* the code.
  prefs: []
  type: TYPE_NORMAL
- en: Both ideas are nonsense. Most programmers have an aversion to word processors
    and get bored with writing too many comments. Writing code *is* hard work. Documenting
    it shouldn't be more hard work. In the heat of the software factory, anything
    that requires extra work tends not to be done. Or if it is, it is done badly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve seen software systems propped up by design specifications, implementation
    notes, maintenance guides, and style guides. Unsurprisingly, this is the kind
    of code that''s really tedious to work with. The problem with all of this supporting
    documentation is:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need extra work to do. Writing documentation takes a lot of time; so
    does reading it. Programmers would rather spend that time programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these separate documents must be kept up to date with any code changes.
    In a large project, that's an awful lot of work. The common alternative (never
    updating any documentation) leads to dangerously inaccurate and misleading information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A forest of documentation is hard to manage. It's not easy to find the right
    document or to locate a particular piece of information that could be in one of
    several places within a document. Like code, documentation has to be held under
    revision control, and you must make sure you're reading the corresponding document
    version for the version of source code you're working on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important information in separate documents can easily be missed. If it's not
    beside the code, and there are no helpful pointers, things are overlooked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t write code that needs to be propped up by external documentation. It''s
    flimsy. Ensure that your code reads clearly on its own*.'
  prefs: []
  type: TYPE_NORMAL
- en: The common alternative—documenting your code with detailed code comments—can
    be just as bad, if not worse. Reams of slavishly detailed comments obstruct good
    code. You'll end up writing poorly formatted documentation rather than a good
    program.
  prefs: []
  type: TYPE_NORMAL
- en: How do we avoid this nightmare? We write *self-documenting* code.
  prefs: []
  type: TYPE_NORMAL
- en: Self-Documenting Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It sounds like a good idea, doesn''t it? But what *is* self-documenting code?
    This program is self-documenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's not anything to be proud of, though. A more complicated, more useful self-documenting
    program requires a great deal of skill. Computer programs tend to be much harder
    to read than they are to write. Anyone who has used Perl will understand this;
    it has been described as the ultimate write-once language. Indeed, old Perl code
    can be truly unfathomable, but you can write opaque code in any language, and
    it doesn't take much effort.
  prefs: []
  type: TYPE_NORMAL
- en: The only document that describes your code completely and correctly is the code
    itself. That doesn't automatically mean it's the best description possible, but
    more often than not, it's the *only* documentation you'll have available.
  prefs: []
  type: TYPE_NORMAL
- en: You should, therefore, do everything you can to make it good documentation,
    the kind of documentation that anyone can read. By necessity, code is something
    that more people than just the author must be able to understand. Programming
    languages are our communication medium. Clear communication is vital. With clarity,
    your code gains quality because you're less likely to make mistakes (since errors
    are more obvious), and it is cheapter to maintain the code—it takes less time
    to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Self-documenting code is easily readable code. It is comprehensible on its own,
    without relying on external documentation. We can improve the clarity of our code
    in many ways. Some techniques are very basic and have been drilled into us since
    we were taught to program. Others are more subtle and come with experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write your code to be read. By humans. Easily. The compiler will be able to
    cope*.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of a simple function that's about as far from self-documenting
    as you can get. What do you think it does?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**DON''T JUDGE A BOOK . . .**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A file of self-documenting code reads a lot like a good reference book. Such
    a bookis carefully structured, sectioned, and laid out. It reads naturally from
    front to back and top to bottom, but you can just as easily dive into it as a
    reference. That''s how our code should work. Let''s compare the parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: A book's introduction explains what's inside, sets the tone, and explainshow
    it fits into the bigger picture. A source file should begin with a code comment
    header. It explains what's in the file and specifies to which project the source
    file belongs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of contents**'
  prefs: []
  type: TYPE_NORMAL
- en: Although some argue that the file header should include a list of all thecontained
    functions, I strongly advise against this. It will rapidly become out of date.
    You can, however, list the contents of the file (all types and classes, functions,
    variables) with most modern editors or IDEs, providing useful directions to specific
    pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sections**'
  prefs: []
  type: TYPE_NORMAL
- en: This book is divided into several parts. Source files may also split intomajor
    sections; perhaps a single file contains several classes or logical groups of
    functions. This is where breakwater comments help. Extravagant ASCII art is generally
    a Bad Thing, but these kinds of comments help to logically break up the file for
    easy navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Beware, though. Putting too many things in a single source file is not a good
    idea. A simple one-to-one file/class correspondence is best. Large, multipurpose
    files are confusing to understand and very hard to navigate. (If this advice leaves
    you with too many source files, then you need to improve the higher-level code
    structure.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapters**'
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter of a book is a self-contained and well-named chunk. Source files
    typically contain a number of well-named functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Paragraphs**'
  prefs: []
  type: TYPE_NORMAL
- en: Within each function, you'll group code into blocks of statements. The initial
    variable declarations will be in one logical block, separated from the following
    code by a blank line (well, at least they will be in older C code). This isn't
    a syntactic thing, just layout that helps you read the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sentences**'
  prefs: []
  type: TYPE_NORMAL
- en: Sentences naturally correspond to each single code statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-references and index**'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this isn't a part of your source file markup, but a good editor orIDE
    will provide cross-referencing capabilities. Learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: This is an interesting analogy, but what difference does it make for writing
    code?Many good book-writing techniques translate into good code-writing techniques.
    Learn them to make your code more readable. Split code into sections, chapters,
    and paragraphs. Use layout to emphasize the code's logical structure. Use simple,
    short code statements—just like short sentences, they're more readable.
  prefs: []
  type: TYPE_NORMAL
- en: That's a realistic example; countless millions of lines in production software
    look like that, and programmers on the front line suffer because of it. In contrast,
    the following code *is* self-documenting. You can probably work out what it does
    by just reading the first line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's one thing you should notice about that function—the lack of comments.
    It's obvious what's going on without any. Comments would just add more stuff to
    be read. They'd be unnecessary noise and would make the function harder to maintain
    in the future. That's important—because even the smallest, most beautiful functions
    *will* need later maintenance.^([[1](#ftn.CHP-4-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-4-FN-1)]) Did you work out what that first example did? Both functions
    compute a value in the Fibonacci sequence. Which would you prefer to read?
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for Self-Documenting Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing self-documenting code is traditionally thought to involve adding a copious
    amount of comments. Good commenting certainly is an important technique, but there's
    muchmore to it than that. In fact, we should actively *avoid* comments bywriting
    clear code that doesn't need them.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections list important self-documenting code techniques. You'll
    notice that they cover similar ground to the other chapters in this first part
    of the book. That's not entirely surprising—there are many overlapping characteristics
    of good code; the benefits of one technique will be seen in several areas of code
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: Write Simple Code with Good Presentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Presentation has an enormous impact on the clarity of code. Thoughtful layout
    conveys the structure of the code; it makes functions, loops, and conditional
    statements clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Make the "normal" path through your code obvious. Error cases should not confuse
    the normal flow of execution. Your *if-then-else* constructs should be ordered
    consistently (i.e., always place the "normal" case before the "error" case, or
    vice versa).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid too many nested statements. They lead to complex code that needs lengthy
    explanation. Common wisdom claims that each function should have one and *only*
    one exit point; this is known as *Single Entry, Single Exit (SESE)* code. But
    this is actually too restrictive for readable code and leads to deep levels of
    nesting. I prefer the `fibonacci` example we saw previously to this SESE variant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the sake of an extra `return` statement, I'd rather avoid that gratuitous
    nesting—it has made the function much harder to read. `return`s deep in the middle
    of a function's logic *are* questionable, but simple short circuits at the top
    aid function readability immensely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be wary of optimizing code so that it's no longer a clear expression of abasic
    algorithm. *Never* optimize code unless you've proved that it *is* a bottleneck
    to acceptable program function. Optimize only then, and clearly comment about
    what's going on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose Meaningful Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All variable, type, file, and function names should be meaningful, not misleading.
    A name should faithfully describe what it represents. If you can't name something
    meaningfully, then do you really understand what it's doing? Your naming scheme
    should be consistent so that there are no nasty surprises. Make sure that a variable
    is only ever used for what its name implies.
  prefs: []
  type: TYPE_NORMAL
- en: Good names are probably our best way of avoiding gratuitous comments. They are
    the nearest thing we have in code to the expressiveness of natural language.
  prefs: []
  type: TYPE_NORMAL
- en: Decompose into Atomic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way that you split the code into functions and the names you give those
    functions can either add meaning to code or totally strip it of sense.
  prefs: []
  type: TYPE_NORMAL
- en: '*One function, one action*. Make that your mantra. Don''t write complex functions
    that make coffee, clean shoes, *and* guess the number you first thought of. In
    one function, do one action. Choose a name that unambiguously explains that action.
    A good name means that no extra documentation is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize any surprising *side effects*, no matter how benign they appear. They
    require extra documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep it short. Short functions are easy to understand. You can get your head
    around a complex algorithm if it's broken into small pieces with descriptive names,
    but you can't if it's a sprawling mess of code on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose Descriptive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As much as possible, describe constraints or behavior with the available language
    features. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are defining a value that will never change, enforce it as a constant
    type (use `const` in C).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a variable should not contain a negative value, use an unsigned type (if
    your language provides one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use enumerations to describe a related set of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select appropriate types. In C/C++, put sizes in `size_t` variables and pointer
    arithmetic results in `ptrdiff_t` variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stumbling over some code that reads `if (counter == 76)` will leave you scratching
    your head. What is the magic significance of the number 76? What is the intent
    of that test?
  prefs: []
  type: TYPE_NORMAL
- en: These so-called *magic numbers* are evil. They hide meaning. Writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'is much clearer. If you use the constant `76` (sorry, `bananas_per_cake`) a
    lot in your code, you gain an additional benefit: When you need to change the
    banana-to-cake ratio, you only need to make one code change, rather than perform
    an error-prone search-and-replace for every `76` in the project.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid magic numbers. Use well-named constants instead*.'
  prefs: []
  type: TYPE_NORMAL
- en: This holds true for constant strings as well as numbers. Question the use of
    *any* literal in your code, especially when you use it several times over—can
    you use a more maintainable named constant instead?
  prefs: []
  type: TYPE_NORMAL
- en: Emphasize Important Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make important stuff stand out from mundane stuff. Draw the reader's attention
    to the right places. There are many coding opportunities to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Order the declarations in a class helpfully. Public information should come
    first, since this is what the class user needs to see. Put the private implementation
    details at the end, since they are less important to most readers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wherever possible, hide all nonessential information. Don't clutter the global
    namespace with unnecessary cruft. In C++ you can use the pimpl idiom to hide class
    implementation details (Meyers 97).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't hide important code. Write only one statement per line, and keep each
    statement simple. You *can* write very clever `for` loops, putting all the logic
    on one line with an assortment of commas, but it's not easy to read. Don't do
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of nested conditional statements. If you don't, the handling
    of important conditions will become hidden by a nest of `if`s and braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Make sure all important code stands out and is easy to read. Hide anything
    that the client audience doesn''t care about*.'
  prefs: []
  type: TYPE_NORMAL
- en: Group-Related Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Present all related information in one place. Otherwise, you'll not only make
    the reader jump through hoops, you'll require him to know via ESP where the hoops
    are. The API for a single component should be presented in a single file. If there
    is so much related information that it becomes messy to present it all together,
    question the code's design.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, group items by a language construct. In C++ and C# we can
    group items within a `namespace`. Java provides `package`s as grouping mechanisms.
    Related constant values can be defined in an `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Group information together intentionally. Use language features to make this
    grouping explicit*.'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a File Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Place a comment block at the top of a file to describe its contents and the
    project to which it belongs. This takes only a little effort, but it can make
    a big difference. When someone comes to maintain that file, they'll have a good
    idea what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This header can be important: Most companies mandate that every source file
    contains a visible copyright notice for legal reasons. File headers commonly look
    something like the following.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Handle Errors Appropriately
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handle any error in the most appropriate context. If there is a disk I/O problem,
    you should handle it in code that accesses the disk. Perhaps handling this error
    would mean raising a different error (like a "couldn't load file" exception) to
    a higher level. This means that at each level in the program, an error is an accurate
    description of what the problem is *in that context*. Don't handle hard disk corruption
    in the user interface code—it doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Self-documenting code helps the reader to understand where an error came from,
    whatit means, and its implications for the program at that point.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t return nonsensical errors. Present the appropriate information in each
    context*.'
  prefs: []
  type: TYPE_NORMAL
- en: Write Meaningful Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, we've tried to avoid writing comments by using other implicit
    code documentation techniques. However, once you've written the clearest code
    you can, you need to comment what remains. Clear code contains an *appropriate*
    amount of commenting. What is this appropriate amount?
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Only add comments if you can''t improve the clarity of the code in any other
    way*.'
  prefs: []
  type: TYPE_NORMAL
- en: Think about all these other techniques first. Would a name change or a new subordinate
    function make the code clearer and avoid a comment?
  prefs: []
  type: TYPE_NORMAL
- en: '**SELF-IMPROVEMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: How do you get better at writing self-documenting code? Let's head back into
    bookwriting territory for some clues.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a simple principle for improving your writing skills: *If you read
    a lot, you become a better writer*. Critically reading the works of recognized
    authors teaches you what works and what doesn''t. You pick up new techniques and
    idioms to add to your arsenal.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you read a lot of code, you'll become a better programmer. If
    you immerse yourself in *good* code, you'll soon be able to smell bad code a mile
    away. Customs officials see so many passports each day that a forged one stands
    out like a sore thumb. Even clever imitations become obvious. Bad code becomes
    so much more striking when you're sensitive to the warning signs.
  prefs: []
  type: TYPE_NORMAL
- en: With this experience you'll naturally find yourself using good techniques in
    yourown code. You'll begin to spot when you write bad code; it will feel uncomfortable.
  prefs: []
  type: TYPE_NORMAL
- en: Practical Self-Documentation Methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll conclude this chapter by comparing two specific code documentation methods.
    Remember that these methods come *after* the techniques we've just seen. Kernighan
    and Plaugher said, "Don't document bad code—rewrite it." (Kernighan Plaugher 78)
  prefs: []
  type: TYPE_NORMAL
- en: Literate Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Literate programming* is an extreme self-documenting code technique, conceived
    by the renowned computer scientist Donald Knuth. He wrote a book by this name
    that described it. (Knuth 92) It is a radical alternative to the traditional programming
    model, although some people think the literate programming episode of Knuth''s
    careerwas a large and unfortunate sidetrack. Even if it''s not the One True Way
    to code, there are still things we can learn from it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind literate programming is simple: You don''t write a program,
    you write a document. The documentation language is bound up tightly with the
    programming language. Your document is primarily a description of *what* is being
    programmed, but also happens to compile *into* that program. The source code is
    the documentation, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: A literate program is written almost as a story; it is easy for the human reader
    tofollow, perhaps even enjoyable to read. It is not ordered or constrained for
    a language parser. This is more than just a language with inverted comments; it's
    an inverted method for programming. Literate programming is a whole different
    way of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth originally mixed TEX (a markup language for document typesetting) and
    C in a system called *WEB*. A literate programming tool parses the program file
    and generates either formatted documentation or source code that can be fed into
    a traditional compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just another programming technique, like structured programming
    or object-oriented programming. It doesn't *guarantee* quality documentation.
    That is, as ever, up to the programmer. However, literate programming shifts the
    emphasis toward writing a description of the program rather than just writing
    code that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: Literate programming really comes into its own during a product's maintenance
    phase. With good quality (and quantity of ) documentation directly on hand, it
    becomes much easier to maintain the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many useful qualities of literate programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Literate programming places emphasis back on writing documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes you think about your code in a different way since you write explanations
    and justifications as you go along.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are more likely to update the documentation when you make changes to the
    code, since it's situated conveniently nearby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are guaranteed to only have one document for the whole codebase. You'll
    always be able to view the correct version for the code you're working on—it *is*
    the code you're working on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literate programming encourages the inclusion of items not normally foundin
    source comments. For example: a description of the algorithms used, proofs of
    correctness, and the justification of design decisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, literate programming isn''t a magical cure-all. It has some serious
    drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Literate programs are harder to write, because most programmers don't find it
    natural. We tend not to think of code as a printed document that needs formatting.
    Rather, we mentally model control flows and interacting objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra compilation steps are required, which make literate programs slowerto
    work with. There is still no *really* good tool support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's quite difficult to process a literate program, since the compiler needs
    to extract all the program fragments and reassemble them, in the correct order.
    Whileit's nice to write the document in any order, C can be quite specific about
    how it wants to see code; `#includes` must come first, for example. This leads
    to some practical compromises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might end up documenting some code that doesn't really need it. And the
    alternative, not documenting swathes of simple code, often happens too. This is
    no longer a good literate program; you may as well not have bothered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *everything* is being written about, you can miss the few important bits
    of documentation in all the noise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Knuth talked about *the programmer as essayist*. Many a programmer couldn't
    write an essay to save his life, but he can write the most exquisite code. Maybe
    these guys are exceptions to the rule, but not every good programmer is a capable
    literate programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tying documentation intimately to code can be problematic. You may have frozen
    your code for a major release—no changes are allowed—but you still need to work
    on the documentation. Altering the documentation means altering the source code.
    Now you have an executable-release version and a documentation-release version
    of the same codebase that you have to tie together: a management nightmare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A later chapter discusses software specifications; how does literate programming
    relate to specifications? A literate program will never replace a functional specification
    describing what work needs to be done. However, it should be possible to develop
    a literate program from such a specification. The literate program really is more
    of a combination of traditional code with a design and implementation specification.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a breed of programming tool that sits halfway between the literate
    programming approach and writing external specifications. These tools generate
    documentation from your source code by pulling out blocks of specially formatted
    comments. This technique has become particularly fashionable since Sun introduced
    Javadoc as a core component of the Java platform. All ofthe Java API documentation
    is generated by Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand exactly how this works, we''ll look at an example. The exact
    comment formats may differ, but to document a `Widget` class, you''d write something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The documentation tool will parse each of your project's files, extract the
    documentation, build a cross-referenced database of all the information it finds
    on the way, andspit out a pretty document containing this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can document pretty much any code you write: classes, types, functions,
    parameters, flags, variables, namespaces, packages, and so on. There are facilities
    to capture alot of information, including the ability to:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify copyright information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document the date of creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-reference information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark old code as deprecated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a short synopsis for quick reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present a description of each function parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many documentation tools available, both open source and commercial.
    We've already mentioned Javadoc; other popular tools are C#'s NDoc and the excellent
    Doxygen ([www.doxygen.org](http://www.doxygen.org)).
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent approach to documentation, allowing you to document code
    at a sensible level of detail without writing a separate specification. You can
    easily read your documentation in the source files too, which can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation tools offer many benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Like literate programming, this approach encourages you to write documentation
    and keep it up to date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No separate step is required to get compilable code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's more natural, not requiring massive adjustments or a steep learning curve.
    While the code can be used to generate a document, you don't have to artificially
    make your code look like a book or worry about tedious text layout concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation tools support rich searching, cross-referencing, and code-outlining
    features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it is important to understand the consequences of comment-based code
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike literate programming, it's really only useful for API documentation,
    not internal code documentation. You must use regular comments at the statement
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's hard to glance at a source file and get an overview of the contents, since
    they are spaced out by reams of documentation comments. You'd have to use the
    overview output of the tool instead. This may be beautifully formatted, but it's
    inconvenient to view when you're immersed in the world of the code editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use literate documentation tools to automatically generate documentation from
    your code*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is a powerful way to write documentation, you *can* still write
    bad documentation using it. These are some helpful heuristics for getting it right:'
  prefs: []
  type: TYPE_NORMAL
- en: For each publicly visible item, write a one- or two-sentence description;don't
    go overboard with reams of text. A slew of prose is slow to read and hard to update.
    Don't waffle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document variables or parameters if it's not clear what they're used for, but
    don't document them if their names make it obvious. You don't need to document
    every last detail if it doesn't add any value. The tool's output will still include
    the item, just with no textual explanation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If some of a function's parameters are used for input and some for output, make
    this clear in their descriptions. Few languages provide a syntactic mechanism
    to express this, so you must document it explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document any function pre- or postconditions, what exceptions might be thrown,
    and any of a function's side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The skill of writing is to create a context in which other people can think*.'
  prefs: []
  type: TYPE_NORMAL
- en: --Edwin Schlossberg
  prefs: []
  type: TYPE_NORMAL
- en: We write code primarily to communicate. Code without documentation is a perilous
    thing, hardly communicative. It is a high-maintenance problem. *Bad* documentation
    is no better, either misleading the reader or resulting in a flimsy program that
    relies on external explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Often the only documentation we have for a piece of code *is* that code itself.
    Making the code self-documenting and clear to read goes some way to remedy this
    situation. Self-documenting code doesn't happen magically, you have to carefully
    think about it. The result is code that looks like it *was* easy to write.
  prefs: []
  type: TYPE_NORMAL
- en: Literate programming is one (quite extreme) method of writing self-documenting
    code. Another less extreme method employs documentation tools. These tools can
    generate API documentation very easily, but they don't necessarily replace all
    written specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Seek to write clear, self-documenting code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to write the least amount of documentation necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about the needs of programmers who will maintain their code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Are proud that they write unfathomable spaghetti
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid writing any documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't care about updating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think, "If it was hard for me to write, it should be hard for anyone else to
    understand."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207456.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  prefs: []
  type: TYPE_NORMAL
- en: Good names are powerful tools when writing self-documenting code.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Passing Comment**'
  prefs: []
  type: TYPE_NORMAL
- en: When you do resort to writing comments, this is how to do it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Code should document itself, but we still need separate specifications for many
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 480.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping related code will make its relationships clear. How can we perform
    this grouping? Which methods document the relationships most strongly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should avoid using *magic numbers* in our code. Is zero a magic number? What
    should you call a constant value representing zero?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-documenting code makes good use of context to convey information. Show
    how you do this, and give an example of how a particular name would lead to a
    different interpretation in different functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it realistic to expect a newcomer to pick up some self-documenting code and
    understand it totally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If code is truly self-documenting, how much other documentation is required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why must more people than the original author understand any piece of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This simple C *bubblesort* function could use some improvement. What specific
    things are wrong with it? Write an improved, self-documenting version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with code documentation tools brings up some interesting issues. What's
    your opinion on these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you review the documentation, should you perform a *code review*, looking
    at the comments in the source files, or a *specification review*, looking at the
    generated documents?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Where do you put documentation of protocols and other non-API issues?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you document private/internal functions? In C/C++, where do you place this
    documentation—in the header file or implementation file?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In a large system, should you create a single, large API document or several
    smaller documents, one per area? What are the advantages of each approach?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're working on a codebase that isn't literately documented, and you need
    to alter or add new methods or functions, is it a good idea to give them literate
    documentation comments, or should you leave them undocumented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to write self-documenting assembly code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What do you consider to be the best documented code you've come across? What
    made it so?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did this code have a large number of external specifications? How many of them
    did you read? How can you be sure you knew enough about the code without reading
    them all?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How much of this do you think was due to the author's programming style, and
    how much was because of any house style or guidelines he or she worked to?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you write in more than one language, how does your documentation strategy
    differ in each?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last code you wrote, how did you make the important stuff stand out?
    Did you hide private information away appropriately?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're working on a team, how often do others come to you to ask you how
    something works? Could you avoid this with better-documented code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5. A PASSING COMMENT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*How to Write Code Comments*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments are free but facts are sacred.
  prefs: []
  type: TYPE_NORMAL
- en: --Charles Prestwich Scott
  prefs: []
  type: TYPE_NORMAL
- en: Comments are a lot like opinions. You're free to make them, but just because
    you do doesn't mean they're right. In this chapter, we'll spend a little time
    thinking about the details of writing these things. There's a lot more to writing
    comments than you'd think.
  prefs: []
  type: TYPE_NORMAL
- en: Probably one of the first things you learned when you were taught to program
    was how to write comments. You were told that comments aid the readability of
    code, and you were probably encouraged to write lots of them. But in this game,
    we need to be thinking more about *quality* than *quantity*. Comments are our
    lifelines, memory jogs, and guides through code. We should treat them with the
    respect they deserve.
  prefs: []
  type: TYPE_NORMAL
- en: I set my syntax-highlighting code editor to display comments in green. This
    way, I get an immediate feeling for the quality of a piece of code and how easy
    it's going to be to work with as soon as I load up a source file. A nice proportion
    of green spread through in the right pattern makes me feel good about the world.
    The opposite makes me stroll to the kitchen for a strong coffee before going any
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Comments can make the difference between bad code and good code, between a grossly
    complex and unfathomable morass of logic and a nice set of clear algorithms. But
    let's not overstate the case—there are things far more important to get right
    than comments. When you've written truly good code, your comments are the *icing
    on the cake*, delicately placed to add aesthetics and value, rather than liberally
    slapped on to cover up all the cracks and blemishes.
  prefs: []
  type: TYPE_NORMAL
- en: Good commenting is a strategy to avoid intimidating code. Comments aren't a
    magic additive to turn sour code sweet.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Code Comment?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't skip this section! Admittedly, this is an excruciating place to start.
    We all know what a code comment is, right? But it is more philosophical than you
    might think.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactically, a comment is a block of source that the compiler will ignore.
    Put what you like in it, the names of your grandchildren or the color of your
    favorite shirt; the compiler won't bat an eye as it merrily parses its way through
    the file.^([[1](#ftn.CHP-5-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Semantically, a comment is the difference between a dingy dirt track and a well-lit
    highway. The comment is an annotation of the code it's situated by. You can use
    it as a highlighter to make a particular problem area stand out or as a documentation
    medium in your header file. You might use comments to describe the shape of an
    algorithm, to aid the maintenance programmer (which could be you later on), or
    to mark the space between each function to help you navigate through a source
    file more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are aimed at the human reader, not the computer. In this sense, comments
    are the most human-focused brick in the programming wall. They are ornately molded
    bricks, as opposed to structural breeze blocks. If we want to improve the quality
    of our comments, we need to look at and address what the human really needs as
    he reads code.
  prefs: []
  type: TYPE_NORMAL
- en: Code comments are not the only documentation that you should put in your code.
    Comments are not specifications. They are not design documents. They are not API
    references.^([[2](#ftn.CHP-5-FN-2)]) However, they are an invaluable form of documentation
    that will always be physically attached to the code (unless someone maliciously
    hits DELETE). Their close proximity means they're more likely to be updated and
    more likely to be read in context. It's an internal documentation mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: As responsible programmers, we have a duty to comment well.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-5-FN-1)]) Of course, the thing that chews up and spits out the comments
    differs with the kind of language you're using. In C/C++, the monstrous *preprocessor*
    beast devours comments before the compile stage begins. In other languages, the
    compiler itself throws away comments as it tokenizes the source. In interpreted
    languages, your intense commenting may slow down execution, since the interpreter
    has to jump over the names of all your grandchildren.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-5-FN-2)]) Well, unless you use a literate programming tool, discussed
    in "[Literate Programming](ch04s03.html#literate_programming "Literate Programming")"
    on page 66.
  prefs: []
  type: TYPE_NORMAL
- en: What Do Comments Look Like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, they're green aren't they? At least they are for me.
  prefs: []
  type: TYPE_NORMAL
- en: C comments come in blocks between `/*` and `*/` and can span any number of lines.
    C++, C99, C#, and Java add the single line comment that follows `//`. Other languages
    provide similar *block* and *line* comment facilities, but with different syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is elementary subject matter. But the different comment markers
    are often used in subtly different ways. We'll see examples as we go along. However,
    any commenting scheme that makes cute use of subtle syntax differentiations should
    be viewed warily.
  prefs: []
  type: TYPE_NORMAL
- en: How Many Comments?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vigorous writing is concise.
  prefs: []
  type: TYPE_NORMAL
- en: --William Strunk Jr.
  prefs: []
  type: TYPE_NORMAL
- en: We need to focus on comment quality, not quantity, so more important than the
    amount of comments we write are the contents of those comments. The next section
    discusses this.
  prefs: []
  type: TYPE_NORMAL
- en: Student programmers are taught to write comments, and lots of them. But there
    is such a thing as *too much* commenting—you can obscure important sections of
    code in a dense forest of words. Code quality suffers when you have to spend more
    time wading through complex paragraphs of comments than the actual code that you
    need to read.
  prefs: []
  type: TYPE_NORMAL
- en: I liken this skill to being a good musician. Playing in a band is not about
    how much noise you can make at every conceivable opportunity. The more you play
    your instrument, the more complex the overall sound, and the worse the music.
    Likewise, too many comments muddle the code. A good musician doesn't have to think,
    *When should I stop playing and let someone else have a chance?* A good musician
    only plays when it will really add something. It's about playing the *minimum*
    you can to create the best sound possible. The beauty is in the space. We should
    only be writing comments when they really add something.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn to write* enough *comments, and no more. Favor quality, not quantity*.'
  prefs: []
  type: TYPE_NORMAL
- en: The people who will read your comments can also read the code, so try to document
    as much as possible *in the code itself*, rather than in comments. It's what they'll
    believe, anyway—comments have a nasty tendency to lie. Consider your code statements
    the first level of comment, and make them self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: Well-written code doesn't actually need comments, because everything should
    be self-explanatory. Function names like `f()` and `g()` scream out for comments
    to describe them, but `someGoodExample()` doesn't ask for a comment at all. You
    can see it's a good example function name.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Spend your time writing code that doesn''t need to be propped up by tons of
    comments*.'
  prefs: []
  type: TYPE_NORMAL
- en: The fewer comments you write, the less chance you have of writing bad comments.
  prefs: []
  type: TYPE_NORMAL
- en: What Goes Inside Our Comments?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of writing well the source and fountainhead is wise thinking.
  prefs: []
  type: TYPE_NORMAL
- en: --Horace
  prefs: []
  type: TYPE_NORMAL
- en: 'Bad comments are worse than no comments at all—they will misinform and mislead
    the reader. So what sort of thing should you write in comments? Here are a few
    basic steps to improve the quality of your comment content:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain Why, Not How
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a key point, so read this paragraph twice. Then eat the page. Your comments
    should not describe *how* the program works. You can see that by reading the code.
    After all, the code is the definitive description of how the code works. And it
    has been written clearly and comprehensibly, hasn't it? You should instead focus
    on describing *why* something is written the way it is or what the next block
    of statements ultimately achieves.
  prefs: []
  type: TYPE_NORMAL
- en: Constantly check whether you're writing `/* update WidgetList structure from
    GlbWLRegistry */` or `/* cache widget information for later */`. They might equate
    to the same thing, but the latter conveys the intent of the code, while the former
    just tells you what it's doing.
  prefs: []
  type: TYPE_NORMAL
- en: As you maintain a section of code, the reason *why* it exists will change less
    often than *how* it achieves that purpose, making this sort of comment's maintenance
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Good comments explain* why *not* how.'
  prefs: []
  type: TYPE_NORMAL
- en: You might also use a comment to explain why you have made a particular implementation
    choice. If you have two possible implementation strategies and you decide on one
    over the other, then consider whether it is worth adding a comment explaining
    this rationale.
  prefs: []
  type: TYPE_NORMAL
- en: Don't Describe the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Worthless descriptive comments can be obvious: `++i; // increment i`. They
    can also be more subtle: a lengthy comment description of a complex algorithm,
    followed by the implementation of the algorithm. There is no need to restate code
    laboriously in English unless you''re documenting a really complex algorithm that''s
    impenetrable without it. And then you should probably worry more about rewriting
    the algorithm than the comment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Honor the golden rule*: One fact—one source. *Don''t duplicate code in a comment*.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't Replace Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you see a comment stating something that could be enforced by the language
    itself (e.g., `// this variable should only be accessed by class foo`), then look
    to express it in concrete syntax.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself writing reams of comments to explain how a complex algorithm
    works, stop. First pat yourself on the back for trying to document what's going
    on. But then consider whether you could change the code or the algorithm to make
    it clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you could split the code into several well-named functions to reflect
    the program logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't write comments to describe the use of a variable; rename the variable.
    The comment you were going to write will often tell you what the name of the variable
    should be!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are documenting a condition that should always hold, perhaps you should
    be writing an assertion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you don't need to prematurely optimize (and thus obfuscate) your
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you find yourself writing dense comments to explain your code, step back.
    Is there a bigger problem to solve?*'
  prefs: []
  type: TYPE_NORMAL
- en: Keep It Useful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good comment usually takes several iterations to move up the quality ladder,
    just like code. Make sure your comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document the unexpected**'
  prefs: []
  type: TYPE_NORMAL
- en: If any bits of code are unusual, unexpected, or surprising, document them with
    a comment. You'll thank yourself when you come back later, having forgotten all
    about the problem. If there are specific work-arounds, say for an operating system
    issue, then mention this in a comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flip side of this is that you don''t need to document the obvious. Remember:
    *Don''t repeat the code!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tell the truth**'
  prefs: []
  type: TYPE_NORMAL
- en: When is a comment not a comment? When it's a lie. Okay, you'll never deliberately
    write lies, but it's easy to accidentally introduce mistruths, especially when
    modifying code that has already been commented. Later code changes can easily
    render a comment inaccurate; "[Working with Comments](ch05s07.html "Working with
    Comments")" on page 84 describes tactics to cope with this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are worthwhile**'
  prefs: []
  type: TYPE_NORMAL
- en: Little witty cryptic comments may be witty, and they might be little, but *don't*
    put them in. They get in the way and cause confusion. Avoid expletives, inside
    jokes that only you understand, and comments that are unnecessarily critical—you
    never know where your code will end up in a month or year's time, so don't write
    comments that could cause you embarrassment later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are clear**'
  prefs: []
  type: TYPE_NORMAL
- en: Your comment serves to annotate and explain the code. Don't be ambiguous. Be
    as specific as you can (without writing a thesis about each line). If someone
    reads your comment and is left wondering what it means, then you have made the
    code *worse* and slowed down their comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are comprehensible**'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to write complete, grammatically correct English sentences inside
    every comment you write. However, the comment *must* be readable. Cute abbreviations
    of words usually only serve to confuse the reader—especially if English is not
    his or her first language.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Think about what you''re writing in a comment; don''t type without using your
    brain. Read it back again in the context of the code. Does it contain the* right
    *information?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A WAR STORY**'
  prefs: []
  type: TYPE_NORMAL
- en: 'I once did some consulting work for a company that had a mixture of programmers:
    some were native English speakers, some native Greek speakers. The Greeks could
    all speak excellent English, but not one of the English speakers could speak Greek
    (no surprise there).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the Greek programmers wrote comments in Greek and, when politely asked,
    refused to change this practice. The English programmers couldn't read these comments
    because they were, quite literally, *all Greek to me*!
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Distractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments serve to illuminate the surrounding code, so we must avoid anything
    that distracts from it. Comments should only *add value*. Avoid comments that
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The past**'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to keep a record of how we *used* to do something. The revision
    control system does that. We don't need to see old code reproduced in comments,
    nor a description of an old algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code you don''t want**'
  prefs: []
  type: TYPE_NORMAL
- en: Don't knock out code by enclosing it in comments. It's confusing. Even when
    debugging *commando style* (no pants, no debugger, and no `printf`s), *don't*
    hide code you need to remove in a comment block. Use C's `#ifdef 0` . . . `#endif`
    or some equivalent. These constructs nest and have clearer intent (especially
    important if you forget to come back later and tidy up).
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII art**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid ASCII art pictures or anything else that tries to highlight code in clever
    ways. This, for example, is a bad idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It won't make sense in editors with variable width display fonts. Comments are
    not supposed to double maintenance effort!
  prefs: []
  type: TYPE_NORMAL
- en: '**End of blocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers comment the end of every control block, for example putting
    `// end if (a < 1)` after the closing brace of an `if` statement. This is a redundant
    form of comment; it needs to be filtered out before real comprehension can occur.
    The bottom of a block should be visible on the same page as the top, and the code
    layout should make its start and end clear. All extra verbiage should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: In Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following example illustrates these commenting principles. Consider the
    following snippet of C++ code. Idiomatic criticisms aside, it is not at all clear
    what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Yuck. There''s some room for improvement here, so let''s improve. The code
    can be made less cryptic by applying sensible layout rules and adding a few comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better! Now it''s entirely clear what the code snippet is supposed to
    be doing. I''m still not entirely happy, though. With appropriate function and
    variable names, we no longer need any comments at all, since the code describes
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that I didn't rename `i` to something more long-winded. It's a loop variable
    with a very small scope. Calling it `loopCounter` would have been overkill and
    would arguably have made the code *harder* to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'It shouldn''t be surprising that we ended up with no comments at all. Remember
    Kernighan and Plaugher''s advice: "Don''t document bad code—rewrite it." (Kernighan
    Plaugher 78)'
  prefs: []
  type: TYPE_NORMAL
- en: A Comment on Aesthetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've no doubt heard people religiously touting about how you should format
    your comments. I'm not going to prescribe the One True Way to format (there is
    no such thing), but there are a few important aspects to consider. Interpret these
    as guidelines, according to your personal taste, rather than as rigid dictates.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All commenting should be clear and consistent. Choose a specific way to lay
    out your comments, and use it throughout. Every programmer has a different sense
    of aesthetics, so choose what works for you. *Do* use a house style if one exists,
    or examine (good) existing code and follow the styles you see there.
  prefs: []
  type: TYPE_NORMAL
- en: Small formatting issues in comment writing may seem trivial—for example, should
    each comment start with a capital letter or not? However, if all your comments
    are randomly capitalized, it conveys a lack of cohesion in the code, as if the
    programmer didn't really think all that carefully when he crafted it.
  prefs: []
  type: TYPE_NORMAL
- en: Clear Block Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax highlighting editors are great because they help comments to stand out.
    But don't rely on them too much. Your code might be read from a monochrome printout
    or viewed in an editor without syntax coloring. The comment work should still
    be easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few strategies can help here, especially regarding block comments. Placing
    the start and end markers (e.g., `/*` and `*/` in C and C++) on their own lines
    makes them stand out. Placing a margin character down the left side of a block
    comment also helps to make it appear as a single item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much better than the alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At the very least, line up the comment text so it's not a jagged mess.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A comment shouldn''t cut across the code and break up the logical flow. Keep
    it at the same level of indentation as the code around it. That way, the comment
    appears to apply to the correct level of the code. I always have to stare hard
    at code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In a loop without braces (which isn't a good idea anyway), *don't* put a comment
    before the single loop body statement—this can lead to all sorts of distaster.
    If you want a comment in there, wrap up the whole thing in braces. It's a far
    safer strategy.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Line Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most comments are written on lines of their own, but sometimes a short single
    line comment can *follow* a code statement. In this case, it''s good practice
    to space out the comment to mark it as clearly apart from the code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is a good example of using comment layout to improve the appearance of
    your code. If each end-of-line comment came directly after the variable declaration,
    they'd look jagged, messy, and require more squinting to read.
  prefs: []
  type: TYPE_NORMAL
- en: Helping You to Read the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments are usually written *above* the code that they describe, not below
    it. This way, the source code reads downward, almost like a book. The comment
    serves to prepare the reader for what is to come.
  prefs: []
  type: TYPE_NORMAL
- en: Used with whitespace, commenting helps to break the code up into "paragraphs."
    A comment introduces a few lines, explaining what they intend to achieve; the
    code immediately follows, then a blank line, then the next block. This is such
    a convention that a comment with a blank line before it feels like a paragraph
    start, whereas a comment sandwiched in the middle of two code lines feels more
    like a statement in brackets or a footnote.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comments are part of the code narrative. Use them in a way that reads naturally*.'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a Low-Maintenance Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's sensible to choose a low-maintenance comment style, or you'll waste time
    fiddling with comments when you should be writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some C coders create comment blocks with a column of asterisks in the left
    margin *and* a column of asterisks as a right margin. Arguably this looks very
    pretty, but the amount of work required to adjust a paragraph of text within such
    margins is immense. When you could have moved on to the next task at hand, you
    have to manually realign all the asterisks on the right. If the programmer used
    tabs, then things get even nastier: If someone with a different-sized tab stop
    opens the file, he or she will wonder what the original programmer was up to—all
    the asterisks will look incredibly ugly and badly lined up.'
  prefs: []
  type: TYPE_NORMAL
- en: The end-of-line comments we saw above are an example of alignment that requires
    some effort. How much work you're prepared to spend is up to you. There is always
    a balance between good-looking source code and maintenance effort. I suppose I
    prefer a little bit of effort to ugly code.
  prefs: []
  type: TYPE_NORMAL
- en: Breakwaters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments are often used as *breakwaters* between sections of code. This is
    where people''s artistic sensibilities take over; programmers use different schemes
    to differentiate major comments (*this is a new section of code*) from minor comments
    (*this describes a few of lines of a function*). A source file implementing several
    classes may have something like this between each major section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Some programmers insert large blocks of comment art between each function. Some
    use a long, single-line comment as a rule-off. I just place a couple of blank
    lines between functions. If your functions are so large that you need visual clues
    to see where they start and end, then you need to revise your code.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using these large rules to emphasize every comment in sight. Otherwise,
    nothing gets emphasized. Good indentation and structure, not impressive ASCII
    art, should group code together.
  prefs: []
  type: TYPE_NORMAL
- en: All that being said, well-chosen breakwater comments can help you to quickly
    navigate around a file.
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments can also be used as inline *flags* in the code. There are a number
    of common conventions. You'll see `//XXX`, `//FIXME`, or `//TODO` littered though
    files that are still works in progress. Good syntax-highlighting editors display
    these comments prominently by default. `XXX` is used to mark troublesome code
    or something that needs to be reworked. `TODO` often marks missing pieces of functionality
    for a later return.^([[3](#ftn.CHP-5-FN-3)]) `FIXME` indicates something that's
    known to be broken.
  prefs: []
  type: TYPE_NORMAL
- en: File Header Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every source file should begin with a comment block that describes its contents.
    This is just a quick overview, a preface, providing some essential information
    that you always want displayed as soon as a file is opened. If such a header exists,
    then any programmer who opens the file will have confidence in the contents; it
    shows the file was thoughtfully created rather than just hacked up as a dumping
    ground for some new code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Give every source file a comment prologue*.'
  prefs: []
  type: TYPE_NORMAL
- en: Some people advocate that this header should provide a list of every function,
    class, global variable, and so on that is defined in the file. This is a maintenance
    disaster; such a comment would rapidly become out of date. The kind of information
    this file header *should* contain is the purpose of the file (e.g., *implementation
    of foo interface*) and a copyright statement describing ownership and copying
    rights.
  prefs: []
  type: TYPE_NORMAL
- en: If a source file is automatically generated during the build process, then you
    must arrange for this file to receive a comment header that states very clearly
    (in BIG SCARY CAPITAL LETTERS) where it originated. This will prevent someone
    from mistakenly editing it, only to have the contents regenerated at the next
    build.
  prefs: []
  type: TYPE_NORMAL
- en: The header should *not* contain information that could easily become out of
    date, like the author(s), modifiers, or the date the file was last modified. This
    probably wouldn't be updated often, and would become misleading. Version control
    tells you this anyway. It also needn't contain a source file history describing
    every modification ever made. That information exists in your source control system
    and doesn't need to be duplicated here. Moreover, if you have to scroll through
    10 pages of modification history to get to the first line of code, then the file
    becomes tedious to work with. For this reason, some programmers put it at the
    end of the file instead, but this will still make the file unreasonably large,
    slow to load, and bothersome to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WELL-PLACED COMMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re focusing on *code* comments in this chapter, what we actually type into
    source code. But different breeds of comment graze in neighboring pastures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check in/out comments**'
  prefs: []
  type: TYPE_NORMAL
- en: Your revision control system maintains a history of how each file was modified
    over the life of the project. It associates *metadata* with each revision—at the
    very least, programmer-supplied *check-in comments*. It may also record *checkout
    comments* if it keeps tabs on which files are currently in use. You use these
    comments to describe what you are changing, as a record for posterity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such comments are invaluable, and should be created carefully. They should
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: Short (so you can quickly browse a log of all modifications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accurate (don't get information wrong, or the history is worthless)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete (so you can see all that has happened in a file without manually *diffing*
    revisions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document *what* has changed and *why*, not *how* it has changed. You can use
    the file revision differences to work out how you modified the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where comments about the past belong. It''s also the right place for
    bugtracking references. Don''t be tempted to put information that belongs here
    into source code comments. Remember: *One fact—one source*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**README files**'
  prefs: []
  type: TYPE_NORMAL
- en: These are plaintext files that live in the directories alongside source code
    files. They are useful documentation, falling somewhere between formal specifications
    and code comments. They often contain practical information, perhaps on what each
    file does or on the structure of the file hierarchy; they are basically short
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: READMEs tend to be either haphazard and poorly thought out or badly maintained
    and out of date—which is a shame. When you come across a README file, you naturally
    load it up to see what helpful information it contains. The presence of a README
    shows someone was thinking when they collected the source files together; there
    was something worth documenting and something worthwhile to say about it.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-5-FN-3)]) Be careful with `TODO` comments. You might be better off
    throwing a `TODO` exception instead, which cannot be missed. That way, if you
    forget to implement the missing code, your program will fail in a well-defined
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments are convenient tools to use while you are writing code. But be careful
    not to abuse them.
  prefs: []
  type: TYPE_NORMAL
- en: Helping You to Write Routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common routine-writing approach is to fashion its structure in comments first
    and then fill in the code underneath each comment line. If you work this way,
    you should ask yourself, once finished, whether the remaining comments are still
    useful. Evaluate them against the criteria just discussed, and revise or remove
    them if necessary. Don't just leave them and move on.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is to write the new routine freehand, and then add any necessary
    comments afterward. The danger is that you'll forget to finish the job, or that
    you might not write the best comments—now knowing almost too well how the code
    works. The experienced programmer comments *as he goes along*. Practice shows
    you the right amount of commenting to use.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be afraid of using the flags we saw earlier, like `TODO`, as markers to
    yourself. It will avoid the embarrassment of forgetting to tie up pesky little
    loose ends. You can easily search your entire codebase for these comments to find
    out what still needs to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Bug-Fix Notices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common, but questionable, comment practice is placing notices where faults
    have been fixed. You may stumble over a comment like this in the middle of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Although written with the best intentions (to help you see what's happened in
    the course of development), these comments often do more harm than good. To understand
    the real problem, you'd have to look up the fault in your fault-tracking system
    and pull out the previous revision of the file to investigate what changed. Few
    bug fixes require that kind of reading, so the newcomer can probably live in blissful
    ignorance. These comments proliferate in the later stages of development and during
    maintenance and litter the source code with sidelines, stale information, and
    distractions from the main thread of execution.
  prefs: []
  type: TYPE_NORMAL
- en: There *is* an argument for inserting a comment when you make a non-obvious fix—to
    prevent someone who is revising the code later from reintroducing the bug. However,
    in these well-chosen cases, you are actually *documenting the unexpected* rather
    than placing a bug-fix notice.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comments should live in the* present, *not the past. Don''t describe things
    that have changed, or tell what something used to do*.'
  prefs: []
  type: TYPE_NORMAL
- en: Comment Rot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments rot. Well, all carelessly maintained code tends to rot, acquiring unsightly
    blemishes and losing the original neat design. However, comments seem to rot much
    more quickly than any other piece of code. They become out of date with the code
    they describe. This can be profoundly annoying.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WAR STORY**'
  prefs: []
  type: TYPE_NORMAL
- en: I once worked on a section of code containing the comment *Features A and B
    not yet implemented*. I needed both these facilities, so I wrote them. Only after
    having done so did I discover that feature B *had* already been implemented—I
    had just wasted effort—and feature A was redundant, since the implementation of
    B handled it as well. If the programmer who did this had removed the incorrect
    comment, I would have been spared a *lot* of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple solution is this: When you fix, add, or modify any code, fix, add,
    or modify any comments around it. Don''t just fiddle with a couple of lines and
    move on. Make sure that any code changes don''t turn comments into lies. The corollary
    is: We must make comments easy to keep up to date, or they won''t be updated.
    Comments must be clearly related to their section of code, not placed in obscure
    locations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you alter code, maintain any comments around it*.'
  prefs: []
  type: TYPE_NORMAL
- en: Another bad habit is leaving blocks of code commented out. This will confuse
    you when you come back in a year's time, or when any other programmer stumbles
    across them. If you encounter some code in a comment block, you'll wonder why
    it's there. Was it a fix that was never completed? Is it still a work in progress?
    Did that code never work? Is the rest of the code functionally complete?
  prefs: []
  type: TYPE_NORMAL
- en: Either leave a note explaining why you have commented the code out or remove
    it completely—you can always get it back from the source control system. Even
    if you think you're only knocking something out temporarily, leave yourself a
    note; you may forget to finish it off.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance and the Inane Comment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you wade though an old codebase, it's best not to remove any inane comments
    you find unless they are downright dangerous. Leave them as a warning for future
    maintenance programmers—they give a useful insight into the (lack of) quality
    of the surrounding code. Of course, if you're actually trying to improve that
    piece of code, then do rework the comments as you go! If you find a comment that
    *is* factually wrong or misleading, then you should rewrite it as a part of your
    maintenance of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Learn the interesting area flags like `XXX`, and treat them with respect and
    caution. Also watch for output statements that have been commented out. These
    are a sure sign that there has been a problem area here in the past—treat the
    code with care!
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of comment rot. Just because a comment says *this is defined in foo.c*
    doesn't mean that it is anymore. Always have faith in code and doubt comments.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Major writing is to say what has been seen, so that it need never be said again.
  prefs: []
  type: TYPE_NORMAL
- en: --Delmore Schwartz
  prefs: []
  type: TYPE_NORMAL
- en: We write a lot of comments. That's because we write a lot of code. Learning
    to write the right sort of comment is important, or our code may keel over under
    the weight of inappropriate and outdated commenting.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are no more important than the code they annotate—you can't make bad
    code good using comments. Your aim should be self-documenting code that requires
    no comments at all.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Try to write a *few* really good comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write comments explaining *why*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concentrate on writing good code rather than a plethora of comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write helpful comments that make sense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Can't tell the difference between good and bad comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write comments explaining *how*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't mind if comments only make sense to themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bolster bad code with many comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill their source files with redundant information (revision history, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207458.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  prefs: []
  type: TYPE_NORMAL
- en: Code layout and presentation schemes will affect how you lay out your comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect of self-commenting code: choosing good names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: Discusses *self-documenting code*, a tactic that makes heavy commenting redundant.
    Also describes *literate programming* techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs: []
  type: TYPE_NORMAL
- en: Revision control systems hold file history so you don't need to explain it in
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 485.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How might the *need for* and the *content of* comments differ in the following
    types of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Low-level assembly language (machine code)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Shell scripts
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A single-file test harness
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A large C/C++ project
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can run tools to calculate what percentage of your source code lines are
    comments. How useful are these tools? How accurate a measure is this of comment
    quality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you come across some incomprehensible code, which is the better way to factor
    in some intelligibility: adding comments to document what you think is going on,
    or renaming variables/functions/types with more descriptive names? Which approach
    will most likely be easier? Which approach will be safer?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you document a C/C++ API with a code comment block, should it go in the
    public header file that declares the function or the source file containing the
    implementation? What are the pros and cons of each location?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look carefully at the source files you've recently worked on. Inspect your commenting.
    Is it honestly any good? (I bet as you read through the code you'll find yourself
    making a few changes!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that your comments are genuinely valuable and not just personal
    ramblings that only you can understand?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the people you work with all comment to the same standard, in about the same
    way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who's the best at writing comments? Why do you think that? Who's the worst?
    How much of a correlation does this bear to these individuals' general quality
    of coding?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you think any imposed coding standards could raise the quality of the comments
    written by your team?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you include history logging information in each source file? If yes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you do maintain it manually? Why, if your revision control system will insert
    this for you automatically? Is the history kept particularly accurate?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is this *really* a sensible practice? How often is this information needed?
    Why is it better if placed in the source file than in another, separate mechanism?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you add your initials to or otherwise mark the comments you make in other
    people's code? Do you ever date comments? When and why do you do this—is it a
    useful practice? Has it ever been useful to find someone else's initials and timestamping?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6. TO ERR IS HUMAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dealing with the Inevitable— Error Conditions in Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that the only way to avoid error is to detect it, that the only way
    to detect it is to be free to enquire.
  prefs: []
  type: TYPE_NORMAL
- en: --J. Robert Oppenheimer
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point in life, everyone has this epiphany: *The world doesn''t work
    as you expect it to*. My one-year-old friend Tom learned this when climbing a
    chair four times his size. He expected to get to the top. The actual result surprised
    him: He ended up under a pile of furniture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the world broken? Is it wrong? No. The world has plodded happily along its
    way for the last few million years and looks set to continue for the foreseeable
    future. It''s *our expectations* that are wrong and need to be adjusted. As they
    say: *Bad things happen, so deal with it*. We must write code that deals with
    the Real World and its unexpected ways.'
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly difficult because the world *mostly* works as we'd expect
    it to, constantly lulling us into a false sense of security. The human brain is
    wired to cope, with built-in fail-safes. If someone bricks up your front door,
    your brain will process the problem, and you'll stop before walking into an unexpected
    wall. But programs are not so clever; we have to tell them where the brick walls
    are and what to do when they hit one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t presume that everything in your program will always run smoothly. The
    world doesn''t always work as you''d expect it to: You *must* handle all possible
    error conditions in your code. It sounds simple enough, but that statement leads
    to a world of pain.'
  prefs: []
  type: TYPE_NORMAL
- en: From Whence It Came
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To expect the unexpected shows a thoroughly modern intellect.
  prefs: []
  type: TYPE_NORMAL
- en: --Oscar Wilde
  prefs: []
  type: TYPE_NORMAL
- en: Errors can and will occur. Undersirable results can arise from almost any operation.
    They are distinct from bugs in a faulty program because you *know* beforehand
    that an error can occur. For example, the database file you want to open might
    have been deleted, a disk could fill up at any time and your next save operation
    might fail, or the web service you're accessing might not currently be available.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't write code to handle these error conditions, you will almost certainly
    end up with a *bug*; your program will not always work as you intend it to. But
    if the error happens only rarely, it will probably be a very subtle bug! We'll
    look at bugs in [Chapter 9](ch09.html "Chapter 9. FINDING FAULT").
  prefs: []
  type: TYPE_NORMAL
- en: 'An error may occur for one of a thousand reasons, but it will fall into one
    of these three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User error**'
  prefs: []
  type: TYPE_NORMAL
- en: The stupid user manhandled your lovely program. Perhaps he provided the wrong
    input or attempted an operation that's absolutely absurd. A good program will
    point out the mistake and help the user rectify it. It won't insult him or whine
    in an incomprehensible manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmer error**'
  prefs: []
  type: TYPE_NORMAL
- en: The user pushed all the right buttons, but the code is broken. This is the consequence
    of a bug elsewhere, a fault the programmer introduced that the user can do nothing
    about (except to try and avoid it in the future). This kind of error should (ideally)
    never occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a cycle here: Unhandled errors can cause bugs. And those bugs might
    result in further error conditions occurring elsewhere in your code. This is why
    we consider defensive programming an important practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptional circumstances
  prefs: []
  type: TYPE_NORMAL
- en: The user pushed all the right buttons, and the programmer didn't mess up. Fate's
    fickle finger intervened, and we ran into something that couldn't be avoided.
    Perhaps a network connection failed, we ran out of printer ink, or there's no
    hard disk space left.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a well-defined strategy to manage each kind of error in our code. An
    error may be detected and reported to the user in a pop-up message box, or it
    may be detected by a middle-tier code layer and signaled to the client code programmatically.
    The same principles apply in both cases: whether a human chooses how to handle
    the problem or your code makes a decision—*someone* is responsible for acknowledging
    and acting on errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Take error handling seriously. The stability of your code rests on it*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors are raised by subordinate components and communicated upward, to be
    dealt with by the caller. They are reported in a number of ways; we''ll look at
    these in the next section. To take control of program execution, we must be able
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Raise an error when something goes wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect all possible error reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle them appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propagate errors we can't handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors are hard to deal with. The error you encounter is often not related to
    what you were doing at the time (most fall under the "exceptional circumstances"
    category). They are also tedious to deal with—we want to focus on what our program
    *should* be doing, not on how it may go wrong. However, without good error management,
    your program will be brittle—built upon sand, not rock. At the first sign of wind
    or rain, it will collapse.
  prefs: []
  type: TYPE_NORMAL
- en: Error-Reporting Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several common strategies for propagating error information to client
    code. You'll run into code that uses each of them, so you must know how to speak
    every dialect. Observe how these error-reporting techniques compare, and notice
    which situations call for each mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Each mechanism has different implications for the *locality of error*. An error
    is local in *time* if it is discovered very soon after it is created. An error
    is local in *space* if it is identified very close to (or even *at*) the site
    where it actually manifests. Some approaches specifically aim to reduce the locality
    of error to make it easier to see what's going on (e.g., error codes). Others
    aim to extend the locality of error so that normal code doesn't get entwined with
    error-handling logic (e.g., exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: The favored reporting mechanism is often an architectural decision. The architect
    might consider it important to define a homogeneous hierarchy of exception classes
    or a central list of shared reason codes to unify error-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: No Reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest error-reporting mechanism is *don't bother*. This works wonderfully
    in cases where you want your program to behave in bizarre and unpredictable ways
    and to crash randomly.
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter an error and don't know what to do about it, blindly ignoring
    it is *not* a viable option. You probably can't continue the function's work,
    but returning without fulfilling your function's contract will leave the world
    in an undefined and inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Never ignore an error condition. If you don''t know how to handle the problem,
    signal a failure back up to the calling code. Don''t sweep an error under the
    rug and hope for the best*.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to ignoring errors is to instantly abort the program upon encountering
    a problem. It's easier than handling errors throughout the code, but hardly a
    well-engineered solution!
  prefs: []
  type: TYPE_NORMAL
- en: Return Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next most simple mechanism is to return a success/failure value from your
    function. A boolean return value provides a simple yes or no answer. A more advanced
    approach enumerates all the possible exit statuses and returns a corresponding
    *reason code*. One value means *success*; the rest represent the many and varied
    abortive cases. This enumeration may be shared across the whole codebase, in which
    case your function returns a subset of the available values. You should therefore
    document what the caller can expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this works well for procedures that don''t return data, passing error
    codes back *with* returned data gets messy. If `int count()` walks down a linked
    list and returns the number of elements, how can it signify a list structure corruption?
    There are three approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a compound data type (or *tuple*) containing both the return value and
    an error code. This is rather clumsy in the popular C-like languages and is seldom
    seen in them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the error code back through a function parameter. In C++ or .NET, this
    parameter would be passed by reference. In C you'd direct the variable access
    through pointers. This approach is ugly and nonintuitive; there is no syntactic
    way to distinguish a return value from a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, reserve a range of return values to signify failure. The `count`
    example can nominate all negative numbers as error reason codes; they'd be meaningless
    answers anyway. Negative numbers are a common choice for this. Pointer return
    values may be given a specific invalid value, which by convention is zero (or
    `NULL`). In Java and C#, you can return a `null` object reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique doesn't always work well. Sometimes it's hard to reserve an error
    range—all return values are equally meaningful and equally likely. It also has
    the side effect of reducing the available range of success values; the use of
    negative values reduces the possible positive values by an order of magnitude.^([[1](#ftn.CHP-6-FN-1)])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Error Status Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method attempts to manage the contention between a function's return value
    and its error status report. Rather than return a reason code, the function sets
    a shared global error variable. After calling the function, you must then inspect
    this status variable to find out whether or not it completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The shared variable reduces confusion and clutter in the function's signature,
    and it doesn't restrict the return value's data range at all. However, errors
    signaled through a separate channel are much easier to miss or willfully ignore.
    A shared global variable also has nasty thread safety implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C standard library employs this technique with its `errno` variable. It
    has very subtle semantics: Before using any standard library facility, you must
    manually clear `errno`. Nothing ever sets a succeeded value; only failures touch
    `errno`. This is a common source of bugs, and it makes calling each library function
    tedious. To add insult to injury, not all C standard library functions use `errno`,
    so it is less than consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique is functionally equivalent to using return values, but it has
    enough disadvantages to make you avoid it. Don't write your own error reports
    this way, and use existing implementations with the utmost care.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions are a language facility for managing errors; not all languages support
    exceptions. Exceptions help to distinguish the normal flow of execution from *exceptional*
    cases—when a function has failed and cannot honor its contract. When your code
    encounters a problem that it can't handle, it stops dead and throws up an *exception*—an
    object representing the error. The language run time then automatically steps
    back up the call stack until it finds some exception-handling code. The error
    lands there, for the program to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two operational models, distinguished by what happens after an exception
    is handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The termination model**'
  prefs: []
  type: TYPE_NORMAL
- en: Execution continues after the handler that caught the exception. This behavior
    is provided by C++, .NET, and Java.
  prefs: []
  type: TYPE_NORMAL
- en: '**The resumption model**'
  prefs: []
  type: TYPE_NORMAL
- en: Execution resumes where the exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: The former model is easier to reason about, but it doesn't give ultimate control.
    It only allows *error handling* (you can execute code when you notice an error),
    not *fault rectification* (a chance to fix the problem and try again).
  prefs: []
  type: TYPE_NORMAL
- en: An exception cannot be ignored. If it isn't caught and handled, it will propagate
    to the very top of the call stack and will usually stop the program dead in its
    tracks. The language run time automatically cleans up as it unwinds the call stack.
    This makes exceptions a tidier and safer alternative to handcrafted error-handling
    code. However, throwing exceptions through sloppy code can lead to memory leaks
    and problems with resource cleanup.^([[2](#ftn.CHP-6-FN-2)]) You must take care
    to write *exception-safe* code. The sidebar explains what this means in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHISTLE-STOP TOUR OF EXCEPTION SAFETY**'
  prefs: []
  type: TYPE_NORMAL
- en: Resilient code must be *exception safe*. It must work correctly (for some definition
    of *correctly*, which we'll investigate below), no matter what exceptions come
    its way. This is true regardless of whether or not the code catches any exceptions
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exception-neutral* code propagates all exceptions up to the caller; it won''t
    consume or change anything. This is an important concept for generic programs
    like C++ template code—the template types may generate all sorts of exceptions
    that template implementors don''t understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different levels of exception safety. They are described
    in terms of guarantees to the calling code. These guarantees are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic guarantee**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If exceptions occur in a function (resulting from an operation you perform
    or the call of another function), it will not leak resources. The code state will
    be *consistent* (i.e., it can still be used correctly), but it will not necessarily
    leave in a known state. For example: A member function should add 10 items to
    a container, but an exception propagates through it. The container is still usable;
    maybe no objects were inserted, maybe all 10 were, or perhaps every other object
    was added.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong guarantee**'
  prefs: []
  type: TYPE_NORMAL
- en: This is far more strict than the basic guarantee. If an exception propagates
    through your code, the program state remains completely unchanged. No object is
    altered, no global variables changed, nothing. In the example above, nothing was
    inserted into the container.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nothrow guarantee**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final guarantee is the most restrictive: that an operation can *never*
    throw an exception. If we are exception neutral, then this implies the function
    cannot do anything else that might throw an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Which guarantee you provide is entirely your choice. The more restrictive the
    guarantee, the more widely (re)usable the code is. In order to implement the strong
    guarantee, you will generally need a number of functions providing the nothrow
    guarantee.
  prefs: []
  type: TYPE_NORMAL
- en: Most notably, every destructor you write *must* honor the nothrow guarantee.^([[3](#ftn.CHP-6-FN-3)])
    Otherwise, all exception handling bets are off. In the presence of an exception,
    object destructors are called automatically as the stack is unwound. Raising an
    exception while handling an exception is not permissible.
  prefs: []
  type: TYPE_NORMAL
- en: The code that handles an exception is distinct from the code that raises it,
    and it may be arbitrarily far away. Exceptions are usually provided by OO languages,
    where errors are defined by a hierarchy of exception classes. A handler can elect
    to catch a quite specific class of error (by accepting a leaf class) or a more
    general category of error (by accepting a base class). Exceptions are particularly
    useful for signaling errors in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions don't come for free; the language support incurs a performance penalty.
    In practice, this isn't significant and only manifests around exception-handling
    statements—exception handlers reduce the compiler's optimization opportunities.
    This doesn't mean that exceptions are flawed; their expense is justified compared
    to the cost of not doing any error handling!
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signals are a more extreme reporting mechanism, largely used for errors sent
    by the execution environment to the running program. The operating system traps
    a number of exceptional events, like a *floating point exception* triggered by
    the maths coprocessor. These well-defined error events are delivered to the application
    in signals that interrupt the program's normal flow of execution, jumping into
    a nominated *signal handler* function. Your program could receive a signal at
    any time, and the code must be able to cope with this. When the signal handler
    completes, program execution continues at the point it was interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are the software equivalent of a hardware interrupt. They are a Unix
    concept, now provided on most platforms (a basic version is part of the ISO C
    standard [ISO99]). The operating system provides sensible default handlers for
    each signal, some of which do nothing, others of which abort the program with
    a neat error message. You can override these with your own handler.
  prefs: []
  type: TYPE_NORMAL
- en: The defined C signal events include program termination, execution suspend/continue
    requests, and math errors. Some environments extend the basic list with many more
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-6-FN-1)]) If you used an `unsigned int` then the number of values
    available would increase by a power of two, reusing the `signed int`'s sign bit.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-6-FN-2)]) For example, you could allocate a block of memory and
    then exit early as an exception propagates through. The allocated memory would
    leak. This kind of problem makes writing code in the face of exceptions a complex
    business.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-6-FN-3)]) That's the case in C++ and Java, at least. C# stupidly
    called ~X() a destructor, even though it was a finalizer in disguise. Throwing
    an exception in a C# destructor has different implications.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How you detect an error obviously depends on the mechanism reporting it. In
    practical terms, this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Return values**'
  prefs: []
  type: TYPE_NORMAL
- en: You determine whether a function failed by looking at its return code. This
    failure test is bound tightly to the act of calling the function; by making the
    call, you are implicitly checking its success. Whether or not you do anything
    with that information is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error status variables**'
  prefs: []
  type: TYPE_NORMAL
- en: After calling a function, you must inspect the error status variable. If it
    follows C's `errno` model of operation, you don't actually need to test for errors
    after every single function call. First reset `errno`, and then call any number
    of standard library functions back-to-back. Afterward, inspect `errno`. If it
    contains an error value, then one of those functions failed. Of course, you don't
    know what fell over, but if you don't care, then this is a streamlined error-detection
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceptions**'
  prefs: []
  type: TYPE_NORMAL
- en: If an exception propagates out of a subordinate function, you can choose to
    catch and handle it or to ignore it and let the exception flow up a level. You
    can only make an informed choice when you know what kinds of exceptions might
    be thrown. You'll only know this if it has been documented (and if you trust the
    documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Java's exception implementation places this documentation in the code itself.
    The programmer has to write an *exception specification* for every method, describing
    what it can throw; it is a part of the function's signature. Java is the only
    mainstream language to enforce this approach. You cannot leak an exception that
    isn't in the list, because the compiler performs static checking to prevent it.^([[4](#ftn.CHP-6-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: '**Signals**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only one way to detect a signal: Install a hander for it. There''s
    no obligation. You can also choose not to install any signal handlers at all and
    accept the default behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As various pieces of code converge in a large system, you will probably need
    to detect errors in more than one way, even within a single function. Whichever
    detection mechanism you use, the key point is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Never ignore* any *errors that might be reported to you. If an error report
    channel exists, it''s there for a reason*.'
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to always write error-detection scaffolding—even if an error
    has no implication for the rest of your code. This makes it clear to a maintenance
    programmer that you know a function may fail and have consciously chosen to ignore
    any failures.
  prefs: []
  type: TYPE_NORMAL
- en: When you let an exception propagate through your code, you are not ignoring
    it—you *can't* ignore an exception. You are allowing it to be handled by a higher
    level. The philosophy of exception handling is quite different in this respect.
    It's less clear what the most appropriate way to document this is—should you write
    a `try`/`catch` block that simply re`throw`s the exception, should you write a
    comment claiming that the code *is* exception safe, or should you do nothing?
    I'd favor documenting the exception behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-6-FN-4)]) C++ also supports exception specifications, but leaves
    their use optional. It's idiomatic to avoid them—for performance reasons, among
    others. Unlike Java, they are enforced at run time.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Love truth, and pardon error.
  prefs: []
  type: TYPE_NORMAL
- en: --Voltaire
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors happen. We''ve seen how to discover them and when to do so. The question
    now is: What do you do about them? This is the hard part. The answer largely depends
    on circumstance and the gravity of an error—whether it''s possible to rectify
    the problem and retry the operation or to carry on regardless. Often there is
    no such luxury; the error may even herald the beginning of the end. The best you
    can do is clean up and exit sharply, before anything else goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this kind of decision, you must be informed. You need to know a few
    key pieces of information about the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Where it came from**'
  prefs: []
  type: TYPE_NORMAL
- en: This is quite distinct from where it's going to be handled. Is the source a
    core system component or a peripheral module? This information may be encoded
    in the error report; if not, you can figure it out manually.
  prefs: []
  type: TYPE_NORMAL
- en: '**What you were trying to do**'
  prefs: []
  type: TYPE_NORMAL
- en: What provoked the error? This may give a clue toward any remedial action. Error
    reporting seldom contains this kind of information, but you can figure out which
    function was called from the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why it went wrong**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the nature of the problem? You need to know exactly what happened, not
    just a general *class* of error. How much of the erroneous operation completed?
    *All* or *none* are nice answers, but generally, the program will be in some indeterminate
    state between the two.
  prefs: []
  type: TYPE_NORMAL
- en: '**When it happened**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the locality of the error in time. Has the system only just failed,
    or is a problem two hours old finally being felt?
  prefs: []
  type: TYPE_NORMAL
- en: '**The severity of the error**'
  prefs: []
  type: TYPE_NORMAL
- en: Some problems are more serious than others, but when detected, one error is
    equivalent to another—you can't continue without understanding and managing the
    problem. Error severity is usually determined by the caller, based on how easy
    it will be to recover or work around the error.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to fix it**'
  prefs: []
  type: TYPE_NORMAL
- en: This may be obvious (e.g., insert a floppy disk and retry) or not (e.g., you
    need to modify the function parameters so they are consistent). More often than
    not, you have to infer this knowledge from the other information you have.
  prefs: []
  type: TYPE_NORMAL
- en: Given this depth of information, you can formulate a strategy to handle each
    error. Forgetting to insert a handler for any potential error will lead to a bug,
    and it might turn out to be a bug that is hard to exercise and hard to track down—so
    think about every error condition carefully.
  prefs: []
  type: TYPE_NORMAL
- en: When to Deal with Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*When* should you handle each error? This can be separate from when it''s detected.
    There are two schools of thought.'
  prefs: []
  type: TYPE_NORMAL
- en: '**As soon as possible**'
  prefs: []
  type: TYPE_NORMAL
- en: Handle each error *as* you detect it. Since the error is handled near to its
    cause, you retain important contextual information, making the error-handling
    code clearer. This is a well-known self-documenting code technique. Managing each
    error near its source means that control passes through less code in an invalid
    state.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually the best option for functions that return error codes.
  prefs: []
  type: TYPE_NORMAL
- en: '**As late as possible**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could defer error handling for as long as possible. This
    recognizes that code detecting an error rarely knows what to do about it. It often
    depends on the context in which it is used: A missing file error may be reported
    to the user when loading a document but silently swallowed when hunting for a
    preferences file.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are ideal for this; you can pass an exception through each level
    until you know how to deal with the error. This separation of detection and handling
    may be clearer, but it can make code more complex. It's not obvious that you are
    deliberately deferring error handling, and it's not clear where an error came
    from when you do finally handle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, it''s nice to separate "business logic" from error handling. But
    often you can''t, as cleanup is necessarily entwined with that business logic,
    and it can be more tortuous to write the two separately. However, centralized
    error-handling code has advantages: You know where to look for it, and you can
    put the abort/continue policy in one place rather than scatter it through many
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Thomas Jefferson once declared, "Delay is preferable to error." There is truth
    there; the actual *existence* of error handling is far more important than *when*
    an error is handled. Nevertheless, choose a compromise that's close enough to
    prevent obscure and out-of-context error handling, while being far enough away
    to not cloud normal code with roundabout paths and error handling dead ends.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Handle each error in the most appropriate context, as soon as you know enough
    about it to deal with it correctly*.'
  prefs: []
  type: TYPE_NORMAL
- en: Possible Reactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've caught an error. You're poised to handle it. What are you going to do
    now? Hopefully, whatever is required for correct program operation. While we can't
    list every recovery technique under the sun, here are the common reactions to
    consider.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging**'
  prefs: []
  type: TYPE_NORMAL
- en: Any reasonably large project should already be employing a logging facility.
    It allows you to collect important trace information, and is an entry point for
    the investigation of nasty problems.
  prefs: []
  type: TYPE_NORMAL
- en: The log exists to record interesting events in the life of the program, to allow
    you to delve into its inner workings and reconstruct paths of execution. For this
    reason, all errors you encounter should be detailed in the program log; they are
    some of the most interesting and telling events of all. Aim to capture all pertinent
    information—as much of the previous list as you can.
  prefs: []
  type: TYPE_NORMAL
- en: For really obscure errors that predict catastrophic disaster, it may be a good
    idea to get the program to "phone home"—to transmit either a snapshot of itself
    or a copy of the error log to the developers for further investigation.
  prefs: []
  type: TYPE_NORMAL
- en: What you do *after* logging is another matter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reporting**'
  prefs: []
  type: TYPE_NORMAL
- en: A program should only report an error to the user when there's nothing left
    to do. The user does not need to be bombarded by a thousand small nuggets of useless
    information or badgered by a raft of pointless questions. Save the interaction
    for when it's really vital. Don't report when you encounter a recoverable situation.
    By all means, log the event, but keep quiet about it. Provide a mechanism that
    enables users to read the event log if you think one day they might care.
  prefs: []
  type: TYPE_NORMAL
- en: There *are* some problems that only the user can fix. For these, it is good
    practice to report the problem immediately, in order to allow the user the best
    chance to resolve the situation or else decide how to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this kind of reporting depends on whether or not the program is interactive.
    Deeply embedded systems are expected to cope on their own; it's hard to pop up
    a dialog box on a washing machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recovery**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes your only course of action is to stop immediately. But not all errors
    spell doom. If your program saves a file, one day the disk will fill up, and the
    save operation will fail. The user expects your program to continue happily, so
    be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: If your code encounters an error and doesn't know what to do about it, pass
    the error upward. It's more than likely your caller will have the ability to recover.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore**'
  prefs: []
  type: TYPE_NORMAL
- en: I only include this for completeness. Hopefully by now you've learned to scorn
    the very suggestion of ignoring an error. If you choose to forget all about handling
    it and to just continue with your fingers crossed, *good luck*. This is where
    most of the bugs in any software package will come from. Ignoring an error whose
    occurrence may cause the system to misbehave inevitably leads to hours of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, write code that allows you to *do nothing* when an error crops
    up. Is that a blatant contradiction? No. It is possible to write code that copes
    with an inconsistent world, that can carry on correctly in the face of an error—but
    it often gets quite convoluted. If you adopt this approach, you must make it obvious
    in the code. Don't risk having it misinterpreted as ignorant and incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ignoring errors does not save time. You''ll spend far longer working out the
    cause of bad program behavior than you ever would have spent writing the error
    handler*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Propagate**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a subordinate function call fails, you probably can''t carry on, but you
    might not know what else to do. The only option is to clean up and propagate the
    error report upward. You have options. There are two ways to propagate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: Export the same error information you were fed (return the same reason code
    or propagate exceptions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinterpret the information, sending a more meaningful message to the next level
    up (return a different reason code or catch and wrap up exceptions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ask yourself this question: Does the error relate to a concept exposed through
    the module interface? If so, it''s okay to propagate that same error. Otherwise,
    recast it in the appropriate light, choosing an error report that makes sense
    in the context of your module''s interface. This is a good self-documenting code
    technique.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Implications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Show me the code!* Let''s spend some time investigating the implications of
    error handling in our code. As we''ll see, it is not easy to write good error
    handling that doesn''t twist and warp the underlying program logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first piece of code we''ll look at is a common error handling structure.
    Yet it isn''t a particularly intelligent approach for writing error-tolerant code.
    The aim is to call three functions sequentially—each of which may fail—and perform
    some intermediate calculations along the way. Spot the problems with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Syntactically it's fine; the code will work. Practically, it's an unpleasant
    style to maintain. The more operations you need to perform, the more deeply nested
    the code gets and the harder it is to read. This kind of error handling quickly
    leads to a rat's nest of conditional statements. It doesn't reflect the actions
    of the code very well; each intermediate calculation could be considered the same
    level of importance, yet they are nested at different levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**CRAFTING ERROR MESSAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: Inevitably, your code will encounter errors that the user must sort out. Human
    intervention may be the only option; your code can't insert a floppy disk or switch
    on the printer by itself. (If it can, you'll make a fortune!)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re going to whine at the user, there are a few general points to bear
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Users don''t think like programmers, so present information the way *they''d
    expect*. When displaying the free space on a disk, you might report `Disk space:
    10K`. But if there''s no space left, a zero could be misread as OK—and the user
    will not be able to fathom why he can''t save a file when the program says everything''s
    fine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your messages aren't too cryptic. You might understand them, but can
    your computer-illiterate granny? (It doesn't matter if your granny won't use this
    program—someone with a lower intellect almost certainly will.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't present meaningless error codes. No user knows what to do when faced with
    an `Error code 707E`. It is, however, valuable to provide such codes as "additional
    info"—they can be quoted to tech support or looked up more easily on a web search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distinguish dire errors from mere warnings. Incorporate this information in
    the message text (perhaps with an `Error`: prefix), and emphasize it in message
    boxes with an accompanying icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only ask a question (even a simple one like *Continue: Yes/No?*) if the user
    fully understands the ramifications of each choice. Explain it if necessary, and
    make it clear what the consequence of each answer is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you present to the user will be determined by interface constraints and
    application or OS style guides. If your company has user interface engineers,
    then it's their job to make these decisions. Work with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we avoid these problems? Yes—there are a few alternatives. The first variant
    flattens the nesting. It is semantically equivalent, but it introduces *some*
    new complexity, since flow control is now dependent on the value of a new status
    variable, `ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also added an opportunity to clean up after any errors. Is that sufficient
    to mop up all failures? Probably not; the necessary cleanup may depend on how
    far we got through the function before lightening struck. There are two cleanup
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a little cleanup after each operation that may fail, then return early.
    This inevitably leads to duplication of cleanup code. The more work you've done,
    the more you have to clean up, so each exit point will need to do gradually more
    unpicking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If each operation in our example allocates some memory, each early-exit point
    will have to release all allocations made to date. The further in, the more releases.
    That will lead to some quite dense and repetitive error-handling code, which makes
    the function far larger and far harder to understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the cleanup code once, at the end of the function, but write it in such
    a way as to only clean up what's dirty. This is neater, but if you inadvertently
    insert an early return in the middle of the function, the cleanup code will be
    bypassed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re not overly concerned about writing *Single Entry, Single Exit (SESE)*
    functions, this next example removes the reliance on a separate control flow variable.^([[5](#ftn.CHP-6-FN-5)])
    We do lose the cleanup code again, though. Simplicity renders this a better description
    of the actual intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A combination of this short-circuit exit with the requirement for cleanup leads
    to the following approach, especially seen in low-level systems code. Some people
    advocate it as the *only* valid use for the maligned `goto`. I'm still not convinced.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can avoid such monstrous code in C++ using *Resource Acquisition Is Initialization
    (RAII)* techniques like smart pointers. (Stroustrup 97) This has the bonus of
    providing exception safety—when an exception terminates your function prematurely,
    resources are automatically deallocated. These techniques avoid a lot of the problems
    we've seen above, moving complexity to a separate flow of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example using exceptions would look like this (in C++, Java, and C#),
    presuming that all subordinate functions do not return error codes but instead
    throw exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is only a basic exception example, but it shows just how neat exceptions
    can be. A sound code design might not need the `try`/`catch` block at all if it
    ensures that no resource is leaked and leaves error handling to a higher level.
    But alas, writing good code in the face of exceptions requires an understanding
    of principles beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-6-FN-5)]) Although this clearly isn't SESE, I contend that the previous
    example isn't, either. There *is* only one exit point, at the end, but the contrived
    control flow is simulating early exit—it *might as well* have multiple exits.
    This is a good example of how being bound by a rule like SESE can lead to bad
    code, unless you think carefully about what you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: Raising Hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve put up with other people''s errors for long enough. It''s time to turn
    the tables and play the bad guy: Let''s raise some errors. When writing a function,
    erroneous things will happen that you''ll need to signal to your caller. Make
    sure you do—don''t silently swallow any failure. Even if you''re sure that the
    caller won''t know what to do in the face of the problem, it *must* remain informed.
    Don''t write code that lies and pretends to be doing something it''s not.'
  prefs: []
  type: TYPE_NORMAL
- en: Which reporting mechanism should you use? It's largely an architectural choice;
    obey the project conventions and the common language idioms. In languages with
    the facility, it is common to favor exceptions, but only use them if the rest
    of the project does. Java and C# really leave you with no choice; exceptions are
    buried deep in their execution run times. A C++ architecture may choose to forego
    this facility to achieve portability with platforms that have no exception support
    or to interface with older C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen strategies for propagating errors from subordinate function
    calls. Our main concern here is reporting fresh problems encountered during execution.
    How you determine these errors is your own business, but when reporting them,
    consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have you cleaned up appropriately first? Reliable code doesn't leak resources
    or leave the world in an inconsistent state, even when an error occurs, unless
    it's *really* unavoidable. If you do either of these things, it must be documented
    carefully. Consider what will happen the next time your code is called if this
    error has manifested. Ensure it will still work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't leak inappropriate information to the outside world in your error reports.
    Only return useful information that the caller understands and can act on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use exceptions correctly. Don't throw an exception for unusual return values—the
    rare but not erroneous cases. Only use exceptions to signal circumstances where
    a function is not able to meet its contract. Don't use them non-idiomatically
    (i.e., for flow control).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using assertions (see "[Constraints](ch01s04.html#constraints "Constraints")"
    on page 16) if you're trapping an error that should never happen in the normal
    course of program execution, a genuine programming error. Exceptions are a valid
    choice for this too—some assertion mechanisms can be configured to throw exceptions
    when they trigger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can pull forward any tests to compile time, then do so. The sooner you
    detect and rectify an error, the less hassle it can cause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it hard for people to ignore your errors. Given half a chance, someone
    *will* use your code badly. Exceptions are good for this—you have to act deliberately
    to hide an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What kind of errors should you be looking out for? This obviously depends on
    what the function is doing. Here''s a checklist of the general kinds of error
    checks you should make in each function:'
  prefs: []
  type: TYPE_NORMAL
- en: Check all function parameters. Ensure you have been given correct and consistent
    input. Consider using assertions for this, depending on how strictly your contract
    was written. (Is it an offense to supply bad parameters?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that invariants are satisfied at interesting points in execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check all values from external sources for validity before you use them. File
    contents and interactive input must be sensible, with no missing pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the return status of all system and other subordinate function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AN EXCEPTION TO THE RULE**'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are a powerful error reporting mechanism. Used well, they can simplify
    your code greatly while helping you to write robust software. In the wrong hands,
    though, they are a deadly weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'I once worked on a project where it was routine for programmers to break a
    `while` loop or end recursion by throwing an exception, using it as a non-local
    `goto`. It''s an intersting idea, and kind of cute when you first see it. But
    this behavior is nothing more than an abuse of exceptions: It isn''t what exceptions
    are idiomatically used for. More than one critical bug was caused by a maintenance
    programmer not understanding the flow of control through a complex, magically
    terminated loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the idioms of your language, and don't write cute code for the sake of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The common principle uniting the raising and handling of errors is to have
    a consistent strategy for dealing with failure, wherever it manifests. These are
    general considerations for managing the occurrence, detection, and handling of
    program errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid things that *could* cause errors. Can you do something that is guaranteed
    to work, instead? For example, avoid allocation errors by reserving enough resource
    beforehand. With an assured pool of memory, your routine cannot suffer memory
    restrictions. Naturally, this will only work when you know how much resource you
    need up front, but you often do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the program or routine's expected behavior under abnormal circumstances.
    This determines how robust the code needs to be and therefore how thorough your
    error handling should be. Can a function silently generate bad output, subscribing
    to the historic *GIGO* principle?^([[6](#ftn.CHP-6-FN-6)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly define which components are responsible for handling which errors. Make
    it explicit in the module's interface. Ensure that your client knows what will
    always work and what may one day fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check your programming practice: *When* do you write error-handling code? Don''t
    put it off until later; you''ll forget to handle something. Don''t wait until
    your development testing highlights problems before writing handlers—that''s not
    an engineering approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write all error detection and handling* now, *as you write the code that may
    fail. Don''t put it off until later. If you must be evil and defer handling, at
    least write the detection scaffolding now*.'
  prefs: []
  type: TYPE_NORMAL
- en: When trapping an error, have you found a symptom or a cause? Consider whether
    you've discovered the source of a problem that needs to be rectified here or if
    you've discovered a symptom of an earlier problem. If it's the latter, then don't
    write reams of handling code here, put that in a more appropriate (earlier) error
    handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-6-FN-6)]) That is, *Garbage In, Garbage Out*—feed it trash, and
    it will happily spit out trash.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To err is human; to repent, divine; to persist, devilish.
  prefs: []
  type: TYPE_NORMAL
- en: --Benjamin Franklin
  prefs: []
  type: TYPE_NORMAL
- en: To err *is* human (but computers seem quite good at it, too). To handle these
    errors is divine.
  prefs: []
  type: TYPE_NORMAL
- en: Every line of code you write must be balanced by appropriate and thorough error
    checking and handling. A program without rigorous error handling will not be stable.
    One day an obscure error may occur, and the program will fall over as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and failure cases is hard work. It bogs programming down in
    the mundane details of the Real World. However, it's absolutely essential. As
    much as 90 percent of the code you write handles exceptional circumstances. (Bentley
    82) That's a surprising statistic, so write code *expecting* to put far more effort
    into the things that can go wrong than the things that will go right.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Combine their good intentions with good coding practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the error-handling code *as* they write the main code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are *thorough* in the code they write, covering every error possibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Take a haphazard approach to writing code, with neither thought to nor review
    of what they're doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the errors that arise as they write code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End up conducting lengthy debugging sessions to track down program crashes,
    because they never considered error conditions in the first place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs: []
  type: TYPE_NORMAL
- en: Handing errors in context is one of the many defensive programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: Self-documenting code ensures that error handling is integral to the code narrative.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: Unhandled error conditions will manifest as bugs in the code. Here's how to
    squash them. (It's best to avoid them in the first place, though.)
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207460.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 487.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are *return values* and *exceptions* equivalent error reporting mechanisms?
    Prove it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What different implementations of *tuple* return types can you think of ? Don't
    limit yourself to a single programming language. What are the pros and cons of
    using tuples as a return value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do exception implementations differ between languages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Signals are an old-school Unix mechanism. Are they still needed now that we
    have modern techniques like exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best code structure for error handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you handle errors that occur in your error-handling code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How thorough is the error handling in your current codebase? How does this contribute
    to the stability of the program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you naturally consider error handling as you write code, or do you find it
    a distraction, preferring to come back to it later?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the last (reasonably sized) function you wrote or worked on, and perform
    a careful review of the code. Find every abnormal occurence and potential error
    situation. How many of these were actually handled in your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now get someone else to review it. Don't be shy! Did they find any more? Why?
    What does this tell you about the code you're working on?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do you find it easier to manage and reason about error conditions using *return
    values* or *exceptions*? Are you sure you know what is involved in writing exception-safe
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
