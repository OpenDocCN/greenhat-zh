<html><head></head><body><div class="part" title="Part&#xA0;III-6.&#xA0;TCP/IP GENERAL FILE TRANSFER PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_general_file_transfer_protocols"/>Part III-6. TCP/IP GENERAL FILE TRANSFER PROTOCOLS</h1></div></div></div><div class="partintro" id="id3344189" title="TCP/IP GENERAL FILE TRANSFER PROTOCOLS"><div/><p><a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a></p><p><a class="xref" href="ch73.html" title="Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)">Chapter 73</a></p><p>File and message transfer protocols represent the most basic type of network communication: the simple movement of blocks of data. Of the many file and message transfer methods, the most fundamental application is what I call <span class="emphasis"><em>general file transfer</em></span>. General file transfer protocols perform one main function: allowing files to be copied from one computer to another.</p><p>Since file transfer protocols move files from place to place without much consideration of their contents, they are relatively unsophisticated compared with certain message-processing applications. However, the idea of being able to move files around is so important that general file transfer protocols were one of the very first applications in internetworking. While many people now use electronic mail or web browsers to perform the functions formerly performed exclusively using general file transfer, these older protocols are still very important and widely used, and important to understand.</p><p>This part covers the two TCP/IP general file transfer protocols: the File Transfer Protocol (FTP) and the Trivial File Transfer Protocol (TFTP). Each is described in its own chapter.</p><p>The relationship between FTP and TFTP is similar to that of the two transport protocols, the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP) at layer 4 (discussed in <a class="xref" href="pt11.html" title="Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS">Part II-8</a>). FTP is full-featured, session-oriented, and somewhat complex. It is the more often used of the two protocols, providing a full command interface and taking advantage of the reliability and stream-transfer functions of TCP, over which it runs. TFTP, like the UDP it uses at the transport layer, is a stripped-down version of FTP. It has far fewer commands and capabilities than FTP, but it is ideal for cases where simplicity and small software program size are important, such as in the case of embedded software in devices.</p></div></div>
<div class="chapter" title="Chapter&#xA0;72.&#xA0;FILE TRANSFER PROTOCOL (FTP)"><div class="titlepage"><div><div><h1 class="title"><a id="file_transfer_protocol_ftp"/>Chapter 72. FILE TRANSFER PROTOCOL (FTP)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e76301"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The primary general file transfer protocol in the TCP/IP suite shows its generality directly through its unqualified name: the <span class="emphasis"><em>File Transfer Protocol (FTP)</em></span><a class="indexterm" id="idx-CHP-72-2515"/>. FTP is one of the most widely used application protocols in the world. It was designed to allow the efficient transfer of files between any two devices on a TCP/IP internetwork. It automatically takes care of the details of how files are moved, provides a rich command syntax to allow various supporting file operations to be performed (such as navigating the directory structure and deleting files), and operates using the Transmission Control Protocol (TCP) transport service for reliability.</p><p>In this chapter, I describe in detail the operation of FTP. I begin with an overview of FTP, a discussion of its long history, and the standards that define it. I then explain the key concepts related to FTP and how it functions. This includes a description of the FTP operational model and a look at how FTP control connections are established, how and when normal and passive data connections are used, and FTP's transmission modes and data representation methods. I then move on to the details of FTP commands and how they work, including a discussion of <a class="indexterm" id="idx-CHP-72-2516"/>FTP command groups, reply codes, and user commands. Finally, I provide a sample illustration of a user FTP session showing the internal commands used for each action.</p><div class="sect1" title="FTP Overview, History, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_overview_history_and_standards"/>FTP Overview, History, and Standards</h1></div></div></div><p>The TCP/IP protocol suite as we know it today was developed in the late 1970s and early 1980s, with the watershed event probably the publishing of the version 4 standards of IP and TCP in 1980. Modern TCP/IP was the result of experimentation and <a class="indexterm" id="idx-CHP-72-2517"/>development work that had been underway since the 1960s. This work included both the design and implementation of the protocols that would implement internetworks and also the creation of the first networking applications to allow users to perform different tasks.</p><div class="sect2" title="FTP Development and Standardization"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_development_and_standardization"/>FTP Development and Standardization</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2518"/>The developers of early applications conceptually divided methods of network use into two categories: <a class="indexterm" id="idx-CHP-72-2519"/><span class="emphasis"><em>direct</em></span> and <span class="emphasis"><em>indirect</em></span>. Direct <a class="indexterm" id="idx-CHP-72-2520"/>network applications let a user access a remote host and use it as if it were local, creating the illusion that the remote network doesn't even exist (or at least, minimizing the importance of distance). <a class="indexterm" id="idx-CHP-72-2521"/>Indirect network use meant getting resources from a remote host and using them on the local system, and then transferring them back. These two methods of use became the models for the first two formalized TCP/IP networking applications: Telnet for direct access (see <a class="xref" href="ch87.html" title="Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS">Chapter 87</a>) and the FTP for indirect network use.</p><p>The first FTP standard was RFC 114, published in April 1971, before TCP and IP even existed. This standard defined the basic commands of the protocol and the formal means by which devices communicate using it. At this time, the predecessor of TCP (called the <a class="indexterm" id="idx-CHP-72-2522"/><span class="emphasis"><em>Network Control Protocol</em></span> or <a class="indexterm" id="idx-CHP-72-2523"/><span class="emphasis"><em>NCP</em></span>) was used for conveying network traffic. There was no Internet back then. Its precursor, the <a class="indexterm" id="idx-CHP-72-2524"/>ARPAnet, was tiny, consisting of only a small group of development computers.</p><p>A number of subsequent RFCs refined the operation of this early version of FTP, with revisions published as RFC 172 in June 1971 and RFC 265 in November 1971. The first major revision was RFC 354, published in July 1972, which for the first time contained a description of the overall communication model used by modern TCP and details on many of the current features of the protocol. In subsequent months, many additional RFCs were published that defined features for FTP or raised issues with it. In RFC 542, published in August 1973, the FTP specification looks remarkably similar to the one we use today, more than three decades later, except that it was still defined to run over NCP.</p><p>After a number of subsequent RFCs that defined and discussed changes, the formal standard for modern FTP was published in RFC 765, "File Transfer Protocol Specification," in June 1980. This was the first standard to define FTP operation over modern TCP/IP and was created at around the same time as the other primary defining standards for TCP/IP.</p><p>RFC 959, "File Transfer Protocol (<a class="indexterm" id="idx-CHP-72-2525"/>FTP)," was published in October 1985 and made some revisions to RFC 765, including the addition of several new commands, and it is now the base specification for FTP. Since that time, a number of other standards have been published that define extensions to FTP, better security measures, and other features.</p></div><div class="sect2" title="Overview of FTP Operation"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_ftp_operation"/>Overview of FTP Operation</h2></div></div></div><p>FTP was created with the overall goal of allowing indirect use of computers on a network by making it easy for users to move files from one place to another. Like most TCP/IP protocols, FTP is based on a client/server model, with an FTP client on a user machine creating a connection to an FTP server to send and retrieve files to and from the server. The main objectives of FTP were to make file transfer simple and to shield the user from implementation details of how the files are actually moved from one place to another. To this end, FTP is designed to deal automatically with many of the issues that can potentially arise due to format differences in files stored on differing systems.</p><p>To ensure that files are sent and received without loss of data that could corrupt them, FTP uses the reliable TCP at the transport layer. An authentication system is used to ensure that only authorized clients are allowed to access a server. At the same time, a feature sometimes called <span class="emphasis"><em>anonymous FTP</em></span> allows an organization that wishes it to set up a general information server to provide files to anyone who might want to retrieve them.</p><p>After a TCP connection is established, an FTP control connection is created. Internal FTP commands are passed over this logical connection based on formatting rules established by the Telnet Protocol. Each command sent by the client receives a reply from the server to indicate whether it succeeded or failed. A data connection is established for each individual data transfer to be performed. FTP supports normal and passive data connections, allowing either the server or client to initiate the data connection. Multiple data types and file types are supported to allow flexibility for various types of transfers.</p><p>The interface between an FTP user and the protocol is provided in the form of a set of interactive user commands. After establishing a connection and completing authentication, two basic commands can be used to send or receive files. Additional support commands are provided to manage the FTP connection as well as to perform support functions such as listing the contents of a directory or deleting or renaming files. In recent years, graphical implementations of FTP have been created to allow users to transfer files using mouse clicks instead of having to memorize commands. Also, other applications can use FTP directly to move files from one place to another.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-420"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The most important general file transfer protocol in TCP/IP is the simply named <span class="emphasis"><em>File Transfer Protocol (FTP)</em></span>. The need to be able to move files of any type between machines is so fundamental that FTP's history goes back more than 30 years. FTP runs over TCP to ensure that files are transferred reliably with no data loss. The protocol uses a set of <span class="emphasis"><em>FTP commands</em></span> sent from an FTP client to an FTP server to perform file-transfer operations; the FTP server sends to the client <span class="emphasis"><em>FTP replies</em></span> that indicate the success or failure of commands.<a class="indexterm" id="I_indexterm1_d1e76422"/></p></div></div></div></div>
<div class="sect1" title="FTP Operational Model, Protocol Components, and Key Terminology"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_operational_model_protocol_component"/>FTP Operational Model, Protocol Components, and Key Terminology</h1></div></div></div><p>The standards that define FTP describe its overall operation using a simple conceptual tool called the <span class="emphasis"><em>FTP model</em></span><a class="indexterm" id="idx-CHP-72-2526"/>. This model defines the roles of the devices that participate in a file transfer and the two communication channels that are established between them. It also describes the components of FTP that manage these channels and defines the terminology used for the components. This makes it an ideal place for us to see how FTP works in broad terms.</p><div class="sect2" title="The Server-FTP Process and User-FTP Process"><div class="titlepage"><div><div><h2 class="title"><a id="the_server-ftp_process_and_user-ftp_proc"/>The Server-FTP Process and User-FTP Process</h2></div></div></div><p>FTP is a classic client/server protocol, as mentioned earlier. However, the client is not called by that name, but rather is called the <span class="emphasis"><em>user</em></span>. The name comes from the fact that the human user that issues FTP commands works on the client machine. The full set of FTP software operating on a device is called a <span class="emphasis"><em>process</em></span>. The FTP software on the server is called the <span class="emphasis"><em>server-FTP process</em></span>, while the software on the client is the <span class="emphasis"><em>user-FTP process</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-421"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The FTP client is sometimes called the <span class="emphasis"><em>user device</em></span>, since the human user interacts with the client directly. The FTP client software is called the <span class="emphasis"><em>user-FTP process</em></span>; the FTP server software is the <span class="emphasis"><em>server-FTP process</em></span>.</p></div></div><div class="sect2" title="FTP Control Connection and Data Connection"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_control_connection_and_data_connecti"/>FTP Control Connection and Data Connection</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2527"/>A critical concept in understanding FTP is that, although it uses TCP like many other applications, it does not use just one TCP connection for all communication the way most protocols do. Instead, the FTP model is designed around two logical channels of communication between the server and user FTP processes:</p><p><span class="strong"><strong>Control Connection</strong></span> This is the main logical TCP connection that is created when an FTP session is established. It is maintained throughout the FTP session and is used only for passing control information, such as FTP commands and replies. It is not used to send files.</p><p><span class="strong"><strong>Data Connection</strong></span> Each time data is sent from the server to the client or vice versa, a distinct TCP data connection is established between them. Data is transferred over this connection. When the file transfer is complete, the connection is terminated.</p><p>Using separate channels provides flexibility in how the protocol is used, but it also adds complexity to FTP.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-422"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Unlike most protocols, FTP does not use a single TCP connection. When a session is set up, a permanent <span class="strong"><strong>control connection</strong></span> is established using TCP for passing commands and replies. When files or other data are to be sent, they are passed over separate TCP <span class="emphasis"><em>data connections</em></span> that are created and then dismantled as needed.</p></div></div><div class="sect2" title="FTP Process Components and Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_process_components_and_terminology"/>FTP Process Components and Terminology</h2></div></div></div><p>Since the control and data functions are communicated using distinct channels, the FTP model divides the software on each device into two logical protocol components that are responsible for each channel. The <span class="emphasis"><em>protocol interpreter (PI)</em></span> is a piece of software that is charged with managing the control connection, issuing and receiving commands and replies. The <span class="emphasis"><em>data transfer process (DTP)</em></span> is responsible for actually sending and receiving data between the client and server. In addition to these two elements, the user FTP process includes a third component, a <span class="emphasis"><em>user interface</em></span>, that interacts with the human FTP user; it is not present on the server side.</p><p>Thus, two server <a class="indexterm" id="idx-CHP-72-2528"/>process components and three client (user) process components are included in FTP. These components are referred to in the FTP model by specific names, which are used in the standard to describe the detailed operation of the protocol. I plan to do the same in this chapter, so I will now describe more fully the components in each device of this model, which are illustrated in <a class="xref" href="ch72s02.html#ftp_operational_model_ftp_is_a_clientser" title="Figure 72-1. FTP operational model FTP is a client/server protocol, with communication taking place between the user-FTP process on the client and the server-FTP process on the server. Commands, replies, and status information are passed between the user-PI and server-PI over the control connection, which is established once and maintained for the session. Data is moved between devices over data connections that are set up for each transfer.">Figure 72-1</a>.</p><div class="figure"><a id="ftp_operational_model_ftp_is_a_clientser"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e76525"/><img alt="FTP operational model FTP is a client/server protocol, with communication taking place between the user-FTP process on the client and the server-FTP process on the server. Commands, replies, and status information are passed between the user-PI and server-PI over the control connection, which is established once and maintained for the session. Data is moved between devices over data connections that are set up for each transfer." src="httpatomoreillycomsourcenostarchimages288261.png.jpg"/></div></div><p class="title">Figure 72-1. FTP operational model FTP is a client/server protocol, with communication taking place between the user-FTP process on the client and the server-FTP process on the server. Commands, replies, and status information are passed between the user-PI and server-PI over the control connection, which is established once and maintained for the session. Data is moved between devices over data connections that are set up for each transfer.</p></div></div><div class="sect2" title="Server-FTP Process Components"><div class="titlepage"><div><div><h2 class="title"><a id="server-ftp_process_components"/>Server-FTP Process Components</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2529"/>The server-FTP process contains two protocol elements:</p><p><span class="strong"><strong>Server Protocol Interpreter (Server-PI)</strong></span> The protocol interpreter is responsible for managing the control connection on the server. It listens on the main reserved FTP port for incoming connection requests from users (clients). Once a connection is established, it receives commands from the user-PI, sends back replies, and manages the server data transfer process.</p><p><span class="strong"><strong>Server <a class="indexterm" id="idx-CHP-72-2530"/>Data Transfer Process (Server-DTP)</strong></span> The DTP on the server side is used to send or receive data to or from the user-DTP. The server-DTP may either establish a data connection or listen for a data connection coming from the user. It interacts with the server's local file system to read and write files.</p></div><div class="sect2" title="User-FTP Process Components"><div class="titlepage"><div><div><h2 class="title"><a id="user-ftp_process_components"/>User-FTP Process Components</h2></div></div></div><p>The User-FTP Process contains three protocol elements:</p><p><span class="strong"><strong>User Protocol Interpreter (User-PI)</strong></span> This protocol interpreter is responsible for managing the control connection on the client. It initiates the FTP session by issuing a request to the server-PI. Once a connection is established, it processes commands received from the user interface, sends them to the server-PI, and receives replies. It also manages the user data transfer process.</p><p><span class="strong"><strong>User Data Transfer Process (User-DTP)</strong></span> The DTP on the user side sends or receives data to or from the server-DTP. The user-DTP may either establish a data connection or listen for a data connection coming from the server. It interacts with the client device's local file system.</p><p><span class="strong"><strong>User Interface</strong></span> The user interface provides a more friendly FTP interface to a human user. It allows simpler user-oriented commands to be used for FTP functions rather than the somewhat cryptic internal FTP commands, and it allows results and information to be conveyed back to the person operating the FTP session.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-423"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The server-FTP process and user-FTP process both contain a <span class="emphasis"><em>protocol interpreter (PI)</em></span> element and a <span class="emphasis"><em>data transfer process (DTP)</em></span> element. The <span class="emphasis"><em>server-PI</em></span> and <span class="emphasis"><em>user-PI</em></span> are logically linked by the FTP control connection; the <span class="emphasis"><em>server-DTP</em></span> and <span class="emphasis"><em>user-DTP</em></span> are logically linked by data connections. The user-FTP process includes a third component, the <span class="emphasis"><em>user interface</em></span>, which provides the means for the human user to issue commands and see responses from the FTP software.</p></div></div><div class="sect2" title="Third-Party File Transfer (Proxy FTP)"><div class="titlepage"><div><div><h2 class="title"><a id="third-party_file_transfer_proxy_ftp"/>Third-Party File Transfer (Proxy FTP)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2531"/><a class="indexterm" id="idx-CHP-72-2532"/>The FTP standard actually defines a separate model for an alternative way of using the protocol. In this technique, a user on one host performs a <a class="indexterm" id="idx-CHP-72-2533"/>file transfer from one server to another. This is done by opening two control connections: one each from the user-PI on the user's machine to the two server-PIs on the two servers. Then, a server-DTP is invoked on each server to send data; the user-DTP is not used.</p><p>This method, sometimes called <span class="emphasis"><em>third-party file transfer</em></span> or <a class="indexterm" id="idx-CHP-72-2534"/><span class="emphasis"><em>proxy FTP</em></span>, is not widely used today. A major reason for its lack of use is that it raises security concerns and has been exploited in the past. Thus, while it is worth mentioning, I will not be discussing it further in my coverage of FTP.</p></div></div>
<div class="sect1" title="FTP Control Connection Establishment, User Authentication, and Anonymous FTP Access"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_control_connection_establishment_use"/>FTP Control Connection Establishment, User Authentication, and Anonymous FTP Access</h1></div></div></div><p>You just saw how <a class="indexterm" id="idx-CHP-72-2535"/>FTP uses distinct logical data and <a class="indexterm" id="idx-CHP-72-2536"/>control channels that are established between an FTP client (user) and an FTP server. Before the data connection can be used to send actual files, the <a class="indexterm" id="idx-CHP-72-2537"/>control connection must be established. A specific process is followed to set up this connection and thereby create the permanent FTP session between devices that can be used for transferring files.</p><p>As with other client/server protocols, the FTP server assumes a passive role in the control connection process. The server protocol interpreter (server-PI) listens on the special well-known TCP port reserved for FTP control connections: port 21. The user-PI initiates the connection by opening a TCP connection from the user device to the server on this port. It uses an ephemeral port number as its source port in the TCP connection.</p><p>Once TCP has been set up, the control connection between the devices is established, allowing commands to be sent from the user-PI to the server-PI and reply codes to be sent back in response. The first order of business after the channel is operating is <span class="emphasis"><em>user authentication</em></span><a class="indexterm" id="idx-CHP-72-2538"/>, which the FTP standard calls the <a class="indexterm" id="idx-CHP-72-2539"/><span class="emphasis"><em>login sequence</em></span>. This process has two purposes:</p><p><span class="strong"><strong>Access Control</strong></span> The authentication process allows access to the server to be restricted to only authorized users. It also lets the server control what types of access each user has.</p><p><span class="strong"><strong>Resource Selection</strong></span> By identifying the user making the connection, the FTP server can make decisions about what resources to make available to the user.</p><div class="sect2" title="FTP Login Sequence and Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_login_sequence_and_authentication"/>FTP Login Sequence and Authentication</h2></div></div></div><p>The FTP's regular authentication scheme is quite rudimentary: it is a simple <span class="emphasis"><em>user name/password</em></span> login scheme, shown in <a class="xref" href="ch72s03.html#ftp_connection_establishment_and_user_au" title="Figure 72-2. FTP connection establishment and user authentication An FTP session begins with the establishment of a TCP connection between the client and server. The client then sends the user name and password to authenticate with the server. Assuming that the information is accepted by the server, it sends a greeting reply to the client and the session is open.">Figure 72-2</a>. Most of us are familiar with this type of authentication for various types of access on the Internet and elsewhere. First, the user is identified by sending a user name from the user-PI to the server-PI using the USER command. Then, the user's password is sent using the PASS command.</p><p>The server checks the user name and password against its user database to verify that the connecting user has valid authority to access the server. If the information is valid, the server sends back a greeting to the client to indicate that the session is opened. If the user improperly authenticates (by specifying an incorrect user name or password), the server will request that the user attempt authorization again. After a number of invalid authorization tries, the server may time out and terminate the connection.</p><p>Assuming that the authentication succeeds, the server then sets up the connection to allow the type of access to which the user is authorized. Some users may have access to only certain files or certain types of files. Some servers may allow particular users to read and write files on the server, while other users may only retrieve files. The administrator can thus tailor FTP access as needed.</p><div class="figure"><a id="ftp_connection_establishment_and_user_au"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e76700"/><img alt="FTP connection establishment and user authentication An FTP session begins with the establishment of a TCP connection between the client and server. The client then sends the user name and password to authenticate with the server. Assuming that the information is accepted by the server, it sends a greeting reply to the client and the session is open." src="httpatomoreillycomsourcenostarchimages288263.png.jpg"/></div></div><p class="title">Figure 72-2. FTP connection establishment and user authentication An FTP session begins with the establishment of a TCP connection between the client and server. The client then sends the user name and password to authenticate with the server. Assuming that the information is accepted by the server, it sends a greeting reply to the client and the session is open.</p></div><p>Once the connection is established, the server can also make resource selection decisions based on the user's identity. For example, on a system with multiple users, the administrator can set up FTP so that when any user connects, she automatically is taken to her own home directory. The optional ACCT (account) command also allows a user to select a particular account if she has more than one.</p></div><div class="sect2" title="FTP Security Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_security_extensions"/>FTP Security Extensions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2540"/>Like most older protocols, the simple login scheme used by FTP is a legacy of the relatively closed nature of the early Internet. It is not considered secure by today's global Internet standards, because the user name and password are sent across the control connection in clear text. This makes it relatively easy for login information to be intercepted by intermediate systems and accounts to be compromised. RFC 2228, "<a class="indexterm" id="idx-CHP-72-2541"/>FTP Security Extensions," defines more sophisticated authentication and encryption options for those who need added security in their FTP software.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-424"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> An FTP session begins with the <a class="indexterm" id="idx-CHP-72-2542"/>establishment of a control connection between an FTP client and server. After the TCP connection is made, the user must authenticate with the server using a simple user name/password exchange between client and server. This provides only rudimentary security, so if more security is required, it must be implemented using FTP <a class="indexterm" id="idx-CHP-72-2543"/>security extensions or through other means.</p></div></div><div class="sect2" title="Anonymous FTP"><div class="titlepage"><div><div><h2 class="title"><a id="anonymous_ftp"/>Anonymous FTP</h2></div></div></div><p>Perhaps surprisingly, many organizations did not see the need for an enhanced level of security. These organizations, in fact, went in the opposite direction: They used FTP without any authentication at all. But why would any business want to allow just anybody access to its FTP server? The answer is pretty simple: Anyone who wants to use the server can do so to provide information to the general public.</p><p>Today, most organizations use the World Wide Web to distribute documents, software, and other files to customers and others who want to obtain them. But in the 1980s, before the Web became popular, FTP was often used to distribute such information. For example, today, if you had a 3Com network interface card and wanted to obtain a driver for it, you would go to the web server <span class="emphasis"><em>www.3com.com</em></span>, but several years ago, you might have accessed the 3Com FTP server <span class="emphasis"><em>(ftp.3com.com)</em></span> to download a driver.</p><p>Clearly, requiring every customer to have a user name and password on such a server would be ridiculously difficult. For this reason, RFC 1635, published in 1994, defined a use for the protocol called <a class="indexterm" id="idx-CHP-72-2544"/><span class="emphasis"><em>anonymous FTP</em></span>. In this technique, a client connects to a server and provides a default user name to log in as a guest. Usually the names <a class="indexterm" id="idx-CHP-72-2545"/><span class="emphasis"><em>anonymous</em></span> or <span class="emphasis"><em>ftp</em></span> are supported. Seeing this name, the server responds back with a special message, saying something like "Guest login OK, send your complete email address as password." The password in this case isn't really a password; it is used simply to allow the server to log who is accessing it.</p><p>The guest is then able to access the site, though the server will usually severely restrict the access rights of guests on the system. Many FTP servers support both identified and anonymous access, with authorized users having more permissions (such as being able to traverse the full directory path and having the right to delete or rename files) and anonymous users restricted to only reading files from a particular directory set up for public access.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-425"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Many FTP servers support <span class="emphasis"><em>anonymous FTP</em></span>, which allows a guest who has no account on the server to have limited access to server resources. This is often used by organizations that wish to make files available to the public for purposes such as technical support, customer support, or distribution.</p></div></div></div>
<div class="sect1" title="FTP Data Connection Management"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_data_connection_management"/>FTP Data Connection Management</h1></div></div></div><p><a class="indexterm" id="idx-CHP-72-2546"/><a class="indexterm" id="idx-CHP-72-2547"/>The control channel created between the server-PI and the user-PI using the FTP connection establishment and authentication process is maintained throughout the FTP session. Over the control channel, the protocol interpreters exchange commands and replies, but not data.</p><p>Each time files or other data need to be sent between the server and user FTP processes, a data connection must be created. The data connection links the user-DTP with the server-DTP. This connection is required both for explicit file transfer actions (getting or receiving a file) and for implicit data transfers, such as requesting a list of files from a directory on the server.</p><p>The FTP standard specifies two different ways of creating a data connection, though it doesn't really explain them in a way that is very easy to understand. The two methods differ primarily in which device—the client or the server—initiates the connection. This may at first seem like a trivial matter, but as you'll see shortly, it is actually quite important.</p><div class="sect2" title="Normal (Active) Data Connections"><div class="titlepage"><div><div><h2 class="title"><a id="normal_active_data_connections"/>Normal (Active) Data Connections</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2548"/>The first method is sometimes called creating a <a class="indexterm" id="idx-CHP-72-2549"/><span class="emphasis"><em>normal</em></span> data connection (because it is the default method) and sometimes an <span class="emphasis"><em>active</em></span> data connection (in contrast with the passive method we will discuss in a moment). In this type of connection, the server-DTP initiates the data channel by opening a TCP connection to the user-DTP. The server uses the special reserved port number 20 (one less than the well-known control FTP port number 21) for the data connection. On the client machine, the default port number used is the same as the ephemeral port number used for the control connection, but as you'll see shortly, the client will often choose a different port for each transfer.</p><p>Let's use an example to see how this works. Suppose the user-PI established a control connection from its ephemeral port number 1678 to the server's FTP control port of 21. Then, to create a data connection for data transfer, the server-PI would instruct the server-DTP to initiate a TCP connection from the server's port 20 to the client's port 1678. The client would acknowledge this, and then data could be transferred (in either direction—remember that TCP is bidirectional).</p><p>In practice, having the client's control and data connection on the same port is not a good idea; it complicates the operation of FTP and can lead to some tricky problems. For this reason, it is strongly recommended that the client specify a different port number using the <a class="indexterm" id="idx-CHP-72-2550"/>PORT command prior to the data transfer. For example, suppose the client specifies port 1742 using PORT. The server-DTP would then create a connection from its port 20 to the client's port 1742 instead of 1678. This process is shown in <a class="xref" href="ch72s04.html#ftp_active_data_connection_in_a_conventi" title="Figure 72-3. FTP active data connection In a conventional, or active, FTP data connection, the server initiates the transfer of data by opening the data connection to the client. In this case, the client first sends a PORT command to tell the server to use port 1742. The server then opens the data connection from its default port number of 20 to client port 1742. Data is then exchanged between the devices using these ports.">Figure 72-3</a>.</p></div><div class="sect2" title="Passive Data Connections"><div class="titlepage"><div><div><h2 class="title"><a id="passive_data_connections"/>Passive Data Connections</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2551"/>The second method is called a <span class="emphasis"><em>passive</em></span> data connection. The client tells the server to be passive—that is, to accept an incoming data connection initiated by the client. The server replies, giving the client the server IP address and port number that it should use. The server-DTP then listens on this port for an incoming TCP connection from the user-DTP. By default, the user machine uses the same port number it used for the control connection, as in the active case. However, here again, the client can choose to use a different port number for the data connection if necessary (typically an ephemeral port number).</p><p>Let's consider our example again, with the control connection from port 1678 on the client to port 21 on the server, but this time consider data transfer using a passive connection, as illustrated in <a class="xref" href="ch72s04.html#ftp_passive_data_connection_in_a_passive" title="Figure 72-4. FTP passive data connection In a passive FTP data connection, the client uses the PASV command to tell the server to wait for the client to establish the data connection. The server responds, telling the client what port it should use on the server for the data transmission—in this case, port 2223. The client then opens the data connection using that port number on the server and a client port number of its own choosing—in this case, 1742.">Figure 72-4</a>. The client would issue the <a class="indexterm" id="idx-CHP-72-2552"/>PASV command to tell the server it wanted to use <a class="indexterm" id="idx-CHP-72-2553"/>passive data control. The server-PI would reply with a port number for the client to use—say port 2223. The server-PI would then instruct the server-DTP to listen on this port 2223. The user-PI would instruct the user-DTP to create a connection from client port 1742 to server port 2223. The server would acknowledge this, and then data could be sent and received, again in either direction.</p><div class="figure"><a id="ftp_active_data_connection_in_a_conventi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e76864"/><img alt="FTP active data connection In a conventional, or active, FTP data connection, the server initiates the transfer of data by opening the data connection to the client. In this case, the client first sends a PORT command to tell the server to use port 1742. The server then opens the data connection from its default port number of 20 to client port 1742. Data is then exchanged between the devices using these ports." src="httpatomoreillycomsourcenostarchimages288265.png.jpg"/></div></div><p class="title">Figure 72-3. FTP active data connection In a conventional, or active, FTP data connection, the server initiates the transfer of data by opening the data connection to the client. In this case, the client first sends a PORT command to tell the server to use port 1742. The server then opens the data connection from its default port number of 20 to client port 1742. Data is then exchanged between the devices using these ports.</p></div></div><div class="sect2" title="Efficiency and Security Issues Related to the Connection Methods"><div class="titlepage"><div><div><h2 class="title"><a id="efficiency_and_security_issues_related_t"/>Efficiency and Security Issues Related to the Connection Methods</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2554"/><a class="indexterm" id="idx-CHP-72-2555"/>At this point, you may be wondering what the practical difference is between the active and passive connection types. I already said that in either case, the data transfer can go in both directions. So what does it matter who initiates the data connection? Isn't this like arguing over who makes a local telephone call?</p><p>The answer is related to the dreaded "S word:" <span class="emphasis"><em>security</em></span>. The fact that FTP uses more than one TCP connection can cause problems for the hardware and software that people use to ensure the security of their systems.</p><p>Consider what is happening in the case of an <a class="indexterm" id="idx-CHP-72-2556"/>active data connection, as described in <a class="xref" href="ch72s04.html#ftp_active_data_connection_in_a_conventi" title="Figure 72-3. FTP active data connection In a conventional, or active, FTP data connection, the server initiates the transfer of data by opening the data connection to the client. In this case, the client first sends a PORT command to tell the server to use port 1742. The server then opens the data connection from its default port number of 20 to client port 1742. Data is then exchanged between the devices using these ports.">Figure 72-3</a>. From the perspective of the client, an established control connection exists from the client's port 1678 to the server's port 21. But the data connection is initiated by the server. So the client sees an incoming connection request to port 1678 (or some other port). Many clients are suspicious about receiving such incoming connections, since under normal circumstances, clients <span class="emphasis"><em>establish</em></span> connections—they don't respond to them. Since incoming TCP connections can potentially be a security risk, many clients are configured to block them using firewall hardware or software.</p><div class="figure"><a id="ftp_passive_data_connection_in_a_passive"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e76903"/><img alt="FTP passive data connection In a passive FTP data connection, the client uses the PASV command to tell the server to wait for the client to establish the data connection. The server responds, telling the client what port it should use on the server for the data transmission—in this case, port 2223. The client then opens the data connection using that port number on the server and a client port number of its own choosing—in this case, 1742." src="httpatomoreillycomsourcenostarchimages288267.png.jpg"/></div></div><p class="title">Figure 72-4. FTP passive data connection In a passive FTP data connection, the client uses the PASV command to tell the server to wait for the client to establish the data connection. The server responds, telling the client what port it should use on the server for the data transmission—in this case, port 2223. The client then opens the data connection using that port number on the server and a client port number of its own choosing—in this case, 1742.</p></div><p>Why not just make it so that the client always accepts connections to the port number one above the ephemeral number used for the control connection? The problem here is that clients often use different port numbers for each transfer by using the PORT command. This is done because of the rules of TCP. As I describe in <a class="xref" href="ch47.html" title="Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION">Chapter 47</a>, after a connection is closed, a period of time must elapse before the port can be used again to prevent mixing up consecutive sessions. This would cause delays when sending multiple files one after the other, so to avoid this, clients usually use different port numbers for each transfer. This is more efficient, but it means a firewall protecting the client would be asked to accept incoming connections that appear to be going to many unpredictable port numbers.</p><p>The use of passive connections largely eliminates this problem. Most firewalls have a lot more difficulty dealing with incoming connections to odd ports than outgoing connections. RFC 1579, "Firewall-Friendly FTP," discusses this issue in detail. It recommends that clients use <a class="indexterm" id="idx-CHP-72-2557"/>passive data connections by default instead of using normal connections with the PORT command to avoid the port-blocking problem.</p><p>Of course, <a class="indexterm" id="idx-CHP-72-2558"/>passive data connections don't really eliminate the problem; they just push it off onto servers. These servers now must face the issue of incoming connections to various ports. Still, it is, generally speaking, easier to deal with security issues on a relatively smaller number of servers than on a large number of clients. FTP servers must be able to accept passive mode transfers from clients anyway, so the usual approach is to set aside a block of ports for this purpose, which the server's security provisions allow to accept incoming connections, while blocking incoming connection requests on other ports.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-426"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> FTP supports two different models for establishing data connections between the client and server. In normal, or <span class="emphasis"><em>active</em></span>, data connections, the server initiates the connection when the client requests a transfer, and the client responds; in a <span class="emphasis"><em>passive</em></span> data connection, the client tells the server it will initiate the connection, and the server responds. Since TCP is bidirectional, data can flow either way in both cases; the chief difference between the two modes has to do with security. In particular, passive mode is often used because many modern client devices are not able to accept incoming connections from servers.</p></div><p>Another point worth mentioning is that it is a significant violation of the layering principle of networks to pass IP addresses and port numbers in FTP commands such as PORT and PASV and the replies to them. This isn't just a philosophical issue. Applications aren't supposed to deal with port numbers, and this creates issues when certain lower-layer technologies are used. For example, consider the use of Network Address Translation (NAT; see <a class="xref" href="ch28.html" title="Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL">Chapter 28</a>), which modifies IP addresses and possibly port numbers. To prevent NAT from "breaking" when FTP is used, special provisions must be made to handle the protocol.</p></div></div>
<div class="sect1" title="FTP General Data Communication and Transmission Modes"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_general_data_communication_and_trans"/>FTP General Data Communication and Transmission Modes</h1></div></div></div><p><a class="indexterm" id="idx-CHP-72-2559"/><a class="indexterm" id="idx-CHP-72-2560"/>Once a data connection has been established between the server-DTP and the user-DTP, data is sent directly from the client to the server, or the server to the client, depending on the specific command issued. Since control information is sent using the distinct control channel, the entire data channel can be used for data communication. (These two logical channels are multiplexed at lower layers along with all other TCP and User Datagram Protocol (UDP) connections on both devices, so this doesn't actually represent a performance improvement over a single channel.)</p><p>FTP defines three different <span class="emphasis"><em>transmission modes</em></span> (also called <span class="emphasis"><em>transfer modes</em></span>) that specify exactly how data is sent from one device to another over an open data channel: <a class="indexterm" id="idx-CHP-72-2561"/><span class="emphasis"><em>stream mode, block mode</em></span>, and <span class="emphasis"><em>compressed mode</em></span>.</p><div class="sect2" title="Stream Mode"><div class="titlepage"><div><div><h2 class="title"><a id="stream_mode"/>Stream Mode</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2562"/>In stream mode, data is sent simply as a continuous stream of unstructured bytes. The sending device simply starts pushing data across the TCP data connection to the recipient. No message format with distinct header fields is used, making this method quite different from the way many other protocols send information in discrete chunks. It relies strongly on the data streaming and reliable transport services of TCP. Since there is no header structure, the end of the file is indicated simply by the sending device closing the data connection when it is done.</p><p>Of the three modes, stream is by far the most widely used in real FTP implementations, for three main reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It is the default and also the simplest method, so it is the easiest to implement and is required for compatibility.</p></li><li class="listitem"><p>It is the most general, because it treats all files as simple streams of bytes without paying attention to their content.</p></li><li class="listitem"><p>It is the most efficient method because no bytes are wasted on overhead such as headers.</p></li></ul></div></div><div class="sect2" title="Block Mode"><div class="titlepage"><div><div><h2 class="title"><a id="block_mode"/>Block Mode</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2563"/>Block mode is a more conventional data transmission mode, in which data is broken into data blocks and encapsulated into individual FTP blocks, or records. Each record has a three-byte header that indicates its length and contains information about the data blocks being sent. A special algorithm is used to keep track of the transmitted data and to detect and restart an interrupted transfer.</p></div><div class="sect2" title="Compressed Mode"><div class="titlepage"><div><div><h2 class="title"><a id="compressed_mode"/>Compressed Mode</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2564"/>Compressed mode is a transmission mode in which a relatively simple compression technique called <span class="emphasis"><em>run-length encoding</em></span> is used to detect repeated patterns in the data being sent, which then represents data in such a way that the overall message takes fewer bytes. The compressed information is sent in a way similar to block mode, using a header-plus-payload record format.</p><p>Compressed mode seems on the surface to be useful. In practice, however, compression is often implemented in other places in a typical networking software stack, making it unnecessary in FTP. For example, if you are transferring a file over the Internet using an analog modem, your modem normally performs compression down at layer 1. Large files on FTP servers are also often already compressed using something like the ZIP format, meaning further compression would serve no purpose.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-427"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> FTP includes three different <span class="emphasis"><em>transmission modes: stream, block</em></span>, and <span class="emphasis"><em>compressed</em></span>. In stream mode, the most commonly used mode, data is sent as a continuous sequence of bytes. In block mode, data is formatted into blocks with headers. In compressed mode, bytes are compacted using run-length encoding.</p></div></div></div>
<div class="sect1" title="FTP Data Representation: Data Types, Format Control, and Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_data_representation_data_types_forma"/>FTP Data Representation: Data Types, Format Control, and Data Structures</h1></div></div></div><p><a class="indexterm" id="idx-CHP-72-2565"/>The most general way of designing FTP would have been to make it treat all files as "black boxes." A file would be represented as just as a set of bytes. FTP would pay no attention to what the file contained and would simply move the file, one byte at a time, from one place to another. In this scenario, FTP would seem to be very similar to the Copy command that is implemented on most file systems, which likewise creates a copy without looking into the file to see what it contains.</p><p>So what would be the problem with that, you may wonder? Well, for some types of files, this is exactly what we want, but for others, it introduces a problem. Certain types of files use different representations on different systems. If you copy a file from one place to another on the same computer using a Copy command, there is no problem, because the same representation for files is used everywhere within that computer. But when you copy it to a computer that uses a different representation, you may encounter difficulties.</p><p>The most common example of this is a type of file that may surprise you: simple text files. All ASCII text files use the ASCII character set, but they differ in the control characters used to mark the end of a line of text. On UNIX, a line feed (LF) character is used; on Apple computers, a carriage return (CR) is used; and Windows machines use both (CR+LF).</p><p>If you move a text file from one type of system to another using regular <a class="indexterm" id="idx-CHP-72-2566"/>FTP, the data will all get moved exactly as it is. Moving a text file from a UNIX system to a PC as just a set of bytes would mean programs would not properly recognize end-of-line markers. To avoid this predicament, FTP moves past the idea that all files are just bytes and incorporates some intelligence to handle different types of files. The FTP standard recognizes this by allowing the specification of certain details about a file's internal representation prior to transfer.</p><div class="sect2" title="FTP Data Types"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_data_types"/>FTP Data Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2567"/>The first piece of information that can be provided about a file is its <span class="emphasis"><em>data type</em></span>, which dictates the overall representation of the file. Four different data types are specified in the FTP standard:</p><p><span class="strong"><strong>ASCII</strong></span> This data type defines an ASCII text file, with lines marked by some sort of end-of-line marker.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-72-2568"/>EBCDIC</strong></span> Conceptually, EBCDIC is the same as the ASCII type, but it is used for files using IBM's EBCDIC character set.</p><p><span class="strong"><strong>Image</strong></span> With the image data type, the file has no formal internal structure and is sent one byte at a time without any processing; this is the black box mode mentioned earlier.</p><p><span class="strong"><strong>Local</strong></span> This data type is used to handle files that may store data in logical bytes containing a number of bits other than eight. Specifying this type along with the way the data is structured allows the data to be stored on the destination system in a manner consistent with its local representation.</p><div class="note" title="Note"><h3 class="title"><a id="note-155"/>Note</h3><p><span class="emphasis"><em>The term byte conventionally refers to eight bits, but strictly speaking, the term used to describe eight bits is octet. A byte may in fact contain a number of bits other than eight on certain systems. For details, see "Binary Information and Representation: Bits, Bytes, Nibbles, Octets, and Characters" in <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a></em></span>.</p></div><p>In practice, the two data types most often used are ASCII and image. The ASCII type is used for text files, and allows them to be moved between systems with line-end codes converted automatically. The Image type is used for generic binary files, such as graphical images, ZIP files, and other data that is represented in a universal manner. It is also often called the <span class="emphasis"><em>binary</em></span> type for that reason.</p></div><div class="sect2" title="ASCII Data Type Line-Delimiting Issues"><div class="titlepage"><div><div><h2 class="title"><a id="ascii_data_type_line-delimiting_issues"/>ASCII Data Type Line-Delimiting Issues</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2569"/>When the ASCII data type is used, differences in internal representations between systems are handled by using a universal external representation that acts as a common language. Lines of the file being transmitted are converted by the sending FTP process from the sender's internal representation to the neutral ASCII representation used by the Telnet Protocol (NETASCII), with each line ending in CR+LF. The receiving device then converts from this neutral representation to the internal format used by the recipient file system.</p><p>For example, when using FTP to move a text file from a Macintosh to a UNIX system, each line would have the CR changed to a CR+LF for transmission over the FTP data channel. The receiving UNIX system would change each CR+LF to just LF so UNIX programs could read it properly.</p><p>Note that because of these changes, the resulting file can be bigger or smaller than the original if it is transferred between systems using ASCII mode. Also, since FTP works by converting to a neutral representation for universality, sending an ASCII file from a UNIX system to a UNIX system means each LF is changed to CR+LF for transmission, and then it's changed back to LF by the recipient. It's slightly inefficient, but not that big a deal.</p><p>It's very important that the correct data type be specified with the appropriate user command. Sending a text file between dissimilar systems without setting the ASCII mode will result in either a file that cannot be properly read on the destination or one that contains stray characters. Conversely, binary files must be sent in binary mode. If you send something like a ZIP file or a JPG graphic in ASCII mode, the FTP software will think it is a text file. It will treat the file as if it were text, and each time it encounters bytes in the file that look like CR, LF, or CR+LF, it will convert them, which you do not want. (Having the wrong data type set is a leading cause of corrupted files when using FTP to move files between PCs and UNIX systems. I know from experience!)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-428"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> FTP defines four data types: <span class="emphasis"><em>ASCII, EBCDIC, image</em></span>, and <span class="emphasis"><em>local. ASCII</em></span> and <span class="emphasis"><em>EBCDIC</em></span> are used for text files in the ASCII and EBCDIC character sets, respectively. The <span class="emphasis"><em>image</em></span> type is used for files with no specific structure. The local type is used for local representation. The ASCII type is important because it allows text files to be transferred successfully between file systems that may use different methods of indicating the end of a line of text. The image type, also called binary, is used for files that must be sent and received byte-for-byte with no transformation, such as executable files, graphics, and files with arbitrary formats.</p></div></div><div class="sect2" title="FTP Format Control"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_format_control"/>FTP Format Control</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2570"/>For the ASCII and EBCDIC types, FTP defines an optional parameter called <a class="indexterm" id="idx-CHP-72-2571"/><span class="emphasis"><em>format control</em></span>, which allows a user to specify a particular representation for how vertical formatting is used to describe a file. The format control option was created to handle files transferred from host devices to printers. It is not used today, to my knowledge (or if it is used, it is used only in special applications).</p><p>Three options can be used in this control:</p><p><span class="strong"><strong>Non Print</strong></span> This is the default, indicating no vertical formatting.</p><p><span class="strong"><strong>Telnet Format</strong></span> The file uses vertical format control characters, as specified in the Telnet Protocol.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-72-2572"/>Carriage Control/FORTRAN</strong></span> The file uses format control characters given as the first character of each line, as specified for the FORTRAN programming language.</p></div><div class="sect2" title="FTP Data Structures"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_data_structures"/>FTP Data Structures</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2573"/>In addition to specifying a file's data type, it is also possible to specify the file's <span class="emphasis"><em>data structure</em></span> in three ways:</p><p><span class="strong"><strong>File Structure</strong></span> The file is a contiguous stream of bytes with no internal structure. This is the default and is used for most types of files.</p><p><span class="strong"><strong>Record Structure</strong></span> The file consists of a set of sequential records, each of which is delimited by an end-of-record marker. The record structure can be used for ASCII text files, but these are more commonly sent with the regular file structure using the ASCII data type.</p><p><span class="strong"><strong>Page Structure</strong></span> The file contains a set of special indexed data pages. This structure is not commonly used; it was initially created for a now archaic type of computer used in the early ARPAnet.</p></div></div>
<div class="sect1" title="FTP Internal Command Groups and Protocol Commands"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_internal_command_groups_and_protocol"/>FTP Internal Command Groups and Protocol Commands</h1></div></div></div><p>Once a connection is established between an FTP server and user, all communication to manage the operation of the protocol takes place over the control channel. The user-PI sends <span class="emphasis"><em>protocol commands</em></span> to the server-PI, which processes them and takes appropriate action. The server-PI responds with <span class="emphasis"><em>reply codes</em></span> to tell the user-PI the result of the commands it issued and convey other important information.</p><p>Interestingly, the actual transmission of FTP commands over the control channel is done using specifications based on the Telnet Protocol. You may recall from the "FTP Overview, History, and Standards" section earlier in this chapter that Telnet and FTP are two of the very oldest TCP/IP applications, the former being for direct network use and the latter for indirect resource access. They were developed at around the same time, and setting up the FTP control channel to act as a type of Telnet connection is a good example of how Internet standards try not to reinvent the wheel.</p><div class="sect2" title="FTP Command Groups and Commands"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_command_groups_and_commands"/>FTP Command Groups and Commands</h2></div></div></div><p>Each command is identified by a short, three- or four-letter <span class="emphasis"><em>command code</em></span> for convenience, and the command performs a specific task in the overall functionality of FTP. Several dozen of these protocol commands are available, and to help organize them, the FTP standard categorizes them into three groups, based on overall function type:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-72-2574"/>Access Control Commands</strong></span> Commands that are part of the user login and authentication process, are used for resource access, or are part of general session control. See <a class="xref" href="ch72s07.html#ftp_access_control_commands" title="Table 72-1. FTP Access Control Commands">Table 72-1</a>.</p><p><span class="strong"><strong>Transfer Parameter Commands</strong></span> Commands that specify parameters for how data transfers should occur. For example, commands in this group specify the data type of a file to be sent, indicate whether passive or active data connections will be used, and so forth. See <a class="xref" href="ch72s07.html#ftp_transfer_parameter_commands" title="Table 72-2. FTP Transfer Parameter Commands">Table 72-2</a>.</p><p><span class="strong"><strong>FTP <a class="indexterm" id="idx-CHP-72-2575"/>Service Commands</strong></span> Commands that actually perform file operations, such as sending and receiving files, and to implement support functions, such as deleting or renaming files. This is the largest group. See <a class="xref" href="ch72s07.html#ftp_protocol_service_commands" title="Table 72-3. FTP Protocol Service Commands">Table 72-3</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-429"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> FTP operation is controlled through the issuing of <span class="emphasis"><em>protocol commands</em></span> from the FTP client to the FTP server. Each command has a three- or four-letter command code that indicates its function. The commands are organized into three groups: <a class="indexterm" id="idx-CHP-72-2576"/><span class="emphasis"><em>access control commands</em></span> used for login and general session control, <span class="emphasis"><em>transfer parameter commands</em></span> that control how transfers are performed, and <span class="emphasis"><em>FTP service commands</em></span><a class="indexterm" id="idx-CHP-72-2577"/> that are used to perform actual file operations.</p></div><p>Since the commands are based on the <a class="indexterm" id="idx-CHP-72-2578"/>Telnet specifications, they are sent as plain text, as specified by Telnet's Network Virtual Terminal (NVT) conventions. Tables <a class="xref" href="ch72s07.html#ftp_access_control_commands" title="Table 72-1. FTP Access Control Commands">Table 72-1</a>, <a class="xref" href="ch72s07.html#ftp_transfer_parameter_commands" title="Table 72-2. FTP Transfer Parameter Commands">Table 72-2</a>, and <a class="xref" href="ch72s07.html#ftp_protocol_service_commands" title="Table 72-3. FTP Protocol Service Commands">Table 72-3</a> list and describe the FTP internal protocol commands in the access control, transfer parameters, and service command groups. They are shown in the order that they appear in the FTP standard (RFC 959).</p><div class="table"><a id="ftp_access_control_commands"/><p class="title">Table 72-1. FTP Access Control Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Access Control Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>USER</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the user attempting to establish an FTP session.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PASS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Password</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the password for the user given previously by the USER command during login authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ACCT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Account</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies an account for an authenticated user during the FTP session. Used only on systems that require this to be separately identified; most select an account automatically based on the name entered in the USER command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CWD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Change working directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows the user to specify a different directory for file transfer during an FTP session.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CDUP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Change to parent directory ("change directory up")</p></td><td style="border-bottom: 0.5pt solid ; "><p>A special case of the CWD command that goes to the directory one level up in the server's directory structure. It is implemented separately to abstract out differences in directory structures between file systems; the user can use CDUP instead of knowing the specific syntax for navigating up the directory tree on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SMNT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Structure mount</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows the user to mount a particular file system for access to different resources.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>REIN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reinitialize</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reinitializes the FTP session, flushing all set parameters and user information. This returns the session to the state when the control connection is just established. It is, in essence, the opposite of the USER command. The next command issued is often USER, to log in a different user.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>QUIT</p></td><td style="border-right: 0.5pt solid ; "><p>Logout</p></td><td style=""><p>Terminates the FTP session and closes the control connection. Note that the naming of this command was unfortunate. The REIN command is really most similar to a conventional logout command, as it terminates a logged-in user and allows another user to log in. In contrast, the QUIT command shuts down the entire session.</p></td></tr></tbody></table></div></div><div class="table"><a id="ftp_transfer_parameter_commands"/><p class="title">Table 72-2. FTP Transfer Parameter Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Transfer Parameter Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PORT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data port</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to tell the FTP server that the client wants to accept an active data connection on a specific port number.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PASV</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Passive</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests that the FTP server allow the user-DTP to initiate passive data connections.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TYPE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Representation type</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies for the file to be <a class="indexterm" id="idx-CHP-72-2579"/>transferred the data type (ASCII, EBCDIC, image, or local), and optionally the format control (Non Print, Telnet, or Carriage Control).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STRU</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>File structure</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the data structure for the file (file, record, or page).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>MODE</p></td><td style="border-right: 0.5pt solid ; "><p>Transfer mode</p></td><td style=""><p>Specifies the transmission mode to be used (stream, block, or compressed).</p></td></tr></tbody></table></div></div><div class="table"><a id="ftp_protocol_service_commands"/><p class="title">Table 72-3. FTP Protocol Service Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Protocol Service Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-72-2580"/>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RETR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retrieve</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the server to send the user a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STOR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Store</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a file to the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STOU</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Store unique</p></td><td style="border-bottom: 0.5pt solid ; "><p>Like STOR, but instructs the server to make sure the file has a unique name in the current directory. This is used to prevent overwriting a file that may already exist with the same name. The server replies back with the name used for the file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>APPE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Append (with create)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Like STOR, but if a file with the name specified already exists, the data being sent is appended to it instead of replacing it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ALLO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allocate</p></td><td style="border-bottom: 0.5pt solid ; "><p>An optional command used to reserve storage on the server before a file is sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>REST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Restart</p></td><td style="border-bottom: 0.5pt solid ; "><p>Restarts a file transfer at a particular server marker. Used only for block or compressed transfer modes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RNFR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rename from</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the old name of a file to be renamed. See the RNTO command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RNTO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rename to</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the new name of a file to be renamed. Used with the RNFR command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ABOR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Abort</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the server to abort the last FTP command and/or the current data transfer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DELE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Delete</p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes a specified file on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RMD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes a directory on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MKD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Make directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PWD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Print working directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the current server working directory for the FTP session; shows the users where they are in the server's file system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LIST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>List</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests a list of the contents of the current directory from the server, including both names and other information. Similar in concept to the <code class="literal">DIR</code> command in DOS/Windows or the <code class="literal">ls</code> command in UNIX.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NLST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name list</p></td><td style="border-bottom: 0.5pt solid ; "><p>Like LIST, but returns only the names in a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SITE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Site parameters</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to implement site-specific functions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SYST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>System</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests that the server send to the client information about the server's operating system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STAT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Status</p></td><td style="border-bottom: 0.5pt solid ; "><p>Prompts the server to send an indication of the status of a file or the transfer currently in progress.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>HELP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Help</p></td><td style="border-bottom: 0.5pt solid ; "><p>Asks the server for any help information that might be useful in allowing the user to determine how the server should be used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>NOOP</p></td><td style="border-right: 0.5pt solid ; "><p>No operation</p></td><td style=""><p>Does nothing, other than prompting the server to send an "OK" response to verify that the control channel is alive.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-156"/>Note</h3><p><span class="emphasis"><em>FTP commands are not case-sensitive, but they have been shown in uppercase for clarity in Tables <a class="xref" href="ch72s07.html#ftp_access_control_commands" title="Table 72-1. FTP Access Control Commands">Table 72-1</a>, <a class="xref" href="ch72s07.html#ftp_transfer_parameter_commands" title="Table 72-2. FTP Transfer Parameter Commands">Table 72-2</a>, and <a class="xref" href="ch72s07.html#ftp_protocol_service_commands" title="Table 72-3. FTP Protocol Service Commands">Table 72-3</a></em></span>.</p></div><p>FTP commands are all sent between FTP elements; they are not usually issued directly by users. Instead, a special set of user commands is employed for this purpose. The FTP user interface implements the link between the user and the user-FTP process, including the translation of user commands into FTP commands. We'll explore these commands later in this chapter.</p></div></div>
<div class="sect1" title="FTP Replies"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_replies"/>FTP Replies</h1></div></div></div><p><a class="indexterm" id="idx-CHP-72-2581"/>Each time the user-PI sends a command to the server-PI over the control connection, the server sends back a reply. FTP replies serve three main purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They serve as confirmation that the server received a command.</p></li><li class="listitem"><p>They tell the user device whether or not the command was accepted, and if an error occurred, what it was.</p></li><li class="listitem"><p>They communicate various types of information to the user of the session, such as the status of a transfer.</p></li></ul></div><div class="sect2" title="Advantages of Using Both Text and Numeric Replies"><div class="titlepage"><div><div><h2 class="title"><a id="advantages_of_using_both_text_and_numeri"/>Advantages of Using Both Text and Numeric Replies</h2></div></div></div><p>For a human user, a string of reply text would be sufficient to satisfy the requirements just mentioned, and FTP replies do include descriptive text. But having only a text string would make it difficult or impossible for FTP software on the client side to interpret results coming from the server. FTP was designed to allow software applications to interact with each other over the FTP command link. For this reason, the protocol's reply system uses <a class="indexterm" id="idx-CHP-72-2582"/><span class="emphasis"><em>reply codes</em></span>.</p><p>FTP reply codes are three-digit numeric responses that can be easily interpreted by a computer program. They are also useful for human users who are familiar with FTP, because they communicate at a glance the results of various operations. While each FTP server implementation may differ in the text sent for each type of reply, the reply codes are used in a consistent manner based on the specifications of the FTP standard. It is, therefore, the codes that are examined to determine the results of a command; the text is just descriptive.</p></div><div class="sect2" title="Reply Code Structure and Digit Interpretation"><div class="titlepage"><div><div><h2 class="title"><a id="reply_code_structure_and_digit_interpret"/>Reply Code Structure and Digit Interpretation</h2></div></div></div><p>To make reply codes even more useful, they are not just assigned in a linear or random order. Rather, a special encoding scheme is used, in which each code has three digits that each communicate a particular type of information and categorize replies. A code can be considered to be of the form <span class="emphasis"><em>xyz</em></span>, where <span class="emphasis"><em>x</em></span> is the first digit, <span class="emphasis"><em>y</em></span> is the second, and <span class="emphasis"><em>z</em></span> is the third.</p><p>The first digit indicates the success or failure of the command in general terms, whether a successful command is complete or incomplete, and whether or not an unsuccessful command should be retried. <a class="xref" href="ch72s08.html#ftp_reply_code_format_first_digit_interp" title="Table 72-4. FTP Reply Code Format: First Digit Interpretation">Table 72-4</a> shows the possible values.</p><div class="table"><a id="ftp_reply_code_format_first_digit_interp"/><p class="title">Table 72-4. FTP Reply Code Format: First Digit Interpretation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Reply Code Format: First Digit Interpretation"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Code Format</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meaning</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive preliminary reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>An initial response indicating that the command has been accepted and processing is still in progress. The user should expect another reply before a new command may be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive completion reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command has been successfully processed and completed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive intermediate reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command was accepted, but processing has been delayed, pending receipt of additional information. This type of reply is used in the middle of command sequences. For example, it is used as part of the authentication sequence after receiving a USER command but before the matching PASS command is sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transient negative completion reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command was not accepted and no action was taken, but the error is temporary and the command may be tried again. This is used for errors that may be a result of temporary glitches or conditions that may change—for example, a file being busy due to another resource accessing it at the time a request was made for it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5yz</p></td><td style="border-right: 0.5pt solid ; "><p>Permanent negative completion reply</p></td><td style=""><p>The command was not accepted and no action was taken. Trying the same command again is likely to result in another error. For example, a request for a file that is not found on the server, or sending an invalid command like BUGU, would fall into this category.</p></td></tr></tbody></table></div></div><p>The second digit of the reply code is used to categorize messages into functional groups. These groups are shown in <a class="xref" href="ch72s08.html#ftp_reply_code_format_second_digit_inter" title="Table 72-5. FTP Reply Code Format: Second Digit Interpretation">Table 72-5</a>.</p><div class="table"><a id="ftp_reply_code_format_second_digit_inter"/><p class="title">Table 72-5. FTP Reply Code Format: Second Digit Interpretation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Reply Code Format: Second Digit Interpretation"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Code Format</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meaning</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x0z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></td><td style="border-bottom: 0.5pt solid ; "><p>Syntax errors or miscellaneous messages</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x1z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Information</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replies to requests for information, such as status requests</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x2z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Connections</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replies related to the control connection or data connection</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x3z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authentication and accounting</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replies related to login procedures and accounting</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x4z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unspecified</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not defined</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>x5z</p></td><td style="border-right: 0.5pt solid ; "><p>File system</p></td><td style=""><p>Replies related to the server's file system</p></td></tr></tbody></table></div></div><p>The third digit indicates a specific type of message within each of the functional groups described by the second digit. The third digit allows each functional group to have ten different reply codes for each reply type given by the first code digit (preliminary success, transient failure, and so on).</p><p>These <span class="emphasis"><em>x, y</em></span>, and <span class="emphasis"><em>z</em></span> digit meanings are combined to make specific <a class="indexterm" id="idx-CHP-72-2583"/>reply codes. For example, consider reply code 530, diagrammed in <a class="xref" href="ch72s08.html#ftp_reply_code_format_this_diagram_shows" title="Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP reply code format is interpreted. In reply code 530, the 5 indicates a permanent error, the 3 specifies that the error is related to authentication or accounting, and the 0 is the specific error type. A similar method is used for reply codes in many other TCP/IP application protocols, including the Simple Mail Transfer Protocol (SMTP) and Hypertext Transfer Protocol (HTTP).">Figure 72-5</a>. The first digit tells you that this is a permanent negative reply, and the second indicates that it is related to login or accounting. (It is, in fact, an error message received when a login fails.) The third digit tells you the specific type of error that has occurred.</p><div class="figure"><a id="ftp_reply_code_format_this_diagram_shows"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e77927"/><img alt="FTP reply code format This diagram shows how the three-digit FTP reply code format is interpreted. In reply code 530, the 5 indicates a permanent error, the 3 specifies that the error is related to authentication or accounting, and the 0 is the specific error type. A similar method is used for reply codes in many other TCP/IP application protocols, including the Simple Mail Transfer Protocol (SMTP) and Hypertext Transfer Protocol (HTTP)." src="httpatomoreillycomsourcenostarchimages288269.png.jpg"/></div></div><p class="title">Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP reply code format is interpreted. In reply code 530, the 5 indicates a permanent error, the 3 specifies that the error is related to authentication or accounting, and the 0 is the specific error type. A similar method is used for reply codes in many other TCP/IP application protocols, including the Simple Mail Transfer Protocol (SMTP) and Hypertext Transfer Protocol (HTTP).</p></div><p><a class="indexterm" id="idx-CHP-72-2584"/>Using encoded reply codes allows the code itself to communicate information immediately and provides a way of keeping different types of responses organized. This idea was adapted for use by several other application protocols, including the Simple Mail Transfer Protocol (SMTP) for email, the Network News Transfer Protocol (NNTP) for network news, and the Hypertext Transfer Protocol (HTTP) for the World Wide Web.</p><p><a class="xref" href="ch72s08.html#ftp_reply_codes" title="Table 72-6. FTP Reply Codes">Table 72-6</a> contains a list of some of the more common FTP reply codes taken from RFC 959. They are shown in numerical order, along with the reply text presented as typical in that document and additional descriptive information as needed.</p><div class="table"><a id="ftp_reply_codes"/><p class="title">Table 72-6. FTP Reply Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FTP Reply Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Typical Reply Text</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Restart marker reply.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used as part of the marker restart feature when transferring in block mode.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>120</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Service ready in <span class="emphasis"><em>nnn</em></span> minutes.</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>nnn</em></span> indicates the number of minutes until the service will be available.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>125</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data connection already open; transfer starting.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>150</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>File status okay; about to open data connection.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>200</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command okay.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sometimes the text indicates the name of the command that was successful.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>202</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command not implemented, or superfluous at this site.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>211</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>System status, or system help reply.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Will contain system-specific status or help information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>212</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Directory status.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>213</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>File status.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>214</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Help message.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Includes help information of use to a human user of this server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>215</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>NAME</em></span> system type.</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>NAME</em></span> is the name of a type of operating system. Often sent as a reply to the SYST command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>220</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Service ready for new user.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent when the command channel is established before the USER command is sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>221</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Service closing control connection.</p></td><td style="border-bottom: 0.5pt solid ; "><p>A "goodbye" message is sent when the session is closed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>225</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data connection open; no transfer in progress.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>226</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Closing data connection.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent after a successful file transfer or a file abort.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>227</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Entering Passive Mode (h1,h2,h3,h4,p1,p2).</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent in reply to the PASV command, indicates the IP address and port to use for the data connection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>230</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User logged in, proceed.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent after successful USER and PASS authentication. Systems often include additional greeting or other information with this code after a login.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>250</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested file action okay, completed.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The text description will provide more details about what was successfully done, such as confirming a change of directory or deleted file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>257</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>PATHNAME</em></span> created.</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>PATHNAME</em></span> is replaced by the path created.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>331</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User name okay, need password.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Intermediate result after sending USER but before sending PASS.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>332</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Need account for login.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>350</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested file action pending further information.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>421</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Service not available, closing control connection.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sometimes sent if the FTP server is in the process of shutting down.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>425</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Can't open data connection.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>426</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Connection closed; transfer aborted.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>450</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested file action not taken. File unavailable.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The file is not available; for example, it may be locked by another user. Contrast to reply code 550.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>451</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action aborted: local error in processing.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>452</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action not taken. Insufficient storage space in system.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The file system is full.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>500</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax error, command unrecognized.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Bad or excessively long command line was sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>501</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax error in parameters or arguments.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>502</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command not implemented.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>503</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad sequence of commands.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>504</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command not implemented for that parameter.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>530</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not logged in.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent if authentication fails due to a bad user name or incorrect password.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>550</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action not taken. File unavailable.</p></td><td style="border-bottom: 0.5pt solid ; "><p>File was not found or user does not have access to it. This error code may be sent in reply to any file transfer command if the user has not successfully logged in yet. Contrast to reply code 450.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>551</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action aborted: page type unknown.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>552</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested file action aborted. Exceeded storage allocation.</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; "><p>553</p></td><td style="border-right: 0.5pt solid ; "><p>Requested action not taken. File name not allowed.</p></td><td style=""> </td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-430"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each command sent by the FTP client results in a reply sent by the FTP server. FTP replies consist of a three-digit numeric <span class="emphasis"><em>reply code</em></span>, along with a line of descriptive text. The reply code serves to standardize FTP replies, both so they can be interpreted by client software and so experienced users can see at a glance the results of a command. The reply code is structured so that the first two digits indicate the type of reply and to what category it belongs.</p></div></div><div class="sect2" title="FTP Multiple-Line Text Replies"><div class="titlepage"><div><div><h2 class="title"><a id="ftp_multiple-line_text_replies"/>FTP Multiple-Line Text Replies</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2585"/>It is possible for a reply to contain more than one line of text. In this case, each line starts with the reply code, and all lines but the last have a hyphen between the reply code and the reply text, to indicate that the reply continues. The last line includes a space between the reply code and reply text, just like a single-line reply. This facility is often used to provide additional response information after a user logs in, via the 230 reply code. <a class="xref" href="ch72s08.html#ftp_multiple-line_text_reply_example" title="Example 72-1. FTP multiple-line text reply example">Example 72-1</a> contains an example.</p><div class="example"><a id="ftp_multiple-line_text_reply_example"/><p class="title">Example 72-1. FTP multiple-line text reply example</p><div class="example-contents"><pre class="programlisting">230-Welcome user to FTP server jabberwockynocky.
230-
230-You are user #17 of 100 simultaneous users allowed.
230-
230-
230-Please see the file "faq.txt" for help using this server.
230-
230 Logged in.</pre></div></div><p>As I mentioned, the actual text string for each reply code is implementation-specific. You can sometimes find some rather humorous text strings associated with some of these error messages. For example, I tried some <a class="indexterm" id="idx-CHP-72-2586"/>commands using the FreeBSD FTP client on one of my Internet accounts. I tried to send or receive a file before I was logged in, and it didn't return an error like "Requested action not taken. File unavailable." Instead, it told me this: "Login first, then I might let you do that."</p></div></div>
<div class="sect1" title="FTP User Interface and User Commands"><div class="titlepage"><div><div><h1 class="title"><a id="ftp_user_interface_and_user_commands"/>FTP User Interface and User Commands</h1></div></div></div><p>The FTP command set provides a rich, complete set of instructions for implementing FTP. A human user could employ these commands to perform file-transfer functions directly with an FTP server. But to do this, the user must have an intimate knowledge of how FTP works. The user must know exactly which commands to send at which time, and in what order.</p><p>Gaining knowledge of internal FTP commands might be a reasonable assignment for an internetworking expert, but not for a typical TCP/IP application user. For this reason, the FTP protocol defines an additional protocol component as part of the user-FTP process: the FTP <span class="emphasis"><em>user interface</em></span>. It provides three main benefits to the FTP user:</p><p><span class="strong"><strong>User Friendliness</strong></span> The FTP user interface presents FTP to the human user in a way that is easier and simpler to use than issuing protocol commands. Instead of requiring the knowledge of all those four-letter codes, the user interface can allow functions to be performed with more intuitive human-language commands. For example, we can say <code class="literal">get</code> a file instead of having to use the command RETR.</p><p><span class="strong"><strong>Customization</strong></span> The command used to perform a particular function can be customized based on common parlance in the networking industry, without requiring changes to be made to FTP itself. For example, the image transfer mode is now also commonly called binary mode, so a user command called <code class="literal">binary</code> has been created to set this mode.</p><p><span class="strong"><strong>Detail Abstraction and Command Sequence Simplification</strong></span> A single user command can be made to issue multiple FTP protocol commands, hiding internal FTP details and making the protocol easier to use. In particular, commands that are related to the maintenance of the connection and other overhead issues that users don't want to deal with can be automated. For example, an FTP client normally issues a PASV or PORT command prior to each data transfer. The user interface can take care of issuing this command automatically prior to a RETR or STOR command when a user tells FTP to get or send a file.</p><div class="sect2" title="Command-Line and Graphical FTP Interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="command-line_and_graphical_ftp_interface"/>Command-Line and Graphical FTP Interfaces</h2></div></div></div><p><a class="indexterm" id="idx-CHP-72-2587"/><a class="indexterm" id="idx-CHP-72-2588"/>Traditionally, FTP clients have used a <span class="emphasis"><em>command-line interface</em></span>. In this familiar arrangement, an FTP client is invoked and the user is automatically asked for a user name and password to establish an FTP session. Then the user is presented with a command prompt, where the user can type various FTP commands to perform different functions. Text responses from the server are displayed to the user to indicate the results of various commands. Normally, the internal protocol <a class="indexterm" id="idx-CHP-72-2589"/>commands (such as PASV and STOR) sent by the client are suppressed to avoid screen clutter, but their display can be enabled in a debug mode.</p><p>Command-line utilities are efficient, but some folks don't care for them. They are rather "old school" in the context of modern graphical operating systems and applications. Thus, many modern FTP clients are graphical in nature. They allow actions to be performed by the user clicking buttons instead of typing commands. Some FTP clients allow files to be transferred by dragging and dropping from a local file system display to one on a remote server. These make FTP even easier to use.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-431"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The FTP <span class="emphasis"><em>user interface</em></span> is the component on the FTP client that acts as an intermediary between the human user and the FTP software. The existence of the user interface allows FTP to be used in a friendly manner without requiring knowledge of FTP's internal protocol commands. Most FTP software uses either a <span class="emphasis"><em>command-line interface</em></span> that understands English-like <a class="indexterm" id="idx-CHP-72-2590"/>user commands or a <span class="emphasis"><em>graphical interface</em></span>, where mouse clicks and other graphical operations are translated into FTP commands.</p></div></div><div class="sect2" title="Typical FTP User Commands"><div class="titlepage"><div><div><h2 class="title"><a id="typical_ftp_user_commands"/>Typical FTP User Commands</h2></div></div></div><p>To discover the specific commands supported by an FTP client, consult its documentation. In a command-line client, you can enter the command <code class="literal">?</code> to see a list of supported commands. <a class="xref" href="ch72s09.html#common_ftp_user_commands" title="Table 72-7. Common FTP User Commands">Table 72-7</a> shows some of the common commands encountered in typical FTP command-line clients, along with the typical parameters they require.</p><p>Note how many of these commands are actually synonyms, such as <code class="literal">bye</code>, <code class="literal">exit</code>, and <code class="literal">quit</code>. Similarly, you can use the command <code class="literal">type ascii</code> to set the ASCII data type or use the <code class="literal">ascii</code> command. This is all done for the user's convenience and is one of the benefits of having a flexible user interface that is distinct from the FTP command set.</p><p>Finally, an alternative way of using FTP is through the specification of an FTP Uniform Resource Locator (URL). While FTP is at its heart an interactive system, FTP URLs allow simple functions, such as retrieving a single file, to be done quickly and easily. They also allow FTP file references to be integrated with hypertext (World Wide Web) documents. See "URL Schemes and Scheme-Specific Syntaxes" in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a> for more on how FTP uses URLs.</p><div class="table"><a id="common_ftp_user_commands"/><p class="title">Table 72-7. Common FTP User Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common FTP User Commands"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User Command</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">account &lt;account-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends the ACCT command to access a particular account on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">append &lt;file-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Appends data to a file using APPE.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ascii</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the ASCII data type for subsequent transfers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">binary</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the image data type for subsequent transfers. Same as the <code class="literal">image</code> command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">bye</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Terminates FTP session and exits the FTP client (same as <code class="literal">exit</code> and <code class="literal">quit</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cd &lt;directory-path&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Changes the remote server working directory (using CWD protocol command).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cdup</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Goes to parent of current working directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">chmod &lt;file-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>On UNIX systems, changes file permissions of a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">close</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Closes a particular FTP session but user stays at FTP command line.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">debug</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets debug mode.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">delete &lt;file-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes a file on the FTP server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">dir [&lt;optional-file-specification&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Lists contents of current working directory (or files matching the specification).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">exit</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Another synonym for <code class="literal">bye</code> and <code class="literal">quit</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">form &lt;format&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the transfer format.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ftp &lt;ftp-server&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Opens session to the FTP server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">get &lt;file-name&gt; [&lt;dest-file-name&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Gets a file. If the <em class="replaceable"><code>&lt;dest-file-name&gt;</code></em> parameter is specified, it is used for the name of the file retrieved; otherwise, the source filename is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">help [&lt;optional-command-name&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays FTP client help information. Same as <code class="literal">?</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">image</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the image data type, like the <code class="literal">binary</code> command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ls [&lt;optional-file-specification&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Lists contents of current working directory (or files matching the specification). Same as <code class="literal">dir</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mget &lt;file-specification&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Gets multiple files from the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mkdir &lt;directory-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a directory on the remote server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mode</code> <strong class="userinput"><code>&lt;transfer-mode&gt;</code></strong></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the file transfer mode.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mput &lt;file-specification&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends (puts) multiple files to the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">msend &lt;file-specification&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as <code class="literal">mput</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">open &lt;ftp-server&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Opens a session to the FTP server (same as <code class="literal">ftp</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">passive</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Turns passive transfer mode on and off.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">put &lt;file-name&gt; [&lt;dest-file-name&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a file to the server. If the <em class="replaceable"><code>&lt;dest-file-name&gt;</code></em> parameter is specified, it is used as the name for the file on the destination host; otherwise, the source filename is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">pwd</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Prints current working directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">quit</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Terminates FTP session and exits FTP client (same as <code class="literal">bye</code> and <code class="literal">exit</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">recv &lt;file-name&gt; [&lt;dest-file-name&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Receives file (same as <code class="literal">get</code>). If the <em class="replaceable"><code>&lt;dest-file-name&gt;</code></em> parameter is specified, it is used for the name of the file retrieved; otherwise, the source filename is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">rename &lt;old-file-name&gt; &lt;new-file-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Renames a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">rhelp</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays remote help information, obtained using FTP <code class="literal">HELP</code> command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">rmdir &lt;directory-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">send &lt;file-name&gt; [&lt;dest-file-name&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a file (same as <code class="literal">put</code>). If the <em class="replaceable"><code>&lt;dest-file-name&gt;</code></em> parameter is specified, it is used as the name for the file on the destination host; otherwise, the source file name is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">site</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a site-specific command to the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">size &lt;file-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows the size of a remote file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">status</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays current session status.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">struct &lt;structure-type&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the file structure.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">system</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows the server's operating system type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">type &lt;data-type&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the data type for transfers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">user &lt;user-name&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Logs in to server as a new user. Server will prompt for a password.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">? [&lt;optional-command-name&gt;]</code></p></td><td style=""><p>Displays FTP client help information. Same as <code class="literal">help</code>.</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="Sample FTP Session"><div class="titlepage"><div><div><h1 class="title"><a id="sample_ftp_session"/>Sample FTP Session</h1></div></div></div><p><a class="indexterm" id="idx-CHP-72-2591"/>Having now seen all the details of how FTP works, let's tie everything together by looking at a sample FTP session between an FTP client and server, to see FTP commands and replies in action. In this example, I will invoke FTP from a client to retrieve a text file from an FTP server, and then I'll delete the file from the server and the directory that contained it. In the process, I will issue some additional commands to illustrate more of how FTP works. I will enable debug mode in the FTP client so that for each user command, you can see the actual FTP commands generated.</p><p><a class="xref" href="ch72s10.html#sample_ftp_session-id001" title="Table 72-8. Sample FTP Session">Table 72-8</a> shows the sample FTP session, slightly simplified. The first column contains commands entered by the user (that's me, of course) on the FTP client. The second shows the actual protocol command(s) sent to the FTP server in highlighted text and the reply returned from the server to the client in plain text. The third column contains descriptive comments.</p><div class="table"><a id="sample_ftp_session-id001"/><p class="title">Table 72-8. Sample FTP Session</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Sample FTP Session"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FTP Protocol Command/FTP Server Reply</p></th><th style="border-bottom: 0.5pt solid ; "><p>Comments</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78916"/></p><pre class="programlisting">ftp -d
pcguide.com</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78921"/></p><pre class="programlisting">Connected to pcguide.com.
220 ftp199.pair.com NcFTPd Server (licensed
copy) ready.
Name (pcguide.com:ixl):</pre></td><td style="border-bottom: 0.5pt solid ; "><p>This is the command to start up FTP. The <code class="literal">-d</code> enables debug mode. In this initial step, the TCP control connection is made and the server replies with a 220 reply code indicating that it's ready for user identification. The FTP client automatically prompts for the user name.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ixl</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78937"/></p><pre class="programlisting"><strong class="userinput"><code>USER ixl</code></strong>
331 User ixl okay, need password.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I use <code class="literal">ixl</code> for user names commonly. Here, the FTP client sends the user name and the server responds, asking for the password.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">****</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78955"/></p><pre class="programlisting"><strong class="userinput"><code>PASS XXXX</code></strong>
230-You are user #1 of 300 simultaneous users
allowed.
230-
230-
230-Welcome to (&lt;system name&gt;)
230-
230 Logged in.
<strong class="userinput"><code>SYST</code></strong>
215 UNIX Type: L8
Remote system type is UNIX.
Using binary mode to transfer files.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I enter my password, which is sent to the FTP server, and the server authenticates me and sends back a 230 message. This tells me the login was successful. It also provides additional information.</p>
<p>The FTP client then automatically sends a SYST command to tell me what type of system the server is using, which is UNIX in this case. The client tells me that binary mode has been selected by default; this is often the default when doing FTP from UNIX to UNIX (as I am doing here), since there is no need for ASCII mode when moving text files between similar systems.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">pwd</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78976"/></p><pre class="programlisting"><strong class="userinput"><code>PWD</code></strong>
257 "/usr/home/ixl" is cwd.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I check the current working directory (<code class="literal">cwd</code>), which the server tells me is my own home directory on this system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cd ftptest</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e78994"/></p><pre class="programlisting"><strong class="userinput"><code>CWD ftptest</code></strong>
550 No such directory.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I try to go to a directory called ftptest, but that was the wrong name, so I get a 550 error for my trouble. (I wasn't trying to do this; I forgot the directory name but figured I might as well show it to you anyway!)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cd ftpdemo</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79009"/></p><pre class="programlisting"><strong class="userinput"><code>CWD ftpdemo</code></strong>
250 "/usr/home/ixl/ftpdemo" is new cwd.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I got the name right this time, and the server confirms the new working directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">dir</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79024"/></p><pre class="programlisting"><strong class="userinput"><code>PASV</code></strong>
227 Entering Passive Mode
(ip1,ip2,ip3,ip4,193,224)
<strong class="userinput"><code>LIST</code></strong>
150 Data connection accepted from
ip5.ip6.ip7.ip8:4279; transfer starting.
-rw-r-r- 1 ixl users 16 May 22 17:47
testfile.txt
226 Listing completed.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I request a list of files from the server. The FTP client automatically issues a PASV command, and the server responds with a port number and IP address for it to use. (I have not shown the IP here for security reasons.) The directory listing is then transferred from the server to the client.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">asc</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79042"/></p><pre class="programlisting"><strong class="userinput"><code>TYPE A</code></strong>
200 Type okay.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I set ASCII mode, although I didn't really need to do that. Note that this client allowed me to abbreviate the <code class="literal">ascii</code> command as <code class="literal">asc</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79059"/></p><pre class="programlisting">get
testfile.txt</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79064"/></p><pre class="programlisting"><strong class="userinput"><code>PASV</code></strong>
227 Entering Passive Mode
(ip1,ip2,ip3,ip4,193,226)
<strong class="userinput"><code>RETR testfile.txt</code></strong>
150 Data connection accepted from
ip5.ip6.ip7.ip8:4283; transfer starting for
testfile.txt (16 bytes).
226 Transfer completed.
17 bytes received in 0.10 seconds (0.17 KB/s)</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I get the file in this demo directory using a <code class="literal">get</code> command. The server accepts the PASV command and sends the file. It initially sends a 150 reply as the transfer starts (initial positive reply), and then sends 226 when it is done. Note that the port numbers used here are different (for both server and client) than they were for the directory listing I did earlier.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79081"/></p><pre class="programlisting">del
testfile.txt</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79086"/></p><pre class="programlisting"><strong class="userinput"><code>DELE testfile.txt</code></strong>
250 Deleted.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I delete the original file on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cdup</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79101"/></p><pre class="programlisting"><strong class="userinput"><code>CDUP</code></strong>
250 "/usr/home/ixl" is new cwd.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I go up to the parent directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79113"/></p><pre class="programlisting">rmdir
ftpdemo</pre></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79118"/></p><pre class="programlisting"><strong class="userinput"><code>RMD ftpdemo</code></strong>
250 Directory removed.</pre></td><td style="border-bottom: 0.5pt solid ; "><p>I remove the directory that the file was in.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">quit</code></p></td><td style="border-right: 0.5pt solid ; "><p>
<a id="I_programlisting1_d1e79133"/></p><pre class="programlisting">QUIT
221 Goodbye.</pre></td><td style=""><p>I end the FTP session. The <code class="literal">quit</code> command also automatically closes the FTP client and returns me to the UNIX shell.</p></td></tr></tbody></table></div></div></div>
<div class="chapter" title="Chapter&#xA0;73.&#xA0;TRIVIAL FILE TRANSFER PROTOCOL (TFTP)"><div class="titlepage"><div><div><h1 class="title"><a id="trivial_file_transfer_protocol_tftp"/>Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e79147"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> In <a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a>, you saw how the File Transfer Protocol (FTP) implements a full set of commands and reply functionalities that enables a user to perform a wide range of file movement and manipulation tasks. Although FTP is ideal as a general-purpose protocol for file transfer between computers, on certain types of hardware, it is too complex to implement easily and provides more capabilities than are really needed. In cases where only the most basic file transfer functions are required while simplicity and small program size is of paramount importance, a companion to FTP called the <span class="emphasis"><em>Trivial File Transfer Protocol (TFTP)</em></span><a class="indexterm" id="idx-CHP-73-2592"/> can be used.</p><p>This chapter provides a description of the operation of TFTP, beginning with an overview description of the protocol, its history and motivation, and the relevant standards that describe it. I discuss its operation in general terms, cover how TFTP clients and servers communicate, and explain TFTP messaging in detail. I then discuss TFTP options and the TFTP option negotiation mechanism. The chapter concludes by showing the various TFTP message formats.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-432"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>While TFTP is a distinct protocol from FTP, explaining the former is easier when the reader is familiar with the latter. I assume that the reader has some understanding of FTP, since it is the more commonly used protocol. If you have come to this chapter prior to reading <a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a>, I recommend at least reading the section "FTP Overview, History, and Standards" in that chapter before proceeding here</em></span><a class="indexterm" id="idx-CHP-73-2593"/>.</p></div><div class="sect1" title="TFTP Overview, History, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="tftp_overview_history_and_standards"/>TFTP Overview, History, and Standards</h1></div></div></div><p><a class="indexterm" id="idx-CHP-73-2594"/>FTP is the main protocol used for the majority of general file transfers in TCP/IP internetworks. One of the objectives of the designers of FTP was to keep the protocol relatively simple, but that was possible only to a limited extent. To enable the protocol to be useful in a variety of cases and between many kinds of devices, FTP needed a fairly large set of features and capabilities. As a result, while FTP is not as complex as certain other protocols, it is still fairly complicated in a number of respects.</p><div class="sect2" title="Why TFTP Was Needed"><div class="titlepage"><div><div><h2 class="title"><a id="why_tftp_was_needed"/>Why TFTP Was Needed</h2></div></div></div><p>The complexity of FTP is partly due to the protocol itself, with its dozens of commands and reply codes, and partly due to the need of using TCP for connections and data transport. The reliance on TCP means that any device wanting to use FTP needs not only the FTP program but a full TCP implementation as well. It must handle FTP's need for simultaneous data and control channel connections and other requirements.</p><p>For a conventional computer, such as a regular PC, Macintosh, or UNIX workstation, none of this is really an issue, especially with today's large hard disks and fast, cheap memory. But remember that FTP was developed more than three decades ago, when hardware was slow and memory was expensive. Furthermore, even today, regular computers are not the only devices used on networks. Some networked devices do not have the capabilities of true computers, but they still need to be able to perform file transfers. For these devices, a full FTP and TCP implementation is a nontrivial matter.</p><p>One of the most notable examples of such devices are <a class="indexterm" id="idx-CHP-73-2595"/><span class="emphasis"><em>diskless workstations</em></span>—computers that have no permanent storage, so when they start up, they cannot read a whole TCP/IP implementation from a hard disk like most computers easily do. They start with only a small amount of built-in software and must obtain configuration information from a server and then download the rest of their software from another network device. The same issue arises for certain other hardware devices with no hard disks.</p><p>The process of starting up these devices is commonly called <a class="indexterm" id="idx-CHP-73-2596"/><span class="emphasis"><em>bootstrapping</em></span> and occurs in two phases. First, the workstation is provided with an IP address and other parameters through the use of a host configuration protocol such as the Bootstrap Protocol (BOOTP; see <a class="xref" href="ch60.html" title="Chapter 60. TCP/IP BOOTSTRAP PROTOCOL (BOOTP)">Chapter 60</a>) or the Dynamic Host Control Protocol (DHCP; see Chapters <a class="xref" href="ch61.html" title="Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS">Chapter 61</a> to <a class="xref" href="ch64.html" title="Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT">Chapter 64</a>). Second, the client downloads software, such as an operating system and drivers, that let it function on the network like any other device. This requires that the device have the ability to transfer files quickly and easily. The instructions to perform this bootstrapping must fit onto a read-only memory (ROM) chip, and this makes the size of the software an important issue—again, especially many years ago.</p><p>The solution <a class="indexterm" id="idx-CHP-73-2597"/>to this need was to create a "light" version of FTP that would emphasize small program size and simplicity over functionality. This new protocol, TFTP, was initially developed in the late 1970s and first standardized in 1980. The modern version, <span class="emphasis"><em>TFTP version 2</em></span>, was documented in RFC 783 in 1981, which was revised and published as RFC 1350, "The TFTP Protocol (Revision 2)," in 1992. This is the current version of the standard.</p></div><div class="sect2" title="Comparing FTP and TFTP"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_ftp_and_tftp"/>Comparing FTP and TFTP</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2598"/>Probably the best way to understand the relationship between TFTP and FTP is to compare it to the relationship between the Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) at the transport layer. UDP is a simplified, stripped-down alternative to TCP that is used when simplicity is more important than rich functionality. Similarly, TFTP is a greatly simplified version of FTP that allows only basic operations and lacks some of FTP's fancy capabilities in order to keep its implementation easy (even trivial) and its program size small.</p><p>Due to its limitations, TFTP is a complement to FTP, not a replacement for it. TFTP is used only when its simplicity is important and its lack of features is not. Its most common application is bootstrapping, as described above, though it can be used for other purposes. One specific application that the TFTP standard describes for the protocol is the transport of electronic mail (email). While the protocol supports this explicitly, TFTP is not generally used for this purpose today.</p><p>FTP and TFTP have significant differences in at least four significant areas:</p><p><span class="strong"><strong>Transport</strong></span> The comparison to TCP and UDP is apt not only based on the features/simplicity trade-off, but because FTP uses TCP for transport while TFTP uses UDP. Like TFTP, UDP is simple, and this makes the two ideal for embedding together as a hardware program set in a network device.</p><p><span class="strong"><strong>Limited Command Set</strong></span> FTP includes a rich set of commands to allow files to be sent, received, renamed, deleted, and so forth. TFTP allows files only to be sent and received.</p><p><span class="strong"><strong>Limited Data Representations</strong></span> TFTP does not include some of FTP's fancy data representation options; it allows only simple ASCII or binary file transfers.</p><p><span class="strong"><strong>Lack of Authentication</strong></span> UDP uses no login mechanism or other means of authentication. This is again a simplification, though it means the operators of TFTP servers must severely restrict the files they make available for access. (It is also part of why TFTP specifically does not allow the client to perform dangerous file operations such as deletion.)</p></div><div class="sect2" title="Overview of TFTP Operation"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_tftp_operation"/>Overview of TFTP Operation</h2></div></div></div><p>Communication and messaging in TFTP is very different from FTP because of the different transport layer protocols used by each. FTP makes use of TCP's rich functionality, including its stream data orientation, to allow it to send bytes of data directly over the FTP data connection. TCP also takes care of reliable delivery of data for FTP, ensuring that files are received correctly. In contrast, since TFTP uses UDP, it must package data into individual messages for both protocol control and data communication. TFTP must also take care of timing transmissions to detect lost datagrams and then retransmitting as needed.</p><p>TFTP servers allow connections from TFTP clients to perform file send and receive <a class="indexterm" id="idx-CHP-73-2599"/>operations. Many hosts that run FTP servers will also run a separate TFTP server module. TFTP users initiate connections by starting a TFTP client program, which generally uses a command-line interface similar to that of many FTP clients; the main difference is the much smaller number of commands in TFTP.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-433"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> For situations in which the full FTP is either unnecessary or impractical, the simpler <span class="emphasis"><em>Trivial File Transfer Protocol (TFTP)</em></span> was developed. TFTP is like FTP in that it is used for general file transfer between a client and server device, but it is stripped down in its capabilities. Rather than including a full command set and using TCP for communication, like FTP, TFTP can be used only for reading or writing a single file, and it uses the fast but unreliable UDP for transport. It is often preferred in situations where small files must be transferred quickly and simply, such as for bootstrapping diskless workstations.</p></div><p>The basic operation of TFTP has not changed since RFC 1350 was published, but a new feature was added to the protocol in 1995. RFC 1782, "TFTP Option Extension," defines a mechanism by which a TFTP client and TFTP server can negotiate certain parameters that will control a file transfer prior to the transfer commencing. This allows more flexibility in how TFTP is used, adding a slight amount of complexity to TFTP, but not a great deal.</p><p>The option extension is backward-compatible with regular TFTP and is used only if both server and client support it. Two subsequent RFCs define the actual options that can be negotiated: RFC 1783, "TFTP Blocksize Option," and RFC 1784, "TFTP Timeout Interval and Transfer Size Options." This set of three RFCs (1782, 1783, and 1784) was replaced in 1998 by updated versions in RFCs 2347, 2348, and 2349.</p></div></div></div>
<div class="sect1" title="TFTP General Operation, Connection Establishment, and Client/Server Communication"><div class="titlepage"><div><div><h1 class="title"><a id="tftp_general_operation_connection_establ"/>TFTP General Operation, Connection Establishment, and Client/Server Communication</h1></div></div></div><p>Since the <span class="emphasis"><em>T</em></span> in <span class="emphasis"><em>TF TP</em></span> stands for <span class="emphasis"><em>Trivial</em></span>, and the protocol was specifically designed to be simple, you would think that describing how it works would, in fact, be simple, wouldn't you? And, actually, that's pretty much true. TFTP communication is client/server based, as discussed in the overview. The process of transferring a file consists of three main phases:</p><p><span class="strong"><strong>Initial Connection</strong></span> The TFTP client establishes the connection by sending an initial request to the server. The server responds back to the client, and the connection is effectively opened.</p><p><span class="strong"><strong>Data Transfer</strong></span> Once the connection is established, the client and server exchange TFTP messages. One device sends data, and the other sends acknowledgments.</p><p><span class="strong"><strong>Connection <a class="indexterm" id="idx-CHP-73-2600"/>Termination</strong></span> When the last TFTP message containing data has been sent and acknowledged, the connection is terminated.</p><div class="sect2" title="Connection Establishment and Identification"><div class="titlepage"><div><div><h2 class="title"><a id="connection_establishment_and_identificat"/>Connection Establishment and Identification</h2></div></div></div><p>The matter of a connection is somewhat different in TFTP than it is with a protocol like FTP that uses TCP. FTP must establish a connection at the TCP level before anything can be done by FTP itself. TFTP, however, uses the connectionless UDP for transport, so there is no connection in the sense that one exists in TCP. In TFTP, the connection is more in a <span class="emphasis"><em>logical</em></span> sense, meaning that the client and server are participating in the protocol and exchanging TFTP messages.</p><p>The TFTP server listens continuously for requests on well-known UDP port number 69, which is reserved for TFTP. The client chooses for its initial communication an ephemeral port number, as is usually the case in TCP/IP. This port number actually identifies the data transfer and is called a <a class="indexterm" id="idx-CHP-73-2601"/><span class="emphasis"><em>transfer identifier (TID)</em></span><a class="indexterm" id="idx-CHP-73-2602"/>.</p><p>What's different about TFTP, however, is that the server also selects a pseudorandom TID that it uses for sending responses back to the client; it doesn't send them from port number 69. This is done because by using a unique client port number and source port number, multiple TFTP exchanges can be conducted simultaneously by a server. Each transfer is identified automatically by the source and destination port number, so there is no need to identify in data messages the transfer to which each block data belongs. This keeps the TFTP header size down, allowing more of each UDP message to contain actual data.</p><p>For example, suppose the TFTP client selects a TID of 3145 for its initial message. It would send a UDP transmission from its port 3145 to the server's port 69. Say the server selects a TID of 1114. It would send its reply from its port 1114 to the client's port 3145. From then on, the client would send messages back to server port 1114 until the TFTP session was completed.</p></div><div class="sect2" title="Lock-Step Client/Server Messaging"><div class="titlepage"><div><div><h2 class="title"><a id="lock-step_clientserver_messaging"/>Lock-Step Client/Server Messaging</h2></div></div></div><p>After the initial exchange, the client and server exchange data and acknowledgment messages in <span class="emphasis"><em>lock-step</em></span> fashion. Each device sends a message for each message it receives: one device sends data messages and waits for acknowledgments; the other sends acknowledgments and waits for data messages. This form of rigid communication is less efficient than allowing the transmitter to fire away with one data message after another, but it is important because it keeps TFTP simple when it comes to an important issue: retransmissions.</p><p>Like all protocols using the unreliable UDP, TFTP has no assurances that any messages sent will actually arrive at their destination, so it must use timers to detect lost transmissions and resend them. What is different about TFTP is that both clients and servers perform retransmission. The device that is sending data messages will resend the data message if it doesn't receive an acknowledgment in a reasonable period of time; the device sending the acknowledgments will resend the acknowledgment if it doesn't receive the next data message promptly. The lock-step communication greatly simplifies this process, since each device needs to keep track of only one outstanding message at a time. It also eliminates the need to deal with complications such as reorganizing blocks received out of order (which protocols like FTP rely on TCP to manage).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-434"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since TFTP uses UDP rather than TCP, no explicit concept of a connection exists as in FTP. A TFTP session instead uses the concept of a logical connection, which is opened when a client sends a request to a server to read or write a file. Communication between the client and server is performed in lock-step fashion: one device sends data messages and receives acknowledgments so it knows the data messages were received; the other sends acknowledgments and receives data messages so it knows the acknowledgments were received.</p></div></div><div class="sect2" title="Difficulties with TFTP's Simplified Messaging Mechanism"><div class="titlepage"><div><div><h2 class="title"><a id="difficulties_with_tftps_simplified_messa"/>Difficulties with TFTP's Simplified Messaging Mechanism</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2603"/>One of the most important drawbacks with this technique is that while it simplifies communication, it does so at the cost of performance. Since only one message can be in transit at a time, this limits throughput to a maximum of 512 bytes for exchange of messages between the client and server. In contrast, when using FTP, large amounts of data can be pipelined; there is no need to wait for an acknowledgment for the first piece of data before sending the second.</p><p>Another complication is that if a data or an acknowledgment message is resent and the original was not lost but rather just delayed, two copies will show up. The original TFTP rules stated that upon receipt of a duplicate datagram, the device receiving it may resend the current datagram. So, receipt of a duplicate block 2 by a client doing a read would result in the client sending a duplicate acknowledgment for block 2. This would result in two acknowledgments being received by the server, which would in turn send block 3 twice. Then there would be two acknowledgments for block 3, and so on.</p><p>The end result of this is that once the initial duplication occurs, every message thereafter is sent twice. This has been affectionately dubbed the <span class="emphasis"><em>Sorcerer's Apprentice bug</em></span>, after the story used as the basis of the famous scene in the movie <span class="emphasis"><em>Fantasia</em></span>, where Mickey Mouse cuts animated brooms in half only to find that each half comes to life. This problem was fixed by changing the rules so that only the device receiving a duplicate data message may send a duplicate acknowledgment. Receipt of a duplicate acknowledgment does not result in sending a duplicate data message. Since only one of the two devices can send duplicates, this fixes the problem.</p><p>It's also worth emphasizing that TFTP includes absolutely no security, so no login or authentication process is in place. As mentioned earlier, administrators must use caution in deciding what files to make available via TFTP and in allowing write access to TFTP servers.</p></div></div>
<div class="sect1" title="TFTP Detailed Operation and Messaging"><div class="titlepage"><div><div><h1 class="title"><a id="tftp_detailed_operation_and_messaging"/>TFTP Detailed Operation and Messaging</h1></div></div></div><p><a class="indexterm" id="idx-CHP-73-2604"/>You saw earlier that TFTP operation consists of three general steps: initial connection, data transfer, and connection termination. All operations are performed through the exchange of specific TFTP messages. Let's take a more detailed look now at these three phases of operation and the specifics of TFTP messaging.</p><div class="sect2" title="Initial Message Exchange"><div class="titlepage"><div><div><h2 class="title"><a id="initial_message_exchange"/>Initial Message Exchange</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2605"/>The first message sent by the client to initiate TFTP is either a read request (RRQ) message or a write request (WRQ) message. This message serves implicitly to establish the logical TFTP connection and to indicate whether the file is to be sent from the server to the client (read request) or the client to the server (write request). The message also specifies the type of file transfer to be performed. TFTP supports two transfer modes: <span class="emphasis"><em>netascii</em></span> mode (ASCII text files as used by the Telnet Protocol) and <span class="emphasis"><em>octet</em></span> mode (binary files).</p><div class="note" title="Note"><h3 class="title"><a id="note-157"/>Note</h3><p><span class="emphasis"><em>Originally, a third file type option existed, called mail mode, but TFTP was never really designed for transmitting mail and this option is now obsolete</em></span>.</p></div><p>Assuming no problem occurred with the request (such as a server problem, inability to find the file, and so on), the server will respond with a positive reply. In the case of a read request, the server will immediately send the first data message back to the client. In the case of a write request, the server will send an acknowledgment message to the client, telling it that it may proceed to send the first data message.</p><p>After the initial exchange, the client and server exchange data and acknowledgment messages in lock-step fashion as described earlier. For a read, the server sends one data message and waits for an acknowledgment from the client before sending the next one. For a write, the client sends one data message and the server sends an acknowledgment for it, before the client sends the next data message.</p></div><div class="sect2" title="Data Block Numbering"><div class="titlepage"><div><div><h2 class="title"><a id="data_block_numbering"/>Data Block Numbering</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2606"/>Each data message contains a block of between 0 and 512 bytes of data. The blocks are numbered sequentially, starting with 1. The number of each block is placed in the header of the data message carrying that block and then used in the acknowledgment for that block so the original sender knows it was received. The device sending the data will always send 512 bytes of data at a time for as long as it has enough data to fill the message. When it gets to the end of the file and has fewer than 512 bytes to send, it will send only as many bytes as remain. (Interestingly, this means that if the size of the file is an exact multiple of 512, the last message sent will have zero bytes of data!)</p><p>The receipt of a data message with between 0 and 511 bytes of data signals that this is the last data message. Once this is acknowledged, it automatically signals the end of the data transfer. There is no need to terminate the connection explicitly, just as it was not necessary to establish it explicitly.</p></div><div class="sect2" title="TFTP Read Process Steps"><div class="titlepage"><div><div><h2 class="title"><a id="tftp_read_process_steps"/>TFTP Read Process Steps</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2607"/>Let's look at an example that shows how TFTP messaging works. Suppose the client wants to read a particular file that is 1200 bytes long. Here are the steps in simplified form (also displayed in <a class="xref" href="ch73s03.html#tftp_read_process_in_this_example_the_cl" title="Figure 73-1. TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file.">Figure 73-1</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The client sends a read request to the server, specifying the name of the file.</p></li><li class="listitem"><p>The server sends back a data message containing block 1, carrying 512 bytes of data.</p></li><li class="listitem"><p>The client receives the data and sends back an acknowledgment for block 1.</p></li><li class="listitem"><p>The server sends block 2, with 512 bytes of data.</p></li><li class="listitem"><p>The client receives block 2 and sends back an acknowledgment for it.</p></li><li class="listitem"><p>The server sends block 3, containing 176 bytes of data. It waits for an acknowledgment before terminating the logical connection.</p></li><li class="listitem"><p>The client receives the data and sends an acknowledgment for block 3. Since this data message had fewer than 512 bytes, it knows the file is complete.</p></li><li class="listitem"><p>The server receives the acknowledgment and knows the file was received successfully.</p></li></ol></div><div class="figure"><a id="tftp_read_process_in_this_example_the_cl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e79460"/><img alt="TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file." src="httpatomoreillycomsourcenostarchimages288271.png.jpg"/></div></div><p class="title">Figure 73-1. TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file.</p></div></div><div class="sect2" title="TFTP Write Process Steps"><div class="titlepage"><div><div><h2 class="title"><a id="tftp_write_process_steps"/>TFTP Write Process Steps</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2608"/><a class="indexterm" id="idx-CHP-73-2609"/>Here are the steps in the same process, but where the client is writing the file (see <a class="xref" href="ch73s03.html#tftp_write_process_this_example_shows_th" title="Figure 73-2. TFTP write process This example shows the client sending the same 1200-byte file to the server that it read in Figure 73-1. The client sends a write request to the server, which acknowledges it; it uses block 0 to represent acknowledgment of the request prior to receipt of any data. The client then sends blocks of data one at a time, each of which is acknowledged by the server. When the server receives block 3 containing fewer than 512 bytes of data, it knows it has received the whole file.">Figure 73-2</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The client sends a write request to the server, specifying the name of the file.</p></li><li class="listitem"><p>The server sends back an acknowledgment. Since this acknowledgment is prior to the receipt of any data, it uses block 0 in the acknowledgment.</p></li><li class="listitem"><p>The client sends a data message containing block 1, with 512 bytes of data.</p></li><li class="listitem"><p>The server receives the data and sends back an acknowledgment for block 1.</p></li><li class="listitem"><p>The client sends block 2, containing 512 bytes of data.</p></li><li class="listitem"><p>The server receives the data and sends back an acknowledgment for block 2.</p></li><li class="listitem"><p>The client sends block 3, containing 176 bytes of data. It waits for an acknowledgment before terminating the logical connection.</p></li><li class="listitem"><p>The server receives block 3 and sends an acknowledgment for it. Since this data message had fewer than 512 bytes, the transfer is done.</p></li><li class="listitem"><p>The client receives the acknowledgment for block 3 and knows the file write was completed successfully.</p></li></ol></div><div class="figure"><a id="tftp_write_process_this_example_shows_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e79513"/><img alt="TFTP write process This example shows the client sending the same 1200-byte file to the server that it read in . The client sends a write request to the server, which acknowledges it; it uses block 0 to represent acknowledgment of the request prior to receipt of any data. The client then sends blocks of data one at a time, each of which is acknowledged by the server. When the server receives block 3 containing fewer than 512 bytes of data, it knows it has received the whole file." src="httpatomoreillycomsourcenostarchimages288273.png.jpg"/></div></div><p class="title">Figure 73-2. TFTP write process This example shows the client sending the same 1200-byte file to the server that it read in <a class="xref" href="ch73s03.html#tftp_read_process_in_this_example_the_cl" title="Figure 73-1. TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file.">Figure 73-1</a>. The client sends a write request to the server, which acknowledges it; it uses block 0 to represent acknowledgment of the request prior to receipt of any data. The client then sends blocks of data one at a time, each of which is acknowledged by the server. When the server receives block 3 containing fewer than 512 bytes of data, it knows it has received the whole file.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-435"/>Tip</h3><p><a class="indexterm" id="idx-CHP-73-2610"/><span class="strong"><strong>KEY CONCEPT</strong></span> A TFTP <span class="emphasis"><em>read operation</em></span> begins with the client sending a read request message to the TFTP server; the server then sends the file in 512-byte data messages, waiting after each one for the client to acknowledge receipt before sending the next. A TFTP <span class="emphasis"><em>write operation</em></span> starts with a write request sent by the client to the server, which the server acknowledges. The client then sends the file in 512-byte data blocks, waiting after each for the server to acknowledge receipt. In both cases, there is no explicit means by which the end of a transfer is marked; the device receiving the file simply knows the transfer is complete when it receives a data message containing fewer than 512 bytes.</p></div><p>If a problem is encountered at any stage of the connection establishment or transfer process, a device may reply with an error message instead of a data or acknowledgment message, as appropriate. An error message normally results in the failure of the data transfer; this is one of the prices paid for the simplicity of TFTP.</p><p>Each TFTP file transfer proceeds using the process described, which transfers a single file. If another file needs to be sent or received, a new logical communication is established, in a manner analogous to how FTP creates data connections. The main difference is that TFTP has no persistent control connection, as FTP does.</p></div></div>
<div class="sect1" title="TFTP Options and Option Negotiation"><div class="titlepage"><div><div><h1 class="title"><a id="tftp_options_and_option_negotiation"/>TFTP Options and Option Negotiation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-73-2611"/>One of the difficulties that designers of simple protocols and applications seem to have is keeping them simple. Many protocols start out small, but over time well-intentioned users suggest improvements that are added slowly but surely. Eventually, the program that was once lean and mean has become, shall we say, "well-marbled." In the software industry, this is called <span class="emphasis"><em>feature creep</em></span> and has happened to many protocols and applications.</p><p>The temptation to add features is especially strong when the program or protocol has few to begin with. Given this, the maintainers of TFTP have done a good job over the years of avoiding this pitfall. However, they did allow one new feature to be added to the protocol in 1995: the "TFTP Option Extension," which describes how a TFTP client and server can negotiate <span class="emphasis"><em>options</em></span> before transferring a file.</p><p>The reason for adding this capability is that the original TFTP provided no way at all for the client and server to exchange important control information prior to sending a file. This limited the flexibility of the protocol to deal with special cases, such as the transfer of data over unusual network types. The TFTP option negotiation feature allows additional parameters to be exchanged between the client and server that govern how data is transferred. It does this without significantly complicating the protocol and is backward-compatible with normal TFTP. It is used only if both client and server support it, and one device trying to use the feature will not cause problems if the other doesn't support it.</p><div class="sect2" title="TFTP Option Negotiation Process"><div class="titlepage"><div><div><h2 class="title"><a id="tftp_option_negotiation_process"/>TFTP Option Negotiation Process</h2></div></div></div><p>The client begins the negotiation by sending a modified TFTP read request or write request message. In addition to the normal information that appears in this message (described in the "TFTP Message Formats" section later in this chapter), a list of options may also be included. Each is specified with an option code and an option value. The names and values are expressed as ASCII strings, terminated by a null character (0 byte). Multiple options may be specified in the request message.</p><p>The server receives the request containing the options, and if it supports the option extension, it processes them. It then returns a <span class="emphasis"><em>special option acknowledgment (<a class="indexterm" id="idx-CHP-73-2613"/>OACK</em></span><a class="indexterm" id="idx-CHP-73-2612"/>) message to the client, where it lists all the options that the client specified that the server recognizes and accepts. Any options that the client requested but the server rejects are not included in the OACK. The client may use only the options that the server accepts. If the client rejects the server's response, it may send back an error message (with error code 8) upon receipt of the unacceptable OACK message.</p><p>The server may specify an alternative value in its response for certain options, if it recognizes the option but doesn't like the client's suggested value. Obviously, if the server doesn't support options at all, it will ignore the client's option requests and respond with a data message (for a read) or a regular acknowledgment (for a write) as in normal TFTP.</p><p>If the server did send an OACK, the client proceeds to send messages using the regular messaging exchange described in the previous section. In the case of a write, the OACK replaces the regular acknowledgment in the message dialog. In the case of a read, the OACK is the server's first message instead of the first data block that it would normally send. TFTP doesn't allow the same device to send two datagrams in a row, so a reply from the client must be received before that first block can be sent. The client does this by sending a regular acknowledgment with a block number of 0 in it—the same form of acknowledgment a server normally sends for a write.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-436"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> TFTP is supposed to be a small and simple protocol, so it includes few extra features. One that it does support is <span class="emphasis"><em>option negotiation</em></span>, where a TFTP client and server attempt to come to agreement on additional parameters that they will use in transferring a file. The TFTP client includes one or more options in its read request or write request message; the TFTP server then sends an option acknowledgment (OACK) message listing each option the server agrees to use. The use of options when reading a file means that an extra acknowledgment must be sent by the client—to acknowledge the OACK—before the server sends the first block of the file.</p></div><p>For review, let's take a look at each of the four possible cases: read and write, with and without options.</p><p>The initial message exchange for a normal read (without option negotiation), as shown in <a class="xref" href="ch73s03.html#tftp_read_process_in_this_example_the_cl" title="Figure 73-1. TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file.">Figure 73-1</a>, is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Client sends read request.</p></li><li class="listitem"><p>Server sends data block 1.</p></li><li class="listitem"><p>Client acknowledges data block 1.</p><p>And so on …</p></li></ol></div><p>With option negotiation, a read is as follows (see <a class="xref" href="ch73s04.html#tftp_read_process_with_option_negotiatio" title="Figure 73-3. TFTP read process with option negotiation This diagram shows the same example illustrated in Figure 73-1, but with one added message exchange used for option negotiation. The client's initial read request here includes options that it wants to use for this transfer. The server responds not immediately with the first data block, but with an OACK. The client indicates receipt of the OACK by sending an acknowledgment using block 0. The server sends data block 1, and the rest of the exchange proceeds as normal.">Figure 73-3</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Client sends read request with options.</p></li><li class="listitem"><p>Server sends OACK.</p></li><li class="listitem"><p>Client sends regular acknowledgment for block 0; that is, it acknowledges the OACK.</p></li><li class="listitem"><p>Server sends data block 1.</p></li><li class="listitem"><p>Client acknowledges data block 1.</p><p>And so on …</p></li></ol></div><div class="figure"><a id="tftp_read_process_with_option_negotiatio"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e79635"/><img alt="TFTP read process with option negotiation This diagram shows the same example illustrated in , but with one added message exchange used for option negotiation. The client's initial read request here includes options that it wants to use for this transfer. The server responds not immediately with the first data block, but with an OACK. The client indicates receipt of the OACK by sending an acknowledgment using block 0. The server sends data block 1, and the rest of the exchange proceeds as normal." src="httpatomoreillycomsourcenostarchimages288275.png.jpg"/></div></div><p class="title">Figure 73-3. TFTP read process with option negotiation This diagram shows the same example illustrated in <a class="xref" href="ch73s03.html#tftp_read_process_in_this_example_the_cl" title="Figure 73-1. TFTP read process In this example, the client starts the process of reading a file by sending a request for it to the server. The server acknowledges this request by immediately sending a DATA message carrying block 1, containing the first 512 bytes of the file. The client acknowledges this with an ACK message for block 1. The server then sends block 2, containing bytes 513 to 1024, which the client acknowledges. When the client receives block 3, it realizes it has only 176 bytes, which marks it as the last block of the file.">Figure 73-1</a>, but with one added message exchange used for option negotiation. The client's initial read request here includes options that it wants to use for this transfer. The server responds not immediately with the first data block, but with an OACK. The client indicates receipt of the OACK by sending an acknowledgment using block 0. The server sends data block 1, and the rest of the exchange proceeds as normal.</p></div><p>The initial message exchange for a normal write (without option negotiation) is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Client sends write request.</p></li><li class="listitem"><p>Server sends acknowledgment.</p></li><li class="listitem"><p>Client sends data block 1.</p></li><li class="listitem"><p>Server acknowledges data block 1.</p><p>And so on …</p></li></ol></div><p>And here's a write <a class="indexterm" id="idx-CHP-73-2614"/>with option negotiation:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Client sends write request with options.</p></li><li class="listitem"><p>Server sends option acknowledgment (instead of regular acknowledgment).</p></li><li class="listitem"><p>Client sends data block 1.</p></li><li class="listitem"><p>Server acknowledges data block 1.</p><p>And so on …</p></li></ol></div></div><div class="sect2" title="TFTP Options"><div class="titlepage"><div><div><h2 class="title"><a id="tftp_options"/>TFTP Options</h2></div></div></div><p><a class="xref" href="ch73s04.html#tftp_options-id001" title="Table 73-1. TFTP Options">Table 73-1</a> contains a summary of the three TFTP <a class="indexterm" id="idx-CHP-73-2615"/>options currently defined.</p><div class="table"><a id="tftp_options-id001"/><p class="title">Table 73-1. TFTP Options</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP Options"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-73-2616"/>TFTP Option Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TFTP Option Code (Used in Request <a class="indexterm" id="idx-CHP-73-2617"/>Messages)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Defining RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Block Size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>blksize</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2348</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows the client and server to send data blocks of a size other than 512 bytes to improve efficiency or address limitations of a particular type of network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Timeout Interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2349</p></td><td style="border-bottom: 0.5pt solid ; "><p>Permits the client and server to agree on a specified number of seconds to use for their retransmission timers. Again, may be of value on certain networks with high latency or other special requirements.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Transfer Size</p></td><td style="border-right: 0.5pt solid ; "><p>tsize</p></td><td style="border-right: 0.5pt solid ; "><p>2349</p></td><td style=""><p>Lets the device sending the file (client on a write, server on a read) tell the other device the size of the file before the transfer commences. This allows the receiving device to allocate space for it in advance.</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="TFTP Message Formats"><div class="titlepage"><div><div><h1 class="title"><a id="tftp_message_formats"/>TFTP Message Formats</h1></div></div></div><p>Unlike FTP, all communication in TFTP is accomplished in the form of discrete messages that follow a particular message format. The reason why TFTP and FTP are so different in this regard is because of the different transport protocols they use. FTP uses TCP, which allows data to be streamed a byte at a time; FTP also makes use of a dedicated channel for commands. TFTP runs on UDP, which uses a conventional header/data formatting scheme.</p><p>The original TFTP standard defines five different types of messages: <a class="indexterm" id="idx-CHP-73-2618"/>read request (RRQ), <a class="indexterm" id="idx-CHP-73-2619"/>write request (WRQ), data (DATA), acknowledgment (ACK), and error (ERROR). The TFTP option extension feature defines a sixth message: option acknowledgment (OACK). Of these six messages, the first two share the same message format. The only common field in every TFTP message is the operation code (Opcode), which tells the recipient of the message what type it is.</p><p>TFTP's message formats are different than those used for certain other protocols, because many of the fields in TFTP are variable in length. Usually, variable-length fields in messages are expressed using a preceding length field that specifies the length of the variable-sized field. Instead, TFTP sends such fields as strings of ASCII characters using netascii, the Telnet version of ASCII. The end of the string is marked by a zero byte. The exception to this is the data field in data messages, the content of which depends on the transfer mode.</p><p>The remainder of the chapter contains the details on each of the TFTP messages.</p><div class="sect2" title="Read Request and Write Request Messages"><div class="titlepage"><div><div><h2 class="title"><a id="read_request_and_write_request_messages"/>Read Request and Write Request Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2620"/>These messages use a common message format, described in <a class="xref" href="ch73s05.html#tftp_rrqwrq_message_format" title="Table 73-2. TFTP RRQ/WRQ Message Format">Table 73-2</a> and shown graphically in <a class="xref" href="ch73s05.html#tftp_rrqwrq_message_format-id001" title="Figure 73-4. TFTP RRQ/WRQ message format">Figure 73-4</a>.</p><div class="table"><a id="tftp_rrqwrq_message_format"/><p class="title">Table 73-2. TFTP RRQ/WRQ Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP RRQ/WRQ Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-73-2621"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the TFTP message type. A value of 1 indicates a RRQ message, while a value of 2 is a WRQ message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Filename</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The name of the file to be <a class="indexterm" id="idx-CHP-73-2622"/>read or written.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Transfer Mode: The string netascii or octet, zero-terminated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>When the client supports TFTP options, it will encode them in sequence following the Mode field. Each option consists of two variable-length subfields. The optN subfield is the option code for option N, containing a string specifying the name of the option; currently, blksize, interval, and tsize are supported. The valueN subfield is the option value for option N, containing the value the client is requesting for this option. (Note that this is a zero-terminated string just like other TFTP variable-length fields, even for a numeric value.)</p></td></tr></tbody></table></div></div><div class="figure"><a id="tftp_rrqwrq_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e79875"/><img alt="TFTP RRQ/WRQ message format" src="httpatomoreillycomsourcenostarchimages288277.png"/></div></div><p class="title">Figure 73-4. TFTP RRQ/WRQ message format</p></div></div><div class="sect2" title="Data Messages"><div class="titlepage"><div><div><h2 class="title"><a id="data_messages"/>Data Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2623"/><a class="indexterm" id="idx-CHP-73-2624"/>Data blocks are sent using the simplified format shown in <a class="xref" href="ch73s05.html#tftp_data_message_format" title="Table 73-3. TFTP Data Message Format">Table 73-3</a> and <a class="xref" href="ch73s05.html#tftp_data_message_format-id001" title="Figure 73-5. TFTP data message format">Figure 73-5</a>.</p><div class="table"><a id="tftp_data_message_format"/><p class="title">Table 73-3. TFTP Data Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP Data Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the TFTP message type. A value of 3 indicates a data message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Block #</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Block Number: The number of the data block being sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Data: 0 to 512 bytes of data.</p></td></tr></tbody></table></div></div><div class="figure"><a id="tftp_data_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e79951"/><img alt="TFTP data message format" src="httpatomoreillycomsourcenostarchimages288279.png"/></div></div><p class="title">Figure 73-5. TFTP data message format</p></div></div><div class="sect2" title="Acknowledgment Messages"><div class="titlepage"><div><div><h2 class="title"><a id="acknowledgment_messages"/>Acknowledgment Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2625"/>Acknowledgments have the simplest format of any <a class="indexterm" id="idx-CHP-73-2626"/>TFTP message, as you can see in <a class="xref" href="ch73s05.html#tftp_acknowledgment_message_format" title="Table 73-4. TFTP Acknowledgment Message Format">Table 73-4</a> and <a class="xref" href="ch73s05.html#tftp_acknowledgment_message_format-id001" title="Figure 73-6. TFTP acknowledgment message format">Figure 73-6</a>.</p><div class="table"><a id="tftp_acknowledgment_message_format"/><p class="title">Table 73-4. TFTP Acknowledgment Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP Acknowledgment Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-73-2627"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the TFTP message type. A value of 4 indicates an ACK message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Block #</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style=""><p>Block Number: The number of the <a class="indexterm" id="idx-CHP-73-2628"/>data block being acknowledged; a value of 0 is used to acknowledge receipt of a write request without options or to acknowledge receipt of an OACK.</p></td></tr></tbody></table></div></div><div class="figure"><a id="tftp_acknowledgment_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e80031"/><img alt="TFTP acknowledgment message format" src="httpatomoreillycomsourcenostarchimages288281.png.jpg"/></div></div><p class="title">Figure 73-6. TFTP acknowledgment message format</p></div></div><div class="sect2" title="Error Messages"><div class="titlepage"><div><div><h2 class="title"><a id="error_messages"/>Error Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-73-2629"/>Error messages can be sent by either the client or server in cases where a problem is detected in the communication. They have the format indicated in <a class="xref" href="ch73s05.html#tftp_error_message_format-id001" title="Table 73-5. TFTP Error Message Format">Table 73-5</a> and <a class="xref" href="ch73s05.html#tftp_error_message_format" title="Figure 73-7. TFTP error message format">Figure 73-7</a>.</p><div class="figure"><a id="tftp_error_message_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e80055"/><img alt="TFTP error message format" src="httpatomoreillycomsourcenostarchimages288283.png"/></div></div><p class="title">Figure 73-7. TFTP error message format</p></div><div class="table"><a id="tftp_error_message_format-id001"/><p class="title">Table 73-5. TFTP Error Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP Error Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the TFTP message type. A value of 5 indicates an error message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A numeric code indicating the type of message being communicated. Values 0 to 7 are defined by the TFTP standard, while value 8 was added by the TFTP option extension:</p>
<p>0 = Not defined; see error message field for details</p>
<p>1 = File not found</p>
<p>2 = Access violation</p>
<p>3 = Disk full or allocation exceeded</p>
<p>4 = Illegal TFTP operation</p>
<p>5 = Unknown transfer ID</p>
<p>6 = File already exists</p>
<p>7 = No such user</p>
<p>8 = Client transfer termination due to unacceptable option negotiation</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Error Msg</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Error Message: A descriptive text error message string, intended for "human consumption," as the standard puts it.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Option Acknowledgment Messages"><div class="titlepage"><div><div><h2 class="title"><a id="option_acknowledgment_messages"/>Option Acknowledgment Messages</h2></div></div></div><p>OACK messages are used to acknowledge receipt of TFTP options. They are structured as shown in <a class="xref" href="ch73s05.html#tftp_oack_message_format" title="Table 73-6. TFTP OACK Message Format">Table 73-6</a> and <a class="xref" href="ch73s05.html#tftp_oack_message_format-id001" title="Figure 73-8. TFTP OACK message format">Figure 73-8</a>.</p><div class="table"><a id="tftp_oack_message_format"/><p class="title">Table 73-6. TFTP OACK Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TFTP OACK Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the TFTP message type. A value of 6 indicates an OACK message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>A list of options being acknowledged by the server. Each option consists of two variable-length subfields. The optN subfield is the option code for option N, containing a string specifying the name of the option, copied from the RRQ or WRQ message. The valueN subfield is the option value for option N, containing the acknowledged value for the option, which may be the value that the client specified or an alternative value, depending on the type of option.</p></td></tr></tbody></table></div></div><div class="figure"><a id="tftp_oack_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e80188"/><img alt="TFTP OACK message format" src="httpatomoreillycomsourcenostarchimages288285.png.jpg"/></div></div><p class="title">Figure 73-8. TFTP OACK message format</p></div></div></div></body></html>