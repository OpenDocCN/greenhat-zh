<html><head></head><body><div class="part" title="Part&#xA0;II-6.&#xA0;IP SUPPORT PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="ip_support_protocols"/>Part II-6. IP SUPPORT PROTOCOLS</h1></div></div></div><div class="partintro" id="id3248242" title="IP SUPPORT PROTOCOLS"><div/><p><a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a></p><p><a class="xref" href="ch32.html" title="Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS">Chapter 32</a></p><p><a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a></p><p><a class="xref" href="ch34.html" title="Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS">Chapter 34</a></p><p><a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a></p><p><a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a></p><p>The Internet Protocol (IP) is the key network layer protocol that implements the TCP/IP protocol suite. Since IP is the protocol that provides the mechanism for delivering datagrams between devices, it is designed to be relatively basic. For example, it lacks provisions for some way to allow errors to be reported back to a transmitting device, and for tests and special tasks to be accomplished. These auxiliary capabilities are necessary for the operation of an internetwork, however, so TCP/IP includes <span class="emphasis"><em>support protocols</em></span> that help IP perform these tasks. This part examines the two main IP support protocols: the <span class="emphasis"><em>Internet Control Message Protocol (ICMP)</em></span> and the <span class="emphasis"><em>Neighbor Discovery (ND)</em></span> protocol.</p><p>The bulk of this part thoroughly describes ICMP, which was initially developed to be a companion to the original IP version 4 (IPv4). With the creation of IP version 6 (IPv6), a new version of ICMP, called ICMP version 6 (ICMPv6), was created as well. The original ICMP is now sometimes called <span class="emphasis"><em>ICMPv4</em></span> to differentiate it, just as the original IP is now often called IPv4.</p><p>The two versions of ICMP have some differences in their specifics, but they are very similar in overall operation. For this reason, I have integrated the general operation description of both versions of ICMP in the first chapter of this part. The area where ICMPv4 and ICMPv6 most differ is in specific message types and formats, so these have been described separately in the second through fifth chapters. These chapters describe the error messages and informational messages in each version.</p><p>The final chapter describes ND, which was created specifically to assist in the operation of IPv6 and is closely related to ICMPv6.</p><p>Due to the close relationship between ICMP and IP, this part assumes that you are familiar with basic IP concepts, including IP addressing, the general format of IP datagrams, and how they are routed (covered in <a class="xref" href="pt06.html" title="Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)">Part II-3</a>). To better understand ICMPv6 details, you may also want to reference the IPv6 addressing and datagram encapsulation information (covered in <a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>).</p></div></div>
<div class="chapter" title="Chapter&#xA0;31.&#xA0;ICMP CONCEPTS AND GENERAL OPERATION"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_concepts_and_general_operation"/>Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e33181"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The Internet Control Message Protocol (<a class="indexterm" id="idx-CHP-31-1175"/>ICMP) is one of the underappreciated "worker bees" of the networking world. Everyone knows how important key protocols such as the Internet Protocol (IP) are to TCP/IP, but few realize that the suite as a whole relies on many functions that ICMP provides. Originally created to allow the reporting of a small set of error conditions, ICMP messages are now used to implement a wide range of error-reporting, feedback, and testing capabilities. While each message type is unique, they are all implemented using a common message format, sent, and then received based on relatively simple protocol rules. This makes ICMP one of the easiest TCP/IP protocols to understand. (Yes, I actually said something in this book was easy!)</p><p>In this chapter, I provide a general description of ICMP. I begin with an overview of ICMP, discussing its purpose, history, and the versions and standards that define it. I describe the general method by which ICMP operates and discuss the rules that govern how and when ICMP messages are created and processed. I then outline the common format used for ICMP messages in <a class="indexterm" id="idx-CHP-31-1176"/>versions 4 and 6 of the protocol (<a class="indexterm" id="idx-CHP-31-1177"/>ICMPv4 and ICMPv6), and how data is encapsulated in them in general terms. I conclude with a discussion of ICMP message classifications and a summary of different message types and codes for both ICMPv4 and ICMPv6.</p><div class="sect1" title="ICMP Overview, History, Versions, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_overview_history_versions_and_stand"/>ICMP Overview, History, Versions, and Standards</h1></div></div></div><p><a class="indexterm" id="idx-CHP-31-1178"/><a class="indexterm" id="idx-CHP-31-1179"/>IP is the foundation of the TCP/IP protocol suite, because it is the mechanism responsible for delivering datagrams. Three of the main characteristics that describe IP's datagram delivery method are <span class="emphasis"><em>connectionless</em></span>, <span class="emphasis"><em>unreliable</em></span>, and <span class="emphasis"><em>unacknowledged</em></span>. This means that datagrams are just sent over the internetwork with no prior connection established, no assurance they will show up, and no acknowledgment sent back to the sender that they arrived. On the surface, this seems like it would result in a protocol that is difficult to use and impossible to rely on, and thus would be a poor choice for designing a protocol suite. However, even though IP makes no guarantees, it works very well because most of the time, IP internetworks are sufficiently robust that messages get where they need to go.</p><p>Even the best-designed system still encounters problems, of course. Incorrect packets are occasionally sent, hardware devices have problems, routes are found to be invalid, and so forth. IP devices also often need to share specific information in order to guide them in their operation, and they need to perform tests and diagnostics. However, IP itself includes no provision that allows devices to exchange low-level control messages. Instead, these features are provided in the form of a companion protocol to IP called the <span class="emphasis"><em>Internet Control Message Protocol (ICMP)</em></span>.</p><p>A good analogy for the relationship between IP and ICMP is to consider the one between a high-powered executive and her experienced administrative assistant. The executive is busy and her time is very expensive. She is paid to do a specific job and to do it well, and not to spend time on administrative tasks. However, without someone doing those tasks, the executive could not do her job properly. The administrative assistant does the important support jobs that make it possible for the executive to focus on her work. The working relationship between them is very important; a good pair will work together like a cohesive team, even anticipating each other's needs.</p><p>In TCP/IP, IP is the executive, and ICMP is its administrative assistant. IP focuses on its core activities, such as addressing, datagram packaging, and routing. ICMP provides critical support to IP in the form of <span class="emphasis"><em>ICMP messages</em></span> that allow different types of communication to occur between IP devices. These messages use a common general format and are encapsulated in IP datagrams for transmission. They are divided into different categories, and each type has a specific use and internal field format.</p><p>Just as an administrative assistant often has a special location in an organization chart, and usually connects with a dotted line directly to the executive she assists, ICMP occupies a unique place in the TCP/IP protocol architecture (see <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>). Technically, you might consider ICMP to belong to layer 4, because it creates messages that are encapsulated in IP datagrams and sent using IP at layer 3. However, in the standard that first defined it, ICMP is specifically declared to be not only part of the network layer, but also, as stated in RFC 792, is "actually an integral part of IP, [that] must be implemented by every IP module." This was the initial defining standard for ICMP, titled simply "Internet Control Message Protocol." It was published at the same time as the standard for IP, which was RFC 791. This is further indication that IP and ICMP really are a team of sorts.</p><p>Due to the close relationship between the two, when the new version 6 of the Internet Protocol (IPv6) was developed in the mid-1990s, it was necessary to define a new version of ICMP as well. This was of course called the "Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification." It was first published as RFC 1885 in 1995, and revised in RFC 2463 in 1998. Just as the original IP is now often called IPv4 to differentiate it from IPv6, the original ICMP is now also called <span class="emphasis"><em>ICMPv4</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-175"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In TCP/IP, diagnostic, test, and error-reporting functions at the internetwork layer are performed by the <span class="emphasis"><em>Internet Control Message Protocol (ICMP)</em></span>, which is like IP's "administrative assistant." The original version, now called ICMPv4, is used with IPv4, and the newer ICMPv6 is used with IPv6.</p></div><p>These two RFCs, 792 and 2463, define the basic operation of ICMPv4 and ICMPv6, respectively, and also describe some of the ICMP message types supported by each version of the protocol. ICMPv4 and ICMPv6 are very similar in most respects, although they have some differences, most of which are a direct result of the changes made to IP itself. Another document, RFC 1122, "Requirements for Internet Hosts—Communication Layers," contains rules for how ICMPv4 is used, as you will see soon in the section on ICMP message creation and processing conventions later in this chapter. RFC 1812, "Requirements for IP Version 4 Routers," is also relevant.</p><p>Both versions of the protocol define a general messaging system that was designed to be expandable. This means that in addition to the messages defined in the ICMP standards themselves, other protocols may also define message types used in ICMP. Some of the more important of these are shown in <a class="xref" href="ch31.html#non-icmp_internet_standards_that_define_" title="Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages">Table 31-1</a>.</p><div class="table"><a id="non-icmp_internet_standards_that_define_"/><p class="title">Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Non-ICMP Internet Standards That Define ICMP Messages"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMP Version of Message Types Defined</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>ICMP Message Types Defined</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>950</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Internet Standard Subnetting Procedure</p></td><td style="border-bottom: 0.5pt solid ; "><p>Address Mask Request, Address Mask Reply</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMP Router Discovery Messages</p></td><td style="border-bottom: 0.5pt solid ; "><p>Router Advertisement, Router Solicitation</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1393</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Traceroute Using an IP Option</p></td><td style="border-bottom: 0.5pt solid ; "><p>Traceroute</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1812</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requirements for IP Version 4 Routers</p></td><td style="border-bottom: 0.5pt solid ; "><p>Defines three new codes (subtypes) for the Destination Unreachable message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2461</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Neighbor Discovery for IP Version 6 (IPv6)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Router Advertisement, Router Solicitation, Neighbor Advertisement, Neighbor Solicitation, Redirect</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>2894</p></td><td style="border-right: 0.5pt solid ; "><p>Router Renumbering for IPv6</p></td><td style=""><p>Router Renumbering</p></td></tr></tbody></table></div></div><p>This chapter includes a full list of the ICMPv4 and ICMPv6 message types covered in this book and the standards that define each one.</p></div></div>
<div class="sect1" title="ICMP General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_general_operation"/>ICMP General Operation</h1></div></div></div><p>ICMP is one of the simplest protocols in the TCP/IP protocol suite. Most protocols implement a particular type of functionality to either facilitate basic <a class="indexterm" id="idx-CHP-31-1180"/>operation of a part of the network stack or an application. To this end, they include many specific algorithms and tasks that define the protocol, which is where most of the complexity lies. ICMP, in contrast, is exactly what its name suggests: a protocol that defines control messages. As such, pretty much all of what ICMP is about is providing a mechanism for any IP device to send control messages to another device.</p><div class="sect2" title="The ICMP Message-Passing Service"><div class="titlepage"><div><div><h2 class="title"><a id="the_icmp_message-passing_service"/>The ICMP Message-Passing Service</h2></div></div></div><p>Various message types are defined in ICMP that allow different types of information to be exchanged. These are usually either generated for the purpose of reporting errors or for exchanging important information of different sorts that is needed to keep IP operating smoothly. ICMP itself doesn't define how all the different ICMP messages are used; this is done by the protocols that use the messages. In this manner, ICMP describes a simple message-passing service to other protocols.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-176"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMP is not like most other TCP/IP protocols in that it does not perform a specific task. It defines a mechanism by which various control messages can be transmitted and received to implement a variety of functions.</p></div><p>As mentioned in the preceding section, ICMP is considered an integral part of IP, even though it uses IP to send its messages. Typically, the operation of ICMP involves some portion of the TCP/IP protocol software on a machine detecting a condition that causes it to generate an ICMP message. This is often the IP layer itself, though it may be some other part of the software. The message is then encapsulated and transmitted like any other TCP/IP message, and is given no special treatment compared to other IP datagrams. The message is sent over the internetwork to the IP layer at the receiving device, as shown in <a class="xref" href="ch31s02.html#icmp_general_operation_a_typical_use_of_" title="Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback mechanism when an IP message is sent. In this example, Device A is trying to send an IP datagram to Device B. However, when it gets to Router R3, a problem of some sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP message back to Device A to tell it that something happened, hopefully with enough information to let Device A correct the problem, if possible. Router R3 can only send the ICMP message back to Device A, not to Router R2 or R1.">Figure 31-1</a>.</p><p>Again, since many of the ICMP messages are actually intended to convey information to a device's IP software, the IP layer itself may be the ultimate destination of an ICMP message once a recipient gets it. In other cases, the ultimate destination may be some other part of the TCP/IP protocol software, which is determined by the type of message received. ICMP does not use ports like the User Datagram Protocol (UDP) or Transmission Control Protocol (TCP) to direct its messages to different applications on a host. The software recognizes the message type and directs it accordingly within the software.</p><p>ICMP was originally designed with the idea that most messages would be sent by routers, but they can be sent by both routers and by regular hosts as well, depending on the message type. Some are obviously sent only by routers, such as Redirect messages; others may be sent by either routers or hosts. Many of the ICMP messages are used in matched pairs, especially in various kinds of Request and Reply messages, and Advertisement and Solicitation messages.</p><div class="figure"><a id="icmp_general_operation_a_typical_use_of_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e33390"/><img alt="ICMP general operation A typical use of ICMP is to provide a feedback mechanism when an IP message is sent. In this example, Device A is trying to send an IP datagram to Device B. However, when it gets to Router R3, a problem of some sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP message back to Device A to tell it that something happened, hopefully with enough information to let Device A correct the problem, if possible. Router R3 can only send the ICMP message back to Device A, not to Router R2 or R1." src="httpatomoreillycomsourcenostarchimages287959.png.jpg"/></div></div><p class="title">Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback mechanism when an IP message is sent. In this example, Device A is trying to send an IP datagram to Device B. However, when it gets to Router R3, a problem of some sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP message back to Device A to tell it that something happened, hopefully with enough information to let Device A correct the problem, if possible. Router R3 can only send the ICMP message back to Device A, not to Router R2 or R1.</p></div></div><div class="sect2" title="ICMP Error Reporting Limited to the Datagram Source"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_error_reporting_limited_to_the_data"/>ICMP Error Reporting Limited to the Datagram Source</h2></div></div></div><p>One interesting general characteristic of ICMP's <a class="indexterm" id="idx-CHP-31-1181"/>operation is that when errors are detected, they can be reported using ICMP, but only back to the original source of a datagram. This is actually a big drawback in how ICMP works. Refer back to <a class="xref" href="ch31s02.html#icmp_general_operation_a_typical_use_of_" title="Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback mechanism when an IP message is sent. In this example, Device A is trying to send an IP datagram to Device B. However, when it gets to Router R3, a problem of some sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP message back to Device A to tell it that something happened, hopefully with enough information to let Device A correct the problem, if possible. Router R3 can only send the ICMP message back to Device A, not to Router R2 or R1.">Figure 31-1</a> and consider again client Host A sending a message to server Host B, with a problem detected in the datagram by Router R3. Even if Router R3 suspects that the problem was caused by one of the preceding routers that handled the message, such as Router R2, it <span class="emphasis"><em>cannot</em></span> send a problem report to Router R2. It can send an ICMP message only back to Host A.</p><p>This limitation is an artifact of how IP works. You may recall from looking at the IP datagram format that the only address fields are for the original source and ultimate destination of the datagram. (The only exception is if the IP Record Route option is used, but devices cannot count on this.) When Router R3 receives a datagram from Router R2 that Router R2 in turn received from Router R1 (and prior to that, from Device A), it is only Device A's address in the datagram. Thus, Router R3 <span class="emphasis"><em>must</em></span> send a problem report back to Device A, and Device A must decide what to do with it. Device A may decide to change the route it uses or to generate an error report that an administrator can use to troubleshoot Router R2.</p><p>In addition to this basic limitation, several special rules and conventions have been put in place to govern the circumstances under which ICMP messages are generated, sent, and processed. I'll discuss these later in the chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-177"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMP error-reporting messages sent in response to a problem seen in an IP datagram can be sent back only to the originating device. Intermediate devices cannot be the recipients of an <a class="indexterm" id="idx-CHP-31-1182"/>ICMP message because their addresses are normally not carried in the IP datagram's header.</p></div></div></div>
<div class="sect1" title="ICMP Message Classes, Types, and Codes"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_message_classes_types_and_codes"/>ICMP Message Classes, Types, and Codes</h1></div></div></div><p><a class="indexterm" id="idx-CHP-31-1183"/><a class="indexterm" id="idx-CHP-31-1184"/>ICMP messages are used to allow the communication of different types of information between IP devices on an internetwork. The messages themselves are used for a wide variety of purposes, and they are organized into general categories as well as numerous specific types and subtypes.</p><div class="sect2" title="ICMP Message Classes"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_message_classes"/>ICMP Message Classes</h2></div></div></div><p>At the highest level, ICMP messages are divided into two classes:</p><p><span class="strong"><strong>Error Messages</strong></span> These messages are used to provide feedback to a source device about an error that has occurred. They are typically generated specifically in response to some sort of action, usually the transmission of a datagram, as shown in the example in <a class="xref" href="ch31s02.html#icmp_general_operation_a_typical_use_of_" title="Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback mechanism when an IP message is sent. In this example, Device A is trying to send an IP datagram to Device B. However, when it gets to Router R3, a problem of some sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP message back to Device A to tell it that something happened, hopefully with enough information to let Device A correct the problem, if possible. Router R3 can only send the ICMP message back to Device A, not to Router R2 or R1.">Figure 31-1</a>. Errors are usually related to the structure or content of a datagram or to problem situations on the internetwork encountered during datagram routing.</p><p><span class="strong"><strong>Informational (or Query) Messages</strong></span> These are messages that are used to let devices exchange information, implement certain IP-related features, and perform testing. They do not indicate errors and are typically not sent in response to a regular datagram transmission. They are generated either when directed by an application or on a regular basis to provide information to other devices. An informational ICMP message may also be sent in reply to another informational ICMP message, since they often occur in request/reply or solicitation/advertisement functional pairs.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-178"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMP messages are divided into two general categories: <span class="emphasis"><em>error messages</em></span> that are used to report problem conditions, and <span class="emphasis"><em>informational messages</em></span> that are used for diagnostics, testing, and other purposes.</p></div></div><div class="sect2" title="ICMP Message Types"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_message_types"/>ICMP Message Types</h2></div></div></div><p>Each individual kind of message in ICMP is given its own unique Type value, which is put into the field of that name in the ICMP common message format. This field is 8 bits wide, so a theoretical maximum of 256 message types can be defined. A separate set of Type values is maintained for each of ICMPv4 and ICMPv6.</p><p>In ICMPv4, Type values were assigned sequentially to both error and informational messages on a first-come, first-served basis (sort of), so we cannot tell just by the Type value what type of message each is. One minor improvement made in ICMPv6 was that the message types were separated. In IPv6, error messages have Type values from 0 to 127, and informational messages have values from 128 to 255. Only some of the Type values are currently defined.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-179"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A total of 256 different possible message types can be defined for each of ICMPv4 and ICMPv6. The Type field that appears in the header of each message specifies the kind of ICMP message. In ICMPv4, there is no relationship between Type value and message type. In ICMPv6, error messages have a Type value of 0 to 127, and informational messages have a Type value of 128 to 255.</p></div></div><div class="sect2" title="ICMP Message Codes"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_message_codes"/>ICMP Message Codes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-31-1185"/>The message type indicates the general purpose of each kind of ICMP message. ICMP also provides an additional level of detail within each message type in the form of a Code field, which is also 8 bits. You can consider this field as a message subtype. Thus, each message type can have up to 256 subtypes that are more detailed subdivisions of the message's overall functionality. A good example is the Destination Unreachable message, which is generated when a datagram cannot be delivered. In this message type, the Code value provides more information on exactly why the delivery was not possible.</p></div><div class="sect2" title="ICMP Message Class and Type Summary"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_message_class_and_type_summary"/>ICMP Message Class and Type Summary</h2></div></div></div><p><a class="indexterm" id="idx-CHP-31-1186"/>The next four chapters of the book describe all of the major ICMP message types for both ICMPv4 and ICMPv6. For convenience, I have summarized all these message types in <a class="xref" href="ch31s03.html#icmp_message_classes_types_and_cod-id001" title="Table 31-2. ICMP Message Classes, Types, and Codes">Table 31-2</a>, which shows each of the Type values for the messages covered in this book, the name of each message, a very brief <a class="indexterm" id="idx-CHP-31-1187"/>summary of its purpose, and the RFC that defines it. (To keep the table from being egregiously large, I have not shown each of the Code values for each Type value; these can be found in the individual message type descriptions.) The table is organized into sections that correspond to the four chapters that describe ICMP message types, except this table is sorted by ascending Type value within each category for easier reference.</p><div class="table"><a id="icmp_message_classes_types_and_cod-id001"/><p class="title">Table 31-2. ICMP Message Classes, Types, and Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMP Message Classes, Types, and Codes"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Summary Description of Message Type</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining RFC Number</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Unreachable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates that a datagram could not be delivered to its destination. The Code value provides more information on the nature of the error.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv4 Error Messages</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Source Quench</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lets a congested IP device tell a device that is sending it datagrams to slow down the rate at which it is sending them.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirect</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows a router to inform a host of a better route to use for sending datagrams.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time Exceeded</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent when a datagram has been discarded prior to delivery due to expiration of its Time to Live field.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameter Problem</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates a miscellaneous problem (specified by the Code value) in delivering a datagram.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo Reply</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent in reply to an Echo (Request) message; used for testing connectivity.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo (Request)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent by a device to test connectivity to another device on the internetwork. The word <span class="emphasis"><em>Request</em></span> sometimes appears in the message name.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Advertisement</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Used by routers to tell hosts of their existence and capabilities.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1256</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv4 Informational Messages (part 1 of 2)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Solicitation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Used by hosts to prompt any listening routers to send a Router Advertisement.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1256</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Timestamp (Request)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent by a device to request that another send it a timestamp value for propagation time calculation and clock synchronization. The word <span class="emphasis"><em>Request</em></span> sometimes appears in the message name.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Timestamp Reply</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent in response to a Timestamp (Request) to provide time calculation and clock synchronization information.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Information Request</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Originally used to request configuration information from another device. Now obsolete.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Information Reply</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Originally used to provide configuration information in response to an Information Request message. Now obsolete.</p></td><td style="border-bottom: 0.5pt solid ; "><p>792</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv4 Informational Messages (part 2 of 2)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address Mask Request</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Used to request that a device send a subnet mask.</p></td><td style="border-bottom: 0.5pt solid ; "><p>950</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address Mask Reply</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Contains a subnet mask sent in reply to an Address Mask Request.</p></td><td style="border-bottom: 0.5pt solid ; "><p>950</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Traceroute</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Used to implement the experimental enhanced traceroute utility.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1393</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Unreachable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates that a datagram could not be delivered to its destination. <span class="emphasis"><em>Code</em></span> value provides more information on the nature of the error.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv6 Error Messages</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Packet Too Big</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent when a datagram cannot be forwarded because it is too big for the maximum transmission unit (MTU) of the next hop in the route. This message is needed in IPv6 and not IPv4 because in IPv4, routers can fragment oversized messages, but in IPv6 they cannot.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time Exceeded</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent when a datagram has been discarded prior to delivery due to the Hop Limit field being reduced to zero.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameter Problem</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates a miscellaneous problem (specified by the <span class="emphasis"><em>Code</em></span> value) in delivering a datagram.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo Request</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent by a device to test connectivity to another device on the internetwork.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>129</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo Reply</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent in reply to an Echo (Request) message; used for testing connectivity.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2463</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>133</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Solicitation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prompts a router to send a Router Advertisement.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2461</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ICMPv6 Informational Messages</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>134</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Advertisement</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent by routers to tell hosts on the local network that the router exists. It also describes its capabilities.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2461</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>135</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Neighbor Solicitation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sent by a device to request the layer 2 address of another device while providing its own as well.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2461</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>136</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Neighbor Advertisement</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides information about a host to other devices on the network.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2461</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>137</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirect</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirects transmissions from a host to either an immediate neighbor on the network or a router.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2461</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>138</p></td><td style="border-right: 0.5pt solid ; "><p>Router Renumbering</p></td><td style="border-right: 0.5pt solid ; "><p>Conveys renumbering information for router renumbering.</p></td><td style=""><p>2894</p></td></tr></tbody></table></div></div><p>You can see that several of the message types are quite similar in ICMPv4 and ICMPv6, but there are some slight differences. An obvious one is that Redirect is considered an error message in ICMPv4, but it's an informational message in ICMPv6. Messages are often used differently as well. In IPv6, the use of many of the ICMP informational messages is described in the Neighbor Discovery (ND) protocol, which is new to IPv6 (see <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a>).</p><p>Note that the Information Request and Information Reply messages were originally created to allow devices to determine an IP address and possibly other configuration information. This function was later implemented using host configuration protocols such as the Reverse Address Resolution Protocol (RARP; see <a class="xref" href="ch14.html" title="Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)">Chapter 14</a>), Boot Protocol (BOOTP; see <a class="xref" href="ch60.html" title="Chapter 60. TCP/IP BOOTSTRAP PROTOCOL (BOOTP)">Chapter 60</a>), and Dynamic Host Configuration Protocol (DHCP, discussed in Chapters <a class="xref" href="ch61.html" title="Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS">Chapter 61</a> through <a class="xref" href="ch64.html" title="Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT">Chapter 64</a>). These message types are now obsolete.</p></div></div>
<div class="sect1" title="ICMP Message Creation and Processing Conventions and Rules"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_message_creation_and_processing_con"/>ICMP Message Creation and Processing Conventions and Rules</h1></div></div></div><p><a class="indexterm" id="idx-CHP-31-1188"/>In the overview of ICMP earlier in this chapter, I compared the relationship between IP and ICMP to that between an executive and an administrative assistant. One of the characteristics that many executives value in a good assistant is that the assistant does his work independently, without causing unnecessary disruption. A good assistant should save the executive time, not cost her time.</p><p>As the assistant to IP, ICMP must similarly help IP function without taking up too much of its resources. Here, the resource being conserved is not so much time as bandwidth. ICMP messages are important, but must be considered part of the overhead of running a network. They carry no user data, so each one represents a small loss of overall end-user bandwidth on the network. For this reason, we want to send them only when necessary, and to carefully control the circumstances under which they are generated.</p><p>Administrative assistants have some serious advantages over networking protocols: common sense and experience. They usually know where the line is drawn between help and hindrance; computers don't. To partially compensate, ICMP's operation is guided by a set of <span class="emphasis"><em>conventions</em></span> or <a class="indexterm" id="idx-CHP-31-1189"/><span class="emphasis"><em>rules</em></span> for how messages are created and processed. For ICMPv4, these conventions are described in part in the defining RFC 792, but much more in RFC 1122, "Requirements for Internet Hosts—Communication Layers," which provides specific information on implementing TCP/IP in host devices. In ICMPv6, the information related to ICMP implementation that appears in RFC 1122 has been largely incorporated into the main document that defines ICMPv6, RFC 2463.</p><p>Most of the issues related to message generation have to do with error messages, not informational messages. The latter class of messages usually doesn't cause problems because they are generated based on specific rules already established in the protocols that use them. For example, routers send Router Advertisement messages on a regular basis, and the routers make sure this is infrequent. They are also sent in response to Router Solicitation messages sent on occasion by hosts, and as long as a host doesn't go haywire and start sending tons of Solicitations, there won't be a problem. Even then, you can give a router enough smarts not to send Router Advertisements too often.</p><div class="sect2" title="Limitations on ICMP Message Responses"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_on_icmp_message_responses"/>Limitations on ICMP Message Responses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-31-1190"/>The problem comes up with error messages specifically because they are sent <span class="emphasis"><em>in response</em></span> to so many situations. Potentially, they may even be sent in response to each other. Without special care, loops or cascading message generation might occur. For example, consider a situation in which Device A encounters an error and sends an error report to Device B. Device B finds an error in Device A's message and sends an error report back to Device A. This could result in billions of messages being sent back and forth, thereby clogging the network, until a human figures out what is wrong and fixes it.</p><p>To prevent such problems, an ICMP error message <span class="emphasis"><em>must not</em></span> be generated in response to any of the following:</p><p><span class="strong"><strong>An ICMP Error Message</strong></span> This prevents loops of the type just mentioned. Note, however, that an ICMP error message <span class="emphasis"><em>can</em></span> be generated in response to an ICMP informational message.</p><p><span class="strong"><strong>A Broadcast or Multicast Datagram</strong></span> What would happen if a datagram were broadcast to 5,000 hosts, and each of them found an error in it and tried to send a report back to the source? Something unpleasant!</p><p><span class="strong"><strong>IP Datagram Fragments Except the First</strong></span> In many cases, the same situation that might cause a device to generate an error for one fragment would also apply to each successive one, causing unnecessary ICMP traffic. For this reason, when a datagram is fragmented, a device may send an error message only in response to a problem in the first fragment.</p><p><span class="strong"><strong>Datagrams with Non-Unicast Source Address</strong></span> If a datagram's source address doesn't define a unique, unicast device address, an error message cannot be sent back to that source. This prevents ICMP messages from being broadcast, unicast, or sent to nonroutable special addresses such as the loopback address.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-180"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In order to prevent excessive numbers of ICMP messages from being sent on a network, a special set of rules governs when and how they may be created. Most of these are designed to eliminate situations in which very large numbers of ICMP error messages would be generated in response to certain occurrences.</p></div><p>These rules apply to both ICMPv4 and ICMPv6, but in ICMPv6 there are a couple of special cases. In certain circumstances, an ICMPv6 Packet Too Big message may be sent to a multicast address, as this is required for Path MTU Discovery (described in <a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a>) to work. Certain Parameter Problem messages may also be sent to multicast or broadcast addresses. Finally, in addition to the rules just mentioned, IPv6 implementations are specifically directed to limit the rate at which they send ICMPv6 messages overall.</p></div><div class="sect2" title="ICMP Message Processing Conventions"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_message_processing_conventions"/>ICMP Message Processing Conventions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-31-1191"/>Message <a class="indexterm" id="idx-CHP-31-1192"/>processing generally takes place as described earlier in the section on ICMP general operation, with the ICMP message delivered either to the IP software or other protocol software implementation as required. What is done with the message usually depends on its type. Some messages are destined for only the IP software itself, but many are intended for the higher-layer protocol that generated the datagram that led to the error. In the next section, you will see that ICMP error messages include information that allows the upper-layer protocol to be extracted for the purpose of passing the message to the appropriate software layer.</p><p>In IPv6, the class of message (error or informational) can be determined from the Type value. This knowledge can then be used to guide processing of ICMP messages with unknown Type values. The rule is that ICMP error messages with unknown Type values must be passed to the appropriate upper-layer protocol. Informational messages with unknown Type values are discarded without taking action.</p><p>In addition to these general rules, there are specific rules put into place to guide the processing of some of the message types. I describe some of these conventions in the chapters that discuss individual ICMP messages.</p><p>An important final point is that ICMP messages, especially error messages, are not considered binding on the device that processes them. To stick with the office analogy, they have the equivalent status in an office of only of an FYI memo, not an assignment. It is often the case that a device <span class="emphasis"><em>should</em></span> take action upon processing an ICMP message, but the device is not required to. The exception, again, is when informational messages are used for specific purposes. For example, most of the messages that come in pairs are designed so that a Request results in the matching Reply and a Solicitation yields an Advertisement.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-181"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A device receiving an ICMP message is not required to take action unless a protocol using a message type dictates a specific response to a particular message type. In particular, devices are not mandated to perform any specific task when receiving an ICMP error message.</p></div></div></div>
<div class="sect1" title="ICMP Common Message Format and Data Encapsulation"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_common_message_format_and_data_enca"/>ICMP Common Message Format and Data Encapsulation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-31-1193"/>As you have seen so far in this chapter, ICMP is not so much a protocol that performs a specific function as a framework for the exchange of error reports and information. Since each of the message types is used for a different purpose, they differ in the types of information they contain. This means each ICMP message has a slightly different format. At the same time, however, ICMP message types also have a degree of commonality—a portion of each message is common between message types.</p><div class="sect2" title="ICMP Common Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_common_message_format"/>ICMP Common Message Format</h2></div></div></div><p>You can think of the structure of an ICMP message as having a <span class="emphasis"><em>common part</em></span> and a <span class="emphasis"><em>unique part</em></span>. The common part consists of three fields that have the same size and same meaning in all ICMP messages (although the values in the fields aren't the same for each ICMP message type). The unique part contains fields that are specific to each type of message.</p><p>Interestingly, the common message format is basically the same for ICMPv4 and ICMPv6. It is described in <a class="xref" href="ch31s05.html#icmp_common_message_format-id001" title="Table 31-3. ICMP Common Message Format">Table 31-3</a> and illustrated in <a class="xref" href="ch31s05.html#icmp_common_message_format_this_overall_" title="Figure 31-2. ICMP common message format This overall, generic message format is used for both ICMPv4 and ICMPv6 message types.">Figure 31-2</a>.</p><div class="table"><a id="icmp_common_message_format-id001"/><p class="title">Table 31-3. ICMP Common Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMP Common Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For ICMPv6, values from 0 to 127 are error messages, and values 128 to 255 are informational messages. Common values for this field are given in <a class="xref" href="ch31s03.html#icmp_message_classes_types_and_cod-id001" title="Table 31-2. ICMP Message Classes, Types, and Codes">Table 31-2</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of message within each ICMP message Type value. Thus, up to 256 subtypes can be defined for each message type. Values for this field are shown in the following chapters on individual ICMP message types.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field that is calculated in a manner similar to the IP header checksum in IPv4. It provides error-detection coverage for the entire ICMP message. Note that in ICMPv6, a pseudo header of IPv6 header fields is prepended for checksum calculation; this is similar to the way this is done in TCP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Message Body/Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains the specific fields used to implement each message type. This is the unique part of the message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmp_common_message_format_this_overall_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e34177"/><img alt="ICMP common message format This overall, generic message format is used for both ICMPv4 and ICMPv6 message types." src="httpatomoreillycomsourcenostarchimages287961.png.jpg"/></div></div><p class="title">Figure 31-2. ICMP common message format This overall, generic message format is used for both ICMPv4 and ICMPv6 message types.</p></div></div><div class="sect2" title="Original Datagram Inclusion in ICMP Error Messages"><div class="titlepage"><div><div><h2 class="title"><a id="original_datagram_inclusion_in_icmp_erro"/>Original Datagram Inclusion in ICMP Error Messages</h2></div></div></div><p>The message body typically contains one or several fields that carry information of relevance to each specific type of ICMP message. All ICMP error messages include a portion of the original IP datagram that led to the ICMP error message. This aids in diagnosing the problem that caused the ICMP message to be generated, by allowing the error to be communicated to higher layers.</p><p>The inclusion of original IP datagram information is done differently for the two ICMP versions:</p><p><span class="strong"><strong>ICMPv4 Error Messages</strong></span> Each error message includes the full IP header and the first 8 bytes of the payload. Since the beginning of the payload will contain the encapsulated higher-layer header, the ICMP message also carries either the full UDP header or the first 8 bytes of the TCP header. In both cases, the source and destination port numbers are part of what is included. If the original header was a standard IP header with no options, the Message Body will therefore have a length of 28 bytes; if options are present, it will be larger.</p><p><span class="strong"><strong>ICMPv6 Error Messages</strong></span> Each error message includes as much of the IPv6 datagram as will fit without causing the size of the ICMPv6 error message (including its IP header encapsulation) to exceed the minimum IPv6 maximum transmission unit size, which is 1280 bytes. This provides additional information for diagnostic purposes when compared to ICMPv4, while ensuring that no ICMPv6 error messages will be too large for any physical network segment. The larger size of the included data allows the IPv6 extension headers to be included in the error message, since the error could be in one of those extension headers.</p><div class="note" title="Note"><h3 class="title"><a id="note-97"/>Note</h3><p><span class="emphasis"><em>Remember that in IPv6, routers cannot fragment IP datagrams; any datagram that is oversized for an underlying physical network is dropped. ICMPv6 is thus designed to ensure that this does not happen by not creating ICMPv6 datagrams over the universal IPv6 MTU size of 1280</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-182"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each kind of ICMP message contains data unique to that message type, but all messages are structured according to a <a class="indexterm" id="idx-CHP-31-1194"/>common ICMP message format. ICMP error messages always include in their message body field some portion of the original IP datagram that resulted in the error being generated.</p></div></div><div class="sect2" title="ICMP Data Encapsulation"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_data_encapsulation"/>ICMP Data Encapsulation</h2></div></div></div><p>After an ICMP message is formatted, it is encapsulated in an IP datagram like any other IP message. This is why some people believe ICMP is architecturally a higher layer than IP, though as I discussed earlier, it is really more of a special case. You can also see that when an ICMP error message is generated, we end up with the original IP header and part or all of the payload, encapsulated in the ICMP message, which in turn is encapsulated within a new IP header that will be sent back as an error report, usually to the device that sent the original IP message.</p></div></div>
<div class="chapter" title="Chapter&#xA0;32.&#xA0;ICMPV4 ERROR MESSAGE TYPES AND FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_error_message_types_and_formats"/>Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e34225"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Routers and hosts use Internet Control Message Protocol (ICMP) <a class="indexterm" id="idx-CHP-32-1195"/>error messages to tell a device that sent a datagram about problems that were encountered during delivery. The original ICMP version 4 (ICMPv4) defined five different error messages, which are all described in the original ICMP standard, RFC 792. These are some of the most important ICMP messages. They provide critical feedback about error conditions and may help a transmitting device take corrective action to ensure reliable and efficient datagram delivery.</p><p>In this first of four chapters on specific ICMP types, I look at the ICMPv4 error messages. I begin with Destination Unreachable messages, which are sent due to datagram delivery failures, and Source Quench messages, which are used to tell a device to slow down the rate at which it sends datagrams. Next, I describe Time Exceeded messages, which are sent when a datagram has been traveling the network too long or takes too long to be reassembled from fragments, and Redirect messages, which let a router provide feedback about better routes to a host. Finally, I discuss Parameter Problem messages, which are generic messages used for problems not covered by other ICMP error messages.</p><div class="sect1" title="ICMPv4 Destination Unreachable Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_destination_unreachable_messages"/>ICMPv4 Destination Unreachable Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-32-1196"/>Since the Internet Protocol (IP) is an unreliable protocol, there are no guarantees that a datagram sent by one device to another will ever actually get there. The internetwork of hosts and routers will make a best effort to deliver the datagram, but it may not get where it needs to for any number of reasons. Devices on an IP network understand that and are designed accordingly. IP software never assumes its datagrams will always be received, and higher-layer protocols like the Transmission Control Protocol (TCP) take care of providing reliability and acknowledgments of received data for applications that need these features.</p><p>This setup, with higher layers handling failed deliveries, is sufficient in some cases. For example, suppose Device A tries to send to Device B, but a router near Device B is overloaded, so it drops the datagram. In this case, the problem is likely intermittent, so Device A can retransmit and eventually reach Device B. But what about a situation where a device is trying to send to an IP address that doesn't exist, or a problem with routing that isn't easily corrected? Having the source just continually retry in this case would be inefficient, to say the least.</p><p>IP is designed to allow IP datagram deliveries to fail, and we should take any such failures seriously. What we really need is a feedback mechanism that can tell a source device that something improper is happening and why. In IP version 4 (IPv4), this service is provided through the transmission of <a class="indexterm" id="idx-CHP-32-1197"/><span class="emphasis"><em>Destination Unreachable</em></span> ICMP messages. When a source node receives one of these messages, it knows there was a problem sending a datagram, and can then decide what action, if any, it wants to take. Like all ICMP error messages, Destination Unreachable messages include a portion of the datagram that could not be delivered, which helps the recipient of the error figure out what the problem is.</p><div class="sect2" title="ICMPv4 Destination Unreachable Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_destination_unreachable_message_f"/>ICMPv4 Destination Unreachable Message Format</h2></div></div></div><p><a class="xref" href="ch32.html#icmpv_destination_unreachable_message_fo" title="Table 32-1. ICMPv4 Destination Unreachable Message Format">Table 32-1</a> and <a class="xref" href="ch32.html#icmpv4_destination_unreachable_mes-id001" title="Figure 32-1. ICMPv4 Destination Unreachable message format">Figure 32-1</a> show the specific format for ICMPv4 Destination Unreachable messages.</p><div class="table"><a id="icmpv_destination_unreachable_message_fo"/><p class="title">Table 32-1. ICMPv4 Destination Unreachable Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Destination Unreachable Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; for Destination Unreachable messages, this is set to 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of unreachable error being communicated. See <a class="xref" href="ch34.html#icmpv_destination_unreachable_mess-id002" title="Table 34-2. ICMPv6 Destination Unreachable Message Subtypes">Table 34-2</a> for a full list of codes and what they mean.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes that are left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The full IP header and the first 8 bytes of the payload of the datagram that prompted this error message to be sent.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_destination_unreachable_mes-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e34349"/><img alt="ICMPv4 Destination Unreachable message format" src="httpatomoreillycomsourcenostarchimages287963.png"/></div></div><p class="title">Figure 32-1. ICMPv4 Destination Unreachable message format</p></div></div><div class="sect2" title="ICMPv4 Destination Unreachable Message Subtypes"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_destination_unreachable_message_s"/>ICMPv4 Destination Unreachable Message Subtypes</h2></div></div></div><p>There are many different reasons why it may not be possible for a datagram to reach its destination. Some of these may be due to erroneous parameters (like the invalid IP address example mentioned earlier). A router might have a problem reaching a particular network for whatever reason. There can also be other more esoteric reasons related to why a datagram cannot be delivered.</p><p>For this reason, the ICMPv4 <a class="indexterm" id="idx-CHP-32-1198"/>Destination Unreachable message type can be considered as a class of related error messages. The receipt of a Destination Unreachable message tells a device that the datagram it sent couldn't be delivered, and the Code field in the ICMP header indicates the reason for the nondelivery. <a class="xref" href="ch32.html#icmpv_destination_unreachable_message_su" title="Table 32-2. ICMPv4 Destination Unreachable Message Subtypes">Table 32-2</a> shows the different Code values, corresponding message subtypes, and a brief explanation of each.</p><div class="table"><a id="icmpv_destination_unreachable_message_su"/><p class="title">Table 32-2. ICMPv4 Destination Unreachable Message Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Destination Unreachable Message Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Subtype</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1199"/>Network Unreachable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The datagram could not be delivered to the network specified in the network ID portion of the IP address. This usually means a problem with routing but could also be caused by a bad address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1200"/>Host Unreachable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The datagram was delivered to the network specified in the network ID portion of the IP address but could not be sent to the specific host indicated in the address. Again, this usually implies a routing issue.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Protocol Unreachable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The protocol specified in the Protocol field was invalid for the host to which the datagram was delivered.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1201"/>Port Unreachable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The destination port specified in the UDP or TCP header was invalid.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1202"/>Fragmentation Needed and DF Set</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is one of those esoteric codes. Normally, an IPv4 router will automatically fragment a datagram that it receives if it is too large for the maximum transmission unit (MTU) of the next physical network link the datagram needs to traverse. However, if the DF (Don't Fragment) flag is set in the IP header, this means the sender of the datagram does not <span class="emphasis"><em>want</em></span> the datagram ever to be fragmented. This puts the router between the proverbial rock and a hard place, and it will be forced to drop the datagram and send an error message with this code. This message type is most often used in a clever way by intentionally sending messages of increasing size to discover the MTU size that a link can handle. This process is called Path MTU Discovery (described in <a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1203"/>Source Route Failed</p></td><td style="border-bottom: 0.5pt solid ; "><p>Generated if a source route was specified for the datagram in an option but a router could not forward the datagram to the next step in the route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1204"/>Destination Network Unknown</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; code 0 is used instead.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1205"/>Destination Host Unknown</p></td><td style="border-bottom: 0.5pt solid ; "><p>The host specified is not known. This is usually generated by a router local to the destination host and usually means a bad address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1206"/>Source Host Isolated</p></td><td style="border-bottom: 0.5pt solid ; "><p>Obsolete, no longer used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1207"/>Communication with Destination Network Is Administratively Prohibited</p></td><td style="border-bottom: 0.5pt solid ; "><p>The source device is not allowed to send to the network where the destination device is located.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1208"/>Communication with Destination Host Is Administratively Prohibited</p></td><td style="border-bottom: 0.5pt solid ; "><p>The source device is allowed to send to the network where the destination device is located, but not that particular device.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1209"/>Destination Network Unreachable for Type of Service</p></td><td style="border-bottom: 0.5pt solid ; "><p>The network specified in the IP address cannot be reached due to the inability to provide service specified in the Type of Service field of the datagram header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1210"/>Destination Host Unreachable for Type of Service</p></td><td style="border-bottom: 0.5pt solid ; "><p>The destination host specified in the IP address cannot be reached due to the inability to provide service specified in the datagram's Type of Service field.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Communication Administratively Prohibited</p></td><td style="border-bottom: 0.5pt solid ; "><p>The datagram could not be forwarded due to filtering that blocks the message based on its contents.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1211"/>Host Precedence Violation</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent by a first-hop router (the first router to handle a sent datagram) when the Precedence value in the Type of Service field is not permitted.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-32-1212"/>Precedence Cutoff in Effect</p></td><td style=""><p>Sent by a router when receiving a datagram whose Precedence value (priority) is lower than the minimum allowed for the network at that time.</p></td></tr></tbody></table></div></div><p>As you can see in <a class="xref" href="ch32.html#icmpv_destination_unreachable_message_su" title="Table 32-2. ICMPv4 Destination Unreachable Message Subtypes">Table 32-2</a>, not all of these codes are actively used at this time. For example, code 8 is obsolete and code 0 is used instead of 6. Also, some of the higher numbers related to the Type of Service field aren't actively used because Type of Service isn't actively used.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-183"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv4 <span class="emphasis"><em>Destination Unreachable</em></span> messages are used to inform a sending device of a failure to deliver an IP datagram. The message's Code field provides information about the nature of the delivery problem.</p></div></div><div class="sect2" title="Interpretation of Destination Unreachable Messages"><div class="titlepage"><div><div><h2 class="title"><a id="interpretation_of_destination_unreachabl"/>Interpretation of Destination Unreachable Messages</h2></div></div></div><p>It's important to remember that just as IP is a best effort, the reporting of unreachable destinations using ICMP is also a best effort. Realize that these ICMP messages are themselves carried in IP datagrams. More than that, however, remember that there may be problems that prevent a router from detecting failure of delivery of an ICMP message, such as a low-level hardware problem. A router could, theoretically, also be precluded from sending an ICMP message even when failure of delivery <span class="emphasis"><em>is</em></span> detected for whatever reason.</p><p>For this reason, the sending of Destination Unreachable messages should be considered supplemental. There is no guarantee that every problem sending a datagram will result in a corresponding ICMP message. No device should count on receiving an ICMP Destination Unreachable for a failed delivery any more than it counts on the delivery in the first place. This is why the higher-layer mechanisms mentioned at the start of this discussion are still important.</p></div></div></div>
<div class="sect1" title="ICMPv4 Source Quench Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_source_quench_messages"/>ICMPv4 Source Quench Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-32-1213"/>When a source device sends out a datagram, it will travel across the internetwork and eventually arrive at its intended destination (at least, that's what we hope will happen). At that point, it is up to the destination device to process the datagram by examining it and determining which higher-layer software process to hand the datagram.</p><p>If a destination device is receiving datagrams at a relatively slow rate, it may be able to process each datagram on the fly as it is received. However, datagram receipt in a typical internetwork can tend to be uneven or bursty, with alternating higher and lower rates of traffic. To allow for times when datagrams are arriving faster than they can be processed, each device has a <span class="emphasis"><em>buffer</em></span> where it can temporarily hold datagrams it has received until it has a chance to deal with them.</p><p>However, this buffer is itself limited in size. Assuming the device has been properly designed, the buffer may be sufficient to smooth out high-traffic and low-traffic periods most of the time. Certain situations can still arise in which traffic is received so rapidly that the buffer fills up entirely. Some examples of scenarios in which this might happen include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A single destination is overwhelmed by datagrams from many sources, such as a popular website being swamped by HTTP requests.</p></li><li class="listitem"><p>Device A and Device B are exchanging information, but Device A is a much faster computer than Device B, and can generate outgoing and process incoming datagrams much faster than Device B can.</p></li><li class="listitem"><p>A router receives a large number of datagrams over a high-speed link that it needs to forward over a low-speed link; they start to pile up while waiting to be sent over the slow link.</p></li><li class="listitem"><p>A hardware failure or other situation causes datagrams to sit at a device unprocessed.</p></li></ul></div><p>A device that continues to receive datagrams when it has no more buffer space is forced to discard them and is said to be <span class="emphasis"><em>congested</em></span>. A source that has its datagram discarded due to congestion won't have any way of knowing this, since IP itself is unreliable and unacknowledged. Therefore, while it is possible to simply allow higher-layer protocols to detect the dropped datagrams and generate replacements, it makes a lot more sense to have the congested device provide feedback to the sources by telling them that it is overloaded.</p><p>In IPv4, a device that is forced to drop datagrams due to congestion provides feedback to the sources that overwhelmed it by sending them ICMPv4 <a class="indexterm" id="idx-CHP-32-1214"/><span class="emphasis"><em>Source Quench</em></span> messages. Just as you use water to quench a fire, a <a class="indexterm" id="idx-CHP-32-1215"/>Source Quench message is a signal that attempts to quench a source device that is sending too fast. In other words, it's a polite way for one IP device to tell another, "Slow down!" When a device receives one of these messages, it knows it needs to reduce the speed at which it is sending datagrams to the device that sent it.</p><div class="sect2" title="ICMPv4 Source Quench Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_source_quench_message_format"/>ICMPv4 Source Quench Message Format</h2></div></div></div><p><a class="xref" href="ch32s02.html#icmpv_source_quench_message_format" title="Table 32-3. ICMPv4 Source Quench Message Format">Table 32-3</a> and <a class="xref" href="ch32s02.html#icmpv4_source_quench_message_forma-id001" title="Figure 32-2. ICMPv4 Source Quench message format">Figure 32-2</a> show the specific format for ICMPv4 <a class="indexterm" id="idx-CHP-32-1216"/>Source Quench messages.</p><div class="table"><a id="icmpv_source_quench_message_format"/><p class="title">Table 32-3. ICMPv4 Source Quench Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Source Quench Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; for Source Quench messages, this is set to 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of error being communicated. For Source Quench messages, this is not used, and the field is set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes that are left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The full IP header and the first 8 bytes of the payload of the datagram that was dropped due to congestion.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_source_quench_message_forma-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e34761"/><img alt="ICMPv4 Source Quench message format" src="httpatomoreillycomsourcenostarchimages287965.png"/></div></div><p class="title">Figure 32-2. ICMPv4 Source Quench message format</p></div></div><div class="sect2" title="Problems with Source Quench Messages"><div class="titlepage"><div><div><h2 class="title"><a id="problems_with_source_quench_messages"/>Problems with Source Quench Messages</h2></div></div></div><p>What's interesting about the Source Quench format is that it is basically a null message. It tells the source that the destination is congested but provides no specific information about that situation, nor does it specify what exactly the destination wants the source to do other than cut back on its transmission rate in some way. There is also no method for the destination to signal a source that it is no longer congested, and that the source should resume its prior sending rate. This means the response to a Source Quench message is left up to the device that receives it. Usually, a device will cut back its transmission rate until it no longer receives the messages, and then it may try to slowly increase the rate again.</p><p>In a similar manner, there are no rules about when and how a device generates Source Quench messages in the first place. A common convention is that one message is generated for each dropped datagram. However, more intelligent algorithms may be employed, especially on higher-end <a class="indexterm" id="idx-CHP-32-1217"/>routers, to predict when the device's buffer will be filled and preemptively quench certain sources that are sending too quickly. Devices may also decide whether to quench all sources when they become busy, or only certain ones. As with other ICMP error messages, a device cannot count on a Source Quench message being sent when a busy device discards one of its datagrams.</p><p>The lack of information communicated in Source Quench messages makes them a rather crude tool for managing congestion. In general terms, the process of regulating the sending of messages between two devices is called <span class="emphasis"><em>flow control</em></span>, and this is usually a function of the transport layer. TCP actually has a flow control mechanism (discussed in <a class="xref" href="ch49.html" title="Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES">Chapter 49</a>) that is far superior to the use of ICMP Source Quench messages.</p><p>Another issue with Source Quench messages is that they can be abused. Transmission of these messages by a malicious user can cause a host to be slowed down when there is no valid reason. This security issue, combined with the superiority of the TCP method for flow control, has caused the use of Source Quench messages to largely fall out of favor.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-184"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <a class="indexterm" id="idx-CHP-32-1218"/>ICMPv4 <span class="emphasis"><em>Source Quench</em></span> messages are sent by a device to request that another reduce the rate at which it is sending datagrams. The messages are a rather crude method of flow control compared to more capable mechanisms such as those provided by TCP.</p></div></div></div>
<div class="sect1" title="ICMPv4 Time Exceeded Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_time_exceeded_messages"/>ICMPv4 Time Exceeded Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-32-1219"/>Large IP internetworks can have thousands of interconnected routers that pass datagrams between devices on various networks. In large internetworks, the topology of connections between routes can become complex, which makes routing more difficult. Routing protocols will normally allow routers to find the best routes between networks, but in some situations, an inefficient route might be selected for a datagram. In the worst case, a <span class="emphasis"><em>router loop</em></span> may occur. An example of this situation is where Router A thinks datagrams intended for Network X should next go to Router B, which thinks they should go to Router C, which thinks they need to go to Router A. (See the ICMPv6 Time Exceeded Message description in <a class="xref" href="ch34.html" title="Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS">Chapter 34</a> for an illustration of a router loop.)</p><p>If a loop like this occurred, datagrams for Network X that were entering this part of the internetwork would circle forever, chewing up bandwidth and eventually leading to the network being unusable. As insurance against this occurrence, each IP datagram includes in its header a Time to Live (TTL) field. This field was originally intended to limit the maximum time (in seconds) that a datagram could be on the internetwork, but now limits the life of a datagram by limiting the number of times the datagram can be passed from one device to the next. The TTL is set to a value by the source that represents the maximum number of hops it wants for the datagram. Each router decrements the value; if it ever reaches zero, the datagram is said to have <span class="emphasis"><em>expired</em></span> and is discarded.</p><p>When a datagram is dropped due to expiration of the TTL field, the device that dropped the datagram will inform the source of this occurrence by sending it an ICMPv4 <a class="indexterm" id="idx-CHP-32-1220"/><span class="emphasis"><em>Time Exceeded</em></span> message, as shown in <a class="xref" href="ch32s03.html#expiration_of_an_ip_datagram_and_time_ex" title="Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation In this example, Device A sends an IP datagram to Device B, which has a Time to Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven hops away). On the fourth, hop the datagram reaches Router R4, which decrements its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP Time Exceeded message back to Device A.">Figure 32-3</a>. Receipt of this message indicates to the original sending device that there is a routing problem when sending to that particular destination, or that it set the TTL field value too low in the first place. As with all ICMP messages, the device receiving it must decide whether and how to respond to receipt of the message. For example, it may first try to resend the datagram with a higher TTL value.</p><div class="figure"><a id="expiration_of_an_ip_datagram_and_time_ex"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e34839"/><img alt="Expiration of an IP datagram and Time Exceeded message generation In this example, Device A sends an IP datagram to Device B, which has a Time to Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven hops away). On the fourth, hop the datagram reaches Router R4, which decrements its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP Time Exceeded message back to Device A." src="httpatomoreillycomsourcenostarchimages287967.png.jpg"/></div></div><p class="title">Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation In this example, Device A sends an IP datagram to Device B, which has a Time to Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven hops away). On the fourth, hop the datagram reaches Router R4, which decrements its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP Time Exceeded message back to Device A.</p></div><p><a class="indexterm" id="idx-CHP-32-1221"/>There is another time expiration situation where ICMP Time Exceeded messages are used. When an IP message is broken into fragments, the destination device is charged with reassembling them into the original message. One or more fragments may not make it to the destination, so to prevent the device from waiting forever, it sets a timer when the first fragment arrives. If this timer expires before the others are received, the device gives up on this message. The fragments are discarded, and a Time Exceeded message is generated.</p><div class="sect2" title="ICMPv4 Time Exceeded Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_time_exceeded_message_format"/>ICMPv4 Time Exceeded Message Format</h2></div></div></div><p><a class="xref" href="ch32s03.html#icmpv_time_exceeded_message_format" title="Table 32-4. ICMPv4 Time Exceeded Message Format">Table 32-4</a> and <a class="xref" href="ch32s03.html#icmpv4_time_exceeded_message_forma-id001" title="Figure 32-4. ICMPv4 Time Exceeded message format">Figure 32-4</a> show the specific format for ICMPv4 Time Exceeded messages.</p><div class="table"><a id="icmpv_time_exceeded_message_format"/><p class="title">Table 32-4. ICMPv4 Time Exceeded Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Time Exceeded Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; for <a class="indexterm" id="idx-CHP-32-1222"/>Time Exceeded messages, this is set to 11.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of error being communicated. A value of 0 indicates expiration of the IP TTL field; a value of 1 indicates that the fragment reassembly time has been exceeded.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes that are left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The full IP header and the first 8 bytes of the payload of the datagram that was dropped due to expiration of the TTL field or reassembly timer.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_time_exceeded_message_forma-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e34939"/><img alt="ICMPv4 Time Exceeded message format" src="httpatomoreillycomsourcenostarchimages287969.png"/></div></div><p class="title">Figure 32-4. ICMPv4 Time Exceeded message format</p></div></div><div class="sect2" title="Applications of Time Exceeded Messages"><div class="titlepage"><div><div><h2 class="title"><a id="applications_of_time_exceeded_messages"/>Applications of Time Exceeded Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-32-1223"/><a class="indexterm" id="idx-CHP-32-1224"/>ICMP Time Exceeded messages are usually sent in response to the two conditions described in <a class="xref" href="ch32s03.html#icmpv_time_exceeded_message_format" title="Table 32-4. ICMPv4 Time Exceeded Message Format">Table 32-4</a>: TTL or reassembly timer expiration. Generally, routers generate TTL expiration messages as they try to route a datagram, while end hosts indicate reassembly violations. However, there is actually a very clever application of these messages that has nothing to do with reporting errors at all.</p><p>The TCP/IP <span class="emphasis"><em>traceroute</em></span> (or <span class="emphasis"><em>tracert</em></span>) utility is used to show the sequence of devices over which a datagram is passed on a particular route between a source and destination. The traceroute utility also shows the amount of time it takes for a datagram to reach each hop in that route. This utility was originally implemented using Time Exceeded messages by sending datagrams with successively higher TTL values.</p><p>First, a dummy datagram is sent with a TTL value of 1, causing the first hop in the route to discard the datagram and send back an ICMP Time Exceeded message; the time elapsed for this could then be measured. Then, a second datagram is sent with a TTL value of 2. This causes the second device in the route to report back a Time Exceeded message, and so on. By continuing to increase the TTL value you can get reports back from each hop in the route. See <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a> for more details on traceroute's operation.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-185"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <a class="indexterm" id="idx-CHP-32-1225"/>ICMPv4 <span class="emphasis"><em>Time Exceeded</em></span> messages are sent in two different time-related circumstances. The first is if a datagram's Time to Live (TTL) field is reduced to zero, causing it to expire and the datagram to be dropped. The second is when all the pieces of a fragmented message are not received before the expiration of the recipient's reassembly timer.</p></div></div></div>
<div class="sect1" title="ICMPv4 Redirect Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_redirect_messages"/>ICMPv4 Redirect Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-32-1226"/>Every device on an internetwork needs to be able to send to every other device. If hosts were responsible for determining the routes to each possible destination, each host would need to maintain an extensive set of routing information. Since there are so many hosts on an internetwork, this would be a very time-consuming and maintenance-intensive situation.</p><p>Instead, IP internetworks are designed around a fundamental design decision: Routers are responsible for determining routes and maintaining routing information. Hosts determine only when they need a datagram routed, and then hand the datagram off to a local router to be sent where it needs to go. I discuss this in more detail in my overview of IP routing concepts (see <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>).</p><p>Since most hosts do not maintain routing information, they must rely on routers to know about routes and where to send datagrams intended for different destinations. Typically, a host on an IP network will start out with a routing table that basically tells it to send everything not on the local network to a single <a class="indexterm" id="idx-CHP-32-1227"/><span class="emphasis"><em>default router</em></span>, which will then figure out what to do with it. Obviously, if there is only one router on the network, the host will use that as the <a class="indexterm" id="idx-CHP-32-1228"/>default router for all nonlocal traffic. However, if there are two or more routers, sending all datagrams to just one router may not make sense. It is possible that a host could be manually configured to know which router to use for which destinations, but another mechanism in IP can allow a host to learn this automatically.</p><p>Consider a Network N1 that contains a number of hosts (H1, H2, and so on) and two routers, R1 and R2. Host H1 has been configured to send all datagrams to Router R1, as its default router. Suppose it wants to send a datagram to a device on Network N2. However, Network N2 is most directly connected to Network N1 using Router R2, not R1. The datagram will first be sent to Router R1, which will look in its routing table and see that datagrams for Network N2 need to be sent through Router R2. "But wait," R1 says. "R2 is on the local network, and H1 is on the local network—so why am I needed as a middleman? H1 should just send datagrams for N2 directly to R2 and leave me out of it."</p><p>In this situation, Router R1 will send an ICMPv4 <span class="emphasis"><em>Redirect</em></span> message back to Host H1, telling it that in the future, it should send this type of datagram directly to Router R2. This situation is shown in <a class="xref" href="ch32s04.html#host_redirection_using_an_icmp_redirect_" title="Figure 32-5. Host redirection using an ICMP Redirect message In this example, Host H1 sends to Router R1 a datagram destined for Network N2. However, Router R1 notices that Router R2 is on the same network and is a more direct route to Network N2. It forwards the datagram on to Router R2, but also sends an ICMP Redirect message back to Host H1 to tell it to use Router R2 next time.">Figure 32-5</a>. Router R1 will also forward the datagram to Router R2 for delivery, since there is no reason to drop the datagram. Thus, despite usually being grouped along with true ICMP error messages, Redirect messages are really arguably not error messages at all. They represent a situation in which only inefficiency exists, not outright error. (In fact, in ICMPv6, they have been reclassified.)</p><div class="sect2" title="ICMPv4 Redirect Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_redirect_message_format"/>ICMPv4 Redirect Message Format</h2></div></div></div><p><a class="xref" href="ch32s04.html#icmpv_redirect_message_format" title="Table 32-5. ICMPv4 Redirect Message Format">Table 32-5</a> and <a class="xref" href="ch32s04.html#icmpv4_redirect_message_format-id001" title="Figure 32-6. ICMPv4 Redirect message format">Figure 32-6</a> show the specific format for ICMPv4 Redirect messages.</p><div class="figure"><a id="host_redirection_using_an_icmp_redirect_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e35039"/><img alt="Host redirection using an ICMP Redirect message In this example, Host H1 sends to Router R1 a datagram destined for Network N2. However, Router R1 notices that Router R2 is on the same network and is a more direct route to Network N2. It forwards the datagram on to Router R2, but also sends an ICMP Redirect message back to Host H1 to tell it to use Router R2 next time." src="httpatomoreillycomsourcenostarchimages287971.png.jpg"/></div></div><p class="title">Figure 32-5. Host redirection using an ICMP Redirect message In this example, Host H1 sends to Router R1 a datagram destined for Network N2. However, Router R1 notices that Router R2 is on the same network and is a more direct route to Network N2. It forwards the datagram on to Router R2, but also sends an ICMP Redirect message back to Host H1 to tell it to use Router R2 next time.</p></div><div class="table"><a id="icmpv_redirect_message_format"/><p class="title">Table 32-5. ICMPv4 Redirect Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Redirect Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; for <a class="indexterm" id="idx-CHP-32-1229"/>Redirect messages, this value is 5.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the meaning or scope of the <a class="indexterm" id="idx-CHP-32-1230"/>Redirect message. See <a class="xref" href="ch32s04.html#icmp_redirect_message_interpretation_cod" title="Table 32-6. ICMP Redirect Message Interpretation Codes">Table 32-6</a> for an explanation of how this field is used in Redirect messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Internet Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of the router to which future datagrams sent to the original destination should be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The full IP header and the first 8 bytes of the payload of the datagram that led to the creation of the Redirect.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_redirect_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e35136"/><img alt="ICMPv4 Redirect message format" src="httpatomoreillycomsourcenostarchimages287973.png.jpg"/></div></div><p class="title">Figure 32-6. ICMPv4 Redirect message format</p></div></div><div class="sect2" title="Redirect Message Interpretation Codes"><div class="titlepage"><div><div><h2 class="title"><a id="redirect_message_interpretation_codes"/>Redirect Message Interpretation Codes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-32-1231"/>When a Redirect message is received back by a device, it inspects the included portion of the original datagram. Since this contains the original destination address of the redirected target device, this tells the original sender which addresses should be redirected in the future. The Internet Address field tells it which router it should use for subsequent datagrams. The Code field tells the sender how broadly to interpret the redirection. There are four different Code values, as shown in <a class="xref" href="ch32s04.html#icmp_redirect_message_interpretation_cod" title="Table 32-6. ICMP Redirect Message Interpretation Codes">Table 32-6</a>.</p><div class="table"><a id="icmp_redirect_message_interpretation_cod"/><p class="title">Table 32-6. ICMP Redirect Message Interpretation Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMP Redirect Message Interpretation Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Subtype</p></th><th style="border-bottom: 0.5pt solid ; "><p>Meaning</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirect Datagrams for the Network (or Subnet)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Redirect all future datagrams sent not only to the device whose address caused this Redirect, but also to all other devices on the network (or subnet) where that device is located. (This code is now obsolete; see the note that follows this table.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirect Datagrams for the Host</p></td><td style="border-bottom: 0.5pt solid ; "><p>Redirect all future datagrams only for the address of the specific device to which the original datagram was sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirect Datagrams for the Type of Service (TOS) and Network (or Subnet)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as for Code value 0, but only for future datagrams that have the same TOS value as the original datagram. (This code is now obsolete; see the note that follows this table.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; "><p>Redirect Datagrams for the TOS and Host</p></td><td style=""><p>As for Code value 1, but only for future datagrams that have the same TOS value as the original datagram.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-98"/>Note</h3><p><span class="emphasis"><em>One problem with</em></span> Redirects <span class="emphasis"><em>for whole networks is that the network specification may be ambiguous in an environment where subnetting or classless addressing is used. For this reason, the use of Code values 0 and 2 was prohibited by RFC 1812; the values are considered obsolete on the modern Internet</em></span>.</p></div><p>Obviously, routers usually generate Redirect messages and send them to hosts; hosts do not normally create them. The specific rules for when Redirect messages are created can be fairly complex, as a number of conditions may exist that preclude these messages from being sent. In particular, special rules exist for when a router may redirect an entire network (or subnet) instead of just a single host. Also, remember that the TOS field is optional and often not used, so Redirects with Code values of 2 or 3 are less common than those with values of 0 and 1.</p></div><div class="sect2" title="Limitations of Redirect Messages"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_of_redirect_messages"/>Limitations of Redirect Messages</h2></div></div></div><p>Keep in mind that ICMP Redirect messages are <span class="emphasis"><em>not</em></span> a mechanism by which the general routing process in IP is implemented; they are only a support function. They are a convenient way for hosts to be given information about routes by local routers, but are not used to communicate route information between routers.</p><p>This means that a Redirect message can tell a host to use a more efficient first-hop router, but cannot tell a router to use a more efficient second-hop router. In the previous example (illustrated in <a class="xref" href="ch32s04.html#host_redirection_using_an_icmp_redirect_" title="Figure 32-5. Host redirection using an ICMP Redirect message In this example, Host H1 sends to Router R1 a datagram destined for Network N2. However, Router R1 notices that Router R2 is on the same network and is a more direct route to Network N2. It forwards the datagram on to Router R2, but also sends an ICMP Redirect message back to Host H1 to tell it to use Router R2 next time.">Figure 32-5</a>), suppose that in addition to the connections mentioned, Router R2 is connected to Router R3 and Router R4. Router R2 sends the datagram in question to Router R3, which realizes it needs to send to Router R4, a router already directly connected to Router R2. Router R3 <span class="emphasis"><em>cannot</em></span> send a Redirect message to Router R2 telling it to use Router R4 next time. The messages are simply not designed for this purpose—remember that ICMP messages always go back to the source of the original datagram, which would not be Router R2 in this case. Such inefficiencies must be resolved using routing protocols.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-186"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A router uses <a class="indexterm" id="idx-CHP-32-1232"/>ICMPv4 <span class="emphasis"><em>Redirect</em></span> messages to inform a host of a preferred router that will be used for future datagrams that are sent to a particular host or network. They are not used to alter routes between routers.</p></div></div></div>
<div class="sect1" title="ICMPv4 Parameter Problem Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_parameter_problem_messages"/>ICMPv4 Parameter Problem Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-32-1233"/>The previous sections in this chapter describe four specific ICMPv4 message types that allow a device to report various error conditions to the original sender of a datagram. However, other error situations may arise that don't correspond to any of these four specific message types. Typically, the problem results when a device attempts to process the header fields of an IP datagram and finds something in it that doesn't make sense.</p><p>If a device finds a problem with any of the parameters in an IP datagram header that is serious enough that it cannot complete processing the header, it must discard the datagram. As in other cases where a datagram must be tossed out, this is serious enough to warrant communication of the problem back to the device that sent the original datagram. This is accomplished in ICMPv4 using the <a class="indexterm" id="idx-CHP-32-1234"/><span class="emphasis"><em>Parameter Problem</em></span> message type.</p><p>This is a catchall type of message that can be used to indicate an error in any header field of an IP datagram. The message type does not contain any specific fields or coding to indicate what the problem is. This was done intentionally to keep the Parameter Problem message generic and ensure that it could indicate any sort of error. Instead of special error codes, most Parameter Problem messages tell the original source which parameter caused the problem by including a special pointer that indicates which field in the original datagram header caused the problem. Both hosts and routers can generate Parameter Problem messages.</p><div class="sect2" title="ICMPv4 Parameter Problem Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_parameter_problem_message_format"/>ICMPv4 Parameter Problem Message Format</h2></div></div></div><p><a class="xref" href="ch32s05.html#icmpv_parameter_problem_message_format" title="Table 32-7. ICMPv4 Parameter Problem Message Format">Table 32-7</a> and <a class="xref" href="ch32s05.html#icmpv4_parameter_problem_message_f-id001" title="Figure 32-7. ICMPv4 Parameter Problem message format">Figure 32-7</a> show the specific format for ICMPv4 Parameter Problem messages.</p><div class="figure"><a id="icmpv4_parameter_problem_message_f-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e35288"/><img alt="ICMPv4 Parameter Problem message format" src="httpatomoreillycomsourcenostarchimages287975.png.jpg"/></div></div><p class="title">Figure 32-7. ICMPv4 Parameter Problem message format</p></div><div class="table"><a id="icmpv_parameter_problem_message_format"/><p class="title">Table 32-7. ICMPv4 Parameter Problem Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Parameter Problem Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; for Parameter Problem messages, this value is 12.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of the problem being communicated. See <a class="xref" href="ch32s05.html#icmpv_parameter_problem_message_interpre" title="Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes">Table 32-8</a> for more information about this field as it relates to Parameter Problem messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pointer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>An offset that points to the byte location in the datagram that caused the Parameter Problem message to be generated. The device receiving the ICMP message can use this value to get an idea of which field in the original message had the problem. This field is used only when the Code value is 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>3 bytes that are left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The full IP header and the first 8 bytes of the payload of the datagram that prompted this error message to be sent.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Parameter Problem Message Interpretation Codes and the Pointer Field"><div class="titlepage"><div><div><h2 class="title"><a id="parameter_problem_message_interpretation"/>Parameter Problem Message Interpretation Codes and the Pointer Field</h2></div></div></div><p>When a Parameter Problem message is generated due to a specific bad field in the original message, the Pointer field is used to show the location of the problem. This meaning of the Parameter Problem message is the one that was defined in the original ICMP standard, RFC 792, and is associated with Code value 0. There are some cases of a parameter problem in which a pointer to a specific field in the original message really wouldn't make sense, so other standards have defined two new Code field values for Parameter Problem messages. <a class="xref" href="ch32s05.html#icmpv_parameter_problem_message_interpre" title="Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes">Table 32-8</a> shows the three Code values and provides a brief explanation of each one.</p><div class="table"><a id="icmpv_parameter_problem_message_interpre"/><p class="title">Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Parameter Problem Message Interpretation Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Subtype</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pointer Indicates the Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is the normal use of the Parameter Problem message. When this Code value is used, the Pointer field indicates the location of the problem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Missing a Required Option</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP datagram needed to have an option in it that was missing. Since the option was missing, there is no way to point to it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>Bad Length</p></td><td style=""><p>The length of the datagram overall was incorrect, indicating a general problem with the message as a whole. Again, the Pointer field makes no sense here.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-187"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The ICMPv4 <span class="emphasis"><em>Parameter Problem</em></span> message is a generic catchall that can be used to convey an error of any type in an IP datagram. A special Pointer field is normally used to indicate to the message's recipient where the problem was in the original datagram.</p></div><p>Note that the Pointer field is only eight bits wide, but since this allows for values of up to 256, it is sufficient for allowing it to point to any location within the IP header. It is possible for the Pointer field to point to a field within an IP option.</p></div></div>
<div class="chapter" title="Chapter&#xA0;33.&#xA0;ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_informational_message_types_and_f"/>Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e35447"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The five Internet Control Message Protocol (ICMP) error message types we examined in the previous chapter communicate important information about error or problem conditions encountered during the operation of an Internet Protocol (IP) internetwork. In contrast, the other class of ICMP messages contains those messages that are <span class="emphasis"><em>informational</em></span>. They are not sent in response to some issue with a regular IP datagram, but are used on their own to implement various support functions for IP. <a class="indexterm" id="idx-CHP-33-1235"/>Informational messages are used for testing and diagnostic purposes, as well as for allowing devices to share critical information that they need to function correctly.</p><p>In this chapter, I describe nine different ICMP version 4 (ICMPv4) informational messages. Because many of these messages are used in functional sets, pairs of related messages are described together. I begin with a discussion of the Echo (Request) and Echo Reply messages used for network testing, and Timestamp (Request) and Timestamp Reply messages used for clock synchronization. I explain the use and format of Router Advertisement and Router Solicitation messages, which allow hosts to discover the identity of local routers and learn important information about them. I also describe the Address Mask Request and Address Mask Reply messages that communicate subnet mask information. I conclude with a look at the Traceroute message, which implements a more sophisticated version of the traceroute utility.</p><div class="note" title="Note"><h3 class="title"><a id="note-99"/>Note</h3><p><span class="emphasis"><em>The original ICMP standard also defined two more informational message types: Information Request and <a class="indexterm" id="idx-CHP-33-1237"/>Information Reply. These were intended to allow devices to determine an IP address and possibly other configuration information. This function was later implemented using host configuration protocols such as the Reverse Address Resolution Protocol (RARP), Boot Protocol (BOOTP), and Dynamic Host Configuration Protocol (DHCP). These message types are now obsolete; therefore, they are not discussed in this chapter</em></span><a class="indexterm" id="idx-CHP-33-1236"/>.</p></div><div class="sect1" title="ICMPv4 Echo (Request) and Echo Reply Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_echo_request_and_echo_reply_mes"/>ICMPv4 Echo (Request) and Echo Reply Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-33-1238"/>One of the main purposes of ICMP informational messages is to enable testing and diagnostics in order to help identify and correct problems on an internetwork. The most basic test that can be conducted between two devices is simply checking if they are capable of sending datagrams to each other. The usual way that this is done is to have one device send a test message to a second device, which receives the message and replies back to tell the first device it received the message.</p><p>ICMPv4 includes a pair of messages specifically for connection testing. Suppose Device A wants to see if it can reach Device B. Device A begins the test process by sending an ICMPv4 <span class="emphasis"><em>Echo</em></span> message to Device B. Device B, when it receives the Echo, responds back to Device A with an <span class="emphasis"><em>Echo</em></span> Reply message. When Device A receives this message, it knows that it is able to communicate (both send and receive) successfully with Device B.</p><div class="note" title="Note"><h3 class="title"><a id="note-100"/>Note</h3><p><span class="emphasis"><em>The name of the first message in this pair is often given as Echo Request. While this does convey the paired nature of the Echo and Echo Reply messages, the formal name used in the standards is simply an Echo message</em></span><a class="indexterm" id="idx-CHP-33-1239"/>.</p></div><div class="sect2" title="ICMPv4 Echo and Echo Reply Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_echo_and_echo_reply_message_forma"/>ICMPv4 Echo and Echo Reply Message Format</h2></div></div></div><p><a class="xref" href="ch33.html#icmpv_echo_and_echo_reply_message_format" title="Table 33-1. ICMPv4 Echo and Echo Reply Message Format">Table 33-1</a> and <a class="xref" href="ch33.html#icmpv4_echo_and_echo_reply_message-id001" title="Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are used within the format of these messages. They allow devices to match Echo and Echo Reply messages together, and exchange a sequence of messages. The Identifier field was envisioned as being used as a higher-level label, like a session identifier, while the Sequence Number was seen as something to identify individual test messages within a series. However, the use of these fields is up to the particular implementation. In some cases, the Identifier field is filled in with the process number of the application that is using the Echo or Echo Reply message to allow several users to use utilities like ping without interference.">Figure 33-1</a> show the format for both ICMPv4 Echo and Echo Reply messages.</p><div class="table"><a id="icmpv_echo_and_echo_reply_message_format"/><p class="title">Table 33-1. ICMPv4 Echo and Echo Reply Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Echo and Echo Reply Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For Echo messages, the value is 8; for Echo Reply messages, the value is 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used for Echo and Echo Reply messages; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>An identification field that can be used to help in matching Echo and Echo Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequence number to help in matching Echo and Echo Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Optional Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Additional data to be sent along with the message (not specified).</p></td></tr></tbody></table></div></div><p>It is possible that a source device may want to send more than one <a class="indexterm" id="idx-CHP-33-1240"/>Echo message to either a single destination or multiple destinations. Conversely, a single destination might receive <a class="indexterm" id="idx-CHP-33-1241"/>Echo messages from more than one source. It is essential that a device receiving an Echo Reply message knows which Echo message prompted it to be sent.</p><div class="figure"><a id="icmpv4_echo_and_echo_reply_message-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e35626"/><img alt="ICMPv4 Echo and Echo Reply message format Two special fields are used within the format of these messages. They allow devices to match Echo and Echo Reply messages together, and exchange a sequence of messages. The Identifier field was envisioned as being used as a higher-level label, like a session identifier, while the Sequence Number was seen as something to identify individual test messages within a series. However, the use of these fields is up to the particular implementation. In some cases, the Identifier field is filled in with the process number of the application that is using the Echo or Echo Reply message to allow several users to use utilities like ping without interference." src="httpatomoreillycomsourcenostarchimages287977.png"/></div></div><p class="title">Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are used within the format of these messages. They allow devices to match Echo and Echo Reply messages together, and exchange a sequence of messages. The Identifier field was envisioned as being used as a higher-level label, like a session identifier, while the Sequence Number was seen as something to identify individual test messages within a series. However, the use of these fields is up to the particular implementation. In some cases, the Identifier field is filled in with the process number of the application that is using the Echo or Echo Reply message to allow several users to use utilities like ping without interference.</p></div></div><div class="sect2" title="Application of Echo and Echo Reply Messages"><div class="titlepage"><div><div><h2 class="title"><a id="application_of_echo_and_echo_reply_messa"/>Application of Echo and Echo Reply Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1242"/>The most common way that you may use the Echo and Echo Reply messages is through the popular utility <span class="emphasis"><em>ping</em></span>, which is used to test host reachability. While the basic test simply consists of sending an Echo message and waiting for an Echo Reply message, modern versions of ping are quite sophisticated. They allow the user to specify many parameters, including the number of Echo messages sent, how often they are sent, the size of message transmitted, and more. They also provide a great deal of information about the connection, including the number of Echo Reply messages received, the time elapsed for the pair of messages to be exchanged, and a lot more. See the description of ping in <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a> for a full explanation of the utility.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-188"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv4 <span class="emphasis"><em>Echo (Request)</em></span><a class="indexterm" id="idx-CHP-33-1243"/> and <span class="emphasis"><em>Echo Reply</em></span> messages are used to facilitate network reachability testing. A device can test its ability to perform basic communication with another one by sending an Echo message and waiting for an Echo Reply message to be returned by the other device. The ping utility, a widely used diagnostic tool in TCP/IP internetworks, makes use of these messages.</p></div></div></div></div>
<div class="sect1" title="ICMPv4 Timestamp (Request) and Timestamp Reply Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_timestamp_request_and_timestamp_r"/>ICMPv4 Timestamp (Request) and Timestamp Reply Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-33-1244"/><a class="indexterm" id="idx-CHP-33-1245"/>All of the hosts and routers on an internetwork operate independently of each other. One aspect of this autonomy is that each device maintains a separate system clock. There's a problem, however: Even highly accurate clocks have slight differences in both how accurately they keep time and the time with which they were initialized at startup. This means that under normal circumstances, no two devices on an internetwork are guaranteed to have exactly the same time.</p><p>The creators of TCP/IP recognized that certain applications might not work properly if there were too much differential between the system clocks of a pair of devices. To support this requirement, they created a pair of ICMP <a class="indexterm" id="idx-CHP-33-1246"/>messages that allow devices to exchange system time information. The initiating device creates a <a class="indexterm" id="idx-CHP-33-1247"/>Timestamp message and sends it to the device with which it wishes to synchronize. That device responds with a <a class="indexterm" id="idx-CHP-33-1248"/>Timestamp Reply message. Timestamp fields in these messages are used to mark the times that these messages are sent and received to allow the devices' clocks to be synchronized.</p><div class="note" title="Note"><h3 class="title"><a id="note-101"/>Note</h3><p><span class="emphasis"><em>As with the Echo message (described in the previous section), the Timestamp message is sometimes seen as Timestamp Request, though the word</em></span> Request <span class="emphasis"><em>doesn't appear in its formal name</em></span>.</p></div><div class="sect2" title="ICMPv4 Timestamp and Timestamp Reply Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_timestamp_and_timestamp_reply_mes"/>ICMPv4 Timestamp and Timestamp Reply Message Format</h2></div></div></div><p>The ICMPv4 <span class="emphasis"><em>Timestamp</em></span> and <span class="emphasis"><em>Timestamp Reply</em></span> messages have the same format. The originating device fills in some of the fields, and the replying device fills in others. The format is as shown in <a class="xref" href="ch33s02.html#icmpv_timestamp_and_timestamp_reply_mess" title="Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format">Table 33-2</a> and <a class="xref" href="ch33s02.html#icmpv4_timestamp_and_timestamp_rep-id001" title="Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format">Figure 33-2</a>.</p><div class="table"><a id="icmpv_timestamp_and_timestamp_reply_mess"/><p class="title">Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Timestamp and Timestamp Reply Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For Timestamp messages, the value is 13; for Timestamp <a class="indexterm" id="idx-CHP-33-1249"/>Reply messages, the value is 14.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used for Timestamp and Timestamp Reply messages; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>An identification field that can be used to help in matching Timestamp and Timestamp Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequence number to help in matching Timestamp and Timestamp Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Originate Timestamp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A time value filled in by the originating device just before sending the Timestamp message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Receive Timestamp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A time value filled in by the responding device just as it receives the Timestamp message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Transmit Timestamp</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>A time value filled in by the responding device just before sending back the Timestamp Reply message.</p></td></tr></tbody></table></div></div><p>The Identifier and Sequence Number fields are used to match Timestamp and Timestamp Reply messages, exactly as they are used for Echo and Echo Reply messages. The Identifier field is intended as a higher-level label, like a session identifier, while the Sequence Number is often used to identify individual messages within a series. However, the use of these fields is up to the particular implementation.</p><div class="figure"><a id="icmpv4_timestamp_and_timestamp_rep-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e35840"/><img alt="ICMPv4 Timestamp and Timestamp Reply message format" src="httpatomoreillycomsourcenostarchimages287979.png"/></div></div><p class="title">Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format</p></div><p>All three <a class="indexterm" id="idx-CHP-33-1250"/>timestamps are represented as the number of milliseconds since midnight, <span class="emphasis"><em>Universal Time</em></span> (<span class="emphasis"><em>UT</em></span>, also called <span class="emphasis"><em>Greenwich mean time</em></span> or <span class="emphasis"><em>GMT</em></span> ). The reason there are three timestamps instead of the two you might ordinarily expect is that the responding device records a separate timestamp when it receives the Timestamp message and when it generates the <a class="indexterm" id="idx-CHP-33-1251"/>Timestamp Reply. When the Reply message is received back by the originating device, it then has the times that both the Timestamp and the Timestamp Reply messages were sent. This allows the originating device to differentiate between the time required for transmitting datagrams over the network and the time for the other device to process the Timestamp message and turn it into a Timestamp Reply message.</p></div><div class="sect2" title="Issues Using Timestamp and Timestamp Reply Messages"><div class="titlepage"><div><div><h2 class="title"><a id="issues_using_timestamp_and_timestamp_rep"/>Issues Using Timestamp and Timestamp Reply Messages</h2></div></div></div><p>In practice, even with these three timestamp fields, it is difficult to coordinate system clocks over an internetwork, especially a large one like the Internet. The main problem is that the amount of time it takes to send a datagram between any pair of devices varies from one datagram to the next. And again, since IP is unreliable, it's possible that the time for a datagram to be received could be infinite. In fact, it might be lost or dropped by a router.</p><p>This means that a simple exchange of Timestamp and Timestamp Reply messages is simply not a method that's reliable enough to ensure that two devices are synchronized on a typical IP internetwork. For this reason, modern devices often use a more sophisticated method for time synchronization, such as the <a class="indexterm" id="idx-CHP-33-1252"/>Network Time Protocol (NTP).</p><p>Note that unlike many of the other ICMP message types, support for Timestamp and Timestamp Reply messages is optional, for both hosts and routers.</p></div></div>
<div class="sect1" title="ICMPv4 Router Advertisement and Router Solicitation Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_router_advertisement_and_router_s"/>ICMPv4 Router Advertisement and Router Solicitation Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-33-1253"/><a class="indexterm" id="idx-CHP-33-1254"/><a class="indexterm" id="idx-CHP-33-1255"/>
In <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>, which described IP routing fundamentals, I discussed a critical aspect of IP internetwork design: the difference between the roles of a router and the roles of a host with regard to routing. Routers are charged with the job of routing datagrams, and therefore, of knowing routes and exchanging route information. Hosts generally do not know a great deal about routes; they rely on routers to convey datagrams intended for destinations outside the local network.</p><p>This dependence means that before a host can really <a class="indexterm" id="idx-CHP-33-1256"/>participate on an internetwork, it needs to know the identity of at least one router on the local network. One way to ensure that this is the case is to just manually configure each host with the address of a local router as its default router. This method is simple, but has the typical drawbacks associated with manual processes: It is time-consuming to set up, difficult to maintain, and inflexible.</p><div class="sect2" title="The Router Discovery Process"><div class="titlepage"><div><div><h2 class="title"><a id="the_router_discovery_process"/>The Router Discovery Process</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1257"/>It would be better if there were some method whereby a host could automatically discover the identity of local routers and learn important information about them. In IP, this process is called <span class="emphasis"><em>Router Discovery</em></span> and was first defined in RFC 1256, "ICMP Router Discovery Messages." The messages referenced in the RFC title are the ICMP Router Advertisement message and the Router Solicitation message. They were added to the ICMP message types that were defined in earlier standards such as RFC 792.</p><p>Routers are responsible for sending <span class="emphasis"><em>Router Advertisement</em></span> messages. These messages tell listening devices that the router exists, and they provide important information about the router such as its address (or addresses, if it has more than one) and how long the host should retain information about the router. Routine Router Advertisement messages are sent on a regular basis, and an administrator can configure the time between messages (usually between seven and ten minutes). Hosts listen for these messages; when an advertisement is received, the host processes it and adds the information about the router to its routing table.</p><p>A host that does not have any manually configured routing information will have no knowledge of routers when it first powers on. Having it sit for many minutes while it looks for a routine Router Advertisement message is inefficient. Instead of waiting, the host may send a <span class="emphasis"><em>Router Solicitation</em></span> message on its local network(s). This will prompt any router that hears it to immediately send out an extra Router Advertisement message directly to that host.</p></div><div class="sect2" title="ICMPv4 Router Advertisement Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_router_advertisement_message_form"/>ICMPv4 Router Advertisement Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1258"/>The ICMPv4 Router Advertisement message format is shown in <a class="xref" href="ch33s03.html#icmpv_router_advertisement_message_forma" title="Table 33-3. ICMPv4 Router Advertisement Message Format">Table 33-3</a> and <a class="xref" href="ch33s03.html#icmpv4_router_advertisement_messag-id001" title="Figure 33-3. ICMPv4 Router Advertisement Message format">Figure 33-3</a>.</p><div class="table"><a id="icmpv_router_advertisement_message_forma"/><p class="title">Table 33-3. ICMPv4 Router Advertisement Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Router Advertisement Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For Router Advertisement messages, the value is 9.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Normally set to 0. When a Mobile IP agent is sending a Router Advertisement with an Agent Advertisement extension, it may set the value to 16 only if the device is a mobile agent and doesn't intend to handle normal traffic. See the discussion of Mobile IP agent discovery for details (<a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Num Addrs</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of addresses associated with this router that are included in this advertisement.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Addr Entry Size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address entry size—number of 32-bit words of information included with each address. Since in this <a class="indexterm" id="idx-CHP-33-1259"/>message format each router address has a 32-bit address and a 32-bit preference level, this value is fixed at 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of seconds that a host should consider the information in this message valid.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Router Address Entries</p></td><td style="border-right: 0.5pt solid ; "><p>Value of Num Addrs field * 8</p></td><td style=""><p>A number of router address entries equal to the value of the Num Addrs field. Each is 8 bytes and has two subfields, each 4 bytes in size. The Router Address subfield is a valid address for an interface to the router sending this message. The Preference Level subfield is the preference level of this address. When more than one address is included in an advertisement, this field indicates which address the router would prefer hosts to use. Higher values mean greater preference.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_router_advertisement_messag-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e36068"/><img alt="ICMPv4 Router Advertisement Message format" src="httpatomoreillycomsourcenostarchimages287981.png"/></div></div><p class="title">Figure 33-3. ICMPv4 Router Advertisement Message format</p></div></div><div class="sect2" title="ICMPv4 Router Solicitation Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_router_solicitation_message_forma"/>ICMPv4 Router Solicitation Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1260"/>ICMPv4 Router Solicitation messages are much simpler, because they need to convey only the following single piece of information: "If you are a router and can hear this, please send a Router Advertisement to me." The format is therefore just the trivial set of fields shown in <a class="xref" href="ch33s03.html#icmpv_router_solicitation_message_format" title="Table 33-4. ICMPv4 Router Solicitation Message Format">Table 33-4</a> and illustrated in <a class="xref" href="ch33s03.html#icmpv4_router_solicitation_message-id001" title="Figure 33-4. ICMPv4 Router Solicitation Message format">Figure 33-4</a>.</p><div class="table"><a id="icmpv_router_solicitation_message_format"/><p class="title">Table 33-4. ICMPv4 Router Solicitation Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Router Solicitation Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-33-1261"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For Router Solicitation messages, the value is 10.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; value set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The 4 reserved bytes sent as 0.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_router_solicitation_message-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e36160"/><img alt="ICMPv4 Router Solicitation Message format" src="httpatomoreillycomsourcenostarchimages287983.png"/></div></div><p class="title">Figure 33-4. ICMPv4 Router Solicitation Message format</p></div></div><div class="sect2" title="Addressing and Use of Router Advertisement and Router Solicitation Messages"><div class="titlepage"><div><div><h2 class="title"><a id="addressing_and_use_of_router_advertiseme"/>Addressing and Use of Router Advertisement and Router Solicitation Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1262"/>If possible, both Router Advertisement and Router Solicitation messages are sent out as multicast for efficiency. Router Advertisements use the "all devices" multicast address (224.0.0.1), because they are intended for hosts to hear. <span class="emphasis"><em>Router Solicitation</em></span> messages use the "all routers" multicast address (224.0.0.2). If the local network does not support multicast, messages are instead sent out by broadcast (to address 255.255.255.255).</p><p>It is important to remember that just like ICMP Redirect messages, Router Advertisement messages are not a generalized method for exchanging routing information. They are a support mechanism only, used to inform hosts about the existence of routers. Detailed information about routes is communicated between routers using routing protocols, like the Routing Information Protocol (RIP) and Open Shortest Path First (OSPF).</p><p>Although Router Discovery is one alternative to manual configuration of a host's default router, there are other alternatives as well. For example, a host configuration protocol like the Dynamic Host Configuration Protocol (DHCP) can allow a host to learn the address of a default router on the local network.</p><p>Finally, note that when Mobile IP is implemented, Router Advertisement messages are used as the basis for Mobile IP–aware routers to send Agent Advertisements. One or more special extensions are added to the regular Router Advertisement format to create an Agent Advertisement. This is discussed extensively in the section on Mobile IP Agent Discovery in <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-189"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMP <span class="emphasis"><em>Router Advertisement</em></span> messages are sent regularly by IP routers to inform hosts of their presence and characteristics. This way, hosts know to use them for delivery of datagrams to distant hosts. A host that is new to a network and wants to find out immediately what routers are present may send a <span class="emphasis"><em>Router Solicitation</em></span> message, which will prompt listening routers to send out Router Advertisement messages.</p></div></div></div>
<div class="sect1" title="ICMPv4 Address Mask Request and Reply Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_address_mask_request_and_reply_me"/>ICMPv4 Address Mask Request and Reply Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-33-1263"/>When IP was first developed, IP addresses were based on a simple two-level structure, with a network identifier (network ID) and host identifier (host ID). To provide more flexibility, a technique called <span class="emphasis"><em>subnetting</em></span> was soon developed. Subnetting expands the addressing scheme into a three-level structure, with each address containing a network ID, subnet identifier, and host ID. The <span class="emphasis"><em>subnet mask</em></span> is a 32-bit number that tells devices (and users) which bits are part of the subnet identifier, as compared to the host ID. All of this is described in considerable detail in the part on IP addressing (<a class="xref" href="pt06.html" title="Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)">Part II-3</a>).</p><p>To function properly in a subnetting environment, each host must know the subnet mask that corresponds to each address it is assigned. Without the mask, it cannot properly interpret IP addresses. Just as in determining the identity of a local router, a host can be informed of the local network's subnet mask either manually or automatically. The manual method is to simply manually assign the subnet mask to each host. The automatic method makes use of a pair of ICMP messages designed for subnet mask determination, which were defined in RFC 950, the same standard that defined subnetting itself.</p><p>To use this method, a host sends an <span class="emphasis"><em>Address Mask Request</em></span> message on the local network, usually to get a response from a router. If it knows the address of a local router, it may send the request directly (unicast); otherwise, the host will broadcast the request to any listening router. A local router (or other device) will receive this message and respond back with an <a class="indexterm" id="idx-CHP-33-1264"/><span class="emphasis"><em>Address Mask Reply</em></span> message that contains the subnet mask for the local network. This process is somewhat similar to the mechanism used by a host to solicit a router to respond with a Router Advertisement message, except that routers do not routinely send subnet mask information—that information must be requested.</p><div class="sect2" title="ICMPv4 Address Mask Request and Address Mask Reply Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_address_mask_request_and_address_"/>ICMPv4 Address Mask Request and Address Mask Reply Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1265"/>The Address Mask Request and Address Mask Reply, like some other request and reply pairs, have the same basic format. The host creates the request with all fields filled in except for the subnet mask value itself, and the router supplies the mask and sends the reply back to the host. The format is described in <a class="xref" href="ch33s04.html#icmpv_address_mask_request_and_address_m" title="Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format">Table 33-5</a> and illustrated in <a class="xref" href="ch33s04.html#icmpv4_address_mask_request_and_ad-id001" title="Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format">Figure 33-5</a>.</p><div class="table"><a id="icmpv_address_mask_request_and_address_m"/><p class="title">Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Address Mask Request and Address Mask Reply Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type. For <a class="indexterm" id="idx-CHP-33-1266"/>Address Mask Request messages, the value is 17; for <a class="indexterm" id="idx-CHP-33-1267"/>Address Mask Reply messages, it is 18.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used for either message type; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>An identification field that can be used to help in matching <a class="indexterm" id="idx-CHP-33-1268"/>Address Mask Request and Address Mask Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequence number to help in matching Address Mask Request and <a class="indexterm" id="idx-CHP-33-1269"/>Address Mask Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Address Mask</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The subnet mask for the local network, filled in by the router in the Address Mask Reply message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_address_mask_request_and_ad-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e36360"/><img alt="ICMPv4 Address Mask Request and Address Mask Reply message format" src="httpatomoreillycomsourcenostarchimages287985.png.jpg"/></div></div><p class="title">Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format</p></div><p>The Identifier and Sequence Number fields can be used to match up requests and replies, as they are for Echo and Echo Reply messages. However, a host won't normally send multiple requests for subnet masks the way it might send Echo messages for testing. For this reason, the Identifier and Sequence Number fields may be ignored by some implementations.</p></div><div class="sect2" title="Use of Address Mask Request and Address Mask Reply Messages"><div class="titlepage"><div><div><h2 class="title"><a id="use_of_address_mask_request_and_address_"/>Use of Address Mask Request and Address Mask Reply Messages</h2></div></div></div><p>Note that the use of Address Mask Request and Address Mask Reply messages is optional, just as the Router Discovery described in the previous section is. Other methods besides these messages or manual configuration may be used to tell a host what subnet mask to use. Again, a common alternative to ICMP for this is to use a host configuration protocol like DHCP. Routers do need to be able to respond to Address Mask Requests for hosts that choose to send them.</p></div></div>
<div class="sect1" title="ICMPv4 Traceroute Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv4_traceroute_messages"/>ICMPv4 Traceroute Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-33-1270"/>The Echo and Echo Reply messages you saw earlier in this chapter are used for the most basic type of test that can be conducted between two devices: checking if they can communicate. A more sophisticated test can also be performed in order to see not only if the devices are able to talk, but also to discover the exact sequence of routers used to move datagrams between them. In TCP/IP, this diagnostic is performed using the <a class="indexterm" id="idx-CHP-33-1271"/>traceroute (or tracert) utility.</p><p>The first implementation of <a class="indexterm" id="idx-CHP-33-1272"/><span class="emphasis"><em>traceroute</em></span> used a clever application of Time Exceeded error messages, as described in the previous chapter. By sending a test message to a destination first with a Time to Live (TTL) value of 1, then 2, then 3, and so on, each router in the path between the source and destination would successively discard the test messages and send back a Time Exceeded message. Each router would then display the sequence of routers between the two hosts. This bit of trickery works well enough in general terms, but is suboptimal in a couple of respects. For example, it requires the source device to send one test message for each router in the path, instead of just a single test message. It also doesn't take into account the possibility that the path between two devices may change during the test.</p><p>Recognizing these limitations, a new experimental standard was developed in 1993 that defined a more efficient way to conduct a traceroute: RFC 1393, "Traceroute Using an IP Option." As the title suggests, this method of doing a traceroute works by having the source device send a single datagram to the destination that contains a special Traceroute IP option. Each router that sees that option while the test message is conducted along the route responds back to the original source with an ICMP Traceroute message, which is also defined in RFC 1393.</p><div class="sect2" title="ICMPv4 Traceroute Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv4_traceroute_message_format"/>ICMPv4 Traceroute Message Format</h2></div></div></div><p>Since the <span class="emphasis"><em>Traceroute</em></span> message was specifically designed for the traceroute utility, it was possible to incorporate extra information in it that a host tracing a route could use. The message format is as shown in <a class="xref" href="ch33s05.html#icmpv_traceroute_message_format" title="Table 33-6. ICMPv4 Traceroute Message Format">Table 33-6</a> and <a class="xref" href="ch33s05.html#icmpv4_traceroute_message_format-id001" title="Figure 33-6. ICMPv4 Traceroute message format">Figure 33-6</a>.</p><div class="table"><a id="icmpv_traceroute_message_format"/><p class="title">Table 33-6. ICMPv4 Traceroute Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv4 Traceroute Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMP message type; in this case, 30.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to the value 0 if the datagram the source device sent was successfully sent to the next router, or 1 to indicate that the datagram was dropped (meaning the traceroute failed).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ID Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>An identification field used to match up this Traceroute message to the original message sent by the source (the one containing the Traceroute IP option).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used, set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Outbound Hop Count</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of routers the original message has already passed through.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Return Hop Count</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of routers the return message has passed through.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Link Speed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The speed of the link over which the Traceroute message is being sent, in bytes per second.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Output Link MTU</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The maximum transmission unit (MTU) of the link over which the Traceroute message is being sent, in bytes.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv4_traceroute_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e36528"/><img alt="ICMPv4 Traceroute message format" src="httpatomoreillycomsourcenostarchimages287987.png"/></div></div><p class="title">Figure 33-6. ICMPv4 Traceroute message format</p></div></div><div class="sect2" title="Use of Traceroute Messages"><div class="titlepage"><div><div><h2 class="title"><a id="use_of_traceroute_messages"/>Use of Traceroute Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-33-1273"/>Although this method of implementing traceroute has advantages over the older Time Exceeded messages method, it has one critical flaw as well: It requires changes to both hosts and routers to support the new IP option and the Traceroute ICMP message. People aren't big on change, especially when it comes to the basic operation of IP. For this reason, RFC 1393 never moved beyond experimental status, and most IP devices still use the older method of implementing traceroute. It is possible that you may encounter ICMP Traceroute messages, however, so it's good that you know they exist.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-190"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMP <span class="emphasis"><em>Traceroute</em></span> messages were designed to provide a more capable way of implementing the traceroute (tracert) utility. However, most TCP/IP implementations still use ICMP Time Exceeded messages for this task.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;34.&#xA0;ICMPV6 ERROR MESSAGE TYPES AND FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_error_message_types_and_formats"/>Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e36554"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The original Internet Control Message Protocol (ICMP) defined for version 4 of the Internet Protocol (IPv4) has a number of <a class="indexterm" id="idx-CHP-34-1274"/>error messages that allow for the communication of problems on an internetwork. When IP version 6 (IPv6) was developed, the differences between IPv4 and IPv6 were significant enough that a new version of ICMP was also required: version 6 <span class="emphasis"><em>(ICMPv6)</em></span>, which is currently specified in RFC 2463. Like ICMPv4, ICMPv6 defines several error messages for informing a source that something has gone wrong.</p><p>In this chapter, I describe the four ICMPv6 error messages defined in RFC 2463. I first discuss ICMPv6 Destination Unreachable messages, which are used to tell a device that the datagram it sent could not be delivered for a variety of reasons. I describe Packet Too Big error messages, which are sent when a datagram can't be sent due to being too large for an underlying network it needs to traverse. I explain the use of Time Exceeded messages, which indicate that too much time was taken to accomplish a transmission. I conclude with a look at Parameter Problem messages, which provide a generalized way of reporting errors that are not described by any of the preceding ICMPv6 error message types.</p><div class="note" title="Note"><h3 class="title"><a id="note-102"/>Note</h3><p><span class="emphasis"><em>Three of the four ICMPv6 error messages (all except Packet Too Big) are equivalent to the ICMPv4 error messages that have the same names. However, to allow this chapter to stand on its own, I describe each one fully, in addition to pointing out any significant differences between the ICMPv4 and ICMPv6 version of the message</em></span>.</p></div><div class="sect1" title="ICMPv6 Destination Unreachable Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_destination_unreachable_messages"/>ICMPv6 Destination Unreachable Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-34-1275"/>IPv6 includes some important enhancements over the older version 4, but the basic operation of the two protocols is still fundamentally the same. Like IPv4, IPv6 is an unreliable network protocol that makes a best effort to deliver datagrams, but offers no guarantees that they will always get there. Just as they did in IPv4, devices on an IPv6 network must not assume that datagrams sent to a destination will always be received.</p><p>When a datagram cannot be delivered, recovery from this condition normally falls to higher-layer protocols like the Transmission Control Protocol (TCP), which will detect the miscommunication and resend the lost datagrams. In some situations, such as a datagram that was dropped due to the congestion of a router, this is sufficient, but in other cases, a datagram may not be delivered due to an inherent problem with how it is being sent. For example, the source may have specified an invalid destination address, which means that even if it were resent many times, the datagram would never get to its intended recipient.</p><p>In general, having the source just resend undelivered datagrams while having no idea why they were lost is inefficient. It is better to have a feedback mechanism that can tell a source device about undeliverable datagrams and provide some information about why the datagram delivery failed. As in ICMPv4, in ICMPv6 this is done with <a class="indexterm" id="idx-CHP-34-1276"/><span class="emphasis"><em>Destination Unreachable</em></span> messages. Each message includes a code that indicates the basic nature of the problem that caused the datagram not to be delivered, as well as all or part of the datagram that was undelivered in order to help the source device diagnose the problem.</p><div class="sect2" title="ICMPv6 Destination Unreachable Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_destination_unreachable_message_f"/>ICMPv6 Destination Unreachable Message Format</h2></div></div></div><p><a class="xref" href="ch34.html#icmpv_destination_unreachable_mess-id001" title="Table 34-1. ICMPv6 Destination Unreachable Message Format">Table 34-1</a> and <a class="xref" href="ch34.html#icmpv6_destination_unreachable_mes-id001" title="Figure 34-1. ICMPv6 Destination Unreachable message format">Figure 34-1</a> show the specific format for ICMPv6 Destination Unreachable messages.</p><div class="figure"><a id="icmpv6_destination_unreachable_mes-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e36613"/><img alt="ICMPv6 Destination Unreachable message format" src="httpatomoreillycomsourcenostarchimages287989.png.jpg"/></div></div><p class="title">Figure 34-1. ICMPv6 Destination Unreachable message format</p></div><div class="table"><a id="icmpv_destination_unreachable_mess-id001"/><p class="title">Table 34-1. ICMPv6 Destination Unreachable Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Destination Unreachable Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for <a class="indexterm" id="idx-CHP-34-1277"/>Destination Unreachable messages, this is set to 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of unreachable errors that are being communicated. See <a class="xref" href="ch32.html#icmpv_destination_unreachable_message_su" title="Table 32-2. ICMPv4 Destination Unreachable Message Subtypes">Table 32-2</a> for a full list of codes and what they mean.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes that are left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>As much of the IPv6 datagram as will fit without causing the size of the ICMPv6 error message (including its own IP header) to exceed the minimum IPv6 maximum transmission unit (MTU) of 1280 bytes.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="ICMPv6 Destination Unreachable Message Subtypes"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_destination_unreachable_message_s"/>ICMPv6 Destination Unreachable Message Subtypes</h2></div></div></div><p>There are a number of different reasons why a destination may be unreachable. To provide additional information about the nature of the problem to the device that originally tried to send the datagram, a value is placed in the message's Code field. One interesting difference between ICMPv4 and ICMPv6 Destination Unreachable messages is that there are many fewer Code values for ICMPv6. The ICMPv6 Code values were streamlined, mainly because several of the ICMPv4 codes were related to relatively obscure features that aren't applicable to ICMPv6.</p><p><a class="xref" href="ch34.html#icmpv_destination_unreachable_mess-id002" title="Table 34-2. ICMPv6 Destination Unreachable Message Subtypes">Table 34-2</a> shows the different Code values, corresponding message subtypes, and a brief explanation of each.</p><div class="table"><a id="icmpv_destination_unreachable_mess-id002"/><p class="title">Table 34-2. ICMPv6 Destination Unreachable Message Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Destination Unreachable Message Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Subtype</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-34-1278"/>No Route to Destination</p></td><td style="border-bottom: 0.5pt solid ; "><p>The datagram was not delivered because it could not be routed to the destination. Since this means that the datagram could not be sent to the destination device's local network, this is basically equivalent to the Network Unreachable message subtype in ICMPv4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-34-1279"/>Communication with Destination Administratively Prohibited</p></td><td style="border-bottom: 0.5pt solid ; "><p>The datagram could not be forwarded due to filtering that blocks the message based on its contents. Equivalent to the message subtype with the same name (and <span class="emphasis"><em>Code</em></span> value 13) in ICMPv4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-34-1280"/>Address Unreachable</p></td><td style="border-bottom: 0.5pt solid ; "><p>There was a problem attempting to deliver the datagram to the host specified in the destination address. This code is equivalent to the ICMPv4 Host Unreachable code and usually means that the destination address was bad or that there was a problem with resolving it into a layer 2 address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-34-1281"/>Port Unreachable</p></td><td style=""><p>The destination port specified in the UDP or TCP header was invalid or does not exist on the destination host.</p></td></tr></tbody></table></div></div><p>Note that Code value 2 is not used. Also, Destination Unreachable messages are sent only when there is a fundamental problem with delivering a particular datagram; they are not sent when a datagram is dropped simply due to congestion of a router.</p></div><div class="sect2" title="Processing of Destination Unreachable Messages"><div class="titlepage"><div><div><h2 class="title"><a id="processing_of_destination_unreachable_me"/>Processing of Destination Unreachable Messages</h2></div></div></div><p>It is up to the recipient of an ICMPv6 Destination Unreachable message to decide what to do with it. However, just as the original datagram may not reach its destination, the Destination Unreachable message may do the same. Therefore, a device cannot rely on the receipt of one of these error messages to inform it of every delivery problem. This is especially true given that it is possible that some unreachable destination problems may not be detectable.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-191"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv6 <span class="emphasis"><em>Destination Unreachable</em></span> messages are used in the same manner as the ICMPv4 Destination Unreachable messages: to inform a sending device of a failure to deliver an IP datagram. The message's Code field provides information about the nature of the delivery problem (though the Code values are different from those in ICMPv4).</p></div></div></div></div>
<div class="sect1" title="ICMPv6 Packet Too Big Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_packet_too_big_messages"/>ICMPv6 Packet Too Big Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-34-1282"/>One of the most interesting changes made to the operation of IP in version 6 is related to the process of datagram fragmentation and reassembly. In IPv4, a host can send a datagram of any size that's allowed by the IP specification out onto the internetwork. If a router needs to send the datagram over a physical link that has a maximum transmission unit (MTU) size that is too small for the size of the datagram, it will automatically fragment the datagram and send the fragments individually so they will fit. The destination device will receive the fragments and reassemble them. I explain the basics behind this in <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>.</p><p>Even though it is convenient for hosts to be able to rely on routers to automatically fragment messages as needed, it is inefficient for routers to spend time doing this. For this reason, in IPv6 developers made the decision to not allow routers to fragment datagrams. This puts the responsibility on each host to ensure that the datagrams they send out are small enough to fit over every physical network between itself and any destination. This is done either by using the IPv6 default minimum MTU of 1280, which every physical link must support, or a special Path MTU Discovery process for determining the minimum MTU between a pair of devices. Again, the full details are in <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>.</p><p>If an IPv6 router is not allowed to fragment an IPv6 datagram that is too large to fit on the next physical link over which it must be forwarded, what should the router do with it? The datagram can't be forwarded, so the router has no choice but to discard it. When this happens, the router is required to report this occurrence back to the device that initially sent the datagram, using an ICMPv6 <a class="indexterm" id="idx-CHP-34-1283"/><span class="emphasis"><em>Packet Too Big</em></span> message. The source device will know that it needs to fragment the datagram in order to have it successfully reach its destination.</p><div class="note" title="Note"><h3 class="title"><a id="note-103"/>Note</h3><p><span class="emphasis"><em>Recall that packet is a synonym for datagram, so you can think of this as the "Datagram Too Big" message</em></span>.</p></div><div class="sect2" title="ICMPv6 Packet Too Big Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_packet_too_big_message_format"/>ICMPv6 Packet Too Big Message Format</h2></div></div></div><p><a class="xref" href="ch34s02.html#icmpv_packet_too_big_message_format" title="Table 34-3. ICMPv6 Packet Too Big Message Format">Table 34-3</a> and <a class="xref" href="ch34s02.html#icmpv6_packet_too_big_message_form-id001" title="Figure 34-2. ICMPv6 Packet Too Big message format">Figure 34-2</a> show the format for ICMPv6 Packet Too Big messages.</p><div class="table"><a id="icmpv_packet_too_big_message_format"/><p class="title">Table 34-3. ICMPv6 Packet Too Big Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Packet Too Big Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for <a class="indexterm" id="idx-CHP-34-1284"/>Packet Too Big messages, this is set to 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used for this message type; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MTU</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The MTU size, in bytes, of the physical link over which the router wanted to send the datagram, but was not able to do so due to the datagram's size. Including this value in the <a class="indexterm" id="idx-CHP-34-1285"/>Packet Too Big message tells the source device the size it needs to use for its next transmission to this destination in order to avoid this problem in the future (at least for this particular link).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>As much of the IPv6 datagram as will fit without causing the size of the ICMPv6 message (including its own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_packet_too_big_message_form-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e36921"/><img alt="ICMPv6 Packet Too Big message format" src="httpatomoreillycomsourcenostarchimages287991.png.jpg"/></div></div><p class="title">Figure 34-2. ICMPv6 Packet Too Big message format</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-192"/>Tip</h3><p><a class="indexterm" id="idx-CHP-34-1286"/><span class="strong"><strong>KEY CONCEPT</strong></span> In IPv6, routers are not allowed to fragment datagrams that are too large to send over a physical link to which they are connected. An oversized datagram is dropped, and an ICMPv6 <span class="emphasis"><em>Packet Too Big</em></span> message is sent back to the datagram's originator to inform it of this occurrence.</p></div></div><div class="sect2" title="Applications of Packet Too Big Messages"><div class="titlepage"><div><div><h2 class="title"><a id="applications_of_packet_too_big_messages"/>Applications of Packet Too Big Messages</h2></div></div></div><p>While Packet Too Big is obviously an error message, it also has another use: the implementation of Path MTU Discovery. This process, described in RFC 1981, defines a way for a device to determine the minimum MTU for a path to a destination. To perform Path MTU Discovery, the source device sends a series of test messages, decreasing the size of the datagram until it no longer receives Packet Too Big messages back in response to its tests. See <a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a> for a bit more detail on this.</p><div class="note" title="Note"><h3 class="title"><a id="note-104"/>Note</h3><p><span class="emphasis"><em>The Packet Too Big message is new to ICMPv6. However, its use is somewhat similar to the use of the Fragmentation Needed and DF Set version of the ICMP4 Destination Unreachable message type, which is used as part of IPv4's Path MTU Discovery feature</em></span>.</p></div><p>Incidentally, Packet Too Big is an exception to the rule that ICMP messages are sent only in response to unicast datagrams; it may be sent in reply to an oversized multicast datagram. If this occurs, it is important to realize that some of the intended targets of the multicast may still have received it, if the path the multicast took to them did not go through the link with the small MTU that caused the error.</p></div></div>
<div class="sect1" title="ICMPv6 Time Exceeded Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_time_exceeded_messages"/>ICMPv6 Time Exceeded Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-34-1287"/><a class="indexterm" id="idx-CHP-34-1288"/>The engineers who first designed IP recognized that due to the nature of how routing works on an internetwork, there was always a danger that a datagram might get lost in the system and spend too much time being passed from one router to another. They included in IPv4 datagrams a field called <span class="emphasis"><em>Time to Live (TTL)</em></span>, which was intended to be set to a time value by the device sending the datagram and used as a timer to cause the datagram to be discarded if it took too long to get to its destination.</p><p>Eventually, the meaning of this field was changed, so it represented not a time in seconds but the number of hops the datagram was allowed to traverse. In IPv6, the new meaning of this field was formalized when it was renamed <span class="emphasis"><em>Hop Limit</em></span>. Regardless of its name, the field still has the same basic purpose: It restricts how long a datagram can exist on an internetwork by limiting the number of times routers can forward it. This is particularly designed to provide protection against <a class="indexterm" id="idx-CHP-34-1289"/>router loops that may occur in large or improperly configured internetworks. An example of this situation is where Router A thinks datagrams intended for Network X should next go to Router B, which thinks they should go to Router C, which thinks they need to go to Router A. Without a Hop Limit, such datagrams would circle forever, clogging networks and never accomplishing anything useful. <a class="xref" href="ch34s03.html#an_example_of_a_router_loop_this_diagram" title="Figure 34-3. An example of a router loop This diagram shows a simple internetwork consisting of four networks, each of which is served by a router. It is an adaptation of Figure 23-3 from Chapter 23, but in this case, the routing tables have been set up incorrectly. Router R1 thinks that it needs to route any traffic intended for Network N4 to Router R3, which thinks it goes to Router R2, which thinks it goes back to Router R1. This means that when any device tries to send to Network N4, the datagram will circle this triangle until its Hop Limit is reached, at which point an ICMPv6 Time Exceeded message will be generated.">Figure 34-3</a> illustrates the router loop problem.</p><p>Each time a router passes an IPv6 datagram, it decreases the <a class="indexterm" id="idx-CHP-34-1290"/>Hop Limit field. If the value ever reaches zero, the datagram expires and is discarded. When this happens, the router that dropped the datagram sends an ICMPv6 Time Exceeded message back to the datagram's originator to inform it that the datagram was dropped. This is basically the same as the ICMPv4 <span class="emphasis"><em>Time Exceeded</em></span> message. As in the ICMPv4 case, the device receiving the message must decide whether and how to respond to receipt of the message. For example, since a device using a Hop Limit that was too low can cause the error, the device may try to resend the datagram with a higher value before concluding that there is a routing problem and giving up. (<a class="xref" href="ch32.html" title="Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS">Chapter 32</a> for an illustration of how TTL expiration works.)</p><p>Just as with the ICMPv4 equivalent, there is also another time expiration situation in which ICMPv6 Time Exceeded messages are used. When an IP message is broken into fragments that are sent independently, the destination device is charged with reassembling the fragments into the original message. One or more fragments may not make it to the destination, however. To prevent the device from waiting forever, it sets a timer when the first fragment arrives. If this timer expires before all of the other fragments are also received, the device gives up on this message. The fragments are tossed out, and a Time Exceeded message is generated.</p><div class="figure"><a id="an_example_of_a_router_loop_this_diagram"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e37008"/><img alt="An example of a router loop This diagram shows a simple internetwork consisting of four networks, each of which is served by a router. It is an adaptation of from , but in this case, the routing tables have been set up incorrectly. Router R1 thinks that it needs to route any traffic intended for Network N4 to Router R3, which thinks it goes to Router R2, which thinks it goes back to Router R1. This means that when any device tries to send to Network N4, the datagram will circle this triangle until its Hop Limit is reached, at which point an ICMPv6 Time Exceeded message will be generated." src="httpatomoreillycomsourcenostarchimages287993.png.jpg"/></div></div><p class="title">Figure 34-3. An example of a router loop This diagram shows a simple internetwork consisting of four networks, each of which is served by a router. It is an adaptation of <a class="xref" href="ch23s03.html#ip_routing_and_routing_tables_this_diagr" title="Figure 23-3. IP routing and routing tables This diagram shows a small, simple internetwork consisting of four LANs each served by a router. The routing table for each lists the router to which datagrams for each destination network should be sent. Notice that due to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.">Figure 23-3</a> from <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>, but in this case, the routing tables have been set up incorrectly. Router R1 thinks that it needs to route any traffic intended for Network N4 to Router R3, which thinks it goes to Router R2, which thinks it goes back to Router R1. This means that when any device tries to send to Network N4, the datagram will circle this triangle until its Hop Limit is reached, at which point an ICMPv6 Time Exceeded message will be generated.</p></div><div class="sect2" title="ICMPv6 Time Exceeded Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_time_exceeded_message_format"/>ICMPv6 Time Exceeded Message Format</h2></div></div></div><p><a class="xref" href="ch32s03.html#icmpv_time_exceeded_message_format" title="Table 32-4. ICMPv4 Time Exceeded Message Format">Table 32-4</a> and <a class="xref" href="ch34s03.html#icmpv6_time_exceeded_message_forma-id001" title="Figure 34-4. ICMPv6 Time Exceeded message format">Figure 34-4</a> show the format for <a class="indexterm" id="idx-CHP-34-1291"/>ICMPv6 <a class="indexterm" id="idx-CHP-34-1292"/>Time Exceeded messages.</p><div class="table"><a id="icmpv_time_exceeded_message_format-id001"/><p class="title">Table 34-4. ICMPv6 Time Exceeded Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Time Exceeded Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Time Exceeded messages, this is set to 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the subtype of time error that's being communicated. A value of 0 indicates expiration of the Hop Limit field; a value of 1 indicates that the fragment reassembly time has been exceeded.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unused</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes left blank and not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>As much of the IPv6 datagram as will fit without causing the size of the ICMPv6 error message (including its own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_time_exceeded_message_forma-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e37109"/><img alt="ICMPv6 Time Exceeded message format" src="httpatomoreillycomsourcenostarchimages287995.png.jpg"/></div></div><p class="title">Figure 34-4. ICMPv6 Time Exceeded message format</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-193"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Like their ICMPv4 namesakes, <a class="indexterm" id="idx-CHP-34-1293"/>ICMPv6 <a class="indexterm" id="idx-CHP-34-1294"/><span class="emphasis"><em>Time Exceeded</em></span> messages are sent in two different time-related circumstances. The first is if a datagram's <span class="emphasis"><em>Hop Limit</em></span> field is reduced to zero, thereby causing it to expire and the datagram to be dropped. The second is when all the pieces of a fragmented message are not received before the recipient's reassembly timer expires.</p></div></div><div class="sect2" title="Applications of Time Exceeded Messages"><div class="titlepage"><div><div><h2 class="title"><a id="applications_of_time_exceeded_mess-id001"/>Applications of Time Exceeded Messages</h2></div></div></div><p>In IPv4, ICMP Time Exceeded messages are used both as an error message and in a clever application to implement the TCP/IP traceroute command. This is done by first sending a dummy datagram with a TTL value of 1, thereby causing the first hop in the route to discard the datagram and send back an ICMP Time Exceeded message. Then a second datagram is sent to the same destination with a TTL value of 2, thus causing the second device in the route to report back a Time Exceeded message, and so on.</p><p>There is an IPv6 version of traceroute that is sometimes called <span class="emphasis"><em>traceroute6</em></span>. Due to the fact that IPv6 and its protocols and applications are still in development, I have not been able to confirm definitively that traceroute6 is implemented using ICMPv6 Time Exceeded messages in the manner described earlier, but I believe this is the case (and it certainly would make sense). See <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a> for more information about traceroute.</p></div></div>
<div class="sect1" title="ICMPv6 Parameter Problem Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_parameter_problem_messages"/>ICMPv6 Parameter Problem Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-34-1295"/>The ICMPv6 Destination Unreachable, Packet Too Big, and Time Exceeded messages described in the previous sections are used to indicate specific error conditions to the original sender of a datagram. Recognizing that a router or host may encounter some other problem in processing a datagram that is not covered by any of these message types, ICMPv6 includes a generic error message type, just as ICMPv4 did. This is called the ICMPv6 <span class="emphasis"><em>Parameter Problem</em></span> message.</p><p>As the name suggests, a Parameter Problem message indicates that a device found a problem with a parameter (another name for a datagram field) while attempting to work its way through the header (or headers) in an IPv6 datagram. This message is generated only when the error encountered is serious enough that the device could not make sense of the datagram and had to discard it. So, if an error is found that a device is able to recover from (does not need to drop the datagram), no Parameter Problem message is created.</p><p>As was the case for the ICMPv4 version of this message, the <a class="indexterm" id="idx-CHP-34-1296"/>ICMPv6 message was designed to be generic, so it can indicate an error in basically any field in the original datagram. A special Pointer field is used that points to the place in that datagram where the error was encountered. By looking at the structure of the original message (which, as you may recall, is included up to a certain size in the ICMP message format), the original device can tell which field contained the problem. The Code value is also used to communicate additional general information about the nature of the problem.</p><div class="sect2" title="ICMPv6 Parameter Problem Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_parameter_problem_message_format"/>ICMPv6 Parameter Problem Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-34-1297"/><a class="xref" href="ch34s04.html#icmpv_parameter_problem_message_fo-id001" title="Table 34-5. ICMPv6 Parameter Problem Message Format">Table 34-5</a> and <a class="xref" href="ch34s04.html#icmpv6_parameter_problem_message_f-id001" title="Figure 34-5. ICMPv6 Parameter Problem message format">Figure 34-5</a> show the format for ICMPv6 <a class="indexterm" id="idx-CHP-34-1298"/>Parameter Problem messages.</p><div class="table"><a id="icmpv_parameter_problem_message_fo-id001"/><p class="title">Table 34-5. ICMPv6 Parameter Problem Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Parameter Problem Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Parameter Problem messages, this is set to 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the general class of the parameter problem. See <a class="xref" href="ch34s04.html#icmpv_parameter_problem_message_in-id001" title="Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes">Table 34-6</a> for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pointer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>An offset that points to the byte location in the original datagram that caused the Parameter Problem message to be generated. The device receiving the ICMP message can use this value to get an idea of which field in the original message had the problem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Original Datagram Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>As much of the IPv6 datagram as will fit without causing the size of the ICMPv6 error message (including its own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_parameter_problem_message_f-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e37274"/><img alt="ICMPv6 Parameter Problem message format" src="httpatomoreillycomsourcenostarchimages287997.png"/></div></div><p class="title">Figure 34-5. ICMPv6 Parameter Problem message format</p></div></div><div class="sect2" title="Parameter Problem Message Interpretation Codes and the Pointer Field"><div class="titlepage"><div><div><h2 class="title"><a id="parameter_problem_message_interpre-id001"/>Parameter Problem Message Interpretation Codes and the Pointer Field</h2></div></div></div><p>The Pointer field, which was only 8 bits wide in ICMPv4, has been widened to 32 bits in ICMPv6 in order to provide more flexibility in isolating the error. The Code value is also used somewhat differently in ICMPv6 than it was in the ICMPv4 version of this message type. In ICMPv4, the Pointer was used only when the Code field was 0, and other code values indicated other problem categories for which the Pointer field did not make sense. In ICMPv6, the Pointer field is used with all Code types to indicate the general nature of what the problem is. This means the Pointer field tells the recipient of the Parameter Problem message where the problem happened in the message, and the Code field tells it what the nature of the problem is. <a class="xref" href="ch34s04.html#icmpv_parameter_problem_message_in-id001" title="Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes">Table 34-6</a> shows the three Code values and provides a brief explanation of each.</p><div class="table"><a id="icmpv_parameter_problem_message_in-id001"/><p class="title">Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Parameter Problem Message Interpretation Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Subtype</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Erroneous Header Field Encountered</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Pointer field points to a header that contains an error or otherwise could not be processed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unrecognized Next Header Type Encountered</p></td><td style="border-bottom: 0.5pt solid ; "><p>As explained in <a class="xref" href="ch26.html" title="Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 26</a>, in IPv6, a datagram can have multiple headers, each of which contains a Next Header field that points to the next header in the datagram. This code indicates that the Pointer field points to a Next Header field containing an unrecognized value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>Unrecognized IPv6 Option Encountered</p></td><td style=""><p>The Pointer field points to an IPv6 option that was not recognized by the processing device.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-194"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The ICMPv6 <span class="emphasis"><em>Parameter Problem</em></span> message is a generic error message that can be used to convey an error of any type in an IP datagram. The Pointer field is used to indicate where the problem was in the original datagram to the recipient of the message.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;35.&#xA0;ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_informational_message_types_and_f"/>Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e37350"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> In the previous chapter, we explored a number of Internet Control Message Protocol version 6 (ICMPv6) error messages. These are sent back to the originator of an Internet Protocol version 6 (IPv6) datagram when the originator detects an error it, thereby making it impossible for the error to be delivered. Like the original version of ICMP (ICMPv4), ICMPv6 also defines another message class: <span class="emphasis"><em>informational</em></span> messages. These ICMPv6 messages are used not to report errors, but to allow the sharing of information required to implement various test, diagnostic, and support functions critical to the operation of IPv6.</p><p>In this chapter, I describe eight different ICMPv6 <a class="indexterm" id="idx-CHP-35-1299"/>informational messages in five topics (six of these messages are used in matching pairs, and the pairs are described together). I begin by describing ICMPv6 Echo Request and Echo Reply messages, which are used for network connectivity testing. I explain the format of Router Advertisement and Router Solicitation messages, which are used to let hosts discover local routers and learn necessary parameters from them. I then describe ICMPv6 Neighbor Advertisement and Neighbor Solicitation messages, which are used for various communications between hosts on a local network, including IPv6 address resolution. I discuss IPv6 Redirect messages, which let routers inform hosts of better first-hop routers, and IPv6 Router Renumbering messages.</p><p>Several of the ICMPv6 informational messages include additional information that is either optional, recommended, or mandatory, depending on the circumstances under which the message is generated. Some of these are shared between message types, so they are described in a separate topic at the end of the chapter.</p><p>In IPv4, the use of many of the ICMP informational messages was described in a variety of different standards. In IPv6, many of the functions using informational messages have been gathered together and formalized in the IPv6 <span class="emphasis"><em>Neighbor Discovery (ND) protocol</em></span>. The solicitation and advertisement of local routers and neighboring hosts, as well as the communication of redirection information are both examples of activities for which ND is responsible. In fact, five of the ICMP messages described in this chapter are actually defined in the ND standard, RFC 2461.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-195"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>Neighbor Discovery (ND) and ICMPv6 are obviously closely related, given that ND describes the use of several of the ICMP messages: Router Advertisement, Router Solicitation, Neighbor Advertisement, Neighbor Solicitation, and Redirect. Thus, just as ICMPv4 is an important assistant to IPv4, both ICMPv6 and ND are important helpers for IPv6. In this book, I provide most of the description of how these messages are used in the next chapter, which discusses ND. In this chapter, I provide only a brief summary of their use, while focusing primarily on message format and the meaning of each of the fields in that format</em></span>.</p></div><div class="sect1" title="ICMPv6 Echo Request and Echo Reply Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_echo_request_and_echo_reply_messa"/>ICMPv6 Echo Request and Echo Reply Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-35-1300"/><a class="indexterm" id="idx-CHP-35-1301"/>IP is a relatively simple protocol that does not include any method for performing tests between devices to help in diagnosing internetwork problems. This means that this job, like other support tasks, falls to ICMP. The simplest test performed when there is a problem using TCP/IP is usually a check that a pair of devices is able to send datagrams to each other. This is most often done by an initiating device that sends a test message to a second device, which receives it and replies back to tell the first device it received the message.</p><p>Like ICMPv4, ICMPv6 includes a pair of messages specifically for connection testing. To use them, Device A begins the test process by sending an ICMPv4 <span class="emphasis"><em>Echo Request</em></span> message to Device B, which responds back to Device A with an <span class="emphasis"><em>Echo Reply</em></span> message. When Device A receives this message, it knows that it is able to communicate (both send and receive) successfully with Device B.</p><div class="note" title="Note"><h3 class="title"><a id="note-105"/>Note</h3><p><span class="emphasis"><em>In ICMPv4 the first message type was named just</em></span> Echo <span class="emphasis"><em>but was often called</em></span> Echo Request. <span class="emphasis"><em>In ICMPv6</em></span>, Request <span class="emphasis"><em>is part of the formal message name—a modest but useful improvement from a clarity standpoint</em></span>.</p></div><div class="sect2" title="ICMPv6 Echo and Echo Reply Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_echo_and_echo_reply_message_forma"/>ICMPv6 Echo and Echo Reply Message Format</h2></div></div></div><p>The format for ICMPv6 Echo Request and Echo Reply messages is very similar to that of the ICMPv4 version, as shown in <a class="xref" href="ch35.html#icmpv_echo_request_and_echo_reply_messag" title="Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format">Table 35-1</a> and <a class="xref" href="ch35.html#icmpv6_echo_request_and_echo_reply-id001" title="Figure 35-1. ICMPv6 Echo Request and Echo Reply message format">Figure 35-1</a>.</p><div class="table"><a id="icmpv_echo_request_and_echo_reply_messag"/><p class="title">Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Echo Request and Echo Reply Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for <a class="indexterm" id="idx-CHP-35-1302"/>Echo Request messages, the value is 128, and for Echo <a class="indexterm" id="idx-CHP-35-1303"/>Reply messages, it's 129. (In ICMPv6, informational messages always have a Type value of 128 or higher.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>An optional identification field that can be used to help in matching Echo Request and <a class="indexterm" id="idx-CHP-35-1304"/>Echo Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequence number to help in matching Echo Request and <a class="indexterm" id="idx-CHP-35-1305"/>Echo Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Optional Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Additional optional data to be sent along with the message. If this is sent in the Echo Request, it is copied into the Echo Reply to be sent back to the source.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_echo_request_and_echo_reply-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e37544"/><img alt="ICMPv6 Echo Request and Echo Reply message format" src="httpatomoreillycomsourcenostarchimages287999.png"/></div></div><p class="title">Figure 35-1. ICMPv6 Echo Request and Echo Reply message format</p></div><p>It is often necessary to match an Echo Reply message with the Echo Request message that led to it being generated. Two special fields are used within the format of these messages to allow Echo Request and Echo Reply messages to be matched together, and to allow a sequence of messages to be exchanged. The Identifier field is provided so that a particular test session can be identified, and the Sequence Number field allows a series of tests in a session to be numbered. The use of both fields is optional.</p></div><div class="sect2" title="Application of Echo and Echo Reply Messages"><div class="titlepage"><div><div><h2 class="title"><a id="application_of_echo_and_echo_reply-id001"/>Application of Echo and Echo Reply Messages</h2></div></div></div><p>ICMPv6 Echo Request and Echo Reply messages are used via the IPv6 version of the IP ping utility, which is commonly called <span class="emphasis"><em>ping6</em></span>. Like its IPv4 predecessor, this utility allows an administrator to configure a number of test options to perform either a simple or rigorous test of the connection between a pair of devices. See <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a> for a full explanation.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-196"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv6 <span class="emphasis"><em>Echo Request</em></span> and <span class="emphasis"><em>Echo Reply</em></span> messages are used to facilitate network reachability testing. A device tests its ability to communicate with another by sending it an Echo Request message and waiting for an Echo Reply in response. The <span class="emphasis"><em>ping</em></span> utility, a widely used diagnostic tool in TCP/IP internetworks, makes use of these messages.</p></div></div></div></div>
<div class="sect1" title="ICMPv6 Router Advertisement and Router Solicitation Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_router_advertisement_and_router_s"/>ICMPv6 Router Advertisement and Router Solicitation Messages</h1></div></div></div><p>At the highest level, we can separate IP devices into two groups: hosts and routers. Both participate in the use of the internetwork, but they have different roles. An important IP principle related to this division is that routers take care of routing—moving data between networks—while hosts generally don't need to worry about this job. Hosts rely on the routers on their local networks to facilitate communication to all other hosts except those on the local network.</p><p>The implications of this are clear: A host cannot really use an internetwork until it knows the identity of at least one local router and the method by which that router is to be used. In IPv4, a technique known as <span class="emphasis"><em>Router Discovery</em></span> was invented, which provides a means by which a host can locate a router and learn important parameters related to the operation of the local network. Router Discovery in IPv6 works in a very similar manner by having routers send <a class="indexterm" id="idx-CHP-35-1306"/><span class="emphasis"><em>Router Advertisement</em></span> messages both on a regular basis and in response to hosts prompting for them using <a class="indexterm" id="idx-CHP-35-1307"/><span class="emphasis"><em>Router Solicitation</em></span> messages. The Router Discovery function has been incorporated into the ND protocol, where it is part of a larger class of tools that I call <span class="emphasis"><em>host–Router Discovery</em></span> functions.</p><div class="sect2" title="ICMPv6 Router Advertisement Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_router_advertisement_message_form"/>ICMPv6 Router Advertisement Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1308"/><a class="indexterm" id="idx-CHP-35-1309"/>The ICMPv6 Router Advertisement and Router Solicitation messages are fairly similar to their counterparts in ICMPv4. The main differences are in the parameters that are communicated. Since routers are responsible for a few more functions in IPv6 than they are in IPv4, the Router Advertisement message in ICMPv6 has a few more fields than the older version.</p><p>The format of an ICMPv6 Router Advertisement message is described in <a class="xref" href="ch35s02.html#icmpv_router_advertisement_message-id001" title="Table 35-2. ICMPv6 Router Advertisement Message Format">Table 35-2</a> and shown in <a class="xref" href="ch35s02.html#icmpv6_router_advertisement_messag-id001" title="Figure 35-2. ICMPv6 Router Advertisement message format">Figure 35-2</a>.</p><div class="figure"><a id="icmpv6_router_advertisement_messag-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e37634"/><img alt="ICMPv6 Router Advertisement message format" src="httpatomoreillycomsourcenostarchimages288001.png.jpg"/></div></div><p class="title">Figure 35-2. ICMPv6 Router Advertisement message format</p></div><div class="table"><a id="icmpv_router_advertisement_message-id001"/><p class="title">Table 35-2. ICMPv6 Router Advertisement Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Router Advertisement Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1310"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Router Advertisement messages, the value is 134.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cur Hop Limit</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Current Hop Limit: This is a default number that the router recommends that hosts on the local network use as a value in the Hop Limit field of datagrams they send. If 0, the router is not recommending a Hop Limit value in this Router Advertisement.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Autoconfig Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Two flags that let the router tell the host how autoconfiguration is performed on the local network, as described in <a class="xref" href="ch35s02.html#icmpv_router_advertisement_message_autoc" title="Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags">Table 35-3</a>. (See <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> for details on IPv6 autoconfiguration.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the host receiving this message how long, in seconds, this router should be used as a default router. If 0, it tells the host this router should not be used as a default router. Note that this is an expiration interval only for the status of the router as a default, not for other information in the Router Advertisement message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reachable Time</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells hosts how long, in milliseconds, they should consider a neighbor to be reachable after they have received reachability confirmation. (See <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a> for more information.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retrans Timer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retransmission Timer: The amount of time, in milliseconds, that a host should wait before retransmitting Neighbor Solicitation messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Router Advertisement messages may contain three possible options (see the "ICMPv6 Informational Message Options" section later in this chapter for more on ICMPv6 options):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Source Link-Layer Address: Included when the router sending the Advertisement knows its link-layer (layer 2) address.</p></li><li class="listitem"><p>MTU: Used to tell local hosts the MTU of the local network when hosts on the network may not know this information.</p></li><li class="listitem"><p>Prefix Information: Tells local hosts what prefix or prefixes to use for the local network. (You'll recall that the "prefix" indicates which bits of an IPv6 address are the network identifier when compared to the host identifier; it is thus analogous to an IPv4 subnet mask.)</p></li></ul></div>
</td></tr></tbody></table></div></div><div class="table"><a id="icmpv_router_advertisement_message_autoc"/><p class="title">Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Router Advertisement Message Autoconfiguration Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Managed Address Configuration Flag: When set, this flag tells hosts to use an administered or stateful method for address autoconfiguration, such as the Dynamic Host Configuration Protocol (DHCP).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>O</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Other Stateful Configuration Flag: When set, this tells hosts to use an administered or stateful autoconfiguration method for information other than addresses.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>6/8 (6 bits)</p></td><td style=""><p>Reserved for future use; sent as zeros.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="ICMPv6 Router Solicitation Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_router_solicitation_message_forma"/>ICMPv6 Router Solicitation Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1311"/>The format of an ICMPv6 Router Solicitation message is shown in <a class="xref" href="ch35s02.html#icmpv_router_solicitation_message_-id001" title="Table 35-4. ICMPv6 Router Solicitation Message Format">Table 35-4</a> and <a class="xref" href="ch35s02.html#icmpv6_router_solicitation_message-id001" title="Figure 35-3. ICMPv6 Router Solicitation message format">Figure 35-3</a>.</p><div class="table"><a id="icmpv_router_solicitation_message_-id001"/><p class="title">Table 35-4. ICMPv6 Router Solicitation Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Router Solicitation Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1312"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Router Solicitation messages, the value is 133.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 reserved bytes set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>If the device sending the Router Solicitation knows its layer 2 address, it should be included in a Source Link-Layer Address option. Option formats are described in the "ICMPv6 Informational Message Options" section later in this chapter.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_router_solicitation_message-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e37921"/><img alt="ICMPv6 Router Solicitation message format" src="httpatomoreillycomsourcenostarchimages288003.png"/></div></div><p class="title">Figure 35-3. ICMPv6 Router Solicitation message format</p></div></div><div class="sect2" title="Addressing of Router Advertisement and Router Solicitation Messages"><div class="titlepage"><div><div><h2 class="title"><a id="addressing_of_router_advertisement_and_r"/>Addressing of Router Advertisement and Router Solicitation Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1313"/>Router Solicitation messages are normally sent to the IPv6 "all routers" multicast address; this is the most efficient method, because routers are required to subscribe to this multicast address while hosts will ignore it. A routine (unsolicited) Router Advertisement message is sent to all devices using the "all nodes" multicast address for the local network. A Router Advertisement message that is sent in response to a Router Solicitation message goes in unicast back to the device that sent the solicitation.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-197"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv6 <span class="emphasis"><em>Router Advertisement</em></span> messages are sent regularly by IPv6 routers to inform hosts of their presence and characteristics, and to provide hosts with parameters that they need to function properly on the local network. A host that wants to find out immediately which routers are present may send a <span class="emphasis"><em>Router Solicitation</em></span> message, which will prompt listening routers to send out Router Advertisements.</p></div></div></div>
<div class="sect1" title="ICMPv6 Neighbor Advertisement and Neighbor Solicitation Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_neighbor_advertisement_and_neighb"/>ICMPv6 Neighbor Advertisement and Neighbor Solicitation Messages</h1></div></div></div><p>The previous section described the Router Advertisement and Router Solicitation messages, which are used to facilitate host–Router Discovery functions as part of the IPv6 ND protocol. The other main group of tasks for which ND is responsible relates to the exchange of information between neighboring hosts on the same network. I call these <span class="emphasis"><em>host-host communication</em></span> or <span class="emphasis"><em>host-host discovery</em></span> functions.</p><p>Arguably, the most important additions to the ND protocol are the functions that formalize the exchange of parameters and the methods that determine the existence of neighboring hosts. These tasks include the new method of address resolution in IPv6 as well as the processes of next-hop determination and neighbor unreachability detection. They require the use of two ICMPv6 messages: the <a class="indexterm" id="idx-CHP-35-1314"/><span class="emphasis"><em>Neighbor Solicitation message</em></span> and the <a class="indexterm" id="idx-CHP-35-1315"/><span class="emphasis"><em>Neighbor Advertisement message</em></span>.</p><p>The <a class="indexterm" id="idx-CHP-35-1316"/>Neighbor Solicitation message allows a device to check that a neighbor exists and is reachable, and lets a device initiate address resolution. The <a class="indexterm" id="idx-CHP-35-1317"/>Neighbor Advertisement message confirms the existence of a host or router, and also provides layer 2 address information when needed. As you can see, these two messages are comparable to the Router Advertisement and Router Solicitation messages, but they are used differently and include different parameters.</p><div class="sect2" title="ICMPv6 Neighbor Advertisement Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_neighbor_advertisement_message_fo"/>ICMPv6 Neighbor Advertisement Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1318"/>The format for the Neighbor Advertisement message is shown in <a class="xref" href="ch35s03.html#icmpv_neighbor_advertisement_message_for" title="Table 35-5. ICMPv6 Neighbor Advertisement Message Format">Table 35-5</a> and <a class="xref" href="ch35s03.html#icmpv6_neighbor_advertisement_mess-id001" title="Figure 35-4. ICMPv6 Neighbor Advertisement message format">Figure 35-4</a>.</p><div class="table"><a id="icmpv_neighbor_advertisement_message_for"/><p class="title">Table 35-5. ICMPv6 Neighbor Advertisement Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Neighbor Advertisement Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1319"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Neighbor Advertisement messages, the value is 136.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Three flags that convey information about the message (and a lot of empty space for future use), as described in <a class="xref" href="ch35s03.html#icmpv_neighbor_advertisement_message_fla" title="Table 35-6. ICMPv6 Neighbor Advertisement Message Flags">Table 35-6</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Target Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>If the Neighbor Advertisement is being sent in response to a Neighbor Solicitation, this is the same value as in the Target Address field of the Solicitation. This field will commonly contain the IPv6 address of the device, thereby sending the Neighbor Advertisement, but not in all cases. For example, if a device responds as a proxy for the target of the Neighbor Solicitation, the Target Address field contains the address of the target, not the device sending the response. (See <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a> for details on address resolution proxying.) If the Neighbor Advertisement is being sent unsolicited, then this is the IPv6 address of the device sending it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>When sent in response to a multicast Neighbor Solicitation, a Neighbor Advertisement message must contain a Target Link-Layer Address option, which carries the link-layer address of the device sending the message. This is a good example of an option that's not really "optional." When the Neighbor Advertisement is sent in response to a unicast Neighbor Solicitation, this option is technically not required (since the sender of the Solicitation must already have the target's link-layer address to have sent it unicast). Despite this, it is still normally included to ensure that the link-layer address of the target is refreshed in the cache of the device that sent the Neighbor Solicitation.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_neighbor_advertisement_mess-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38103"/><img alt="ICMPv6 Neighbor Advertisement message format" src="httpatomoreillycomsourcenostarchimages288005.png.jpg"/></div></div><p class="title">Figure 35-4. ICMPv6 Neighbor Advertisement message format</p></div><div class="table"><a id="icmpv_neighbor_advertisement_message_fla"/><p class="title">Table 35-6. ICMPv6 Neighbor Advertisement Message Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Neighbor Advertisement Message Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Router Flag: Set when a router sends a Neighbor Advertisement, and cleared when a host sends one. This identifies the type of device that sent the datagram, and is also used as part of neighbor unreachability detection to detect when a device changes from acting as a router to functioning as a regular host.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>S</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Solicited Flag: When set, indicates that this message was sent in response to a Neighbor Solicitation message. Cleared for unsolicited Neighbor Advertisements.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>O</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Override Flag: When set, tells the recipient that the information in this message should override any existing cached entry for the link-layer address of this device. This bit is normally set in unsolicited Neighbor Advertisements, since these are sent when a host needs to force a change of information in the caches of its neighbors.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>3 5/8 (29 bits)</p></td><td style=""><p>A big set of reserved bits.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="ICMPv6 Neighbor Solicitation Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_neighbor_solicitation_message_for"/>ICMPv6 Neighbor Solicitation Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1320"/>The Neighbor Solicitation <a class="indexterm" id="idx-CHP-35-1321"/>message format is much simpler, as shown in <a class="xref" href="ch35s03.html#icmpv_neighbor_solicitation_message_form" title="Table 35-7. ICMPv6 Neighbor Solicitation Message Format">Table 35-7</a> and <a class="xref" href="ch35s03.html#icmpv6_neighbor_solicitation_messa-id001" title="Figure 35-5. ICMPv6 Neighbor Solicitation message format">Figure 35-5</a>.</p><div class="table"><a id="icmpv_neighbor_solicitation_message_form"/><p class="title">Table 35-7. ICMPv6 Neighbor Solicitation Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Neighbor Solicitation Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Neighbor Solicitation messages, the value is 135.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 reserved bytes set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Target Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IPv6 address of the target of the solicitation. For IPv6 address resolution, this is the actual unicast IP address of the device whose layer 2 (link-layer) address we are trying to resolve.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>If the device sending the Neighbor Solicitation knows both its own IP address and layer 2 address, it should include the layer 2 address in a Source Link-Layer Address option. The inclusion of this option will allow the destination of the Neighbor Solicitation to enter the layer 2 and layer 3 addresses of the source of this message into its own address cache. (See the discussion of IPv6 address resolution in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>.)</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_neighbor_solicitation_messa-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38277"/><img alt="ICMPv6 Neighbor Solicitation message format" src="httpatomoreillycomsourcenostarchimages288007.png"/></div></div><p class="title">Figure 35-5. ICMPv6 Neighbor Solicitation message format</p></div></div><div class="sect2" title="Addressing of Neighbor Advertisement and Neighbor Solicitation Messages"><div class="titlepage"><div><div><h2 class="title"><a id="addressing_of_neighbor_advertisement_and"/>Addressing of Neighbor Advertisement and Neighbor Solicitation Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1322"/><a class="indexterm" id="idx-CHP-35-1323"/>Neighbor Solicitation messages are sent either unicast to the address of the target device or to the solicited-node multicast address of the target. This latter address is a special type that's used to allow a device to send a multicast that will be heard by the target whose address it is trying to resolve, but won't be heard by most other devices; it is explained in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>, which describes IPv6 address resolution.</p><p>When a Neighbor Advertisement message is generated in response to a Neighbor Solicitation message, it is sent unicast back to the device that sent the Solicitation message, unless that message was sent from the unspecified address, in which case it is multicast to the "all nodes" multicast address. If the Neighbor Advertisement message is sent unsolicited (for example, by a device that wishes to inform others of a change in link-layer address), it is sent to the "all nodes" multicast address.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-198"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <a class="indexterm" id="idx-CHP-35-1324"/>ICMPv6 <span class="emphasis"><em>Neighbor Advertisement</em></span> and <span class="emphasis"><em>Neighbor Solicitation</em></span> messages are similar in many ways to the Router Advertisement and Router Solicitation messages. However, rather than being used to communicate parameters from routers to hosts, they are used for various types of communication between hosts on a physical network, such as address resolution, next-hop determination, and neighbor unreachability detection.</p></div></div></div>
<div class="sect1" title="ICMPv6 Redirect Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_redirect_messages"/>ICMPv6 Redirect Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-35-1325"/><a class="indexterm" id="idx-CHP-35-1326"/>Because of the different roles of routers and hosts in an IPv6 internetwork, hosts don't need to know very much about routes. They send datagrams intended for destinations on the local network directly, while they send those for other networks to their local routers and let them "do the driving," so to speak.</p><p>If a local network has only a single router, it will send all such nonlocal traffic to that router. If it has more than one local router, the host then must decide which router to use for which traffic. In general terms, a host will not know the most efficient choice of router for every type of datagram it may need to send. In fact, many nodes start out with a limited routing table that says to send <span class="emphasis"><em>everything</em></span> to a single default router, even if there are several routers on the network.</p><p>When a router receives datagrams destined for certain networks, it may realize that it would be more efficient if a host to a different router on the local network sent such traffic. If so, it will invoke the <a class="indexterm" id="idx-CHP-35-1327"/>Redirect function by sending an ICMPv6 <span class="emphasis"><em>Redirect</em></span> message to the device that sent the original datagram. This is the last of the functions that is performed in IPv6 by the ND protocol and is explained in <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a>.</p><div class="note" title="Note"><h3 class="title"><a id="note-106"/>Note</h3><p><span class="emphasis"><em>In ICMPv6, the Redirect message is informational and no longer considered an error message as it was in ICMPv4</em></span>.</p></div><div class="sect2" title="ICMPv6 Redirect Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_redirect_message_format"/>ICMPv6 Redirect Message Format</h2></div></div></div><p>The format of ICMPv6 Redirect messages is shown in <a class="xref" href="ch35s04.html#icmpv_redirect_message_format-id001" title="Table 35-8. ICMPv6 Redirect Message Format">Table 35-8</a> and <a class="xref" href="ch35s04.html#icmpv6_redirect_message_format-id001" title="Figure 35-6. ICMPv6 Redirect message format">Figure 35-6</a>.</p><div class="table"><a id="icmpv_redirect_message_format-id001"/><p class="title">Table 35-8. ICMPv6 Redirect Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Redirect Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Redirect messages, the value is 137.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 bytes sent as zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Target Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of the router that the router creating the <a class="indexterm" id="idx-CHP-35-1328"/>Redirect is telling the recipient of the Redirect to use as a first hop for future transmissions to the destination. For example, if Router R2 generated a Redirect telling Host A that, in the future, transmissions to Host B should be sent first to Router R1, then Router R1's IPv6 address would be in this field.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of the device whose future transmissions are being redirected; this is the destination of the datagram that originally led to the Redirect being generated. Repeating the previous example: If Router R2 generated a Redirect telling Host A that, in the future, transmissions to Host B should be sent first to Router R1, then Host B's IPv6 address would be in this field.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Redirect messages normally include two ICMPv6 option fields (see the "ICMPv6 Informational Message Options" section later in this chapter):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Target Link-Layer Address: The layer 2 address of the Target Address, if known. This saves the recipient of the Redirect message from needing to perform an address resolution on the target.</p></li><li class="listitem"><p>Redirected Header: As much of the IPv6 datagram that spawned this Redirect as will fit without causing the size of the ICMPv6 error message (including its own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.</p></li></ul></div>
</td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_redirect_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38480"/><img alt="ICMPv6 Redirect message format" src="httpatomoreillycomsourcenostarchimages288009.png"/></div></div><p class="title">Figure 35-6. ICMPv6 Redirect message format</p></div><p>Redirect messages are always sent in unicast to the address of the device that originally sent the datagram that originally created the Redirect message.</p></div><div class="sect2" title="Application of Redirect Messages"><div class="titlepage"><div><div><h2 class="title"><a id="application_of_redirect_messages"/>Application of Redirect Messages</h2></div></div></div><p>The Redirect message has always been somewhat of an oddball. In ICMPv4, it is considered an error message, but this makes it different from other error messages. For one thing, it's not really an error, since it doesn't represent a failure to deliver, only an inefficiency in doing so. For this reason, in ICMPv6 it was moved into the set of informational message types. Here, too, it doesn't really fit in with the others, since it is sent in reaction to a regular IP message, and it also includes a copy of (part of) the datagram that spawned it, as error messages do.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-199"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ICMPv6 <span class="emphasis"><em>Redirect</em></span> messages are used by a router to inform a host of a better router to use for future datagrams that were sent to a particular host or network. They are not used to alter routes between routers, however.</p></div></div></div>
<div class="sect1" title="ICMPv6 Router Renumbering Messages"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_router_renumbering_messages"/>ICMPv6 Router Renumbering Messages</h1></div></div></div><p><a class="indexterm" id="idx-CHP-35-1329"/>One of the more interesting decisions made in <a class="indexterm" id="idx-CHP-35-1330"/>IPv6 was the selection of a very large 128-bit address size. This provides an address space far larger than what humans are ever likely to need, and probably larger than needed for IPv6, strictly speaking. What this wealth of bits provides is the flexibility to assign meaning to different bits in the address structure. This, in turn, serves as the basis for important features such as the autoconfiguration and automated renumbering of IPv6 addresses.</p><div class="sect2" title="IPv6 Router Renumbering"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_router_renumbering"/>IPv6 Router Renumbering</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1331"/>The renumbering feature in IPv6 is of particular interest to network administrators, since it has the potential to make large network migrations and merges much simpler. In August 2000, the IETF published RFC 2894, "<a class="indexterm" id="idx-CHP-35-1332"/>Router Renumbering for IPv6," which describes a similar technique that allows routers in an autonomous system to be renumbered by giving them new prefixes (network identifiers).</p><p>Router renumbering is actually a fairly simple process, especially if we avoid the gory details, which is exactly what I intend to do. A network administrator uses a device on the internetwork to generate one or more <span class="emphasis"><em>Router Renumbering Command</em></span> messages. These messages provide a list of prefixes of routers that are to be renumbered. Each router processes these messages to see if the addresses on any of their interfaces match the specified prefixes. If so, they change the matched prefixes to the new ones specified in the message. Additional information is also included in the Router Renumbering Command message to control how and when the renumbering is done.</p><p>If requested, each router processing a Command message will respond with a <span class="emphasis"><em>Router Renumbering Result</em></span> message. This serves as feedback to the originator of the Command message, indicating whether the renumbering was successful, and what changes, if any, were made.</p><p>The router renumbering standard also defines a few important management features. Many of these reflect the great power of something that can mass-renumber routers, and hence, they represent the potential for such power to be abused. Command messages may be sent in a test mode, in which they are processed but the renumbering is not actually done. Messages include a sequence number to guard against replay attacks, and a special <span class="emphasis"><em>Sequence Number Reset</em></span> message can be used to reset the sequence number information that was previously sent. For added security, the standard specifies that messages be authenticated and have their identity checked.</p></div><div class="sect2" title="ICMPv6 Router Renumbering Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_router_renumbering_message_format"/>ICMPv6 Router Renumbering Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1333"/>The format of <a class="indexterm" id="idx-CHP-35-1334"/>Router Renumbering messages is shown in <a class="xref" href="ch35s05.html#icmpv_router_renumbering_message_format" title="Table 35-9. ICMPv6 Router Renumbering Message Format">Table 35-9</a> and <a class="xref" href="ch35s05.html#icmpv6_router_renumbering_message_-id001" title="Figure 35-7. ICMPv6 Router Renumbering message format">Figure 35-7</a>.</p><div class="figure"><a id="icmpv6_router_renumbering_message_-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38570"/><img alt="ICMPv6 Router Renumbering message format" src="httpatomoreillycomsourcenostarchimages288011.png.jpg"/></div></div><p class="title">Figure 35-7. ICMPv6 Router Renumbering message format</p></div><div class="table"><a id="icmpv_router_renumbering_message_format"/><p class="title">Table 35-9. ICMPv6 Router Renumbering Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Router Renumbering Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1335"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 message type; for Router Renumbering messages, the value is 138.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the subtype of Router Renumbering message:</p>
<p>0 = Router Renumbering Command</p>
<p>1 = Router Renumbering Result</p>
<p>255 = Sequence Number Reset</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum field for the ICMP header (see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 32-bit number that guards against replay attacks by letting a recipient detect stale, duplicate, or out-of-order commands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Segment Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Differentiates between valid Router Renumbering messages within the same Sequence Number.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Five flags used to control the renumbering process, as described in <a class="xref" href="ch35s05.html#icmpv_router_renumbering_message_flags" title="Table 35-10. ICMPv6 Router Renumbering Message Flags">Table 35-10</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Max Delay</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells a router receiving a message the maximum amount of time (in milliseconds) it is allowed to delay before sending a reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 reserved bytes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Message Body</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>For a Router Renumbering Command, the message body contains two sets of information. The first is a Match-Prefix Part for the prefix being renumbered. The second is one or more Use-Prefix Parts that describe the new prefix for each match. A router receiving a Command checks its own interface addresses, and if they match the Match-Prefix-Part, they use Use-Prefix Parts data to accomplish the renumbering.</p>
<p>For a Router Renumbering Result, the message body contains zero or more Match Results entries that describe each prefix that a router has matched from a Router Renumbering Command. Each entry provides information about whether renumbering for a prefix was successful.</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch35s05.html#icmpv_router_renumbering_message_flags" title="Table 35-10. ICMPv6 Router Renumbering Message Flags">Table 35-10</a> shows the Router Renumbering Message flags. The first four flags (T, R, A, and S) control the operation of Command messages. They are just copied verbatim in a Result message from the Command message that led to the Result message being created. The P flag is used only in Result messages (0 in Command messages).</p><div class="table"><a id="icmpv_router_renumbering_message_flags"/><p class="title">Table 35-10. ICMPv6 Router Renumbering Message Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Router Renumbering Message Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Test Command Flag: When set to 1, this flags this Command messageas being a test message. This tells the recipient to only simulate processing of the renumbering, not to actually do it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Result Requested Flag: When set to 1, requests that a Result message be sent after processing the Command message. When set to 0, says not to send one.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>All Interfaces Flag: When this flag is clear (0), the Command message is not applied to any router interfaces that have been administratively shut down. When 1, it is applied to all interfaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>S</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Site-Specific Flag: This flag has meaning only when a router treats its interfaces as belonging to different sites. If so, a value of 1 tells it to apply the Command message only to interfaces on the same site as the interface for which the Command message was received. A value of 0 applies it to all interfaces regardless of site.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>P</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Processed Previously Flag: This flag is normally 0, meaning the Command message was not previously seen and the Result message contains the report of processing it. When 1, this indicates that the recipient of the Command message believes it has seen it before and is not processing it. (Test commands are not included in the assessment of whether a Command message has been seen before.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>3/8 (3 bits)</p></td><td style=""><p>Three bits reserved for future flags.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Addressing of Router Renumbering Messages"><div class="titlepage"><div><div><h2 class="title"><a id="addressing_of_router_renumbering_message"/>Addressing of Router Renumbering Messages</h2></div></div></div><p>Since Router Renumbering messages are intended for all routers on a site, they are normally sent to the "all routers" multicast address, using either link-local or site-local scope. They may also be sent to local unicast addresses.</p></div></div>
<div class="sect1" title="ICMPv6 Informational Message Options"><div class="titlepage"><div><div><h1 class="title"><a id="icmpv6_informational_message_options"/>ICMPv6 Informational Message Options</h1></div></div></div><p><a class="indexterm" id="idx-CHP-35-1336"/>Each of the five ICMPv6 informational message types defined and used by the protocol has an Options field into which one or more options may be inserted. This probably isn't the best name for these sets of data, since they are only optional in certain cases. In fact, in some cases the option is actually the entire point of the message. For example, a Neighbor Advertisement message containing a link-layer address for address resolution carries it in an Options field, but the message wouldn't be of much use without it!</p><p>Each option has its own structure of subfields based on the classic type, length, and value triplet used in many message formats. The Type subfield indicates the option type, and the Length field indicates its length, so that the device processing the option can determine where it ends. The value may be contained in one or more fields, which hold the actual information for which the option is being used.</p><p>Some options are used for only one kind of ICMPv6 message; others are used for more than one variety. So, they are best thought of as modular components used in different types of messages as needed. I describe the format of each of these five options in the following sections.</p><div class="sect2" title="Source Link-Layer Address Option Format"><div class="titlepage"><div><div><h2 class="title"><a id="source_link-layer_address_option_format"/>Source Link-Layer Address Option Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1337"/>The <a class="indexterm" id="idx-CHP-35-1338"/>Source Link-Layer Address Option carries the link-layer address of a device sending an ICMPv6 message, as shown in <a class="xref" href="ch35s06.html#icmpv_source_link-layer_address_option_f" title="Table 35-11. ICMPv6 Source Link-Layer Address Option Format">Table 35-11</a> and <a class="xref" href="ch35s06.html#icmpv6_source_link-layer_address_option_" title="Figure 35-8. ICMPv6 Source Link-Layer Address option format">Figure 35-8</a>. It's used in Router Advertisement, Router Solicitation, and Neighbor Solicitation messages.</p><div class="table"><a id="icmpv_source_link-layer_address_option_f"/><p class="title">Table 35-11. ICMPv6 Source Link-Layer Address Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Source Link-Layer Address Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1339"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 option type. For the <a class="indexterm" id="idx-CHP-35-1340"/>Source Link-Layer Address option, the value is 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the entire option (including the Type and Length fields), expressed in units of 8 octets (64 bits).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1341"/>Source Link-Layer Address</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The link-layer (layer 2) address of the device sending the ICMPv6 message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_source_link-layer_address_option_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38901"/><img alt="ICMPv6 Source Link-Layer Address option format" src="httpatomoreillycomsourcenostarchimages288013.png.jpg"/></div></div><p class="title">Figure 35-8. ICMPv6 Source Link-Layer Address option format</p></div></div><div class="sect2" title="Target Link-Layer Address Option Format"><div class="titlepage"><div><div><h2 class="title"><a id="target_link-layer_address_option_format"/>Target Link-Layer Address Option Format</h2></div></div></div><p>The <a class="indexterm" id="idx-CHP-35-1342"/>Target Link-Layer Address option carries the link-layer address corresponding to the Target Address field in Neighbor Advertisement and Redirect messages. Its format is shown in <a class="xref" href="ch35s06.html#icmpv_target_link-layer_address_option_f" title="Table 35-12. ICMPv6 Target Link-Layer Address Option Format">Table 35-12</a> and <a class="xref" href="ch35s06.html#icmpv6_target_link-layer_address_option_" title="Figure 35-9. ICMPv6 Target Link-Layer Address option format">Figure 35-9</a>.</p><div class="table"><a id="icmpv_target_link-layer_address_option_f"/><p class="title">Table 35-12. ICMPv6 Target Link-Layer Address Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Target Link-Layer Address Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1343"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 option type. For the <a class="indexterm" id="idx-CHP-35-1344"/>Target Link-Layer Address option, the value is 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the entire option (including the Type and Length fields), expressed in units of 8 octets (64 bits).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1345"/>Target Link-Layer Address</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The link-layer (layer 2) address of the target device.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_target_link-layer_address_option_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e38989"/><img alt="ICMPv6 Target Link-Layer Address option format" src="httpatomoreillycomsourcenostarchimages288015.png.jpg"/></div></div><p class="title">Figure 35-9. ICMPv6 Target Link-Layer Address option format</p></div></div><div class="sect2" title="Prefix Information Option Format"><div class="titlepage"><div><div><h2 class="title"><a id="prefix_information_option_format"/>Prefix Information Option Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1346"/><a class="indexterm" id="idx-CHP-35-1347"/>The <a class="indexterm" id="idx-CHP-35-1348"/><span class="emphasis"><em>Prefix Information</em></span> option provides a prefix and related information in Router Advertisement messages. This is the longest and most complex of the options, as you can see in <a class="xref" href="ch35s06.html#icmpv_prefix_information_option_format" title="Table 35-13. ICMPv6 Prefix Information Option Format">Table 35-13</a> and <a class="xref" href="ch35s06.html#icmpv6_prefix_information_option_format" title="Figure 35-10. ICMPv6 Prefix Information option format">Figure 35-10</a>.</p><div class="table"><a id="icmpv_prefix_information_option_format"/><p class="title">Table 35-13. ICMPv6 Prefix Information Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Prefix Information Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1349"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 option type. For the <a class="indexterm" id="idx-CHP-35-1350"/>Prefix Information option, the value is 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the entire option (including the Type and Length fields), expressed in units of 8 octets (64 bits). The Prefix Information option is fixed in size at 32 bytes, so the value of the Length field is 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of bits in the Prefix field that are considered part of the network identifier (the remainder are used for the host identifier and ignored). See <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> for details on prefix lengths.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A pair of flags that convey information about the prefix, as described in <a class="xref" href="ch35s06.html#icmpv_prefix_information_option_flags" title="Table 35-14. ICMPv6 Prefix Information Option Flags">Table 35-14</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Valid Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The amount of time, in seconds, that the recipient of the message containing this option should consider the prefix valid for purposes of on-link determination (see the description of the L flag in <a class="xref" href="ch35s06.html#icmpv_prefix_information_option_flags" title="Table 35-14. ICMPv6 Prefix Information Option Flags">Table 35-14</a>). A value of all 1s means infinity (forever).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Preferred Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>When the recipient of this prefix uses it to automatically generate addresses using address autoconfiguration, this specifies the amount of time, in seconds, that such addresses remain preferred (meaning, valid and freely usable). A value of all 1s means infinity (forever).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 4 unused bytes sent as zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Prefix</p></td><td style="border-right: 0.5pt solid ; "><p>16</p></td><td style=""><p>The prefix being communicated from the router to the host in the Router Advertisement message. The Prefix Length field indicates how many of the 128 bits in this field are significant (part of the network ID). Only these bits are placed in the Prefix field; the remaining bits are cleared to zero.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_prefix_information_option_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e39142"/><img alt="ICMPv6 Prefix Information option format" src="httpatomoreillycomsourcenostarchimages288017.png"/></div></div><p class="title">Figure 35-10. ICMPv6 Prefix Information option format</p></div><div class="table"><a id="icmpv_prefix_information_option_flags"/><p class="title">Table 35-14. ICMPv6 Prefix Information Option Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Prefix Information Option Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-35-1351"/>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>On-Link Flag: When set to 1, tells the recipient of the option that this prefix can be used for on-link determination. This means the prefix can be used for deciding whether or not an address is <span class="emphasis"><em>on-link</em></span> (on the recipient's local network). When 0, the sender is making no statement regarding whether the prefix can be used for this or not.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Autonomous Address-Configuration Flag: When set to 1, specifies that this prefix can be used for IPv6 address autoconfiguration. (See <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> for details on IPv6 autoconfiguration.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>6/8 (6 bits)</p></td><td style=""><p>6 leftover bits reserved and sent as zeros.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Redirected Header Option Format"><div class="titlepage"><div><div><h2 class="title"><a id="redirected_header_option_format"/>Redirected Header Option Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-35-1352"/>In a Redirect message, the <a class="indexterm" id="idx-CHP-35-1353"/><span class="emphasis"><em>Redirected Header</em></span> option provides a copy of the original message (or a portion of it) that led to the Redirect message being generated. This option's format is shown in <a class="xref" href="ch35s06.html#icmpv_redirected_header_option_format" title="Table 35-15. ICMPv6 Redirected Header Option Format">Table 35-15</a> and <a class="xref" href="ch35s06.html#icmpv6_redirected_header_option_format" title="Figure 35-11. ICMPv6 Redirected Header option format">Figure 35-11</a>.</p><div class="table"><a id="icmpv_redirected_header_option_format"/><p class="title">Table 35-15. ICMPv6 Redirected Header Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 Redirected Header Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 option type. For the Redirected Header option, the value is 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the entire option (including the Type and Length fields), expressed in units of 8 octets (64 bits).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 6 reserved bytes sent as zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>IP Header + Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>As much of the original IPv6 datagram as will fit without causing the size of the ICMPv6 error message (including its own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_redirected_header_option_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e39292"/><img alt="ICMPv6 Redirected Header option format" src="httpatomoreillycomsourcenostarchimages288019.png"/></div></div><p class="title">Figure 35-11. ICMPv6 Redirected Header option format</p></div></div><div class="sect2" title="MTU Option Format"><div class="titlepage"><div><div><h2 class="title"><a id="mtu_option_format"/>MTU Option Format</h2></div></div></div><p>The <span class="emphasis"><em>MTU</em></span> option lets a router convey a recommended MTU value in Router Advertisement messages. Its format is shown in <a class="xref" href="ch35s06.html#icmpv_mtu_option_format" title="Table 35-16. ICMPv6 MTU Option Format">Table 35-16</a> and <a class="xref" href="ch35s06.html#icmpv6_mtu_option_format" title="Figure 35-12. ICMPv6 MTU option format">Figure 35-12</a>.</p><div class="table"><a id="icmpv_mtu_option_format"/><p class="title">Table 35-16. ICMPv6 MTU Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ICMPv6 MTU Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the ICMPv6 option type. For the MTU option, the value is 5.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the entire option (including the Type and Length fields), expressed in units of 8 octets (64 bits). The MTU option is fixed in length at 8 bytes, so the value of this field is 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 2 reserved bytes sent as zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>MTU</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The MTU value, in bytes, that the router is recommending for use on the local link.</p></td></tr></tbody></table></div></div><div class="figure"><a id="icmpv6_mtu_option_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e39371"/><img alt="ICMPv6 MTU option format" src="httpatomoreillycomsourcenostarchimages288021.png.jpg"/></div></div><p class="title">Figure 35-12. ICMPv6 MTU option format</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;36.&#xA0;IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_neighbor_discovery_nd_protocol"/>Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e39381"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The new Internet Protocol version 6 (IPv6) represents an evolution of the venerable IP. It maintains the same basic operational principles of IPv4, but makes some important modifications, particularly in the area of addressing. In fact, some of the more significant changes in IPv6 are actually not in IP itself, but in the protocols that support IP. One of the most interesting of these was the creation of an entirely new support protocol for IPv6. It combines several tasks previously performed by other protocols in IPv4, adds some new functions, <a class="indexterm" id="idx-CHP-36-1354"/>and makes numerous improvements to the whole package. This new standard is called the IPv6 <span class="emphasis"><em>Neighbor Discovery (ND)</em></span> protocol.</p><p>In this chapter, I describe the new ND protocol used in IPv6. I begin with an overview of the protocol, discussing its history, the motivation for its creation, and the standards that define it. I then describe its operation in general terms, listing the fundamental functions that ND performs, the three groups these functions fit into, and the Internet Control Message Protocol version 6 (ICMPv6) message types used to carry them out. I describe the key differences between <a class="indexterm" id="idx-CHP-36-1355"/>ND and the way that its functions were carried out in IPv4. I then provide more information on the three functional groups in ND: those that involve discovery of important internetwork information from routers, those that are related to address resolution and neighbor communication between hosts, and finally, those involved with router redirection.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-200"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This chapter assumes basic comprehension of IPv6, which, in turn, requires understanding IPv4. ND uses ICMPv6 messages, so I reference Chapters <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a> to <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a>, which discuss them. Finally, since ICMP performs some of the functions done by the Address Resolution Protocol (ARP) in IPv4, you may need to refer to <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a> if you're unfamiliar with ARP's operation</em></span>.</p></div><div class="sect1" title="IPv6 ND Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_overview"/>IPv6 ND Overview</h1></div></div></div><p>The purpose of network layer protocols like IP is to provide a means of connecting together individual local networks to create a much larger internetwork. To higher-layer protocols and to users, this internetwork behaves in most respects as if it were a single large network, because the lower layers hide the details that hold together the individual networks. Any device can send information to any other regardless of where it is located, and like magic, it will work—at least most of the time.</p><p>The existence of an internetwork means that devices can treat all other devices as peers, at least from the perspective of higher-layer protocols and applications. From the standpoint of lower layers, however, there is a very important difference between devices that are on a host's local network and those that are elsewhere. In a general sense, most devices have a more important relationship with the devices that are on their local network than those that are far away. Some of the most obvious tasks that a device must perform specifically with other devices on its local network include the following:</p><p><span class="strong"><strong>Direct Datagram Delivery</strong></span> Devices deliver data directly to other devices on their local network, while data going to distant devices must be indirectly delivered (routed).</p><p><span class="strong"><strong>Layer 2 Addressing</strong></span> To facilitate direct delivery, devices need to know the layer 2 addresses of the other devices on the local network; they don't need to know them for nonlocal devices.</p><p><span class="strong"><strong>Router Identification</strong></span> To deliver indirectly, a device needs to find a router on its local network that it can talk to.</p><p><span class="strong"><strong>Router Communication</strong></span> The local router must communicate information to each of the local hosts using it, so the hosts know how best to use it.</p><p><span class="strong"><strong>Configuration</strong></span> Hosts will usually look to information provided by local devices to let them perform configuration tasks such as determining their own IP address.</p><p>To support these and other requirements, several special protocols and functions were developed along with the original IP (version 4). The IP addressing scheme lets devices differentiate local addresses from distant ones. The Address Resolution Protocol (ARP) lets devices determine layer 2 addresses from layer 3 addresses. ICMP provides a messaging system to support various communication requirements between local devices, including the ability of a host to find a local router and the router to provide information to local hosts.</p><p>These features all work properly in IPv4, but they were developed in sort of an ad hoc manner. They are defined not in a single place, but rather in a variety of different Internet <a class="indexterm" id="idx-CHP-36-1356"/>standards. There were also some limitations with the way these local device functions were implemented.</p><div class="sect2" title="Formalizing Local Network Functions: The Neighbor Concept"><div class="titlepage"><div><div><h2 class="title"><a id="formalizing_local_network_functions_the_"/>Formalizing Local Network Functions: The Neighbor Concept</h2></div></div></div><p>IPv6 represents the biggest change in decades to not just the IP itself, but the entire TCP/IP suite. It thus provided an ideal opportunity to formalize and integrate the many disparate functions and tasks related to communication between local devices. The result was the creation of a new protocol: <span class="emphasis"><em>Neighbor Discovery for IP version 6</em></span>, also commonly called the <span class="emphasis"><em>IPv6 Neighbor Discovery</em></span> protocol. Since this protocol is new in IPv6, there is no IPv4 version of it, so the name is usually just seen as the <span class="emphasis"><em>ND</em></span> protocol with no further qualifications; its use with IPv6 is implied.</p><p>The term <span class="emphasis"><em>neighbor</em></span> is one that has been used for years in various networking standards and technologies to refer to devices that are local to each other. In the context of the current discussion, two devices are <span class="emphasis"><em>neighbors</em></span> if they are on the same local network, meaning that they can send information to each other directly. The term can refer to either a regular host or a router. I think this is a good analogy to the way humans refer to those who live or work nearby. Just as most of us have a special relationship with people who are our neighbors and communicate more with them than with those who are far away, so do IP devices.</p><p>Since a neighbor is a local device, the name of the ND protocol would seem to indicate that ND is all about how neighbors discover each other's existence. In the context of this protocol, however, the term <span class="emphasis"><em>discovery</em></span> has a much more generic meaning: It refers to discovering not just who are neighbors are, but also discovering important information about them. In addition to letting devices identify their neighbors, ND facilitates all the tasks listed earlier, including such functions as address resolution, parameter communication, autoconfiguration, and much more, as you will see in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-201"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The new <span class="emphasis"><em>IPv6 Neighbor Discovery (ND)</em></span> protocol formalizes for IPv6 a number of functions related to communication between devices on a local network that are performed in IPv4 by protocols such as ARP and ICMP. ND is considered another helper protocol for IPv6 and is closely related to ICMPv6.</p></div></div><div class="sect2" title="Neighbor Discovery Standards"><div class="titlepage"><div><div><h2 class="title"><a id="neighbor_discovery_standards"/>Neighbor Discovery Standards</h2></div></div></div><p>The ND protocol was originally defined in RFC 1970, published in August 1996, and revised in the current defining standard, RFC 2461, published December 1998. Most of the functions of the ND protocol are implemented using a set of five special ICMPv6 control messages, which were discussed in the previous chapter. Thus, to some extent, the operation of ND is partially described by the ICMPv6 standard, RFC 2463. Where ICMPv4 can be considered IPv4's "administrative assistant," IPv6 really has two such assistants working closely together: ICMPv6 <a class="indexterm" id="idx-CHP-36-1357"/>and ND. I discuss more of the differences between the ways IPv4 and IPv6 implement ND's functions later in this chapter.</p></div></div></div>
<div class="sect1" title="IPv6 ND General Operational Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_general_operational_overview"/>IPv6 ND General Operational Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-36-1358"/>As I just mentioned, the name of the ND protocol really does not do it justice. The protocol facilitates not merely the discovery of neighboring devices, but also a substantial number of functions related to local network connectivity, datagram routing, and configuration. Both regular hosts and routers in an IPv6 environment count on the ND protocol to facilitate important exchanges of information that are necessary for proper internetwork operation.</p><p>The ND protocol has a number of similarities to ICMP. An important one is that like ICMP, ND is a <span class="emphasis"><em>messaging</em></span> protocol. It doesn't implement a single specific function, but rather a group of activities that are performed through the exchange of messages. This means I can't explain the operation of ND through a specific description of what ND does, but rather must define its operation by means of a list of messages that ND provides, and the specific ways that those messages are used.</p><p>Any local network on an internetwork will have both regular hosts and routers, and the term <span class="emphasis"><em>neighbor</em></span> can refer to either. Of course, hosts and routers play different roles on a network, and as a result, ND is very different for each. The ND standard describes nine specific functions performed by the protocol. To better understand these functions and how they are related, we can divide them into three functional groups based on communication type and the kinds of devices involved, as illustrated in <a class="xref" href="ch36s02.html#neighbor_discovery_nd_protocol_functiona" title="Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions">Figure 36-1</a>.</p><div class="figure"><a id="neighbor_discovery_nd_protocol_functiona"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e39521"/><img alt="Neighbor Discovery (ND) protocol functional groups and functions" src="httpatomoreillycomsourcenostarchimages288023.png.jpg"/></div></div><p class="title">Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions</p></div><p>Two main groups of functions in ND are those for handling router discovery and those for handling communications between hosts. A third functional group consists of just the Redirect function.</p><div class="sect2" title="Host-Router Discovery Functions"><div class="titlepage"><div><div><h2 class="title"><a id="host-router_discovery_functions"/>Host-Router Discovery Functions</h2></div></div></div><p>ND host-router discovery functions are those that facilitate the discovery of local routers and the exchange of information between routers and hosts. This includes four specific functions:</p><p><span class="strong"><strong>Router Discovery (RD)</strong></span> RD is the core function of this group. It's the method by which hosts locate routers on their local network.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-36-1359"/>Prefix Discovery</strong></span> Closely related to the process of RD is Prefix Discovery. Recall that the term <span class="emphasis"><em>prefix</em></span> refers to the network identifier portion of an IP address. Hosts use this function to determine the network they are on, which, in turn, tells them how to differentiate between local and distant destinations and whether to attempt direct or indirect delivery of datagrams.</p><p><span class="strong"><strong>Parameter Discovery</strong></span> Also closely related to RD, this is the method by which a host learns important parameters about the local network and/or routers, such as the maximum transmission unit (MTU) of the local link.</p><p><span class="strong"><strong>Address Autoconfiguration</strong></span> Hosts in IPv6 are designed to be able to automatically configure themselves, but this requires information that is normally provided by a router.</p></div><div class="sect2" title="Host-Host Communication Functions"><div class="titlepage"><div><div><h2 class="title"><a id="host-host_communication_functions"/>Host-Host Communication Functions</h2></div></div></div><p>The other main group of functions is associated with information determination and communication directly between nodes, usually hosts. Some of these functions can be performed between hosts and routers, but this group is not specifically related to RD. Host-host communcation functions include the following:</p><p><span class="strong"><strong>Address Resolution</strong></span> The process by which a device determines the layer 2 address of another device on the local network from that device's layer 3 (IP) address. This is the job performed by ARP in IPv4.</p><p><span class="strong"><strong>Next-Hop Determination</strong></span> The method for looking at an IP datagram's destination address and determining where it should next be sent.</p><p><span class="strong"><strong>Neighbor Unreachability Detection</strong></span> The process of determining whether or not a neighbor device can be directly contacted.</p><p><span class="strong"><strong>Duplicate Address Detection</strong></span> Determining if an address that a device wishes to use already exists on the network.</p></div><div class="sect2" title="Redirect Function"><div class="titlepage"><div><div><h2 class="title"><a id="redirect_function"/>Redirect Function</h2></div></div></div><p>The last functional group contains just one function: <span class="emphasis"><em>Redirect</em></span>. This is the technique whereby a router informs a host of a better next-hop node to use for a particular destination.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-202"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ND encompasses nine individual functions, many of which are related to each other. They are organized into three functional groups: <span class="emphasis"><em>host-router discovery functions</em></span>, host-host communications functions, and the <span class="emphasis"><em>Redirect function</em></span>.</p></div></div><div class="sect2" title="Relationships Between Functions"><div class="titlepage"><div><div><h2 class="title"><a id="relationships_between_functions"/>Relationships Between Functions</h2></div></div></div><p>The division of ND's overall functionality into nine tasks in three groups is somewhat arbitrary, but provides a good frame of reference for understanding what the protocol does. Some of the functions in different groups are related; next-hop determination uses information obtained as part of Parameter Discovery. The Redirect function is also a form of router-host communication but is distinct from RD.</p></div><div class="sect2" title="ICMPv6 Messages Used by ND"><div class="titlepage"><div><div><h2 class="title"><a id="icmpv6_messages_used_by_nd"/>ICMPv6 Messages Used by ND</h2></div></div></div><p><a class="indexterm" id="idx-CHP-36-1360"/>Just as ND is similar to ICMP in its operation, the two protocols are related in another way: the way that they perform messaging. ND actually implements its functions using ICMPv6 messages. A set of five message types is described in the ND standard:</p><p><span class="strong"><strong>Router Advertisement Messages</strong></span> Sent regularly by routers to tell hosts that they exist and provide important prefix and parameter information to them.</p><p><span class="strong"><strong>Router Solicitation Messages</strong></span> Sent by hosts to request that any local routers send a Router Advertisement message so they don't have to wait for the next regular advertisement message.</p><p><span class="strong"><strong>Neighbor Advertisement Messages</strong></span> Sent by hosts to indicate the existence of the host and provide information about it.</p><p><span class="strong"><strong>Neighbor Solicitation Messages</strong></span> Sent to verify the existence of another host and to ask it to transmit a Neighbor Advertisement message.</p><p><span class="strong"><strong>Redirect Messages</strong></span> Sent by a router to tell a host of a better method to route data to a particular destination.</p><p>We'll look at how these message types are used later in this chapter. See <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a> for the structures of each of these five ICMPv6 message types used by ND.</p></div></div>
<div class="sect1" title="IPv6 ND Functions Compared to Equivalent IPv4 Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_functions_compared_to_equivalent"/>IPv6 ND Functions Compared to Equivalent IPv4 Functions</h1></div></div></div><p><a class="indexterm" id="idx-CHP-36-1361"/>The IPv6 ND protocol has the distinction of being the only truly new protocol created as part of the core of IPv6; there is no previous version of ND. Of course, most of the services that ND provides to IPv6 were also required in IPv4. They were just provided in a rather diverse set of protocols and standards that the ND protocol has formalized, integrated, and improved.</p><p>What this means is that while ND is new, the jobs it does are equivalent to the tasks performed by several other protocols in IPv4. Specifically, the bulk of ND functions correspond to the following set of standards, features, and message types in IPv4:</p><p><span class="strong"><strong>ICMPv4 <a class="indexterm" id="idx-CHP-36-1362"/>Router Discovery</strong></span> Most of the functions associated with identifying and obtaining information from routers in ND are based on the use of ICMPv4 Router Advertisement and Router Solicitation messages, as defined in RFC 1256.</p><p><span class="strong"><strong>Address Resolution Protocol</strong></span> ND provides enhanced address resolution capabilities that are similar to the functions provided in IPv4 by ARP.</p><p><span class="strong"><strong>ICMPv4 Redirect</strong></span> ND's Redirect function and Redirect messages are based on similar functionality defined in IPv4 and ICMPv4.</p><p>There are other aspects of ND that only somewhat correlate to how things work in IPv4. There are also improvements or new functionality compared to how these IPv4 functions work. Some of these are due to differences in how <a class="indexterm" id="idx-CHP-36-1363"/>IPv6 itself operates compared to IPv4. For example, Prefix Discovery in ND is sort of related to the Address Mask Request and Address Mask Reply messaging in ICMPv4.</p><p>Overall, ND represents a substantial improvement compared to the way its job was done in IPv4. Like IPv6 itself, ND is generally better suited to the needs of modern networks than the older protocols. Some of the more important specific improvements made in ND compared to how its job was done in IPv4 include the following:</p><p><span class="strong"><strong>Formalizing of Router Discovery</strong></span> In IPv4, the process of RD and solicitation was arguably an afterthought. ND formalizes this process and makes it part of the core of the TCP/IP protocol suite.</p><p><span class="strong"><strong>Formalizing of Address Resolution</strong></span> In a similar manner, address resolution is handled in a superior way in ND, which functions at layer 3 and is tightly tied to IP, just as ICMP is. There is no more need for an ambiguously layered protocol like ARP, whose implementation depends greatly on the underlying physical and data link layers.</p><p><span class="strong"><strong>Ability to Perform Functions Securely</strong></span> ND operates at the network layer, so it can make use of the authentication and encryption capabilities of IPsec for tasks such as address resolution and RD.</p><p><span class="strong"><strong>Autoconfiguration</strong></span> In combination with features built into IPv6, ND allows many devices to automatically configure themselves, without the need for something like a Dynamic Host Configuration Protocol (DHCP) server (though DHCPv6 does also exist).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-36-1364"/>Dynamic Router Selection</strong></span> Devices use ND to detect if neighbors are reachable. If a device is using a router that stops being reachable, it will detect this and automatically switch to another one.</p><p><span class="strong"><strong>Multicast-Based Address Resolution</strong></span> Address resolution is performed using special multicast addresses instead of broadcasts, thereby reducing unnecessary disruption of "innocent bystanders" when resolution messages must be sent.</p><p><span class="strong"><strong>Better Redirection</strong></span> Improvements have been made to the method for generating and using Redirect messages.</p></div>
<div class="sect1" title="IPv6 ND Host-Router Discovery Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_host-router_discovery_functions"/>IPv6 ND Host-Router Discovery Functions</h1></div></div></div><p><a class="indexterm" id="idx-CHP-36-1365"/>Connecting individual networks together creates internetworks. The devices that are responsible for this connection of networks are routers, which send data from one network to the next. A host must rely on a router to forward transmissions to all devices other than those on the local network. For this reason, before a host can properly use an internetwork, it needs to find a local router and learn important information about both the router and the network itself. Enabling this information exchange is one of the most important jobs of the IPv6 ND protocol.</p><p>The general term used to describe most of the ND communication between hosts and routers on a local network is <span class="emphasis"><em>discovery</em></span>. As I mentioned earlier in this chapter, the term encompasses not merely discovery of the router, but also communication of important parameters. Most of this communication flows from the routers to the hosts, since routers control the way that each network is used. They provide information to hosts so the hosts know how best to operate.</p><p>The various discovery features related to host-router communication are all facilitated by the same exchange of two different ICMPv6 message types. Router Advertisement messages are sent only by routers, and they contain information about the router and the network on which it is located. Router Solicitation messages are optional, and they are sent by hosts when they want to find a local router. The format of each of these messages is described in <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a>.</p><p>Note that both Router Advertisement and Router Solicitation messages may include an optional layer 2 address of the device sending the message. This is used to update address resolution caches to save time when address resolution is needed later.</p><p>The mechanisms for using these messages are not really that complicated. The best way to see how the discovery process works overall is to look at the specific tasks performed both by routers and hosts in ND. Let's start by looking at the functions that routers perform.</p><div class="sect2" title="Host-Router Discovery Functions Performed by Routers"><div class="titlepage"><div><div><h2 class="title"><a id="host-router_discovery_functions_performe"/>Host-Router Discovery Functions Performed by Routers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-36-1366"/>Routers are responsible for the following functions:</p><p><span class="strong"><strong>Routine Advertisement</strong></span> The main job that routers do in ND is to regularly transmit Router Advertisement messages. Each router maintains a timer that controls how often an advertisement is sent out. Advertisements are also sent when any sort of special situation arises. For example, a message will be sent if key information about the router changes, such as its address on the local network. Router Advertisement messages include key information about both the router and the network. See <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a> for a full description of the Router Advertisement message format.</p><p><span class="strong"><strong>Parameter Maintenance</strong></span> Routers are responsible for maintaining key parameters about the local network, so they can be sent in advertisements. These include the default Hop Limit field value that should be used by hosts on the network, a default MTU value for the network, <a class="indexterm" id="idx-CHP-36-1367"/>and information such as network prefixes, which are used for both first-hop routing by hosts and autoconfiguration. Again, some more details on these can be found in <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a>.</p><p><span class="strong"><strong>Solicitation Processing</strong></span> Routers listen for Router Solicitation messages. When one is received, they will immediately send a Router Advertisement to the requesting host.</p></div><div class="sect2" title="Host-Router Discovery Functions Performed by Hosts"><div class="titlepage"><div><div><h2 class="title"><a id="host-router_discovery_functions_pe-id001"/>Host-Router Discovery Functions Performed by Hosts</h2></div></div></div><p>For their part, hosts are responsible for three main functions:</p><p><span class="strong"><strong>Advertisement Processing</strong></span> Hosts listen for advertisements on their local network and process them. They then set appropriate parameters based on the information in these messages. This includes maintaining various data structures such as lists of prefixes and routers, which are updated regularly as new advertisement information comes in.</p><p><span class="strong"><strong>Solicitation Generation</strong></span> Under certain conditions, a host will generate a Router Solicitation and send it out on the local network. This very simple message just requests that any local routers that hear it immediately send a Router Advertisement message back to the device that made the request. This is most often done when a host is first turned on, so it doesn't have to sit waiting for the next routine advertisement.</p><p><span class="strong"><strong>Autoconfiguration</strong></span> When required, and if the network supports the function, the host will use information from the local router to allow it to automatically configure itself with an IP address and other parameters.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-203"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the two main functional groups of ND is the set of <span class="emphasis"><em>host-router discovery</em></span> functions. They allow hosts on a local network to discover the identity of a local router and learn important parameters about how the network is to be used. Host-router discovery operations are performed using ICMPv6 Router Advertisement and Router Solicitation messages.</p></div></div></div>
<div class="sect1" title="IPv6 ND Host-Host Communication Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_host-host_communication_function"/>IPv6 ND Host-Host Communication Functions</h1></div></div></div><p><a class="indexterm" id="idx-CHP-36-1368"/>The delivery of datagrams in IP can be divided into two methods: direct and indirect. Indirect datagram delivery requires that routers provide help to hosts, which leads to the host-router discovery functions described in the previous section. Direct delivery of datagrams is performed from one host to another on the same network. This doesn't require the use of routers, but necessitates other IPv6 ND protocol functions that involve communication directly between local hosts. These include next-hop determination, address resolution, neighbor unreachability detection, and duplicate address detection.</p><div class="sect2" title="Next-Hop Determination"><div class="titlepage"><div><div><h2 class="title"><a id="next-hop_determination"/>Next-Hop Determination</h2></div></div></div><p>The first task that any host must perform when it wants to send a datagram is <a class="indexterm" id="idx-CHP-36-1369"/><span class="emphasis"><em>next-hop determination</em></span>. This is the process by which a device looks at the destination address in a datagram and decides whether direct or indirect delivery is required. In early IPv4, this was done by looking at the class of the address, and later on, by using the subnet mask. In IPv6, the prefix information obtained from local routers is compared to the destination of the datagram to determine if the destination device is local or distant. If it is local, the next hop is the same as the destination address; if it is not local, the next hop is chosen from the device's list of local routers (which are determined either by manual configuration or using the host-router discovery features of ND).</p><p>For efficiency purposes, hosts do not perform this next-hop determination for each and every datagram. They maintain a destination cache that contains information about what the next hop should be for recent devices to which datagrams have been sent. Each time a next-hop determination is performed for a particular destination, information from that determination is entered into the cache so that it can be used the next time datagrams are sent to that device.</p></div><div class="sect2" title="Address Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="address_resolution"/>Address Resolution</h2></div></div></div><p>If a host determines that the destination of a datagram is local, it will then need to send the datagram to that device. The actual transmission will occur using whatever physical layer and data link layer technology has been used to implement the local network. This requires the host to know the layer 2 address of the destination, even though it generally has only the layer 3 address from the datagram. Getting from the layer 3 address to the layer 2 address is known as the address resolution problem.</p><p>In IPv6, the ND protocol is responsible for address resolution. When a host wants to get the layer 2 address of a datagram destination it sends an ICMPv6 Neighbor Solicitation message containing the IP address of the device whose layer 2 address it wishes to determine. That device responds back with a Neighbor Advertisement message that contains its layer 2 address. Instead of using a broadcast that would disrupt each device on the local network, the solicitation is sent using a special multicast to the destination device's solicited-node address. See Chapters <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a> and <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> for more information about address resolution in IPv6.</p><p>Note also that even though this discussion does concentrate on communication between hosts, address resolution may also be done when a host needs to send a datagram to a local router and has no entry for it in its destination cache. In the context of address resolution, a destination device is just a neighbor. Whether it is a host or a router matters only in terms of what happens after the datagram has been sent and received. In other words, these host-to-host functions are so named only because they are not specific to the communication between hosts and routers like the tasks in the preceding section.</p></div><div class="sect2" title="Updating Neighbors Using Neighbor Advertisement Messages"><div class="titlepage"><div><div><h2 class="title"><a id="updating_neighbors_using_neighbor_advert"/>Updating Neighbors Using Neighbor Advertisement Messages</h2></div></div></div><p>Devices do not routinely send Neighbor Advertisement messages the way that routers send Router Advertisement messages. There really isn't any need for this: <a class="indexterm" id="idx-CHP-36-1370"/>Neighbors don't change much over time, and resolution will occur naturally over time as devices send datagrams to each other. In addition, having advertisements sent regularly by so many devices on a network would be wasteful.</p><p>A host may, however, send an unsolicited Neighbor Advertisement message under certain conditions where it feels it is necessary to immediately provide updated information to other neighbors on the local network. A good example of this is a hardware failure—in particular, the failure of a network interface card. When the card is replaced, the device's layer 2 (MAC) address will change. Assuming the device's IP layer can detect this, it can send out an unsolicited Neighbor Advertisement message to tell other devices to update their resolution caches with the new MAC address.</p></div><div class="sect2" title="Neighbor Unreachability Detection and the Neighbor Cache"><div class="titlepage"><div><div><h2 class="title"><a id="neighbor_unreachability_detection_and_th"/>Neighbor Unreachability Detection and the Neighbor Cache</h2></div></div></div><p><a class="indexterm" id="idx-CHP-36-1371"/>Neighbor Solicitation and Neighbor Advertisement messages are most often associated with address resolution, but they also have other purposes. One of these is neighbor unreachability detection. Each device maintains information about each of its neighbors and updates it dynamically as network conditions change. The information is kept for both host and router devices that are neighbors on the local network. Knowing that a device has become unreachable is important because a host can adapt its behavior accordingly. In the case of an unreachable host, a device may wait a certain period of time before trying to send datagrams to an unreachable host, instead of flooding the network with repeated attempts to send to the host. An unreachable router, on the other hand, is a signal that the device needs to find a new router to use, if an alternate is available.</p><p>Each host maintains a neighbor cache that contains information about neighboring devices. Each time a host receives a datagram from a neighbor, it knows the neighbor is reachable at that particular moment, so the device makes an entry in the cache for the neighbor to indicate this. Of course, receiving a datagram from a neighbor means only that the neighbor is reachable now; the more time that elapses since the last datagram was received, the greater the chance that something has happened to make the neighbor no longer reachable.</p><p>For this reason, neighbor reachability information must be considered temporary. Each time a neighbor is entered into the cache as reachable, a timer is started. When the timer expires, the reachability information for that neighbor is considered stale, and reachability is no longer assumed for that neighbor. When a new datagram is received from the neighbor in question, the timer is reset and the cache is again set to indicate that the device is reachable. The amount of time a host should consider a neighbor reachable before expiring it is communicated by a local router using a field in a Router Advertisement message.</p><p>A host can also dynamically seek out a neighbor if it needs to know its reachability status. It sends a Neighbor Solicitation message to the device and waits for a Neighbor Advertisement message in response. It then updates the cache accordingly.</p></div><div class="sect2" title="Duplicate Address Detection"><div class="titlepage"><div><div><h2 class="title"><a id="duplicate_address_detection"/>Duplicate Address Detection</h2></div></div></div><p>The last use of the two messages we have been discussing here is for <a class="indexterm" id="idx-CHP-36-1372"/>duplicate address detection. When a host uses the IPv6 autoconfiguration facility, one of the steps in the process is to ensure that the address it is trying to use doesn't already exist on the network. This is done by sending a Neighbor Solicitation message to the address the device wishes to use. If a Neighbor Advertisement message is received in reply, the address is already in use.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-204"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The second of the two main functional groups of ND is the set of <span class="emphasis"><em>host-host communication</em></span> functions. Two ICMPv6 messages, Neighbor Advertisement and Neighbor Solicitation, are defined. They enable a variety of types of essential communication between adjacent hosts on a local network. These include address resolution, determining the next hop to which a datagram should be sent, and also the assessment of a neighboring device's reachability.</p></div></div></div>
<div class="sect1" title="IPv6 ND Redirect Function"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_nd_redirect_function"/>IPv6 ND Redirect Function</h1></div></div></div><p><a class="indexterm" id="idx-CHP-36-1373"/>The last of the major responsibilities of the IPv6 ND protocol is the <span class="emphasis"><em>Redirect</em></span> function. This is used by a router to inform a host of a better route to use for datagrams that have been sent to a particular destination. An argument could be made that the <a class="indexterm" id="idx-CHP-36-1374"/>Redirect function should be part of the host-router group since it represents a form of communication between routers and regular hosts. However, it is somewhat different from the other discovery functions, and so the standard treats it separately.</p><p>Routers are responsible for detecting situations where a host on the local network has made an inefficient first-hop routing decision, and then attempting to correct it. For example, consider a network that has two routers on it, R1 and R2. A Host H1 wants to send a datagram to Device X2 on another network that is connected to Host H1's network through Router R2. If Host H1 sends the datagram to Router R1, that router will know it must go through Router R2, and will send it there. Seeing that Router R2 was also on the local network, Router R1 therefore knows that Host H1 made a poor initial routing decision: The datagram should have been sent to Router R2 directly, not Router R1. If this sounds very similar to ICMPv4's redirect feature, that's because it is!</p><p>In response, Router R1 will create a special ICMPv6 Redirect message. This message will tell Host H1 that for any subsequent datagrams that will be sent to Device X2 should be first sent to Router R2, instead of to Router R1. It is also possible that a router may determine other situations where the first hop from a particular host should be different and will advise the host using a Redirect message. This is illustrated in <a class="xref" href="ch36s06.html#nd_host_redirection_using_an_icmpv6_redi" title="Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends to Router R1 an IPv6 datagram destined for a device on Network N2. However, Router R1 notices that Router R2 is on the same network as the source device and is a more direct route to Network N2. It forwards the datagram on to Router R2 but also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router R2 next time.">Figure 36-2</a>.</p><p>Only routers send Redirect messages, not hosts. Hosts are responsible for looking for these Redirect messages and processing them. A host receiving such a message will look in it to see which destination's datagram led to the redirection notice, and which new first hop the router is saying the host should use in the future for that destination. In this example, Host H1 will see that Router R1 is saying that any further datagrams to Device X2 should be sent to Router R2 instead of Router R1. Host H1 will update its destination cache for Device X2 accordingly.</p><div class="figure"><a id="nd_host_redirection_using_an_icmpv6_redi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e39898"/><img alt="ND host redirection using an ICMPv6 Redirect message Host H1 sends to Router R1 an IPv6 datagram destined for a device on Network N2. However, Router R1 notices that Router R2 is on the same network as the source device and is a more direct route to Network N2. It forwards the datagram on to Router R2 but also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router R2 next time." src="httpatomoreillycomsourcenostarchimages288025.png.jpg"/></div></div><p class="title">Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends to Router R1 an IPv6 datagram destined for a device on Network N2. However, Router R1 notices that Router R2 is on the same network as the source device and is a more direct route to Network N2. It forwards the datagram on to Router R2 but also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router R2 next time.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-205"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The ND <span class="emphasis"><em>Redirect</em></span> function allows a router to tell a host to use a different router for future transmissions to a particular destination. It is similar to the IPv4 redirect feature and is implemented using ICMPv6 Redirect messages.</p></div><p>When a router sends a Redirect message, it may also include in the message the data link layer address of the destination to which it is redirecting. This address is used by the host to update its address resolution cache, if necessary. This may save bandwidth in the future by eliminating an address resolution cycle, when the redirected host tries to send to the new, redirected location. In the example, Router R1 may include Router R2's own layer 2 address in the Redirect message. This can be used by Host H1 the next time it has a datagram for Device X2.</p><p>IPv6 also supports the authentication of Redirect messages to prevent unauthorized devices from causing havoc by sending inappropriate Redirect messages. A host may be configured to discard Redirect messages that are not properly authenticated.</p></div></body></html>