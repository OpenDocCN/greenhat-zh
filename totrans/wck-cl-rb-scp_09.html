<html><head></head><body>
  <div class="sgc-1" id="filepos695778"/>&#13;
&#13;
  <h1 class="calibre1" id="calibre_pb_427"><span class="calibre2"><a class="calibre7" shape="rect"/>Chapter 9. SORTING ALGORITHMS</span></h1>&#13;
&#13;
  <div class="calibre3"><a class="calibre17" shape="rect"/><img alt="SORTING ALGORITHMS" class="calibre23" src="../Images/00001.jpg"/></div>&#13;
&#13;
  <p class="calibre4">Ruby is a wonderful language for many reasons, but even the best programming languages can be stifled by poor algorithms, improper data structures, or logic errors. <a class="calibre17" shape="rect"/>Sorting is a fundamental programming skill you should definitely master. Whether you're sorting numbers, letters, or names, sorting algorithms can make or break your program's efficiency.</p>&#13;
&#13;
  <p class="calibre4">The performance of sorting algorithms is frequently measured using the <span><em class="italic">Big O notation</em></span> (pronounced "Big Oh"), a concept that comes from computational complexity theory. You can relax; we won't be going into computational complexity theory or proofs. Suffice it to say, Big O notation abstracts an algorithm's consumption of resources—specifically, time. A simple example to illustrate Big O notation is to think about the efficiency of accessing every element in an array. The Big O notation for this situation would be O(<span><em class="italic">n</em></span>), where <span><em class="italic">n</em></span> represents the number of elements, and each element in the array is accessed once. I don't intend to go into the details of <a class="calibre17" shape="rect"/>Big O; for our purposes, it is simply a way to describe the efficiency of an algorithm.<a class="calibre17" shape="rect"/></p>&#13;
&#13;
  <p class="calibre4">For a controlled comparison of the various <a class="calibre17" shape="rect"/>sorting <a class="calibre17" shape="rect"/>methods, I created a harness that will handle a specific test case. The harness will set up the test cases, initialize the timer, and finally, call the sorting algorithm. Every algorithm has the same goal and produces the same output; they are presented in loosely ascending order by efficiency. Remember that each of the following algorithms is written as its own method for easy integration into other scripts. The first controlled element of the comparison is the numbers that will be sorted. I had another Ruby script generate 1,000 random numbers and store them in a text document. The importance of sorting the same data for each algorithm is that some randomizations can help the performance of one algorithm over another, if the data is sorted already.</p>&#13;
&#13;
  <p class="calibre4">To determine the results of each sorting method, I'm using the <a class="calibre17" shape="rect"/>benchmark library. This will allow me to know exactly when the algorithm starts sorting and stops sorting. The output format will look something similar to this:</p>&#13;
&#13;
  <p><a class="calibre17" shape="rect"/></p>&#13;
&#13;
  <div class="calibre3">&#13;
    <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
    0.406000   0.015000   0.421000 (  0.437000)</tt></span>&#13;
  </div>&#13;
&#13;
  <p class="calibre4">The benchmark output will display the users CPU time, system's CPU time, the total amount of CPU time consumed, and finally, the elapsed real time. The unit of time is seconds, and the main value we're interested in is the real time.</p>&#13;
&#13;
  <div class="calibre3">&#13;
    <hr class="calibre21"/>&#13;
  </div>&#13;
&#13;
  <div class="calibre3">&#13;
    <h3 class="calibre24" id="heading_id_2"><span class="calibre18"><a class="calibre7" shape="rect"/>Note</span></h3>&#13;
&#13;
    <p class="calibre4"><span class="calibre18"><span><em class="italic">There is always the built-in Ruby sort method, <code class="calibre19">quicksort</code>, but the following sorts will give you other options if you don't use Ruby's.</em></span><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></span></p>&#13;
  </div>&#13;
&#13;
  <div class="calibre3">&#13;
    <hr class="calibre21"/>&#13;
  </div>&#13;


  <div class="calibre3 calibre3 calibre3 calibre3">
    <h1 class="calibre1" id="calibre_pb_428"><span class="calibre2"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos700370"/>Bubble Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_429"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos700655"/>Bubble Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>bubbleSort.rb</h3>
      </div>

      <p class="calibre4">Bubble sort uses an easy exchange method. This algorithm is perhaps the simplest method of sorting to understand. As you will see in the explanation, the algorithm looks at the first two elements in a data set and compares them. If the first element is larger than the second, the algorithm swaps them. This process continues for each pair of elements in the data set. At the end of the data set, the comparison starts again and continues until no swaps are made.<a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_430"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos701783"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def bubble_sort(a)<br class="calibre20"/>&#13;
           i = 0<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>     while i&lt;a.size<br class="calibre20"/>&#13;
               j = a.size - 1<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>         while (i &lt; j)<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>              if a[j] &lt; a[j - 1]<br class="calibre20"/>&#13;
                        temp = a[j]<br class="calibre20"/>&#13;
                        a[j] = a[j - 1]<br class="calibre20"/>&#13;
                        a[j - 1] = temp<br class="calibre20"/>&#13;
                        end<br class="calibre20"/>&#13;
                    j-=1<br class="calibre20"/>&#13;
                    end<br class="calibre20"/>&#13;
                i+=1<br class="calibre20"/>&#13;
                end<br class="calibre20"/>&#13;
            return a<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/> big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/><br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00007.jpg"/> puts Benchmark.measure {big_array_sorted = <a class="calibre17" shape="rect"/>bubble_sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("<a class="calibre17" shape="rect"/>output_bubble_sort.txt","w") do |out|<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00008.jpg"/>     out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_431"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos703917"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby bubbleSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_432"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos704512"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script will sort 1,000 random numbers and will output the ordered pair to a file called <span><em class="italic">output_bubble_sort.txt</em></span>. Additionally, the script outputs the amount of time required to execute the script using the benchmark library.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      2.125000   0.000000   2.125000 (  2.140000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_433"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos705407"/>How It Works</span></h2>
    </div>

    <p class="calibre4">The script is broken up into three main areas: the required libraries, the actual <a class="calibre17" shape="rect"/>sorting algorithm, and finally, the harness—which will supply the list of random numbers to be sorted. I want to talk about the harness first, so we'll begin with the lower half of the script and then jump back up to the top.</p>

    <p class="calibre4">In order to speed up the process of generating a random number data set, I used another script to create 1,000 random numbers and write them to <span><em class="italic">1000RanNum.txt</em></span>.<sup class="calibre35">[<a class="calibre6" href="#filepos710525" id="filepos706211" shape="rect">1</a>]</sup> The first instruction in this script is to create an array (called <code class="calibre19">big_array</code>) that will hold those numbers <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>. Another array is created to hold the sorted values; this one is called <code class="calibre19">big_array_sorted</code>. Next, the file containing 1,000 random numbers is opened. The file has one number per line, so after having opened the file successfully, each number is pushed onto the array <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>.</p>

    <p class="calibre4">Once all the numbers have been added to <code class="calibre19">big_array</code>, the script is ready to begin <a class="calibre17" shape="rect"/>sorting. In order to make this timed trial as controlled as possible (and without using my stopwatch), I'm using the <code class="calibre19">measure</code> method from the benchmark library <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. Essentially, <code class="calibre19">measure</code> will start the timer once the script has begun sorting the numbers and then stop the timer when the sort has finished. The results are then displayed in the form of <code class="calibre19">user, system, total</code>, and <code class="calibre19">real times</code>. I'll come back to the sorting algorithm, but we need to see where the data is stored. Once the numbers have been sorted, the results are saved to <code class="calibre19">big_array_sorted</code> and output to a text file, <span><em class="italic">output_&lt;sort name&gt;.txt</em></span>. The text file can be used for further analysis and to ensure the numbers were actually sorted <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00008.jpg"/></span>.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">Within the <code class="calibre19">measure</code> method, the script calls <code class="calibre19">bubble_sort(a)</code>. As mentioned previously, <a class="calibre17" shape="rect"/>bubble sort is a quick, simple, and generic sorting algorithm that has no regard for efficiency. You can think of this algorithm as being almost a brute force attack. As you experiment with other algorithms, you'll begin to appreciate the elegance and beauty of how the best algorithms are written. But first, we start with the basics!</p>

    <p class="calibre4">An array is passed to the <code class="calibre19">bubble_sort</code> method. The variable <code class="calibre19">i</code> is initialized and will serve as a counter. A while loop is started, which will isolate one element of the data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. Next, a second while loop is nested within the first. The second while loop contains the meat of the sort <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. <a class="calibre17" shape="rect"/>Bubble sort compares the first two elements, and if the first is greater than the second, the values are exchanged. This process is used for each pair of elements in the data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. Once the end of the list is reached, the process starts over until no further exchanges occur. If you visualize a vertical tower of random numbers sorted using the bubble sort, you can understand where the algorithm gets its name.<a class="calibre17" shape="rect"/></p>
  </div>

  <div class="calibre3">
    <br class="calibre20"/>
    <hr class="calibre21"/>

    <div class="calibre3">
      <p class="calibre4"><sup class="calibre35">[<a class="calibre6" href="#filepos706211" id="filepos710525" shape="rect">1</a>]</sup> To avoid influencing the test, I've used the same test file for all the scripts in the chapter.</p>
    </div>
  </div>

  <div class="mbppagebreak" id="calibre_pb_434"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos710757">
    <h1 class="calibre1" id="calibre_pb_435"><span class="calibre2"><a class="calibre7" shape="rect"/>Selection Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_436"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos711246"/>Selection Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>selectionSort.rb</h3>
      </div>

      <p class="calibre4"><a class="calibre17" shape="rect"/>Selection sort improves on the bubble sort algorithm, but it still isn't the pinnacle of efficiency. However, selection sort has its place in our coding tool bag because it can be used to quickly sort small lists. The algorithm isn't complicated, so implementing it in code can swiftly take care of a sorting need. Instead of comparing two elements within a data set, selection sort will search for the smallest element of the data set and move it to the beginning of the list. The same process is repeated for the second element and so on. It's interesting to observe that this algorithm also uses exchanges to sort. Other algorithms' efficiencies may be dependent on the starting order of a data set. That is to say, if some lists are partially ordered, some algorithms will gain a performance advantage and not have to move as many elements. The difference with selection sort is that this algorithm doesn't care. It always has <span><em class="italic">n</em></span> swaps, where <span><em class="italic">n</em></span> is the number of elements in the data set, which is great for the worst-case scenarios. Going back to the Big O notation, this would be O(<span><em class="italic">n</em></span>).<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_437"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos713312"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def <a class="calibre17" shape="rect"/>selection_sort(a)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>   a.each_index do |i|<br class="calibre20"/>&#13;
             min_index = min(a, i)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>     a[i], a[min_index] = a[min_index], a[i]<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
           a<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>     def min(subset, from)<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>     min_value = subset[from..-1].min<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/>     min_index = subset[from..-1].index(min_value) + from<br class="calibre20"/>&#13;
           return min_index<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = selection_sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("output_selectionSort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_438"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos714910"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby selectionSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_439"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos715508"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script will sort our 1,000 random numbers and output the ordered pair to a file called <span><em class="italic">output_selection_sort.txt</em></span>. Additionally, the script outputs to $stdout the amount of time used to execute the script, calculated using the benchmark library.<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      0.406000   0.015000   0.421000 (  0.437000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_440"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos716461"/>How It Works</span></h2>
    </div>

    <p class="calibre4">I have already discussed the surrounding parts of the <a class="calibre17" shape="rect"/>sorting scripts in the previous example. If you have any questions, refer to "#52 Bubble Sort" on <a class="calibre6" href="../Text/dummy_split_358.html#filepos700370" shape="rect">Bubble Sort</a>. I will focus on the individual sorting algorithms for the rest of this chapter.</p>

    <p class="calibre4"><a class="calibre17" shape="rect"/>Selection sort is another classic <a class="calibre17" shape="rect"/>sorting algorithm, but it is slightly more efficient than the bubble sort. It also has fewer lines of code. Unlike other algorithms seen in this chapter, <a class="calibre17" shape="rect"/>selection sort immediately goes after the <a class="calibre17" shape="rect"/>minimum value of the data set without any type of pre-processing. Once the smallest element is found, the element swaps its position with the first position of the data set. Then the algorithm looks for the second lowest value in a data set and repeats this until all elements have been used.</p>

    <p class="calibre4">The first big difference in this script is the creation of another method, called <code class="calibre19">min</code>, which <code class="calibre19">selectionSort</code> will use to find the minimum value from a subset of the original data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. Keep this method in the back of your mind, and we'll come back to it. <code class="calibre19">selectionSort</code> starts with a loop that will iterate through each element in the data set. The loop relies on the method <code class="calibre19">each_index</code> to do this</p>

    <div class="calibre3"><a class="calibre17" shape="rect"/><img alt="How It Works" class="calibre23" src="../Images/00002.jpg"/></div>

    <p class="calibre4">. After the index of an element has been retrieved, <code class="calibre19">min</code> is immediately called to pass the index value. While in <code class="calibre19">min</code>, the script searches for the smallest element in a subset <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>. Once the smallest value has been found, its index is retrieved and returned to the calling method <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">Finally, the sort uses the typical Ruby swap routine to make a quick swap between the smallest element and the element that is currently in its new place <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. This process is repeated until all the values have been accessed. For a data set of size <span><em class="italic">n</em></span>, the script will perform <span><em class="italic">n</em></span> iterations, making this algorithm's performance predictable.<a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_441"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos719966">
    <h1 class="calibre1" id="calibre_pb_442"><span class="calibre2"><a class="calibre7" shape="rect"/>Shell Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_443"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos720451"/>Shell Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>shellSort.rb</h3>
      </div>

      <p class="calibre4">Shell sort is an <span><em class="italic">insertion sorting</em></span> algorithm: A value is stored to a temporary value, then inserted into its appropriate place. One difference between this algorithm and the traditional insertion sort is that a shell sort compares two elements that are separated by a gap of several positions—in essence, making bigger jumps. This slight change results in greater efficiency in the worst-case scenario. Remember, worst-case scenarios are when a list of elements are in complete disarray and cannot be disordered any more than they currently are.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_444"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos721837"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def shell_sort(a)<br class="calibre20"/>&#13;
           i = 0<br class="calibre20"/>&#13;
           j = 0<br class="calibre20"/>&#13;
           size = a.length<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>     increment = size / 2<br class="calibre20"/>&#13;
           temp = 0<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>     while increment &gt; 0<br class="calibre20"/>&#13;
               i = increment<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>         while i&lt;size<br class="calibre20"/>&#13;
                   j = i<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>             temp = a[i]<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/>             while j&gt;=increment and a[j-increment]&gt;temp<br class="calibre20"/>&#13;
                       a[j] = a[j-increment]<br class="calibre20"/>&#13;
                       j = j-increment<br class="calibre20"/>&#13;
                   end<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00007.jpg"/>             a[j] = temp<br class="calibre20"/>&#13;
                   i+=1<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
               if increment == 2<br class="calibre20"/>&#13;
                   increment = 1<br class="calibre20"/>&#13;
               else<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00008.jpg"/>             increment = (increment/2).to_i<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
           return a<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = shell_sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("<a class="calibre17" shape="rect"/>output_shell_sort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_445"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos724367"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby shellSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_446"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos724961"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">As with the others, this script sorts the 1,000 random numbers and outputs the ordered set to a file called <span><em class="italic">output_shell_sort.txt</em></span>. Additionally, the script outputs the amount of time used to execute the script using the <a class="calibre17" shape="rect"/>benchmark library.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      0.047000   0.000000   0.047000 (  0.047000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_447"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos725905"/>How It Works</span></h2>
    </div>

    <p class="calibre4"><a class="calibre17" shape="rect"/>Shell sort improves on the insertion sort algorithm by using a gap sequence, which enables the <a class="calibre17" shape="rect"/>sorting algorithm to make bigger improvements on the list's final ordering. This creates fewer write operations, resulting in a shorter runtime.</p>

    <p class="calibre4">The algorithm begins with an array being passed as the only argument. Next, several variables are initialized to help track the sorting process. The important variable to watch is <code class="calibre19">increment</code> <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. This variable will dictate the gap sequence mentioned previously. You may have noticed that the structure closely resembles bubble sort, but there are slight differences which have an impact during runtime.</p>

    <p class="calibre4">The first of the three while loops states, "as long as the increment that we are moving is more than zero, there is still work left to be done" <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. The second while loop ensures the value of <code class="calibre19">i</code> stays within the bounds of the array's length <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. Next, the value located at position <code class="calibre19">i</code> in array <code class="calibre19">a</code> is stored in a temporary variable so that we don't lose the element during later moves <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>.</p>

    <p class="calibre4">Unlike bubble sort, <a class="calibre17" shape="rect"/>shell sort adds a third while loop <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>. As long as the variable <code class="calibre19">j</code> is greater than <code class="calibre19">increment</code> and the value of the array position <code class="calibre19">j-increment</code> is larger than the <code class="calibre19">temp</code> variable, then values at <code class="calibre19">j-increment</code> are inserted into the array. After the third while loop is broken, the <code class="calibre19">temp</code> value is placed back in the array, and the process continues for each element <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. Once the end of the data set is reached, the process starts over again, and <code class="calibre19">increment</code> is recalculated <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00008.jpg"/></span>. The process continues until <code class="calibre19">increment</code> is equal to zero.<a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_448"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos729247">
    <h1 class="calibre1" id="calibre_pb_449"><span class="calibre2"><a class="calibre7" shape="rect"/>Merge Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_450"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos729732"/>Merge Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>mergeSort.rb</h3>
      </div>

      <p class="calibre4">This <a class="calibre17" shape="rect"/>sorting algorithm does exactly what the name describes: It merges two sort elements. The algorithm splits the main data set into smaller subsets of one element. It then takes the first and second elements and sorts them, creating a subset. The result of the initial subset is merged and sorted with the next element. This process is done recursively until all elements have been merged back into the main data set. Interestingly, this algorithm is the first to address performance in significantly large data sets.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_451"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos731028"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def merge(a1, a2)<br class="calibre20"/>&#13;
           ret = []<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           while (true)<br class="calibre20"/>&#13;
               if a1.empty?<br class="calibre20"/>&#13;
                   return ret.concat(a2)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
               if a2.empty?<br class="calibre20"/>&#13;
                   return ret.concat(a1)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>             if a1[0] &lt; a2[0]<br class="calibre20"/>&#13;
                   ret &lt;&lt; a1[0]<br class="calibre20"/>&#13;
                   a1 = a1[1...a1.size]<br class="calibre20"/>&#13;
               else<br class="calibre20"/>&#13;
                   ret &lt;&lt; a2[0]<br class="calibre20"/>&#13;
                   a2 = a2[1...a2.size]<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def <a class="calibre17" shape="rect"/>merge_sort(a)<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>     if a.size == 1<br class="calibre20"/>&#13;
               return a<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>     elsif a.size == 2<br class="calibre20"/>&#13;
               if a[0] &gt; a[1]<br class="calibre20"/>&#13;
                   a[0], a[1] = a[1], a[0]<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
               return a<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>     size1 = (a.size / 2).to_i<br class="calibre20"/>&#13;
           size2 = a.size - size1<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           a1 = a[0...size1]<br class="calibre20"/>&#13;
           a2 = a[size1...a.size]<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/>     a1 = merge_sort(a1)<br class="calibre20"/>&#13;
           a2 = merge_sort(a2)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00007.jpg"/>     return merge(a1, a2)<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = merge_sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("<a class="calibre17" shape="rect"/>output_merge_sort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_452"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos733901"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby mergeSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_453"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos734495"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script sorts the 1,000 random numbers and outputs the ordered set to <span><em class="italic">output_merge_sort.txt</em></span>. Additionally, the script prints the amount of time used to execute the script, again relying on the <a class="calibre17" shape="rect"/>benchmark library.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      0.109000   0.000000   0.109000 (  0.109000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_454"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos735415"/>How It Works</span></h2>
    </div>

    <p class="calibre4">The <a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/>merge sort consists of two methods: <code class="calibre19">merge_sort</code> and <code class="calibre19">merge</code>. The <code class="calibre19">merge_sort</code> method is responsible for controlling the recursive splitting and returning the final product. The only mission for <code class="calibre19">merge</code> is to merge two arrays together. There is heavy usage of recursive method calls, so follow along and note where the method calls itself.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The <code class="calibre19">merge_sort</code> method begins with a check to see if the array being passed to the method has a size equal to one <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. This is the condition where the recursion will stop, so it will only happen when the data set has been split into smaller one-element data sets. Next, <code class="calibre19">merge_sort</code> looks for an array with two elements, and if found, the script will sort it and return the sorted two-element data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. If neither of the two previous conditions is met, the script will proceed to break the array into two even smaller arrays <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>. These smaller arrays are then passed back into another recursive <code class="calibre19">merge_sort</code> call <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>.</p>

    <p class="calibre4">After the <code class="calibre19">merge_sort</code> call is returned for both halves, the <code class="calibre19">merge</code> method is used to merge those data sets together <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. While in <code class="calibre19">merge</code>, the arrays are compared and sorted appropriately <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. <a class="calibre17" shape="rect"/>Sorting arrays that have some order is much easier than sorting totally random numbers. This enables the <a class="calibre17" shape="rect"/>merge sort to remain efficient through each recursive call. Compared to the <a class="calibre17" shape="rect"/>Big O notation of bubble sort, which was O(<span><em class="italic">n</em></span><sup class="calibre35">2</sup>), <a class="calibre17" shape="rect"/>merge sort is O(<span><em class="italic">n</em></span> log <span><em class="italic">n</em></span>). You can see that merge sort is much more efficient by comparing the sorting times.<a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_455"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos738789">
    <h1 class="calibre1" id="calibre_pb_456"><span class="calibre2"><a class="calibre7" shape="rect"/>Heap Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_457"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos739273"/>Heap Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>heapSort.rb</h3>
      </div>

      <p class="calibre4">Building on the selection sort, heap sort uses the selections much more efficiently, as can be seen in a comparison of the two execution times. Heap sort is comparable to the quick sort algorithm shown in the next section, but typically, quick sort will have a faster execution time. The difference in the two sorting routines is in the worst-case Big O scenario, where heap sort edges out quick sort. In most implementations, the worst case is not the normal case, so it is up to you to consider the consequences.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_458"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos740524"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def heap_sort(a)<br class="calibre20"/>&#13;
           size = a.length<br class="calibre20"/>&#13;
           temp = 0<br class="calibre20"/>&#13;
           i = (size/2)-1<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>     while i &gt;= 0<br class="calibre20"/>&#13;
               sift_down(a,i,size)<br class="calibre20"/>&#13;
               i-=1<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           i=siz e-1<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>     while i &gt;= 1<br class="calibre20"/>&#13;
               a[0], a[1] = a[1], a[0]<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>         sift_down(a, 0, i-1)<br class="calibre20"/>&#13;
               i-=1<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
           return a<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def sift_down(num, root, bottom)<br class="calibre20"/>&#13;
           done = false<br class="calibre20"/>&#13;
           max_child = 0<br class="calibre20"/>&#13;
           temp  = 0<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           while root*2 &lt;= bottom and !done<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>         if root*2 == bottom<br class="calibre20"/>&#13;
                   max_child = root * 2<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/>         elsif num[root*2].to_i &gt; num[root*2+1].to_i<br class="calibre20"/>&#13;
                   max_child = root * 2<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00007.jpg"/>         else<br class="calibre20"/>&#13;
                   max_child = root * 2 + 1<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00008.jpg"/>         if num[root] &lt; num[max_child]<br class="calibre20"/>&#13;
                   num[root], num[max_child] = num[max_child], num[root]<br class="calibre20"/>&#13;
                   root = max_child<br class="calibre20"/>&#13;
               else<br class="calibre20"/>&#13;
                   done = true<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = <a class="calibre17" shape="rect"/>heap_sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("output_heap_sort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_459"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos743467"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby heapSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_460"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos744060"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script will sort the random number data set and output the ordered set to a file called <span><em class="italic">output_heap_sort.txt</em></span>. The script also prints the amount of time used to execute the script:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      0.078000   0.000000   0.078000 (  0.078000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_461"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos744948"/>How It Works</span></h2>
    </div>

    <p class="calibre4">While the structure of <a class="calibre17" shape="rect"/>heap sort closely resembles merge sort, with two methods used to sort the elements, <a class="calibre17" shape="rect"/>heap sort does not use recursion to achieve a sorted data set. The first method, <code class="calibre19">heapSort</code>, starts with a while loop that calls <code class="calibre19">sift_down</code> <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. This call effectively builds the heap for <a class="calibre17" shape="rect"/>sorting. The <code class="calibre19">sift_down</code> method is used to create and manipulate the heap for sorting the array. A heap is a tree-type data structure. If you're not familiar with a heap, think of a family tree with one node at the top and parents and children below, representing elements. The heap must have a <span><em class="italic">root</em></span>, or top-most element, and two optional <span><em class="italic">leaves</em></span>, or children. The script also passes the array as an argument.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The <code class="calibre19">sift_down</code> method uses three conditional statements to determine the placement of an element within the heap. The first statement looks to see if the element is at the bottom of the heap <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. If it is not, then the two children of the node are compared. If the elements are already ordered as children, then the order is maintained <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>. If neither of the first two conditions is met, then the element must be a child and is not in the proper order <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. The location where the element should be placed is stored in <code class="calibre19">max_child</code>. With this information, another conditional statement moves the elements into their correct order using the <code class="calibre19">temp</code> variable as the elements are shifted <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00008.jpg"/></span>.</p>

    <p class="calibre4">Jumping back to the <code class="calibre19">heapSort</code> method, the initial heap has been created. So, the algorithm begins to move the elements into their final place within the data set. The second while loop places the root node of the tree in the last place of the data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. It then calls <code class="calibre19">sift_down</code> to reconstruct the tree with a new root node and repeats the process for each element <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. Think of the second while loop as popping off the root node of the tree, then rebuilding it until all elements have been popped off. Using the heap data structure enables this algorithm to produce large, sorted data sets in a short period of time. The performance follows a logarithmic line, as opposed to a linear line like the previous sorting algorithms.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_462"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos748907">
    <h1 class="calibre1" id="calibre_pb_463"><span class="calibre2"><a class="calibre7" shape="rect"/>Quick Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_464"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos749392"/>Quick Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>quickSort.rb</h3>
      </div>

      <p class="calibre4">Quick sort is speedy in its execution; it is one of the fastest algorithms presented so far, and happens to be the default sort method contained within many programming languages. The basic logic behind this algorithm is in ordering every element based on a <span><em class="italic">pivot element</em></span>. The script picks an initial element to be used as the pivot element. Then the list is reordered based on the pivot element, placing every element less than the pivot in one list and every element higher <a class="calibre17" shape="rect"/>in another list. The median is the final spot for the <a class="calibre17" shape="rect"/>pivot element. Once all elements have been ordered on this pivot, the process is repeated for each sublist. The algorithm is considered a divide-and-conquer sort.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_465"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos750925"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"> require 'benchmark'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       def quick_sort(f, aArray)<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00002.jpg"/>     return [] if aArray.empty?<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>     pivot  = aArray[0]<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/><br class="calibre20"/>&#13;
           before = quick_sort(f, aArray[1..-1].delete_if { |x| not f.call(x, pivot) })<br class="calibre20"/>&#13;
           after  = quick_sort(f, aArray[1..-1].delete_if { |x| f.call(x, pivot) })<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>     return (before &lt;&lt; pivot).concat(after)<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/><br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = quick_sort(Proc.new { |x, pivot| x &lt;<br class="calibre20"/>&#13;
       pivot }, big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("<a class="calibre17" shape="rect"/>output_quick_sort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_466"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos752501"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby quickSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_467"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos753095"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script will sort the data set and output the ordered results to <span><em class="italic">output_quick_sort.txt</em></span>, then report the amount of time used to execute the script:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      0.094000   0.000000   0.094000 (  0.094000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_468"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos753912"/>How It Works</span></h2>
    </div>

    <p class="calibre4"><a class="calibre17" shape="rect"/>Quick sort is another algorithm that uses recursion to accomplish the sort. The <a class="calibre17" shape="rect"/>sorting begins by checking if the array is empty <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. With recursion, you must have a condition to return to the calling method, and an empty array is just that condition. Next, a pivot is chosen—in this case, the first element of the passed array <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>.</p>

    <p class="calibre4">The next two lines have a lot going on, so I'll break them down. The <code class="calibre19">before</code> and <code class="calibre19">after</code> variables will contain the elements in relation to the current pivot element. Looking at the variable <code class="calibre19">before</code>, you can see that <code class="calibre19">quick_sort</code> is recursively <a class="calibre17" shape="rect"/>called <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. The <code class="calibre19">quick_sort</code> method takes two arguments. The first is a <code class="calibre19">proc</code> object, and the second is an array. <code class="calibre19">proc</code> objects are unique because the local variables within the blocks of code are bound to the object, and the code can be called in multiple contexts to retrieve the bound variables. The <code class="calibre19">proc</code> is initially created in the first <code class="calibre19">quick_sort</code> call within the harness <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>. It is used to compare an element with the chosen pivot element.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The second argument passed to <code class="calibre19">quick_sort</code> is the data set array. In the recursive calls, the second argument is actually an array that contains a subset of the original data set. The sort uses a range within the array and calls the <code class="calibre19">delete_if</code> method. This method does exactly what the name implies. In this case, values in the array are deleted if they are larger than the pivot value. The <code class="calibre19">call</code> method invokes the <code class="calibre19">proc</code> object defined earlier and actually carries out the comparison. The final array passed will contain every value less than the pivot value. The opposite is true for the <code class="calibre19">after</code> variable. The <code class="calibre19">proc</code> object and every variable in the list smaller than the pivot element are passed. The halves are broken down until the pivot value is the only remaining element. With each return, the pivot value is added to the <code class="calibre19">before</code> array, and the <code class="calibre19">after</code> array is concatenated. After breaking the array down to one element and <a class="calibre17" shape="rect"/>sorting them on the way up, the array is completely sorted on the final <code class="calibre19">before</code>/<code class="calibre19">pivot</code>/<code class="calibre19">after</code> concatenation <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_469"/>


  <div class="calibre3 calibre3 calibre3 calibre3" id="filepos757847">
    <h1 class="calibre1" id="calibre_pb_470"><span class="calibre2"><a class="calibre7" shape="rect"/>Shear Sort</span></h1>
  </div>


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_471"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos758332"/>Shear Sort</span></h2>
    </div>

    <div class="calibre3">
      <div class="calibre3 calibre3 calibre3">
        <h3 class="calibre16" id="heading_id_2"><a class="calibre7" shape="rect"/>shearSort.rb</h3>
      </div>

      <p class="calibre4">Shear sort is extremely efficient, but only on a parallel processor. When you see the benchmark output, you'll notice a higher time than the other sorts. However, when operating with more than one processor, a <span><em class="italic">2D mesh</em></span> is created. The advantage of the 2D mesh is that sorts can be made concurrently on the rows and columns—you get two sorts for each clock cycle! This algorithm is a perfect example of divide-and-conquer.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_472"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos759517"/>The Code</span></h2>&#13;
    </div><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"><img alt="" class="calibre23" src="../Images/00002.jpg"/> class Shear_sort<br class="calibre20"/>&#13;
           def sort(a)<br class="calibre20"/>&#13;
               div = 1<br class="calibre20"/>&#13;
               i   = 1<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00003.jpg"/>         while i * i &lt;= a.length<br class="calibre20"/>&#13;
                   if a.length % i == 0<br class="calibre20"/>&#13;
                       div = i<br class="calibre20"/>&#13;
                   end<br class="calibre20"/>&#13;
               i += 1<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           @rows = div<br class="calibre20"/>&#13;
               @cols = a.length/div<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00004.jpg"/>         @log = Math.log(@rows).to_i<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00005.jpg"/>             @log.times do<br class="calibre20"/>&#13;
                   (@cols / 2).times do<br class="calibre20"/>&#13;
                   @rows.times do |i|<br class="calibre20"/>&#13;
                   part1_<a class="calibre17" shape="rect"/>sort(a, i*@cols, (i+1)*@cols, 1, i % 2 == 0)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
               @rows.times do |i|<br class="calibre20"/>&#13;
                   part2_sort(a, i*@cols, (i+1)*@cols, 1, i % 2 == 0)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
           (@rows / 2).times do<br class="calibre20"/>&#13;
               @cols.times do |i|<br class="calibre20"/>&#13;
                   part1_sort(a, i, @rows*@cols+i, @cols, true)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
               @cols.times do |i|<br class="calibre20"/>&#13;
                   part2_sort(a, i, @rows*@cols+i, @cols, true)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00006.jpg"/>     (@cols / 2).times do<br class="calibre20"/>&#13;
               @rows.times do |i|<br class="calibre20"/>&#13;
                   part1_sort(a, i*@cols, (i+1)*@cols, 1, true)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
               @rows.times do |i|<br class="calibre20"/>&#13;
                   part2_sort(a, i*@cols, (i+1)*@cols, 1, true)<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
           return a<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00007.jpg"/> def part1_sort(ap_array, a_low, a_hi, a_nx, a_up)<br class="calibre20"/>&#13;
             part_sort(ap_array, a_low, a_hi, a_nx, a_up)<br class="calibre20"/>&#13;
         end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
         def part2_sort(ap_array, a_low, a_hi, a_nx, a_up)<br class="calibre20"/>&#13;
             part_sort(ap_array, a_low + a_nx, a_hi, a_nx, a_up)<br class="calibre20"/>&#13;
         end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
         def part_sort(ap_array, j, a_hi, a_nx, a_up)<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00008.jpg"/>         while (j + a_nx) &lt; a_hi<br class="calibre20"/>&#13;
      <img alt="" class="calibre23" src="../Images/00009.jpg"/><br class="calibre20"/>&#13;
                if((a_up &amp;&amp; ap_array[j] &gt; ap_array[j+a_nx]) || !a_up &amp;&amp; ap_array[j] &lt;<br class="calibre20"/>&#13;
       ap_array[j+a_nx])<br class="calibre20"/>&#13;
                     ap_array[j], ap_array[j + a_nx] = ap_array[j+a_nx], ap_array[j]<br class="calibre20"/>&#13;
                 end<br class="calibre20"/>&#13;
                 j += a_nx * 2<br class="calibre20"/>&#13;
               end<br class="calibre20"/>&#13;
           end<br class="calibre20"/>&#13;
       end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       big_array = Array.new<br class="calibre20"/>&#13;
       big_array_sorted = Array.new<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       IO.foreach("1000RanNum.txt", $\ = ' ') {|num| big_array.push num.to_i }<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       puts Benchmark.measure {big_array_sorted = <a class="calibre17" shape="rect"/>Shear_sort.new.sort(big_array)}<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
       File.open("<a class="calibre17" shape="rect"/>output_shear_sort.txt","w") do |out|<br class="calibre20"/>&#13;
           out.puts big_array_sorted<br class="calibre20"/>&#13;
       end</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_473"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos764054"/>Running the Code</span></h2>
    </div>

    <p class="calibre4">Execute this script by typing:</p><a class="calibre17" shape="rect"/>

    <div class="calibre3">
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">ruby shearSort.rb</code></strong></tt></span>
    </div>
  </div>


  <div class="calibre3">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h2 class="calibre8" id="calibre_pb_474"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos764648"/>The Results</span></h2>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script will sort the random numbers and output the ordered data to <span><em class="italic">output_shear_sort.txt</em></span>, then output the amount of time used to execute the script:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">user       system     total    real<br class="calibre20"/>&#13;
      4.875000   0.000000   4.875000 (  4.875000)</tt></span>&#13;
    </div>&#13;
  </div>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h2 class="calibre8" id="calibre_pb_475"><span class="calibre9"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos765468"/>How It Works</span></h2>
    </div>

    <p class="calibre4">Until this point, each of the sorts has been optimized for a single-processor architecture. <a class="calibre17" shape="rect"/>Shear sort leverages the efficiencies of <a class="calibre17" shape="rect"/>multiple processors. As mentioned above, a 2D mesh is created, and the variables <code class="calibre19">@rows</code> and <code class="calibre19">@cols</code> track the mesh. The <a class="calibre17" shape="rect"/>sort methods are grouped together in a class called <code class="calibre19">Shear_sort</code> <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00002.jpg"/></span>. The class is composed of four methods, but two of the methods (<code class="calibre19">part1_sort</code> and <code class="calibre19">part2_sort</code>) are nearly identical. The first method we will analyze is <code class="calibre19">sort</code>. This method is responsible for calling the two other <a class="calibre17" shape="rect"/>sorting methods, as well as maintaining control over all of the sorted parts, like a manager. The method begins by defining a few variables used to hold information when creating the 2D mesh.</p>

    <p class="calibre4">The first while loop is used to make some calculations need to design the 2D mesh <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00003.jpg"/></span>. The operations tell the script how many rows there will be in the mesh. Using the number of rows divided by the length of the data set will yield how many columns are needed to create the 2D mesh. The dimensions of the 2D mesh are stored in <code class="calibre19">@rows</code> and <code class="calibre19">@cols</code>.</p>

    <p class="calibre4">Next, <code class="calibre19">@log</code> is calculated. This calculation is a <code class="calibre19">logarithmic</code> method of the data set length (this method is found in the Math library) <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00004.jpg"/></span>. <code class="calibre19">@log</code> will be used to limit the amount of times we loop through the first of two <a class="calibre17" shape="rect"/>sorting iterations. This <code class="calibre19">@log</code> loop begins the sorting process, and it is also the first time we call <code class="calibre19">part1_sort</code> and <code class="calibre19">part2_sort</code> <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00005.jpg"/></span>. There are a lot of nested loops in here, so note that the order of sorts is rows first, followed by columns. The sorting of rows is actually done in alternating directions, and that is where the last argument of <code class="calibre19">part1_sort</code> comes into play. Even-numbered rows are sorted from left to right, and odd-numbered rows are sorted the other way. Don't worry though, the last while loop we'll look at corrects this alternating sort. The columns are also sorted in the third while loop, but they are sorted in the same direction every time. This process is performed log(<span><em class="italic">n</em></span>) times, or <code class="calibre19">@log</code>.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">After the <code class="calibre19">@log</code> loop has terminated, another round of looping is required to complete the sorting of the data set <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00006.jpg"/></span>. Remember that the row sorting was done using <a class="calibre17" shape="rect"/>alternating sorts; this time, the sorting is performed in the same direction. The final sort is a copy from the row sorting loop above. The only difference is that the last argument passed to <code class="calibre19">part1_sort</code> and <code class="calibre19">part2_sort</code> is specified to <code class="calibre19">true</code>. Once again, this loop sorts the data set further and, more importantly, finalizes the positions of all the elements within the original data set.</p>

    <p class="calibre4">I'll only describe <code class="calibre19">part1_sort</code> because, as I mentioned earlier, it's nearly identical to <code class="calibre19">part2_sort</code>. Don't worry—I'll point out the differences for you just in case you missed them. If multiple processors were available, the sorting of parts one and two would occur simultaneously, giving <a class="calibre17" shape="rect"/>shear sort a very short execution time for large data sets. The <code class="calibre19">part1_sort</code> method takes five arguments: an array, a low number, a high number, a column, and a Boolean value <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00007.jpg"/></span>. The difference between these two <code class="calibre19">part</code> sorts is the calculation of the second argument. If you trace the method of <code class="calibre19">part_sort</code>, you will see the variable <code class="calibre19">j</code>. This variable relates to which part of the data set is being manipulated, and therein lies the difference between the two <code class="calibre19">part</code> sorts <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00008.jpg"/></span>. If you were to view the data set in the middle of the algorithm, you wouldn't see a 2D array. Instead, the 2D mesh is all based on element positions. If the mesh had five columns and five rows, then every fifth element would be the start of a column, and the elements in between would represent pieces of a row. Now if you see the element comparisons and wonder why the algorithm is comparing elements' distances from each other, you'll know why!</p>

    <p class="calibre4">If the Boolean argument is <code class="calibre19">true</code> and the lower indexed element is greater than the higher indexed element, then the values are swapped. The same is true if the Boolean argument is <code class="calibre19">false</code> and the lower indexed element is less than the higher indexed element. If neither of the conditions is valid, the while loop moves on <span><a class="calibre17" shape="rect"/><img alt="" class="calibre23" src="../Images/00009.jpg"/></span>. By using the <code class="calibre19">if</code> statement, alternating sorts are possible.</p>

    <p class="calibre4">Once all the loops have finished running, the array will be sorted. The array, stored in the variable <code class="calibre19">a</code>, is returned to the calling function. Overall, this sort has a lot of code, but the efficiencies are truly remarkable.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_476"/>


  <div class="calibre3" id="filepos772840">
    <div class="calibre3 calibre3 calibre3">
      <h1 class="calibre1" id="calibre_pb_477"><span class="calibre2"><a class="calibre7" shape="rect"/>A Note About Efficiencies</span></h1>
    </div>

    <p class="calibre4">Efficiency may or may not be something you have thought about as you've scripted or written applications. However, I bet if you were to write anything that scaled, or could be expanded, efficiency would become important. Honestly, you could use any of the algorithms presented in this chapter to sort an array of 10 elements, and you wouldn't notice a bit of performance difference. What about if you start sorting arrays of 10,000 elements? 100,000 elements? The performance issue will become a bit more noticeable. The situation and context of the script you're writing should determine the best sorting algorithm to use. Experience will give you more insight into the best tool to accomplish the job.</p>

    <p class="calibre4">While on the topic of efficiency, sorting algorithms aren't the only place to improve efficiencies within a script. Searching algorithms, processing vectors, logical checks, or conditional loops can all be scrutinized for ways to improve efficiency. There is usually more than one way to solve a problem; if you don't know the best way to accomplish a specific task, experiment with several methods, and use the benchmarking library to help you compare the results of the different approaches. Don't just stop with sorting algorithms, think about the code you're writing holistically, and see if there are ways to accomplish your objective more efficiently.<a class="calibre17" shape="rect"/></p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_478"/>
</body></html>