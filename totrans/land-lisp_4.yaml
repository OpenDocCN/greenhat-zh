- en: Part IV. Lisp is Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781390.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Chapter 14. Ramping Lisp Up a Notch with Functional Programming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen in the preceding chapters, Lisp makes it pretty easy to throw
    together some quick code and build some simple games in no time. However, Lisp’s
    main claim to fame is as an academic tool, appropriate for tackling the most complicated
    scientific problems. The fact that it’s also great for hacking is arguably just
    a side benefit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book, we’re going to focus on the scientific side of the
    language, exploring some advanced techniques to build a more sophisticated game
    that I hope will really blow your mind. It will do things you may never have thought
    would be possible in a computer program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’re going to learn about the first advanced Lisp concept,
    called the *functional programming technique*. In the next chapter, we’ll use
    this technique to build a simple dice wars game, as well as a crude artificially
    intelligent opponent to play against!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: What Is Functional Programming?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already discussed the concept of functional programming a bit in earlier
    chapters. The glib answer is that functional programming is “a style of programming
    where we write all of our code using functions.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: However, we mean something very specific when using the term *function* in this
    context—exactly the same thing that mathematicians mean when they use the word
    *function*. So, what do mathematicians mean when they use this word?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably already know the answer. Try to remember way, way back when you
    took pre-algebra. If you didn’t fall asleep during that particular lesson, you
    might remember your teacher drawing something like this on the chalkboard:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782772.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: This picture shows that a function has arguments that may go into it, called
    the *domain* of the function. The function then takes these arguments and returns
    a value. This value is said to fall within the *range* of the function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some advanced Lispers will cringe when someone says that a function “returns
    a value.” This is because Lisp derives from a something called the *lambda calculus*,
    which is a fundamental programming-like algebra developed back in the 1930s by
    Alonzo Church. In the lambda calculus, you “run” a program by performing substitution
    rules on the starting program to determine the result of a function. Hence, the
    result of a set of functions just sort of magically appears by performing substitutions;
    never does a function consciously “decide” to return a value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, Lisp purists prefer to say that a function “evaluates to a
    result.” However, almost everyone else in the programming world likes to say that
    functions return a value. It’s up to you to decide which way of thinking about
    functions feels the most natural.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important properties of mathematical functions that we’ll want
    our Lisp functions to obey as well:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The function always returns the same result, as long as the same arguments are
    passed into it. (This is often referred to as *referential transparency*.)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function never references variables that are defined outside the function,
    unless we are certain that these variables will remain constant.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No variables are modified (or *mutated*, as functional programmers like to say)
    by the function.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the function is to do nothing other than to return a result.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function doesn’t do anything that is visible to the outside world, such
    as pop up a dialog box on the screen or make your computer go “Bing!”
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function doesn’t take information from an outside source, such as the keyboard
    or the hard drive.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we obey these rules whenever possible, we can say that our code is written
    in the *functional style*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of a true mathematical function is the sine function. Similarly,
    the `sin` function in Lisp (which calculates the mathematical sine) is a great
    example of a Lisp function that obeys the rules of the functional style:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sin` function always returns the same result, as long as you always pass
    the same argument (in this case, `0.5`) into it. It doesn’t do anything to interact
    with the outside world. Its entire purpose in life is to return the sine as a
    value. It obeys all the rules in the preceding list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, it would be impossible to write *all* the code in a computer program
    in the functional style. For instance, one of the rules stipulates that the computer
    isn’t allowed to go “Bing!”—who would want to use a computer if it didn’t go “Bing!”
    once in a while?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781022.png.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Whenever a piece of code does something that is visible to the outside world,
    such as go “Bing!” or display a dialog box on the screen, we say that the code
    *causes a side effect*. Functional programmers think of such side effects as making
    your code “dirty.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The technical term for such dirty code that contains side effects is *imperative
    code*. The term *imperative* implies that the code is written in a “cookbook”
    style, where you basically say things like “first do this, and then do that.”
    Like a cookbook, most lines in imperative code perform side effects, such as writing
    to the screen or modifying a global variable. Imperative code is the opposite
    of functional code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the central philosophy of functional programming. It states
    that you should break your program into two parts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The first, and biggest part, should be completely functional and free of side
    effects. This is the clean part of your program.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second, smaller part of your program is the part that has all the side effects,
    interacting with the user and the rest of the outside world. This code is dirty
    and should be kept as small as possible.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a piece of code pops up a dialog box, for example, we deem it dirty and banish
    it to the imperative section of our code. Things like dialog boxes are not really
    math, and we shouldn’t let them play with our math functions and other clean,
    functional code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781918.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Anatomy of a Program Written in the Functional Style
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve discussed how functional programming is done, let’s write a simple
    program that follows this style. Since we want this program to be a typical example
    of most software, we should figure out what most software in the world actually
    does. So what do most programs in the world actually do? They keep track of widgets!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781308.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Here’s our entire example program, written in the functional style:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As promised, it is split into two parts: the *clean part* and the *dirty part*.
    I did say that the clean part of the program should be much bigger than the dirty
    part. However, since this example is so short, the dirty part ended up a bit bigger.
    Usually, you can expect the clean part to be around 80 percent of the actual code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some programming languages are even more focused on functional programming than
    Lisp is. Haskell, for instance, has powerful features that let you write 99.9
    percent of your code in a functional style. In the end, however, your program
    will still need to have some kind of side effect; otherwise, your code couldn’t
    accomplish anything useful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does our example program do? Well, it basically does what most computer
    programs in the world are designed to do: It keeps track of widgets in a database!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The database in this example is very primitive. It’s just a Lisp list, stored
    in the global variable `*database*`. Since the database is going to start off
    empty, we initialize this variable and set it to be empty ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We can call the function `main-loop` to start tracking some widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
    This function just starts an infinite loop, asking the user for a widget name
    ![](httpatomoreillycomsourcenostarchimages783510.png). Then, after it reads in
    the widget, it calls the `add-widget` function to add the new widget to the database
    ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: However, the `add-widget` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    is in the clean part of the code. That means it’s functional and isn’t allowed
    to modify the `*database*` variable directly. Like all functional code, the `add-widget`
    function is allowed to do nothing more than return a new value. This means that
    the only way it can “add” a widget to a database is to return a brand-new database!
    It does this by simply taking the database passed to it and then consing the widget
    to the database to create a new database ![](httpatomoreillycomsourcenostarchimages783562.png).
    The new database is identical to the previous one, except that it now contains
    a new widget at the front of the list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of how crazy this sounds on the face of it. Imagine that we’re running
    an Oracle database server, containing millions of widgets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782052.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Then, when we add a new widget, the database server accomplishes this by creating
    a brand-new replica of the previous database, which differs only in that a single
    new item has been added:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781440.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: This would be horribly inefficient. However, in our widgets example, things
    are not as bad as they may first appear. It is true that the `add-widgets` function
    creates a new list of widgets every time it is called, and that repeated calls
    to this function would make the list longer and longer. However, since every new
    widget is simply added to the front of the list, it turns out that the tail end
    of the widget list is identical to the previous version of the list. Hence, the
    `add-widget` function can “cheat” whenever it creates a new list, by simply consing
    a single new widget to the front of the list, and then repurposing the old list
    as a tail to hold the rest of the items ![](httpatomoreillycomsourcenostarchimages783562.png).
    This allows the new list to be created in a way that is fast and also requires
    very little new memory to be allocated. In fact, the only new memory allocated
    by `add-widget` is a single new cons cell to link the new widget to the previous
    list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This type of cheating when creating new data structures is a key technique that
    makes efficient functional programming possible. Furthermore, sharing of structures
    can be done safely, since one of the tenets of functional programming is to never
    modify old pieces of data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'So our `add-widget` function creates a new database for us with the additional
    item added to it. The `main-loop` function, in the dirty part of the code, sets
    the global `*database*` variable equal to this new database. In this way, we have
    indirectly modified the database in two steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The `add-widget` function, which is basically the brains of this program, generated
    an updated database for us.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `main-loop` function, which was in charge of the dirty work, modified the
    global `*database*` variable to complete the operation.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This example program illustrates the basic layout of a Lisp program written
    in the functional style. Let’s try out our new program to see it in action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that you can hit ctrl-C to exit the infinite loop in this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common stumbling block for programmers learning to write programs in the
    functional style is that they find it hard to combine different chunks of code
    to perform a single action. This is called *code composition*. A programming language
    should make code composition easy. In other words, it should make it easy for
    you to take different pieces of code and use them together to solve a task. The
    most powerful tool for code composition when writing functional code is *higher-order
    programming*, which lets you use functions that accept other functions as parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to understand why code composition can be a challenge
    to a beginning functional programmer. Suppose we want to add two to every number
    in the following list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To do this, we will need to write code to traverse the list, as well as write
    code to add two to a number. These are the two tasks we need to compose.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Code Composition with Imperative Code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One possible naïve (and imperative) way to perform this task is to use a `loop`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we’re creating a variable `n` that counts through all the items in the
    list in a `loop` ![](httpatomoreillycomsourcenostarchimages783564.png). We then
    use `setf` to add two to the number at the location `n` in the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is similar to the sort of code you might write if you were a C programmer.
    Although it’s pretty ugly, there are positive things that can be said about it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Code structured like this is potentially very efficient. It’s space-efficient,
    since we don’t need to allocate any memory for storing a new list (we’re just
    munging the old list to increase all the numbers in it by two). And it could also
    be very time-efficient, if we rewrote this loop to work on an array instead of
    a list. (Remember that finding the *n*th item in a list is slow.)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code written like this clearly composes the task of looping ![](httpatomoreillycomsourcenostarchimages783564.png)
    and the task of adding two to a number ![](httpatomoreillycomsourcenostarchimages783562.png).
    By putting our code for the addition inside the loop, we are composing these two
    activities to complete a more complicated goal: adding two to an entire list of
    numbers.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are obvious downsides to the imperative approach:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: It destroys the original list. This is a problem if we use the `*my-list*` variable
    later, and miss the fact that this code has messed up the original values in this
    list. A Lisper would say that allowing the `*my-list*` variable to be modified
    willy-nilly makes this variable a piece of *hidden state* in the program. Bugs
    related to hidden state are common in programming languages that encourage imperative-style
    programming.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We needed to create a variable `n` ![](httpatomoreillycomsourcenostarchimages783564.png)
    to keep track of our position in the list. This makes the code more bulky and
    also adds more places where bugs could lurk. There’s always a risk that we give
    `n` a wrong value or use it incorrectly to access items from the list.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Functional Style
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s see what happens if we rewrite this code in a functional style. Let’s
    first write it as a beginning functional programmer might, without using higher-order
    programming:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we’re creating a function `add-two` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds two to the number at the front of the list and then calls itself recursively
    to build the tail of the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'This code avoids many of the downsides from the imperative solution. It does
    not destroy the original list, and it does not require us to use a numeric index.
    Unfortunately, it also lacks one of the critical benefits of the imperative version:
    There is no longer a clear delineation between the code that adds two to items
    in the list and the code that traverses the list. These two activities are now
    deeply intertwined, which is the reason we needed to create a special function,
    `add-two`, to make this solution work. We have lost our ability to compose these
    two tasks in a clean way.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming to the Rescue
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to write code for this task in a functional style, but still allow
    our code to be composable, we’ll need to make use of higher-order functions. Here
    is how an experienced Lisper would add two to every number in a list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we finally have a version of the code that is functional *and* allows us
    to compose the traversal code and the addition code. Here, the traversal is performed
    by the `mapcar` function, which is a higher-order function since it applies a
    supplied function to every member in a list. The addition is performed by a lambda
    function, which is responsible only for adding two to a number, and is oblivious
    to the fact that the numbers are in a list. This example shows that higher-order
    programming can let us write clearly delineated chunks of code and then compose
    them, without needing to break from the functional style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Why Functional Programming Is Crazy
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know one reason why functional programming is crazy: Functional
    programs can’t really do anything, since they can’t have *side effects*. As Simon
    Peyton Jones, a well-known functional programmer, likes to say, “All you can do
    without side effects is push a button and watch the box get hot for a while.”
    (Which isn’t technically true, since even the box getting hot is a side effect.)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen that we can work around this limitation of functional programming
    by adding a dirty section to our programs, which is kept separate from the rest
    of the code and contains all our code that is imperative and not in the functional
    style. However, recall the problem with the functional style: It can cause code
    to be extremely inefficient.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Performance has always been a huge concern with functional programs. Having
    to write code that isn’t allowed to mutate the value of existing variables, but
    only create new variables, can lead to a huge amount of memory copying and memory
    allocation, which can slow programs down to a crawl. One way to mitigate this
    copying and allocation is by using shared structures between different pieces
    of data in our programs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, code written in the functional style has other properties that
    affect performance. For instance, functional code uses a lot of recursion, instead
    of looping. Using recursion causes the Lisp compiler/interpreter to put a lot
    of items on the program stack, which can be very slow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, functional programmers have developed optimization techniques that
    can solve the vast majority of performance problems. These include memoization,
    tail call optimization, lazy evaluation, and higher-order programming, which we’ll
    cover in the next few chapters. Using these techniques and others, an experienced
    functional programmer can write code that is usually comparable in performance
    to code written in any other style.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: However, some types of programs just can’t be written in a purely functional
    way. For instance, you probably wouldn’t write something like a full-on Oracle-style
    relational database system in a functional style. Yet, smaller, memory-resident
    database systems may be able to use purely functional techniques (an example is
    the HAppS-IxSet available to Haskell programmers at [http://happs.org/](http://happs.org/)).
    So there is really no hard limit as to when functional programming can be used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Why Functional Programming Is Fantastic
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that I’ve told you about all the headaches a functional programmer must
    endure, you may be wondering, “Why would anyone bother to program this way?” The
    answer is that functional programming has many enticing benefits that make up
    for these headaches.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming Reduces Bugs
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bugs in computer programs usually happen because, under certain circumstances,
    the code behaves in ways the programmer didn’t expect when the code was written.
    In functional programming, the behavior of your functions depends on one and only
    one thing: the arguments explicitly passed into the function. This makes it much
    easier for a programmer to appreciate all the circumstances a program could possibly
    encounter, including circumstances that could lead to errors.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions that depend on only their arguments for their behavior also
    makes bugs easy to duplicate. If you call a function with the same data passed
    in through its arguments, it should do the same exact thing every time. This is
    the property we called *referential transparency*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programs Are More Compact
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out a lot of the work in run-of-the-mill computer programs involves
    creating, initializing, and updating variables. Functional programs don’t do any
    of this. As we discussed earlier, functional programs make use of higher-order
    functions, which don’t require us to create tons of temporary variables in our
    code, and that makes our code more compact.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Functional Code Is More Elegant
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest advantage of functional programming is that it brings all of computer
    programming back to the domain of mathematics. It wouldn’t make sense for a math
    equation to pop up a dialog box or write to the hard drive. It can be argued that
    if we get our computer code back to this same level of purity, it will be far
    more elegant. Additionally, if our code is closer to the world of mathematics,
    we may be able to use tools in mathematics to write better computer code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a lot of research continues to be done in using mathematical proofs
    to check for the correctness of functional computer programs. Although this research
    still isn’t to the point where a practical programmer would use such techniques,
    they may be more common in the future. And, almost certainly, a functional programming
    style will be essential in making correctness proofs on your code possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed functional programming. Along the way, you learned
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Programs written in the *functional style* always give the same result when
    they are given the same values in their arguments.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs do not contain *side effects*. Their whole purpose in life
    is to just calculate a value to return.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that are not functional usually read like a cookbook, with statements
    like, “First do this, and then do that.” This style of programming is called *imperative
    programming*.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good strategy for writing Lisp programs is to break them into a clean, functional
    part and a dirty, imperative part.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs can be written quickly, are more compact, and tend to have
    fewer bugs, particularly in the hands of an experienced functional programmer.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 15. Dice of Doom, a Game Written in the Functional Style
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’re finally ready to create a more sophisticated (and fun) computer program
    in the functional style. As we expand this program throughout the rest of this
    book, you’ll learn about techniques for writing elegant functional code, while
    at the same time maintaining strong performance in your programs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782714.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: The Rules of Dice of Doom
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dice of Doom is a game in the same family as Risk, Dice Wars ([http://www.gamedesign.jp/flash/dice/dice.html](http://www.gamedesign.jp/flash/dice/dice.html)),
    and KDice ([http://kdice.com/](http://kdice.com/)). In the beginning, we’re going
    to keep the rules of Dice of Doom mind-numbingly simple. In later chapters, we’ll
    expand the rules, until eventually we’ll have a game very similar to Dice Wars.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the simplified rules we’ll start with:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Two players (named A and B) occupy spaces on a hexagonal grid. Each hexagon
    in the grid will have some six-sided dice on it, owned by the occupant.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During a turn, a player can perform any number of moves, but must perform at
    least one move. If the player cannot move, the game ends.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move consists of attacking a neighboring hexagon owned by the opponent. The
    player must have more dice in her hexagon than the neighboring hexagon in order
    to attack. For now, all attacks will automatically lead to a win. In future variants,
    we’ll actually roll the dice for a battle. But for now, the player with more dice
    just wins automatically.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After winning a battle, the losing player’s dice are removed from the board,
    and all but one of the winning player’s dice are moved onto the newly won hexagon.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a player is finished making her moves, reinforcements are added to that
    player’s dice armies. Reinforcements to the player’s occupied hexagons are added
    one die at a time, starting from the upper-left corner, moving across and down.
    The maximum number of dice added as reinforcements is one less than the player
    took from the opponent in her completed turn.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a player can no longer take her turn, the game has ended. The player who
    occupies the most hexagons at this point is the winner. (A tie is also possible.)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sample Game of Dice of Doom
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our implementation of Dice of Doom will include an AI player, we’re going
    to start with an extremely humble size for our game board. As you probably know,
    AI code can be very computationally intensive. In our early, very naive version
    of this game, any board larger than a 2-by-2 grid of hexagons would bring CLISP
    to its knees!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a complete game, played on a puny 2-by-2 board:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783538.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: At the beginning of the game, player A (indicated with black hexagons) possesses
    the top two hexagons, with three dice on each. Player B occupies the bottom row
    (indicated by the white hexagons), with three dice and one die, respectively.
    Player A attacks the lone die with one of his piles. After the attack, one of
    player A’s dice remains behind, while the others move to the conquered spot. Then
    player A passes the turn.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782970.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Player B now attacks player A’s two dice with a pile of three. Player B then
    passes. At this point, player B receives a single reinforcement die on her left
    hexagon. This is because she killed two of player A’s dice. The reinforcements,
    as per the rules, consist of the number of dice killed, minus one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782752.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Player A now attacks with three of his dice and passes. Also, he gets a reinforcement
    die.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782186.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Player B now has only one legal move, attacking two against one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781602.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Player A now has the upper hand, killing all of player B’s remaining dice. As
    you can see, player A is permitted to perform multiple attacks on his turn before
    passing. The game has ended with player A as the winner.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dice of Doom, Version 1
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start coding this game in Lisp. As we discussed in the previous chapter,
    this game will contain both clean, functional code and dirty, imperative code.
    You’ll be able to tell in which category a block of code fits by the “clean/functional”
    or “dirty/imperative” icon next to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Defining Some Global Variables
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll create some global variables that define the basic parameters
    for our game:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’re stating that there will be two players ![](httpatomoreillycomsourcenostarchimages783564.png),
    that the maximum number of dice on a square is three ![](httpatomoreillycomsourcenostarchimages783562.png),
    and that the board will be 2-by-2 ![](httpatomoreillycomsourcenostarchimages783560.png).
    In later versions of Dice of Doom, we’ll increase all of these parameters, to
    allow for a more challenging game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s useful to know the total number or hexagons there are at the current
    board size, we also define `*board-hexnum*` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Note that even though the grid is made of hexagons, it is still basically a square
    grid, since the number of hexagons just equals the square of the side of the grid.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, every code sample has an associated icon to indicate whether
    it is made of dirty, imperative or clean, functional code. By the end of this
    chapter, you should be able to easily tell the difference and have some appreciation
    for the benefits of each style.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Representing the Game Board
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to represent the game board using a simple list. The hexagons will
    be stored in this list, starting at the top left, and then moving across and down.
    For each hexagon, we’ll store a list of two items: a number indicating the current
    occupant of the hexagon and another number indicating the number of dice at that
    location.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here is an example of a game board and the list that encodes
    it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779855.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that most Lisp programmers like to count starting at zero. Therefore, players
    A and B are represented with the numbers 0 and 1\. This list indicates that player
    A has three dice on the first hexagon and three on the second. Player B has three
    dice on the third hexagon and one on the fourth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: When we create our AI player, it will need to be able to look at many hexagons
    on the board very quickly. Because of this, we’re going to create a second representation
    of our board in the form of an array. Remember that checking a numeric location
    (for instance, hexagon 2) in a list requires the `nth` function, which is potentially
    slow. Arrays, on the other hand, will allow for very fast lookup at a specific
    location, even with very large board sizes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The `board-array` function converts a board represented with a list to an array
    for us:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the game begins, we’ll start with a randomized board. Here’s the function
    that creates a random board:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function is not in the functional style (as the icon indicates), since
    it will create a different, random result every time it is called. It generates
    the board as a list, but then converts the list to our speedier array format when
    it’s done, using `board-array` ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: It generates random values using the Lisp function `random`. This function produces
    a different random integer every time, greater than or equal to zero, but smaller
    than the number passed to it. We use our `*num-players*` and `*max-dice*` global
    variables to generate random values for each hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out the `gen-board` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember that the hash mark (#) indicates that we’ve created an array, not a
    list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name our players using letters (just A and B, until we start introducing
    more players). Here’s a function that converts a player number into a letter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `code-char` function converts an ASCII code into the appropriate character.
    Let’s call it for player 1 to see the result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, let’s create a function that will take an encoded board and draw it
    in a pretty way on the screen. It will tilt the board in the same way as our drawings,
    so it’s obvious which six hexagons neighbor any given hexagon.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the whole purpose of this `draw-board` function is to write stuff to the
    console, it’s definitely not functional. Let’s look at this function more closely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The outer `loop` runs through all the rows of the board, stored in the variable
    `y` ![](httpatomoreillycomsourcenostarchimages783564.png). There are two inner
    `loop`s. The first inner `loop` adds the indentation to the left side to give
    the board that tilted look ![](httpatomoreillycomsourcenostarchimages783562.png).
    The second inner `loop` loops through the columns, stored in the variable `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png). It then uses `x` and `y`
    to calculate the appropriate hex number, and retrieves that hex from the board
    array using `aref` ![](httpatomoreillycomsourcenostarchimages783554.png). Finally,
    it prints the data in the hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of the `draw-board` function, as well as a drawing to compare
    it with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781087.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Decoupling Dice of Doom's Rules from the Rest of the Game
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to write the code that takes care of the guts of our first
    Dice of Doom implementation. In writing this code, we’re going to employ a powerful
    functional programming technique: a *function pipeline*. This means that our game
    is going to consist of a succession of functions that operate, one after another,
    on a big chunk of data, which will hold a representation of our game board, making
    modifications to the structure along the way. A function pipeline will allow us
    to build a game rule engine that’s *100% decoupled from the rest of the game code*.
    To understand why this is so cool, let’s first consider some of what’s involved
    in writing a board game with a smart AI player.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: For one thing, any computer implementation of a board game will need code that
    handles the human player’s moves. This part of the code will need to know the
    rules of the board game and make sure the human player’s move is legal before
    letting it happen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need to write the AI code. And in order for the AI player to pick
    a move, it needs to know all the rules of the board game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice something? Both of these separate parts of our game engine need to understand
    the rules of the game! Clearly, what we want to do is break our game code into
    three big pieces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The handling of the human’s moves
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI player
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rule engine
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One piece handles the player’s moves. Another is the code for the AI player.
    Both of these then talk to some code that understand the rules, sort of a “rule
    engine.” Is this kind of design possible?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional, imperative programming style, it would be very difficult to
    write a program like this. Most imperative game engines duplicate the code that
    “understands the rules,” because of the complexity of writing fully decoupled
    components in an imperative language. The reason for this is that a board game
    requires a lot of context—every move is dependent on what moves preceded it. This
    means that every time the AI module or player-handling module needs to check the
    rules, it must tell the “rule code” the current context in detail. Both would
    need to tell the rule code that “It’s player so-and-so’s turn and the game board
    looks like such-and-such.” Without this information, the rule code can’t tell
    whether or not a move is legal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Passing around this context requires tons of tedious bookkeeping code everywhere,
    is error-prone, and is inefficient. It’s inefficient because, with a naive design,
    the player-handling code may check the legality of moves the AI code had already
    explored and found legal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming, however, we can decouple these three concerns
    entirely in our program. We will be able to do this without bookkeeping code and
    in a way that avoids duplication any legality calculations. We will accomplish
    this by encoding our rule code in a lazy game tree!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic approach we’re using—programming a game in the functional style using
    a lazy game tree and a function pipeline—is described in the classic paper “Why
    Functional Programming Matters” by John Hughes ([http://www.scribd.com/doc/26902/whyfp/](http://www.scribd.com/doc/26902/whyfp/)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll be creating a game tree that is not yet lazy. You’ll
    need to wait until [Chapter 18](ch20.html "Chapter 18. Lazy Programming") to understand
    lazy programming and what a lazy game tree will look like. That’s also when you’ll
    be able to fully appreciate how cool this architectural design really is.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781119.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Generating a Game Tree
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire rule set for our game is encoded in the following master function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `game-tree` function builds a tree of all possible moves, given a certain
    starting configuration. This function will be called only a single time at the
    beginning of the game. It will then recursively build a tree of all possible moves
    for the game, down to the final winning positions. The other parts of our game
    will then elegantly traverse this tree in order to conform to the rules of the
    game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to calculate the legal possible moves of the game tree from a given
    context, the function needs four pieces of data passed to it as arguments ![](httpatomoreillycomsourcenostarchimages783564.png):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: What the board looks like
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current player
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many dice have been captured by the player in the player’s current turn,
    which is needed to calculate any future reinforcements, as per our rules
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the current move is the first move for the current player, because a
    player can’t pass a turn without first making at least one move
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the `game-tree` function creates the tree, it will put information about
    the current board and current player at every branch ![](httpatomoreillycomsourcenostarchimages783562.png).
    The subbranches will then hold all the legal follow-up moves from the current
    branch:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783184.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'There are two types of legal moves possible for players: attack a hexagon or
    pass their turn to the next player (assuming they’ve already attacked at least
    once already). The passing move is added to the list of legal moves through the
    `add-passing-move` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    The attacking moves are added to the list through the `attacking-moves` function
    ![](httpatomoreillycomsourcenostarchimages783554.png). Let’s look at these functions
    next.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Passing Moves
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that adds the passing moves to the game tree:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The job of this function is to add a passing move to the tally of moves, if
    passing is permitted. The current list of moves is passed in to this function
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then the function will
    return the expanded list of moves. If the move is the first move in a player’s
    turn ![](httpatomoreillycomsourcenostarchimages783562.png), no passing is allowed,
    and we just return the unaltered list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we add a new move to the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Every move in our game tree consists of two parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The first part is a description of the move. Since we’re just passing in this
    move, we’ll set the description to `nil` ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the move is an entirely new game tree, which holds the entire
    universe of moves that exists after this move has been performed. We create this
    by recursively calling `game-tree` again ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since this is the end of the player’s turn, the player may receive dice as reinforcements.
    So, we update the board sent to this new `game-tree` call with the `add-new-dice`
    function ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we also will need to change the current player, since a new person’s
    turn is now starting. We do this by adding one to the current player number and
    taking the modulus of the result, with the total number of players as the denominator
    ![](httpatomoreillycomsourcenostarchimages783544.png). Changing a player in this
    fancy way will allow the code to work, even when we increase the number of players
    in the game in future versions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Attacking Moves
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that adds the possible attacking moves to the game tree:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `attacking-moves` function is a bit more complicated than the `add-passing-move`
    function. It’s responsible for scanning the current game board and figuring out
    what moves the current player is legally allowed to perform.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Since it must spend a lot of time figuring out who the player is on a given
    hexagon, we first write a convenience function called `player` that returns the
    player for a given board position ![](httpatomoreillycomsourcenostarchimages783564.png).
    We write a similar function to get the number of dice on a given hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to scan the board top to bottom and find out which squares the
    current player occupies. For each occupied square, there may be one or more legal
    attacks starting at that position. Since the number of attacks from any hexagon
    may vary, we use `mapcan` to scan the board ![](httpatomoreillycomsourcenostarchimages783560.png).
    Remember that `mapcan` lets each hexagon we scan return its results as a list.
    Then `mapcan` concatenates these lists together. This way, any scanned hexagon
    can contribute zero to *n* moves to the list.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Within the `lambda` function used by the `mapcan`, which gets called for every
    hexagon, we first want to check whether the current player occupies this hexagon
    ![](httpatomoreillycomsourcenostarchimages783554.png). Then we want to check all
    of its neighbors to see if any of them present a viable attack. We do this with
    another `mapcan` ![](httpatomoreillycomsourcenostarchimages783510.png). We’ll
    figure out the neighbors to this hexagon by using the `neighbors` function, which
    we’ll write shortly ![](httpatomoreillycomsourcenostarchimages783498.png).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: How do we decide if a hexagon can be an attack destination? Well, it must be
    a hexagon we don’t already own, plus (as per the rules) the source hexagon needs
    to have more dice than the destination hexagon ![](httpatomoreillycomsourcenostarchimages783544.png).
    If we have found a legal attack move, we then describe the move ![](httpatomoreillycomsourcenostarchimages783556.png).
    The description is simply a list of the source position and the destination position.
    We then (as with passing moves) recursively generate another game tree that describes
    what happens if the move is executed ![](httpatomoreillycomsourcenostarchimages783566.png).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Neighbors
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s create the function that calculates the neighboring hexagons to
    a given hexagon:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every hexagon on the board may have up to six neighbors, or fewer, if the hexagon
    is on an edge of the board. We build up a list of possible neighbors in a `loop`
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then collect the ones
    with position numbers that aren’t off the edge of the board ![](httpatomoreillycomsourcenostarchimages783554.png).
    Also, since our position numbers wrap from row to row, we need to make sure we
    don’t look to the left if we’re on the left edge of the board ![](httpatomoreillycomsourcenostarchimages783562.png)
    or look to the right if we’re on the right edge of the board ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: This function is marked clean (it is in the functional style), but nonetheless
    contains a loop. Usually, looping goes against the tenets of functional programming.
    However, many Lispers consider it kosher to use a `loop` in functional code if
    all it does is collect some values, since it really isn’t mutating any values
    or producing any other side effects. So, we will allow ourselves to use such loops
    in the functional-style part of this game.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our `neighbors` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781241.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: As you can see, it correctly tells us that hexagon 2 neighbors hexagons 0 and
    3.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Attacking
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s write our `board-attack` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a function that figures out what happens if the hexagon `src` attacks
    the hexagon `dst`. It works by `loop`ing across the board, keeping track of the
    current position ![](httpatomoreillycomsourcenostarchimages783564.png) and the
    contents in the hexagon at that position ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the current hexagon is the source hexagon, we just place a single die in that
    place; as per our rules, a single die is left behind after an attack ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the current hexagon is the destination position, we place the remaining dice
    there, subtracting the one left behind ![](httpatomoreillycomsourcenostarchimages783554.png).
    In other cases, we just collect the very same hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our `board-attack` function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782736.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: As you can see, attacking from hexagon 1 to 3 causes `board-attack` to properly
    update the game board, so that one die remains on the old square and two are on
    the new, conquered square.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the functions in this chapter have inefficiencies to keep things simple.
    We’ll fix many of these in future versions of the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcements
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the reinforcements to the board, we need to scan across the game board,
    find occupied spots that can accommodate another die, and add the die there. Of
    course, the number of reinforcements is limited based on how many opponent dice
    the player captured in the last turn. Because of this, we’ll need to keep a running
    tally of how many reinforcement dice remain.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious way to track the remaining dice would be to have a `remaining-dice`
    variable, and decrement this every time a die is placed. However, having a die
    that is decremented (mutated) would not be in line with the functional style.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, instead, we’re going to write our `add-new-dice` function using a
    local recursive function, which will also maintain this running count of dice.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is this `add-new-dice` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing `add-new-dice` does is define a local function named `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This function will be our list-eater that goes through the hexagons of the board
    and spits out a new list that includes the reinforcements. Since our board is
    actually stored in an array for efficiency reasons, we convert our array into
    a list with the `coerce` function before calling `f` ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function `f`, we must consider three situations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: That we’re at the end of the board. In this case, the reinforced board will
    also be completed, so we just return `nil` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That we’re out of `spare-dice` to add to add as reinforcements. In this case,
    the rest of the board will just be the same as before, so we can just return the
    remainder of the list as the new board ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of the preceding situations. In all other cases, we need to analyze
    the current hexagon and decide whether a reinforcement should be added in it.
    We check whether the current player occupies that hexagon and whether we have
    less than the maximum number of dice on that square ![](httpatomoreillycomsourcenostarchimages783554.png).
    If this is the case, we add a new die on the hexagon and call `f` against the
    rest of the board, recursively ![](httpatomoreillycomsourcenostarchimages783510.png).
    Otherwise, we leave the current hexagon unchanged and proceed by recursively calling
    `f` against the rest of the board ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let try adding reinforcements to a board:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `add-new-dice` properly placed two reinforcement dice for player
    A (player 0).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Trying Out Our New game-tree Function
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now written all the code needed to create a comprehensive game tree
    of our simplified version of Dice of Doom. But be careful! A game tree of most
    board games is excruciatingly large. Even on a 2-by-2 board, our game may consist
    of hundreds of possible moves. You’ll want to call the `game-tree` function only
    on a game board that is near the end of play, or you’ll be watching helplessly
    as the CLISP REPL prints out a humongous tree showing all the possible ways in
    which a game may progress.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a safe board position for you to try out:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783122.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The game tree first lists the current player number ![](httpatomoreillycomsourcenostarchimages783564.png),
    the layout of the board ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then the legal moves for that context. For the initial board position, at
    the beginning of player A’s turn, there is only one possible move: The player
    can move from hexagon 2 to hexagon 3, capturing player B’s die in that spot ![](httpatomoreillycomsourcenostarchimages783560.png).
    After that, the player can pass. Player B now has no move available. Since this
    player’s game tree has no available moves listed ![](httpatomoreillycomsourcenostarchimages783554.png),
    the game has ended, with a win for player A.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Playing Dice of Doom Against Another Human
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve completely captured the universe of Dice of Doom in our comprehensive
    `game-tree` function, it’s simple to create a human versus human version of this
    game. All we need to do is create some functions that travel down the game tree
    as players choose their moves.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The Main Loop
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the function that travels down the game tree, allowing two humans to
    play Dice of Doom:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function, `play-vs-human`, is the main loop of our game. It accepts a tree
    describing the starting position of the board.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: First, it calls a function named `print-info`, which will draw the board on
    the screen, along with other helpful information about the current state of the
    game ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we need to check
    if any follow-up moves exist. These follow-up moves would be listed starting at
    the `caddr` position of the game tree ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: If follow-up moves are available, we call the function `handle-human`, which
    will interact with the current player to help him pick his new move. This `handle-human`
    function will then return the subbranch of the tree that represents the player’s
    choice. We can then recursively pass this subbranch into `play-vs-human` to proceed
    with the game ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If no follow-up moves are available, the game has officially ended. We then
    call the `announce-winner` function, which, appropriately, will announce the winner
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Giving Information About the State of the Game
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the print-info function, which describes the status of the current
    node in the game tree:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function displays two important pieces of information on the REPL. First,
    it shows who the current player is ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it prints out a pretty version of the game board with the `draw-board` function
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Handling Input from Human Players
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next is the function that lets humans choose their next move. It displays a
    very helpful, numbered menu of all currently available moves for the player to
    choose from.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To display the list of available moves, we use a `loop` that traverses all the
    available moves and prints a description about each one ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `loop` is not functional, since it prints stuff on the screen for the player
    to read. We print a counting number in front of each move ![](httpatomoreillycomsourcenostarchimages783560.png)
    using the variable n, which counts from 1 inside our `loop` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Each move has an action value associated with it. If the action is non-nil ![](httpatomoreillycomsourcenostarchimages783554.png),
    then the action is an attack, where the action value describes the source and
    destination hexagons of the attack. We print such attacking action using the `format`
    command ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We use an empty action value to represent the passing move. In that case, we
    just `princ` “end turn” to describe this move ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: After the available moves have been displayed, we use `read` to read in the
    player’s choice. With the `nth` function, we can then select that branch of the
    game tree and return it from our `handle-human` function ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Winner
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The task of announcing the winner can be nicely broken into a *clean/functional*
    and a *dirty/imperative* part.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The clean part concerns the task of calculating the winning player. We want
    to calculate this in a way that can handle more than just two players, since our
    game will allow for more in the future. Also, the function must be cognizant of
    possible ties.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we’ll write a function called `winners` that returns a
    list of one or more players who captured the maximum number of hexagons at the
    end of the game. If there is a tie, it will simply return all the players who
    share first place, in terms of the total count of occupied spaces for all players.
    With this design, the function will work for *any number of players* and will
    elegantly handle ties. This is what the `winners` function looks like:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We calculate the winner for a given ending board position in four steps.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: First, we build up a tally of who occupies each hexagon on the board ![](httpatomoreillycomsourcenostarchimages783564.png).
    With the `across loop` construct, we can traverse the array of the ending board
    directly and collect the occupier of each hexagon.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we need to count the total number of squares each player has captured,
    using this tally. The totals variable will be an alist of player->spaces pairs.
    We build this alist by finding all players who have at least one entry in the
    tally with `remove-duplicates` ![](httpatomoreillycomsourcenostarchimages783560.png).
    We can map across this and then create a count for each occupier ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, we want to find what the maximum number of occupied hexagons for a single
    player is. We do this by stripping the counts from our alist by mapping `cdr`
    across the list ![](httpatomoreillycomsourcenostarchimages783554.png). We then
    apply `max` to this list to find the largest number of occupied spaces for a single
    player.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need create a list of all the “best” players. We do this by stripping
    out all but the best from our totals using the `remove-if` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    We then just pull out the player numbers for the best players by mapping `car`
    across the list of bests ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s write the dirty `announce-winner` function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is rather simple. First, we calculate the winners by calling our
    earlier function ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    check if there is more than one winner ![](httpatomoreillycomsourcenostarchimages783562.png)
    (a tie). For ties, we print a special message ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we just announce a single winner ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Trying Out the Human vs. Human Version of Dice of Doom
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have a completely playable game of dice of doom. Here is an example
    game from start to finish:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an Intelligent Computer Opponent
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed when we were designing the game tree code for Dice of Doom,
    having a separate game tree generator makes it easy to add an AI player to a game
    engine. In fact, we’re now going to add a computer player that can play an absolutely
    perfect game with only 23 additional lines of code!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does an AI player decide to make a move? We’ll use the following strategy:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Look at each available move.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a point rating to the board position resulting from each move.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the move with the maximum point rating.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This sounds like a simple plan, but there is one step in this algorithm that’s
    pretty tricky: calculating the best point rating for a given board position.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: If a move leads immediately to a win, it’s easy to give a point rating to that
    move—any winning move clearly deserves a very high point rating. However, most
    moves in a game cannot lead to an immediate win. In those cases, in order to determine
    if the result of a set of moves deserves a good point rating, we need to figure
    out what the opponent player will do in response.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: But how will we know what the opponent player will decide to do? If we’re not
    careful, we’ll end up in an ugly impasse where we say, “He thinks that I think
    that he thinks that I think . . .” in order to calculate a meaningful point value
    for a given board position. How do we account for the opponent’s behavior without
    giving ourselves a headache?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781316.png.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: The Minimax Algorithm
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that for a two-player board game, a simple method exists to model
    what an opponent will do. We simply accept the truism “What is good for my opponent
    is bad for me.” This means we can use the following approach to model a move for
    the opponent:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Look at each available move.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a point rating to the board position resulting from each move.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the move with the minimum point rating.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This algorithm for estimating what an opponent will do is identical to the one
    used for the primary player, except that in step 3, we pick the move with the
    *minimum* instead of *maximum* rating. The benefit of this approach, called the
    *minimax algorithm*, is that we use the same point ratings when working out the
    opponent’s moves that we use for the primary AI player, but then just tweak the
    third step a little to adjust.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'This is crucial: It turns out that if we can avoid calculating separate ratings
    for ourselves as for our opponent in the game, then searching down the game tree
    for good moves becomes dramatically easier and faster.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic minimax algorithm works only in two-player games. When three or more
    players are involved in a game, we can’t really say that “What is good for my
    opponent is bad for me” is completely true any more. This is because an additional
    truism becomes important: “The enemy of my enemy is my friend.” This means that
    some of my opponents may, at times, act as a friend by making moves that harm
    a common enemy, while not affecting me directly. We’ll discuss this issue more
    in [Chapter 20](ch22.html "Chapter 20. Making Dice of Doom More Fun").'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Turning Minimax into Actual Code
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to put the minimax idea into practice, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: '[PRE32]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `rate-position` function generates a numeric point rating for a given branch
    of the game tree. In order to do this, we first need to figure out if there are
    any moves available from the given position ![](httpatomoreillycomsourcenostarchimages783564.png)
    (that is, the current move is not an ending move in the game).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: If moves are available, we’ll need to look at all the subsequent moves to decide
    how to rate the current position. We accomplish this by calling `get-ratings`
    ![](httpatomoreillycomsourcenostarchimages783554.png), a function that will return
    the point rating of each follow-up move. As per minimax, we will then pick either
    the best (`max`) ![](httpatomoreillycomsourcenostarchimages783562.png) or worst
    (`min`) ![](httpatomoreillycomsourcenostarchimages783560.png) rating of all the
    follow-up moves, depending on whether the move being rated is for the AI player
    or its opponent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, there are no follow-up moves, we’ll need to check who
    the winner is for the current board position ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the player isn’t among the winners of this position, we can give the position
    the minimum rating of `0` ![](httpatomoreillycomsourcenostarchimages783556.png).
    Otherwise, we’ll divide one by the number of winners to determine our rating ![](httpatomoreillycomsourcenostarchimages783544.png).
    By doing this, we also give a meaningful rating for ties. If the player is the
    sole winner, the rating, using this formula, will be the maximum value of `1`.
    For a two-player tie, the rating will be a sensible `0.5`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `get-ratings` function looks like:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: '[PRE33]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function simply maps `rate-position` across each available follow-up move
    for the given branch of the tree.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Game Loop with an AI Player
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we wrote a function called `handle-human` that interacted with a human
    to decide on a move in the game. Here is an analogous function, `handle-computer`,
    that interacts with our AI player to choose a move:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `handle-computer` function is quite straightforward. First, we get the
    ratings of each available move ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we pick the move that is rated the highest ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s create a function that handles the main loop for playing against
    the computer. This one is analogous to our earlier `play-vs-human` function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As with the `play-vs-human` function, `play-vs-computer` first prints out information
    about the current state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
    If no more moves are available, it then calls the `announce-winner` function ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to check who the current player is. By convention, we’ll have
    the human be player A (player 0). If the player number is 0, we call our old `handle-human`
    function to let the human decide on her move ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we treat the player as an AI player and use the `handle-computer` function
    to decide on a move ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: We have now written a fully functional AI engine for Dice of Doom!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Playing Our First Human vs. Computer Game
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is an example game playing against the computer AI. The computer
    plays an optimal game and wins.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Making Dice of Doom Faster
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional programming style can lead to slow code, at least in the hands
    of a novice programmer. We used the functional style to develop the core of Dice
    of Doom. Hence, this first version of our game is excruciatingly inefficient.
    We had to limit our game to a 2-by-2 board to make it playable. But now we can
    increase our board size to 3-by-3, as we optimize our game engine.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase the parameters controlling the board size to make this happen.
    You may not want to play a game at this new size until you’ve implemented all
    the optimizations throughout the rest of this chapter, unless you are an extremely
    patient person and don’t mind having the computer take minutes building the initial
    game tree and deciding on moves.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There, we’ve upgraded the board size to 3 by 3.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter covers some important techniques for optimizing functional
    code. These techniques apply to all programs written in the functional style,
    which includes Dice of Doom. In later chapters, we’ll add other optimizations.
    Eventually, we’ll be able to play against an AI player on much more spacious boards,
    while still having elegant code written in the functional style.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start optimizing Dice of Doom, there is an important Lisp programming
    concept we need to discuss: *closures*. Closures are extra bits of data from the
    outside world that are captured whenever a lambda function is created. To understand
    the hows and whys of capturing variables in a closure, consider the following
    example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we’re creating a new, unnamed function ![](httpatomoreillycomsourcenostarchimages783564.png),
    and then setting `*foo*` equal to this function. Next, we call this function using
    the `funcall` command ![](httpatomoreillycomsourcenostarchimages783562.png). As
    you would expect, the value returned from this function is `5`. All the lambda
    function does is return this number.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider this more interesting example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This version of `foo` is exactly the same as the previous version of `*foo*`,
    except that we first declare a local variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is set to `5`. Then, in the body of the `lambda`, we return `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    So, what do you think will happen if we call this new version of `*foo*`?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is a tough question is that `x` is declared as a “local” variable.
    However, `x` (apparently) no longer exists once we call `*foo*`, since we’re already
    long past the point where we’re evaluating the body of the `let` expression.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out and see what happens:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Holy cow! Somehow the lambda expression we created remembered what `x` was at
    the time it was created. The variable `x`, which we previously thought of as a
    local variable, has somehow managed to live on past the block in which it was
    created!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first covered `let` expressions in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Lisp Program"), you learned that advanced Lispers prefer to call variables
    created with a `let` expression *lexical variables*. Now you can see why: A variable
    created in this way does not need to be local, if it is captured in a closure,
    by using the variable in a lambda expression.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: To understand how closures work, remember that Lisp uses garbage collection.
    In fact, it was the first language to have this feature. Garbage collection means
    that you never have to “free” variables (as you do in C programming). The Lisp
    compiler/interpreter is smart enough to know when variables are no longer in use
    and destroys them automatically.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection will happen at some arbitrary future time after you’ve exited
    a `let` expression. Periodically, Lisp will search its memory for items that are
    no longer referenced anywhere and can therefore be safely destroyed. If Lisp notices
    that a variable defined in a `let` is no longer used by anything, it will destroy
    that variable.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: However, if you create a lambda expression within the `let` expression (as we
    did in the previously), it’s possible for those variables to live on, being referenced
    from within the lambda expression. In that case, the garbage collector will leave
    those variables alone. Basically, you’ve created variables that are permanent—at
    least as long as the lambda expression doesn’t fall out of use and get garbage
    collected.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do a lot of cool things using closures. They’re often used for caching
    small pieces of information between uses of a function. For instance, here a function
    that remembers what line number is currently being printed:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In order to keep track of the line number, we first create a lexical variable
    named `line-number` ![](httpatomoreillycomsourcenostarchimages783564.png). Next,
    we declare our `my-print` function using `defun` ![](httpatomoreillycomsourcenostarchimages783562.png),
    in the body of the `let`. This command will create a lambda function behind the
    scenes, therefore letting us also generate a closure.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of the `my-print` function, we can then print the `line-number`
    ![](httpatomoreillycomsourcenostarchimages783560.png), and even mutate it using
    `incf` ![](httpatomoreillycomsourcenostarchimages783554.png). (`incf` just adds
    one to a variable.) Because the `line-number` variable is captured in the closure,
    it can “live on” between calls to `my-print`, allowing us to count line numbers.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first optimization we’re going to perform is called *memoization*. This
    technique makes use of closures. Memoization works only for functions written
    in the functional style. As you know, the behavior of a function in the functional
    style depends only on the arguments passed into it. Also, the only action of a
    function in the functional style is to calculate a value to return to the caller.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests an obvious optimization: What if we remember the arguments and
    result of each call of this function? Then, if the function ever gets called again
    with the same arguments, we won’t need to recalculate the result. Instead, we
    can simply return the precalculated result.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Several functions in Dice of Doom can benefit from memoization.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the neighbors Function
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the `neighbors` function, which lets us know which hexagons
    on the board can be attacked from a given location:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What `neighbors` is telling us is that if we want to attack other hexagons on
    the board from hexagon 0, we can reach only hexagon 3, 1, or 4 (based on our new
    3-by-3 board size).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, the `neighbors` function needed to do all kinds of ugly
    checking for the edges of the board, since hexagons along the edges are limited
    in the hexagons they can attack. However, since the shape of the board never changes
    mid-game, these numbers never change for a given board position. This makes `neighbors`
    a perfect candidate for memoization! Here is the code that accomplishes this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s dissect this code to make sense of what’s happening. First, we save the
    old version of the `neighbors` function in a local variable named `old-neighbors`
    ![](httpatomoreillycomsourcenostarchimages783564.png). The `symbol-function` command
    simply retrieves the function bound to a symbol. Using `symbol-function` here
    allows us to retain access to the old value of `neighbors`, even if we define
    a new function with the same name, as we’ll do shortly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a local variable `previous` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which will hold all previous arguments and results the function has ever seen.
    This can be represented as a hash table, where the arguments are the hash key
    and the results are the values.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Now we define a new `neighbors` function that will override the old definition
    of `neighbors` ![](httpatomoreillycomsourcenostarchimages783560.png). This new
    definition will add memoization to the old version of the function. Then we look
    up the argument `pos` in the hash table and return it, if available ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we call the old definition of the function (that’s why we needed to
    create the `old-neighbors` lexical variable) and add this new argument/result
    pair to the hash table ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since `setf` returns the value being set, this command will also cause this newly
    calculated result to be returned to the caller of `neighbors`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful not to declare the memoized version of the `neighbors` function more
    than once, without also redeclaring the original version of the function. Otherwise,
    the `neighbors` function will be wrapped in multiple unsightly layers of memoization,
    since there are no checks if the memoization has already been done.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the Game Tree
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest payoff by far for memoization in our program will be in the `game-tree`
    function. This makes sense, if you think about how a board game works. Very often,
    you can get the same board positions in a board game by performing the same moves
    in a slightly different order. In our naive version of the `game-tree` function,
    every different move sequence leads to a completely different branch in the game
    tree that we need to build in a totally repetitive and inefficient way.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'In the memoized version of the `game-tree` code, the function can say to itself,
    “Hey, I’ve seen that board position before!” and can then share branches of the
    game tree. Here is a memoized version of `game-tree` that does this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this memoization is virtually identical to the one we used for
    the `neighbors` function. The only difference is that we’re setting the hash table
    to use `equalp` instead of `eql` (the default) for the test on the key ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: This is because the key (that is, the arguments to `game-tree`) contains the
    game board, in the form of an array. If we change the test function to be `equalp`,
    then Lisp will check every hexagon on the board and make sure it matches before
    using a previous calculation.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the rate-position Function
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another function that will benefit greatly from memoization is the `rate-position`
    function. Here it is, memoized:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to do something a bit special for the memoization on this function to
    work correctly, because of the `tree` argument passed into rate-position. The
    game tree is potentially huge, so we need to make sure we never compare a game
    tree object with `equal` (or a similar comparison function that is slow with large
    lists). Instead, we want to compare it with `eql`. Because of this, we handle
    the memoization of each of the two parameters to `rate-position` (`tree` and `player`)
    separately. We accomplish this by having nested hash tables.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an outer hash table with the default `eql` test ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then, we define a `tab` variable that looks up one of our variables (`player`)
    in the outer hash table ![](httpatomoreillycomsourcenostarchimages783562.png),
    to retrieve an inner hash table. If `tab` is not found in the outer hash table
    ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll create a new, empty
    inner hash table, storing it in the outer hash table with the same key ![](httpatomoreillycomsourcenostarchimages783554.png).
    The rest of the function is similar to our previous examples, except that we’re
    now using our inner hash table, with the `tree` argument as a key ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: This memoization will bring us a step closer to having larger, and more fun,
    boards for Dice of Doom.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You use memoization for optimizing the performance of code written in the functional
    style. However, memoization code is not, in itself, written in the functional
    style. It cannot be, since it requires you to maintain and update a table of previous
    calls to the target function.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Tail Call Optimization
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next technique we’re going to use to optimize our functional program is
    called *tail call optimization*. To understand this concept, let’s study a simple
    function that calculates the length of a list:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `my-length` function should be pretty easy for you to understand at this
    point. First, it checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783564.png).
    If not, it recursively calls itself against the tail of the list and adds one
    to the total, using the `1+` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the list is empty, the function just returns `0` ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that this function is actually quite inefficient. We can easily
    see this by trying to use it against a really big list:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Calling this function in CLISP actually causes the program to crash! (Other
    Common Lisp compilers/interpreters may do better, depending on whether the compiler
    writers use any special tricks to anticipate this common pitfall in Lisp code.)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: This happens because of the `1+` function. It tells Lisp, “*First*, figure out
    the length of the shorter list, *then* call `1+` on the result.”
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that each time we call `my-length` recursively, Lisp must remember
    that we need to add one to the result later on, once the length of the tail of
    the list has been figured out. Since the list is 100,000 items long, it must remember
    this 99,999 times before it can perform a single addition! The CLISP interpreter
    places a reminder for all of these additions on the program stack, which eventually
    overflows, crashing the program.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we avoid this problem? We do it by rewriting our `my-length` function
    like so:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we define a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png)
    that will act as our list-eater. This function takes an extra parameter, often
    called an `accumulator`, here shortened to `acc` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `acc` argument keeps a running count of how many items in the list we have
    previously encountered. When we initially call the function `f`, we set `acc`
    to `0` ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: By making this accumulator available, it means that when `f` calls itself recursively
    ![](httpatomoreillycomsourcenostarchimages783560.png), it now longer needs to
    add one to the result. Instead, it just adds one to the accumulator. Once we reach
    the end of the list (`lst` is `nil` ![](httpatomoreillycomsourcenostarchimages783562.png)),
    then `acc` will equal the total number of items in the list, so we can just return
    it ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: What is important here is that *the very last thing* the function `f` does,
    in the case where more items are on the list, is call itself recursively ![](httpatomoreillycomsourcenostarchimages783560.png).
    (The additional line in the `if` statement ![](httpatomoreillycomsourcenostarchimages783554.png)
    doesn’t count, since that part won’t be called if the expression evaluates to
    true.) When a function in Lisp calls itself (or another function) as its very
    last action, we call this action a *tail call*. A smart Lisp compiler, when seeing
    a tail call, can then say to itself, “Hey, since I don’t need to do anything more
    after calling `f` again, I can just go straight to `f`, without needing to put
    the current program context on the stack.”
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: This is actually similar to performing a `GOTO` in BASIC or a `longjmp` in C++.
    In all of these cases, we just “forget” where we came from, which is very fast
    and doesn’t thrash the stack. However, in the case of a tail call in Lisp, it
    is also perfectly safe. Anyone who has used `GOTO` or `longjmp` knows they’re
    anything but safe!
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two different definitions for `lst` that exist in the
    preceding example code. One is an argument to the `my-length` function, and the
    other is an argument to the function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The values of these two lst arguments will deviate as the program runs and `f`
    is called recursively. However, within the function `f`, the version in its own
    argument list will take precedence. This process of hiding one variable with another
    through precedence is called *variable shadowing*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I used variable shadowing in the `my-length` function so it would be impossible
    for me to accidentally use the “wrong list” when writing the code inside of function
    `f`. Other programmers dislike this technique, since having similarly named variables
    with different values can lead to confusion. You’ll need to decide which of these
    arguments is most convincing to you and whether you’ll use variable shadowing
    in your own code.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Support for Tail Calls in Common Lisp
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, you can’t be 100 percent sure in Common Lisp that a compiler/interpreter
    will perform tail call optimizations. It is not required by the ANSI Common Lisp
    standard. (The situation is actually different in the Scheme dialect, since Scheme
    has a strict requirement for tail call optimization.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: However, most Common Lisp compilers support this feature, although CLISP requires
    some extra cajoling to make tail call optimization work for some functions, including
    our example function. The reason for this is that tail calls can actually lead
    to performance problems themselves, in some esoteric cases. Also, when we debug
    a program, it’s nice to be able to look at the full call stack; tail call optimizations
    will prevent this, since, by their nature, they will minimize the information
    available on the stack.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the extra step we need to take to get CLISP to tail call optimize the
    `my-length` function:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Calling this function will tell CLISP to run the `my-length` function through
    its full compiler, which includes a tail code optimization step. Now we can run
    `my-length` against our jumbo-sized list!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tail Call Optimization in Dice of Doom
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One function in our game that could definitely benefit from tail call optimization
    is the `add-new-dice` function. Here’s the fully optimized version:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As before, we’re performing the list-eating in a function called `f` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which also has an accumulator. However, this time the `acc` variable will contain
    a *list* of newly updated hexagons with extra dice. We can now call `f` in tail
    call positions in two places ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png),
    where we `cons` new hexagons to the `acc` variable.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve processed the whole list of hexagons on the board, we can just return
    `acc`. However, since we’ve consed stuff to `acc` as we went along the list, `acc`
    will actually be reversed. Therefore, we need to perform an extra call to `reverse`
    at the very end ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored some basic techniques for optimizing computer programs
    written in the functional style.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: A Sample Game on the 3-by-3 Board
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s enjoy the fruits of our labor. The following is a full game against
    the AI player on a 3-by-3 board. As you can see, on an evenly matched starting
    board, the computer is now practically unbeatable.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What You've Learned
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we used our knowledge of functional programming to develop
    a board game with AI. Along the way you learned the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming techniques allow you to write a game program with a “rule
    engine” that is separate from the rest of the code. You accomplish this by using
    *function pipelining* and building a *game tree* that is independently traversed
    by other parts of your game code as the game progresses.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create an AI player for a two-player game using the *minimax algorithm*.
    This algorithm is based on the truism “What is good for my enemy is bad for me.”
    It allows you to efficiently rate positions in a two-player board game.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical variables (which we’ve been calling *local* variables) can live on past
    the form in which they were created if they are referenced by a lambda expression.
    Capturing variables in this way is called *creating a closure*.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs can be optimized using *memoization*, which requires you
    to cache previous results calculated by a function.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also improve functional programs by using *tail call optimizations*,
    which allow you to make sure the call stack isn’t abused. You do this by controlling
    which function appears in the tail call (final) position of your list-eater functions.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 16. The Magic of Lisp Macros
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Macro programming* allows you to mess around inside your Lisp compiler/interpreter
    to turn Lisp into your own custom programming language. When faced with a difficult
    programming challenge, many experienced Lispers will first ask themselves, “What
    programming language could I use to make this problem easy to solve?” Then they’ll
    use macros to convert Lisp into *that* language!'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'No other programming language possesses such a simple and comprehensive macro
    system. One can even argue that it would be impossible to add this feature to
    other programming languages, for a simple reason: The Lisp languages are the only
    ones in which computer code and program data are made out of the same “stuff.”
    As discussed many times in this book, the fundamental structures for storing data
    in Lisp are symbols, numbers, and lists, which are made of cons cells. Similarly,
    the code of a Lisp program is made out of these same basic building blocks. As
    you’ll see in this chapter, this symmetry between code and data in Lisp is the
    magic that makes the Lisp macro system possible.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781590.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have heard that other programming languages, such as C++, also have
    a feature called macros. For instance, in the C++ language, you would create these
    using the #define directive. However, these are not the same thing! Lisp macros
    work in an entirely different and far more sophisticated way.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Lisp Macro
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when you’re writing a computer program, you get a feeling of *déjà
    vu*. I’m sure you know this feeling. You’re typing away at your computer, and
    you suddenly realize, “Hey, this is the third time this week I’ve written this
    same fragment of code!”
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for example, that your program needs a special `add` function:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function adds together two numbers and prints out the sum on the REPL
    as a side effect. You might find this function useful in a program during debugging:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This `add` function seems straightforward, but its code has an annoyance: Why
    do you need so many parentheses to declare your variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png)?
    The `let` command requires so many parentheses that when you need only a single
    variable, the code ends up looking especially ludicrous.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses required by `let` are an example of the kind of *visual noise*
    a programmer must deal with almost every day. However, you can’t just write a
    regular function to hide those parentheses, because the `let` command can do things
    a regular Lisp function can’t support. The `let` command is a *special form*.
    It’s a core part of the language and has special powers beyond those of a standard
    Lisp function.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros let us get rid of the superfluous parentheses. Let’s create a new macro
    named `let1`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, the definition of a macro looks similar to the definition of
    a function. However, instead of using `defun`, we use `defmacro` to define it.
    Like a function, it has a name (in this case, `let1`) and arguments passed to
    it ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve defined the macro `let1`, it can be used just like `let`, except
    that it works with fewer parentheses:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Macro Expansion
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a macro definition looks very similar to a function definition, a macro
    is actually very different from a function. To understand why, imagine your Lisp
    is actually a cute little blob, merrily running your Lisp programs.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782790.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
- en: This blob understands only standard Lisp code. If it were to see our `let1`
    command, it would have no idea what to do.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782218.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: Now imagine that we have a magic wand that transforms the appearance of our
    code *just before* Lisp gets a peek at it. In our example, it will transform `let1`
    into a regular `let`, so Lisp will stay happy.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781008.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: This magic wand is called *macro expansion*. This is a special transformation
    that your code is put through before the core of the Lisp interpreter/compiler
    gets to see it. The job of the macro expander is to find any macros in your code
    (such as our let1 macro) and to convert them into regular Lisp code.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: This means a macro is run at *a different time* than a function is run. A regular
    Lisp function runs when you execute a program that contains the function. This
    is called *runtime*. A macro, on the other hand, runs before the program does,
    when the program is read and compiled by your Lisp environment. This is called
    *macro expansion time*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the basic thinking behind Lisp macros, let’s take a
    closer look at how `let1` was defined.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: How Macros Are Transformed
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define a new macro with the `defmacro` command, we’re basically teaching
    the Lisp macro expansion system a new transformation that it can use to translate
    code before running a program. The macro receives raw source code in its arguments,
    in the form of Lisp expressions. Its job is to help the macro expander transform
    this raw code into standard Lisp code that keeps the Lisp blob happy.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how our `let1` macro gets transformed. Here is
    its definition once again:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first line of this `defmacro` call ![](httpatomoreillycomsourcenostarchimages783564.png)
    tells the macro expander, “Hey, if you see a form in code that begins with let1,
    here’s what you need to do to transform it into standard Lisp.” A macro defined
    with `defmacro` may also have arguments passed into it, which will contain the
    raw source code found inside the macro when the macro is used. The `let1` macro
    has three such arguments passed into it: `var`, `val`, and `body` ![](httpatomoreillycomsourcenostarchimages783564.png).
    So what do these three arguments represent?'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779867.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, when we use `let1`, we’ll end up having three different expressions
    inside it, which are the arguments to the `let1` macro:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '**`var`**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the name of the variable we’re defining. This name will
    be available within our macro using the argument named `var`. In this example,
    it will equal the symbol `foo`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '**`val`**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The second expression holds the code that determines the value of the variable.
    In our macro, this is the second argument, `val`. It will equal the list `(+ 2
    3)`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '**`body`**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The third expression inside a `let1` call is the body code, which makes use
    of the new variable that’s created (in this case, `foo`). It will be available
    in the macro through the argument named `body`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Since the `let` command is allowed to have multiple statements in its body,
    we will want to mirror this behavior in the `let1` macro. This is why, in the
    `defmacro` command defining let1, the final `body` argument has the special keyword
    `&body` in front of it. This tells the macro expander “Give me all remaining expressions
    in the macro in a list.” Because of this, the body argument in our `let1` example
    is actually `((* foo foo))`—a nested list. In this example, we put only a single
    statement inside `let1`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen what the values to the arguments of our `let1` macro are,
    let’s see how the macro uses this information to transform the `let1` into a standard
    `let` that the Lisp compiler can understand. The easiest way to transform source
    code in Lisp is to use backquote syntax. (If you don’t remember how to use backquotes,
    please see [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works") in [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works").) With backquotes, we can build the code for a proper `let` command using
    code passed to `let1`. Here’s our `let1` macro again for reference:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the `let1` macro returns a backquoted list starting with the
    symbol `let` ![](httpatomoreillycomsourcenostarchimages783564.png), followed by
    the variable name and value, placed in a proper nested list, which Lisp’s `let`
    command requires. The commas cause the actual variable name and value to be plopped
    in at these locations. Finally, we place the `body` code from the `let1` in the
    analogous place in the `let` command ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'The `body` argument is inserted into the transformed code using the splicing
    comma `(,@)`. To understand why the `body` needs to be handled in this special
    way, consider the following use of our `let1` macro:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this case, we’ve put more than one thing inside the body of our `let`. Remember
    that the `let` command includes an implicit `progn` command, and it can have multiple
    Lisp instructions inside. Our new `let`1 macro allows for this as well by placing
    the special `&body` marker in front of the `body` argument, causing all remaining
    syntax expressions to be passed into `let1` as a list. So, in the preceding example,
    the `body` argument contains the code `((princ "Lisp is awesome!") (* foo foo))`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Using the Simple Macro
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve written our `let1` macro, let’s rewrite our custom `add` function
    in a cleaner way:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Isn’t this much easier on the eyes?
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `macroexpand` command to see code generated by a macro. Simply
    pass the macro’s code to `macroexpand`, like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can now see the raw code generated by `let1` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `T` at the end ![](httpatomoreillycomsourcenostarchimages783562.png) just
    means `macroexpand` was handed a valid macro that it was able to expand.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: As your macros become more complex, you’ll find that `macroexpand` is a valuable
    tool in testing and debugging their structure.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: More Complex Macros
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose you need a custom `my-length` command. This is a classic list-eating
    function that will count the length of a list. We’ll write it in the proper “tail
    call optimized” style (discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming")), where the recursive function call
    is in the tail position. Here’s the code:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see, this function has tons of repetitive stuff, once again giving
    us that dreaded feeling of *déjà vu*. There are two repetitive patterns in this
    function:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: As in other list-eater functions, we have the annoying check to see if the list
    is empty ![](httpatomoreillycomsourcenostarchimages783562.png) and the associated
    use of `cdr` ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did all this verbose work to create a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s write some macros that make this function (and other functions with the
    same repetition) more pithy.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: A Macro for Splitting Lists
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s create a `split` macro. It will let us write cleaner list-eater
    functions, such as our `my-length` function.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'List-eaters always check if the list is empty. If it isn’t, they take apart
    the list using `car` and/or `cdr`, and then perform operations on the head and/or
    tail of the list. The `split` macro does this for us. Here’s what it looks like
    when we use the finished `split` macro:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first argument of the `split` macro is a list you want to split into a head
    and a tail ![](httpatomoreillycomsourcenostarchimages783564.png). If this is possible,
    the next expression in the `split` macro will be called ![](httpatomoreillycomsourcenostarchimages783562.png).
    As a bonus, our `split` macro automatically creates two variables for us, named
    `head` and `tail`. This way, we don’t always need to call `car` and `cdr` inside
    list-eating functions. If the list is empty ![](httpatomoreillycomsourcenostarchimages783560.png),
    we call the expression at the end ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code for the `split` macro. Note that this initial version
    of the macro contains some bugs we’ll discuss shortly:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our `split` macro requires three (and only three) expressions as arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    This means when we use this macro, we’ll always need exactly three items.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The code that needs to be generated by `split` is pretty straightforward. First,
    we have an `if` that checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is, we break apart the list and stick it into our two local variables, `head`
    ![](httpatomoreillycomsourcenostarchimages783560.png) and `tail` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Then we put in the code that handles the “yes, we can split the list” case ![](httpatomoreillycomsourcenostarchimages783510.png).
    If we can’t split the list, we call the no case ![](httpatomoreillycomsourcenostarchimages783544.png).
    Note that in the no case, we don’t have access to the `head/tail` variables, since
    they aren’t created if the list can’t be split.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new `split` macro, we can clean up our `my-length` macro a bit:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice how we now make use of the `tail` variable created by `split`, simplifying
    our code ![](httpatomoreillycomsourcenostarchimages783564.png). Macros that automatically
    generate variables like this are called *anaphoric macros*.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not yet finished with our `split` macro. Although it basically
    works, it contains some subtle bugs that we need to address.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Repeated Execution in Macros
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common bug that can happen in a macro is incorrect repeated execution of
    code. In fact, our current version of the `split` macro contains this flaw. Here
    is an example that clearly shows the problem:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this use of `split`, the statement “Lisp rocks!” was printed three times,
    even though it appears only once in the original code. How is this possible?
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the arguments passed into a macro consist of raw source code.
    This means the `val` argument passed into `split` contains the raw code of the
    `progn` statement ![](httpatomoreillycomsourcenostarchimages783564.png), including
    the raw code for the `princ` statement within it. Since we reference `val` three
    times inside the `split` macro, it causes the `princ` statement to be executed
    three times.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by running this example through `macroexpand`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the `princ` statement appears three times ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    This causes unexpected behavior and is inefficient, since we’re repeatedly running
    the same code unnecessarily.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'If you give this problem some thought, the solution isn’t too hard to figure
    out. We simply need to create a local variable inside the `split` macro, like
    this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that we made use of `let1` in this new version of `split`. As this shows,
    it is perfectly okay to use macros inside *other* macros.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we rerun our previous example, we can see that `split` behaves correctly,
    `princ`ing the statement only once:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Unfortunately, this new version of the `split` macro introduces *yet another*
    bug. Let’s tackle this new bug next.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Variable Capture
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the bug in our newest version of `split`, try running the following:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Can you tell what happened? We just created a variable `x` inside the new version
    of our `split` macro! Here’s what the call to `split` looks like if we `macroexpand`
    it:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how the expanded version of `split` contains a definition of `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    This blocks the competing definition in our troublesome example ![](httpatomoreillycomsourcenostarchimages783564.png).
    In this scenario, the `split` macro accidentally *captured* the variable `x` and
    overwrote it in an unexpected way. How can we avoid this problem?
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple solution would be to not create a variable `x` in the macro, but
    to instead use a variable with some insane long name like `xqweopfjsadlkjgh`.
    Then we could feel pretty confident the variable used inside the macro will never
    clash with a variable inside the code that uses it. If fact, there is a Common
    Lisp function called `gensym` whose job it is to generate crazy variable names
    exactly for this purpose:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `gensym` function will create a unique variable name for you that is guaranteed
    never to clash with any other variable name in your code. You may notice that
    it also has a special prefix (`#`:) that differentiates it from other names. Common
    Lisp handles these `gensym-based` names as a special case and will stop you from
    using the name of a `gensym` variable directly.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s use the `gensym` function inside our `split` macro to protect the
    macro from causing variable capture:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the first line of our revised macro, we define a variable `g` that contains
    the `gensym` name ![](httpatomoreillycomsourcenostarchimages783564.png). It’s
    very important to notice that there is *not* a backquote at the front of this
    line. This means that this line of code is run at *macro expand time*, not *runtime*,
    and it is perfectly fine to define the variable `g` at this point. The `let1`
    on the next line, however, has a backquote in front of it ![](httpatomoreillycomsourcenostarchimages783562.png).
    This line will be run at runtime, so we don’t want to use a hardcoded variable
    in this spot. In this new version, we instead use the unique `gensym` name stored
    in `g`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Now every time the `split` macro is used, a unique name is generated to hold
    the internal value. We can test this by running some examples through `macroexpand`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Notice how a differently named local variable was created in both instances
    ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png).
    This guarantees that the variable name will not only be unique within your code,
    but will also be unique if the `split` macro is ever used multiple times in a
    nested fashion. We have now created a fully debugged version of our `split` macro.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Just because it is now bug-free does not mean that it is free of variable capture.
    Note that the macro still defines the variables `head` and `tail`. If you used
    this function in other code in which head or tail had an alternate meaning, your
    code would fail! However, in the case of `head` and `tail`, the capture is on
    purpose. In this situation, the variable capture is a *feature*, not a bug—it
    is an anaphoric macro. As we’ve discussed, this means that it makes named variables
    or functions available that we can use in the body of the macro.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: A Recursion Macro
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take another look at our improved `my-length` macro:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As we discussed, there is an additional repetitive pattern in this code: The
    creation of a local function `f`. Let’s write another macro that gets rid of this
    additional visual noise: `recurse`. Here’s an example of the `recurse` macro in
    use:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The first parameter into the `recurse` macro is a list of variables and their
    starting values ![](httpatomoreillycomsourcenostarchimages783564.png). In this
    case, we’re declaring only one variable (`n`) and setting its starting value to
    9\. The rest of the lines in the macro make up the body of the recursive function.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the body is start a fresh line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we check if `n` has reached zero yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it has, we print “lift-off!” ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we print the current number ![](httpatomoreillycomsourcenostarchimages783510.png)
    and call the function again, recursively. Like our `split` macro, the `recurse`
    macro is anaphoric. In the case of `recurse`, it makes a function named `self`
    available, which we call when we’re ready to perform a recursion ![](httpatomoreillycomsourcenostarchimages783544.png).
    We also subtract one from `n` at this point to lower the countdown number.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how `recurse` should work, let’s write this `recurse` macro.
    In order to process the list of arguments and starting values, it’s useful for
    us to have a function that can group items into a list of pairs. Here is a function,
    `pairs`, that accomplishes this:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `pairs` function is a tail-call-optimized list-eater, which, ironically,
    has its own local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Shortly, we won’t need to declare such a function anymore.) It uses `split` to
    break an item off the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    However, since it needs to process two items (a pair) from the list at once, we
    need to run an additional check to see if the tail is empty ![](httpatomoreillycomsourcenostarchimages783560.png).
    If there are no items in the list ![](httpatomoreillycomsourcenostarchimages783544.png)
    (or only one item left ![](httpatomoreillycomsourcenostarchimages783510.png)),
    we return our accumulated values. Otherwise, we recursively process the rest of
    the list, with a new pair of items placed into the accumulator ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re finally ready to write the `recurse` macro:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, it simply transforms the recursion into a traditional local
    function. First, it uses our new `pairs` function to take apart the variable names
    and starting values, and puts the result into `p` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it defines a local function simply named `self`. The variable names for `self`
    are the odd-numbered items from `p` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we want `self` to be accessible, anaphorically, from inside the macro, we
    use a plain name instead of a `gensym` name for this function. At the bottom of
    the macro, we then simply call `self`, passing in all the starting values ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created the `recurse` macro, let’s once again clean up our `my-length`
    function using this new language construct:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, there is very little repetition or visual noise in this version
    of our `my-length` function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Now you can appreciate how helpful macros can be when trying to write clean,
    succinct code. However, a liberal use of macros will also require you to bear
    some costs that you need to be aware of. We’ll look at the potential downsides
    to macros next.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros: Dangers and Alternatives'
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Macros allow us to write code that generates other code, making the Lisp languages
    a wonderful tool for metaprogramming and prototyping new language ideas. But,
    at some level, macros are just a sleight of hand: They let you trick the Lisp
    compiler/interpreter into accepting your own customized language constructs and
    treating them like standard Lisp. They are indeed a powerful tool in a programmer’s
    tool chest, but they are not as elegant as some of the other programming tools
    you’ve encountered in this book.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of macros is that they can make it hard for other programmers
    to understand your code. After all, if you’re creating your own language dialect,
    other programmers won’t be familiar with it. Even your future self—say, in a year
    or two—may have a hard time understanding the structure of your code if you’ve
    made heavy use of macros. Because of this, experienced Lispers will do their best
    to use alternate techniques to macro programming whenever possible. Often, a beginning
    Lisper will write a macro in situations that could be addressed in other, cleaner
    ways.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, it’s fun to see how we were able to clean up our `my-length`
    function by adding a couple of macros named `split` and `recurse`. However, in
    the previous two chapters, you learned about another tool, functional programming,
    which can also be used to clean up list-eater functions. One powerful function
    often used by functional programmers is `reduce`. It is a higher-order function
    that accepts a function and a list, and will call the function once for every
    value in the list. Here is the `my-length` function rewritten to use the powerful
    `reduce` function, rather than macros:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see, this new version of `my-length` easily blows away our previous
    version. It is shorter, and it doesn’t rely on any of the nonstandard macros that
    we created.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `reduce` holds our *reduction function* ![](httpatomoreillycomsourcenostarchimages783564.png).
    Its job is to keep track of, and update, an accumulated value, here named `x`.
    This variable `x` will hold the current accumulated value, which in this case
    will be the length of the list so far. This means we can simply add one to `x`
    to update it to its new value ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since the reduction function will be called once for every item in the list, it
    will, in the end, generate the length of the list. (The reduction function also
    receives, as an argument, the current item in the list, here given as the variable
    `i`. However, we do not need it for calculating the list’s length.) The next item
    passed to `reduce` is the list we want to reduce ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, since the accumulated length we’re calculating should have an initial
    value of zero, we indicate this by setting the `:initial-value` keyword argument
    to zero ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there are other scenarios where the list-eater macros we’ve created
    in this chapter are still useful. There are many cases where the `reduce` function
    could not be so easily used. So in the end, there are still many situations where
    creating your own Lisp dialect is exactly the right solution to a problem, as
    you’ll see in the next chapter.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered macro programming. You’ve learned the following:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Macros let you write code that writes code. With macros, you can create your
    own programming language and convert it to standard Lisp just before the compiler
    can get a peek at it.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏让你可以编写编写代码的代码。有了宏，你可以在编译器能够查看它之前，创建自己的编程语言并将其转换为标准 Lisp。
- en: Macros allow you to get rid of that feeling of *déjà vu* when writing your code,
    in situations when nothing else can do so.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏可以让你在编写代码时摆脱那种*似曾相识*的感觉，在没有任何其他方法可以做到的情况下。
- en: You must be careful when writing macros so that they don’t lead to unintentional,
    repeated execution of code.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写宏时，你必须小心，以免导致代码意外地重复执行。
- en: You need to be careful to avoid unintended *variable capture* in macros. You
    can avoid this by using `gensym` names.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要小心避免在宏中发生意外的*变量捕获*。你可以通过使用 `gensym` 命名来避免这种情况。
- en: If variables created by a macro are exposed on purpose, as a feature of the
    macro, the macro is called an *anaphoric macro*.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宏创建的变量有意暴露，作为宏的一个特性，那么这个宏被称为*反身宏*。
- en: Macro programming is a very powerful technique. However, try to use functional
    programming instead to solve a problem whenever possible. Macros should always
    be a last resort.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏编程是一个非常强大的技术。然而，尽可能尝试使用函数式编程来解决问题。宏应该始终是最后的手段。
- en: Chapter 17. Domain-Specific Languages
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章。领域特定语言
- en: One of the best reasons for using macros is to perform *domain-specific language*
    (*DSL*) programming. DSL programming is an advanced macro programming technique
    that allows us to solve difficult programming problems by drastically changing
    the structure and appearance of Lisp code to optimize it for a specialized purpose.
    Although macros are not strictly necessary for doing DSL programming, by writing
    a set of macros, you can easily create a DSL in Lisp.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏的最好理由之一是进行*领域特定语言（DSL）*编程。DSL 编程是一种高级宏编程技术，它允许我们通过大幅改变 Lisp 代码的结构和外观来优化它以适应特定目的，从而解决困难的编程问题。尽管宏对于进行
    DSL 编程不是严格必要的，但通过编写一组宏，你可以在 Lisp 中轻松创建一个 DSL。
- en: What Is a Domain?
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是领域？
- en: According to the 2000 US Census, the average family in the United States had
    1.86 children. Since no individual family has exactly 1.86 children, it is obvious
    that no particular family is truly perfectly average. In the same way, there is
    no such thing as an average computer program. Every program is designed to solve
    a specific problem, and every area of human inquiry, or *domain*, has its own
    idiosyncratic requirements that influence programs that solve problems in the
    given area. With DSLs, we enhance the core of our programming language to take
    these domain-specific requirements into account, potentially making our resulting
    code easier to write and understand.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 2000 年的美国人口普查，美国平均家庭有 1.86 个孩子。由于没有哪个家庭的孩子数量正好是 1.86 个，因此很明显，没有哪个家庭真正完美地平均。同样，也没有所谓的平均计算机程序。每个程序都是为了解决特定的问题而设计的，每个人类探究领域，或*领域*，都有其独特的需求，这些需求会影响解决该领域问题的程序。通过
    DSL，我们增强了编程语言的核心，以考虑这些特定领域的需求，从而可能使我们的代码更容易编写和理解。
- en: 'Let’s take a look at some specific domains and create some DSLs that let us
    easily work within these domains using Lisp. In this chapter, we’ll create two
    different DSLs. First, we’ll create a DSL for writing *scalable vector graphics
    (SVG)* files. Then we’ll write a DSL for creating commands in a text adventure—we’re
    finally going to upgrade our Wizard’s Adventure Game from [Chapter 5](ch05.html
    "Chapter 5. Building a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting
    with the World: Reading and Printing in Lisp") to make it fully playable!'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些特定的领域，并创建一些领域特定语言（DSL），这样我们就可以使用 Lisp 在这些领域内轻松工作。在本章中，我们将创建两个不同的 DSL。首先，我们将创建一个用于编写*可伸缩矢量图形（SVG）*文件的
    DSL。然后我们将编写一个用于创建文本冒险游戏命令的 DSL——我们最终将把我们的巫师冒险游戏从[第 5 章](ch05.html "第 5 章。构建文本游戏引擎")和[第
    6 章](ch06.html "第 6 章。与世界交互：在 Lisp 中读取和打印")升级到完全可玩的状态！
- en: Writing SVG Files
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 SVG 文件
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780406.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780406.png)'
- en: The SVG format is a file format for drawing graphics. In this format, you specify
    objects like circles and polygons, and then pass them to a compatible computer
    program to view. Because the SVG format specifies a drawing using pure math functions
    instead of raw pixels, it is easy for a program to render an SVG image at any
    size, making images in this format easily scalable.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: The SVG format is currently receiving a lot of attention from web developers.
    All modern browsers (excluding Microsoft Internet Explorer) support SVG natively.
    Recently, Google released a set of libraries called SVG Web that adds decent support
    for SVG, even in Internet Explorer. This allows SVG to work in more than 90 percent
    of current web browsers. Finally, SVG has become a practical and efficient option
    for drawing graphics on websites.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'The SVG format is built on top of the XML format. Here is an example of what
    a complete SVG file looks like:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Simply copy this text and place it in a file named *example.svg* (or download
    this file from [http://landoflisp.com/](http://landoflisp.com/)). Then you can
    open the file from the Firefox web browser (the Safari, Chrome, and Opera web
    browsers should also work).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you should see, with a red and blue circle:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782270.png.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
- en: Now, let’s write some macros and functions to let us create a picture like this
    directly in Common Lisp!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Creating XML and HTML with the tag Macro
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XML data format (just like the HTML data format) consists primarily of
    nested tags:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Every tag ![](httpatomoreillycomsourcenostarchimages783564.png) also has a
    matching closing tag ![](httpatomoreillycomsourcenostarchimages783562.png). The
    closing tag has the same name, but with a slash preceding it. Additionally, tags
    may contain attributes:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this example, we create a tag named `mytag` that has the attribute of being
    blue and has a height of 9.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Macro Helper Function
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, when writing a macro to perform a task, you’ll find a lot of what your
    macro needs to do can be handled by a function instead. Because of this, it is
    often prudent to first write a helper function that does most of what the macro
    needs to do. Then you write the macro, keeping it as simple as possible by leveraging
    the helper function. This is what we’re going to do as we write a macro to create
    XML-style tags in Lisp.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our helper function, called `print-tag`, which prints a single opening
    (or closing) tag:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'First, the `print-tag` function prints an opening angle bracket ![](httpatomoreillycomsourcenostarchimages783564.png).
    Since this is only a character, we use the literal character syntax by prefixing
    the bracket with #\. Then we check the predicate `closingp` ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is true, the tag needs to have a slash in front of it to make it a closing
    tag. Then we print the name of the tag, converted to lowercase with the `string-downcase`
    function ![](httpatomoreillycomsourcenostarchimages783560.png). Next, we iterate
    through all the attributes in the `alst` of attributes ![](httpatomoreillycomsourcenostarchimages783554.png)
    and print out each attribute/value pair ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, we end by putting in a closing angle bracket ![](httpatomoreillycomsourcenostarchimages783544.png).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example use of the `print-tag` function. Since it is a plain
    function and not a macro, it’s easy to debug in the REPL. This is another reason
    why helper functions are a good idea when creating macros.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can see, this function does a fine job of printing an XML tag. However,
    it would be a real chore if all tags had to be created in this way. That’s why
    we’re going to write the `tag` macro next.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tag Macro
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tag` macro we’ll create has been adopted from the macro of the same name
    in Paul Graham’s Arc Lisp dialect. It improves on the `print-tag` function in
    several crucial ways, all of which could not be remedied without having a macro:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Tags always come in pairs. However, if we want to nest tags, a function would
    not be able to print tags that surround the tags printed inside it. This is because
    it requires us to execute code before and after nested tags are evaluated. This
    is possible in a macro, but not a function.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag names and attribute names usually do not need to change in a dynamic way.
    Because of this, it’s redundant to need to prefix tag names with a single quote.
    In other words, tag names should by default be treated as if they were in data
    mode.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike tag names, it’s very desirable for the values of attributes to be dynamically
    generated. Our macro will have a syntax that places the attribute values into
    code mode so we can execute Lisp code to populate these values.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, this is how we would like the tag macro to work, when we use it in
    the REPL:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Notice that the tag name and attribute list no longer need quotes in front of
    them. Additionally, it is now easy to calculate an attribute dynamically with
    Lisp code. In this case, we’re calculating that the height is 4 plus 5.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the macro that accomplishes this task:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you would expect, the macro first calls `print-tag` to generate the opening
    tag ![](httpatomoreillycomsourcenostarchimages783564.png). This is a bit tricky
    when we generate the alist of attributes for `print-tag`, since we want the values
    for the attributes to be in code mode. We accomplish this by wrapping the attributes
    using `list` ![](httpatomoreillycomsourcenostarchimages783562.png). Then we `mapcar`
    through the attributes, which we’ve paired with the `pairs` function ![](httpatomoreillycomsourcenostarchimages783554.png).
    (Remember that we created the `pairs` function toward the end of the previous
    chapter.) For each attribute pair, we generate a code fragment in the list that
    consists of cons, without a quotation mark in front of the value of the attribute,
    so that we can dynamically calculate it ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put all the code nested inside our `tag` macro, so that it is called
    after the opening tag ![](httpatomoreillycomsourcenostarchimages783510.png). Finally
    we create a closing tag ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'To make more sense of how this macro handles the attribute list, let’s pass
    the output from our example to `macroexpand`:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Looking at the macro expansion, it should be clear how the `tag` macro builds
    the attribute list to pass to `print-tag` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and how it allows us to dynamically generate attribute values, such as the height
    attribute ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of this macro in use, now with two inner tags:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice how it correctly surrounds the inner, nested tags with proper XML opening
    and closing tags. Note also that I have added line breaks and indentation to the
    output ![](httpatomoreillycomsourcenostarchimages783564.png) for clarity. The
    actual output of the `tag` function always prints on a single line, without line
    breaks or indentation.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Using the tag Macro to Generate HTML
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tag` macro can be used for generating XML *or* HTML. For instance, we
    could do the following to generate a “Hello World” HTML document:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Since HTML uses predefined tags (unlike XML, where the tags can have any name),
    we could write simple macros for specific HTML tags that make them even easier
    to write HTML in Lisp. For instance, here are some simple `html` and `body` macros:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we could write our “Hello World” HTML example even more elegantly:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: However, we want to use the `tag` macro to create SVG drawings instead. So let’s
    expand our DSL for the SVG domain.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Creating SVG-Specific Macros and Functions
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s write the `svg` macro, which embodies an entire SVG image. Here
    it is:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `svg` macro is built on top of the `tag` macro. SVG images, for our purposes,
    require two special attributes to be created:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The `xmlns` attribute tells the SVG viewer (in our case, the Firefox web browser)
    where it can find the proper documentation for the SVG format ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second attribute enables hyperlinks inside the picture ![](httpatomoreillycomsourcenostarchimages783562.png).
    We’ll be using this hyperlinking feature in more advanced examples, starting in
    the next chapter.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To draw pictures, we’ll need to manipulate colors. To keep things simple, we’re
    just going to represent colors as RGB triples stored in a list. For instance,
    the color `(255 0 0)` is bright red.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, it is useful to generate lighter or darker variants of a particular
    color. The following `brightness` function does this for us:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If you pass bright red into this function and set the brightness to negative
    100, you can see that it will generate a darker red:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, let’s create a function that sets the style of an SVG picture element:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `svg-style` function accepts a color, and then sets the fill and stroke
    (outline) of a picture element ![](httpatomoreillycomsourcenostarchimages783564.png).
    By using our brightness function, we can make the outline a darker variant of
    the fill ![](httpatomoreillycomsourcenostarchimages783562.png). This way, we need
    to specify only a single color for every element in our pictures, while maintaining
    a pleasing appearance.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a function to draw a circle. Since we won’t need to nest other
    SVG tags inside a circle, there is no need to write a macro for drawing circles—a
    function suffices.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We’ll want to set the center, radius, and color of each circle. The center needs
    to be assigned to the `cx` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and `cy` ![](httpatomoreillycomsourcenostarchimages783562.png) SVG attributes
    of the circle. The radius is put in the `r` attribute ![](httpatomoreillycomsourcenostarchimages783560.png).
    We set the style of our circle with our `svg-style` function ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to draw the simple SVG picture of two circles shown earlier,
    using our new DSL! Here’s how we do it:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We now have a functional SVG DSL. Let’s add some more functionality to our DSL
    so we can appreciate the power a DSL can give to our programs.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Building a More Complicated SVG Example
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a new function to our SVG DSL that makes it easy to draw an arbitrary
    polygon:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: An SVG polygon stores all the points of the polygon in the `points` attribute
    ![](httpatomoreillycomsourcenostarchimages783564.png). We construct the list of
    points by using a `format` statement, which contains the `˜{ ˜}` control strings
    ![](httpatomoreillycomsourcenostarchimages783562.png). Remember from [Chapter 11](ch12.html
    "Chapter 11. Printing Text with the format Function") that these control strings
    let us iterate through a list inside the `format` function. In this case, we’re
    iterating through the list of points. We then flatten the list of point pairs
    using `mapcan` ![](httpatomoreillycomsourcenostarchimages783560.png), which you
    may remember is the same as using a `mapcar` followed by an `append`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re going to draw some random walks. A *random walk* is
    a graph of what you would get if you decide, at each moment in time, to flip a
    coin and then move either up or down a step. Random walks are very similar in
    behavior to stocks in the stock market. They are often used as a starting point
    for financial modeling. Here is a function that generates a random walk:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function builds a list of numbers, starting with the `value` parameter.
    Then it increases or decreases this value randomly. We choose which direction
    to move using the `random` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Note that, in order to keep it simple, this function isn’t tail call optimized,
    since the `cons` happens after the recursive call.)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how we can use the `random-walk` function:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now let’s use our SVG DSL to draw a slew of random walks in a picture:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Since the amount of data created in this example is quite huge, we’re dumping
    the data straight to a file (named *random_walk.svg*), instead of printing it
    to the REPL. We do this by redirecting the `*standard-output*` dynamic variable
    ![](httpatomoreillycomsourcenostarchimages783564.png), a technique introduced
    in [Chapter 12](ch13.html "Chapter 12. Working with Streams"). Notice how we can
    mix Lisp code freely with our DSL commands. For instance, we can loop right inside
    the SVG macro to generate 10 polygons at once ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the graph pretty, we’re going to fill in the area under each graph
    line with a color. To do this, we’ll represent each line using a polygon, with
    the base line along the bottom of the graph (with a y-coordinate of 200) included
    as points to close the shape:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781225.png)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
- en: This is why we add points for the bottom-left ![](httpatomoreillycomsourcenostarchimages783560.png)
    and bottom-right ![](httpatomoreillycomsourcenostarchimages783554.png) corner
    as we create each polygon. For even more fun, we also randomize the color of each
    graph line ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some random graphs generated by this very simple DSL
    code:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779828.png.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
- en: 'Now that you’ve seen how easily you can write XML, HTML, and SVG DSLs in Lisp,
    let’s create an entirely different kind of DSL—one that will let us build custom
    game commands for our Wizard’s Adventure Game from [Chapter 5](ch05.html "Chapter 5. Building
    a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the
    World: Reading and Printing in Lisp")!'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Game Commands for Wizard's Adventure Game
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783098.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
- en: 'If you remember, when we last encountered the game starring our wizard and
    apprentice in [Chapter 5](ch05.html "Chapter 5. Building a Text Game Engine")
    and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and
    Printing in Lisp"), we could walk around the world and pick up objects. However,
    we couldn’t really perform any other interesting or fun actions. To make a game
    fun, it should include special actions that can be performed with certain objects
    and/or at certain locations in the game. We need frogs that can be kissed, dragons
    that can be fought, and perhaps even maidens that can be rescued!'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Creating these kinds of interesting activities in the game poses a unique challenge.
    On the one hand, there are clearly many similarities between such different game
    actions. For instance, most of them will require us to have an object in our possession.
    On the other hand, they all need to have *unique and idiosyncratic properties*
    (enabled through command-specific Lisp code) or the game becomes boring. As you’ll
    see, a DSL can help you add many such unique commands to your game.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code from here until the end of this chapter, we’re going to use
    all the game code from [Chapter 5](ch05.html "Chapter 5. Building a Text Game
    Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading
    and Printing in Lisp"). Just put the code from those chapters into a file named
    *wizards_game.lisp* (or download *wizards_game.lisp* from [http://landoflisp.com/](http://landoflisp.com/)).
    As soon as the game is loaded, you can type game commands like look directly in
    the CLISP REPL. Alternatively, you can use the `game-repl` command we created
    in [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and Printing
    in Lisp") to get a more polished game experience. Remember that the `quit` command
    will take you out of the game REPL.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you do to load the game code from the REPL and start running game
    commands:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Creating New Game Commands by Hand
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what should our game DSL look like? The only way to really know is to first
    create some commands by hand. Then we can see if there are any common patterns
    between different commands that we can use as the basis of our DSL.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: A Command for Welding
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781998.png.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
- en: 'In the attic of the wizard’s house is a welding machine. Let’s allow the players
    to weld the chain to the bucket if they bring those items to that location. Here’s
    the code to make this happen:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: First, we need an easy way of checking whether the player is currently carrying
    an object, using the `have` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    Remember that we created a command for checking what the player is carrying, named
    `inventory`. If an object is a member of the inventory, it means the player must
    “have” that object.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Next, our program needs some way of keeping track of whether or not the chain
    and bucket are welded together, since there will be actions later in the game
    that are possible only once this welding has happened. For this purpose, we create
    a global, dynamic variable named `*chain-welded*` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to create the welding command itself ![](httpatomoreillycomsourcenostarchimages783560.png).
    Welding is possible only if a slew of conditions are met ![](httpatomoreillycomsourcenostarchimages783554.png):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: You must be in the attic.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have `chain` and `bucket` as the subject and object of the welding
    command.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be carrying the chain and bucket with you.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain and bucket can’t already be welded together.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these conditions are met, we set our `*chain-welded*` variable to `true`
    ![](httpatomoreillycomsourcenostarchimages783510.png) and print a message indicating
    this success. If any of the conditions fail, we indicate that the welding was
    unsuccessful ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the command in the CLISP REPL:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Well, that’s exactly the right response. After all, we’re not in the attic,
    and we aren’t carrying the right objects. So far, so good.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try our new command in our fancy `game-repl`:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'What? Why doesn’t it “know” that command? The answer is simple: Our `game-re`pl
    has some basic protections against running unauthorized commands. To remedy this,
    we need to add `weld` to our list of permitted commands:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: By using the `pushnew` command, the `weld` function is added only to the allowed
    commands if it wasn’t already present in that list. Problem solved!
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: A Command for Dunking
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780712.png.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
- en: 'In the wizard’s garden, there is a well. Let’s create a command that lets the
    player dunk the bucket in the well to fill it with water:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As with our `weld` command, we first need a variable to keep track of whether
    the bucket has been filled yet ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we need a `dunk` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Notice how, with dunking, we once again have a long list of conditions that need
    to be met before we can successfully complete the action ![](httpatomoreillycomsourcenostarchimages783560.png).
    Some of these are similar to those we needed for our welding command. For instance,
    dunking also requires the player to be in a specific location with the correct
    object. Other conditions are dunking-specific, such as the fact that the player
    needs to have a welded chain before being able to dunk. Finally, we need to push
    the `dunk` function onto our list of allowed actions ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780228.png)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
- en: The game-action Macro
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve created two custom game actions for our game, it’s obvious that
    the `weld` and `dunk` commands are very similar in some ways. However, as in our
    SVG library, each game command needs to contain a certain amount of dynamic logic
    in it, to customize the behavior of the command. Let’s write a `game-action` macro
    that addresses these issues. It will make it much easier to create new game commands.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This `game-action` macro embodies the common pattern between our `dunk` and
    `weld` commands. The parameters to `game-action` are the name of the command,
    the two objects involved in the action, the place it needs to occur, and some
    arbitrary additional code in the `body` parameter that lets us add custom logic
    to the command ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: The main job of the `game-action` macro is to define a new function for a command
    ![](httpatomoreillycomsourcenostarchimages783562.png). It may be surprising to
    you that a macro can do something as powerful as define a new function on its
    own, but there is nothing to stop it from doing this. I hope this example shows
    you just how flexible and mind-bending the Common Lisp macro system can be.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Since all game actions for this game require the location, subject, and object,
    we can take care of some of the conditions directly within this macro ![](httpatomoreillycomsourcenostarchimages783560.png).
    However, we’re going to leave other conditions open for each specific command.
    Notice, for example, that the subject of the game sentence needs to be owned by
    the player ![](httpatomoreillycomsourcenostarchimages783554.png), but the object
    does not. This makes sense, since there are many actions that can be performed,
    such as “throw rock dragon,” where the object of the sentence (dragon) does *not*
    need to be in the player’s inventory.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Once the basic macro-level conditions have been met, we will defer the rest
    of the logic to the level of the individual command ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the conditions were *not* met, we print an error message, customized with the
    name of the current command ![](httpatomoreillycomsourcenostarchimages783544.png).
    Finally, we `pushnew` the command into the list of allowed commands for our fancy
    `game-repl` ![](httpatomoreillycomsourcenostarchimages783566.png).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: One thing we do *not* do in this macro is define or set any global variables.
    If a game command needs to define a `*chain-welded*` or `*bucket-filled*` global
    variable, it must do this itself. This makes sense, since there is clearly no
    guarantee that there will be a one-to-one relationship between state variables
    for our game and particular commands. For instance, some commands may be permitted
    multiple times, making the state unnecessary. Or an action may depend on multiple
    state variables. Having this kind of variation in the commands is what makes them
    unique and fun.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'With this macro, we now have a simple DSL for creating new game actions! Essentially,
    this command gives us our own programming language, specialized for the domain
    of creating game commands. Let’s rewrite our previous `weld` and `dunk` commands
    using our new game command programming language:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see, these commands have become much easier on the eyes. Notice how
    `weld` checks for ownership of the bucket, whereas `dunk` does not need to check
    for ownership of the well.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate the value of using macros to implement our game command
    DSL, let’s implement a more complicated game command, `splash`:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'For this command, there are three distinct scenarios that might happen:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: The bucket is empty.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your bucket is full, but you stole the frog. In that case, you lose.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your bucket is full and you didn’t steal the frog. You win!
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our `game-action` macro, we can support many action commands, each with
    special idiosyncratic behavior. Still, we are able to avoid unnecessary repetition.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `game-action` command exposes the `subject` and `object` variables within
    the body of the macro. This allows game commands to access this information, but
    it might also cause a name collision if the code that creates the `game-action`
    commands also has variables named `subject` and `object`. As an exercise, try
    modifying the `game-action` macro so that the `subject` and `object` variables
    are replaced by `gensym` names, as discussed in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Let's Try the Completed Wizard's Adventure Game!
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a sample run through of the Wizard’s Adventure Game that shows off some
    of the rich functionality we’ve put into this game. Play the game yourself and
    see if you can win the magic donut!
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780868.png.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
- en: '[PRE112]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: What You've Learned
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter demonstrated how to create DSLs in Lisp. You learned the following:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: When you need to do some weird programming for a very specific domain, Macros
    are a great solution. With them, you can create your own DSL.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, it makes sense to first write a helper function for a macro (like `print-tag`),
    and then write a macro (like `tag`) to add improvements that only a macro can
    provide. These improvements usually involve being able to access the code with
    a clearer, and often safer, syntax.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix DSLs with regular Lisp code, which gives you a lot of power.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSLs are useful when you need to write very specific code—whether it’s code
    for a web page, code that draws a picture, or code that builds special game commands.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 18. Lazy Programming
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional
    Programming"), you learned that your programs can be simpler and cleaner when
    built with clean, math-like functions. These functions always return the same
    result, which depends solely on the arguments passed into them. When you rely
    only on these types of functions, you are using the *functional programming style*.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we used the functional programming style to create the Dice of
    Doom game in [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written
    in the Functional Style"), a problem became evident: If your functions rely entirely
    on the arguments passed into them, the stuff that you need to pass into them often
    becomes *huge*.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: In the Dice of Doom game, we pass around the `game-tree` variable, which holds
    all the possible future states of the game board. This is a truly massive structure,
    even on a measly 3-by-3 board! So while the game’s current design makes our code
    very simple and elegant, it doesn’t appear to scale well to larger game boards,
    which would have exponentially larger game trees. The only way we could conceivably
    maintain our elegant code while allowing more complex games on larger boards is
    to make our program smart enough not to look at every conceivable move right from
    the start of the game. Is this possible? Yes, it is possible, using a feature
    called *lazy evaluation*. In this chapter, we’ll employ lazy evaluation to create
    an improved version of Dice of Doom.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: Adding Lazy Evaluation to Lisp
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With lazy evaluation, we can still create our entire game tree in a single
    place in our code—at the beginning of our game. However, we use some clever tricks
    so that some branches of our game tree are hidden in clouds:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782958.png.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
- en: The branches of the game tree are still declared right from the start. However,
    we don’t bother doing all the actual calculations for the branches in clouds,
    as we would do when we create a “real” branch. This is the *lazy* part of lazy
    evaluation.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we wait to see if anyone “looks” at a cloudy branch. The moment this
    happens, POOF!, we create a real branch of our game tree at that spot:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781540.png)'
  id: totrans-747
  prefs: []
  type: TYPE_IMG
- en: This means that these branches in the game tree are created only if some part
    of the code happens to look at them. If the player never chooses a particular
    move in the game, and the AI never decides to contemplate it, our program will
    lazily avoid the calculations needed to figure out what the given branch actually
    looks like.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as Haskell and Clojure Lisp, contain support for lazy evaluation
    as part of the core of the language. In fact, Clojure encourages its use and clearly
    demonstrates how useful it is for functional programming. However, the ANSI Common
    Lisp standard does not contain any similar feature for such lazy evaluation. Fortunately,
    with Common Lisp’s powerful macro system, we can easily add this feature to the
    language ourselves!
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Creating the lazy and force Commands
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic commands for lazy evaluation we’re going to create are `lazy`
    and `force`. The `lazy` command will be a wrapper you can put around a piece of
    code, telling Lisp that you would like the code to be evaluated in a lazy way,
    like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'As you can see, the computer *does not* try to calculate the value of 1 plus
    2\. Instead, it simply returns a function. To get the actual result of the calculation,
    we must call our other basic lazy evaluation command on a lazy value:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The important thing is that the calculation was performed, but not when the
    lazy value was created—only when it was forced. To see that this is the case,
    let’s look at a more complex example:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here, we’ve created our own `add` function, which, as a side effect, prints
    a message to the console showing when the addition is happening ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we lazily add two numbers with our function and store the result in the
    variable `*foo*` ![](httpatomoreillycomsourcenostarchimages783562.png). So far,
    we know the addition hasn’t actually happened, since the message “I am adding
    now” has not yet appeared.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: Then we `force` our variable ![](httpatomoreillycomsourcenostarchimages783560.png).
    By forcing the value, the calculation is actually performed, and the result of
    `3` is returned. You can see that the addition took place when we forced the lazy
    value, since our message was also printed in the console ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for a simple implementation of `lazy`:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We implement `lazy` by declaring a macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    This macro will require two variables in the code it generates. We need to declare
    these as `gensym` names ![](httpatomoreillycomsourcenostarchimages783562.png),
    as discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros").
    Next, we begin generating the code that the macro will output ![](httpatomoreillycomsourcenostarchimages783560.png)
    (note the backquote at the beginning of this line).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the code generated by the macro is a declaration for two local
    variables, using the `gensym` names we created ![](httpatomoreillycomsourcenostarchimages783560.png).
    The first variable tells us whether this lazy value has been forced yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it is `nil`, the value can hide in a cloud. If the variable is true, the value
    is no longer hidden in a cloud, because it has been forced.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Once the value has been calculated through a call to `force`, we store the resulting
    value in another variable, though initially this value isn’t used and is set to
    `nil` ![](httpatomoreillycomsourcenostarchimages783554.png). When our `lazy` macro
    is called, we want it to return a function, which can be called at a later time
    to force our lazy value to return a result. Therefore, we declare a lambda function
    next ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Remember that any local variables declared outside this lambda function will
    be captured by the function as a closure. This means that the local variables
    above ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png)
    will persist between subsequent calls of the lambda function. Why does this matter?
    Well, once the cloud goes POOF!, we have completed all the work to calculate a
    value, and we don’t want to do it again when the lazy value is forced and checked
    again multiple times in the future. We can avoid this by remembering the value
    after the first `force` here ![](httpatomoreillycomsourcenostarchimages783554.png)
    between calls.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: When our lazy value is forced (by calling the lambda function we created), the
    first question we must ask ourselves is whether it has been forced already or
    is still hidden behind the cloud ![](httpatomoreillycomsourcenostarchimages783544.png).
    For a value that has not yet been forced, we go POOF! and perform the lazy calculation
    ![](httpatomoreillycomsourcenostarchimages783556.png), and save it as our `value`.
    We also mark it as having been `forced` ![](httpatomoreillycomsourcenostarchimages783566.png).
    Now the cloud has been destroyed.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: Once the cloud is gone, we can simply return our calculated value ![](httpatomoreillycomsourcenostarchimages783498.png).
    This may have been just calculated, or it may already exist from a previous call
    to `force`.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the (admittedly mind-bending) code for the `lazy` macro, the `force`
    function is super-simple. All it does is call the lambda function created by `lazy`:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We now have a fully functional set of primitive lazy evaluation commands. Many
    different types of sophisticated tools could be built on top of these simple `lazy`
    and `force` commands.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lazy Lists Library
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now employ our new commands to build a library for *lazy lists*, based
    loosely on their implementation in Clojure. (In Clojure, lazy lists are referred
    to as *lazy sequences*.)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the fundamental command for working with Lisp lists is the `cons` command,
    you shouldn’t be surprised that the first command we create for working with lazy
    lists is the `lazy-cons` command:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This macro emulates the behavior of `cons`, except that the result is wrapped
    in the `lazy` macro. To accompany `lazy-cons`, we’ll also create `lazy-car` and
    `lazy-cdr` commands:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'All these functions do is force the lazy value and then call `car` and `cdr`,
    respectively. Let’s try using these new commands:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As you can see, we can use `lazy-cons` exactly as we would use `cons` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we can take apart a lazy cons in the same way we would take apart a cons
    ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it looks like our lazy list functions aren’t any different from the
    standard `cons`, `car`, and `cdr` functions. However, we can actually use them
    to perform some pretty amazing feats. Consider, for instance, the following definition:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here, we’ve used the `lazy-cons` command to declare something impossible: a
    variable that holds a list of all positive integers! We do this by creating a
    local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png), which
    we then call recursively to build an infinite chain of `lazy-cons`es, using an
    ever-increasing number `n` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Once we’ve declared this seemingly impossible `*integers*` variable, we can use
    it just as you might expect:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As long as we stick to using only our `lazy-` commands, we can pull whatever
    we want out of our infinite list of integers, forcing more and more numbers from
    `*integers*` on an as-needed basis.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: Since not all lists are infinite (as is the list of positive integers), we’ll
    also need to have a concept of a `lazy-nil` to terminate a list. Similarly, we
    need a `lazy-null` function that we can use to check if we’ve reached the end
    of a list, just as the `null` function can be used to check for the end of a regular
    list.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Now that we have all the basic building blocks for working with lazy lists,
    let’s create some useful functions for our library.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Regular Lists and Lazy Lists
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One obvious thing we would want to be able to do is convert a regular list
    into a lazy list. The `make-lazy` function allows us to do this:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As the `make-lazy` function clearly shows, writing lazy list library functions
    is sort of like writing zen koans. The only way to understand them is to stare
    at them for a long time. The English language doesn’t have appropriate words for
    clearly explaining functions like `make-lazy`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: In broad terms, `make-lazy` uses recursion to travel across the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then wraps each cons in a call to the `lazy` macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    However, to get the full meaning of this function (and the other remaining functions
    in our lazy library), you’ll just have to try to think carefully about what `lazy`
    and `force` really mean, and meditate a bit over each function. Luckily, once
    our little lazy list library is complete, it will hide most of the strangeness
    of lazy evaluation.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: Just as we wrote the `make-lazy` function to convert regular lists to lazy lists,
    we can create some functions to do the reverse—convert lazy lists into regular
    ones. The `take` and `take-all` functions allow us to do this.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The reason we want two different commands for going from lazy to regular lists
    is that, unlike regular lists, lazy lists can be infinite. Therefore, it is useful
    to have an additional command that lets us take just a specified number of items
    from the list. The `take` function accepts an extra argument `n` that indicates
    just how many values we want to take ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we just want all values, we can call the `take-all` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Of course, this function cannot be used on infinite lists—taking all items from
    an infinite list would lead to an infinite loop.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our new lazy list conversion functions:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: As you would expect, if we take the first 10 integers off the list of all positive
    integers, we just get the numbers 1 through 10 as a result ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `take` function can also be used on a finite list we’ve created by calling
    `make-lazy` ![](httpatomoreillycomsourcenostarchimages783562.png). However, if
    a list is finite, we can use the simpler `take-all` function and just get a regular
    list of all items in the lazy list ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and Searching Across Lazy Lists
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also want to be able to map and search across lazy lists. Here are some
    functions to allow that:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: These functions are analogous to the functions `mapcar`, `mapcan`, `find-if`,
    and `nth`. The only difference is that they accept and return lazy lists. This
    means that instead of using `null`, `car`, and `cdr`, they use the lazy versions
    of these functions (`lazy-null`, `lazy-car`, and `lazy-cdr`) that we just created.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these functions is pretty straightforward:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Calling `lazy-mapcar` to map the square root function across the positive integers
    gives us a lazy list of the square roots of the positive integers. The first 10
    are shown ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we call
    `lazy-mapcan` ![](httpatomoreillycomsourcenostarchimages783562.png) and check
    if each positive integer is even. If it is, we return a lazy list of the numbers
    ![](httpatomoreillycomsourcenostarchimages783560.png). If it isn’t, we return
    the lazy empty list ![](httpatomoreillycomsourcenostarchimages783554.png). The
    result is that we’ve filtered out all the even numbers from our lazy list of integers.
    We can use `lazy-find-if` to find the first odd number in a lazy list ![](httpatomoreillycomsourcenostarchimages783510.png).
    In this case, the number was 7\. Finally, we can use `lazy-nth` to pick a number
    out of a specific location in a lazy list ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: We have now written an entire, if rather simple, lazy list library. Place all
    the functions we’ve written so far in this chapter in a file named *lazy.lisp*
    (or simply download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: Now, you’re going to see that lazy lists allow us to greatly boost the power
    of our Dice of Doom game engine!
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Dice of Doom, Version 2
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written in the Functional
    Style"), we created the first version of our Dice of Doom game. We are now going
    to modify some of the functions from that version. To proceed, place the code
    from that chapter into a file named *dice_of_doom_v1.lisp* so that we can reference
    it in this new version (or just download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our previous Dice of Doom and our new lazy list library, run the following
    in the REPL:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Next, we’re going to increase the size of our board to a more roomy 4-by-4:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: To allow the game to run at a reasonable speed at this larger size, we’ll make
    the list of moves at each branch of our game tree a lazy list, instead of just
    a regular list. By simply converting this one structure in our game from a regular
    list to a lazy list, the entire game tree will become lazy as a result. To accomplish
    this, we now need to redefine some of the functions from the first version of
    our game to use our new lazy list functions.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make some small modifications to the functions that calculate
    the attacking and passing moves possible from a given board position:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, the `add-passing-move` function needs only one small change.
    Since the list of moves is now a lazy list, we use `lazy-cons` to add a passing
    move to the top of the list of possible moves ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: The `attacking-moves` function requires a few more changes. First, since it
    now needs to return a lazy list, we use `lazy-mapcan` in lieu of `mapcan` in two
    places as the moves are calculated ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    The `lazy-mapcan` function also requires the lists created inside it to be lazy,
    which we accomplish with the `make-lazy` function ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783544.png).
    Also, any place we returned `nil` we now instead return a `lazy-nil` ![](httpatomoreillycomsourcenostarchimages783510.png)![](httpatomoreillycomsourcenostarchimages783556.png).
    Finally, we also make the list of calculated board positions lazy ![](httpatomoreillycomsourcenostarchimages783566.png),
    since it is fed into the outer `lazy-mapcan`.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s make similar changes to two of the functions that deal with human
    players:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the `handle-human` function, we have a local function `print-moves`, which
    is a list-eater function across the list of moves. We modify it to use our lazy
    commands when checking for the end of the list ![](httpatomoreillycomsourcenostarchimages783564.png),
    taking a move off the front of the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and recursing across the tail of the list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, we modify `handle-human` to use `lazy-nth` to pick a move after the human
    chooses it from the list of options ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: In the `play-vs-human` function, we make just a single pinpoint change. In order
    to determine whether we’ve reached the end of a game, we need to check whether
    the list of subsequent possible moves is empty, and then announce the winner.
    We simply use `lazy-null` to check if the lazy list of moves is empty ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'With these simple changes in place, you can play Dice of Doom against another
    human on much larger board sizes, since no move in the tree is realized unless
    one of the players decides to make it. On our larger, 4-by-4 board, enter the
    following to start a game (just as for version 1 of our game):'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Version 1 would screech to a halt the moment this command was executed. This
    is because it would need to generate the entirety of the game tree, *for every
    possible move of the whole game*, before the game would even start playing.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: With our lazy version of Dice of Doom, the game starts instantly!
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Making Our AI Work on Larger Game Boards
  id: totrans-826
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we’re going to adjust our game AI functions to use the new lazy list library
    when processing moves. Along the way, we will make some additional improvements
    to the AI code.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: Trimming the Game Tree
  id: totrans-828
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779954.png.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
- en: In version 1 of Dice of Doom, our AI code was, in certain ways, extremely powerful.
    This is because, at every decision point, the AI player would look at *every possible
    future board position* to choose the absolute best next move. In this way, it
    could play a perfect game of Dice of Doom, winning every game that was winnable.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: However, such a design does not scale to larger boards. This is because it becomes
    impossible to contemplate every single possible future move once there are too
    many. In fact, the whole point of our new lazy game tree is to avoid contemplating
    every possible move. Therefore, we need a way to tell the computer, “Consider
    only this many moves, and no more.” In other words, we want to be able tell it
    to look only two, three, or four moves ahead, and then stop looking any further.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: The functional programming style of Dice of Doom allows us to do this in a very
    elegant but nonobvious way.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: The *obvious* solution to the problem would be to modify the `get-ratings` and
    `rate-position` from version 1 to have a new argument called `search-depth`. Then
    we could ask ourselves at every call of those functions, “Have we reached the
    maximum search depth we want?”
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it gunks up those functions with extra,
    confusing code. In fact, the way we evaluate board positions is theoretically
    a separate issue from how deep we wish to search. As programmers like to say,
    these issues are *orthogonal*, and it would be best if we could write separate
    functions to deal with each of these issues independently.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with our new lazy game tree, it is possible to write a separate function
    that is solely responsible for “trimming” the search tree and is completely independent
    from the main AI code that contemplates and rates possible moves.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function that trims our tree:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This is a pretty simple function that takes just two arguments: a lazy tree
    and the depth to which we wish to trim it ![](httpatomoreillycomsourcenostarchimages783564.png).
    As a result, it just outputs a new game tree, calling itself recursively, decrementing
    the depth for each level it travels into the tree ![](httpatomoreillycomsourcenostarchimages783554.png).
    Once this depth reaches zero ![](httpatomoreillycomsourcenostarchimages783562.png),
    we know we’re at the level that we want to trim, and we set the lazy list of moves
    to the empty list ![](httpatomoreillycomsourcenostarchimages783560.png).'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is call our new `limit-tree-depth` function before doing
    our AI rating calculations. We do this by tweaking our `handle-computer` function
    a bit:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Before calling `get-ratings` to get a rating for every next available move,
    we transform our game tree into our trimmed game tree ![](httpatomoreillycomsourcenostarchimages783564.png).
    All of our AI code can now run on the trimmed tree, completely oblivious to the
    fact that a larger game tree exists or that there are deeper moves it isn’t including
    in its calculations. With this technique, we have managed to decouple the code
    that limits the AI search depth from the algorithm that actually evaluates board
    positions. One other small modification is to use `lazy-nth` when picking a move
    out of the lazy list of moves ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `limit-tree-depth` function uses a pretty crude method for trimming our
    tree: It simply trims all tree branches beyond a certain depth. For most board
    games, doing this is an optimal way of trimming the game tree. However, Dice of
    Doom has the uncommon property that multiple moves in a row are allowed for each
    player. It would probably be more optimal if `limit-tree-depth` took into account
    how many times we’ve switched players as a criterion for trimming a branch. But
    our simpler version works well enough.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should also make a pinpoint change to `play-vs-computer`:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here, we just added a `lazy-null` to check for the end of the lazy list of moves
    in a single spot ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at another trick that will improve the power of our AI code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: Applying Heuristics
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By trimming our game tree, we’ve fundamentally changed our AI player. Without
    trimming, the AI player was able to play a perfect game at all times. By trimming
    the tree, however, it is possible for the AI to “miss something,” since it is
    no longer contemplating every possible future move. In version 2 of Dice of Doom,
    the computer player will no longer be able to play a perfect game—just a “pretty
    good” game is possible.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we’ve exchanged the AI’s ability to play a perfect game for much
    better performance. In the process, we’ve turned the AI code from something precise
    that can be analyzed by mathematics into something that is “squishier” and far
    less precise. As computer scientists would say, we have now entered into the realm
    of *heuristics*.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, heuristics are programming techniques that are imperfect,
    but allow us to get good results very quickly. Broadly speaking, any technique
    that is fast but not guaranteed to work 100 percent of the time is a heuristic.
    When we write code that uses heuristics (as our Dice of Doom AI engine now does),
    it is often worthwhile to use some creative thinking and to “play around” with
    the code in different ways.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: Basically, since we’re already given up on our goal of a perfect solution and
    are now using imprecise techniques, it’s possible that tweaking the knobs on the
    heuristic code in different ways could dramatically improve our results. And indeed,
    it turns out that there is a simple change we can make to our Dice of Doom AI
    heuristics that will significantly improve the AI player’s game.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Winning by a Lot vs. Winning by a Little
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In version 1 of our Dice of Doom code, the AI player had no reason to ever worry
    about its margin of victory. All it cared about was that when the game ended,
    it had ownership of at least one more territory of the board than its opponent,
    which meant it had won.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: However, now that we’re using imprecise heuristics in our AI code, it matters
    *a lot* how large the lead is at any point in the game. A heuristic rule for this
    situation is “If I am totally whomping my opponent in the game, it is pretty unlikely
    he/she will be able to recover, even if I look only a few moves ahead.”
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a minimax algorithm (as we’re using in our AI) assigns a point
    score to every final leaf branch in the tree. In version 1 of our game, this score
    was either 0 or 1, or sometimes 1/2 when the game ended in a tie. In version 2,
    these are not truly “final leaves” in the tree, but simply leaves in our much
    smaller trimmed tree. In this situation, it would be much better if our leaf point
    scores had a larger range of values, so that we can tell which moves lead to a
    game we’re winning by “a lot” and which moves lead to a game we’re winning by
    only “a little.”
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a `score-board` function that uses some more complex heuristics
    to score the board position at a leaf:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The `score-board` function loops ![](httpatomoreillycomsourcenostarchimages783564.png)
    across all of the hexes of the board and builds a running total of points for
    each hex using the `sum` directive of the loop macro. If the player we’re scoring
    owns the current hex ![](httpatomoreillycomsourcenostarchimages783562.png), we
    want to add positive points to the total ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide exactly how many points to add to the total for an occupied hex,
    we make another heuristic observation: Hexes that neighbor a stronger opponent
    aren’t quite as valuable as hexes without strong neighbors. We’ll call a hex that
    neighbors an enemy hex that has more dice on it a *threatened hex*. For hexes
    that are threatened ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll
    add only 1 point to the point total ![](httpatomoreillycomsourcenostarchimages783554.png).
    For hexes that are unthreatened, we’ll add 2 points ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, for each hex owned by an opposing player, we’ll subtract 1 point from
    the total ![](httpatomoreillycomsourcenostarchimages783544.png).'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Again, the important thing to realize is that `score-board` is a heuristic function,
    and there is no truly right or wrong way to generate such a score. Instead of
    adding 2 points for unthreatened hexes, we could just as easily have added 1.5
    points. In developing this example, I ran some simulations playing various opponents
    using different versions of the `score-board` function, and this version ended
    up working reasonably well. Developing heuristics is not an exact science.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function that determines whether a given hex is threatened:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: First, we get the hex in question and figure out who the occupying player is,
    and how many dice that player has ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we loop through all the neighboring squares for the current position ![](httpatomoreillycomsourcenostarchimages783562.png).
    After that, we find out the player and dice count for each of the neighbors ![](httpatomoreillycomsourcenostarchimages783560.png).
    As soon as we find a neighboring hex owned by an opponent with a larger dice count
    (a threatening neighbor) ![](httpatomoreillycomsourcenostarchimages783554.png),
    we can return true ![](httpatomoreillycomsourcenostarchimages783510.png). Calling
    `return` in this way causes the loop to stop early with true as a result.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed our `score-board` and `threatened` functions, we’re
    ready to write our improved `get-ratings` and `rate-position` functions:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: As you can see, we’ve updated a couple lines of code ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)
    to be compatible with our new lazy game tree. Notice that any game positions that
    lack follow-up moves (that is, leaves) now cause our new score-board function
    to be called ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fully working heuristic AI player that can play on larger
    game boards, let’s try it out. As usual, all moves for player B in the following
    example are being automatically calculated by the AI algorithm:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: With these changes in place, the AI player will win around 65 to 70 percent
    of all games (depending on the board size and AI level) when pitted against a
    player that chooses only random moves. This is actually a very good result. Our
    simple `gen-board` function often creates very lopsided starting positions, so
    many of the remaining 30 percent of the games are simply unwinnable for the computer.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Beta Pruning
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add one final improvement to version 2 of our Dice of Doom AI.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '*Alpha-beta pruning* is a well-known optimization of the minimax algorithm
    that improves performance by skipping over some branches (*pruning* those branches)
    if it is certain that they will not impact the final minimax evaluation.'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780064.png.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
- en: 'When would a branch in the game tree be unable to impact the final result?
    In order to understand how alpha-beta pruning works, look at the following picture,
    showing the game tree for a simple 2-by-2 board:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783278.png.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
- en: At the top of this picture is the starting position of the game. The arrows
    point to possible moves. Above each board it states which player (A or B) currently
    is making a move.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: The picture also shows the results of a minimax analysis of the game tree. On
    the bottom right of each board, you can see a number showing how our latest `get-ratings`
    function (with the new `score-board` logic) would rate that position. For leaf
    nodes (the boards along the very bottom), this number is calculated through `score-board`.
    For branch nodes, the number is calculated based on the minimax algorithm.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: Every position in the game tree that allows a choice of moves is marked either
    as a MAX node or MIN node. Since the analysis in the picture is based on finding
    the best move for player A, all places allowing choices for player A are marked
    as MAX. All positions allowing choices for player B are marked as MIN. As you
    can see from the picture, this game is pretty unexciting, and there is only one
    position where player B actually has a choice of moves. In other words, only one
    MIN node exists in the game tree.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: Working left to right, the minimax algorithm travels, depth first, exploring
    all the way down to the leaves. This is called a *depth-first search*. (We’re
    assuming no trimming is occurring, with `*ai-level*` set very high.) Then it chooses
    either the maximum or minimum scores for any nodes that have more than one branch.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: When it does this, the first (left) branch of the MIN node in the picture ends
    up with a score of 8\. If the AI engine now dips into the right branch, it really
    only cares what it finds there as long as the score remains below 8\. After all,
    the minimum of 8 and any larger number larger than 8 will still be 8, making such
    large numbers irrelevant to the eventual outcome of the calculation.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the AI finds a node in the right branch that has a score of 8 (marked
    with a star in the picture), it knows the rest of the right branch is irrelevant
    and can be pruned away from our calculations. This means the minimax algorithm
    has no need to look at the branch in the tree marked with the dotted line in the
    picture.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example, showing alpha-beta pruning in action. In the game
    tree shown in the picture, this pruning leads to only modest savings, since just
    a small number of the total nodes can be pruned. However, with larger game trees,
    the savings from alpha-beta pruning are typically immense, constituting a majority
    of the nodes in the game tree.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to take some liberties in how we implement alpha-beta pruning in
    our game to keep things simple. First, an alpha-beta pruning algorithm usually
    will pass around two variables called, naturally, `alpha` and `beta`.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的游戏中对alpha-beta剪枝的实现采取一些简化措施。首先，alpha-beta剪枝算法通常会传递两个变量，自然地称为 `alpha`
    和 `beta`。
- en: This is because it’s possible to write code that handles both the MAX nodes
    and MIN nodes at once by switching `alpha` and `beta` between the high and low
    limits. In our example, we’re going to use the variables `upper-limit` and `lower-limit`
    instead, indicating the highest and lowest values we care about as we traverse
    the game tree. As a cost, there will be some repetitive-looking code for handling
    the MAX and MIN cases. However, thinking of alpha-beta pruning in terms of `upper-limit`
    and `lower-limit` makes the code a bit easier to understand.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们可以编写一次处理MAX节点和MIN节点的代码，通过在高低限制之间切换 `alpha` 和 `beta`。在我们的例子中，我们将使用变量 `upper-limit`
    和 `lower-limit`，表示我们在遍历游戏树时关心的最高和最低值。作为代价，将会有一些看起来重复的代码来处理MAX和MIN情况。然而，将alpha-beta剪枝视为
    `upper-limit` 和 `lower-limit` 使得代码更容易理解。
- en: Another compromise we’re making is that we’re not decoupling the pruning code
    from the minimax code. Remember that with the trimming code, we wrote an independent
    function named `limit-tree-depth`, which separated the act of trimming from the
    rest of the AI code. We could use a similar approach for separating the alpha-beta
    pruning code as well, creating a function that can transform the game tree into
    a pruned version on its own. However, doing this is a bit more involved, because
    the alpha-beta pruning code must have access to intermediate minimax calculations.
    For a more advanced AI engine, this would be a good idea. For our simple engine,
    we will just add our alpha-beta pruning check directly inside our minimax functions.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的另一个妥协是，我们没有将剪枝代码与最小-最大代码解耦。记住，在使用剪枝代码时，我们编写了一个独立的函数名为 `limit-tree-depth`，它将剪枝操作与AI代码的其他部分分离。我们同样可以采用类似的方法来分离alpha-beta剪枝代码，创建一个能够将游戏树转换为剪枝版本的函数。然而，这样做稍微复杂一些，因为alpha-beta剪枝代码必须能够访问中间的最小-最大计算。对于更高级的AI引擎，这是一个好主意。对于我们的简单引擎，我们将在最小-最大函数内部直接添加我们的alpha-beta剪枝检查。
- en: 'So let’s get started. First, we’ll rewrite our `get-ratings` function as two
    new functions: `ab-get-ratings-max` and `ab-get-ratings-min`.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。首先，我们将重写我们的 `get-ratings` 函数为两个新函数：`ab-get-ratings-max` 和 `ab-get-ratings-min`。
- en: Remember that the `get-ratings` function was responsible for calculating the
    best score out of multiple available moves from a single-board arrangement. Now,
    however, we want it to stop early in its evaluation of moves once it decides it
    has found a move that’s “as good as is possible.” Determining whether it has reached
    this point is subtly different depending on whether the node in question is a
    MAX move (a move of the current player) or a MIN move (a move for the opponent).
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`get-ratings` 函数负责计算从单板布局中多个可用走法中的最佳得分。然而，现在我们希望它在决定找到了“尽可能好”的走法后，能够提前停止对走法的评估。确定是否达到这一点取决于所讨论的节点是MAX走法（当前玩家的走法）还是MIN走法（对手的走法）。
- en: 'Let’s look at the version responsible for MAX nodes first:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看负责MAX节点的版本：
- en: '[PRE141]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We’re now passing in an extra `upper-limit` and `lower-limit` argument into
    `ab-get-ratings-max` ![](httpatomoreillycomsourcenostarchimages783564.png). This
    function won’t actually ever check the `lower-limit` argument directly, since
    it is concerned only with finding the maximum rating possible from the given location
    in the tree. However, it will pass this value on to child branches, which may
    contain MIN nodes that *do* care about the lower limit.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将额外的 `upper-limit` 和 `lower-limit` 参数传递给 `ab-get-ratings-max`！![图片](http://atomoreilly.com/source/no_starch_images/783564.png)。这个函数实际上永远不会直接检查
    `lower-limit` 参数，因为它只关心从树中的给定位置找到可能的最大评分。然而，它将这个值传递给子分支，这些分支可能包含关心下限的MIN节点。
- en: When we rate the next branch of the tree ![](httpatomoreillycomsourcenostarchimages783562.png)
    (by calling `ab-rate-position`, which we’ll write shortly), we save the result
    as `x`. If `x` is greater than or equal to our `upper-limit` ![](httpatomoreillycomsourcenostarchimages783560.png),
    we know we got a result as good as we can hope for, and can just return the latest
    rating as a final value in our list ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: If `x` isn’t large enough, we need to keep looking at the remaining branches
    ![](httpatomoreillycomsourcenostarchimages783510.png). Note that `x` will become
    the new `lower-limit` if it’s larger than the previous `lower-limit`.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the `ab-get-ratings-min` function:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `ab-get-ratings-min` function is basically identical to the `ab-get-ratings-max`
    function, except the roles of the upper and lower limits are flipped. Based on
    the repetitiveness of these two functions, you could probably imagine how the
    `ab-get-ratings-max` and `ab-get-ratings-min` functions could be combined into
    a single function. As mentioned earlier, with that approach, rather than `upper-limit`
    and `lower-limit`, you would use the more generic terms `alpha` and `beta`, as
    these will differ based on whether the node is a MAX node or a MIN node.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to tweak `rate-position`, the function that rates a single-board
    arrangement:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In our new `ab-rate-position`, we check if this node in the game tree is a move
    for us or a move for an opponent ![](httpatomoreillycomsourcenostarchimages783564.png).
    If it’s a move for us, then it’s a MAX node, and we want to dispatch to `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783562.png). If it’s the opponent’s
    turn, we instead dispatch to `ab-get-ratings-min` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, `ab-rate-positon` is the same as our previous `rate-position` function.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our support for alpha-beta pruning, we need to modify one more
    function: the `handle-computer` function that kicks off our minimax calculations:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This function starts off the minimax calculation by calling `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783564.png), since the first move most
    definitely belongs to the target player and therefore is a MAX node.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: When we call this function, we’ll need to pass in our starting `upper-limit`
    and `lower-limit`. Since we’re at the very beginning of our minimax searching,
    we’ll want to set these to be as large and as small as possible. Ideally, we would
    want them to be *positive infinity* and *negative infinity*. Although many Lisp
    environments contain support for such concepts, they are not part of the ANSI
    Common Lisp standard. However, the standard does define `most-positive-fixnum`
    and `most-negative-fixnum`, which are very large positive and negative numbers,
    making them perfectly suited for our purposes. Hence, we pass these into `ab-get-ratings-max`
    to start off our limits ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to squeeze out a tad more efficiency from our AI engine, we could,
    instead, set the `upper-limit` and `lower-limit` to be the maximum and minimum
    values from our `score-board` function. That would slightly improve the amount
    of pruning that is possible. However, the `score-board` function may return a
    different range of scores based on the size of the board. and it might have other
    dependencies if we decide to optimize board scoring even more in the future. Therefore,
    it is best for the time being if we set our limits to nigh infinity for the start
    of our minimax calculations so we don’t need to worry about this.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final reward for once again improving the performance of our AI, let’s
    increase the size of the board to use a 5-by-5 game field. With our new lazy,
    trimmed, and pruned AI algorithms, we should be able to handle this larger board
    without a sweat:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we used memoization for some of our earlier functions. If you
    have already played some games in this chapter on a 4-by-4 board, one function
    in particular, the `neighbors` function, may return results based on this old
    board size. This is only an issue if you’ve already played a game on the 4-by-4
    board without restarting your Lisp in the interim. To fix this, simply rerun the
    definition of the `neighbors` function in `dice_of_doom_v1.lisp` from the REPL
    (including the memoized revision at the bottom of the file) to clear any cached
    results.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our game looks like now:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: At this point, our REPL game interface is becoming really impractical for such
    a large game field. We’ll be addressing that next.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  id: totrans-912
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we made the computer player for our Dice of Doom game much
    more sophisticated. We implementing the game tree using lazy lists, and applied
    several optimization techniques to limit the number of board positions that are
    searched by the AI engine. Along the way, you learned the following:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '*Lazy programming* allows you to work with very large (and even infinite) data
    structures and do so efficiently.'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have a `lazy` macro and a `force` function, you can use them to build
    more sophisticated lazy operations, including building a lazy list library.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heuristics are imperfect algorithms that can be used to improve the performance
    of your code, with some creative thinking. In our example, we made some heuristic
    changes to how we score leaf nodes.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we converted Dice of Doom to use a lazy tree, we were able to elegantly
    trim the game tree in order to limit how deep the AI thinks when contemplating
    its moves.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha-beta pruning lets us improve performance even more, by pruning branches
    that have no way of impacting the final scores on the moves being considered by
    the AI.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 19. Creating a Graphical, Web-Based Version of Dice of Doom
  id: totrans-919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a second version of Dice of Doom to play
    on larger game boards. It has become quite difficult to understand the board and
    make moves using our crude console interface. Certainly, Dice of Doom would be
    infinitely better if we had a pretty graphical game board that allowed us to simply
    click where we wanted to make our moves. Well, I have good news for you . . .
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll put together a lot of code from earlier chapters to transform
    Dice of Doom into a full-featured, graphical game you can play right inside a
    web browser!
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Game Board Using the SVG Format
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already written a primitive web server in [Chapter 13](ch14.html "Chapter 13. Let's
    Create a Web Server!"). Also, we’ve covered how to draw SVG graphics with a DSL
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages"). Lucky for
    us, the new HTML5 standard includes features that make it possible to embed SVG
    pictures directly inside a standard HTML document. In this way, we’ll be able
    to use our simple little web server to serve up some fully interactive vector
    graphics. You’ll be amazed at how easy it is to do this.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time this book was written, the only web browser to support inline SVG
    within HTML was Firefox 3.7 Alpha. Use this, or a more recent release of Firefox
    with our new version of Dice of Doom. If you’re having problems, try navigating
    to the about:config page in the Firefox address bar, and set the html5.enable
    configuration setting to true. This will allow Firefox to use the latest HTML5
    settings.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that our web server library is not pure ANSI Common Lisp, and
    makes use of some CLISP-specific extensions. This means it requires CLISP to function.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll need to pull in code from various other chapters to get ready.
    In the previous chapter, we created version 2 of our Dice of Doom engine. Place
    all the code from that chapter in a file named *dice_of_doom_v2.lisp*. You should
    also already have created a file named *webserver.lisp* from [Chapter 13](ch14.html
    "Chapter 13. Let's Create a Web Server!"). (These files are all freely available
    from [http://landoflisp.com/](http://landoflisp.com/).)
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load in these files:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For our SVG support, we’ll also need the SVG-rendering code from [Chapter 16](ch18.html
    "Chapter 16. The Magic of Lisp Macros") and [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages"). Place those functions in *svg.lisp*. (This file is also available
    from [http://landoflisp.com/](http://landoflisp.com/).) For reference, the functions
    we’ll need are `let1`, `split`, `pairs`, `print-tag`, `tag`, `svg`, `brightness`,
    `svg-style`, and `polygon`. Load this file next:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now let’s write some code that can draw a pretty version of our game board
    using SVG. First, we’ll want to define some constants that control the various
    dimensions needed to draw the board:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The board width and height will be 900-by-500 pixels, which is a good size for
    playing a game in a browser on most people’s computer screens. The board scale
    ![](httpatomoreillycomsourcenostarchimages783564.png) represents half the width
    of a single hex on the screen in pixels. The `*top-offset*` variable ![](httpatomoreillycomsourcenostarchimages783562.png)
    tells us we want three extra hex heights of free space above the base of the board.
    We’ll need this because a hex with lot of dice on it will have its dice sticking
    out, upward, and we need room for these dice to be visible on the screen. The
    `*dice-scale*` variable ![](httpatomoreillycomsourcenostarchimages783560.png)
    tells us that a single die will be about 40 pixels tall and wide on the screen.
    Finally, we set `*dot-size*` to `0.05`, which tells us that each dot will be about
    0.05 times the size of a die ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Die
  id: totrans-935
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to write a function that can draw a die. Note that we won’t
    use bitmaps or anything like that to draw. Instead, we’re drawing a die “the hard
    way,” by rendering it directly out of raw SVG polygons. Here’s the code:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: To draw a die, we need to pass in three arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    The first two are the x and y position at which the die should appear in the SVG
    picture. The third is the color we want the die to be. This function will take
    some liberties with that color and modify it as needed to give the die a little
    shading.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Anything we draw in this function will need to be rendered in a scaled fashion,
    based on the `*dice-scale*` constant we defined. Therefore, we first define a
    local function `calc-pt` that scales a point for us ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we’ll need to draw several scaled polygons, let’s also create a convenience
    function, `f`, that runs `calc-pt` against all points in a polygon and then draws
    it by calling the `polygon` function ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 'A die in our picture will have three visible faces: the top face, the front
    face, and the right face. We draw these by calling our function `f` three times
    starting here ![](httpatomoreillycomsourcenostarchimages783554.png) and using
    some hard-coded coordinates for the three faces.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is draw the little dots on the faces of the die.
    We do this by `mapcing` ![](httpatomoreillycomsourcenostarchimages783510.png)
    the coordinates for the dots ![](httpatomoreillycomsourcenostarchimages783544.png)
    against a lambda function that can render a dot. This lambda function uses the
    `*dot-size*` variable to scale down a square-shaped polygon that represents each
    dot on the die face. We could write more sophisticated code to draw circular and/or
    elliptical dots, but the dots are so small that squares look just fine.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try drawing a die at x=50 and y=50 with an RGB red `(255 0 0)` color:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If you want to see what the final die looks like, just save this gobbledygook
    to a file named *die.svg*. Then load the result in Firefox, where you should see
    the following picture (shown at a blown-up size):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782140.png.jpg)'
  id: totrans-945
  prefs: []
  type: TYPE_IMG
- en: Drawing a Tile
  id: totrans-946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s write the function to draw an entire hex tile, including the base
    and the dice on the tile:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: This function takes in a lot of parameters, because a lot of information is
    encoded in a single tile of the board. You’ll learn the precise meaning of each
    of these parameters when we draw the board in the next section.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: First, our `draw-tile-svg` function draws the base. To give the base a mild
    3D look, we’ll draw it twice, with one level stacked on top of the other. Here
    ![](httpatomoreillycomsourcenostarchimages783564.png) is the loop that draws the
    two bases. Within that loop, we need to draw a hexagonal polygon ![](httpatomoreillycomsourcenostarchimages783562.png).
    We map a scaling function across the coordinates so that they are scaled to our
    `*board-scale*` variable. Here ![](httpatomoreillycomsourcenostarchimages783560.png)
    you can see the six points of a hexagon in perspective encoded using decimal notation.
    The color of the base will be brightened slightly if it has been chosen by the
    player to perform a move. We do this by increasing the brightness of the tile
    when creating our polygons ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve finished drawing the tile base, we need to draw the dice that reside
    on the tile. We do this by looping across the number of dice ![](httpatomoreillycomsourcenostarchimages783510.png)
    and then calling our `draw-die-svg` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    When calculating the x and y positions of the dice, we need to perform a bit of
    scaling math. The most interesting piece of this math is that we shift the dice
    a bit to the left or right, depending on whether the sum of the x-, y-, and z-coordinates
    for a given die is odd or even ![](httpatomoreillycomsourcenostarchimages783556.png).
    This makes the stacks look a little imperfect and will give the stacked dice for
    the complete board a pleasing, natural appearance.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s call our function to draw a finished tile and see how it looks. Again,
    just copy the output from this command to a file named something like *tile.svg*.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Here’s what you should see when looking at the file in Firefox:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782446.png.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
- en: Drawing the Board
  id: totrans-956
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to write a function that draws an entire game board as an SVG.
    It will be very similar to our `draw-board` function, which we’ve been using to
    draw the board to the console. It fulfills the same role, but simply outputs the
    result as SVG data.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `draw-board-svg` function takes the board as an argument, but also requires
    two other arguments that will be important for using the picture as the front
    end of the user interface for our game ![](httpatomoreillycomsourcenostarchimages783564.png).
    One argument is `chosen-tile`, which indicates a tile that the player has clicked
    with the mouse. We’re going to color that tile a bit lighter, so the player can
    tell that the computer has recognized the selection. Another argument is `legal-tiles`,
    which indicates which tiles the player can legally click next.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: It so happens that SVG pictures have a feature for web links, which works just
    like the `<a href="...">` hyperlinks in regular HTML. If a tile is a legal tile
    for the player’s next move, we’ll wrap the SVG for that tile in such a link, making
    it clickable. Having the `legal-tiles` parameter lets us know which tiles we want
    to be clickable.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: The `draw-board-svg` function consists of a couple of nested loops that loop
    through the `y` ![](httpatomoreillycomsourcenostarchimages783562.png) and `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png) coordinates of the tile
    board. For each tile, we then define a ton of local variables (using the facility
    for local variables in the `loop` macro introduced in [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")). First, we declare `pos` ![](httpatomoreillycomsourcenostarchimages783554.png),
    which indicates the position of current tile in the hex array. Then we fetch that
    hex. Next, we calculate the pixel coordinates for the tiles, in the variables
    `xx` and `yy`. As you can see, the math for these coordinates gets a bit tricky,
    since the board is drawn in perspective on the screen.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: The final local variable we define is `col`, which will hold the color of the
    tile and dice in the current spot. We do this by using a list of die colors, which
    currently holds the colors red (for player A) and blue (for player B). We also
    darken the color a bit based on the y-coordinate using the `brightness` function
    (discussed in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages")).
    This darkens the rows in the back a bit, adding to the 3D appearance of our SVG
    game board.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: If the current tile is a member of the legal tiles ![](httpatomoreillycomsourcenostarchimages783510.png),
    we’re going to wrap it in a web link, as mentioned previously. In SVG, this is
    done with a tag in the form `<a xlink:href="...">`, which we create here ![](httpatomoreillycomsourcenostarchimages783544.png).
    Notice that we also wrap each tile in a `<g>` tag, which tells the SVG renderer
    to treat the polygons in this tile as a group. To figure out the actual URL we
    want to link to, we call the `make-game-link` function. This function builds an
    appropriate URL. You’ll understand the format of the URL better once we start
    writing the code that handles the web server for our game.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’re ready to call our `draw-tile` function ![](httpatomoreillycomsourcenostarchimages783556.png).
    There are two different versions of the call in our code: one for the hyperlinked
    version and one for the nonlinked version.'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'Phew! Now we can finally draw a full game board dynamically, using the SVG
    format:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'If you save the output to *board.svg* and load it in Firefox, here is what
    you should see:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781682.png.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
- en: Building the Web Server Interface
  id: totrans-969
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve completed the graphical side of Dice of Doom version 3, we’re
    ready to write the side that interfaces with the web server.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: Writing Our Web Request Handler
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The central function for our web server handling is called `dod-request-handler`.
    It is the function that we can pass to the `serve` command in our web server library,
    and it is responsible for handling all the web requests coming from the web browser.
    Here is the code for `dod-request-handler`:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: First, this function checks whether the current page being fetched from the
    web server is `game.html` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This is the page where our game will reside on the web server. At the top of the
    page, we specify the `doctype` ![](httpatomoreillycomsourcenostarchimages783562.png).
    When done in this way, it tells the web browser to expect an HTML5-encoded web
    page. Then we put in some simple HTML to center the page and print a welcome message
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: The `params` passed from the web server library may contain an important value
    named `chosen`, which we fetch using this line ![](httpatomoreillycomsourcenostarchimages783554.png).
    If there is no chosen tile, or if the game tree is currently empty ![](httpatomoreillycomsourcenostarchimages783510.png),
    it means the player must be starting a brand-new game. If that’s the case, we
    will call a function named `web-initialize` ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out whether the game has ended. We can tell this by checking
    if the list of moves is empty (which, as you might remember, is stored in the
    `caddr` location of the tree). In that case, we’ll announce a winner ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we need to see if the current player is player zero, which means
    the player is the human player. In that case, we’ll call the function `web-handle-human`
    ![](httpatomoreillycomsourcenostarchimages783566.png) to build the rest of the
    HTML data in the body of the page. We also use the `read-from-string` function
    to pull the number of the chosen tile from the `chosen` parameter, if it exists.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: In all other cases, we know we’re dealing with a computer player and hand over
    control to `web-handle-computer` ![](httpatomoreillycomsourcenostarchimages783498.png)
    to build the rest of the HTML.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `dod-request-handler` function needs to call the `draw-dod-page`
    function to draw the game board, which we do here ![](httpatomoreillycomsourcenostarchimages783062.png).
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Our Game Web Server
  id: totrans-980
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The limitations of our game web server are quite significant. First of all,
    for simplicity’s sake, the `dod-request-handler` function makes absolutely no
    effort to try to determine from whom the web request is coming. It behaves as
    if all game interactions were coming from a single player, and therefore isn’t
    a true multiplayer server for Dice of Doom. If multiple players were to try to
    play different games at the same time, the `dod-request-handler` would get confused
    and *bad things* would happen.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: It would not be too difficult to expand `dod-request-handler` into a true web
    server for multiple, parallel games. To do this, we would need to pull session
    information out of the header data it receives as an argument from the web server,
    and then all variables it references (such as `*cur-game-tree*`, for instance)
    would need to live in a hash table, using the session information as a key. This
    way, each player would have her own game tree, and our engine could then serve
    multiple games in parallel. The implementation of such a multigame version of
    the `dod-request-handler` is “an exercise for the reader.”
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of `dod-request-handler` is that it reads information from
    the URL using the `read-from-string` function. As you’ve learned in earlier chapters,
    this function can be compromised to run arbitrary code in the hands of an experienced
    (and evil) Lisper.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a New Game
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the `web-initialize` function, which initializes our game engine to
    start a brand-new game of Dice of Doom:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As you can see, it generates a random game board, builds a tree from it, and
    then stores the result in the global `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Announcing a Winner
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that announces the winner within the web browser:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: It is exactly the same as our previous `announce-winner` function, except that
    it now includes some extra code at the end to build a web link ![](httpatomoreillycomsourcenostarchimages783564.png),
    which will allow us to conveniently start a brand-new game, since the current
    game has ended.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Human Player
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web-handle-human` function is responsible for creating the HTML and doing
    the bookkeeping when the player taking the current turn is the human player.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The recent choices the human has made dictate what this function will do. The
    `web-handle-human` function knows the human’s choices by referencing the most
    recently chosen position, which derives from a variable passed as a parameter
    through the web request. It also can reference the `*from-tile*` global variable,
    which tells it which tile the player initially chose to use as a starting location
    for a move. It needs both of these values, since a move has both a source location
    and a destination location.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: If the player has not yet chosen a location, we want to print a message requesting
    that the player choose a hex ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player chose to pass, we want to print a message saying that player’s reinforcements
    have been placed ![](httpatomoreillycomsourcenostarchimages783562.png). (Remember
    that reinforcements are placed right after someone passes.)
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check if the `*from-tile*` variable is nil. If this is the case, it
    means the player has not yet chosen a starting location for a dice attack. If
    it’s `nil`, we can set `*from-tile*` equal to the location that was just selected
    ![](httpatomoreillycomsourcenostarchimages783560.png), as well as ask the player
    to select a destination.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: If the currently selected location is the same as the `*from-tile*` variable,
    it means a tile was selected twice. This must mean the player has changed his
    mind and wants to undo his selection. Therefore, we will set `*from-tile*` to
    `nil` and print a cancellation message ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: In all other cases, it means the player has selected two valid locations for
    the start and end of an attack. We can now advance the `*cur-game-tree*` to point
    to the appropriate next tree inside the lazy list of available moves ![](httpatomoreillycomsourcenostarchimages783510.png).
    We want to print a message, allowing the player to pass ![](httpatomoreillycomsourcenostarchimages783544.png)
    or make yet another attack.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the code our game server will use to interact with the
    human player. Next, let’s write a function to handle the computer player.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Computer Player
  id: totrans-1001
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handling the web interface for our computer player is pretty simple. After
    all, computer players don’t need any fancy user interface stuff to know what’s
    going on in the game. All the web stuff that happens when the computer is making
    moves is there solely for the benefit of the human player. Here is the `web-handle-computer`
    code that renders the HTML in the web interface as the AI player makes a move:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: All this function does is call our previous `handle-computer` function, which
    will return the next branch that the computer has selected in the game tree. We
    use this to update our `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we print a message to state that the player has moved ![](httpatomoreillycomsourcenostarchimages783562.png).
    The last part of the function is a clever little gimmick to spice up our web interface
    a bit. It puts a smidgen of JavaScript in the HTML of the web page ![](httpatomoreillycomsourcenostarchimages783560.png),
    which forces the web browser to automatically load a new web page in five seconds.
    This means that as the computer AI player makes its moves, we get to see everything
    happen in a crude animation!
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the SVG Game Board from Within the HTML
  id: totrans-1005
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only one more function to write to complete version 3 of Dice of Doom:
    the `draw-dod-page` function. This function interfaces our page game server code
    with the SVG code that draws our board.'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The most complicated part of this function is the code that determines which
    tiles on the board are legal tiles for the player to click ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player has already selected a tile, we want to find all moves ![](httpatomoreillycomsourcenostarchimages783562.png)
    where the starting position for the move matches the selected tile ![](httpatomoreillycomsourcenostarchimages783560.png)
    and return the destination position for the given move ![](httpatomoreillycomsourcenostarchimages783554.png).
    If the player hasn’t selected a tile yet, we just want to return all the legal
    starting positions ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our fully graphical version of Dice of Doom. Let’s play!
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: Playing Version 3 of Dice of Doom
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to start up our web server. Simply serve up our `dod-request-handler`,
    and we’re ready to go:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Now move over to Firefox and go to [http://localhost:8080/game.html](http://localhost:8080/game.html).
    You should see our game in your browser:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783058.png.jpg)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
- en: 'When you click a tile, it is highlighted:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782450.png.jpg)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
- en: 'Now you can select a tile to attack. In this example, we’ll choose the stack
    of two dice to the right of the selected stack:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781872.png.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
- en: 'Next, let’s pass our turn by clicking the **`pass`** web link. This will cause
    the reinforcement dice to be placed (in this case, only a single additional die
    in the upper-left corner):'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781252.png.jpg)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
- en: If you now hit **`continue`**, you will see the game cycle automatically through
    the moves for the computer player, in a similar fashion. It will keep going on
    like this until there is a winner for the game. You can always start a new game
    by just going back to the original *game.html* URL.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: This is much nicer than the crude console interface we’ve been using so far!
    But there are still a few, final improvements we’re going to make to pep up Dice
    of Doom. We’ll be covering those in the next (and final chapter) of this book.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  id: totrans-1023
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed how you can generate interactive graphics in
    a web browser from a Lisp program. Along the way, you learned the following:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: You can create a graphical version of Dice Of Doom by rendering the board using
    the SVG format.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML5 standard supports inline SVG images. You can use this to create an
    interactive, web-based version of your game.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simple web server used for our example has several limitations. For example,
    our game cannot be played by multiple players. However, the request handler could
    be expanded to allow for multiple, parallel games.
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 20. Making Dice of Doom More Fun
  id: totrans-1028
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now time to create a final version of Dice of Doom. Version 4 of our game
    will be much more fun to play than our earlier versions.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Although you probably were not aware of it, we made some major compromises in
    the rules for our game to make it easier to program. In this chapter, we will
    allow more players, add rolling of the dice, and implement a few more changes
    to make Dice of Doom a much more interesting game.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the Number of Players
  id: totrans-1031
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, put all the code from the previous chapter in a file named *dice_of_doom_v3.lisp*
    (also available from the companion website), and then execute the following command:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The first change we’re going to make is to increase the number of players from
    two to four. Three of these will be AI opponents, played by the computer. Because
    of how we’ve written our code so far, this requires very little extra code:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: First, we simply change our `*num-players*` variable to `4`. Then we need to
    indicate additional die colors for our new players. The colors for the four players
    will be red, blue, green, and purple.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the AI we’ve created so far already works just fine in a four-player
    game.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Our AI game engine will use what is called a “paranoid strategy.” This means
    that the AI players will always assume that every other player (including the
    human) has no other goal but to—how should I put this?—screw them over personally.
    This isn’t a bad strategy to use; however, a game with more than two players opens
    up new possibilities. For instance, losing players could gang up on a winning
    player to improve their odds. Our game AI isn’t smart enough to form such packs
    of cooperation, but it’s good enough.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve already tweaked some constants to increase the number of players,
    let’s tweak a couple more:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we’re increasing the maximum number of dice on a hex tile from three to
    five, and decreasing the level of our AI from four to two. With the new rules
    described in this chapter, we’ll need to dumb down our AI a bit to make sure it
    stays zippy. Since there are now four competing players, the AI actually doesn’t
    need to be so smart to challenge the human opponent.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: Rolling the Dice
  id: totrans-1042
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’m sure you’ve probably noticed one obvious flaw in our game so far: Despite
    the fact that it is called Dice of Doom, it actually is completely devoid of any
    randomness! The dice are never rolled, and the larger stack will always automatically
    win, which makes for a pretty lame dice game. Now we’re finally going to rectify
    this flaw.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the game, during an attack, both piles of dice are rolled,
    and whoever rolls the highest number wins the battle. Ties are a victory for the
    defender. If the attacker loses, that player must surrender all dice from the
    attacking hex except one.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: In the lingo of AI programming, this means we will add *chance nodes* to our
    game tree. The way we’re going to implement this is pretty simple.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Building Chance Nodes
  id: totrans-1046
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every move in our lazy list of moves up to now has always had exactly two items
    in it: a description of the move (a list of the source and destination of the
    attack, or `nil` for a passing move) and the new node of the game tree for when
    the move has been taken. Now we’re simply going to add a third item to a move,
    which contains the game tree for an unsuccessful attack. This means that each
    move in our move list will double as a chance node, with two possible follow-up
    nodes for the next game tree, depending on whether an attack is successful.'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update our `attacking-moves` function to add this extra item to the move
    so that each move acts as a chance node.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The only thing new in this updated version of `attacking-moves` is right here
    ![](httpatomoreillycomsourcenostarchimages783564.png), where we add a third item
    as we create a new move in the game tree. The board in this alternate branch of
    our chance node is constructed by calling the function `board-attack-fail`, which
    we will write next.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 'The `board-attack-fail` function does exactly what you would expect: It takes
    a board and returns a board that has all dice but one removed from the hex from
    which a failed attack originated.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Here, we simply loop over the board and return each hex unmodified ![](httpatomoreillycomsourcenostarchimages783562.png),
    unless it happens to be the source hex for the attack. In that case, we remove
    all dice from that hex but one ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: Doing the Actual Dice Rolling
  id: totrans-1054
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to write some functions to actually roll the dice. Here is a
    function that rolls a pile of dice:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: First, it calculates a total count of a pile of rolled dice by looping once
    for each die. For each die, it generates a random number from 1 to 6\. Then it
    stores the total sum in the `total` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, the `roll-dice` function prints a descriptive message about the roll ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it returns the total ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re never going to roll a pile of dice in isolation, let’s create another
    function that pits two piles of dice against each other:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: This simply calls `roll-dice` twice and compares the total of the two rolls.
    We’ll want to use this function as we travel along our game tree to pick either
    the winning or losing move as a turn is chosen by either the human or the computer.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Dice Rolling Code from Our Game Engine
  id: totrans-1061
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of our game engine, rolling dice simply means picking either
    the winning or losing branch of the chance node after the human or computer has
    chosen a move. This action is performed by the `pick-chance-branch` function:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This function takes the current board and also the move that contains the chance
    node that needs to be resolved ![](httpatomoreillycomsourcenostarchimages783564.png).
    When the path inside the move is not `null`, we call `roll-against` with a count
    of dice in the source and destination hexes along the path of attack ![](httpatomoreillycomsourcenostarchimages783562.png).
    We check for a `null` path because that means the move was a “pass,” which doesn’t
    require any dice rolling.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: If the dice roll for the attack is successful, we remove the first child tree
    from the chance node within the move ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the attack is unsuccessful, we return the second child of the chance node ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make sure that the `pick-chance-branch` function is called when
    the human or computer chooses a move. First, let’s take care of the human:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: All we’ve done here is to add a call to `pick-chance-branch` at the end of our
    previous `handle-human` function, at the point we need to return the child branch
    of the game tree that holds the next state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the `handle-computer` function in the same way:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Again, we’ve simply added a call to `pick-chance-branch` at the end of the function
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: It is now possible to play our updated Dice of Doom game. However, at this point,
    the computer player will play a very poor game, because the AI does not yet understand
    that the chance nodes exist. It will simply assume that every attack will always
    be successful, making it much too foolhardy to play a decent game. We need to
    improve our AI so that it takes into account the rolling of the dice as it makes
    its decisions.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: Updating the AI
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the AI to be able to deal with the dice rolls that are now important to
    our game, it must know a little something about the statistics of dice rolls.
    The following table gives it the needed statistical information:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This table contains the odds of winning for each possible pairing of dice in
    our game. The columns represent the attacking dice, starting with one die. The
    rows represent the destination dice, starting with two dice (the minimum dice
    needed for an attack).
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: This table tells us, for instance, that a roll of two attacking dice against
    one defending die has an 84 percent chance of winning. Four attacking dice against
    three defending dice have a 74 percent chance of winning.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, the core function in our AI code is the `get-ratings` function,
    which gives a point score to the list of possible follow-up moves. We need to
    modify how it calculates the score of each possible move to take the odds of success
    of the dice roll into account. We are now going to make use of our `*dice-odds*`
    table, as well as the point scores of the successful or failed outcomes of each
    attack, to interpolate a combined score for each available move:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In our updated `get-ratings` function, we look up the odds of each attack succeeding
    from our table ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    multiply the odds with the rating for the winning child tree ![](httpatomoreillycomsourcenostarchimages783562.png).
    Additionally, we add in the odds of losing the attack (one minus the odds of winning)
    multiplied by the rating for the losing board position ![](httpatomoreillycomsourcenostarchimages783560.png).
    We now have an updated `get-ratings` function that understands chance nodes and
    accounts for them appropriately when generating the score for a move.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: 'For our game AI to be fully compatible with chance nodes, we need to make one
    additional small change. Our tree-trimming function needs to know about the two
    branches of the chance node within each move, so it can properly trim both the
    winning and losing alternatives for each move:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: We `mapcar` ![](httpatomoreillycomsourcenostarchimages783564.png) across the
    tail of each move, so trimming is performed on both branches of any chance nodes.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version 4 of Dice of Doom will not have alpha-beta pruning. Performing proper
    alpha-beta pruning in the presence of chance nodes is very complex.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Dice of Doom Reinforcement Rules
  id: totrans-1086
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the number of reinforcements at the end of a player’s turn always
    equals the number of captured opponent dice, minus one. This reinforcement rule
    guaranteed that the total number of dice in a game always decreases, so that the
    game was certain to eventually terminate, and the game tree was always finite
    in size.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: However, since version 2, our game tree has been a lazy tree, so it is perfectly
    fine if the tree is infinite. Remember that one of the main benefits of lazy evaluation
    is that you can have data structures that are infinite in size.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we are now going to adjust our reinforcement rules to make our game
    strategically more interesting.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: According to our new rules, the number of reinforcement dice will equal the
    number of tiles in the player’s largest contiguous territory. This adds a lot
    of strategic depth, because the players must constantly decide whether to risk
    connecting their territories, or perhaps even to sacrifice smaller, nonviable
    territories by sending them on suicide missions.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this new reinforcement rule, let’s first define the function
    `get-connected`, which returns a list of tiles that are owned by the current player
    and are connected as a cluster of neighbors to the target tile:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: This function uses the same algorithm for finding connected tiles as we used
    for calculating connectedness in our Grand Theft Wumpus game in [Chapter 8](ch09.html
    "Chapter 8. This Ain't Your Daddy's Wumpus"). We traverse through the hexes and
    their neighbors recursively, while maintaining a `visited` list.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: The `get-connected` function accomplishes this by defining two recursive local
    functions. The `check-pos` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    checks a single position and appends any new neighbors accessible from that location
    to the visited list. The `check-neighbors` function ![](httpatomoreillycomsourcenostarchimages783562.png)
    checks an entire list of neighbors, similarly appending new neighbors to the visited
    list. These two functions call each other recursively until all neighbors in a
    cluster are found. To start off this recursive calculation, we call the `check-pos`
    function with the target position and an initially empty `visited` list ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now find clusters. However, to find the *largest* cluster, we need the
    `largest-cluster-size` function:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: This function defines a local function `f`, which we’ll use to check every position
    on the board, while maintaining both a list of previously visited nodes and the
    size of the largest, best cluster found so far ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: As long as the current position number is less than the total number of spots
    on the board ![](httpatomoreillycomsourcenostarchimages783562.png), we continue
    to check tiles. If the current tile to be checked belongs to the player and also
    has not yet been visited ![](httpatomoreillycomsourcenostarchimages783560.png),
    we’ll call `get-connected` to retrieve the cluster of hexes reachable from this
    spot ![](httpatomoreillycomsourcenostarchimages783554.png). Then, if the size
    of the cluster is larger than the best found so far ![](httpatomoreillycomsourcenostarchimages783510.png),
    we make this the new best size in our recursive call ![](httpatomoreillycomsourcenostarchimages783544.png).
    Otherwise, we proceed by calling `f` while keeping the previous best size ![](httpatomoreillycomsourcenostarchimages783556.png).
    (The best variable at this point will hold the best value found so far from previous
    iterations.) No matter what happens, however, the `pos` variable is incremented
    with every recursive call to `f`, so that we eventually cover the whole board.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update `add-new-dice` to make use of our new rule for choosing
    the number of reinforcements:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: As you can see, the `add-new-dice` function still receives `spare-dice` as an
    argument for compatibility with our old code ![](httpatomoreillycomsourcenostarchimages783564.png),
    but now this argument is simply ignored. Instead, the number of reinforcements
    added to the board depends on the size of the largest cluster ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, the `add-new-dice` is identical to our previous version.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: This is all the code we need to enable the new reinforcement rules. Note that,
    due to the design of our code, the AI player has full access to the game tree.
    Since the game tree now contains all of this new reinforcement data, the AI will
    automatically adapt its playing strategy to take into account the new reinforcement
    rules!
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve gone through quite a long trip as we’ve created the Dice of Doom game,
    employing an immense number of different programming techniques along the way.
    We’ve taken even more trips with all the other games in this book. Thanks for
    taking this journey with me through the world of Lisp programming!
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest that you take a moment to enjoy the fruits of your labor and play
    a few games of the fourth and final version of Dice of Doom. Again, all you need
    to do is serve up the Dice of Doom request handler through our web server:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Now you can play Dice of Doom in Firefox (again, at the address *localhost:8080/game.html*)
    as it is meant to be played, with four players and all the new rules we’ve added
    in this chapter.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781284.png.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
- en: Good luck with all your Dice of Doom battles and all your future Lisp programming!
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780634.png.jpg)'
  id: totrans-1110
  prefs: []
  type: TYPE_IMG
- en: Appendix A. Epilogue
  id: totrans-1111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve worked your way through this book, here is one final reward:
    A story about the technologies behind the entire Lisp family of programming languages,
    set in the not-too-distant future . . .'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781408.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780716.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780760.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780566.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780604.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780012.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783188.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783236.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782622.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782670.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782072.png.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
- en: Functional Guild Cruiser
  id: totrans-1114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming is a mathematical approach to programming that was pioneered
    by the creators of Lisp. Functional programming places certain restrictions on
    the programmer, but it can lead to very elegant code. When using functional programming,
    every variable that is used by a given function must be one of the following:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782902.png)'
  id: totrans-1119
  prefs: []
  type: TYPE_IMG
- en: A parameter passed into that function
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local variable created within that function
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constant
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, functional programming doesn’t allow a function to have *side effects*.
    This means a function can’t write to the disk, print messages on the screen, or
    do anything other than return a result. The goal is to write most of a program
    using “functional code,” while retaining a teensy bit of code that does any dirty,
    nonfunctional stuff that is still needed.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing code in a functional style guarantees that a function does only one
    thing (returns a value) and is dependent on one only thing (the parameters passed
    to it). This makes it very easy to debug. No matter how many times you run a function,
    as long as you’re passing it the same data, you will always get the same result.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Example A-1. Example
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Explanation
  id: totrans-1128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enter this code into the Lisp REPL and execute `(ask-and-respond)`, you
    will be asked for your name, and then greeted by your name but with all duplicate
    letters removed. All the hard work in this function is handled by `unique-letters`,
    which is written in a functional style ![](httpatomoreillycomsourcenostarchimages783564.png).
    The dirty work of interacting with the user, which can’t be written in a purely
    functional way, is handled by `ask-and-respond` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main weakness of functional programming is that some side effects are almost
    always necessary for a program to actually *do* something. This means you can’t
    write a useful program that has the entirety of its code written in the functional
    style. At least a small amount of code will be nonfunctional.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming").
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782372.png.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
- en: Macro Guild Melee Fighters
  id: totrans-1134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*True macros* are one of Lisp’s most unique and amazing features. In fact,
    the reason Lispers put up with all those annoying parentheses in their code is
    that those parentheses enable the awesome Lisp macro system.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780362.png)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
- en: True macros allow you to add new functionality to Lisp in a very fundamental
    way. Experienced Lispers can use macros to make their Lisp compiler/interpreter
    do their bidding cleanly and elegantly.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  id: totrans-1141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using macros, an experienced Lisper can minimize code duplication, and better
    tailor the underlying language to the problem at hand. This leads to cleaner code
    and fewer bugs.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: Example A-2. Example
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Explanation
  id: totrans-1145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lisp macros are so powerful that you can actually write your own if-then command!
    The code shown here creates a macro called `three-way-if` that has three branches:
    one for a `nil` value ![](httpatomoreillycomsourcenostarchimages783564.png), one
    for a numerical zero value ![](httpatomoreillycomsourcenostarchimages783562.png),
    and one for everything else ![](httpatomoreillycomsourcenostarchimages783560.png).
    For most purposes, a function like this might seem stupid, but if you ever want
    to write a program that constantly needs to distinguish zeros from `nil`s (or
    needs to handle some other domain-specific headache), you’ll make your life much
    easier by writing a macro.'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Lisp macros are so powerful, there is always the danger of programmers
    abusing them. Overuse of macros can make it hard for other programmers to understand
    your code.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: Macros are discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp
    Macros").
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: Restart Guild Armored Fighter
  id: totrans-1150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Proper exception handling is extremely difficult. There are really only two
    good approaches: Don’t handle exceptions at all and just let your program die
    when one occurs, or handle every single exception in the most direct and specific
    way possible. But is it truly possible to handle every potential exception in
    your code? If your write Common Lisp code, it’s possible to get extremely close
    to this ideal goal.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782448.png)'
  id: totrans-1155
  prefs: []
  type: TYPE_IMG
- en: For example, suppose you write a function that raises the prices on a list of
    widgets. But then, while the function is processing one of the widgets in the
    list, there’s a memory allocation error. You can’t prepare for this type of error
    ahead of time, since it could happen anywhere in a program. This makes it impossible
    to address using traditional exception handling methods.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你编写了一个函数来提高小部件列表中的价格。但在函数处理列表中的某个小部件时，出现了内存分配错误。你无法提前准备这种类型的错误，因为它可能发生在程序的任何地方。这使得使用传统的异常处理方法无法解决这个问题。
- en: 'Even if a function lower in the call stack catches and resolves the source
    of the exception, the program still faces an unsolvable problem: Some of the widget
    prices have been raised, while others have not. Common Lisp, however, has a mechanism
    for addressing this problem, called *restarts*.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调用栈中较低层的函数捕获并解决了异常的根源，程序仍然面临一个无法解决的问题：一些小部件的价格已经上涨，而另一些则没有。然而，Common Lisp
    有一个机制来解决这个问题，称为 *重启*。
- en: In a language that supports restarts, the function that raises the widget prices
    can make the proclamation, “Hey everybody! If something bad happens while I’m
    working on my widgets, just use my restart (called `try-again`) when it’s safe
    for me to finish my work!” Another function, lower in the call tree, can now handle
    the error, and then call `try-again` to ensure that the widget prices won’t become
    corrupt. This allows the function to finish raising widget prices at the exact
    point of failure.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持重启的语言中，提高小部件价格的函数可以宣布，“嘿，大家！如果在我处理小部件时发生什么坏事，当对我来说安全完成我的工作时，请使用我的重启（称为 `try-again`）！”
    另一个位于调用树较低层的函数现在可以处理错误，然后调用 `try-again` 来确保小部件价格不会变得损坏。这允许函数在失败的确切点完成提高小部件价格的操作。
- en: In fact, if you have a program that can’t afford to shut down (a web server,
    for example), you can still handle a surprising number of extreme exceptions in
    Common Lisp without ending the program. Even if the program encounters a truly
    exceptional exception, it can simply divert control back to the REPL. The programmer
    can then fix the cause of the exception, access a list of available restarts,
    and continue running the program on the spot.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你有一个无法承受关闭的程序（例如，一个网络服务器），你仍然可以在不结束程序的情况下处理大量极端的异常。即使程序遇到真正异常的异常，它也可以简单地将控制权转回到交互式解释器。然后程序员可以修复异常的原因，访问可用的重启列表，并立即继续运行程序。
- en: How It Kills Bugs
  id: totrans-1160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何杀死错误
- en: By using restarts and the Lisp REPL, a bug can be fixed in a running program,
    allowing you to “hot script” long-running applications with only a negligible
    interruption.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用重启和 Lisp REPL，可以在运行中的程序中修复错误，允许你以几乎可以忽略不计的中断来“热脚本”长时间运行的应用程序。
- en: Example A-3. Example
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-3. 示例
- en: '[PRE182]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Explanation
  id: totrans-1164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This is an implementation of a function that raises prices on a list of widgets.
    The actual work of raising the price of a single widget is done by the `raise-price`
    function ![](httpatomoreillycomsourcenostarchimages783564.png). The call to this
    function is protected by wrapping it in a `loop` and the `restart-case` command,
    which declares a restart called `try-again` ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the price can be raised without problems, the `raise-price` function will complete
    normally, the loop is interrupted with a `return` ![](httpatomoreillycomsourcenostarchimages783562.png),
    and the next item in the list of widgets is processed. On the other hand, if an
    error occurs while raising the price on a widget, another function (or the programmer)
    can attempt to fix the problem and call the `try-again` restart to retry the widget
    at the point of failure ![](httpatomoreillycomsourcenostarchimages783560.png),
    which leads to another cycle through the `loop` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The function can then continue down the rest of the list, raising the prices on
    the remaining widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: By using restarts, your code can offer multiple alternative follow-up options
    for coping with an exception, so that even the most exceptional exceptions can
    be handled appropriately.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Common Lisp has one of the most advanced exception handling systems
    in existence, it is still difficult to handle every exception appropriately in
    your code. However, restarts give you the unique ability to fix a running program
    and allow it to continue operating, which is usually not possible in other languages.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: Restarts are discussed in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up
    a Notch with Functional Programming").
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782184.png.jpg)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
- en: Generic Setter Guild Supply Ship
  id: totrans-1171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To modify the value of a variable in Common Lisp, you use `setf`. However,
    this command also has an amazing special power: Instead of a variable name, you
    can pass it a complex Lisp expression that retrieves a value. It can then turn
    that expression “inside out” and use it to modify that value, rather than simply
    retrieve it. These types of expressions are called *generic setters*.'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779817.png)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
- en: Many commands besides `setf` also support generic setters. Using this feature,
    most types of data structures can get by without any specific “setting” functions
    of their own.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  id: totrans-1178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a complicated, nested data structure, it’s often easier to understand
    code that retrieves data from a specific location than it is to understand code
    that sets a value at the same location. If you want to set a value at a specific
    location in a complicated structure, you usually need to work backward through
    the structure to figure out how to change it. But with generic setters, you can
    let Lisp handle the hard code for you. Having simpler code is a great way to fight
    bugs.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Example A-4. Example
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Explanation
  id: totrans-1182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example creates a variable named `foo`, which holds a list of three items
    ![](httpatomoreillycomsourcenostarchimages783564.png). The second item in the
    list is an empty hash table. Then it adds a key named `my-key` with a value of
    `77` to the table inside `foo` all at once, by putting a complex expression into
    `setf` that “gets at” this location ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By mutating an existing data structure, generic setters cause a side effect,
    which violates one of the tenets of functional programming. This means they can’t
    be used when programming in a purely functional style.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: Generic setters are discussed in [Chapter 9](ch10.html "Chapter 9. Advanced
    Datatypes and Generic Programming").
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783056.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783102.png.jpg)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
- en: DSL Guild Hot Rods
  id: totrans-1188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Lisp has such a simple syntax (everything is delimited with parentheses),
    it is easy to use it to build your own custom programming language, designed for
    a specific domain. Such *domain-specific languages* (*DSLs*) tend to make heavy
    use of the Lisp macro system. They represent an extreme form of macro programming,
    transforming Lisp into a completely new programming language.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781109.png.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
- en: Explanation
  id: totrans-1194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of code that uses a DSL to build an HTML page. In this case,
    the page displays “Hello **World**” in a browser, with the second word rendered
    in bold. The `html` and `body` commands (macros created for the HTML library in
    [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros")) generate opening
    and closing tags that will contain the body of the page ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it calls the regular Lisp function `princ` to generate the text. The second
    word is wrapped in another custom DSL command, `bold` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which generates opening and closing bold tags around the specified text.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: Example A-5. Example
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Weakness
  id: totrans-1198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since DSLs are programming languages you create all by yourself, you can definitely
    shoot yourself in the foot if you aren’t careful. It’s easy to create code in
    a language that is impossible for others (and perhaps even you) to understand.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages") discusses DSLs,
    including the DSL that allows you to write HTML directly inside your Lisp code,
    as shown in this example.'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: CLOS Guild Battleship
  id: totrans-1201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-1204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Common Lisp has the most sophisticated object-oriented programming framework
    of any major programming language, called the *Common Lisp Object System* (*CLOS*).
    It is customizable at a fundamental level using the *Metaobject Protocol* (*MOP*).
    There’s really nothing like it anywhere else in programming. It lets you create
    incredibly complex software without losing control over the code.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782004.png.jpg)'
  id: totrans-1206
  prefs: []
  type: TYPE_IMG
- en: How It Kills Bugs
  id: totrans-1207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Object-oriented programing* (*OOP*) is a commonly used technique for keeping
    bugs under control. By writing code in an object-oriented style, you can *decouple*
    different parts of your code. When you decouple code, you break your code into
    logical components, which can be tested independently.'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: 'Example A-6. Example 1: Wrapping Code Around Methods'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The basic concepts behind object-oriented programming in Common Lisp are discussed
    in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic Programming").
    For detailed information on the design of CLOS, I recommend reading the CLOS papers
    compiled at [http://www.dreamsongs.com/CLOS.html](http://www.dreamsongs.com/CLOS.html).
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-1212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, imagine we run a company that sells widgets, and we need some
    object-oriented Lisp code to help keep track of them. First, we need to create
    a new CLOS class (called `widget`) with `defclass` ![](httpatomoreillycomsourcenostarchimages783564.png).
    It has one property (or *slot*, in Lisp lingo) describing the widget’s color.
    Next, we declare a `describe-widget`, which prints out a description of the widget
    ![](httpatomoreillycomsourcenostarchimages783562.png). By convention, a function
    designed to operate on a specific type of object is called a *method*. In this
    case, the `describe-widget` is considered a method of the `widget` object.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we want to write an entry to a log file every time a user checks
    on a widget. Using the CLOS, we can declare one or more *before methods* that
    will automatically be called before the main `describe-widget` method is executed
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn’t have before methods available, we would need to dirty up our main
    widget code to add logging, like so:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Here, we’ve added the command for logging ![](httpatomoreillycomsourcenostarchimages783562.png)
    right in the middle of the `describe-widget` method ![](httpatomoreillycomsourcenostarchimages783564.png).
    This code is a lot uglier, because writing to logs has nothing intrinsically to
    do with describing a widget. The logging in this version is also tightly coupled
    to the main code, which means we can no longer test the widget code independently
    from the debugging code. Using the before method leads to cleaner, more decoupled
    code.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-1218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example demontrates *multiple dispatch*, a powerful technique for writing
    methods that are chosen based on the types of their parameters.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: 'Example A-7. Example 2: Multiple Dispatch'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The example begins by creating a `color` class ![](httpatomoreillycomsourcenostarchimages783564.png)
    and also defines three derived classes: `red`, `green`, and `blue` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we declare a `mix` method, which will tell us what happens if we mix any
    two colors. By default, when we mix two colors, it just says, “I don’t know what
    color that makes” ![](httpatomoreillycomsourcenostarchimages783560.png). However,
    using multiple dispatch, *we can define more versions* of the `mix` method. For
    instance, we can declare a version that mixes blue and yellow ![](httpatomoreillycomsourcenostarchimages783554.png),
    and another version for yellow and red ![](httpatomoreillycomsourcenostarchimages783510.png).
    Here’s what happens when we call these methods with different colors:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The important thing to note about the example is that in order to figure out
    which mix method to call in a given situation, the CLOS needs to take into account
    both of the objects passed into the method. It is *dispatching* to a specific
    implementation of the method based on the types of *multiple* objects. This is
    a feature that is not available in traditional object-oriented languages, such
    as Java or C++.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Opinions vary widely in the Lisp community as to how large a role object-oriented
    techniques should play in programming. The critics of this style complain that
    object-oriented techniques force data to be hidden away in lot of disparate places
    by requiring them to live inside many different objects. Having data located in
    disparate places can make programs difficult to understand, especially if that
    data changes over time. Therefore, many Lispers prefer to use functional techniques
    over object-oriented techniques, though the two can often be used together with
    some care. Nonetheless, there are still many domains in which object-oriented
    techniques are invaluable, such as in user interface programming or simulation
    programming.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780010.png.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
- en: The Continuation Guild Rocket Pods
  id: totrans-1228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: Scheme (limited support in Common Lisp with *continuation-passing style*, or
    through the use of special libraries)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783034.png)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  id: totrans-1232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the 1970s, a special dialect of Lisp was created that featured a particularly
    powerful programming feature called *continuations*. Basically, continuations
    let you put “time travel” into your code. This allows you to do things like run
    programs backward, sideways, or in other crazy ways. For instance, it’s great
    for implementing advanced programming techniques, such as *nondeterministic programming*.
    In nondeterministic programming, you write code that offers the computer multiple
    choices for what to do next. If one choice isn’t satisfactory, the computer can
    “roll back time” with continuations to try a different path.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: Example A-8. Example
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Note
  id: totrans-1236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Scheme Lisp dialect and won’t run in Common Lisp.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  id: totrans-1238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many situations where having time travel in your code can make the
    code easier to understand. The classic example is in a web server. Often, a person
    must visit several pages on a web page in order to perform a single action. With
    a continuation-aware web server, you can write code that pretends these pages
    were visited all at the same time, making your code a lot less buggy. Later on,
    the web server uses continuations to break your code into several parts (by using
    the time-travel abilities of continuations), taking care of all the ugly details
    of handling a multipage web action.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-1240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example, we create a simple function called `foo` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds one to a number, and then doubles it. For instance, running `(foo 7)`
    will return `16`. However, inside the function, there is a call to `call-with-current-continuation`
    ![](httpatomoreillycomsourcenostarchimages783562.png), which captures the state
    of the function before the doubling step. It saves this “moment in time” in the
    variable `continuation` ![](httpatomoreillycomsourcenostarchimages783560.png).
    The current state of the running program is captured at this line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Everything that happens *after* the continuation was captured will then be executed
    if we call the captured continuation. The only part of the `foo` command that
    happens after the continuation was captured is the multiplication by two ![](httpatomoreillycomsourcenostarchimages783554.png).
    Consequently, the variable `continuation` is now a time machine that we can use
    to jump into this past moment to switch out the number we want to double with
    another one. So, if we were to now call `(continuation 100)`, it would return
    200 (which is 100 doubled). We have traveled backward in time!
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuations are such an awesome feature that they don’t really have a downside.
    The only real problem they present is for creators of programming languages. True
    continuations are technically difficult to put into a programming language, so
    few languages support them. Scheme happens to be one of them. To learn more about
    continuation-based web servers, see “Implementation and Use of the PLT Scheme
    Web Server”by Shriram Krishnamurthi, et al.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782118.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782166.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781552.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781592.png.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
- en: Brevity Guild Micro Fighter
  id: totrans-1245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: Arc Lisp (indirectly available in Common Lisp using custom macros)
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779769.png.jpg)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  id: totrans-1249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lisp allows you to write code that is incredibly concise but doesn’t look like
    your cat walked over your keyboard. (I’m looking at you, Perl!) This is possible
    because of the various features we’ve already mentioned, such as macros, functional
    programming, and Lisp’s dynamic typing system.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one Lisp dialect, however, that takes this idea to the extreme: Arc.
    In fact, code brevity is the primary design goal for this language. Paul Graham,
    the designer of Arc, analyzed large amounts of computer code in an attempt to
    figure out which primitive commands are needed to write code that is as concise
    as possible, while keeping the code readable.'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  id: totrans-1252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Arc, the goal is to write programs that are short. It is designed to let
    you say what you want to say in the most concise way possible, leaving no place
    for bugs to hide.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: Example A-9. Example
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Arc Lisp dialect and won’t run in Common Lisp.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-1258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example creates a list of all prime numbers between 1 and 1000, using the
    naïve method of checking for smaller numbers that divide evenly into the current
    loop value.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: The `accum` function creates a local function named `a`, which is used to collect
    any primes that are found ![](httpatomoreillycomsourcenostarchimages783564.png).
    We iterate through the integers with a `for` loop ![](httpatomoreillycomsourcenostarchimages783562.png),
    checking for smaller numbers that divide evenly into the current value of `i`
    ![](httpatomoreillycomsourcenostarchimages783560.png). If none are are found,
    `i` is added to the list of primes ![](httpatomoreillycomsourcenostarchimages783554.png),
    by calling the function `a` with this new number. The brackets, `[ ]`, are a shortcut
    for creating a lambda function with one parameter, which is accessed with the
    underscore character.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding an optimally concise set of commands is difficult. With too many commands
    available, your code can become hard to understand, since it’s difficult to remember
    what each function does. With too few commands, programs can get too bulky. Arc
    Lisp tries to find a happy medium, although there’s still room for alternative
    language designs optimized for code brevity.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros") demonstrates
    how to use macros to make your code concise, and many other examples of Lisp’s
    powers of brevity are shown in the chapters following that discussion.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781032.png.jpg)'
  id: totrans-1264
  prefs: []
  type: TYPE_IMG
- en: Multicore Guild Formation Fighters
  id: totrans-1265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: Clojure Lisp (available in Common Lisp with the CL-STM extension)
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783054.png)'
  id: totrans-1268
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  id: totrans-1269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that most computers have multiple cores, there is a lot of interest in finding
    elegant ways to write multicore/multithreaded code. One popular approach is to
    use functional data structures along with a *software transactional memory* system.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: Using software transactional memory, you can share complex data structures between
    several threads, with a guarantee that no thread will see inconsistent information
    in the data, even if it tries to read shared data while another thread is attempting
    to write to it.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: How It Fights Bugs
  id: totrans-1272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multithreaded code tends to be very buggy. By using software transactional memory,
    you can greatly increase your odds of writing bug-free multithreaded software.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-1274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we define two bank accounts called `checking` and `savings`
    ![](httpatomoreillycomsourcenostarchimages783564.png), with a total amount of
    $300 between them. We then define a `transfer-to-savings` function, which can
    be called to move money from the `checking` account to the `savings` account ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Example A-10. Example
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Because this function contains a `dosync` block, Clojure will make sure these
    two `alter` operations ![](httpatomoreillycomsourcenostarchimages783560.png) happen
    at the same moment in time. Of course, both values aren’t really altered at the
    exact same point in time, but the language makes sure it will appear to happen
    simultaneously. If another thread were to read these two accounts at the same
    time, also within a `dosync` block, it would see exactly $300 in the combined
    accounts, no matter how many times either thread checks these values.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  id: totrans-1281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software transactional memory carries a performance penalty that cancels out
    some of the performance gains that come with using multiple CPU cores. However,
    as the number of CPU cores increases, this penalty is less of an issue.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: The Lazy Guild Frigate
  id: totrans-1283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lisp Dialect
  id: totrans-1284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure (available in Common Lisp with the Series library, CLAZY library, or
    custom macros)
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783350.png.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783350.png.jpg)'
- en: Synopsis
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: A lazy programming language will perform a calculation *only* if the compiler
    determines it is absolutely necessary to produce a visible result. Clojure is
    the most popular Lisp dialect to include lazy programming as a primary feature.
    However, limited forms of lazy programming are common in all Lisp dialects.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 懒编程语言仅在编译器确定它绝对必要以产生可见结果时才会执行计算。Clojure是最受欢迎的包含懒编程作为主要特性的Lisp方言。然而，所有Lisp方言中都有懒编程的有限形式。
- en: How It Kills Bugs
  id: totrans-1289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何杀死错误
- en: Lazy languages let you create infinitely big data structures (as long as you
    don’t try to use *all* of the data), which allows more of your code to be formulated
    as transformations of large data structures. In general, it is easier to debug
    data structures than it is to debug algorithms. Algorithms involve steps that
    unfold over time, and to understand them, you usually need to watch them as they
    execute. Data, on the other hand, exists independently of time, which means you
    can find bugs in a data structure just by looking at it.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的语言允许你创建无限大的数据结构（只要你不尝试使用*所有*的数据），这使得更多的代码可以表述为大型数据结构的转换。一般来说，调试数据结构比调试算法更容易。算法涉及随时间展开的步骤，要理解它们，你通常需要观察它们执行的过程。另一方面，数据独立于时间存在，这意味着你只需查看数据结构就能找到其中的错误。
- en: Example A-11. Example
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-11. 示例
- en: '[PRE192]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Note
  id: totrans-1293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用Clojure Lisp方言，无法在Common Lisp中运行。
- en: Explanation
  id: totrans-1295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This code returns the first 20 even positive integers. To do this, it first
    creates an infinite list of all positive integers ![](httpatomoreillycomsourcenostarchimages783560.png),
    using the `iterate` function to create a list of integers starting at zero. Then
    it filters out the even numbers ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it takes the first 20 numbers from that result ![](httpatomoreillycomsourcenostarchimages783564.png).
    Until the final `take` command, the data structures being operated on are theoretically
    infinite. However, since Clojure is a lazy language, it instantiates these data
    structures only on an as-needed basis. This means that only the first 20 such
    numbers are ever generated. (And even then, they are generated only if we actually
    use the final value somehow, such as printing it to the screen.)
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回前20个正偶数。为此，它首先使用`iterate`函数创建一个从零开始的整数列表，形成一个无限大的正整数列表 ![](httpatomoreillycomsourcenostarchimages783560.png)。然后它过滤出偶数
    ![](httpatomoreillycomsourcenostarchimages783562.png)。最后，它从该结果中取出前20个数字 ![](httpatomoreillycomsourcenostarchimages783564.png)。直到最后的`take`命令，正在操作的数据结构在理论上是无尽的。然而，由于Clojure是一种懒语言，它仅在需要时实例化这些数据结构。这意味着只有前20个这样的数字会被生成。（即使如此，只有在实际使用最终值的情况下，例如将其打印到屏幕上，它们才会被生成。）
- en: Weakness
  id: totrans-1297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Since a lazy programming language chooses the order in which your code is run,
    it can lead to debugging headaches if you try to trace your code as it is running.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于懒编程语言选择代码运行的顺序，如果你尝试跟踪代码的执行过程，可能会导致调试困难。
- en: '[Chapter 18](ch20.html "Chapter 18. Lazy Programming") discusses lazy programming.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch20.html "第18章。懒编程") 讨论了懒编程。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782876.png.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782876.png.jpg)'
