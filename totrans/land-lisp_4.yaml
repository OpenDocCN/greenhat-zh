- en: Part IV. Lisp is Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781390.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 14. Ramping Lisp Up a Notch with Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen in the preceding chapters, Lisp makes it pretty easy to throw
    together some quick code and build some simple games in no time. However, Lisp’s
    main claim to fame is as an academic tool, appropriate for tackling the most complicated
    scientific problems. The fact that it’s also great for hacking is arguably just
    a side benefit.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book, we’re going to focus on the scientific side of the
    language, exploring some advanced techniques to build a more sophisticated game
    that I hope will really blow your mind. It will do things you may never have thought
    would be possible in a computer program.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’re going to learn about the first advanced Lisp concept,
    called the *functional programming technique*. In the next chapter, we’ll use
    this technique to build a simple dice wars game, as well as a crude artificially
    intelligent opponent to play against!
  prefs: []
  type: TYPE_NORMAL
- en: What Is Functional Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already discussed the concept of functional programming a bit in earlier
    chapters. The glib answer is that functional programming is “a style of programming
    where we write all of our code using functions.”
  prefs: []
  type: TYPE_NORMAL
- en: However, we mean something very specific when using the term *function* in this
    context—exactly the same thing that mathematicians mean when they use the word
    *function*. So, what do mathematicians mean when they use this word?
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably already know the answer. Try to remember way, way back when you
    took pre-algebra. If you didn’t fall asleep during that particular lesson, you
    might remember your teacher drawing something like this on the chalkboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782772.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This picture shows that a function has arguments that may go into it, called
    the *domain* of the function. The function then takes these arguments and returns
    a value. This value is said to fall within the *range* of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some advanced Lispers will cringe when someone says that a function “returns
    a value.” This is because Lisp derives from a something called the *lambda calculus*,
    which is a fundamental programming-like algebra developed back in the 1930s by
    Alonzo Church. In the lambda calculus, you “run” a program by performing substitution
    rules on the starting program to determine the result of a function. Hence, the
    result of a set of functions just sort of magically appears by performing substitutions;
    never does a function consciously “decide” to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, Lisp purists prefer to say that a function “evaluates to a
    result.” However, almost everyone else in the programming world likes to say that
    functions return a value. It’s up to you to decide which way of thinking about
    functions feels the most natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important properties of mathematical functions that we’ll want
    our Lisp functions to obey as well:'
  prefs: []
  type: TYPE_NORMAL
- en: The function always returns the same result, as long as the same arguments are
    passed into it. (This is often referred to as *referential transparency*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function never references variables that are defined outside the function,
    unless we are certain that these variables will remain constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No variables are modified (or *mutated*, as functional programmers like to say)
    by the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the function is to do nothing other than to return a result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function doesn’t do anything that is visible to the outside world, such
    as pop up a dialog box on the screen or make your computer go “Bing!”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function doesn’t take information from an outside source, such as the keyboard
    or the hard drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we obey these rules whenever possible, we can say that our code is written
    in the *functional style*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of a true mathematical function is the sine function. Similarly,
    the `sin` function in Lisp (which calculates the mathematical sine) is a great
    example of a Lisp function that obeys the rules of the functional style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `sin` function always returns the same result, as long as you always pass
    the same argument (in this case, `0.5`) into it. It doesn’t do anything to interact
    with the outside world. Its entire purpose in life is to return the sine as a
    value. It obeys all the rules in the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, it would be impossible to write *all* the code in a computer program
    in the functional style. For instance, one of the rules stipulates that the computer
    isn’t allowed to go “Bing!”—who would want to use a computer if it didn’t go “Bing!”
    once in a while?
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781022.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever a piece of code does something that is visible to the outside world,
    such as go “Bing!” or display a dialog box on the screen, we say that the code
    *causes a side effect*. Functional programmers think of such side effects as making
    your code “dirty.”
  prefs: []
  type: TYPE_NORMAL
- en: The technical term for such dirty code that contains side effects is *imperative
    code*. The term *imperative* implies that the code is written in a “cookbook”
    style, where you basically say things like “first do this, and then do that.”
    Like a cookbook, most lines in imperative code perform side effects, such as writing
    to the screen or modifying a global variable. Imperative code is the opposite
    of functional code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the central philosophy of functional programming. It states
    that you should break your program into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, and biggest part, should be completely functional and free of side
    effects. This is the clean part of your program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second, smaller part of your program is the part that has all the side effects,
    interacting with the user and the rest of the outside world. This code is dirty
    and should be kept as small as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a piece of code pops up a dialog box, for example, we deem it dirty and banish
    it to the imperative section of our code. Things like dialog boxes are not really
    math, and we shouldn’t let them play with our math functions and other clean,
    functional code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781918.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Anatomy of a Program Written in the Functional Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve discussed how functional programming is done, let’s write a simple
    program that follows this style. Since we want this program to be a typical example
    of most software, we should figure out what most software in the world actually
    does. So what do most programs in the world actually do? They keep track of widgets!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781308.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s our entire example program, written in the functional style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As promised, it is split into two parts: the *clean part* and the *dirty part*.
    I did say that the clean part of the program should be much bigger than the dirty
    part. However, since this example is so short, the dirty part ended up a bit bigger.
    Usually, you can expect the clean part to be around 80 percent of the actual code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some programming languages are even more focused on functional programming than
    Lisp is. Haskell, for instance, has powerful features that let you write 99.9
    percent of your code in a functional style. In the end, however, your program
    will still need to have some kind of side effect; otherwise, your code couldn’t
    accomplish anything useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does our example program do? Well, it basically does what most computer
    programs in the world are designed to do: It keeps track of widgets in a database!'
  prefs: []
  type: TYPE_NORMAL
- en: The database in this example is very primitive. It’s just a Lisp list, stored
    in the global variable `*database*`. Since the database is going to start off
    empty, we initialize this variable and set it to be empty ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: We can call the function `main-loop` to start tracking some widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
    This function just starts an infinite loop, asking the user for a widget name
    ![](httpatomoreillycomsourcenostarchimages783510.png). Then, after it reads in
    the widget, it calls the `add-widget` function to add the new widget to the database
    ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: However, the `add-widget` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    is in the clean part of the code. That means it’s functional and isn’t allowed
    to modify the `*database*` variable directly. Like all functional code, the `add-widget`
    function is allowed to do nothing more than return a new value. This means that
    the only way it can “add” a widget to a database is to return a brand-new database!
    It does this by simply taking the database passed to it and then consing the widget
    to the database to create a new database ![](httpatomoreillycomsourcenostarchimages783562.png).
    The new database is identical to the previous one, except that it now contains
    a new widget at the front of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of how crazy this sounds on the face of it. Imagine that we’re running
    an Oracle database server, containing millions of widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782052.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, when we add a new widget, the database server accomplishes this by creating
    a brand-new replica of the previous database, which differs only in that a single
    new item has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781440.png)'
  prefs: []
  type: TYPE_IMG
- en: This would be horribly inefficient. However, in our widgets example, things
    are not as bad as they may first appear. It is true that the `add-widgets` function
    creates a new list of widgets every time it is called, and that repeated calls
    to this function would make the list longer and longer. However, since every new
    widget is simply added to the front of the list, it turns out that the tail end
    of the widget list is identical to the previous version of the list. Hence, the
    `add-widget` function can “cheat” whenever it creates a new list, by simply consing
    a single new widget to the front of the list, and then repurposing the old list
    as a tail to hold the rest of the items ![](httpatomoreillycomsourcenostarchimages783562.png).
    This allows the new list to be created in a way that is fast and also requires
    very little new memory to be allocated. In fact, the only new memory allocated
    by `add-widget` is a single new cons cell to link the new widget to the previous
    list.
  prefs: []
  type: TYPE_NORMAL
- en: This type of cheating when creating new data structures is a key technique that
    makes efficient functional programming possible. Furthermore, sharing of structures
    can be done safely, since one of the tenets of functional programming is to never
    modify old pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So our `add-widget` function creates a new database for us with the additional
    item added to it. The `main-loop` function, in the dirty part of the code, sets
    the global `*database*` variable equal to this new database. In this way, we have
    indirectly modified the database in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `add-widget` function, which is basically the brains of this program, generated
    an updated database for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `main-loop` function, which was in charge of the dirty work, modified the
    global `*database*` variable to complete the operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This example program illustrates the basic layout of a Lisp program written
    in the functional style. Let’s try out our new program to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you can hit ctrl-C to exit the infinite loop in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common stumbling block for programmers learning to write programs in the
    functional style is that they find it hard to combine different chunks of code
    to perform a single action. This is called *code composition*. A programming language
    should make code composition easy. In other words, it should make it easy for
    you to take different pieces of code and use them together to solve a task. The
    most powerful tool for code composition when writing functional code is *higher-order
    programming*, which lets you use functions that accept other functions as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to understand why code composition can be a challenge
    to a beginning functional programmer. Suppose we want to add two to every number
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To do this, we will need to write code to traverse the list, as well as write
    code to add two to a number. These are the two tasks we need to compose.
  prefs: []
  type: TYPE_NORMAL
- en: Code Composition with Imperative Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One possible naïve (and imperative) way to perform this task is to use a `loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re creating a variable `n` that counts through all the items in the
    list in a `loop` ![](httpatomoreillycomsourcenostarchimages783564.png). We then
    use `setf` to add two to the number at the location `n` in the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is similar to the sort of code you might write if you were a C programmer.
    Although it’s pretty ugly, there are positive things that can be said about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Code structured like this is potentially very efficient. It’s space-efficient,
    since we don’t need to allocate any memory for storing a new list (we’re just
    munging the old list to increase all the numbers in it by two). And it could also
    be very time-efficient, if we rewrote this loop to work on an array instead of
    a list. (Remember that finding the *n*th item in a list is slow.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code written like this clearly composes the task of looping ![](httpatomoreillycomsourcenostarchimages783564.png)
    and the task of adding two to a number ![](httpatomoreillycomsourcenostarchimages783562.png).
    By putting our code for the addition inside the loop, we are composing these two
    activities to complete a more complicated goal: adding two to an entire list of
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are obvious downsides to the imperative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It destroys the original list. This is a problem if we use the `*my-list*` variable
    later, and miss the fact that this code has messed up the original values in this
    list. A Lisper would say that allowing the `*my-list*` variable to be modified
    willy-nilly makes this variable a piece of *hidden state* in the program. Bugs
    related to hidden state are common in programming languages that encourage imperative-style
    programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We needed to create a variable `n` ![](httpatomoreillycomsourcenostarchimages783564.png)
    to keep track of our position in the list. This makes the code more bulky and
    also adds more places where bugs could lurk. There’s always a risk that we give
    `n` a wrong value or use it incorrectly to access items from the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Functional Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s see what happens if we rewrite this code in a functional style. Let’s
    first write it as a beginning functional programmer might, without using higher-order
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re creating a function `add-two` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds two to the number at the front of the list and then calls itself recursively
    to build the tail of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code avoids many of the downsides from the imperative solution. It does
    not destroy the original list, and it does not require us to use a numeric index.
    Unfortunately, it also lacks one of the critical benefits of the imperative version:
    There is no longer a clear delineation between the code that adds two to items
    in the list and the code that traverses the list. These two activities are now
    deeply intertwined, which is the reason we needed to create a special function,
    `add-two`, to make this solution work. We have lost our ability to compose these
    two tasks in a clean way.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming to the Rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to write code for this task in a functional style, but still allow
    our code to be composable, we’ll need to make use of higher-order functions. Here
    is how an experienced Lisper would add two to every number in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we finally have a version of the code that is functional *and* allows us
    to compose the traversal code and the addition code. Here, the traversal is performed
    by the `mapcar` function, which is a higher-order function since it applies a
    supplied function to every member in a list. The addition is performed by a lambda
    function, which is responsible only for adding two to a number, and is oblivious
    to the fact that the numbers are in a list. This example shows that higher-order
    programming can let us write clearly delineated chunks of code and then compose
    them, without needing to break from the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Why Functional Programming Is Crazy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know one reason why functional programming is crazy: Functional
    programs can’t really do anything, since they can’t have *side effects*. As Simon
    Peyton Jones, a well-known functional programmer, likes to say, “All you can do
    without side effects is push a button and watch the box get hot for a while.”
    (Which isn’t technically true, since even the box getting hot is a side effect.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen that we can work around this limitation of functional programming
    by adding a dirty section to our programs, which is kept separate from the rest
    of the code and contains all our code that is imperative and not in the functional
    style. However, recall the problem with the functional style: It can cause code
    to be extremely inefficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance has always been a huge concern with functional programs. Having
    to write code that isn’t allowed to mutate the value of existing variables, but
    only create new variables, can lead to a huge amount of memory copying and memory
    allocation, which can slow programs down to a crawl. One way to mitigate this
    copying and allocation is by using shared structures between different pieces
    of data in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, code written in the functional style has other properties that
    affect performance. For instance, functional code uses a lot of recursion, instead
    of looping. Using recursion causes the Lisp compiler/interpreter to put a lot
    of items on the program stack, which can be very slow.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, functional programmers have developed optimization techniques that
    can solve the vast majority of performance problems. These include memoization,
    tail call optimization, lazy evaluation, and higher-order programming, which we’ll
    cover in the next few chapters. Using these techniques and others, an experienced
    functional programmer can write code that is usually comparable in performance
    to code written in any other style.
  prefs: []
  type: TYPE_NORMAL
- en: However, some types of programs just can’t be written in a purely functional
    way. For instance, you probably wouldn’t write something like a full-on Oracle-style
    relational database system in a functional style. Yet, smaller, memory-resident
    database systems may be able to use purely functional techniques (an example is
    the HAppS-IxSet available to Haskell programmers at [http://happs.org/](http://happs.org/)).
    So there is really no hard limit as to when functional programming can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Why Functional Programming Is Fantastic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that I’ve told you about all the headaches a functional programmer must
    endure, you may be wondering, “Why would anyone bother to program this way?” The
    answer is that functional programming has many enticing benefits that make up
    for these headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming Reduces Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bugs in computer programs usually happen because, under certain circumstances,
    the code behaves in ways the programmer didn’t expect when the code was written.
    In functional programming, the behavior of your functions depends on one and only
    one thing: the arguments explicitly passed into the function. This makes it much
    easier for a programmer to appreciate all the circumstances a program could possibly
    encounter, including circumstances that could lead to errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions that depend on only their arguments for their behavior also
    makes bugs easy to duplicate. If you call a function with the same data passed
    in through its arguments, it should do the same exact thing every time. This is
    the property we called *referential transparency*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programs Are More Compact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out a lot of the work in run-of-the-mill computer programs involves
    creating, initializing, and updating variables. Functional programs don’t do any
    of this. As we discussed earlier, functional programs make use of higher-order
    functions, which don’t require us to create tons of temporary variables in our
    code, and that makes our code more compact.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Code Is More Elegant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest advantage of functional programming is that it brings all of computer
    programming back to the domain of mathematics. It wouldn’t make sense for a math
    equation to pop up a dialog box or write to the hard drive. It can be argued that
    if we get our computer code back to this same level of purity, it will be far
    more elegant. Additionally, if our code is closer to the world of mathematics,
    we may be able to use tools in mathematics to write better computer code.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a lot of research continues to be done in using mathematical proofs
    to check for the correctness of functional computer programs. Although this research
    still isn’t to the point where a practical programmer would use such techniques,
    they may be more common in the future. And, almost certainly, a functional programming
    style will be essential in making correctness proofs on your code possible.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed functional programming. Along the way, you learned
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Programs written in the *functional style* always give the same result when
    they are given the same values in their arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs do not contain *side effects*. Their whole purpose in life
    is to just calculate a value to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that are not functional usually read like a cookbook, with statements
    like, “First do this, and then do that.” This style of programming is called *imperative
    programming*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good strategy for writing Lisp programs is to break them into a clean, functional
    part and a dirty, imperative part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs can be written quickly, are more compact, and tend to have
    fewer bugs, particularly in the hands of an experienced functional programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 15. Dice of Doom, a Game Written in the Functional Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’re finally ready to create a more sophisticated (and fun) computer program
    in the functional style. As we expand this program throughout the rest of this
    book, you’ll learn about techniques for writing elegant functional code, while
    at the same time maintaining strong performance in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782714.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Rules of Dice of Doom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dice of Doom is a game in the same family as Risk, Dice Wars ([http://www.gamedesign.jp/flash/dice/dice.html](http://www.gamedesign.jp/flash/dice/dice.html)),
    and KDice ([http://kdice.com/](http://kdice.com/)). In the beginning, we’re going
    to keep the rules of Dice of Doom mind-numbingly simple. In later chapters, we’ll
    expand the rules, until eventually we’ll have a game very similar to Dice Wars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the simplified rules we’ll start with:'
  prefs: []
  type: TYPE_NORMAL
- en: Two players (named A and B) occupy spaces on a hexagonal grid. Each hexagon
    in the grid will have some six-sided dice on it, owned by the occupant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During a turn, a player can perform any number of moves, but must perform at
    least one move. If the player cannot move, the game ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move consists of attacking a neighboring hexagon owned by the opponent. The
    player must have more dice in her hexagon than the neighboring hexagon in order
    to attack. For now, all attacks will automatically lead to a win. In future variants,
    we’ll actually roll the dice for a battle. But for now, the player with more dice
    just wins automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After winning a battle, the losing player’s dice are removed from the board,
    and all but one of the winning player’s dice are moved onto the newly won hexagon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a player is finished making her moves, reinforcements are added to that
    player’s dice armies. Reinforcements to the player’s occupied hexagons are added
    one die at a time, starting from the upper-left corner, moving across and down.
    The maximum number of dice added as reinforcements is one less than the player
    took from the opponent in her completed turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a player can no longer take her turn, the game has ended. The player who
    occupies the most hexagons at this point is the winner. (A tie is also possible.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sample Game of Dice of Doom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our implementation of Dice of Doom will include an AI player, we’re going
    to start with an extremely humble size for our game board. As you probably know,
    AI code can be very computationally intensive. In our early, very naive version
    of this game, any board larger than a 2-by-2 grid of hexagons would bring CLISP
    to its knees!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a complete game, played on a puny 2-by-2 board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783538.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the beginning of the game, player A (indicated with black hexagons) possesses
    the top two hexagons, with three dice on each. Player B occupies the bottom row
    (indicated by the white hexagons), with three dice and one die, respectively.
    Player A attacks the lone die with one of his piles. After the attack, one of
    player A’s dice remains behind, while the others move to the conquered spot. Then
    player A passes the turn.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782970.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Player B now attacks player A’s two dice with a pile of three. Player B then
    passes. At this point, player B receives a single reinforcement die on her left
    hexagon. This is because she killed two of player A’s dice. The reinforcements,
    as per the rules, consist of the number of dice killed, minus one.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782752.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Player A now attacks with three of his dice and passes. Also, he gets a reinforcement
    die.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782186.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Player B now has only one legal move, attacking two against one.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781602.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Player A now has the upper hand, killing all of player B’s remaining dice. As
    you can see, player A is permitted to perform multiple attacks on his turn before
    passing. The game has ended with player A as the winner.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dice of Doom, Version 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start coding this game in Lisp. As we discussed in the previous chapter,
    this game will contain both clean, functional code and dirty, imperative code.
    You’ll be able to tell in which category a block of code fits by the “clean/functional”
    or “dirty/imperative” icon next to it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Some Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll create some global variables that define the basic parameters
    for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’re stating that there will be two players ![](httpatomoreillycomsourcenostarchimages783564.png),
    that the maximum number of dice on a square is three ![](httpatomoreillycomsourcenostarchimages783562.png),
    and that the board will be 2-by-2 ![](httpatomoreillycomsourcenostarchimages783560.png).
    In later versions of Dice of Doom, we’ll increase all of these parameters, to
    allow for a more challenging game.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s useful to know the total number or hexagons there are at the current
    board size, we also define `*board-hexnum*` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Note that even though the grid is made of hexagons, it is still basically a square
    grid, since the number of hexagons just equals the square of the side of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, every code sample has an associated icon to indicate whether
    it is made of dirty, imperative or clean, functional code. By the end of this
    chapter, you should be able to easily tell the difference and have some appreciation
    for the benefits of each style.
  prefs: []
  type: TYPE_NORMAL
- en: Representing the Game Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to represent the game board using a simple list. The hexagons will
    be stored in this list, starting at the top left, and then moving across and down.
    For each hexagon, we’ll store a list of two items: a number indicating the current
    occupant of the hexagon and another number indicating the number of dice at that
    location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here is an example of a game board and the list that encodes
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779855.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that most Lisp programmers like to count starting at zero. Therefore, players
    A and B are represented with the numbers 0 and 1\. This list indicates that player
    A has three dice on the first hexagon and three on the second. Player B has three
    dice on the third hexagon and one on the fourth.
  prefs: []
  type: TYPE_NORMAL
- en: When we create our AI player, it will need to be able to look at many hexagons
    on the board very quickly. Because of this, we’re going to create a second representation
    of our board in the form of an array. Remember that checking a numeric location
    (for instance, hexagon 2) in a list requires the `nth` function, which is potentially
    slow. Arrays, on the other hand, will allow for very fast lookup at a specific
    location, even with very large board sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `board-array` function converts a board represented with a list to an array
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game begins, we’ll start with a randomized board. Here’s the function
    that creates a random board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function is not in the functional style (as the icon indicates), since
    it will create a different, random result every time it is called. It generates
    the board as a list, but then converts the list to our speedier array format when
    it’s done, using `board-array` ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: It generates random values using the Lisp function `random`. This function produces
    a different random integer every time, greater than or equal to zero, but smaller
    than the number passed to it. We use our `*num-players*` and `*max-dice*` global
    variables to generate random values for each hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out the `gen-board` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the hash mark (#) indicates that we’ve created an array, not a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name our players using letters (just A and B, until we start introducing
    more players). Here’s a function that converts a player number into a letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `code-char` function converts an ASCII code into the appropriate character.
    Let’s call it for player 1 to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s create a function that will take an encoded board and draw it
    in a pretty way on the screen. It will tilt the board in the same way as our drawings,
    so it’s obvious which six hexagons neighbor any given hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the whole purpose of this `draw-board` function is to write stuff to the
    console, it’s definitely not functional. Let’s look at this function more closely.
  prefs: []
  type: TYPE_NORMAL
- en: The outer `loop` runs through all the rows of the board, stored in the variable
    `y` ![](httpatomoreillycomsourcenostarchimages783564.png). There are two inner
    `loop`s. The first inner `loop` adds the indentation to the left side to give
    the board that tilted look ![](httpatomoreillycomsourcenostarchimages783562.png).
    The second inner `loop` loops through the columns, stored in the variable `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png). It then uses `x` and `y`
    to calculate the appropriate hex number, and retrieves that hex from the board
    array using `aref` ![](httpatomoreillycomsourcenostarchimages783554.png). Finally,
    it prints the data in the hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of the `draw-board` function, as well as a drawing to compare
    it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781087.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Decoupling Dice of Doom's Rules from the Rest of the Game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to write the code that takes care of the guts of our first
    Dice of Doom implementation. In writing this code, we’re going to employ a powerful
    functional programming technique: a *function pipeline*. This means that our game
    is going to consist of a succession of functions that operate, one after another,
    on a big chunk of data, which will hold a representation of our game board, making
    modifications to the structure along the way. A function pipeline will allow us
    to build a game rule engine that’s *100% decoupled from the rest of the game code*.
    To understand why this is so cool, let’s first consider some of what’s involved
    in writing a board game with a smart AI player.'
  prefs: []
  type: TYPE_NORMAL
- en: For one thing, any computer implementation of a board game will need code that
    handles the human player’s moves. This part of the code will need to know the
    rules of the board game and make sure the human player’s move is legal before
    letting it happen.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need to write the AI code. And in order for the AI player to pick
    a move, it needs to know all the rules of the board game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice something? Both of these separate parts of our game engine need to understand
    the rules of the game! Clearly, what we want to do is break our game code into
    three big pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: The handling of the human’s moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rule engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One piece handles the player’s moves. Another is the code for the AI player.
    Both of these then talk to some code that understand the rules, sort of a “rule
    engine.” Is this kind of design possible?
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional, imperative programming style, it would be very difficult to
    write a program like this. Most imperative game engines duplicate the code that
    “understands the rules,” because of the complexity of writing fully decoupled
    components in an imperative language. The reason for this is that a board game
    requires a lot of context—every move is dependent on what moves preceded it. This
    means that every time the AI module or player-handling module needs to check the
    rules, it must tell the “rule code” the current context in detail. Both would
    need to tell the rule code that “It’s player so-and-so’s turn and the game board
    looks like such-and-such.” Without this information, the rule code can’t tell
    whether or not a move is legal.
  prefs: []
  type: TYPE_NORMAL
- en: Passing around this context requires tons of tedious bookkeeping code everywhere,
    is error-prone, and is inefficient. It’s inefficient because, with a naive design,
    the player-handling code may check the legality of moves the AI code had already
    explored and found legal.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming, however, we can decouple these three concerns
    entirely in our program. We will be able to do this without bookkeeping code and
    in a way that avoids duplication any legality calculations. We will accomplish
    this by encoding our rule code in a lazy game tree!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic approach we’re using—programming a game in the functional style using
    a lazy game tree and a function pipeline—is described in the classic paper “Why
    Functional Programming Matters” by John Hughes ([http://www.scribd.com/doc/26902/whyfp/](http://www.scribd.com/doc/26902/whyfp/)).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll be creating a game tree that is not yet lazy. You’ll
    need to wait until [Chapter 18](ch20.html "Chapter 18. Lazy Programming") to understand
    lazy programming and what a lazy game tree will look like. That’s also when you’ll
    be able to fully appreciate how cool this architectural design really is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781119.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating a Game Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire rule set for our game is encoded in the following master function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `game-tree` function builds a tree of all possible moves, given a certain
    starting configuration. This function will be called only a single time at the
    beginning of the game. It will then recursively build a tree of all possible moves
    for the game, down to the final winning positions. The other parts of our game
    will then elegantly traverse this tree in order to conform to the rules of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to calculate the legal possible moves of the game tree from a given
    context, the function needs four pieces of data passed to it as arguments ![](httpatomoreillycomsourcenostarchimages783564.png):'
  prefs: []
  type: TYPE_NORMAL
- en: What the board looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many dice have been captured by the player in the player’s current turn,
    which is needed to calculate any future reinforcements, as per our rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the current move is the first move for the current player, because a
    player can’t pass a turn without first making at least one move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the `game-tree` function creates the tree, it will put information about
    the current board and current player at every branch ![](httpatomoreillycomsourcenostarchimages783562.png).
    The subbranches will then hold all the legal follow-up moves from the current
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783184.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two types of legal moves possible for players: attack a hexagon or
    pass their turn to the next player (assuming they’ve already attacked at least
    once already). The passing move is added to the list of legal moves through the
    `add-passing-move` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    The attacking moves are added to the list through the `attacking-moves` function
    ![](httpatomoreillycomsourcenostarchimages783554.png). Let’s look at these functions
    next.'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Passing Moves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that adds the passing moves to the game tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The job of this function is to add a passing move to the tally of moves, if
    passing is permitted. The current list of moves is passed in to this function
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then the function will
    return the expanded list of moves. If the move is the first move in a player’s
    turn ![](httpatomoreillycomsourcenostarchimages783562.png), no passing is allowed,
    and we just return the unaltered list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we add a new move to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every move in our game tree consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part is a description of the move. Since we’re just passing in this
    move, we’ll set the description to `nil` ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the move is an entirely new game tree, which holds the entire
    universe of moves that exists after this move has been performed. We create this
    by recursively calling `game-tree` again ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since this is the end of the player’s turn, the player may receive dice as reinforcements.
    So, we update the board sent to this new `game-tree` call with the `add-new-dice`
    function ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we also will need to change the current player, since a new person’s
    turn is now starting. We do this by adding one to the current player number and
    taking the modulus of the result, with the total number of players as the denominator
    ![](httpatomoreillycomsourcenostarchimages783544.png). Changing a player in this
    fancy way will allow the code to work, even when we increase the number of players
    in the game in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Attacking Moves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that adds the possible attacking moves to the game tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `attacking-moves` function is a bit more complicated than the `add-passing-move`
    function. It’s responsible for scanning the current game board and figuring out
    what moves the current player is legally allowed to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Since it must spend a lot of time figuring out who the player is on a given
    hexagon, we first write a convenience function called `player` that returns the
    player for a given board position ![](httpatomoreillycomsourcenostarchimages783564.png).
    We write a similar function to get the number of dice on a given hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to scan the board top to bottom and find out which squares the
    current player occupies. For each occupied square, there may be one or more legal
    attacks starting at that position. Since the number of attacks from any hexagon
    may vary, we use `mapcan` to scan the board ![](httpatomoreillycomsourcenostarchimages783560.png).
    Remember that `mapcan` lets each hexagon we scan return its results as a list.
    Then `mapcan` concatenates these lists together. This way, any scanned hexagon
    can contribute zero to *n* moves to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `lambda` function used by the `mapcan`, which gets called for every
    hexagon, we first want to check whether the current player occupies this hexagon
    ![](httpatomoreillycomsourcenostarchimages783554.png). Then we want to check all
    of its neighbors to see if any of them present a viable attack. We do this with
    another `mapcan` ![](httpatomoreillycomsourcenostarchimages783510.png). We’ll
    figure out the neighbors to this hexagon by using the `neighbors` function, which
    we’ll write shortly ![](httpatomoreillycomsourcenostarchimages783498.png).
  prefs: []
  type: TYPE_NORMAL
- en: How do we decide if a hexagon can be an attack destination? Well, it must be
    a hexagon we don’t already own, plus (as per the rules) the source hexagon needs
    to have more dice than the destination hexagon ![](httpatomoreillycomsourcenostarchimages783544.png).
    If we have found a legal attack move, we then describe the move ![](httpatomoreillycomsourcenostarchimages783556.png).
    The description is simply a list of the source position and the destination position.
    We then (as with passing moves) recursively generate another game tree that describes
    what happens if the move is executed ![](httpatomoreillycomsourcenostarchimages783566.png).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Neighbors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s create the function that calculates the neighboring hexagons to
    a given hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every hexagon on the board may have up to six neighbors, or fewer, if the hexagon
    is on an edge of the board. We build up a list of possible neighbors in a `loop`
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then collect the ones
    with position numbers that aren’t off the edge of the board ![](httpatomoreillycomsourcenostarchimages783554.png).
    Also, since our position numbers wrap from row to row, we need to make sure we
    don’t look to the left if we’re on the left edge of the board ![](httpatomoreillycomsourcenostarchimages783562.png)
    or look to the right if we’re on the right edge of the board ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: This function is marked clean (it is in the functional style), but nonetheless
    contains a loop. Usually, looping goes against the tenets of functional programming.
    However, many Lispers consider it kosher to use a `loop` in functional code if
    all it does is collect some values, since it really isn’t mutating any values
    or producing any other side effects. So, we will allow ourselves to use such loops
    in the functional-style part of this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our `neighbors` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781241.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it correctly tells us that hexagon 2 neighbors hexagons 0 and
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s write our `board-attack` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that figures out what happens if the hexagon `src` attacks
    the hexagon `dst`. It works by `loop`ing across the board, keeping track of the
    current position ![](httpatomoreillycomsourcenostarchimages783564.png) and the
    contents in the hexagon at that position ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the current hexagon is the source hexagon, we just place a single die in that
    place; as per our rules, a single die is left behind after an attack ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the current hexagon is the destination position, we place the remaining dice
    there, subtracting the one left behind ![](httpatomoreillycomsourcenostarchimages783554.png).
    In other cases, we just collect the very same hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our `board-attack` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782736.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, attacking from hexagon 1 to 3 causes `board-attack` to properly
    update the game board, so that one die remains on the old square and two are on
    the new, conquered square.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the functions in this chapter have inefficiencies to keep things simple.
    We’ll fix many of these in future versions of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the reinforcements to the board, we need to scan across the game board,
    find occupied spots that can accommodate another die, and add the die there. Of
    course, the number of reinforcements is limited based on how many opponent dice
    the player captured in the last turn. Because of this, we’ll need to keep a running
    tally of how many reinforcement dice remain.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious way to track the remaining dice would be to have a `remaining-dice`
    variable, and decrement this every time a die is placed. However, having a die
    that is decremented (mutated) would not be in line with the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, instead, we’re going to write our `add-new-dice` function using a
    local recursive function, which will also maintain this running count of dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is this `add-new-dice` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing `add-new-dice` does is define a local function named `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This function will be our list-eater that goes through the hexagons of the board
    and spits out a new list that includes the reinforcements. Since our board is
    actually stored in an array for efficiency reasons, we convert our array into
    a list with the `coerce` function before calling `f` ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function `f`, we must consider three situations:'
  prefs: []
  type: TYPE_NORMAL
- en: That we’re at the end of the board. In this case, the reinforced board will
    also be completed, so we just return `nil` ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That we’re out of `spare-dice` to add to add as reinforcements. In this case,
    the rest of the board will just be the same as before, so we can just return the
    remainder of the list as the new board ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of the preceding situations. In all other cases, we need to analyze
    the current hexagon and decide whether a reinforcement should be added in it.
    We check whether the current player occupies that hexagon and whether we have
    less than the maximum number of dice on that square ![](httpatomoreillycomsourcenostarchimages783554.png).
    If this is the case, we add a new die on the hexagon and call `f` against the
    rest of the board, recursively ![](httpatomoreillycomsourcenostarchimages783510.png).
    Otherwise, we leave the current hexagon unchanged and proceed by recursively calling
    `f` against the rest of the board ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let try adding reinforcements to a board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `add-new-dice` properly placed two reinforcement dice for player
    A (player 0).
  prefs: []
  type: TYPE_NORMAL
- en: Trying Out Our New game-tree Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now written all the code needed to create a comprehensive game tree
    of our simplified version of Dice of Doom. But be careful! A game tree of most
    board games is excruciatingly large. Even on a 2-by-2 board, our game may consist
    of hundreds of possible moves. You’ll want to call the `game-tree` function only
    on a game board that is near the end of play, or you’ll be watching helplessly
    as the CLISP REPL prints out a humongous tree showing all the possible ways in
    which a game may progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a safe board position for you to try out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783122.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The game tree first lists the current player number ![](httpatomoreillycomsourcenostarchimages783564.png),
    the layout of the board ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then the legal moves for that context. For the initial board position, at
    the beginning of player A’s turn, there is only one possible move: The player
    can move from hexagon 2 to hexagon 3, capturing player B’s die in that spot ![](httpatomoreillycomsourcenostarchimages783560.png).
    After that, the player can pass. Player B now has no move available. Since this
    player’s game tree has no available moves listed ![](httpatomoreillycomsourcenostarchimages783554.png),
    the game has ended, with a win for player A.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing Dice of Doom Against Another Human
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve completely captured the universe of Dice of Doom in our comprehensive
    `game-tree` function, it’s simple to create a human versus human version of this
    game. All we need to do is create some functions that travel down the game tree
    as players choose their moves.
  prefs: []
  type: TYPE_NORMAL
- en: The Main Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the function that travels down the game tree, allowing two humans to
    play Dice of Doom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function, `play-vs-human`, is the main loop of our game. It accepts a tree
    describing the starting position of the board.
  prefs: []
  type: TYPE_NORMAL
- en: First, it calls a function named `print-info`, which will draw the board on
    the screen, along with other helpful information about the current state of the
    game ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we need to check
    if any follow-up moves exist. These follow-up moves would be listed starting at
    the `caddr` position of the game tree ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: If follow-up moves are available, we call the function `handle-human`, which
    will interact with the current player to help him pick his new move. This `handle-human`
    function will then return the subbranch of the tree that represents the player’s
    choice. We can then recursively pass this subbranch into `play-vs-human` to proceed
    with the game ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: If no follow-up moves are available, the game has officially ended. We then
    call the `announce-winner` function, which, appropriately, will announce the winner
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Giving Information About the State of the Game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the print-info function, which describes the status of the current
    node in the game tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function displays two important pieces of information on the REPL. First,
    it shows who the current player is ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it prints out a pretty version of the game board with the `draw-board` function
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Handling Input from Human Players
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next is the function that lets humans choose their next move. It displays a
    very helpful, numbered menu of all currently available moves for the player to
    choose from.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To display the list of available moves, we use a `loop` that traverses all the
    available moves and prints a description about each one ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `loop` is not functional, since it prints stuff on the screen for the player
    to read. We print a counting number in front of each move ![](httpatomoreillycomsourcenostarchimages783560.png)
    using the variable n, which counts from 1 inside our `loop` ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Each move has an action value associated with it. If the action is non-nil ![](httpatomoreillycomsourcenostarchimages783554.png),
    then the action is an attack, where the action value describes the source and
    destination hexagons of the attack. We print such attacking action using the `format`
    command ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: We use an empty action value to represent the passing move. In that case, we
    just `princ` “end turn” to describe this move ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: After the available moves have been displayed, we use `read` to read in the
    player’s choice. With the `nth` function, we can then select that branch of the
    game tree and return it from our `handle-human` function ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Winner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The task of announcing the winner can be nicely broken into a *clean/functional*
    and a *dirty/imperative* part.
  prefs: []
  type: TYPE_NORMAL
- en: The clean part concerns the task of calculating the winning player. We want
    to calculate this in a way that can handle more than just two players, since our
    game will allow for more in the future. Also, the function must be cognizant of
    possible ties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we’ll write a function called `winners` that returns a
    list of one or more players who captured the maximum number of hexagons at the
    end of the game. If there is a tie, it will simply return all the players who
    share first place, in terms of the total count of occupied spaces for all players.
    With this design, the function will work for *any number of players* and will
    elegantly handle ties. This is what the `winners` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We calculate the winner for a given ending board position in four steps.
  prefs: []
  type: TYPE_NORMAL
- en: First, we build up a tally of who occupies each hexagon on the board ![](httpatomoreillycomsourcenostarchimages783564.png).
    With the `across loop` construct, we can traverse the array of the ending board
    directly and collect the occupier of each hexagon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we need to count the total number of squares each player has captured,
    using this tally. The totals variable will be an alist of player->spaces pairs.
    We build this alist by finding all players who have at least one entry in the
    tally with `remove-duplicates` ![](httpatomoreillycomsourcenostarchimages783560.png).
    We can map across this and then create a count for each occupier ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, we want to find what the maximum number of occupied hexagons for a single
    player is. We do this by stripping the counts from our alist by mapping `cdr`
    across the list ![](httpatomoreillycomsourcenostarchimages783554.png). We then
    apply `max` to this list to find the largest number of occupied spaces for a single
    player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need create a list of all the “best” players. We do this by stripping
    out all but the best from our totals using the `remove-if` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    We then just pull out the player numbers for the best players by mapping `car`
    across the list of bests ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s write the dirty `announce-winner` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function is rather simple. First, we calculate the winners by calling our
    earlier function ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    check if there is more than one winner ![](httpatomoreillycomsourcenostarchimages783562.png)
    (a tie). For ties, we print a special message ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we just announce a single winner ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Trying Out the Human vs. Human Version of Dice of Doom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have a completely playable game of dice of doom. Here is an example
    game from start to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Intelligent Computer Opponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed when we were designing the game tree code for Dice of Doom,
    having a separate game tree generator makes it easy to add an AI player to a game
    engine. In fact, we’re now going to add a computer player that can play an absolutely
    perfect game with only 23 additional lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does an AI player decide to make a move? We’ll use the following strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at each available move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a point rating to the board position resulting from each move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the move with the maximum point rating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This sounds like a simple plan, but there is one step in this algorithm that’s
    pretty tricky: calculating the best point rating for a given board position.'
  prefs: []
  type: TYPE_NORMAL
- en: If a move leads immediately to a win, it’s easy to give a point rating to that
    move—any winning move clearly deserves a very high point rating. However, most
    moves in a game cannot lead to an immediate win. In those cases, in order to determine
    if the result of a set of moves deserves a good point rating, we need to figure
    out what the opponent player will do in response.
  prefs: []
  type: TYPE_NORMAL
- en: But how will we know what the opponent player will decide to do? If we’re not
    careful, we’ll end up in an ugly impasse where we say, “He thinks that I think
    that he thinks that I think . . .” in order to calculate a meaningful point value
    for a given board position. How do we account for the opponent’s behavior without
    giving ourselves a headache?
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781316.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Minimax Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that for a two-player board game, a simple method exists to model
    what an opponent will do. We simply accept the truism “What is good for my opponent
    is bad for me.” This means we can use the following approach to model a move for
    the opponent:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at each available move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a point rating to the board position resulting from each move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the move with the minimum point rating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This algorithm for estimating what an opponent will do is identical to the one
    used for the primary player, except that in step 3, we pick the move with the
    *minimum* instead of *maximum* rating. The benefit of this approach, called the
    *minimax algorithm*, is that we use the same point ratings when working out the
    opponent’s moves that we use for the primary AI player, but then just tweak the
    third step a little to adjust.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is crucial: It turns out that if we can avoid calculating separate ratings
    for ourselves as for our opponent in the game, then searching down the game tree
    for good moves becomes dramatically easier and faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic minimax algorithm works only in two-player games. When three or more
    players are involved in a game, we can’t really say that “What is good for my
    opponent is bad for me” is completely true any more. This is because an additional
    truism becomes important: “The enemy of my enemy is my friend.” This means that
    some of my opponents may, at times, act as a friend by making moves that harm
    a common enemy, while not affecting me directly. We’ll discuss this issue more
    in [Chapter 20](ch22.html "Chapter 20. Making Dice of Doom More Fun").'
  prefs: []
  type: TYPE_NORMAL
- en: Turning Minimax into Actual Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to put the minimax idea into practice, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `rate-position` function generates a numeric point rating for a given branch
    of the game tree. In order to do this, we first need to figure out if there are
    any moves available from the given position ![](httpatomoreillycomsourcenostarchimages783564.png)
    (that is, the current move is not an ending move in the game).
  prefs: []
  type: TYPE_NORMAL
- en: If moves are available, we’ll need to look at all the subsequent moves to decide
    how to rate the current position. We accomplish this by calling `get-ratings`
    ![](httpatomoreillycomsourcenostarchimages783554.png), a function that will return
    the point rating of each follow-up move. As per minimax, we will then pick either
    the best (`max`) ![](httpatomoreillycomsourcenostarchimages783562.png) or worst
    (`min`) ![](httpatomoreillycomsourcenostarchimages783560.png) rating of all the
    follow-up moves, depending on whether the move being rated is for the AI player
    or its opponent.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, there are no follow-up moves, we’ll need to check who
    the winner is for the current board position ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the player isn’t among the winners of this position, we can give the position
    the minimum rating of `0` ![](httpatomoreillycomsourcenostarchimages783556.png).
    Otherwise, we’ll divide one by the number of winners to determine our rating ![](httpatomoreillycomsourcenostarchimages783544.png).
    By doing this, we also give a meaningful rating for ties. If the player is the
    sole winner, the rating, using this formula, will be the maximum value of `1`.
    For a two-player tie, the rating will be a sensible `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `get-ratings` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function simply maps `rate-position` across each available follow-up move
    for the given branch of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Game Loop with an AI Player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we wrote a function called `handle-human` that interacted with a human
    to decide on a move in the game. Here is an analogous function, `handle-computer`,
    that interacts with our AI player to choose a move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This `handle-computer` function is quite straightforward. First, we get the
    ratings of each available move ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we pick the move that is rated the highest ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s create a function that handles the main loop for playing against
    the computer. This one is analogous to our earlier `play-vs-human` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As with the `play-vs-human` function, `play-vs-computer` first prints out information
    about the current state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
    If no more moves are available, it then calls the `announce-winner` function ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to check who the current player is. By convention, we’ll have
    the human be player A (player 0). If the player number is 0, we call our old `handle-human`
    function to let the human decide on her move ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we treat the player as an AI player and use the `handle-computer` function
    to decide on a move ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: We have now written a fully functional AI engine for Dice of Doom!
  prefs: []
  type: TYPE_NORMAL
- en: Playing Our First Human vs. Computer Game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is an example game playing against the computer AI. The computer
    plays an optimal game and wins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Making Dice of Doom Faster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional programming style can lead to slow code, at least in the hands
    of a novice programmer. We used the functional style to develop the core of Dice
    of Doom. Hence, this first version of our game is excruciatingly inefficient.
    We had to limit our game to a 2-by-2 board to make it playable. But now we can
    increase our board size to 3-by-3, as we optimize our game engine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase the parameters controlling the board size to make this happen.
    You may not want to play a game at this new size until you’ve implemented all
    the optimizations throughout the rest of this chapter, unless you are an extremely
    patient person and don’t mind having the computer take minutes building the initial
    game tree and deciding on moves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There, we’ve upgraded the board size to 3 by 3.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter covers some important techniques for optimizing functional
    code. These techniques apply to all programs written in the functional style,
    which includes Dice of Doom. In later chapters, we’ll add other optimizations.
    Eventually, we’ll be able to play against an AI player on much more spacious boards,
    while still having elegant code written in the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start optimizing Dice of Doom, there is an important Lisp programming
    concept we need to discuss: *closures*. Closures are extra bits of data from the
    outside world that are captured whenever a lambda function is created. To understand
    the hows and whys of capturing variables in a closure, consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re creating a new, unnamed function ![](httpatomoreillycomsourcenostarchimages783564.png),
    and then setting `*foo*` equal to this function. Next, we call this function using
    the `funcall` command ![](httpatomoreillycomsourcenostarchimages783562.png). As
    you would expect, the value returned from this function is `5`. All the lambda
    function does is return this number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider this more interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This version of `foo` is exactly the same as the previous version of `*foo*`,
    except that we first declare a local variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is set to `5`. Then, in the body of the `lambda`, we return `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    So, what do you think will happen if we call this new version of `*foo*`?
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is a tough question is that `x` is declared as a “local” variable.
    However, `x` (apparently) no longer exists once we call `*foo*`, since we’re already
    long past the point where we’re evaluating the body of the `let` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Holy cow! Somehow the lambda expression we created remembered what `x` was at
    the time it was created. The variable `x`, which we previously thought of as a
    local variable, has somehow managed to live on past the block in which it was
    created!
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first covered `let` expressions in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Lisp Program"), you learned that advanced Lispers prefer to call variables
    created with a `let` expression *lexical variables*. Now you can see why: A variable
    created in this way does not need to be local, if it is captured in a closure,
    by using the variable in a lambda expression.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how closures work, remember that Lisp uses garbage collection.
    In fact, it was the first language to have this feature. Garbage collection means
    that you never have to “free” variables (as you do in C programming). The Lisp
    compiler/interpreter is smart enough to know when variables are no longer in use
    and destroys them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection will happen at some arbitrary future time after you’ve exited
    a `let` expression. Periodically, Lisp will search its memory for items that are
    no longer referenced anywhere and can therefore be safely destroyed. If Lisp notices
    that a variable defined in a `let` is no longer used by anything, it will destroy
    that variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you create a lambda expression within the `let` expression (as we
    did in the previously), it’s possible for those variables to live on, being referenced
    from within the lambda expression. In that case, the garbage collector will leave
    those variables alone. Basically, you’ve created variables that are permanent—at
    least as long as the lambda expression doesn’t fall out of use and get garbage
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do a lot of cool things using closures. They’re often used for caching
    small pieces of information between uses of a function. For instance, here a function
    that remembers what line number is currently being printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In order to keep track of the line number, we first create a lexical variable
    named `line-number` ![](httpatomoreillycomsourcenostarchimages783564.png). Next,
    we declare our `my-print` function using `defun` ![](httpatomoreillycomsourcenostarchimages783562.png),
    in the body of the `let`. This command will create a lambda function behind the
    scenes, therefore letting us also generate a closure.
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of the `my-print` function, we can then print the `line-number`
    ![](httpatomoreillycomsourcenostarchimages783560.png), and even mutate it using
    `incf` ![](httpatomoreillycomsourcenostarchimages783554.png). (`incf` just adds
    one to a variable.) Because the `line-number` variable is captured in the closure,
    it can “live on” between calls to `my-print`, allowing us to count line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first optimization we’re going to perform is called *memoization*. This
    technique makes use of closures. Memoization works only for functions written
    in the functional style. As you know, the behavior of a function in the functional
    style depends only on the arguments passed into it. Also, the only action of a
    function in the functional style is to calculate a value to return to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests an obvious optimization: What if we remember the arguments and
    result of each call of this function? Then, if the function ever gets called again
    with the same arguments, we won’t need to recalculate the result. Instead, we
    can simply return the precalculated result.'
  prefs: []
  type: TYPE_NORMAL
- en: Several functions in Dice of Doom can benefit from memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the neighbors Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the `neighbors` function, which lets us know which hexagons
    on the board can be attacked from a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What `neighbors` is telling us is that if we want to attack other hexagons on
    the board from hexagon 0, we can reach only hexagon 3, 1, or 4 (based on our new
    3-by-3 board size).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, the `neighbors` function needed to do all kinds of ugly
    checking for the edges of the board, since hexagons along the edges are limited
    in the hexagons they can attack. However, since the shape of the board never changes
    mid-game, these numbers never change for a given board position. This makes `neighbors`
    a perfect candidate for memoization! Here is the code that accomplishes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dissect this code to make sense of what’s happening. First, we save the
    old version of the `neighbors` function in a local variable named `old-neighbors`
    ![](httpatomoreillycomsourcenostarchimages783564.png). The `symbol-function` command
    simply retrieves the function bound to a symbol. Using `symbol-function` here
    allows us to retain access to the old value of `neighbors`, even if we define
    a new function with the same name, as we’ll do shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a local variable `previous` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which will hold all previous arguments and results the function has ever seen.
    This can be represented as a hash table, where the arguments are the hash key
    and the results are the values.
  prefs: []
  type: TYPE_NORMAL
- en: Now we define a new `neighbors` function that will override the old definition
    of `neighbors` ![](httpatomoreillycomsourcenostarchimages783560.png). This new
    definition will add memoization to the old version of the function. Then we look
    up the argument `pos` in the hash table and return it, if available ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we call the old definition of the function (that’s why we needed to
    create the `old-neighbors` lexical variable) and add this new argument/result
    pair to the hash table ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since `setf` returns the value being set, this command will also cause this newly
    calculated result to be returned to the caller of `neighbors`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful not to declare the memoized version of the `neighbors` function more
    than once, without also redeclaring the original version of the function. Otherwise,
    the `neighbors` function will be wrapped in multiple unsightly layers of memoization,
    since there are no checks if the memoization has already been done.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the Game Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest payoff by far for memoization in our program will be in the `game-tree`
    function. This makes sense, if you think about how a board game works. Very often,
    you can get the same board positions in a board game by performing the same moves
    in a slightly different order. In our naive version of the `game-tree` function,
    every different move sequence leads to a completely different branch in the game
    tree that we need to build in a totally repetitive and inefficient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the memoized version of the `game-tree` code, the function can say to itself,
    “Hey, I’ve seen that board position before!” and can then share branches of the
    game tree. Here is a memoized version of `game-tree` that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this memoization is virtually identical to the one we used for
    the `neighbors` function. The only difference is that we’re setting the hash table
    to use `equalp` instead of `eql` (the default) for the test on the key ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: This is because the key (that is, the arguments to `game-tree`) contains the
    game board, in the form of an array. If we change the test function to be `equalp`,
    then Lisp will check every hexagon on the board and make sure it matches before
    using a previous calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing the rate-position Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another function that will benefit greatly from memoization is the `rate-position`
    function. Here it is, memoized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We need to do something a bit special for the memoization on this function to
    work correctly, because of the `tree` argument passed into rate-position. The
    game tree is potentially huge, so we need to make sure we never compare a game
    tree object with `equal` (or a similar comparison function that is slow with large
    lists). Instead, we want to compare it with `eql`. Because of this, we handle
    the memoization of each of the two parameters to `rate-position` (`tree` and `player`)
    separately. We accomplish this by having nested hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an outer hash table with the default `eql` test ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then, we define a `tab` variable that looks up one of our variables (`player`)
    in the outer hash table ![](httpatomoreillycomsourcenostarchimages783562.png),
    to retrieve an inner hash table. If `tab` is not found in the outer hash table
    ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll create a new, empty
    inner hash table, storing it in the outer hash table with the same key ![](httpatomoreillycomsourcenostarchimages783554.png).
    The rest of the function is similar to our previous examples, except that we’re
    now using our inner hash table, with the `tree` argument as a key ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: This memoization will bring us a step closer to having larger, and more fun,
    boards for Dice of Doom.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You use memoization for optimizing the performance of code written in the functional
    style. However, memoization code is not, in itself, written in the functional
    style. It cannot be, since it requires you to maintain and update a table of previous
    calls to the target function.
  prefs: []
  type: TYPE_NORMAL
- en: Tail Call Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next technique we’re going to use to optimize our functional program is
    called *tail call optimization*. To understand this concept, let’s study a simple
    function that calculates the length of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `my-length` function should be pretty easy for you to understand at this
    point. First, it checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783564.png).
    If not, it recursively calls itself against the tail of the list and adds one
    to the total, using the `1+` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the list is empty, the function just returns `0` ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that this function is actually quite inefficient. We can easily
    see this by trying to use it against a really big list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function in CLISP actually causes the program to crash! (Other
    Common Lisp compilers/interpreters may do better, depending on whether the compiler
    writers use any special tricks to anticipate this common pitfall in Lisp code.)
  prefs: []
  type: TYPE_NORMAL
- en: This happens because of the `1+` function. It tells Lisp, “*First*, figure out
    the length of the shorter list, *then* call `1+` on the result.”
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that each time we call `my-length` recursively, Lisp must remember
    that we need to add one to the result later on, once the length of the tail of
    the list has been figured out. Since the list is 100,000 items long, it must remember
    this 99,999 times before it can perform a single addition! The CLISP interpreter
    places a reminder for all of these additions on the program stack, which eventually
    overflows, crashing the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we avoid this problem? We do it by rewriting our `my-length` function
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png)
    that will act as our list-eater. This function takes an extra parameter, often
    called an `accumulator`, here shortened to `acc` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `acc` argument keeps a running count of how many items in the list we have
    previously encountered. When we initially call the function `f`, we set `acc`
    to `0` ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: By making this accumulator available, it means that when `f` calls itself recursively
    ![](httpatomoreillycomsourcenostarchimages783560.png), it now longer needs to
    add one to the result. Instead, it just adds one to the accumulator. Once we reach
    the end of the list (`lst` is `nil` ![](httpatomoreillycomsourcenostarchimages783562.png)),
    then `acc` will equal the total number of items in the list, so we can just return
    it ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: What is important here is that *the very last thing* the function `f` does,
    in the case where more items are on the list, is call itself recursively ![](httpatomoreillycomsourcenostarchimages783560.png).
    (The additional line in the `if` statement ![](httpatomoreillycomsourcenostarchimages783554.png)
    doesn’t count, since that part won’t be called if the expression evaluates to
    true.) When a function in Lisp calls itself (or another function) as its very
    last action, we call this action a *tail call*. A smart Lisp compiler, when seeing
    a tail call, can then say to itself, “Hey, since I don’t need to do anything more
    after calling `f` again, I can just go straight to `f`, without needing to put
    the current program context on the stack.”
  prefs: []
  type: TYPE_NORMAL
- en: This is actually similar to performing a `GOTO` in BASIC or a `longjmp` in C++.
    In all of these cases, we just “forget” where we came from, which is very fast
    and doesn’t thrash the stack. However, in the case of a tail call in Lisp, it
    is also perfectly safe. Anyone who has used `GOTO` or `longjmp` knows they’re
    anything but safe!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two different definitions for `lst` that exist in the
    preceding example code. One is an argument to the `my-length` function, and the
    other is an argument to the function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The values of these two lst arguments will deviate as the program runs and `f`
    is called recursively. However, within the function `f`, the version in its own
    argument list will take precedence. This process of hiding one variable with another
    through precedence is called *variable shadowing*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I used variable shadowing in the `my-length` function so it would be impossible
    for me to accidentally use the “wrong list” when writing the code inside of function
    `f`. Other programmers dislike this technique, since having similarly named variables
    with different values can lead to confusion. You’ll need to decide which of these
    arguments is most convincing to you and whether you’ll use variable shadowing
    in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Support for Tail Calls in Common Lisp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, you can’t be 100 percent sure in Common Lisp that a compiler/interpreter
    will perform tail call optimizations. It is not required by the ANSI Common Lisp
    standard. (The situation is actually different in the Scheme dialect, since Scheme
    has a strict requirement for tail call optimization.)
  prefs: []
  type: TYPE_NORMAL
- en: However, most Common Lisp compilers support this feature, although CLISP requires
    some extra cajoling to make tail call optimization work for some functions, including
    our example function. The reason for this is that tail calls can actually lead
    to performance problems themselves, in some esoteric cases. Also, when we debug
    a program, it’s nice to be able to look at the full call stack; tail call optimizations
    will prevent this, since, by their nature, they will minimize the information
    available on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the extra step we need to take to get CLISP to tail call optimize the
    `my-length` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function will tell CLISP to run the `my-length` function through
    its full compiler, which includes a tail code optimization step. Now we can run
    `my-length` against our jumbo-sized list!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tail Call Optimization in Dice of Doom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One function in our game that could definitely benefit from tail call optimization
    is the `add-new-dice` function. Here’s the fully optimized version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As before, we’re performing the list-eating in a function called `f` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which also has an accumulator. However, this time the `acc` variable will contain
    a *list* of newly updated hexagons with extra dice. We can now call `f` in tail
    call positions in two places ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png),
    where we `cons` new hexagons to the `acc` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve processed the whole list of hexagons on the board, we can just return
    `acc`. However, since we’ve consed stuff to `acc` as we went along the list, `acc`
    will actually be reversed. Therefore, we need to perform an extra call to `reverse`
    at the very end ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored some basic techniques for optimizing computer programs
    written in the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: A Sample Game on the 3-by-3 Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s enjoy the fruits of our labor. The following is a full game against
    the AI player on a 3-by-3 board. As you can see, on an evenly matched starting
    board, the computer is now practically unbeatable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we used our knowledge of functional programming to develop
    a board game with AI. Along the way you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming techniques allow you to write a game program with a “rule
    engine” that is separate from the rest of the code. You accomplish this by using
    *function pipelining* and building a *game tree* that is independently traversed
    by other parts of your game code as the game progresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create an AI player for a two-player game using the *minimax algorithm*.
    This algorithm is based on the truism “What is good for my enemy is bad for me.”
    It allows you to efficiently rate positions in a two-player board game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical variables (which we’ve been calling *local* variables) can live on past
    the form in which they were created if they are referenced by a lambda expression.
    Capturing variables in this way is called *creating a closure*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs can be optimized using *memoization*, which requires you
    to cache previous results calculated by a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also improve functional programs by using *tail call optimizations*,
    which allow you to make sure the call stack isn’t abused. You do this by controlling
    which function appears in the tail call (final) position of your list-eater functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 16. The Magic of Lisp Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Macro programming* allows you to mess around inside your Lisp compiler/interpreter
    to turn Lisp into your own custom programming language. When faced with a difficult
    programming challenge, many experienced Lispers will first ask themselves, “What
    programming language could I use to make this problem easy to solve?” Then they’ll
    use macros to convert Lisp into *that* language!'
  prefs: []
  type: TYPE_NORMAL
- en: 'No other programming language possesses such a simple and comprehensive macro
    system. One can even argue that it would be impossible to add this feature to
    other programming languages, for a simple reason: The Lisp languages are the only
    ones in which computer code and program data are made out of the same “stuff.”
    As discussed many times in this book, the fundamental structures for storing data
    in Lisp are symbols, numbers, and lists, which are made of cons cells. Similarly,
    the code of a Lisp program is made out of these same basic building blocks. As
    you’ll see in this chapter, this symmetry between code and data in Lisp is the
    magic that makes the Lisp macro system possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781590.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have heard that other programming languages, such as C++, also have
    a feature called macros. For instance, in the C++ language, you would create these
    using the #define directive. However, these are not the same thing! Lisp macros
    work in an entirely different and far more sophisticated way.'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Lisp Macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when you’re writing a computer program, you get a feeling of *déjà
    vu*. I’m sure you know this feeling. You’re typing away at your computer, and
    you suddenly realize, “Hey, this is the third time this week I’ve written this
    same fragment of code!”
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for example, that your program needs a special `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This function adds together two numbers and prints out the sum on the REPL
    as a side effect. You might find this function useful in a program during debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This `add` function seems straightforward, but its code has an annoyance: Why
    do you need so many parentheses to declare your variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png)?
    The `let` command requires so many parentheses that when you need only a single
    variable, the code ends up looking especially ludicrous.'
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses required by `let` are an example of the kind of *visual noise*
    a programmer must deal with almost every day. However, you can’t just write a
    regular function to hide those parentheses, because the `let` command can do things
    a regular Lisp function can’t support. The `let` command is a *special form*.
    It’s a core part of the language and has special powers beyond those of a standard
    Lisp function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros let us get rid of the superfluous parentheses. Let’s create a new macro
    named `let1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the definition of a macro looks similar to the definition of
    a function. However, instead of using `defun`, we use `defmacro` to define it.
    Like a function, it has a name (in this case, `let1`) and arguments passed to
    it ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve defined the macro `let1`, it can be used just like `let`, except
    that it works with fewer parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Macro Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a macro definition looks very similar to a function definition, a macro
    is actually very different from a function. To understand why, imagine your Lisp
    is actually a cute little blob, merrily running your Lisp programs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782790.png)'
  prefs: []
  type: TYPE_IMG
- en: This blob understands only standard Lisp code. If it were to see our `let1`
    command, it would have no idea what to do.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782218.png)'
  prefs: []
  type: TYPE_IMG
- en: Now imagine that we have a magic wand that transforms the appearance of our
    code *just before* Lisp gets a peek at it. In our example, it will transform `let1`
    into a regular `let`, so Lisp will stay happy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781008.png)'
  prefs: []
  type: TYPE_IMG
- en: This magic wand is called *macro expansion*. This is a special transformation
    that your code is put through before the core of the Lisp interpreter/compiler
    gets to see it. The job of the macro expander is to find any macros in your code
    (such as our let1 macro) and to convert them into regular Lisp code.
  prefs: []
  type: TYPE_NORMAL
- en: This means a macro is run at *a different time* than a function is run. A regular
    Lisp function runs when you execute a program that contains the function. This
    is called *runtime*. A macro, on the other hand, runs before the program does,
    when the program is read and compiled by your Lisp environment. This is called
    *macro expansion time*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the basic thinking behind Lisp macros, let’s take a
    closer look at how `let1` was defined.
  prefs: []
  type: TYPE_NORMAL
- en: How Macros Are Transformed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define a new macro with the `defmacro` command, we’re basically teaching
    the Lisp macro expansion system a new transformation that it can use to translate
    code before running a program. The macro receives raw source code in its arguments,
    in the form of Lisp expressions. Its job is to help the macro expander transform
    this raw code into standard Lisp code that keeps the Lisp blob happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how our `let1` macro gets transformed. Here is
    its definition once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of this `defmacro` call ![](httpatomoreillycomsourcenostarchimages783564.png)
    tells the macro expander, “Hey, if you see a form in code that begins with let1,
    here’s what you need to do to transform it into standard Lisp.” A macro defined
    with `defmacro` may also have arguments passed into it, which will contain the
    raw source code found inside the macro when the macro is used. The `let1` macro
    has three such arguments passed into it: `var`, `val`, and `body` ![](httpatomoreillycomsourcenostarchimages783564.png).
    So what do these three arguments represent?'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779867.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, when we use `let1`, we’ll end up having three different expressions
    inside it, which are the arguments to the `let1` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`var`**'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the name of the variable we’re defining. This name will
    be available within our macro using the argument named `var`. In this example,
    it will equal the symbol `foo`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`val`**'
  prefs: []
  type: TYPE_NORMAL
- en: The second expression holds the code that determines the value of the variable.
    In our macro, this is the second argument, `val`. It will equal the list `(+ 2
    3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`body`**'
  prefs: []
  type: TYPE_NORMAL
- en: The third expression inside a `let1` call is the body code, which makes use
    of the new variable that’s created (in this case, `foo`). It will be available
    in the macro through the argument named `body`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `let` command is allowed to have multiple statements in its body,
    we will want to mirror this behavior in the `let1` macro. This is why, in the
    `defmacro` command defining let1, the final `body` argument has the special keyword
    `&body` in front of it. This tells the macro expander “Give me all remaining expressions
    in the macro in a list.” Because of this, the body argument in our `let1` example
    is actually `((* foo foo))`—a nested list. In this example, we put only a single
    statement inside `let1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen what the values to the arguments of our `let1` macro are,
    let’s see how the macro uses this information to transform the `let1` into a standard
    `let` that the Lisp compiler can understand. The easiest way to transform source
    code in Lisp is to use backquote syntax. (If you don’t remember how to use backquotes,
    please see [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works") in [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works").) With backquotes, we can build the code for a proper `let` command using
    code passed to `let1`. Here’s our `let1` macro again for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `let1` macro returns a backquoted list starting with the
    symbol `let` ![](httpatomoreillycomsourcenostarchimages783564.png), followed by
    the variable name and value, placed in a proper nested list, which Lisp’s `let`
    command requires. The commas cause the actual variable name and value to be plopped
    in at these locations. Finally, we place the `body` code from the `let1` in the
    analogous place in the `let` command ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `body` argument is inserted into the transformed code using the splicing
    comma `(,@)`. To understand why the `body` needs to be handled in this special
    way, consider the following use of our `let1` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ve put more than one thing inside the body of our `let`. Remember
    that the `let` command includes an implicit `progn` command, and it can have multiple
    Lisp instructions inside. Our new `let`1 macro allows for this as well by placing
    the special `&body` marker in front of the `body` argument, causing all remaining
    syntax expressions to be passed into `let1` as a list. So, in the preceding example,
    the `body` argument contains the code `((princ "Lisp is awesome!") (* foo foo))`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Simple Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve written our `let1` macro, let’s rewrite our custom `add` function
    in a cleaner way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t this much easier on the eyes?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `macroexpand` command to see code generated by a macro. Simply
    pass the macro’s code to `macroexpand`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can now see the raw code generated by `let1` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `T` at the end ![](httpatomoreillycomsourcenostarchimages783562.png) just
    means `macroexpand` was handed a valid macro that it was able to expand.
  prefs: []
  type: TYPE_NORMAL
- en: As your macros become more complex, you’ll find that `macroexpand` is a valuable
    tool in testing and debugging their structure.
  prefs: []
  type: TYPE_NORMAL
- en: More Complex Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose you need a custom `my-length` command. This is a classic list-eating
    function that will count the length of a list. We’ll write it in the proper “tail
    call optimized” style (discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming")), where the recursive function call
    is in the tail position. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function has tons of repetitive stuff, once again giving
    us that dreaded feeling of *déjà vu*. There are two repetitive patterns in this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: As in other list-eater functions, we have the annoying check to see if the list
    is empty ![](httpatomoreillycomsourcenostarchimages783562.png) and the associated
    use of `cdr` ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did all this verbose work to create a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s write some macros that make this function (and other functions with the
    same repetition) more pithy.
  prefs: []
  type: TYPE_NORMAL
- en: A Macro for Splitting Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s create a `split` macro. It will let us write cleaner list-eater
    functions, such as our `my-length` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'List-eaters always check if the list is empty. If it isn’t, they take apart
    the list using `car` and/or `cdr`, and then perform operations on the head and/or
    tail of the list. The `split` macro does this for us. Here’s what it looks like
    when we use the finished `split` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `split` macro is a list you want to split into a head
    and a tail ![](httpatomoreillycomsourcenostarchimages783564.png). If this is possible,
    the next expression in the `split` macro will be called ![](httpatomoreillycomsourcenostarchimages783562.png).
    As a bonus, our `split` macro automatically creates two variables for us, named
    `head` and `tail`. This way, we don’t always need to call `car` and `cdr` inside
    list-eating functions. If the list is empty ![](httpatomoreillycomsourcenostarchimages783560.png),
    we call the expression at the end ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code for the `split` macro. Note that this initial version
    of the macro contains some bugs we’ll discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Our `split` macro requires three (and only three) expressions as arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    This means when we use this macro, we’ll always need exactly three items.
  prefs: []
  type: TYPE_NORMAL
- en: The code that needs to be generated by `split` is pretty straightforward. First,
    we have an `if` that checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is, we break apart the list and stick it into our two local variables, `head`
    ![](httpatomoreillycomsourcenostarchimages783560.png) and `tail` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Then we put in the code that handles the “yes, we can split the list” case ![](httpatomoreillycomsourcenostarchimages783510.png).
    If we can’t split the list, we call the no case ![](httpatomoreillycomsourcenostarchimages783544.png).
    Note that in the no case, we don’t have access to the `head/tail` variables, since
    they aren’t created if the list can’t be split.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new `split` macro, we can clean up our `my-length` macro a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we now make use of the `tail` variable created by `split`, simplifying
    our code ![](httpatomoreillycomsourcenostarchimages783564.png). Macros that automatically
    generate variables like this are called *anaphoric macros*.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not yet finished with our `split` macro. Although it basically
    works, it contains some subtle bugs that we need to address.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Repeated Execution in Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common bug that can happen in a macro is incorrect repeated execution of
    code. In fact, our current version of the `split` macro contains this flaw. Here
    is an example that clearly shows the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this use of `split`, the statement “Lisp rocks!” was printed three times,
    even though it appears only once in the original code. How is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the arguments passed into a macro consist of raw source code.
    This means the `val` argument passed into `split` contains the raw code of the
    `progn` statement ![](httpatomoreillycomsourcenostarchimages783564.png), including
    the raw code for the `princ` statement within it. Since we reference `val` three
    times inside the `split` macro, it causes the `princ` statement to be executed
    three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by running this example through `macroexpand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `princ` statement appears three times ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    This causes unexpected behavior and is inefficient, since we’re repeatedly running
    the same code unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you give this problem some thought, the solution isn’t too hard to figure
    out. We simply need to create a local variable inside the `split` macro, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that we made use of `let1` in this new version of `split`. As this shows,
    it is perfectly okay to use macros inside *other* macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we rerun our previous example, we can see that `split` behaves correctly,
    `princ`ing the statement only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this new version of the `split` macro introduces *yet another*
    bug. Let’s tackle this new bug next.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Variable Capture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the bug in our newest version of `split`, try running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you tell what happened? We just created a variable `x` inside the new version
    of our `split` macro! Here’s what the call to `split` looks like if we `macroexpand`
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the expanded version of `split` contains a definition of `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    This blocks the competing definition in our troublesome example ![](httpatomoreillycomsourcenostarchimages783564.png).
    In this scenario, the `split` macro accidentally *captured* the variable `x` and
    overwrote it in an unexpected way. How can we avoid this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple solution would be to not create a variable `x` in the macro, but
    to instead use a variable with some insane long name like `xqweopfjsadlkjgh`.
    Then we could feel pretty confident the variable used inside the macro will never
    clash with a variable inside the code that uses it. If fact, there is a Common
    Lisp function called `gensym` whose job it is to generate crazy variable names
    exactly for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `gensym` function will create a unique variable name for you that is guaranteed
    never to clash with any other variable name in your code. You may notice that
    it also has a special prefix (`#`:) that differentiates it from other names. Common
    Lisp handles these `gensym-based` names as a special case and will stop you from
    using the name of a `gensym` variable directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s use the `gensym` function inside our `split` macro to protect the
    macro from causing variable capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of our revised macro, we define a variable `g` that contains
    the `gensym` name ![](httpatomoreillycomsourcenostarchimages783564.png). It’s
    very important to notice that there is *not* a backquote at the front of this
    line. This means that this line of code is run at *macro expand time*, not *runtime*,
    and it is perfectly fine to define the variable `g` at this point. The `let1`
    on the next line, however, has a backquote in front of it ![](httpatomoreillycomsourcenostarchimages783562.png).
    This line will be run at runtime, so we don’t want to use a hardcoded variable
    in this spot. In this new version, we instead use the unique `gensym` name stored
    in `g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now every time the `split` macro is used, a unique name is generated to hold
    the internal value. We can test this by running some examples through `macroexpand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Notice how a differently named local variable was created in both instances
    ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png).
    This guarantees that the variable name will not only be unique within your code,
    but will also be unique if the `split` macro is ever used multiple times in a
    nested fashion. We have now created a fully debugged version of our `split` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Just because it is now bug-free does not mean that it is free of variable capture.
    Note that the macro still defines the variables `head` and `tail`. If you used
    this function in other code in which head or tail had an alternate meaning, your
    code would fail! However, in the case of `head` and `tail`, the capture is on
    purpose. In this situation, the variable capture is a *feature*, not a bug—it
    is an anaphoric macro. As we’ve discussed, this means that it makes named variables
    or functions available that we can use in the body of the macro.
  prefs: []
  type: TYPE_NORMAL
- en: A Recursion Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take another look at our improved `my-length` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed, there is an additional repetitive pattern in this code: The
    creation of a local function `f`. Let’s write another macro that gets rid of this
    additional visual noise: `recurse`. Here’s an example of the `recurse` macro in
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter into the `recurse` macro is a list of variables and their
    starting values ![](httpatomoreillycomsourcenostarchimages783564.png). In this
    case, we’re declaring only one variable (`n`) and setting its starting value to
    9\. The rest of the lines in the macro make up the body of the recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the body is start a fresh line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we check if `n` has reached zero yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it has, we print “lift-off!” ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we print the current number ![](httpatomoreillycomsourcenostarchimages783510.png)
    and call the function again, recursively. Like our `split` macro, the `recurse`
    macro is anaphoric. In the case of `recurse`, it makes a function named `self`
    available, which we call when we’re ready to perform a recursion ![](httpatomoreillycomsourcenostarchimages783544.png).
    We also subtract one from `n` at this point to lower the countdown number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how `recurse` should work, let’s write this `recurse` macro.
    In order to process the list of arguments and starting values, it’s useful for
    us to have a function that can group items into a list of pairs. Here is a function,
    `pairs`, that accomplishes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `pairs` function is a tail-call-optimized list-eater, which, ironically,
    has its own local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Shortly, we won’t need to declare such a function anymore.) It uses `split` to
    break an item off the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    However, since it needs to process two items (a pair) from the list at once, we
    need to run an additional check to see if the tail is empty ![](httpatomoreillycomsourcenostarchimages783560.png).
    If there are no items in the list ![](httpatomoreillycomsourcenostarchimages783544.png)
    (or only one item left ![](httpatomoreillycomsourcenostarchimages783510.png)),
    we return our accumulated values. Otherwise, we recursively process the rest of
    the list, with a new pair of items placed into the accumulator ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re finally ready to write the `recurse` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it simply transforms the recursion into a traditional local
    function. First, it uses our new `pairs` function to take apart the variable names
    and starting values, and puts the result into `p` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it defines a local function simply named `self`. The variable names for `self`
    are the odd-numbered items from `p` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we want `self` to be accessible, anaphorically, from inside the macro, we
    use a plain name instead of a `gensym` name for this function. At the bottom of
    the macro, we then simply call `self`, passing in all the starting values ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created the `recurse` macro, let’s once again clean up our `my-length`
    function using this new language construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is very little repetition or visual noise in this version
    of our `my-length` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can appreciate how helpful macros can be when trying to write clean,
    succinct code. However, a liberal use of macros will also require you to bear
    some costs that you need to be aware of. We’ll look at the potential downsides
    to macros next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros: Dangers and Alternatives'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Macros allow us to write code that generates other code, making the Lisp languages
    a wonderful tool for metaprogramming and prototyping new language ideas. But,
    at some level, macros are just a sleight of hand: They let you trick the Lisp
    compiler/interpreter into accepting your own customized language constructs and
    treating them like standard Lisp. They are indeed a powerful tool in a programmer’s
    tool chest, but they are not as elegant as some of the other programming tools
    you’ve encountered in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of macros is that they can make it hard for other programmers
    to understand your code. After all, if you’re creating your own language dialect,
    other programmers won’t be familiar with it. Even your future self—say, in a year
    or two—may have a hard time understanding the structure of your code if you’ve
    made heavy use of macros. Because of this, experienced Lispers will do their best
    to use alternate techniques to macro programming whenever possible. Often, a beginning
    Lisper will write a macro in situations that could be addressed in other, cleaner
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, it’s fun to see how we were able to clean up our `my-length`
    function by adding a couple of macros named `split` and `recurse`. However, in
    the previous two chapters, you learned about another tool, functional programming,
    which can also be used to clean up list-eater functions. One powerful function
    often used by functional programmers is `reduce`. It is a higher-order function
    that accepts a function and a list, and will call the function once for every
    value in the list. Here is the `my-length` function rewritten to use the powerful
    `reduce` function, rather than macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this new version of `my-length` easily blows away our previous
    version. It is shorter, and it doesn’t rely on any of the nonstandard macros that
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `reduce` holds our *reduction function* ![](httpatomoreillycomsourcenostarchimages783564.png).
    Its job is to keep track of, and update, an accumulated value, here named `x`.
    This variable `x` will hold the current accumulated value, which in this case
    will be the length of the list so far. This means we can simply add one to `x`
    to update it to its new value ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since the reduction function will be called once for every item in the list, it
    will, in the end, generate the length of the list. (The reduction function also
    receives, as an argument, the current item in the list, here given as the variable
    `i`. However, we do not need it for calculating the list’s length.) The next item
    passed to `reduce` is the list we want to reduce ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, since the accumulated length we’re calculating should have an initial
    value of zero, we indicate this by setting the `:initial-value` keyword argument
    to zero ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there are other scenarios where the list-eater macros we’ve created
    in this chapter are still useful. There are many cases where the `reduce` function
    could not be so easily used. So in the end, there are still many situations where
    creating your own Lisp dialect is exactly the right solution to a problem, as
    you’ll see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered macro programming. You’ve learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Macros let you write code that writes code. With macros, you can create your
    own programming language and convert it to standard Lisp just before the compiler
    can get a peek at it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros allow you to get rid of that feeling of *déjà vu* when writing your code,
    in situations when nothing else can do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be careful when writing macros so that they don’t lead to unintentional,
    repeated execution of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to be careful to avoid unintended *variable capture* in macros. You
    can avoid this by using `gensym` names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If variables created by a macro are exposed on purpose, as a feature of the
    macro, the macro is called an *anaphoric macro*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macro programming is a very powerful technique. However, try to use functional
    programming instead to solve a problem whenever possible. Macros should always
    be a last resort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 17. Domain-Specific Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best reasons for using macros is to perform *domain-specific language*
    (*DSL*) programming. DSL programming is an advanced macro programming technique
    that allows us to solve difficult programming problems by drastically changing
    the structure and appearance of Lisp code to optimize it for a specialized purpose.
    Although macros are not strictly necessary for doing DSL programming, by writing
    a set of macros, you can easily create a DSL in Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Domain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the 2000 US Census, the average family in the United States had
    1.86 children. Since no individual family has exactly 1.86 children, it is obvious
    that no particular family is truly perfectly average. In the same way, there is
    no such thing as an average computer program. Every program is designed to solve
    a specific problem, and every area of human inquiry, or *domain*, has its own
    idiosyncratic requirements that influence programs that solve problems in the
    given area. With DSLs, we enhance the core of our programming language to take
    these domain-specific requirements into account, potentially making our resulting
    code easier to write and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at some specific domains and create some DSLs that let us
    easily work within these domains using Lisp. In this chapter, we’ll create two
    different DSLs. First, we’ll create a DSL for writing *scalable vector graphics
    (SVG)* files. Then we’ll write a DSL for creating commands in a text adventure—we’re
    finally going to upgrade our Wizard’s Adventure Game from [Chapter 5](ch05.html
    "Chapter 5. Building a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting
    with the World: Reading and Printing in Lisp") to make it fully playable!'
  prefs: []
  type: TYPE_NORMAL
- en: Writing SVG Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780406.png)'
  prefs: []
  type: TYPE_IMG
- en: The SVG format is a file format for drawing graphics. In this format, you specify
    objects like circles and polygons, and then pass them to a compatible computer
    program to view. Because the SVG format specifies a drawing using pure math functions
    instead of raw pixels, it is easy for a program to render an SVG image at any
    size, making images in this format easily scalable.
  prefs: []
  type: TYPE_NORMAL
- en: The SVG format is currently receiving a lot of attention from web developers.
    All modern browsers (excluding Microsoft Internet Explorer) support SVG natively.
    Recently, Google released a set of libraries called SVG Web that adds decent support
    for SVG, even in Internet Explorer. This allows SVG to work in more than 90 percent
    of current web browsers. Finally, SVG has become a practical and efficient option
    for drawing graphics on websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SVG format is built on top of the XML format. Here is an example of what
    a complete SVG file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Simply copy this text and place it in a file named *example.svg* (or download
    this file from [http://landoflisp.com/](http://landoflisp.com/)). Then you can
    open the file from the Firefox web browser (the Safari, Chrome, and Opera web
    browsers should also work).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you should see, with a red and blue circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782270.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s write some macros and functions to let us create a picture like this
    directly in Common Lisp!
  prefs: []
  type: TYPE_NORMAL
- en: Creating XML and HTML with the tag Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XML data format (just like the HTML data format) consists primarily of
    nested tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Every tag ![](httpatomoreillycomsourcenostarchimages783564.png) also has a
    matching closing tag ![](httpatomoreillycomsourcenostarchimages783562.png). The
    closing tag has the same name, but with a slash preceding it. Additionally, tags
    may contain attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a tag named `mytag` that has the attribute of being
    blue and has a height of 9.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Macro Helper Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, when writing a macro to perform a task, you’ll find a lot of what your
    macro needs to do can be handled by a function instead. Because of this, it is
    often prudent to first write a helper function that does most of what the macro
    needs to do. Then you write the macro, keeping it as simple as possible by leveraging
    the helper function. This is what we’re going to do as we write a macro to create
    XML-style tags in Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our helper function, called `print-tag`, which prints a single opening
    (or closing) tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the `print-tag` function prints an opening angle bracket ![](httpatomoreillycomsourcenostarchimages783564.png).
    Since this is only a character, we use the literal character syntax by prefixing
    the bracket with #\. Then we check the predicate `closingp` ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is true, the tag needs to have a slash in front of it to make it a closing
    tag. Then we print the name of the tag, converted to lowercase with the `string-downcase`
    function ![](httpatomoreillycomsourcenostarchimages783560.png). Next, we iterate
    through all the attributes in the `alst` of attributes ![](httpatomoreillycomsourcenostarchimages783554.png)
    and print out each attribute/value pair ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, we end by putting in a closing angle bracket ![](httpatomoreillycomsourcenostarchimages783544.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example use of the `print-tag` function. Since it is a plain
    function and not a macro, it’s easy to debug in the REPL. This is another reason
    why helper functions are a good idea when creating macros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function does a fine job of printing an XML tag. However,
    it would be a real chore if all tags had to be created in this way. That’s why
    we’re going to write the `tag` macro next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tag Macro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tag` macro we’ll create has been adopted from the macro of the same name
    in Paul Graham’s Arc Lisp dialect. It improves on the `print-tag` function in
    several crucial ways, all of which could not be remedied without having a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags always come in pairs. However, if we want to nest tags, a function would
    not be able to print tags that surround the tags printed inside it. This is because
    it requires us to execute code before and after nested tags are evaluated. This
    is possible in a macro, but not a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag names and attribute names usually do not need to change in a dynamic way.
    Because of this, it’s redundant to need to prefix tag names with a single quote.
    In other words, tag names should by default be treated as if they were in data
    mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike tag names, it’s very desirable for the values of attributes to be dynamically
    generated. Our macro will have a syntax that places the attribute values into
    code mode so we can execute Lisp code to populate these values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, this is how we would like the tag macro to work, when we use it in
    the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the tag name and attribute list no longer need quotes in front of
    them. Additionally, it is now easy to calculate an attribute dynamically with
    Lisp code. In this case, we’re calculating that the height is 4 plus 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the macro that accomplishes this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, the macro first calls `print-tag` to generate the opening
    tag ![](httpatomoreillycomsourcenostarchimages783564.png). This is a bit tricky
    when we generate the alist of attributes for `print-tag`, since we want the values
    for the attributes to be in code mode. We accomplish this by wrapping the attributes
    using `list` ![](httpatomoreillycomsourcenostarchimages783562.png). Then we `mapcar`
    through the attributes, which we’ve paired with the `pairs` function ![](httpatomoreillycomsourcenostarchimages783554.png).
    (Remember that we created the `pairs` function toward the end of the previous
    chapter.) For each attribute pair, we generate a code fragment in the list that
    consists of cons, without a quotation mark in front of the value of the attribute,
    so that we can dynamically calculate it ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put all the code nested inside our `tag` macro, so that it is called
    after the opening tag ![](httpatomoreillycomsourcenostarchimages783510.png). Finally
    we create a closing tag ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make more sense of how this macro handles the attribute list, let’s pass
    the output from our example to `macroexpand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the macro expansion, it should be clear how the `tag` macro builds
    the attribute list to pass to `print-tag` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and how it allows us to dynamically generate attribute values, such as the height
    attribute ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of this macro in use, now with two inner tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Notice how it correctly surrounds the inner, nested tags with proper XML opening
    and closing tags. Note also that I have added line breaks and indentation to the
    output ![](httpatomoreillycomsourcenostarchimages783564.png) for clarity. The
    actual output of the `tag` function always prints on a single line, without line
    breaks or indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tag Macro to Generate HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tag` macro can be used for generating XML *or* HTML. For instance, we
    could do the following to generate a “Hello World” HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Since HTML uses predefined tags (unlike XML, where the tags can have any name),
    we could write simple macros for specific HTML tags that make them even easier
    to write HTML in Lisp. For instance, here are some simple `html` and `body` macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we could write our “Hello World” HTML example even more elegantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: However, we want to use the `tag` macro to create SVG drawings instead. So let’s
    expand our DSL for the SVG domain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SVG-Specific Macros and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s write the `svg` macro, which embodies an entire SVG image. Here
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `svg` macro is built on top of the `tag` macro. SVG images, for our purposes,
    require two special attributes to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: The `xmlns` attribute tells the SVG viewer (in our case, the Firefox web browser)
    where it can find the proper documentation for the SVG format ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second attribute enables hyperlinks inside the picture ![](httpatomoreillycomsourcenostarchimages783562.png).
    We’ll be using this hyperlinking feature in more advanced examples, starting in
    the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To draw pictures, we’ll need to manipulate colors. To keep things simple, we’re
    just going to represent colors as RGB triples stored in a list. For instance,
    the color `(255 0 0)` is bright red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, it is useful to generate lighter or darker variants of a particular
    color. The following `brightness` function does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass bright red into this function and set the brightness to negative
    100, you can see that it will generate a darker red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s create a function that sets the style of an SVG picture element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `svg-style` function accepts a color, and then sets the fill and stroke
    (outline) of a picture element ![](httpatomoreillycomsourcenostarchimages783564.png).
    By using our brightness function, we can make the outline a darker variant of
    the fill ![](httpatomoreillycomsourcenostarchimages783562.png). This way, we need
    to specify only a single color for every element in our pictures, while maintaining
    a pleasing appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a function to draw a circle. Since we won’t need to nest other
    SVG tags inside a circle, there is no need to write a macro for drawing circles—a
    function suffices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We’ll want to set the center, radius, and color of each circle. The center needs
    to be assigned to the `cx` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and `cy` ![](httpatomoreillycomsourcenostarchimages783562.png) SVG attributes
    of the circle. The radius is put in the `r` attribute ![](httpatomoreillycomsourcenostarchimages783560.png).
    We set the style of our circle with our `svg-style` function ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to draw the simple SVG picture of two circles shown earlier,
    using our new DSL! Here’s how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We now have a functional SVG DSL. Let’s add some more functionality to our DSL
    so we can appreciate the power a DSL can give to our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Building a More Complicated SVG Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a new function to our SVG DSL that makes it easy to draw an arbitrary
    polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: An SVG polygon stores all the points of the polygon in the `points` attribute
    ![](httpatomoreillycomsourcenostarchimages783564.png). We construct the list of
    points by using a `format` statement, which contains the `˜{ ˜}` control strings
    ![](httpatomoreillycomsourcenostarchimages783562.png). Remember from [Chapter 11](ch12.html
    "Chapter 11. Printing Text with the format Function") that these control strings
    let us iterate through a list inside the `format` function. In this case, we’re
    iterating through the list of points. We then flatten the list of point pairs
    using `mapcan` ![](httpatomoreillycomsourcenostarchimages783560.png), which you
    may remember is the same as using a `mapcar` followed by an `append`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re going to draw some random walks. A *random walk* is
    a graph of what you would get if you decide, at each moment in time, to flip a
    coin and then move either up or down a step. Random walks are very similar in
    behavior to stocks in the stock market. They are often used as a starting point
    for financial modeling. Here is a function that generates a random walk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This function builds a list of numbers, starting with the `value` parameter.
    Then it increases or decreases this value randomly. We choose which direction
    to move using the `random` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Note that, in order to keep it simple, this function isn’t tail call optimized,
    since the `cons` happens after the recursive call.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how we can use the `random-walk` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s use our SVG DSL to draw a slew of random walks in a picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Since the amount of data created in this example is quite huge, we’re dumping
    the data straight to a file (named *random_walk.svg*), instead of printing it
    to the REPL. We do this by redirecting the `*standard-output*` dynamic variable
    ![](httpatomoreillycomsourcenostarchimages783564.png), a technique introduced
    in [Chapter 12](ch13.html "Chapter 12. Working with Streams"). Notice how we can
    mix Lisp code freely with our DSL commands. For instance, we can loop right inside
    the SVG macro to generate 10 polygons at once ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the graph pretty, we’re going to fill in the area under each graph
    line with a color. To do this, we’ll represent each line using a polygon, with
    the base line along the bottom of the graph (with a y-coordinate of 200) included
    as points to close the shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781225.png)'
  prefs: []
  type: TYPE_IMG
- en: This is why we add points for the bottom-left ![](httpatomoreillycomsourcenostarchimages783560.png)
    and bottom-right ![](httpatomoreillycomsourcenostarchimages783554.png) corner
    as we create each polygon. For even more fun, we also randomize the color of each
    graph line ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some random graphs generated by this very simple DSL
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779828.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you’ve seen how easily you can write XML, HTML, and SVG DSLs in Lisp,
    let’s create an entirely different kind of DSL—one that will let us build custom
    game commands for our Wizard’s Adventure Game from [Chapter 5](ch05.html "Chapter 5. Building
    a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the
    World: Reading and Printing in Lisp")!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Game Commands for Wizard's Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783098.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you remember, when we last encountered the game starring our wizard and
    apprentice in [Chapter 5](ch05.html "Chapter 5. Building a Text Game Engine")
    and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and
    Printing in Lisp"), we could walk around the world and pick up objects. However,
    we couldn’t really perform any other interesting or fun actions. To make a game
    fun, it should include special actions that can be performed with certain objects
    and/or at certain locations in the game. We need frogs that can be kissed, dragons
    that can be fought, and perhaps even maidens that can be rescued!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating these kinds of interesting activities in the game poses a unique challenge.
    On the one hand, there are clearly many similarities between such different game
    actions. For instance, most of them will require us to have an object in our possession.
    On the other hand, they all need to have *unique and idiosyncratic properties*
    (enabled through command-specific Lisp code) or the game becomes boring. As you’ll
    see, a DSL can help you add many such unique commands to your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code from here until the end of this chapter, we’re going to use
    all the game code from [Chapter 5](ch05.html "Chapter 5. Building a Text Game
    Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading
    and Printing in Lisp"). Just put the code from those chapters into a file named
    *wizards_game.lisp* (or download *wizards_game.lisp* from [http://landoflisp.com/](http://landoflisp.com/)).
    As soon as the game is loaded, you can type game commands like look directly in
    the CLISP REPL. Alternatively, you can use the `game-repl` command we created
    in [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and Printing
    in Lisp") to get a more polished game experience. Remember that the `quit` command
    will take you out of the game REPL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you do to load the game code from the REPL and start running game
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Creating New Game Commands by Hand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what should our game DSL look like? The only way to really know is to first
    create some commands by hand. Then we can see if there are any common patterns
    between different commands that we can use as the basis of our DSL.
  prefs: []
  type: TYPE_NORMAL
- en: A Command for Welding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781998.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the attic of the wizard’s house is a welding machine. Let’s allow the players
    to weld the chain to the bucket if they bring those items to that location. Here’s
    the code to make this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: First, we need an easy way of checking whether the player is currently carrying
    an object, using the `have` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    Remember that we created a command for checking what the player is carrying, named
    `inventory`. If an object is a member of the inventory, it means the player must
    “have” that object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, our program needs some way of keeping track of whether or not the chain
    and bucket are welded together, since there will be actions later in the game
    that are possible only once this welding has happened. For this purpose, we create
    a global, dynamic variable named `*chain-welded*` ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to create the welding command itself ![](httpatomoreillycomsourcenostarchimages783560.png).
    Welding is possible only if a slew of conditions are met ![](httpatomoreillycomsourcenostarchimages783554.png):'
  prefs: []
  type: TYPE_NORMAL
- en: You must be in the attic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have `chain` and `bucket` as the subject and object of the welding
    command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be carrying the chain and bucket with you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain and bucket can’t already be welded together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these conditions are met, we set our `*chain-welded*` variable to `true`
    ![](httpatomoreillycomsourcenostarchimages783510.png) and print a message indicating
    this success. If any of the conditions fail, we indicate that the welding was
    unsuccessful ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the command in the CLISP REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Well, that’s exactly the right response. After all, we’re not in the attic,
    and we aren’t carrying the right objects. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try our new command in our fancy `game-repl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'What? Why doesn’t it “know” that command? The answer is simple: Our `game-re`pl
    has some basic protections against running unauthorized commands. To remedy this,
    we need to add `weld` to our list of permitted commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: By using the `pushnew` command, the `weld` function is added only to the allowed
    commands if it wasn’t already present in that list. Problem solved!
  prefs: []
  type: TYPE_NORMAL
- en: A Command for Dunking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780712.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the wizard’s garden, there is a well. Let’s create a command that lets the
    player dunk the bucket in the well to fill it with water:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: As with our `weld` command, we first need a variable to keep track of whether
    the bucket has been filled yet ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we need a `dunk` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Notice how, with dunking, we once again have a long list of conditions that need
    to be met before we can successfully complete the action ![](httpatomoreillycomsourcenostarchimages783560.png).
    Some of these are similar to those we needed for our welding command. For instance,
    dunking also requires the player to be in a specific location with the correct
    object. Other conditions are dunking-specific, such as the fact that the player
    needs to have a welded chain before being able to dunk. Finally, we need to push
    the `dunk` function onto our list of allowed actions ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780228.png)'
  prefs: []
  type: TYPE_IMG
- en: The game-action Macro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve created two custom game actions for our game, it’s obvious that
    the `weld` and `dunk` commands are very similar in some ways. However, as in our
    SVG library, each game command needs to contain a certain amount of dynamic logic
    in it, to customize the behavior of the command. Let’s write a `game-action` macro
    that addresses these issues. It will make it much easier to create new game commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This `game-action` macro embodies the common pattern between our `dunk` and
    `weld` commands. The parameters to `game-action` are the name of the command,
    the two objects involved in the action, the place it needs to occur, and some
    arbitrary additional code in the `body` parameter that lets us add custom logic
    to the command ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: The main job of the `game-action` macro is to define a new function for a command
    ![](httpatomoreillycomsourcenostarchimages783562.png). It may be surprising to
    you that a macro can do something as powerful as define a new function on its
    own, but there is nothing to stop it from doing this. I hope this example shows
    you just how flexible and mind-bending the Common Lisp macro system can be.
  prefs: []
  type: TYPE_NORMAL
- en: Since all game actions for this game require the location, subject, and object,
    we can take care of some of the conditions directly within this macro ![](httpatomoreillycomsourcenostarchimages783560.png).
    However, we’re going to leave other conditions open for each specific command.
    Notice, for example, that the subject of the game sentence needs to be owned by
    the player ![](httpatomoreillycomsourcenostarchimages783554.png), but the object
    does not. This makes sense, since there are many actions that can be performed,
    such as “throw rock dragon,” where the object of the sentence (dragon) does *not*
    need to be in the player’s inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Once the basic macro-level conditions have been met, we will defer the rest
    of the logic to the level of the individual command ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the conditions were *not* met, we print an error message, customized with the
    name of the current command ![](httpatomoreillycomsourcenostarchimages783544.png).
    Finally, we `pushnew` the command into the list of allowed commands for our fancy
    `game-repl` ![](httpatomoreillycomsourcenostarchimages783566.png).
  prefs: []
  type: TYPE_NORMAL
- en: One thing we do *not* do in this macro is define or set any global variables.
    If a game command needs to define a `*chain-welded*` or `*bucket-filled*` global
    variable, it must do this itself. This makes sense, since there is clearly no
    guarantee that there will be a one-to-one relationship between state variables
    for our game and particular commands. For instance, some commands may be permitted
    multiple times, making the state unnecessary. Or an action may depend on multiple
    state variables. Having this kind of variation in the commands is what makes them
    unique and fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this macro, we now have a simple DSL for creating new game actions! Essentially,
    this command gives us our own programming language, specialized for the domain
    of creating game commands. Let’s rewrite our previous `weld` and `dunk` commands
    using our new game command programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these commands have become much easier on the eyes. Notice how
    `weld` checks for ownership of the bucket, whereas `dunk` does not need to check
    for ownership of the well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate the value of using macros to implement our game command
    DSL, let’s implement a more complicated game command, `splash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'For this command, there are three distinct scenarios that might happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The bucket is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your bucket is full, but you stole the frog. In that case, you lose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your bucket is full and you didn’t steal the frog. You win!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our `game-action` macro, we can support many action commands, each with
    special idiosyncratic behavior. Still, we are able to avoid unnecessary repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `game-action` command exposes the `subject` and `object` variables within
    the body of the macro. This allows game commands to access this information, but
    it might also cause a name collision if the code that creates the `game-action`
    commands also has variables named `subject` and `object`. As an exercise, try
    modifying the `game-action` macro so that the `subject` and `object` variables
    are replaced by `gensym` names, as discussed in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  prefs: []
  type: TYPE_NORMAL
- en: Let's Try the Completed Wizard's Adventure Game!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a sample run through of the Wizard’s Adventure Game that shows off some
    of the rich functionality we’ve put into this game. Play the game yourself and
    see if you can win the magic donut!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780868.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter demonstrated how to create DSLs in Lisp. You learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to do some weird programming for a very specific domain, Macros
    are a great solution. With them, you can create your own DSL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, it makes sense to first write a helper function for a macro (like `print-tag`),
    and then write a macro (like `tag`) to add improvements that only a macro can
    provide. These improvements usually involve being able to access the code with
    a clearer, and often safer, syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix DSLs with regular Lisp code, which gives you a lot of power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSLs are useful when you need to write very specific code—whether it’s code
    for a web page, code that draws a picture, or code that builds special game commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 18. Lazy Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional
    Programming"), you learned that your programs can be simpler and cleaner when
    built with clean, math-like functions. These functions always return the same
    result, which depends solely on the arguments passed into them. When you rely
    only on these types of functions, you are using the *functional programming style*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we used the functional programming style to create the Dice of
    Doom game in [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written
    in the Functional Style"), a problem became evident: If your functions rely entirely
    on the arguments passed into them, the stuff that you need to pass into them often
    becomes *huge*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Dice of Doom game, we pass around the `game-tree` variable, which holds
    all the possible future states of the game board. This is a truly massive structure,
    even on a measly 3-by-3 board! So while the game’s current design makes our code
    very simple and elegant, it doesn’t appear to scale well to larger game boards,
    which would have exponentially larger game trees. The only way we could conceivably
    maintain our elegant code while allowing more complex games on larger boards is
    to make our program smart enough not to look at every conceivable move right from
    the start of the game. Is this possible? Yes, it is possible, using a feature
    called *lazy evaluation*. In this chapter, we’ll employ lazy evaluation to create
    an improved version of Dice of Doom.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Lazy Evaluation to Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With lazy evaluation, we can still create our entire game tree in a single
    place in our code—at the beginning of our game. However, we use some clever tricks
    so that some branches of our game tree are hidden in clouds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782958.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The branches of the game tree are still declared right from the start. However,
    we don’t bother doing all the actual calculations for the branches in clouds,
    as we would do when we create a “real” branch. This is the *lazy* part of lazy
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we wait to see if anyone “looks” at a cloudy branch. The moment this
    happens, POOF!, we create a real branch of our game tree at that spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781540.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that these branches in the game tree are created only if some part
    of the code happens to look at them. If the player never chooses a particular
    move in the game, and the AI never decides to contemplate it, our program will
    lazily avoid the calculations needed to figure out what the given branch actually
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as Haskell and Clojure Lisp, contain support for lazy evaluation
    as part of the core of the language. In fact, Clojure encourages its use and clearly
    demonstrates how useful it is for functional programming. However, the ANSI Common
    Lisp standard does not contain any similar feature for such lazy evaluation. Fortunately,
    with Common Lisp’s powerful macro system, we can easily add this feature to the
    language ourselves!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the lazy and force Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic commands for lazy evaluation we’re going to create are `lazy`
    and `force`. The `lazy` command will be a wrapper you can put around a piece of
    code, telling Lisp that you would like the code to be evaluated in a lazy way,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the computer *does not* try to calculate the value of 1 plus
    2\. Instead, it simply returns a function. To get the actual result of the calculation,
    we must call our other basic lazy evaluation command on a lazy value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing is that the calculation was performed, but not when the
    lazy value was created—only when it was forced. To see that this is the case,
    let’s look at a more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve created our own `add` function, which, as a side effect, prints
    a message to the console showing when the addition is happening ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we lazily add two numbers with our function and store the result in the
    variable `*foo*` ![](httpatomoreillycomsourcenostarchimages783562.png). So far,
    we know the addition hasn’t actually happened, since the message “I am adding
    now” has not yet appeared.
  prefs: []
  type: TYPE_NORMAL
- en: Then we `force` our variable ![](httpatomoreillycomsourcenostarchimages783560.png).
    By forcing the value, the calculation is actually performed, and the result of
    `3` is returned. You can see that the addition took place when we forced the lazy
    value, since our message was also printed in the console ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for a simple implementation of `lazy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: We implement `lazy` by declaring a macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    This macro will require two variables in the code it generates. We need to declare
    these as `gensym` names ![](httpatomoreillycomsourcenostarchimages783562.png),
    as discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros").
    Next, we begin generating the code that the macro will output ![](httpatomoreillycomsourcenostarchimages783560.png)
    (note the backquote at the beginning of this line).
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the code generated by the macro is a declaration for two local
    variables, using the `gensym` names we created ![](httpatomoreillycomsourcenostarchimages783560.png).
    The first variable tells us whether this lazy value has been forced yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it is `nil`, the value can hide in a cloud. If the variable is true, the value
    is no longer hidden in a cloud, because it has been forced.
  prefs: []
  type: TYPE_NORMAL
- en: Once the value has been calculated through a call to `force`, we store the resulting
    value in another variable, though initially this value isn’t used and is set to
    `nil` ![](httpatomoreillycomsourcenostarchimages783554.png). When our `lazy` macro
    is called, we want it to return a function, which can be called at a later time
    to force our lazy value to return a result. Therefore, we declare a lambda function
    next ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that any local variables declared outside this lambda function will
    be captured by the function as a closure. This means that the local variables
    above ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png)
    will persist between subsequent calls of the lambda function. Why does this matter?
    Well, once the cloud goes POOF!, we have completed all the work to calculate a
    value, and we don’t want to do it again when the lazy value is forced and checked
    again multiple times in the future. We can avoid this by remembering the value
    after the first `force` here ![](httpatomoreillycomsourcenostarchimages783554.png)
    between calls.
  prefs: []
  type: TYPE_NORMAL
- en: When our lazy value is forced (by calling the lambda function we created), the
    first question we must ask ourselves is whether it has been forced already or
    is still hidden behind the cloud ![](httpatomoreillycomsourcenostarchimages783544.png).
    For a value that has not yet been forced, we go POOF! and perform the lazy calculation
    ![](httpatomoreillycomsourcenostarchimages783556.png), and save it as our `value`.
    We also mark it as having been `forced` ![](httpatomoreillycomsourcenostarchimages783566.png).
    Now the cloud has been destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cloud is gone, we can simply return our calculated value ![](httpatomoreillycomsourcenostarchimages783498.png).
    This may have been just calculated, or it may already exist from a previous call
    to `force`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the (admittedly mind-bending) code for the `lazy` macro, the `force`
    function is super-simple. All it does is call the lambda function created by `lazy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We now have a fully functional set of primitive lazy evaluation commands. Many
    different types of sophisticated tools could be built on top of these simple `lazy`
    and `force` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lazy Lists Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now employ our new commands to build a library for *lazy lists*, based
    loosely on their implementation in Clojure. (In Clojure, lazy lists are referred
    to as *lazy sequences*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the fundamental command for working with Lisp lists is the `cons` command,
    you shouldn’t be surprised that the first command we create for working with lazy
    lists is the `lazy-cons` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro emulates the behavior of `cons`, except that the result is wrapped
    in the `lazy` macro. To accompany `lazy-cons`, we’ll also create `lazy-car` and
    `lazy-cdr` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'All these functions do is force the lazy value and then call `car` and `cdr`,
    respectively. Let’s try using these new commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use `lazy-cons` exactly as we would use `cons` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we can take apart a lazy cons in the same way we would take apart a cons
    ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it looks like our lazy list functions aren’t any different from the
    standard `cons`, `car`, and `cdr` functions. However, we can actually use them
    to perform some pretty amazing feats. Consider, for instance, the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve used the `lazy-cons` command to declare something impossible: a
    variable that holds a list of all positive integers! We do this by creating a
    local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png), which
    we then call recursively to build an infinite chain of `lazy-cons`es, using an
    ever-increasing number `n` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Once we’ve declared this seemingly impossible `*integers*` variable, we can use
    it just as you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: As long as we stick to using only our `lazy-` commands, we can pull whatever
    we want out of our infinite list of integers, forcing more and more numbers from
    `*integers*` on an as-needed basis.
  prefs: []
  type: TYPE_NORMAL
- en: Since not all lists are infinite (as is the list of positive integers), we’ll
    also need to have a concept of a `lazy-nil` to terminate a list. Similarly, we
    need a `lazy-null` function that we can use to check if we’ve reached the end
    of a list, just as the `null` function can be used to check for the end of a regular
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the basic building blocks for working with lazy lists,
    let’s create some useful functions for our library.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Regular Lists and Lazy Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One obvious thing we would want to be able to do is convert a regular list
    into a lazy list. The `make-lazy` function allows us to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: As the `make-lazy` function clearly shows, writing lazy list library functions
    is sort of like writing zen koans. The only way to understand them is to stare
    at them for a long time. The English language doesn’t have appropriate words for
    clearly explaining functions like `make-lazy`.
  prefs: []
  type: TYPE_NORMAL
- en: In broad terms, `make-lazy` uses recursion to travel across the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then wraps each cons in a call to the `lazy` macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    However, to get the full meaning of this function (and the other remaining functions
    in our lazy library), you’ll just have to try to think carefully about what `lazy`
    and `force` really mean, and meditate a bit over each function. Luckily, once
    our little lazy list library is complete, it will hide most of the strangeness
    of lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we wrote the `make-lazy` function to convert regular lists to lazy lists,
    we can create some functions to do the reverse—convert lazy lists into regular
    ones. The `take` and `take-all` functions allow us to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The reason we want two different commands for going from lazy to regular lists
    is that, unlike regular lists, lazy lists can be infinite. Therefore, it is useful
    to have an additional command that lets us take just a specified number of items
    from the list. The `take` function accepts an extra argument `n` that indicates
    just how many values we want to take ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we just want all values, we can call the `take-all` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Of course, this function cannot be used on infinite lists—taking all items from
    an infinite list would lead to an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our new lazy list conversion functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, if we take the first 10 integers off the list of all positive
    integers, we just get the numbers 1 through 10 as a result ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `take` function can also be used on a finite list we’ve created by calling
    `make-lazy` ![](httpatomoreillycomsourcenostarchimages783562.png). However, if
    a list is finite, we can use the simpler `take-all` function and just get a regular
    list of all items in the lazy list ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and Searching Across Lazy Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also want to be able to map and search across lazy lists. Here are some
    functions to allow that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: These functions are analogous to the functions `mapcar`, `mapcan`, `find-if`,
    and `nth`. The only difference is that they accept and return lazy lists. This
    means that instead of using `null`, `car`, and `cdr`, they use the lazy versions
    of these functions (`lazy-null`, `lazy-car`, and `lazy-cdr`) that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these functions is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Calling `lazy-mapcar` to map the square root function across the positive integers
    gives us a lazy list of the square roots of the positive integers. The first 10
    are shown ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we call
    `lazy-mapcan` ![](httpatomoreillycomsourcenostarchimages783562.png) and check
    if each positive integer is even. If it is, we return a lazy list of the numbers
    ![](httpatomoreillycomsourcenostarchimages783560.png). If it isn’t, we return
    the lazy empty list ![](httpatomoreillycomsourcenostarchimages783554.png). The
    result is that we’ve filtered out all the even numbers from our lazy list of integers.
    We can use `lazy-find-if` to find the first odd number in a lazy list ![](httpatomoreillycomsourcenostarchimages783510.png).
    In this case, the number was 7\. Finally, we can use `lazy-nth` to pick a number
    out of a specific location in a lazy list ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: We have now written an entire, if rather simple, lazy list library. Place all
    the functions we’ve written so far in this chapter in a file named *lazy.lisp*
    (or simply download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, you’re going to see that lazy lists allow us to greatly boost the power
    of our Dice of Doom game engine!
  prefs: []
  type: TYPE_NORMAL
- en: Dice of Doom, Version 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written in the Functional
    Style"), we created the first version of our Dice of Doom game. We are now going
    to modify some of the functions from that version. To proceed, place the code
    from that chapter into a file named *dice_of_doom_v1.lisp* so that we can reference
    it in this new version (or just download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our previous Dice of Doom and our new lazy list library, run the following
    in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’re going to increase the size of our board to a more roomy 4-by-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: To allow the game to run at a reasonable speed at this larger size, we’ll make
    the list of moves at each branch of our game tree a lazy list, instead of just
    a regular list. By simply converting this one structure in our game from a regular
    list to a lazy list, the entire game tree will become lazy as a result. To accomplish
    this, we now need to redefine some of the functions from the first version of
    our game to use our new lazy list functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make some small modifications to the functions that calculate
    the attacking and passing moves possible from a given board position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `add-passing-move` function needs only one small change.
    Since the list of moves is now a lazy list, we use `lazy-cons` to add a passing
    move to the top of the list of possible moves ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: The `attacking-moves` function requires a few more changes. First, since it
    now needs to return a lazy list, we use `lazy-mapcan` in lieu of `mapcan` in two
    places as the moves are calculated ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    The `lazy-mapcan` function also requires the lists created inside it to be lazy,
    which we accomplish with the `make-lazy` function ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783544.png).
    Also, any place we returned `nil` we now instead return a `lazy-nil` ![](httpatomoreillycomsourcenostarchimages783510.png)![](httpatomoreillycomsourcenostarchimages783556.png).
    Finally, we also make the list of calculated board positions lazy ![](httpatomoreillycomsourcenostarchimages783566.png),
    since it is fed into the outer `lazy-mapcan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s make similar changes to two of the functions that deal with human
    players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In the `handle-human` function, we have a local function `print-moves`, which
    is a list-eater function across the list of moves. We modify it to use our lazy
    commands when checking for the end of the list ![](httpatomoreillycomsourcenostarchimages783564.png),
    taking a move off the front of the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and recursing across the tail of the list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, we modify `handle-human` to use `lazy-nth` to pick a move after the human
    chooses it from the list of options ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: In the `play-vs-human` function, we make just a single pinpoint change. In order
    to determine whether we’ve reached the end of a game, we need to check whether
    the list of subsequent possible moves is empty, and then announce the winner.
    We simply use `lazy-null` to check if the lazy list of moves is empty ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'With these simple changes in place, you can play Dice of Doom against another
    human on much larger board sizes, since no move in the tree is realized unless
    one of the players decides to make it. On our larger, 4-by-4 board, enter the
    following to start a game (just as for version 1 of our game):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Version 1 would screech to a halt the moment this command was executed. This
    is because it would need to generate the entirety of the game tree, *for every
    possible move of the whole game*, before the game would even start playing.
  prefs: []
  type: TYPE_NORMAL
- en: With our lazy version of Dice of Doom, the game starts instantly!
  prefs: []
  type: TYPE_NORMAL
- en: Making Our AI Work on Larger Game Boards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we’re going to adjust our game AI functions to use the new lazy list library
    when processing moves. Along the way, we will make some additional improvements
    to the AI code.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming the Game Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779954.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In version 1 of Dice of Doom, our AI code was, in certain ways, extremely powerful.
    This is because, at every decision point, the AI player would look at *every possible
    future board position* to choose the absolute best next move. In this way, it
    could play a perfect game of Dice of Doom, winning every game that was winnable.
  prefs: []
  type: TYPE_NORMAL
- en: However, such a design does not scale to larger boards. This is because it becomes
    impossible to contemplate every single possible future move once there are too
    many. In fact, the whole point of our new lazy game tree is to avoid contemplating
    every possible move. Therefore, we need a way to tell the computer, “Consider
    only this many moves, and no more.” In other words, we want to be able tell it
    to look only two, three, or four moves ahead, and then stop looking any further.
  prefs: []
  type: TYPE_NORMAL
- en: The functional programming style of Dice of Doom allows us to do this in a very
    elegant but nonobvious way.
  prefs: []
  type: TYPE_NORMAL
- en: The *obvious* solution to the problem would be to modify the `get-ratings` and
    `rate-position` from version 1 to have a new argument called `search-depth`. Then
    we could ask ourselves at every call of those functions, “Have we reached the
    maximum search depth we want?”
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it gunks up those functions with extra,
    confusing code. In fact, the way we evaluate board positions is theoretically
    a separate issue from how deep we wish to search. As programmers like to say,
    these issues are *orthogonal*, and it would be best if we could write separate
    functions to deal with each of these issues independently.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with our new lazy game tree, it is possible to write a separate function
    that is solely responsible for “trimming” the search tree and is completely independent
    from the main AI code that contemplates and rates possible moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function that trims our tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty simple function that takes just two arguments: a lazy tree
    and the depth to which we wish to trim it ![](httpatomoreillycomsourcenostarchimages783564.png).
    As a result, it just outputs a new game tree, calling itself recursively, decrementing
    the depth for each level it travels into the tree ![](httpatomoreillycomsourcenostarchimages783554.png).
    Once this depth reaches zero ![](httpatomoreillycomsourcenostarchimages783562.png),
    we know we’re at the level that we want to trim, and we set the lazy list of moves
    to the empty list ![](httpatomoreillycomsourcenostarchimages783560.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is call our new `limit-tree-depth` function before doing
    our AI rating calculations. We do this by tweaking our `handle-computer` function
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Before calling `get-ratings` to get a rating for every next available move,
    we transform our game tree into our trimmed game tree ![](httpatomoreillycomsourcenostarchimages783564.png).
    All of our AI code can now run on the trimmed tree, completely oblivious to the
    fact that a larger game tree exists or that there are deeper moves it isn’t including
    in its calculations. With this technique, we have managed to decouple the code
    that limits the AI search depth from the algorithm that actually evaluates board
    positions. One other small modification is to use `lazy-nth` when picking a move
    out of the lazy list of moves ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `limit-tree-depth` function uses a pretty crude method for trimming our
    tree: It simply trims all tree branches beyond a certain depth. For most board
    games, doing this is an optimal way of trimming the game tree. However, Dice of
    Doom has the uncommon property that multiple moves in a row are allowed for each
    player. It would probably be more optimal if `limit-tree-depth` took into account
    how many times we’ve switched players as a criterion for trimming a branch. But
    our simpler version works well enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should also make a pinpoint change to `play-vs-computer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just added a `lazy-null` to check for the end of the lazy list of moves
    in a single spot ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at another trick that will improve the power of our AI code.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Heuristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By trimming our game tree, we’ve fundamentally changed our AI player. Without
    trimming, the AI player was able to play a perfect game at all times. By trimming
    the tree, however, it is possible for the AI to “miss something,” since it is
    no longer contemplating every possible future move. In version 2 of Dice of Doom,
    the computer player will no longer be able to play a perfect game—just a “pretty
    good” game is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we’ve exchanged the AI’s ability to play a perfect game for much
    better performance. In the process, we’ve turned the AI code from something precise
    that can be analyzed by mathematics into something that is “squishier” and far
    less precise. As computer scientists would say, we have now entered into the realm
    of *heuristics*.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, heuristics are programming techniques that are imperfect,
    but allow us to get good results very quickly. Broadly speaking, any technique
    that is fast but not guaranteed to work 100 percent of the time is a heuristic.
    When we write code that uses heuristics (as our Dice of Doom AI engine now does),
    it is often worthwhile to use some creative thinking and to “play around” with
    the code in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, since we’re already given up on our goal of a perfect solution and
    are now using imprecise techniques, it’s possible that tweaking the knobs on the
    heuristic code in different ways could dramatically improve our results. And indeed,
    it turns out that there is a simple change we can make to our Dice of Doom AI
    heuristics that will significantly improve the AI player’s game.
  prefs: []
  type: TYPE_NORMAL
- en: Winning by a Lot vs. Winning by a Little
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In version 1 of our Dice of Doom code, the AI player had no reason to ever worry
    about its margin of victory. All it cared about was that when the game ended,
    it had ownership of at least one more territory of the board than its opponent,
    which meant it had won.
  prefs: []
  type: TYPE_NORMAL
- en: However, now that we’re using imprecise heuristics in our AI code, it matters
    *a lot* how large the lead is at any point in the game. A heuristic rule for this
    situation is “If I am totally whomping my opponent in the game, it is pretty unlikely
    he/she will be able to recover, even if I look only a few moves ahead.”
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a minimax algorithm (as we’re using in our AI) assigns a point
    score to every final leaf branch in the tree. In version 1 of our game, this score
    was either 0 or 1, or sometimes 1/2 when the game ended in a tie. In version 2,
    these are not truly “final leaves” in the tree, but simply leaves in our much
    smaller trimmed tree. In this situation, it would be much better if our leaf point
    scores had a larger range of values, so that we can tell which moves lead to a
    game we’re winning by “a lot” and which moves lead to a game we’re winning by
    only “a little.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a `score-board` function that uses some more complex heuristics
    to score the board position at a leaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The `score-board` function loops ![](httpatomoreillycomsourcenostarchimages783564.png)
    across all of the hexes of the board and builds a running total of points for
    each hex using the `sum` directive of the loop macro. If the player we’re scoring
    owns the current hex ![](httpatomoreillycomsourcenostarchimages783562.png), we
    want to add positive points to the total ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide exactly how many points to add to the total for an occupied hex,
    we make another heuristic observation: Hexes that neighbor a stronger opponent
    aren’t quite as valuable as hexes without strong neighbors. We’ll call a hex that
    neighbors an enemy hex that has more dice on it a *threatened hex*. For hexes
    that are threatened ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll
    add only 1 point to the point total ![](httpatomoreillycomsourcenostarchimages783554.png).
    For hexes that are unthreatened, we’ll add 2 points ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, for each hex owned by an opposing player, we’ll subtract 1 point from
    the total ![](httpatomoreillycomsourcenostarchimages783544.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the important thing to realize is that `score-board` is a heuristic function,
    and there is no truly right or wrong way to generate such a score. Instead of
    adding 2 points for unthreatened hexes, we could just as easily have added 1.5
    points. In developing this example, I ran some simulations playing various opponents
    using different versions of the `score-board` function, and this version ended
    up working reasonably well. Developing heuristics is not an exact science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function that determines whether a given hex is threatened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the hex in question and figure out who the occupying player is,
    and how many dice that player has ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we loop through all the neighboring squares for the current position ![](httpatomoreillycomsourcenostarchimages783562.png).
    After that, we find out the player and dice count for each of the neighbors ![](httpatomoreillycomsourcenostarchimages783560.png).
    As soon as we find a neighboring hex owned by an opponent with a larger dice count
    (a threatening neighbor) ![](httpatomoreillycomsourcenostarchimages783554.png),
    we can return true ![](httpatomoreillycomsourcenostarchimages783510.png). Calling
    `return` in this way causes the loop to stop early with true as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed our `score-board` and `threatened` functions, we’re
    ready to write our improved `get-ratings` and `rate-position` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve updated a couple lines of code ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)
    to be compatible with our new lazy game tree. Notice that any game positions that
    lack follow-up moves (that is, leaves) now cause our new score-board function
    to be called ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fully working heuristic AI player that can play on larger
    game boards, let’s try it out. As usual, all moves for player B in the following
    example are being automatically calculated by the AI algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: With these changes in place, the AI player will win around 65 to 70 percent
    of all games (depending on the board size and AI level) when pitted against a
    player that chooses only random moves. This is actually a very good result. Our
    simple `gen-board` function often creates very lopsided starting positions, so
    many of the remaining 30 percent of the games are simply unwinnable for the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Beta Pruning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add one final improvement to version 2 of our Dice of Doom AI.
  prefs: []
  type: TYPE_NORMAL
- en: '*Alpha-beta pruning* is a well-known optimization of the minimax algorithm
    that improves performance by skipping over some branches (*pruning* those branches)
    if it is certain that they will not impact the final minimax evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780064.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When would a branch in the game tree be unable to impact the final result?
    In order to understand how alpha-beta pruning works, look at the following picture,
    showing the game tree for a simple 2-by-2 board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783278.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the top of this picture is the starting position of the game. The arrows
    point to possible moves. Above each board it states which player (A or B) currently
    is making a move.
  prefs: []
  type: TYPE_NORMAL
- en: The picture also shows the results of a minimax analysis of the game tree. On
    the bottom right of each board, you can see a number showing how our latest `get-ratings`
    function (with the new `score-board` logic) would rate that position. For leaf
    nodes (the boards along the very bottom), this number is calculated through `score-board`.
    For branch nodes, the number is calculated based on the minimax algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Every position in the game tree that allows a choice of moves is marked either
    as a MAX node or MIN node. Since the analysis in the picture is based on finding
    the best move for player A, all places allowing choices for player A are marked
    as MAX. All positions allowing choices for player B are marked as MIN. As you
    can see from the picture, this game is pretty unexciting, and there is only one
    position where player B actually has a choice of moves. In other words, only one
    MIN node exists in the game tree.
  prefs: []
  type: TYPE_NORMAL
- en: Working left to right, the minimax algorithm travels, depth first, exploring
    all the way down to the leaves. This is called a *depth-first search*. (We’re
    assuming no trimming is occurring, with `*ai-level*` set very high.) Then it chooses
    either the maximum or minimum scores for any nodes that have more than one branch.
  prefs: []
  type: TYPE_NORMAL
- en: When it does this, the first (left) branch of the MIN node in the picture ends
    up with a score of 8\. If the AI engine now dips into the right branch, it really
    only cares what it finds there as long as the score remains below 8\. After all,
    the minimum of 8 and any larger number larger than 8 will still be 8, making such
    large numbers irrelevant to the eventual outcome of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the AI finds a node in the right branch that has a score of 8 (marked
    with a star in the picture), it knows the rest of the right branch is irrelevant
    and can be pruned away from our calculations. This means the minimax algorithm
    has no need to look at the branch in the tree marked with the dotted line in the
    picture.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example, showing alpha-beta pruning in action. In the game
    tree shown in the picture, this pruning leads to only modest savings, since just
    a small number of the total nodes can be pruned. However, with larger game trees,
    the savings from alpha-beta pruning are typically immense, constituting a majority
    of the nodes in the game tree.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to take some liberties in how we implement alpha-beta pruning in
    our game to keep things simple. First, an alpha-beta pruning algorithm usually
    will pass around two variables called, naturally, `alpha` and `beta`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because it’s possible to write code that handles both the MAX nodes
    and MIN nodes at once by switching `alpha` and `beta` between the high and low
    limits. In our example, we’re going to use the variables `upper-limit` and `lower-limit`
    instead, indicating the highest and lowest values we care about as we traverse
    the game tree. As a cost, there will be some repetitive-looking code for handling
    the MAX and MIN cases. However, thinking of alpha-beta pruning in terms of `upper-limit`
    and `lower-limit` makes the code a bit easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Another compromise we’re making is that we’re not decoupling the pruning code
    from the minimax code. Remember that with the trimming code, we wrote an independent
    function named `limit-tree-depth`, which separated the act of trimming from the
    rest of the AI code. We could use a similar approach for separating the alpha-beta
    pruning code as well, creating a function that can transform the game tree into
    a pruned version on its own. However, doing this is a bit more involved, because
    the alpha-beta pruning code must have access to intermediate minimax calculations.
    For a more advanced AI engine, this would be a good idea. For our simple engine,
    we will just add our alpha-beta pruning check directly inside our minimax functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s get started. First, we’ll rewrite our `get-ratings` function as two
    new functions: `ab-get-ratings-max` and `ab-get-ratings-min`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `get-ratings` function was responsible for calculating the
    best score out of multiple available moves from a single-board arrangement. Now,
    however, we want it to stop early in its evaluation of moves once it decides it
    has found a move that’s “as good as is possible.” Determining whether it has reached
    this point is subtly different depending on whether the node in question is a
    MAX move (a move of the current player) or a MIN move (a move for the opponent).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the version responsible for MAX nodes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We’re now passing in an extra `upper-limit` and `lower-limit` argument into
    `ab-get-ratings-max` ![](httpatomoreillycomsourcenostarchimages783564.png). This
    function won’t actually ever check the `lower-limit` argument directly, since
    it is concerned only with finding the maximum rating possible from the given location
    in the tree. However, it will pass this value on to child branches, which may
    contain MIN nodes that *do* care about the lower limit.
  prefs: []
  type: TYPE_NORMAL
- en: When we rate the next branch of the tree ![](httpatomoreillycomsourcenostarchimages783562.png)
    (by calling `ab-rate-position`, which we’ll write shortly), we save the result
    as `x`. If `x` is greater than or equal to our `upper-limit` ![](httpatomoreillycomsourcenostarchimages783560.png),
    we know we got a result as good as we can hope for, and can just return the latest
    rating as a final value in our list ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: If `x` isn’t large enough, we need to keep looking at the remaining branches
    ![](httpatomoreillycomsourcenostarchimages783510.png). Note that `x` will become
    the new `lower-limit` if it’s larger than the previous `lower-limit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the `ab-get-ratings-min` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The `ab-get-ratings-min` function is basically identical to the `ab-get-ratings-max`
    function, except the roles of the upper and lower limits are flipped. Based on
    the repetitiveness of these two functions, you could probably imagine how the
    `ab-get-ratings-max` and `ab-get-ratings-min` functions could be combined into
    a single function. As mentioned earlier, with that approach, rather than `upper-limit`
    and `lower-limit`, you would use the more generic terms `alpha` and `beta`, as
    these will differ based on whether the node is a MAX node or a MIN node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to tweak `rate-position`, the function that rates a single-board
    arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: In our new `ab-rate-position`, we check if this node in the game tree is a move
    for us or a move for an opponent ![](httpatomoreillycomsourcenostarchimages783564.png).
    If it’s a move for us, then it’s a MAX node, and we want to dispatch to `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783562.png). If it’s the opponent’s
    turn, we instead dispatch to `ab-get-ratings-min` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, `ab-rate-positon` is the same as our previous `rate-position` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our support for alpha-beta pruning, we need to modify one more
    function: the `handle-computer` function that kicks off our minimax calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: This function starts off the minimax calculation by calling `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783564.png), since the first move most
    definitely belongs to the target player and therefore is a MAX node.
  prefs: []
  type: TYPE_NORMAL
- en: When we call this function, we’ll need to pass in our starting `upper-limit`
    and `lower-limit`. Since we’re at the very beginning of our minimax searching,
    we’ll want to set these to be as large and as small as possible. Ideally, we would
    want them to be *positive infinity* and *negative infinity*. Although many Lisp
    environments contain support for such concepts, they are not part of the ANSI
    Common Lisp standard. However, the standard does define `most-positive-fixnum`
    and `most-negative-fixnum`, which are very large positive and negative numbers,
    making them perfectly suited for our purposes. Hence, we pass these into `ab-get-ratings-max`
    to start off our limits ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to squeeze out a tad more efficiency from our AI engine, we could,
    instead, set the `upper-limit` and `lower-limit` to be the maximum and minimum
    values from our `score-board` function. That would slightly improve the amount
    of pruning that is possible. However, the `score-board` function may return a
    different range of scores based on the size of the board. and it might have other
    dependencies if we decide to optimize board scoring even more in the future. Therefore,
    it is best for the time being if we set our limits to nigh infinity for the start
    of our minimax calculations so we don’t need to worry about this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final reward for once again improving the performance of our AI, let’s
    increase the size of the board to use a 5-by-5 game field. With our new lazy,
    trimmed, and pruned AI algorithms, we should be able to handle this larger board
    without a sweat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we used memoization for some of our earlier functions. If you
    have already played some games in this chapter on a 4-by-4 board, one function
    in particular, the `neighbors` function, may return results based on this old
    board size. This is only an issue if you’ve already played a game on the 4-by-4
    board without restarting your Lisp in the interim. To fix this, simply rerun the
    definition of the `neighbors` function in `dice_of_doom_v1.lisp` from the REPL
    (including the memoized revision at the bottom of the file) to clear any cached
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our game looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our REPL game interface is becoming really impractical for such
    a large game field. We’ll be addressing that next.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we made the computer player for our Dice of Doom game much
    more sophisticated. We implementing the game tree using lazy lists, and applied
    several optimization techniques to limit the number of board positions that are
    searched by the AI engine. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lazy programming* allows you to work with very large (and even infinite) data
    structures and do so efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have a `lazy` macro and a `force` function, you can use them to build
    more sophisticated lazy operations, including building a lazy list library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heuristics are imperfect algorithms that can be used to improve the performance
    of your code, with some creative thinking. In our example, we made some heuristic
    changes to how we score leaf nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we converted Dice of Doom to use a lazy tree, we were able to elegantly
    trim the game tree in order to limit how deep the AI thinks when contemplating
    its moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha-beta pruning lets us improve performance even more, by pruning branches
    that have no way of impacting the final scores on the moves being considered by
    the AI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 19. Creating a Graphical, Web-Based Version of Dice of Doom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a second version of Dice of Doom to play
    on larger game boards. It has become quite difficult to understand the board and
    make moves using our crude console interface. Certainly, Dice of Doom would be
    infinitely better if we had a pretty graphical game board that allowed us to simply
    click where we wanted to make our moves. Well, I have good news for you . . .
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll put together a lot of code from earlier chapters to transform
    Dice of Doom into a full-featured, graphical game you can play right inside a
    web browser!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Game Board Using the SVG Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already written a primitive web server in [Chapter 13](ch14.html "Chapter 13. Let's
    Create a Web Server!"). Also, we’ve covered how to draw SVG graphics with a DSL
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages"). Lucky for
    us, the new HTML5 standard includes features that make it possible to embed SVG
    pictures directly inside a standard HTML document. In this way, we’ll be able
    to use our simple little web server to serve up some fully interactive vector
    graphics. You’ll be amazed at how easy it is to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time this book was written, the only web browser to support inline SVG
    within HTML was Firefox 3.7 Alpha. Use this, or a more recent release of Firefox
    with our new version of Dice of Doom. If you’re having problems, try navigating
    to the about:config page in the Firefox address bar, and set the html5.enable
    configuration setting to true. This will allow Firefox to use the latest HTML5
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that our web server library is not pure ANSI Common Lisp, and
    makes use of some CLISP-specific extensions. This means it requires CLISP to function.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll need to pull in code from various other chapters to get ready.
    In the previous chapter, we created version 2 of our Dice of Doom engine. Place
    all the code from that chapter in a file named *dice_of_doom_v2.lisp*. You should
    also already have created a file named *webserver.lisp* from [Chapter 13](ch14.html
    "Chapter 13. Let's Create a Web Server!"). (These files are all freely available
    from [http://landoflisp.com/](http://landoflisp.com/).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load in these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'For our SVG support, we’ll also need the SVG-rendering code from [Chapter 16](ch18.html
    "Chapter 16. The Magic of Lisp Macros") and [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages"). Place those functions in *svg.lisp*. (This file is also available
    from [http://landoflisp.com/](http://landoflisp.com/).) For reference, the functions
    we’ll need are `let1`, `split`, `pairs`, `print-tag`, `tag`, `svg`, `brightness`,
    `svg-style`, and `polygon`. Load this file next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s write some code that can draw a pretty version of our game board
    using SVG. First, we’ll want to define some constants that control the various
    dimensions needed to draw the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The board width and height will be 900-by-500 pixels, which is a good size for
    playing a game in a browser on most people’s computer screens. The board scale
    ![](httpatomoreillycomsourcenostarchimages783564.png) represents half the width
    of a single hex on the screen in pixels. The `*top-offset*` variable ![](httpatomoreillycomsourcenostarchimages783562.png)
    tells us we want three extra hex heights of free space above the base of the board.
    We’ll need this because a hex with lot of dice on it will have its dice sticking
    out, upward, and we need room for these dice to be visible on the screen. The
    `*dice-scale*` variable ![](httpatomoreillycomsourcenostarchimages783560.png)
    tells us that a single die will be about 40 pixels tall and wide on the screen.
    Finally, we set `*dot-size*` to `0.05`, which tells us that each dot will be about
    0.05 times the size of a die ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Die
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to write a function that can draw a die. Note that we won’t
    use bitmaps or anything like that to draw. Instead, we’re drawing a die “the hard
    way,” by rendering it directly out of raw SVG polygons. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: To draw a die, we need to pass in three arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    The first two are the x and y position at which the die should appear in the SVG
    picture. The third is the color we want the die to be. This function will take
    some liberties with that color and modify it as needed to give the die a little
    shading.
  prefs: []
  type: TYPE_NORMAL
- en: Anything we draw in this function will need to be rendered in a scaled fashion,
    based on the `*dice-scale*` constant we defined. Therefore, we first define a
    local function `calc-pt` that scales a point for us ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we’ll need to draw several scaled polygons, let’s also create a convenience
    function, `f`, that runs `calc-pt` against all points in a polygon and then draws
    it by calling the `polygon` function ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'A die in our picture will have three visible faces: the top face, the front
    face, and the right face. We draw these by calling our function `f` three times
    starting here ![](httpatomoreillycomsourcenostarchimages783554.png) and using
    some hard-coded coordinates for the three faces.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is draw the little dots on the faces of the die.
    We do this by `mapcing` ![](httpatomoreillycomsourcenostarchimages783510.png)
    the coordinates for the dots ![](httpatomoreillycomsourcenostarchimages783544.png)
    against a lambda function that can render a dot. This lambda function uses the
    `*dot-size*` variable to scale down a square-shaped polygon that represents each
    dot on the die face. We could write more sophisticated code to draw circular and/or
    elliptical dots, but the dots are so small that squares look just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try drawing a die at x=50 and y=50 with an RGB red `(255 0 0)` color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see what the final die looks like, just save this gobbledygook
    to a file named *die.svg*. Then load the result in Firefox, where you should see
    the following picture (shown at a blown-up size):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782140.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing a Tile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s write the function to draw an entire hex tile, including the base
    and the dice on the tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: This function takes in a lot of parameters, because a lot of information is
    encoded in a single tile of the board. You’ll learn the precise meaning of each
    of these parameters when we draw the board in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: First, our `draw-tile-svg` function draws the base. To give the base a mild
    3D look, we’ll draw it twice, with one level stacked on top of the other. Here
    ![](httpatomoreillycomsourcenostarchimages783564.png) is the loop that draws the
    two bases. Within that loop, we need to draw a hexagonal polygon ![](httpatomoreillycomsourcenostarchimages783562.png).
    We map a scaling function across the coordinates so that they are scaled to our
    `*board-scale*` variable. Here ![](httpatomoreillycomsourcenostarchimages783560.png)
    you can see the six points of a hexagon in perspective encoded using decimal notation.
    The color of the base will be brightened slightly if it has been chosen by the
    player to perform a move. We do this by increasing the brightness of the tile
    when creating our polygons ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve finished drawing the tile base, we need to draw the dice that reside
    on the tile. We do this by looping across the number of dice ![](httpatomoreillycomsourcenostarchimages783510.png)
    and then calling our `draw-die-svg` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    When calculating the x and y positions of the dice, we need to perform a bit of
    scaling math. The most interesting piece of this math is that we shift the dice
    a bit to the left or right, depending on whether the sum of the x-, y-, and z-coordinates
    for a given die is odd or even ![](httpatomoreillycomsourcenostarchimages783556.png).
    This makes the stacks look a little imperfect and will give the stacked dice for
    the complete board a pleasing, natural appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s call our function to draw a finished tile and see how it looks. Again,
    just copy the output from this command to a file named something like *tile.svg*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what you should see when looking at the file in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782446.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing the Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to write a function that draws an entire game board as an SVG.
    It will be very similar to our `draw-board` function, which we’ve been using to
    draw the board to the console. It fulfills the same role, but simply outputs the
    result as SVG data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The `draw-board-svg` function takes the board as an argument, but also requires
    two other arguments that will be important for using the picture as the front
    end of the user interface for our game ![](httpatomoreillycomsourcenostarchimages783564.png).
    One argument is `chosen-tile`, which indicates a tile that the player has clicked
    with the mouse. We’re going to color that tile a bit lighter, so the player can
    tell that the computer has recognized the selection. Another argument is `legal-tiles`,
    which indicates which tiles the player can legally click next.
  prefs: []
  type: TYPE_NORMAL
- en: It so happens that SVG pictures have a feature for web links, which works just
    like the `<a href="...">` hyperlinks in regular HTML. If a tile is a legal tile
    for the player’s next move, we’ll wrap the SVG for that tile in such a link, making
    it clickable. Having the `legal-tiles` parameter lets us know which tiles we want
    to be clickable.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw-board-svg` function consists of a couple of nested loops that loop
    through the `y` ![](httpatomoreillycomsourcenostarchimages783562.png) and `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png) coordinates of the tile
    board. For each tile, we then define a ton of local variables (using the facility
    for local variables in the `loop` macro introduced in [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")). First, we declare `pos` ![](httpatomoreillycomsourcenostarchimages783554.png),
    which indicates the position of current tile in the hex array. Then we fetch that
    hex. Next, we calculate the pixel coordinates for the tiles, in the variables
    `xx` and `yy`. As you can see, the math for these coordinates gets a bit tricky,
    since the board is drawn in perspective on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The final local variable we define is `col`, which will hold the color of the
    tile and dice in the current spot. We do this by using a list of die colors, which
    currently holds the colors red (for player A) and blue (for player B). We also
    darken the color a bit based on the y-coordinate using the `brightness` function
    (discussed in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages")).
    This darkens the rows in the back a bit, adding to the 3D appearance of our SVG
    game board.
  prefs: []
  type: TYPE_NORMAL
- en: If the current tile is a member of the legal tiles ![](httpatomoreillycomsourcenostarchimages783510.png),
    we’re going to wrap it in a web link, as mentioned previously. In SVG, this is
    done with a tag in the form `<a xlink:href="...">`, which we create here ![](httpatomoreillycomsourcenostarchimages783544.png).
    Notice that we also wrap each tile in a `<g>` tag, which tells the SVG renderer
    to treat the polygons in this tile as a group. To figure out the actual URL we
    want to link to, we call the `make-game-link` function. This function builds an
    appropriate URL. You’ll understand the format of the URL better once we start
    writing the code that handles the web server for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’re ready to call our `draw-tile` function ![](httpatomoreillycomsourcenostarchimages783556.png).
    There are two different versions of the call in our code: one for the hyperlinked
    version and one for the nonlinked version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Phew! Now we can finally draw a full game board dynamically, using the SVG
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'If you save the output to *board.svg* and load it in Firefox, here is what
    you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781682.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the Web Server Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve completed the graphical side of Dice of Doom version 3, we’re
    ready to write the side that interfaces with the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Our Web Request Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The central function for our web server handling is called `dod-request-handler`.
    It is the function that we can pass to the `serve` command in our web server library,
    and it is responsible for handling all the web requests coming from the web browser.
    Here is the code for `dod-request-handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: First, this function checks whether the current page being fetched from the
    web server is `game.html` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This is the page where our game will reside on the web server. At the top of the
    page, we specify the `doctype` ![](httpatomoreillycomsourcenostarchimages783562.png).
    When done in this way, it tells the web browser to expect an HTML5-encoded web
    page. Then we put in some simple HTML to center the page and print a welcome message
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: The `params` passed from the web server library may contain an important value
    named `chosen`, which we fetch using this line ![](httpatomoreillycomsourcenostarchimages783554.png).
    If there is no chosen tile, or if the game tree is currently empty ![](httpatomoreillycomsourcenostarchimages783510.png),
    it means the player must be starting a brand-new game. If that’s the case, we
    will call a function named `web-initialize` ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out whether the game has ended. We can tell this by checking
    if the list of moves is empty (which, as you might remember, is stored in the
    `caddr` location of the tree). In that case, we’ll announce a winner ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we need to see if the current player is player zero, which means
    the player is the human player. In that case, we’ll call the function `web-handle-human`
    ![](httpatomoreillycomsourcenostarchimages783566.png) to build the rest of the
    HTML data in the body of the page. We also use the `read-from-string` function
    to pull the number of the chosen tile from the `chosen` parameter, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: In all other cases, we know we’re dealing with a computer player and hand over
    control to `web-handle-computer` ![](httpatomoreillycomsourcenostarchimages783498.png)
    to build the rest of the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `dod-request-handler` function needs to call the `draw-dod-page`
    function to draw the game board, which we do here ![](httpatomoreillycomsourcenostarchimages783062.png).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Our Game Web Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The limitations of our game web server are quite significant. First of all,
    for simplicity’s sake, the `dod-request-handler` function makes absolutely no
    effort to try to determine from whom the web request is coming. It behaves as
    if all game interactions were coming from a single player, and therefore isn’t
    a true multiplayer server for Dice of Doom. If multiple players were to try to
    play different games at the same time, the `dod-request-handler` would get confused
    and *bad things* would happen.
  prefs: []
  type: TYPE_NORMAL
- en: It would not be too difficult to expand `dod-request-handler` into a true web
    server for multiple, parallel games. To do this, we would need to pull session
    information out of the header data it receives as an argument from the web server,
    and then all variables it references (such as `*cur-game-tree*`, for instance)
    would need to live in a hash table, using the session information as a key. This
    way, each player would have her own game tree, and our engine could then serve
    multiple games in parallel. The implementation of such a multigame version of
    the `dod-request-handler` is “an exercise for the reader.”
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of `dod-request-handler` is that it reads information from
    the URL using the `read-from-string` function. As you’ve learned in earlier chapters,
    this function can be compromised to run arbitrary code in the hands of an experienced
    (and evil) Lisper.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a New Game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the `web-initialize` function, which initializes our game engine to
    start a brand-new game of Dice of Doom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it generates a random game board, builds a tree from it, and
    then stores the result in the global `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Announcing a Winner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the function that announces the winner within the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: It is exactly the same as our previous `announce-winner` function, except that
    it now includes some extra code at the end to build a web link ![](httpatomoreillycomsourcenostarchimages783564.png),
    which will allow us to conveniently start a brand-new game, since the current
    game has ended.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Human Player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web-handle-human` function is responsible for creating the HTML and doing
    the bookkeeping when the player taking the current turn is the human player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The recent choices the human has made dictate what this function will do. The
    `web-handle-human` function knows the human’s choices by referencing the most
    recently chosen position, which derives from a variable passed as a parameter
    through the web request. It also can reference the `*from-tile*` global variable,
    which tells it which tile the player initially chose to use as a starting location
    for a move. It needs both of these values, since a move has both a source location
    and a destination location.
  prefs: []
  type: TYPE_NORMAL
- en: If the player has not yet chosen a location, we want to print a message requesting
    that the player choose a hex ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player chose to pass, we want to print a message saying that player’s reinforcements
    have been placed ![](httpatomoreillycomsourcenostarchimages783562.png). (Remember
    that reinforcements are placed right after someone passes.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check if the `*from-tile*` variable is nil. If this is the case, it
    means the player has not yet chosen a starting location for a dice attack. If
    it’s `nil`, we can set `*from-tile*` equal to the location that was just selected
    ![](httpatomoreillycomsourcenostarchimages783560.png), as well as ask the player
    to select a destination.
  prefs: []
  type: TYPE_NORMAL
- en: If the currently selected location is the same as the `*from-tile*` variable,
    it means a tile was selected twice. This must mean the player has changed his
    mind and wants to undo his selection. Therefore, we will set `*from-tile*` to
    `nil` and print a cancellation message ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: In all other cases, it means the player has selected two valid locations for
    the start and end of an attack. We can now advance the `*cur-game-tree*` to point
    to the appropriate next tree inside the lazy list of available moves ![](httpatomoreillycomsourcenostarchimages783510.png).
    We want to print a message, allowing the player to pass ![](httpatomoreillycomsourcenostarchimages783544.png)
    or make yet another attack.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the code our game server will use to interact with the
    human player. Next, let’s write a function to handle the computer player.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Computer Player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handling the web interface for our computer player is pretty simple. After
    all, computer players don’t need any fancy user interface stuff to know what’s
    going on in the game. All the web stuff that happens when the computer is making
    moves is there solely for the benefit of the human player. Here is the `web-handle-computer`
    code that renders the HTML in the web interface as the AI player makes a move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: All this function does is call our previous `handle-computer` function, which
    will return the next branch that the computer has selected in the game tree. We
    use this to update our `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we print a message to state that the player has moved ![](httpatomoreillycomsourcenostarchimages783562.png).
    The last part of the function is a clever little gimmick to spice up our web interface
    a bit. It puts a smidgen of JavaScript in the HTML of the web page ![](httpatomoreillycomsourcenostarchimages783560.png),
    which forces the web browser to automatically load a new web page in five seconds.
    This means that as the computer AI player makes its moves, we get to see everything
    happen in a crude animation!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the SVG Game Board from Within the HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only one more function to write to complete version 3 of Dice of Doom:
    the `draw-dod-page` function. This function interfaces our page game server code
    with the SVG code that draws our board.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The most complicated part of this function is the code that determines which
    tiles on the board are legal tiles for the player to click ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player has already selected a tile, we want to find all moves ![](httpatomoreillycomsourcenostarchimages783562.png)
    where the starting position for the move matches the selected tile ![](httpatomoreillycomsourcenostarchimages783560.png)
    and return the destination position for the given move ![](httpatomoreillycomsourcenostarchimages783554.png).
    If the player hasn’t selected a tile yet, we just want to return all the legal
    starting positions ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our fully graphical version of Dice of Doom. Let’s play!
  prefs: []
  type: TYPE_NORMAL
- en: Playing Version 3 of Dice of Doom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to start up our web server. Simply serve up our `dod-request-handler`,
    and we’re ready to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Now move over to Firefox and go to [http://localhost:8080/game.html](http://localhost:8080/game.html).
    You should see our game in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783058.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click a tile, it is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782450.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can select a tile to attack. In this example, we’ll choose the stack
    of two dice to the right of the selected stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781872.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let’s pass our turn by clicking the **`pass`** web link. This will cause
    the reinforcement dice to be placed (in this case, only a single additional die
    in the upper-left corner):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781252.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you now hit **`continue`**, you will see the game cycle automatically through
    the moves for the computer player, in a similar fashion. It will keep going on
    like this until there is a winner for the game. You can always start a new game
    by just going back to the original *game.html* URL.
  prefs: []
  type: TYPE_NORMAL
- en: This is much nicer than the crude console interface we’ve been using so far!
    But there are still a few, final improvements we’re going to make to pep up Dice
    of Doom. We’ll be covering those in the next (and final chapter) of this book.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed how you can generate interactive graphics in
    a web browser from a Lisp program. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a graphical version of Dice Of Doom by rendering the board using
    the SVG format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML5 standard supports inline SVG images. You can use this to create an
    interactive, web-based version of your game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simple web server used for our example has several limitations. For example,
    our game cannot be played by multiple players. However, the request handler could
    be expanded to allow for multiple, parallel games.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 20. Making Dice of Doom More Fun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now time to create a final version of Dice of Doom. Version 4 of our game
    will be much more fun to play than our earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: Although you probably were not aware of it, we made some major compromises in
    the rules for our game to make it easier to program. In this chapter, we will
    allow more players, add rolling of the dice, and implement a few more changes
    to make Dice of Doom a much more interesting game.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the Number of Players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, put all the code from the previous chapter in a file named *dice_of_doom_v3.lisp*
    (also available from the companion website), and then execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change we’re going to make is to increase the number of players from
    two to four. Three of these will be AI opponents, played by the computer. Because
    of how we’ve written our code so far, this requires very little extra code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: First, we simply change our `*num-players*` variable to `4`. Then we need to
    indicate additional die colors for our new players. The colors for the four players
    will be red, blue, green, and purple.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the AI we’ve created so far already works just fine in a four-player
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Our AI game engine will use what is called a “paranoid strategy.” This means
    that the AI players will always assume that every other player (including the
    human) has no other goal but to—how should I put this?—screw them over personally.
    This isn’t a bad strategy to use; however, a game with more than two players opens
    up new possibilities. For instance, losing players could gang up on a winning
    player to improve their odds. Our game AI isn’t smart enough to form such packs
    of cooperation, but it’s good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve already tweaked some constants to increase the number of players,
    let’s tweak a couple more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re increasing the maximum number of dice on a hex tile from three to
    five, and decreasing the level of our AI from four to two. With the new rules
    described in this chapter, we’ll need to dumb down our AI a bit to make sure it
    stays zippy. Since there are now four competing players, the AI actually doesn’t
    need to be so smart to challenge the human opponent.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling the Dice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’m sure you’ve probably noticed one obvious flaw in our game so far: Despite
    the fact that it is called Dice of Doom, it actually is completely devoid of any
    randomness! The dice are never rolled, and the larger stack will always automatically
    win, which makes for a pretty lame dice game. Now we’re finally going to rectify
    this flaw.'
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the game, during an attack, both piles of dice are rolled,
    and whoever rolls the highest number wins the battle. Ties are a victory for the
    defender. If the attacker loses, that player must surrender all dice from the
    attacking hex except one.
  prefs: []
  type: TYPE_NORMAL
- en: In the lingo of AI programming, this means we will add *chance nodes* to our
    game tree. The way we’re going to implement this is pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: Building Chance Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every move in our lazy list of moves up to now has always had exactly two items
    in it: a description of the move (a list of the source and destination of the
    attack, or `nil` for a passing move) and the new node of the game tree for when
    the move has been taken. Now we’re simply going to add a third item to a move,
    which contains the game tree for an unsuccessful attack. This means that each
    move in our move list will double as a chance node, with two possible follow-up
    nodes for the next game tree, depending on whether an attack is successful.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update our `attacking-moves` function to add this extra item to the move
    so that each move acts as a chance node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The only thing new in this updated version of `attacking-moves` is right here
    ![](httpatomoreillycomsourcenostarchimages783564.png), where we add a third item
    as we create a new move in the game tree. The board in this alternate branch of
    our chance node is constructed by calling the function `board-attack-fail`, which
    we will write next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `board-attack-fail` function does exactly what you would expect: It takes
    a board and returns a board that has all dice but one removed from the hex from
    which a failed attack originated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply loop over the board and return each hex unmodified ![](httpatomoreillycomsourcenostarchimages783562.png),
    unless it happens to be the source hex for the attack. In that case, we remove
    all dice from that hex but one ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Doing the Actual Dice Rolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to write some functions to actually roll the dice. Here is a
    function that rolls a pile of dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: First, it calculates a total count of a pile of rolled dice by looping once
    for each die. For each die, it generates a random number from 1 to 6\. Then it
    stores the total sum in the `total` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, the `roll-dice` function prints a descriptive message about the roll ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it returns the total ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re never going to roll a pile of dice in isolation, let’s create another
    function that pits two piles of dice against each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: This simply calls `roll-dice` twice and compares the total of the two rolls.
    We’ll want to use this function as we travel along our game tree to pick either
    the winning or losing move as a turn is chosen by either the human or the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Dice Rolling Code from Our Game Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of our game engine, rolling dice simply means picking either
    the winning or losing branch of the chance node after the human or computer has
    chosen a move. This action is performed by the `pick-chance-branch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the current board and also the move that contains the chance
    node that needs to be resolved ![](httpatomoreillycomsourcenostarchimages783564.png).
    When the path inside the move is not `null`, we call `roll-against` with a count
    of dice in the source and destination hexes along the path of attack ![](httpatomoreillycomsourcenostarchimages783562.png).
    We check for a `null` path because that means the move was a “pass,” which doesn’t
    require any dice rolling.
  prefs: []
  type: TYPE_NORMAL
- en: If the dice roll for the attack is successful, we remove the first child tree
    from the chance node within the move ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the attack is unsuccessful, we return the second child of the chance node ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make sure that the `pick-chance-branch` function is called when
    the human or computer chooses a move. First, let’s take care of the human:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: All we’ve done here is to add a call to `pick-chance-branch` at the end of our
    previous `handle-human` function, at the point we need to return the child branch
    of the game tree that holds the next state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the `handle-computer` function in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’ve simply added a call to `pick-chance-branch` at the end of the function
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: It is now possible to play our updated Dice of Doom game. However, at this point,
    the computer player will play a very poor game, because the AI does not yet understand
    that the chance nodes exist. It will simply assume that every attack will always
    be successful, making it much too foolhardy to play a decent game. We need to
    improve our AI so that it takes into account the rolling of the dice as it makes
    its decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the AI to be able to deal with the dice rolls that are now important to
    our game, it must know a little something about the statistics of dice rolls.
    The following table gives it the needed statistical information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This table contains the odds of winning for each possible pairing of dice in
    our game. The columns represent the attacking dice, starting with one die. The
    rows represent the destination dice, starting with two dice (the minimum dice
    needed for an attack).
  prefs: []
  type: TYPE_NORMAL
- en: This table tells us, for instance, that a roll of two attacking dice against
    one defending die has an 84 percent chance of winning. Four attacking dice against
    three defending dice have a 74 percent chance of winning.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, the core function in our AI code is the `get-ratings` function,
    which gives a point score to the list of possible follow-up moves. We need to
    modify how it calculates the score of each possible move to take the odds of success
    of the dice roll into account. We are now going to make use of our `*dice-odds*`
    table, as well as the point scores of the successful or failed outcomes of each
    attack, to interpolate a combined score for each available move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: In our updated `get-ratings` function, we look up the odds of each attack succeeding
    from our table ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    multiply the odds with the rating for the winning child tree ![](httpatomoreillycomsourcenostarchimages783562.png).
    Additionally, we add in the odds of losing the attack (one minus the odds of winning)
    multiplied by the rating for the losing board position ![](httpatomoreillycomsourcenostarchimages783560.png).
    We now have an updated `get-ratings` function that understands chance nodes and
    accounts for them appropriately when generating the score for a move.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our game AI to be fully compatible with chance nodes, we need to make one
    additional small change. Our tree-trimming function needs to know about the two
    branches of the chance node within each move, so it can properly trim both the
    winning and losing alternatives for each move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: We `mapcar` ![](httpatomoreillycomsourcenostarchimages783564.png) across the
    tail of each move, so trimming is performed on both branches of any chance nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version 4 of Dice of Doom will not have alpha-beta pruning. Performing proper
    alpha-beta pruning in the presence of chance nodes is very complex.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Dice of Doom Reinforcement Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the number of reinforcements at the end of a player’s turn always
    equals the number of captured opponent dice, minus one. This reinforcement rule
    guaranteed that the total number of dice in a game always decreases, so that the
    game was certain to eventually terminate, and the game tree was always finite
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: However, since version 2, our game tree has been a lazy tree, so it is perfectly
    fine if the tree is infinite. Remember that one of the main benefits of lazy evaluation
    is that you can have data structures that are infinite in size.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we are now going to adjust our reinforcement rules to make our game
    strategically more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: According to our new rules, the number of reinforcement dice will equal the
    number of tiles in the player’s largest contiguous territory. This adds a lot
    of strategic depth, because the players must constantly decide whether to risk
    connecting their territories, or perhaps even to sacrifice smaller, nonviable
    territories by sending them on suicide missions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this new reinforcement rule, let’s first define the function
    `get-connected`, which returns a list of tiles that are owned by the current player
    and are connected as a cluster of neighbors to the target tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the same algorithm for finding connected tiles as we used
    for calculating connectedness in our Grand Theft Wumpus game in [Chapter 8](ch09.html
    "Chapter 8. This Ain't Your Daddy's Wumpus"). We traverse through the hexes and
    their neighbors recursively, while maintaining a `visited` list.
  prefs: []
  type: TYPE_NORMAL
- en: The `get-connected` function accomplishes this by defining two recursive local
    functions. The `check-pos` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    checks a single position and appends any new neighbors accessible from that location
    to the visited list. The `check-neighbors` function ![](httpatomoreillycomsourcenostarchimages783562.png)
    checks an entire list of neighbors, similarly appending new neighbors to the visited
    list. These two functions call each other recursively until all neighbors in a
    cluster are found. To start off this recursive calculation, we call the `check-pos`
    function with the target position and an initially empty `visited` list ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now find clusters. However, to find the *largest* cluster, we need the
    `largest-cluster-size` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: This function defines a local function `f`, which we’ll use to check every position
    on the board, while maintaining both a list of previously visited nodes and the
    size of the largest, best cluster found so far ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: As long as the current position number is less than the total number of spots
    on the board ![](httpatomoreillycomsourcenostarchimages783562.png), we continue
    to check tiles. If the current tile to be checked belongs to the player and also
    has not yet been visited ![](httpatomoreillycomsourcenostarchimages783560.png),
    we’ll call `get-connected` to retrieve the cluster of hexes reachable from this
    spot ![](httpatomoreillycomsourcenostarchimages783554.png). Then, if the size
    of the cluster is larger than the best found so far ![](httpatomoreillycomsourcenostarchimages783510.png),
    we make this the new best size in our recursive call ![](httpatomoreillycomsourcenostarchimages783544.png).
    Otherwise, we proceed by calling `f` while keeping the previous best size ![](httpatomoreillycomsourcenostarchimages783556.png).
    (The best variable at this point will hold the best value found so far from previous
    iterations.) No matter what happens, however, the `pos` variable is incremented
    with every recursive call to `f`, so that we eventually cover the whole board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update `add-new-dice` to make use of our new rule for choosing
    the number of reinforcements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `add-new-dice` function still receives `spare-dice` as an
    argument for compatibility with our old code ![](httpatomoreillycomsourcenostarchimages783564.png),
    but now this argument is simply ignored. Instead, the number of reinforcements
    added to the board depends on the size of the largest cluster ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, the `add-new-dice` is identical to our previous version.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the code we need to enable the new reinforcement rules. Note that,
    due to the design of our code, the AI player has full access to the game tree.
    Since the game tree now contains all of this new reinforcement data, the AI will
    automatically adapt its playing strategy to take into account the new reinforcement
    rules!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve gone through quite a long trip as we’ve created the Dice of Doom game,
    employing an immense number of different programming techniques along the way.
    We’ve taken even more trips with all the other games in this book. Thanks for
    taking this journey with me through the world of Lisp programming!
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest that you take a moment to enjoy the fruits of your labor and play
    a few games of the fourth and final version of Dice of Doom. Again, all you need
    to do is serve up the Dice of Doom request handler through our web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Now you can play Dice of Doom in Firefox (again, at the address *localhost:8080/game.html*)
    as it is meant to be played, with four players and all the new rules we’ve added
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781284.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good luck with all your Dice of Doom battles and all your future Lisp programming!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780634.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Appendix A. Epilogue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve worked your way through this book, here is one final reward:
    A story about the technologies behind the entire Lisp family of programming languages,
    set in the not-too-distant future . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781408.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780716.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780760.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780566.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780604.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780012.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783188.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783236.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782622.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782670.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782072.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Functional Guild Cruiser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming is a mathematical approach to programming that was pioneered
    by the creators of Lisp. Functional programming places certain restrictions on
    the programmer, but it can lead to very elegant code. When using functional programming,
    every variable that is used by a given function must be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782902.png)'
  prefs: []
  type: TYPE_IMG
- en: A parameter passed into that function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local variable created within that function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, functional programming doesn’t allow a function to have *side effects*.
    This means a function can’t write to the disk, print messages on the screen, or
    do anything other than return a result. The goal is to write most of a program
    using “functional code,” while retaining a teensy bit of code that does any dirty,
    nonfunctional stuff that is still needed.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing code in a functional style guarantees that a function does only one
    thing (returns a value) and is dependent on one only thing (the parameters passed
    to it). This makes it very easy to debug. No matter how many times you run a function,
    as long as you’re passing it the same data, you will always get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-1. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enter this code into the Lisp REPL and execute `(ask-and-respond)`, you
    will be asked for your name, and then greeted by your name but with all duplicate
    letters removed. All the hard work in this function is handled by `unique-letters`,
    which is written in a functional style ![](httpatomoreillycomsourcenostarchimages783564.png).
    The dirty work of interacting with the user, which can’t be written in a purely
    functional way, is handled by `ask-and-respond` ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main weakness of functional programming is that some side effects are almost
    always necessary for a program to actually *do* something. This means you can’t
    write a useful program that has the entirety of its code written in the functional
    style. At least a small amount of code will be nonfunctional.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming").
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782372.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Macro Guild Melee Fighters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*True macros* are one of Lisp’s most unique and amazing features. In fact,
    the reason Lispers put up with all those annoying parentheses in their code is
    that those parentheses enable the awesome Lisp macro system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780362.png)'
  prefs: []
  type: TYPE_IMG
- en: True macros allow you to add new functionality to Lisp in a very fundamental
    way. Experienced Lispers can use macros to make their Lisp compiler/interpreter
    do their bidding cleanly and elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using macros, an experienced Lisper can minimize code duplication, and better
    tailor the underlying language to the problem at hand. This leads to cleaner code
    and fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-2. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lisp macros are so powerful that you can actually write your own if-then command!
    The code shown here creates a macro called `three-way-if` that has three branches:
    one for a `nil` value ![](httpatomoreillycomsourcenostarchimages783564.png), one
    for a numerical zero value ![](httpatomoreillycomsourcenostarchimages783562.png),
    and one for everything else ![](httpatomoreillycomsourcenostarchimages783560.png).
    For most purposes, a function like this might seem stupid, but if you ever want
    to write a program that constantly needs to distinguish zeros from `nil`s (or
    needs to handle some other domain-specific headache), you’ll make your life much
    easier by writing a macro.'
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Lisp macros are so powerful, there is always the danger of programmers
    abusing them. Overuse of macros can make it hard for other programmers to understand
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Macros are discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp
    Macros").
  prefs: []
  type: TYPE_NORMAL
- en: Restart Guild Armored Fighter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Proper exception handling is extremely difficult. There are really only two
    good approaches: Don’t handle exceptions at all and just let your program die
    when one occurs, or handle every single exception in the most direct and specific
    way possible. But is it truly possible to handle every potential exception in
    your code? If your write Common Lisp code, it’s possible to get extremely close
    to this ideal goal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782448.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, suppose you write a function that raises the prices on a list of
    widgets. But then, while the function is processing one of the widgets in the
    list, there’s a memory allocation error. You can’t prepare for this type of error
    ahead of time, since it could happen anywhere in a program. This makes it impossible
    to address using traditional exception handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if a function lower in the call stack catches and resolves the source
    of the exception, the program still faces an unsolvable problem: Some of the widget
    prices have been raised, while others have not. Common Lisp, however, has a mechanism
    for addressing this problem, called *restarts*.'
  prefs: []
  type: TYPE_NORMAL
- en: In a language that supports restarts, the function that raises the widget prices
    can make the proclamation, “Hey everybody! If something bad happens while I’m
    working on my widgets, just use my restart (called `try-again`) when it’s safe
    for me to finish my work!” Another function, lower in the call tree, can now handle
    the error, and then call `try-again` to ensure that the widget prices won’t become
    corrupt. This allows the function to finish raising widget prices at the exact
    point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if you have a program that can’t afford to shut down (a web server,
    for example), you can still handle a surprising number of extreme exceptions in
    Common Lisp without ending the program. Even if the program encounters a truly
    exceptional exception, it can simply divert control back to the REPL. The programmer
    can then fix the cause of the exception, access a list of available restarts,
    and continue running the program on the spot.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using restarts and the Lisp REPL, a bug can be fixed in a running program,
    allowing you to “hot script” long-running applications with only a negligible
    interruption.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-3. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an implementation of a function that raises prices on a list of widgets.
    The actual work of raising the price of a single widget is done by the `raise-price`
    function ![](httpatomoreillycomsourcenostarchimages783564.png). The call to this
    function is protected by wrapping it in a `loop` and the `restart-case` command,
    which declares a restart called `try-again` ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the price can be raised without problems, the `raise-price` function will complete
    normally, the loop is interrupted with a `return` ![](httpatomoreillycomsourcenostarchimages783562.png),
    and the next item in the list of widgets is processed. On the other hand, if an
    error occurs while raising the price on a widget, another function (or the programmer)
    can attempt to fix the problem and call the `try-again` restart to retry the widget
    at the point of failure ![](httpatomoreillycomsourcenostarchimages783560.png),
    which leads to another cycle through the `loop` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The function can then continue down the rest of the list, raising the prices on
    the remaining widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: By using restarts, your code can offer multiple alternative follow-up options
    for coping with an exception, so that even the most exceptional exceptions can
    be handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Common Lisp has one of the most advanced exception handling systems
    in existence, it is still difficult to handle every exception appropriately in
    your code. However, restarts give you the unique ability to fix a running program
    and allow it to continue operating, which is usually not possible in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Restarts are discussed in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up
    a Notch with Functional Programming").
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782184.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generic Setter Guild Supply Ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To modify the value of a variable in Common Lisp, you use `setf`. However,
    this command also has an amazing special power: Instead of a variable name, you
    can pass it a complex Lisp expression that retrieves a value. It can then turn
    that expression “inside out” and use it to modify that value, rather than simply
    retrieve it. These types of expressions are called *generic setters*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779817.png)'
  prefs: []
  type: TYPE_IMG
- en: Many commands besides `setf` also support generic setters. Using this feature,
    most types of data structures can get by without any specific “setting” functions
    of their own.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a complicated, nested data structure, it’s often easier to understand
    code that retrieves data from a specific location than it is to understand code
    that sets a value at the same location. If you want to set a value at a specific
    location in a complicated structure, you usually need to work backward through
    the structure to figure out how to change it. But with generic setters, you can
    let Lisp handle the hard code for you. Having simpler code is a great way to fight
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-4. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example creates a variable named `foo`, which holds a list of three items
    ![](httpatomoreillycomsourcenostarchimages783564.png). The second item in the
    list is an empty hash table. Then it adds a key named `my-key` with a value of
    `77` to the table inside `foo` all at once, by putting a complex expression into
    `setf` that “gets at” this location ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By mutating an existing data structure, generic setters cause a side effect,
    which violates one of the tenets of functional programming. This means they can’t
    be used when programming in a purely functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Generic setters are discussed in [Chapter 9](ch10.html "Chapter 9. Advanced
    Datatypes and Generic Programming").
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783056.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783102.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DSL Guild Hot Rods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Lisp has such a simple syntax (everything is delimited with parentheses),
    it is easy to use it to build your own custom programming language, designed for
    a specific domain. Such *domain-specific languages* (*DSLs*) tend to make heavy
    use of the Lisp macro system. They represent an extreme form of macro programming,
    transforming Lisp into a completely new programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781109.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of code that uses a DSL to build an HTML page. In this case,
    the page displays “Hello **World**” in a browser, with the second word rendered
    in bold. The `html` and `body` commands (macros created for the HTML library in
    [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros")) generate opening
    and closing tags that will contain the body of the page ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it calls the regular Lisp function `princ` to generate the text. The second
    word is wrapped in another custom DSL command, `bold` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which generates opening and closing bold tags around the specified text.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-5. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since DSLs are programming languages you create all by yourself, you can definitely
    shoot yourself in the foot if you aren’t careful. It’s easy to create code in
    a language that is impossible for others (and perhaps even you) to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages") discusses DSLs,
    including the DSL that allows you to write HTML directly inside your Lisp code,
    as shown in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: CLOS Guild Battleship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Common Lisp has the most sophisticated object-oriented programming framework
    of any major programming language, called the *Common Lisp Object System* (*CLOS*).
    It is customizable at a fundamental level using the *Metaobject Protocol* (*MOP*).
    There’s really nothing like it anywhere else in programming. It lets you create
    incredibly complex software without losing control over the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782004.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Object-oriented programing* (*OOP*) is a commonly used technique for keeping
    bugs under control. By writing code in an object-oriented style, you can *decouple*
    different parts of your code. When you decouple code, you break your code into
    logical components, which can be tested independently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example A-6. Example 1: Wrapping Code Around Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The basic concepts behind object-oriented programming in Common Lisp are discussed
    in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic Programming").
    For detailed information on the design of CLOS, I recommend reading the CLOS papers
    compiled at [http://www.dreamsongs.com/CLOS.html](http://www.dreamsongs.com/CLOS.html).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, imagine we run a company that sells widgets, and we need some
    object-oriented Lisp code to help keep track of them. First, we need to create
    a new CLOS class (called `widget`) with `defclass` ![](httpatomoreillycomsourcenostarchimages783564.png).
    It has one property (or *slot*, in Lisp lingo) describing the widget’s color.
    Next, we declare a `describe-widget`, which prints out a description of the widget
    ![](httpatomoreillycomsourcenostarchimages783562.png). By convention, a function
    designed to operate on a specific type of object is called a *method*. In this
    case, the `describe-widget` is considered a method of the `widget` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we want to write an entry to a log file every time a user checks
    on a widget. Using the CLOS, we can declare one or more *before methods* that
    will automatically be called before the main `describe-widget` method is executed
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn’t have before methods available, we would need to dirty up our main
    widget code to add logging, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve added the command for logging ![](httpatomoreillycomsourcenostarchimages783562.png)
    right in the middle of the `describe-widget` method ![](httpatomoreillycomsourcenostarchimages783564.png).
    This code is a lot uglier, because writing to logs has nothing intrinsically to
    do with describing a widget. The logging in this version is also tightly coupled
    to the main code, which means we can no longer test the widget code independently
    from the debugging code. Using the before method leads to cleaner, more decoupled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example demontrates *multiple dispatch*, a powerful technique for writing
    methods that are chosen based on the types of their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example A-7. Example 2: Multiple Dispatch'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The example begins by creating a `color` class ![](httpatomoreillycomsourcenostarchimages783564.png)
    and also defines three derived classes: `red`, `green`, and `blue` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we declare a `mix` method, which will tell us what happens if we mix any
    two colors. By default, when we mix two colors, it just says, “I don’t know what
    color that makes” ![](httpatomoreillycomsourcenostarchimages783560.png). However,
    using multiple dispatch, *we can define more versions* of the `mix` method. For
    instance, we can declare a version that mixes blue and yellow ![](httpatomoreillycomsourcenostarchimages783554.png),
    and another version for yellow and red ![](httpatomoreillycomsourcenostarchimages783510.png).
    Here’s what happens when we call these methods with different colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to note about the example is that in order to figure out
    which mix method to call in a given situation, the CLOS needs to take into account
    both of the objects passed into the method. It is *dispatching* to a specific
    implementation of the method based on the types of *multiple* objects. This is
    a feature that is not available in traditional object-oriented languages, such
    as Java or C++.
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Opinions vary widely in the Lisp community as to how large a role object-oriented
    techniques should play in programming. The critics of this style complain that
    object-oriented techniques force data to be hidden away in lot of disparate places
    by requiring them to live inside many different objects. Having data located in
    disparate places can make programs difficult to understand, especially if that
    data changes over time. Therefore, many Lispers prefer to use functional techniques
    over object-oriented techniques, though the two can often be used together with
    some care. Nonetheless, there are still many domains in which object-oriented
    techniques are invaluable, such as in user interface programming or simulation
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780010.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Continuation Guild Rocket Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Scheme (limited support in Common Lisp with *continuation-passing style*, or
    through the use of special libraries)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783034.png)'
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the 1970s, a special dialect of Lisp was created that featured a particularly
    powerful programming feature called *continuations*. Basically, continuations
    let you put “time travel” into your code. This allows you to do things like run
    programs backward, sideways, or in other crazy ways. For instance, it’s great
    for implementing advanced programming techniques, such as *nondeterministic programming*.
    In nondeterministic programming, you write code that offers the computer multiple
    choices for what to do next. If one choice isn’t satisfactory, the computer can
    “roll back time” with continuations to try a different path.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-8. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Scheme Lisp dialect and won’t run in Common Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many situations where having time travel in your code can make the
    code easier to understand. The classic example is in a web server. Often, a person
    must visit several pages on a web page in order to perform a single action. With
    a continuation-aware web server, you can write code that pretends these pages
    were visited all at the same time, making your code a lot less buggy. Later on,
    the web server uses continuations to break your code into several parts (by using
    the time-travel abilities of continuations), taking care of all the ugly details
    of handling a multipage web action.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example, we create a simple function called `foo` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds one to a number, and then doubles it. For instance, running `(foo 7)`
    will return `16`. However, inside the function, there is a call to `call-with-current-continuation`
    ![](httpatomoreillycomsourcenostarchimages783562.png), which captures the state
    of the function before the doubling step. It saves this “moment in time” in the
    variable `continuation` ![](httpatomoreillycomsourcenostarchimages783560.png).
    The current state of the running program is captured at this line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Everything that happens *after* the continuation was captured will then be executed
    if we call the captured continuation. The only part of the `foo` command that
    happens after the continuation was captured is the multiplication by two ![](httpatomoreillycomsourcenostarchimages783554.png).
    Consequently, the variable `continuation` is now a time machine that we can use
    to jump into this past moment to switch out the number we want to double with
    another one. So, if we were to now call `(continuation 100)`, it would return
    200 (which is 100 doubled). We have traveled backward in time!
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuations are such an awesome feature that they don’t really have a downside.
    The only real problem they present is for creators of programming languages. True
    continuations are technically difficult to put into a programming language, so
    few languages support them. Scheme happens to be one of them. To learn more about
    continuation-based web servers, see “Implementation and Use of the PLT Scheme
    Web Server”by Shriram Krishnamurthi, et al.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782118.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782166.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781552.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781592.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Brevity Guild Micro Fighter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Arc Lisp (indirectly available in Common Lisp using custom macros)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779769.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lisp allows you to write code that is incredibly concise but doesn’t look like
    your cat walked over your keyboard. (I’m looking at you, Perl!) This is possible
    because of the various features we’ve already mentioned, such as macros, functional
    programming, and Lisp’s dynamic typing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one Lisp dialect, however, that takes this idea to the extreme: Arc.
    In fact, code brevity is the primary design goal for this language. Paul Graham,
    the designer of Arc, analyzed large amounts of computer code in an attempt to
    figure out which primitive commands are needed to write code that is as concise
    as possible, while keeping the code readable.'
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Arc, the goal is to write programs that are short. It is designed to let
    you say what you want to say in the most concise way possible, leaving no place
    for bugs to hide.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-9. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Arc Lisp dialect and won’t run in Common Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example creates a list of all prime numbers between 1 and 1000, using the
    naïve method of checking for smaller numbers that divide evenly into the current
    loop value.
  prefs: []
  type: TYPE_NORMAL
- en: The `accum` function creates a local function named `a`, which is used to collect
    any primes that are found ![](httpatomoreillycomsourcenostarchimages783564.png).
    We iterate through the integers with a `for` loop ![](httpatomoreillycomsourcenostarchimages783562.png),
    checking for smaller numbers that divide evenly into the current value of `i`
    ![](httpatomoreillycomsourcenostarchimages783560.png). If none are are found,
    `i` is added to the list of primes ![](httpatomoreillycomsourcenostarchimages783554.png),
    by calling the function `a` with this new number. The brackets, `[ ]`, are a shortcut
    for creating a lambda function with one parameter, which is accessed with the
    underscore character.
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding an optimally concise set of commands is difficult. With too many commands
    available, your code can become hard to understand, since it’s difficult to remember
    what each function does. With too few commands, programs can get too bulky. Arc
    Lisp tries to find a happy medium, although there’s still room for alternative
    language designs optimized for code brevity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros") demonstrates
    how to use macros to make your code concise, and many other examples of Lisp’s
    powers of brevity are shown in the chapters following that discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781032.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multicore Guild Formation Fighters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lisp Dialect**'
  prefs: []
  type: TYPE_NORMAL
- en: Clojure Lisp (available in Common Lisp with the CL-STM extension)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783054.png)'
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that most computers have multiple cores, there is a lot of interest in finding
    elegant ways to write multicore/multithreaded code. One popular approach is to
    use functional data structures along with a *software transactional memory* system.
  prefs: []
  type: TYPE_NORMAL
- en: Using software transactional memory, you can share complex data structures between
    several threads, with a guarantee that no thread will see inconsistent information
    in the data, even if it tries to read shared data while another thread is attempting
    to write to it.
  prefs: []
  type: TYPE_NORMAL
- en: How It Fights Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multithreaded code tends to be very buggy. By using software transactional memory,
    you can greatly increase your odds of writing bug-free multithreaded software.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we define two bank accounts called `checking` and `savings`
    ![](httpatomoreillycomsourcenostarchimages783564.png), with a total amount of
    $300 between them. We then define a `transfer-to-savings` function, which can
    be called to move money from the `checking` account to the `savings` account ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Example A-10. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Because this function contains a `dosync` block, Clojure will make sure these
    two `alter` operations ![](httpatomoreillycomsourcenostarchimages783560.png) happen
    at the same moment in time. Of course, both values aren’t really altered at the
    exact same point in time, but the language makes sure it will appear to happen
    simultaneously. If another thread were to read these two accounts at the same
    time, also within a `dosync` block, it would see exactly $300 in the combined
    accounts, no matter how many times either thread checks these values.
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software transactional memory carries a performance penalty that cancels out
    some of the performance gains that come with using multiple CPU cores. However,
    as the number of CPU cores increases, this penalty is less of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: The Lazy Guild Frigate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lisp Dialect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure (available in Common Lisp with the Series library, CLAZY library, or
    custom macros)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783350.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lazy programming language will perform a calculation *only* if the compiler
    determines it is absolutely necessary to produce a visible result. Clojure is
    the most popular Lisp dialect to include lazy programming as a primary feature.
    However, limited forms of lazy programming are common in all Lisp dialects.
  prefs: []
  type: TYPE_NORMAL
- en: How It Kills Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy languages let you create infinitely big data structures (as long as you
    don’t try to use *all* of the data), which allows more of your code to be formulated
    as transformations of large data structures. In general, it is easier to debug
    data structures than it is to debug algorithms. Algorithms involve steps that
    unfold over time, and to understand them, you usually need to watch them as they
    execute. Data, on the other hand, exists independently of time, which means you
    can find bugs in a data structure just by looking at it.
  prefs: []
  type: TYPE_NORMAL
- en: Example A-11. Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code returns the first 20 even positive integers. To do this, it first
    creates an infinite list of all positive integers ![](httpatomoreillycomsourcenostarchimages783560.png),
    using the `iterate` function to create a list of integers starting at zero. Then
    it filters out the even numbers ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it takes the first 20 numbers from that result ![](httpatomoreillycomsourcenostarchimages783564.png).
    Until the final `take` command, the data structures being operated on are theoretically
    infinite. However, since Clojure is a lazy language, it instantiates these data
    structures only on an as-needed basis. This means that only the first 20 such
    numbers are ever generated. (And even then, they are generated only if we actually
    use the final value somehow, such as printing it to the screen.)
  prefs: []
  type: TYPE_NORMAL
- en: Weakness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a lazy programming language chooses the order in which your code is run,
    it can lead to debugging headaches if you try to trace your code as it is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch20.html "Chapter 18. Lazy Programming") discusses lazy programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782876.png.jpg)'
  prefs: []
  type: TYPE_IMG
