["```\n#include <sys/param.h>\n#include <sys/bus.h>\n\nint\nbus_setup_intr(device_t dev, struct resource *r, int flags,\n    driver_filter_t filter, driver_intr_t ithread, void *arg,\n    void **cookiep);\n\nint\nbus_teardown_intr(device_t dev, struct resource *r, void *cookiep);\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/malloc.h>\n\n#include <machine/bus.h>\n#include <sys/rman.h>\n#include <machine/resource.h>\n\n#include <dev/ppbus/ppbconf.h>\n#include \"ppbus_if.h\"\n#include <dev/ppbus/ppbio.h>\n\n#define PINT_NAME               \"pint\"\n#define BUFFER_SIZE             256\n\nstruct pint_data {\n        int                     sc_irq_rid;\n        struct resource        *sc_irq_resource;\n        void                   *sc_irq_cookie;\n        device_t                sc_device;\n        struct cdev            *sc_cdev;\n        short                   sc_state;\n#define PINT_OPEN               0x01\n        char                   *sc_buffer;\n        int                     sc_length;\n};\n\nstatic d_open_t                 pint_open;\nstatic d_close_t                pint_close;\nstatic d_read_t                 pint_read;\nstatic d_write_t                pint_write;\n\nstatic struct cdevsw pint_cdevsw = {\n        .d_version =            D_VERSION,\n        .d_open =               pint_open,\n        .d_close =              pint_close,\n        .d_read =               pint_read,\n        .d_write =              pint_write,\n        .d_name =               PINT_NAME\n};\n\nstatic devclass_t pint_devclass;\n\nstatic int\npint_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n        int error;\n\n        ppb_lock(ppbus);\n\n        if (sc->sc_state) {\n                ppb_unlock(ppbus);\n                return (EBUSY);\n        } else\n                sc->sc_state |= PINT_OPEN;\n\n        error = ppb_request_bus(ppbus, pint_device, PPB_WAIT | PPB_INTR);\n        if (error) {\n                sc->sc_state = 0;\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n        ppb_wctr(ppbus, 0);\n        ppb_wctr(ppbus, IRQENABLE);\n\n        ppb_unlock(ppbus);\n        return (0);\n}\n\nstatic int\npint_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n\n        ppb_lock(ppbus);\n\n        ppb_wctr(ppbus, 0);\n        ppb_release_bus(ppbus, pint_device);\n        sc->sc_state = 0;\n\n        ppb_unlock(ppbus);\n        return (0);\n}\n\nstatic int\npint_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        int amount, error = 0;\n\n        amount = MIN(uio->uio_resid,\n            (BUFFER_SIZE - 1 - uio->uio_offset > 0) ?\n             BUFFER_SIZE - 1 - uio->uio_offset : 0);\n        if (amount == 0)\n                return (error);\n\n        error = uiomove(sc->sc_buffer, amount, uio);\n        if (error) {\n                device_printf(pint_device, \"write failed\\n\");\n                return (error);\n        }\n\n        sc->sc_buffer[amount] = '\\0';\n        sc->sc_length = amount;\n\n        return (error);\n}\n\nstatic int\npint_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n        int amount, error = 0;\n\n        ppb_lock(ppbus);\n        error = ppb_sleep(ppbus, pint_device, PPBPRI | PCATCH, PINT_NAME, 0);\n        ppb_unlock(ppbus);\n        if (error)\n                return (error);\n\n        amount = MIN(uio->uio_resid,\n            (sc->sc_length - uio->uio_offset > 0) ?\n             sc->sc_length - uio->uio_offset : 0);\n\n        error = uiomove(sc->sc_buffer + uio->uio_offset, amount, uio);\n        if (error)\n                device_printf(pint_device, \"read failed\\n\");\n\n        return (error);\n}\n\nstatic void\npint_intr(void *arg)\n{\n        struct pint_data *sc = arg;\n        device_t pint_device = sc->sc_device;\n\n#ifdef INVARIANTS\n        device_t ppbus = device_get_parent(pint_device);\n        ppb_assert_locked(ppbus);\n#endif\n\n        wakeup(pint_device);\n}\n\nstatic void\npint_identify(driver_t *driver, device_t parent)\n{\n        device_t dev;\n\n        dev = device_find_child(parent, PINT_NAME, −1);\n        if (!dev)\n                BUS_ADD_CHILD(parent, 0, PINT_NAME, −1);\n}\n\nstatic int\npint_probe(device_t dev)\n{\n        /* probe() is always OK. */\n        device_set_desc(dev, \"Interrupt Handler Example\");\n\n        return (BUS_PROBE_SPECIFIC);\n}\n\nstatic int\npint_attach(device_t dev)\n{\n        struct pint_data *sc = device_get_softc(dev);\n        int error, unit = device_get_unit(dev);\n\n        /* Declare our interrupt handler. */\n        sc->sc_irq_rid = 0;\n        sc->sc_irq_resource = bus_alloc_resource_any(dev, SYS_RES_IRQ,\n            &sc->sc_irq_rid, RF_ACTIVE | RF_SHAREABLE);\n\n        /* Interrupts are mandatory. */\n        if (!sc->sc_irq_resource) {\n                device_printf(dev,\n                    \"unable to allocate interrupt resource\\n\");\n                return (ENXIO);\n        }\n\n        /* Register our interrupt handler. */\n        error = bus_setup_intr(dev, sc->sc_irq_resource,\n            INTR_TYPE_TTY | INTR_MPSAFE, NULL, pint_intr,\n            sc, &sc->sc_irq_cookie);\n        if (error) {\n                bus_release_resource(dev, SYS_RES_IRQ, sc->sc_irq_rid,\n                    sc->sc_irq_resource);\n                device_printf(dev, \"unable to register interrupt handler\\n\");\n                return (error);\n        }\n\n        sc->sc_buffer = malloc(BUFFER_SIZE, M_DEVBUF, M_WAITOK);\n\n        sc->sc_device = dev;\n        sc->sc_cdev = make_dev(&pint_cdevsw, unit, UID_ROOT, GID_WHEEL, 0600,\n            PINT_NAME \"%d\", unit);\n        sc->sc_cdev->si_drv1 = sc;\n\n        return (0);\n}\n\nstatic int\npint_detach(device_t dev)\n{\n        struct pint_data *sc = device_get_softc(dev);\n\n        destroy_dev(sc->sc_cdev);\n\n        bus_teardown_intr(dev, sc->sc_irq_resource, sc->sc_irq_cookie);\n        bus_release_resource(dev, SYS_RES_IRQ, sc->sc_irq_rid,\n            sc->sc_irq_resource);\n\n        free(sc->sc_buffer, M_DEVBUF);\n\n        return (0);\n}\n\nstatic device_method_t pint_methods[] = {\n        /* Device interface. */\n        DEVMETHOD(device_identify,      pint_identify),\n        DEVMETHOD(device_probe,         pint_probe),\n        DEVMETHOD(device_attach,        pint_attach),\n        DEVMETHOD(device_detach,        pint_detach),\n        { 0, 0 }\n};\n\nstatic driver_t pint_driver = {\n        PINT_NAME,\n        pint_methods,\n        sizeof(struct pint_data)\n};\n\nDRIVER_MODULE(pint, ppbus, pint_driver, pint_devclass, 0, 0);\nMODULE_DEPEND(pint, ppbus, 1, 1, 1);\n```", "```\nstatic void\npint_identify(driver_t *driver, device_t parent)\n{\n        device_t dev;\n\n        dev = device_find_child(parent, PINT_NAME, −1);\n        if (!dev)\n                BUS_ADD_CHILD(parent, 0, PINT_NAME, −1);\n}\n```", "```\nstatic int\npint_probe(device_t dev)\n{\n        /* probe() is always OK. */\n        device_set_desc(dev, \"Interrupt Handler Example\");\n\n      return (BUS_PROBE_SPECIFIC);\n}\n```", "```\nstatic int\npint_attach(device_t dev)\n{\n        struct pint_data *sc = device_get_softc(dev);\n        int error, unit = device_get_unit(dev);\n\n        /* Declare our interrupt handler. */\n        sc->sc_irq_rid = 0;\n        sc->sc_irq_resource = bus_alloc_resource_any(dev, SYS_RES_IRQ,\n            &sc->sc_irq_rid, RF_ACTIVE | RF_SHAREABLE);\n\n        /* Interrupts are mandatory. */\n        if (!sc->sc_irq_resource) {\n                device_printf(dev,\n                    \"unable to allocate interrupt resource\\n\");\n              return (ENXIO);\n        }\n\n        /* Register our interrupt handler. */\n        error = bus_setup_intr(dev, sc->sc_irq_resource,\n            INTR_TYPE_TTY | INTR_MPSAFE, NULL, pint_intr,\n            sc, &sc->sc_irq_cookie);\n        if (error) {\n                bus_release_resource(dev, SYS_RES_IRQ, sc->sc_irq_rid,\n                    sc->sc_irq_resource);\n                device_printf(dev, \"unable to register interrupt handler\\n\");\n                return (error);\n        }\n\n        sc->sc_buffer = malloc(BUFFER_SIZE, M_DEVBUF, M_WAITOK);\n\n      sc->sc_device = dev;\n        sc->sc_cdev = make_dev(&pint_cdevsw, unit, UID_ROOT, GID_WHEEL,\n            0600, PINT_NAME \"%d\", unit);\n      sc->sc_cdev->si_drv1 = sc;\n\n        return (0);\n}\n```", "```\nstatic int\npint_detach(device_t dev)\n{\n        struct pint_data *sc = device_get_softc(dev);\n\n      destroy_dev(sc->sc_cdev);\n\n      bus_teardown_intr(dev, sc->sc_irq_resource, sc->sc_irq_cookie);\n      bus_release_resource(dev, SYS_RES_IRQ, sc->sc_irq_rid,\n            sc->sc_irq_resource);\n\n      free(sc->sc_buffer, M_DEVBUF);\n\n        return (0);\n}\n```", "```\nstatic int\npint_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n        int error;\n\n      ppb_lock(ppbus);\n\n      if (sc->sc_state) {\n                ppb_unlock(ppbus);\n              return (EBUSY);\n        } else\n              sc->sc_state |= PINT_OPEN;\n\n        error = ppb_request_bus(ppbus, pint_device, PPB_WAIT | PPB_INTR);\n        if (error) {\n                sc->sc_state = 0;\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n      ppb_wctr(ppbus, 0);\n      ppb_wctr(ppbus, IRQENABLE);\n\n        ppb_unlock(ppbus);\n        return (0);\n}\n```", "```\nstatic int\npint_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n\n      ppb_lock(ppbus);\n\n      ppb_wctr(ppbus, 0);\n      ppb_release_bus(ppbus, pint_device);\n      sc->sc_state = 0;\n\n        ppb_unlock(ppbus);\n        return (0);\n}\n```", "```\nstatic int\npint_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        int amount, error = 0;\n\n        amount = MIN(uio->uio_resid,\n            (BUFFER_SIZE - 1 - uio->uio_offset > 0) ?\n             BUFFER_SIZE - 1 - uio->uio_offset : 0);\n        if (amount == 0)\n                return (error);\n\n        error = uiomove(sc->sc_buffer, amount, uio);\n        if (error) {\n                device_printf(pint_device, \"write failed\\n\");\n                return (error);\n        }\n\n        sc->sc_buffer[amount] = '\\0';\n        sc->sc_length = amount;\n\n        return (error);\n}\n```", "```\nstatic int\npint_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct pint_data *sc = dev->si_drv1;\n        device_t pint_device = sc->sc_device;\n        device_t ppbus = device_get_parent(pint_device);\n        int amount, error = 0;\n\n      ppb_lock(ppbus);\n        error = ppb_sleep(ppbus, pint_device, PPBPRI | PCATCH,\n            PINT_NAME, 0);\n        ppb_unlock(ppbus);\n        if (error)\n                return (error);\n\n        amount = MIN(uio->uio_resid,\n            (sc->sc_length - uio->uio_offset > 0) ?\n             sc->sc_length - uio->uio_offset : 0);\n\n        error = uiomove(sc->sc_buffer + uio->uio_offset, amount, uio);\n        if (error)\n                device_printf(pint_device, \"read failed\\n\");\n\n        return (error);\n}\n```", "```\nstatic void\npint_intr(void *arg)\n{\n        struct pint_data *sc = arg;\n        device_t pint_device = sc->sc_device;\n\n#ifdef INVARIANTS\n        device_t ppbus = device_get_parent(pint_device);\n        ppb_assert_locked(ppbus);\n#endif\n\n      wakeup(pint_device);\n}\n```", "```\n$ `sudo kldload ./pint.ko`\n$ `su`\nPassword:\n# `echo \"DON'T PANIC\" > /dev/pint0`\n# `cat /dev/pint0 &`\n[1] 954\n# `ps | head -n 1 && ps | grep \"cat\"`\n  PID  TT  STAT      TIME COMMAND\n  954  v1  I      0:00.03 cat /dev/pint0\n```", "```\n#include <sys/types.h>\n  #include <machine/cpufunc.h>\n\n  #include <err.h>\n  #include <fcntl.h>\n  #include <stdio.h>\n  #include <stdlib.h>\n  #include <unistd.h>\n\n #define BASE_ADDRESS    0x378\n\n  int\n  main(int argc, char *argv[])\n  {\n          int fd;\n\n          fd = open(\"/dev/io\", O_RDWR);\n          if (fd < 0)\n                  err(1, \"open(/dev/io)\");\n\n          outb(BASE_ADDRESS, 0x00);\n          outb(BASE_ADDRESS, 0xff);\n          outb(BASE_ADDRESS, 0x00);\n\n          close(fd);\n          return (0);\n  }\n```", "```\n# `echo \"DON'T PANIC\" > /dev/pint0`\n# `cat /dev/pint0 &`\n[1] 1056\n# `./tint`\nDON'T PANIC\n```"]