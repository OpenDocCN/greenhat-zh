<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page91"/><img src="../images/115-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter7"/><a href="toc.html#chapter7"><b>LADDIE EVENT HANDLING</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">Your appliance needs to respond when alarms or other critical events occur. Whether it’s CPU temperature, battery level, low disk space, or paper level, something is going to occur that requires action from your appliance.</p>&#13;
<p class="indent">The idea of having a general purpose event-handling system is, surprisingly, not common in Linux. Too often the need for event handling is not apparent until near the end of system testing of the appliance, so it is usually addressed as an afterthought—with ad hoc and poorly integrated code.</p>&#13;
<p class="indent">The authors have built enough Linux appliances to know that we should build event handling into the core of our design for Laddie. As part of the Laddie project, we built our own event-handling system that uses logging to capture the events of interest. Our event-handling daemon is called logmuxd, and this chapter explains why we built it, describes its features, presents its major tables, and gives complete examples of its use. This chapter may be of value even if you choose not to use logmuxd, since it shows the kinds of processing needed for any event-aware appliance.</p>&#13;
<p class="indent"><a id="page92"/>This chapter discusses event handling in the context of logging, but bear in mind that the goal is event handling, and logging is just the mechanism used to reach that goal.</p>&#13;
<p class="indent">We’ve organized this chapter into the following sections:</p>&#13;
<ul>&#13;
<li>Rationale for a New Event-Handling System</li>&#13;
<li>Features and Capabilities of logmuxd</li>&#13;
<li>Configuring logmuxd</li>&#13;
<li>Examples Using logmuxd</li>&#13;
</ul>&#13;
<p class="secl"><a id="chapter7.1"/><a href="toc.html#chapter7.1"><b>Rationale for a New Event-Handling System</b></a></p>&#13;
<p class="noindent">We’ve found that the only code we’ve ever delivered on time and bug free was code that we did not write. That is, our most successful projects were the ones in which we were most able to avoid writing new code. New code always has bugs, and new code is always late. Why, then, did we decide to write a logging daemon to do event handling? There are really two parts to the answer: why we chose to use logging as the mechanism, and why we chose not to use an existing logging system.</p>&#13;
<p class="indent">Chapter 6 explains why we think logging is the right mechanism for event reporting. All events that are of interest to us are already captured by, or can easily be captured by, syslog messages. There are syslog libraries for almost every programming language, and syslog is well understood, fairly secure, and is both CPU and memory efficient.</p>&#13;
<p class="indent">A distant second to syslog for event handling is D-Bus, an open source package often used to distribute desktop events. D-Bus offers libraries and an API that allows processes to exchange messages, provided that both processes are D-Bus aware. (Because of this, legacy applications that use syslog must be rewritten to add D-Bus support.) However, D-Bus does not offer the same breadth of languages that syslog offers, and D-Bus usually requires two running daemons, which makes it relatively RAM and CPU intensive (compared to syslog).</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>D-Bus comes standard on most Linux desktops, but it’s probably inappropriate for event handling on most Linux appliances.</i></p>&#13;
<p class="indent1">If syslog is the event reporting mechanism, then why not use the syslog daemon for event handling? The major feature that we found missing from the currently available logging systems was the ability to easily duplicate log messages and broadcast them on accepted TCP connections.</p>&#13;
<p class="indent">The Laddie Alarm System needs to have Laddie alarm messages routed to several running programs and UIs. Figure 7-1 illustrates a typical case. When an alarm occurs, ladd sends a log message to report the event. We need to send a copy of the resulting log message to every CLI that has logging enabled and to every web page that is looking at the system status. The problem is that we don’t know beforehand how many of each of these interfaces are open.</p>&#13;
<p class="indent">Our new logging daemon, logmuxd, solves this problem by allowing us to route messages to many destinations, even if those destinations are transitory. No other logging system supports multiple, transitory destinations. When ladd detects an alarm, it sends a log using syslog(); then logmuxd captures the event, rewrites it if needed, and multiplexes it out to each of the accepted TCP connections.</p>&#13;
<p class="imgc"><a id="page93"/><img src="../images/117-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 7-1: The need for a multiplexing log daemon</i></p>&#13;
<p class="indent">We decided to invest the time to build a new logging system for event handling because we wanted the ability to capture, rewrite, and route event reports from all applications and daemons on the appliance. As an appliance designer, you may find that your appliance needs to capture event reports from many sources and route the messages to many destinations. If so, you should consider using logmuxd in your appliance.</p>&#13;
<p class="secl"><a id="chapter7.2"/><a href="toc.html#chapter7.2"><b>Features and Capabilities of logmuxd</b></a></p>&#13;
<p class="noindent">We want logmuxd to work either with an existing syslogd installation or as a replacement for it. That is, we need to be able to read and write messages in the syslog style of angle brackets surrounding an integer. We want our logging daemon to support many types of input and many types of destinations, to be able to route based on a regex, and to be able to rewrite a log message before forwarding it on to its destination.</p>&#13;
<p class="indent">Each destination has its own set of routing and rewriting rules. This is similar to syslogd and means that you may have otherwise identical filters with the output of each filter going to a different destination.</p>&#13;
<p class="indent">Filters use the regex() library for pattern matching and for extracting relevant fields from the log messages. Messages can optionally be rewritten using the fields extracted from the regex pattern.</p>&#13;
<p class="indent">Figure 7-2 presents the overall architecture of logmuxd. In the next section we discuss each of the blocks in this diagram.</p>&#13;
<p class="imgc"><img src="../images/117-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 7-2: Architecture of logmuxd</i></p>&#13;
<p class="indent">The use of logmuxd might be easier to understand if we start with a list of its configuration tables<sup>1</sup> grouped according to the three processing blocks shown in Figure 7-2. Table 7-1 doesn’t describe all of the tables in detail, so you might want to use the RTA table editor to examine them more closely.</p>&#13;
<p class="tcap"><a id="page94"/><b>Table 7-1:</b> Configuration Tables Grouped According to Processing Block</p>&#13;
<p class="imgl"><img src="../images/118-1.jpg" alt=""/></p>&#13;
<p class="indent">logmuxd has several limitations. It does not have any flood filtering (for example, syslog’s “Last message repeated 10 billion times”). It uses regex, which gives it a lot of power and flexibility, but at the expense of CPU cycles. Finally, it is a relatively new logging daemon and is still in flux to a certain degree, as new features are added and as bugs are found and fixed.</p>&#13;
<p class="indent">You can overcome most of the limitations of logmuxd by pairing it with syslogd. Configure syslogd to output all messages to a FIFO, and configure logmuxd to read from the FIFO and to filter and rewrite only those few messages that you want to capture for further processing.</p>&#13;
<p class="secl"><a id="chapter7.3"/><a href="toc.html#chapter7.3"><b>Configuring logmuxd</b></a></p>&#13;
<p class="noindent">RTA tables store the configuration and statistics for logmuxd. The following discussion describes the tables, and the examples in the next section give the SQL for using them.</p>&#13;
<p class="secs"><a id="chapter7.4"/><a href="toc.html#chapter7.4"><i><b>logmuxd Sources</b></i></a></p>&#13;
<p class="noindent">You tell logmuxd about your event sources by describing them in the four editable fields in logmuxd’s MuxIn table. These fields are source, port, type, and term.</p>&#13;
<p class="indent">The <i>source</i> field contains the filename if the source is a file, pipe, or Unix socket, or the IP address if the source is a UDP or TCP socket.</p>&#13;
<p class="indent">The <i>port</i> field contains the port number for UDP and TCP sockets and is ignored for sources with an entry from a filesystem.</p>&#13;
<p class="indent">The <i>type</i> field specifies one of the six possible types for the source. Table 7-2 describes the six source types.</p>&#13;
<p class="tcap"><a id="page95"/><b>Table 7-2:</b> Six Possible Source Types</p>&#13;
<p class="imgl"><img src="../images/119-1.jpg" alt=""/></p>&#13;
<p class="indent">The <i>term</i> field specifies how the source terminates log messages. A zero indicates that log messages are terminated with a null character. Messages from syslog use a null terminator. A one indicates that each read() on the source will receive a complete message. This termination is used on UDP sockets, for example. A two indicates that a newline terminates the message. Newline termination is used for tail -f types of sources.</p>&#13;
<p class="indent">The MuxIn table also has read-only fields that hold usage statistics, error statistics, and the file descriptor for the source. For more information on these fields, use the RTA table editor to examine them on a running Laddie appliance.</p>&#13;
<p class="indent">Two other logmuxd tables are associated with message input processing. The Rawlog table acts as a FIFO to hold the 10 most recent messages. This is useful when debugging filters or monitoring the raw input to the logger. The Accpt table holds the file descriptor and other information needed by accepted TCP connections and by open Unix sockets. There are no configurable fields in either Rawlog or Accpt.</p>&#13;
<p class="secs"><a id="chapter7.5"/><a href="toc.html#chapter7.5"><i><b>logmuxd Filters and Rewriting</b></i></a></p>&#13;
<p class="noindent">One of the main reasons to use logmuxd is that it rewrites messages and forwards them on to another process. For example, when a user sets a test alarm in a zone, ladd sends the log message “User set alarm on zone <i>n, zone_name”</i> (where <i>n</i> and <i>zone_name</i> are replaced by the zone number and user-assigned name). We want this log message to appear on the front panel LCD display, but the LCD display can only display 16 characters, so we use the rewriting capability of logmuxd to rewrite the message to fit on the LCD display. The original message is rewritten from this:</p>&#13;
<p class="ex">Aug 12 22:28:31 ladd[3820]: User set alarm on zone 5, Refrigerator</p>&#13;
<p class="noindent1">to this:</p>&#13;
<p class="ex">22:28 Usr set 5</p>&#13;
<p class="indent">All of the configuration data to recognize and rewrite a log message is contained in the Filters table. This table contains the type and name of the destination, the regular expression to match, and an snprintf() format string for the rewritten message. Let’s look at each of these fields in turn.</p>&#13;
<p class="indent"><a id="page96"/>Two fields are used to specify the destination: <i>desttype</i> and <i>destname</i>. There is a separate table for each type of destination. This is necessary because, for example, an email destination needs different configuration information than an SNMP trap destination does. The type of the destination and its destination table are set by the desttype field. There are nine valid destination types. The types for 1 and 2 are not included in Table 7-3, since they are strictly source types.</p>&#13;
<p class="tcap"><b>Table 7-3:</b> The Nine Valid Destination Types</p>&#13;
<p class="imgl"><img src="../images/120-1.jpg" alt=""/></p>&#13;
<p class="indent">There can be several distinct destinations described in each of the destination tables. Each destination has its own unique name (a destname) in one of the destination tables. For example, if you have two different SNMP destinations, you may call one of them <i>allsnmp</i> and the other <i>laddiesnmp</i>. By giving them different names, you can define different routing and rewriting rules for them. To link a filter in the Filters table to a specific destination, you need to specify both the destination type and destination name.</p>&#13;
<p class="indent">Logmuxd routes messages based on the message’s facility, log level, and on a text pattern match. These three corresponding fields in the Filters table are <i>facility</i>, <i>level</i>, and <i>regex</i>. The facilities and log levels are the same as those defined for syslogd. The regex pattern is a regular expression used for both pattern matching and subpattern extraction.</p>&#13;
<p class="indent">The regex library is a good choice for pattern matching and extraction, since the patterns can be precompiled to improve the speed of the pattern match, and regex lets you easily extract subpatterns from the search pattern. In our use of logmuxd, we’ve found that we don’t really need to know too much about regex patterns. The following example illustrates most of what you need to know.</p>&#13;
<p class="indent">Say that you are processing the event of a train’s arrival at a station, and the log message is <i>Train from San Jose arriving on Track number 15</i>. To rewrite this message as <i>San Jose : 15</i>, you need to extract both the city and the track number. The regex pattern to capture the city is <i>[A-Za-z -]+</i>. This pattern matches any combination of at least one upper- or lowercase alphabetic character, a space, or a dash. The pattern for the track number is just <i>[0-9]+</i>. Here’s the trick: If you put parentheses around a pattern, regex makes that pattern available separately in the regex output. The following is a regex pattern to match the message and extract the city and train number.</p>&#13;
<p class="ex">Train from ([A-Za-z -]+) arriving on Track number ([0-9]+)</p>&#13;
<p class="indent"><a id="page97"/>The Filter table’s <i>rewrite</i> field contains the snprintf() format string used to rewrite the log message. The format string contains text of your choosing and can contain the strings extracted from the regex pattern. The matches to the regex patterns are available as explicit parameters to the snprintf(). Table 7-4 lists the parameters available to you.</p>&#13;
<p class="tcap"><b>Table 7-4:</b> Available Parameters to the snprintf()</p>&#13;
<p class="imgl"><img src="../images/121-1.jpg" alt=""/></p>&#13;
<p class="indent">Continuing the example above, you can get the message <i>San Jose : 15</i> with a rewrite format string of <i>%1$s : %2$s</i>.</p>&#13;
<p class="indent">You can add a date and time to your rewritten message by including <i>%11$s</i> in your rewrite string. The format of the date and time is set by the <i>time_fmt</i> field, which is passed to strftime() for the conversion. Common examples of time_fmt include <i>%F %T</i>, which gives a date and time display of <i>YYYY-MM-DD hh:mm:ss</i>, and <i>%R</i>, which displays only the time as <i>hh:mm</i>.</p>&#13;
<p class="indent">The explicit parameter for a newline is handy, since it can be difficult to get a newline character into an RTA table. Remember, to PostgreSQL, a \n is a two-character string with a backslash and the letter <i>n</i>.</p>&#13;
<p class="indent">We’ll show more examples of regex pattern matching and message rewriting in the section “Examples Using logmuxd” on page 98.</p>&#13;
<p class="secs"><a id="chapter7.6"/><a href="toc.html#chapter7.6"><i><b>logmuxd Destinations</b></i></a></p>&#13;
<p class="noindent">Each type of destination has a table to hold the parameters unique to that type. You can easily figure out most of the tables and their content by browsing them with the RTA table editor, but three destination tables deserve some additional comments.</p>&#13;
<p class="indent">The <i>MailDest</i> table has a <i>subject</i> field that contains the subject of the email message to send. The <i>to_list</i> field is a space-separated list of recipients of the email. For security reasons, the only characters allowed in to_list are alpha-numerics, periods, underscores, at signs (@), and spaces. If you are going to use email as a destination, be sure to run Sendmail, Postfix, or another mail transfer agent on your appliance.</p>&#13;
<p class="indent">The <i>SnmpDest</i> table contains the name of the destination, the IP address of the SNMP trap daemon, the community string for the SNMP daemon, the port number, and the type of trap to send (version 2 trap or version 2 inform). The values in these fields are passed as parameters to the snmptrap command, which actually sends the trap.</p>&#13;
<p class="indent"><a id="page98"/>The <i>TblDest</i> table holds 20 log messages, with the most recent message always at the top of the table. In Laddie we use this table to hold the log messages that we make visible to the end user.</p>&#13;
<p class="secl"><a id="chapter7.7"/><a href="toc.html#chapter7.7"><b>Examples Using logmuxd</b></a></p>&#13;
<p class="noindent">Let’s go over a few examples to help clarify how to use logmuxd.</p>&#13;
<p class="secs"><a id="chapter7.8"/><a href="toc.html#chapter7.8"><i><b>Example 1: A logmuxd Demonstration</b></i></a></p>&#13;
<p class="noindent">In the previous sections, you saw that one of the nice features of the Laddie Alarm System is that when an alarm occurs, all of the UIs are updated to reflect the new alarm and the new system status. This demonstration shows how to see the log messages that are distributed to all of the UIs.</p>&#13;
<ol>&#13;
<li>Boot the Laddie CD. After the system is up, verify that you can see Laddie’s web interface on the web browser of another PC.</li>&#13;
<li>On Laddie, logmuxd is configured to broadcast alarm system events down all accepted TCP connections to port 4444. Open a terminal window and telnet to port 4444 on the Laddie PC. For example:&#13;
<p class="ex">telnet 192.168.1.11 4444</p></li>&#13;
<li>Use the web interface to test a few zones, and then clear all the alarms. Your telnet session should display log messages similar to the ones below.&#13;
<p class="ex">2007-10-07 12:03:35 User set alarm on zone 2, Back Door<br/>2007-10-07 12:03:35<br/>Alarm system status: alarm 2007-10-07 12:03:37<br/>User set alarm on zone 3, Garage<br/>2007-10-07 12:03:38 User cleared alarm on zone 2, Back Door<br/>2007-10-07 12:03:40 User cleared alarm on zone 3, Garage<br/>2007-10-07 12:03:40 Alarm system status: safe</p>&#13;
</li>&#13;
</ol>&#13;
<p class="indent1">As simple as this example is, it shows logmuxd’s ability to multiplex log messages.</p>&#13;
<p class="secs"><a id="chapter7.9"/><a href="toc.html#chapter7.9"><i><b>Example 2: logmuxd and Accepted TCP Connections</b></i></a></p>&#13;
<p class="noindent">Our rationale for building a new logger was that we wanted the ability to open a TCP connection to the logging daemon and have log messages delivered to us over that connection. The last example showed us this ability in action, and in this example we see how to configure logmuxd to accept TCP connections. We use logmuxd to replace syslogd, the logger command to generate a “train arriving” message, and a telnet connection to logmuxd to view the rewritten log messages. In this example we are going to rewrite log messages of the form “Train arriving from <i>city_name</i> on track <i>track_number</i>” to the form “<i>city_name</i> : <i>track_number</i>”.</p>&#13;
<p class="indent"><a id="page99"/>You can copy the source from the CD and build logmuxd on your development system, or you can boot the Laddie CD and use its running version of logmuxd. Don’t worry about changing the logmuxd tables on Laddie, a reboot will restore them to their original state. We are going to use psql for the table updates, but you can also use the table editor, if you wish. Figure 7-3 illustrates the data flow in this example.</p>&#13;
<p class="imgc"><img src="../images/123-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 7-3: A logmuxd example using telnet</i></p>&#13;
<p class="indent">The basic steps in the configuration are:</p>&#13;
<ol>&#13;
<li>Configure logmuxd to accept syslog messages from /dev/log. Verify the setup.</li>&#13;
<li>Configure logmuxd to recognize and rewrite “train arriving” messages.</li>&#13;
<li>Configure logmuxd to accept TCP connections on port 3333.</li>&#13;
<li>Use logger and telnet to verify that messages are distributed to connections to TCP port 3333.</li>&#13;
</ol>&#13;
<p class="indent1">We start by clearing the configuration in all of the tables that we are going to use. Using the console or telnet, log in on the PC that is running logmuxd (the PC booted from the book’s CD). The RTA interface on logmuxd listens on port 8887; you can start the SQL session and clear the tables with these commands:</p>&#13;
<p class="imgl"><img src="../images/123-2.jpg" alt=""/></p>&#13;
<p class="secls"><b>MuxIn</b></p>&#13;
<p class="noindent">We want logmuxd to replace syslogd in this example, so we need to configure it to listen at the Unix socket /dev/log and to read log messages in the syslog style. We specify the source as /dev/log, the type as 6 (syslog format), and the log message terminator as 0 (null character between messages).</p>&#13;
<p class="ex">UPDATE MuxIn SET source = "/dev/log", type = <i>6,</i> term = 0 LIMIT 1;</p>&#13;
<p class="indent">If everything is working at this point, the above command opened a Unix socket on /dev/log, and a display of the MuxIn table should show a valid file descriptor for our source. (A netstat command should also show the /dev/log socket.)</p>&#13;
<p class="ex">SELECT source, fd FROM MuxIn;</p>&#13;
<p class="indent"><a id="page100"/>If we are now listening on /dev/log, we should be able to see log messages sent with logger. Open another terminal window and telnet into the PC running logmuxd a second time. Issue the following command in the new window:</p>&#13;
<p class="ex">logger "Hello, world!"</p>&#13;
<p class="indent">Verify that logmuxd received the message by looking at the Rawlog table.</p>&#13;
<p class="ex">SELECT source, log FROM Rawlog;</p>&#13;
<p class="secls"><b>Filters</b></p>&#13;
<p class="noindent">Continuing with the example, we are going to use the first row in Filters, but we are going to update it one or two columns at a time so that we can better explain just those columns.</p>&#13;
<p class="seca"><b>desttype</b></p>&#13;
<p class="bl">You may recall that the desttype is an integer that implicitly selects which of the destination tables this filter will use as its destination. A desttype of 3 is used for accepted TCP connections.</p>&#13;
<p class="seca"><b>destname</b></p>&#13;
<p class="bl">There may be multiple, independent destinations within a destination table. We need some way to distinguish one destination from another, so we give each destination a name. The destype in the Filter table selects which destination table to use, and the destname selects which row in that table to use. For this example we will assign a name of <i>example_2.</i></p>&#13;
<p class="exh">UPDATE Filters SET desttype = 3, destname = "example_2" LIMIT 1;</p>&#13;
<p class="seca"><b>regex</b></p>&#13;
<p class="bl">If we combine the regex pattern we built when we first looked at the train arrival example with some simple SQL, we get the command to set the regex pattern in our filter.</p>&#13;
<p class="exh">UPDATE Filters SET regex =<br/>"Train from ([A-Za-z -]+) arriving on Track number ([0-9]+)" LIMIT 1;</p>&#13;
<p class="seca"><b>level and facility</b></p>&#13;
<p class="bl">The logmuxd daemon routes based on the level and facility of the incoming log message. In this example we do not care which level and facility were used to send the message, so we set the level to a high value, and we clear the facility mask.</p>&#13;
<p class="exh">UPDATE Filters SET level = 15, facility = 0 LIMIT 1;</p>&#13;
<p class="indent"><a id="page101"/>At this point in our example, we can test the pattern-matching ability of our regex pattern. Use the terminal with the bash prompt to issue the following command.</p>&#13;
<p class="ex">logger "Train from Phoenix arriving on Track number 22"</p>&#13;
<p class="indent">Verify that the count of matches in our filter has gone up by one.</p>&#13;
<p class="ex">SELECT * FROM Filters LIMIT 1;</p>&#13;
<p class="indent">Repeat the above two steps a few times using different city names and track numbers. Issue a few logger commands where the pattern does not quite match, and verify that the count does not increment.</p>&#13;
<p class="noindent1"><b>rewrite</b></p>&#13;
<p class="bl">You may recall that the magic of regex patterns is that you can extract a subpattern by placing parenthesis around it. Here, we are extracting the city name and the track number and rewriting them as <i>city_name : track_number.</i> The regex subpatterns are available to the rewriting string as <i>%1$s to %9$s.</i> We want the first two patterns, and we want to add a newline to the output, so we set the rewrite string with the command:</p>&#13;
<p class="exh">UPDATE Filters SET rewrite = "%1$s : %2$s %12$s" LIMIT 1;</p>&#13;
<p class="indent">We are done with the Filters table and can now finish the configuration by editing the NetDest table.</p>&#13;
<p class="secls"><b>NetDest</b></p>&#13;
<p class="noindent">We want to set up a TCP socket listening on port 3333. Let’s give everyone on the network access to the port by binding to 0.0.0.0. The name of this network destination should be example_2, and the type of this network destination should be an accepted TCP connection, which is type 3:</p>&#13;
<p class="ex">UPDATE NetDest SET destname = "example_2", dest = "0.0.0.0", port = 3333, type = 3 LIMIT 1;</p>&#13;
<p class="indent">If all has gone well, there should be a listening socket on port 3333. Use netstat -nat to verify that the port is open and bound to the right address. Use the following SQL to see the file descriptor of the socket.</p>&#13;
<p class="ex">SELECT * FROM NetDest LIMIT 1;</p>&#13;
<p class="indent">We can now verify the whole system. Open a third terminal window and connect to port 3333. Your command might look something like this:</p>&#13;
<p class="ex">telnet 192.168.1.99 3333</p>&#13;
<p class="indent"><a id="page102"/>You should now be able to verify that logmuxd has accepted your telnet connection. Enter the following on the terminal, still at the psql prompt:</p>&#13;
<p class="ex">SELECT * FROM AccptDest;</p>&#13;
<p class="indent">It should all be working. Enter the following on a terminal with the bash prompt:</p>&#13;
<p class="ex">logger "Train from Phoenix arriving on Track number 22"<br/>logger "Train from San Jose arriving on Track number 15"<br/>logger "Train from San Francisco arriving on Track number 9"</p>&#13;
<p class="indent">Verify that the city and track number are extracted and displayed on the connection to port 3333. Your output should appear as:</p>&#13;
<p class="ex">Phoenix : 22<br/>San Jose : 15<br/>San Francisco : 9</p>&#13;
<p class="indent">This has been a long example, but it has illustrated both how to configure logmuxd and how to debug that configuration.</p>&#13;
<p class="secs"><a id="chapter7.10"/><a href="toc.html#chapter7.10"><i><b>Example 3: logmuxd and SNMP Traps</b></i></a></p>&#13;
<p class="noindent">The <i>Simple Network Management Protocol (SNMP)</i> is an Internet standard that is used to manage network devices such as routers. The protocol has commands to read and write values (GET and SET) as well as <i>traps,</i> which are its equivalent to log messages. Network appliances are often required to send SNMP traps when specific events occur. This example shows how to use logmuxd to translate syslog-style log messages into SNMP traps. (SNMP and traps are covered in detail in later chapters, and you might want to delay going through this example until after reading those chapters.)</p>&#13;
<p class="indent">The Laddie Alarm System sends SNMP trap messages when the system enters or leaves an alarm state. To send the SNMP traps, logmuxd uses a helper application, snmptrap. The snmptrap command sends SNMP traps in the same manner that logger sends syslog messages.</p>&#13;
<p class="indent">You may recall that ladd uses syslog to send logs similar to the following when a zone goes into alarm.</p>&#13;
<p class="ex">Alarm set on zone <i>2,</i> Back Door<br/>User set alarm on zone <i>3,</i> Garage</p>&#13;
<p class="indent">The snmptrap commands corresponding to the above two log messages are shown below.</p>&#13;
<p class="imgl"><img src="../images/126-1.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page103"/>In the above lines, <i>public</i> is the community name, and it comes from the SnmpDest table since it is specific to the destination. The same is true for <i>snmp_mgr:162,</i> which is the destination name (or IP address) and the port number used by snmptrapd. If the type field of SnmpDest is set to 3, a -Ci is added to the command, making it an SNMP version 2 <i>inform.</i> The SnmpDest fields for destination name, port, community string, and type of trap to send should all appear in your UI, since the end user must configure these with values that match the end user’s installation.</p>&#13;
<p class="indent">You can use the name of the trap if your MIB is installed and accessible to the snmptrap command. If the MIB is not installed, you need to put the full, numeric object ID (OID) of the trap on the command line. The two single quotes in the command line tell the snmptrap command to send the current uptime in the trap. Be sure to read the man page for snmptrap to learn more about the command and its options. The SNMP chapters in this book will answer many of your questions regarding SNMP and its event notification system, traps.</p>&#13;
<p class="indent">Information about the SNMP trap server comes from user information entered into the SnmpDest table. Some information for the traps must be extracted from the log messages. For example, to send our SNMP traps, we need to translate these:</p>&#13;
<p class="ex">Alarm set on zone <i>2,</i> Back Door<br/>User set alarm on zone <i>3,</i> Garage</p>&#13;
<p class="noindent">into these:</p>&#13;
<p class="ex">ladAlarm ladTrapZoneId i 2 ladTrapZoneName s "Back Door"<br/>ladTestAlarm ladTrapZoneId i 3 ladTrapZoneName s "Garage"</p>&#13;
<p class="indent">This is where regex pattern matching and rewriting come into play. Using the regex patterns given in the train station example above, you have everything you need to fill in the tables.</p>&#13;
<p class="indent">The destination type 9 indicates an SNMP destination, and the name we’ve given this destination is snmp_monitor. We need two rows from the Filters table, one row for the “User set” message that is sent when a user tests a zone, and another row for the “Alarm set” messages generated by real alarms. We use Filters rows 1 and 2 so that we don’t overwrite row 0, which was used in the previous example. We show the configuration here using SQL, but the table editor would work just as well.</p>&#13;
<p class="imgl"><img src="../images/127-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page104"/><img src="../images/128-1.jpg" alt=""/></p>&#13;
<p class="indent">The values in the SnmpDest table are specific to the network computer that is configured to receive the traps, so you should provide user access to these values from one or more of your UIs. (The Laddie web interface lets you specify where to send Laddie’s SNMP traps.) In this example we set the values manually using SQL. Let’s assume that the trap destination is on a network host named snmp_host.</p>&#13;
<p class="imgl"><img src="../images/128-2.jpg" alt=""/></p>&#13;
<p class="indent">You can test this configuration by running snmptrapd on one of your network hosts. (See Chapter 13 for details.)</p>&#13;
<p class="secl"><a id="chapter7.11"/><a href="toc.html#chapter7.11"><b>Summary</b></a></p>&#13;
<p class="noindent">Traditional logging handles an event by putting the report of the event (the log message) into one or more files on disk. A better approach is to examine each event individually and then decide how best to handle it. Making your appliance aware of events and able to respond to those events is one of the best things you can do for your customers.</p>&#13;
<p class="indent">In earlier chapters we showed you how to use the PostgreSQL protocol and API for control and status of your appliance. But control and status is only half of the solution—in this chapter we presented event handling, the other half of a successful appliance design.</p>&#13;
<p class="noindent1">__________________</p>&#13;
<p class="foot"><sup>1</sup> Other programming books might give configuration as a file format or set of subroutine calls. Instead, we present logmuxd configuration in terms of its RTA table interface. You should now think of all status and configuration information in terms of how it would appear in an RTA table.</p>&#13;
<p class="foot"><sup>2</sup> If the SNMP GET and SET commands correspond to the SQL SELECT and UPDATE commands, then the SNMP Management Information Base (MIB) corresponds to a database table.</p>&#13;
</div>&#13;
</body></html>