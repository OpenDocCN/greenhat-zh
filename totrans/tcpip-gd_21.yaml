- en: Part III-10. INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 87](ch87.html "Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION
    PROTOCOLS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING
    UTILITIES AND PROTOCOLS")'
  prefs: []
  type: TYPE_NORMAL
- en: File and message transfer applications include the File Transfer Protocol (FTP),
    electronic mail (email), and the World Wide Web, which makes file and message
    transfer the most important category of classic TCP/IP applications. However,
    those applications do not represent the only ways that TCP/IP internetworks are
    used. While not as glamorous as some of the application protocols we have examined
    so far in this section, interactive and administrative protocols are also important
    and worth understanding.
  prefs: []
  type: TYPE_NORMAL
- en: This final part of the book covers a couple other categories of TCP/IP applications.
    The first chapter describes interactive and remote application protocols, which
    are used traditionally to allow a user of one computer to access another, or to
    permit the real-time exchange of information. The second chapter discusses TCP/IP
    administration and troubleshooting utilities, which can be employed by both administrators
    and end users to manage TCP/IP networks and diagnose problems with them.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to TCP/IP applications, file and message transfer applications
    get the most attention, because they are the ones used most often on modern internetworks.
    Another category of TCP/IP application protocols that is less well known is the
    group that allows users to interactively access and use other computers directly
    over an internetwork, such as the public Internet. These applications are not
    often employed by end users today, but they are still important—both from a historical
    perspective and because of their usefulness in certain circumstances, especially
    to network administrators.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide a brief description of the classic interactive and
    remote application protocols used in TCP/IP. I first describe the Telnet Protocol,
    one of the earliest and most conceptually important application protocols in TCP/IP.
    This discussion includes a description of Telnet client/server communication,
    the Telnet Network Virtual Terminal (NVT), and Telnet's protocol commands and
    options. I then describe the Berkeley remote access family, often called the *r
    commands* or protocols because their command names begin with that letter. Finally,
    I provide a brief overview of the Internet Relay Chat (IRC) protocol, the original
    interactive chat application of the Internet and one still used widely today.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the very earliest days of internetworking, one of the most important problems
    that computer scientists needed to solve was how to allow someone operating one
    computer to access and use another as if that remote user were connected to it
    locally. The protocol created to meet this need was called *Telnet*, and the effort
    to develop it was tied closely to that of the Internet and TCP/IP as a whole.
    Even though most Internet users today never invoke the Telnet Protocol directly,
    they use some of its underlying principles indirectly all the time. Every time
    you send a piece of email, use the File Transfer Protocol (FTP) to transfer a
    file, or load a web page, you are using technology based on Telnet. For this reason,
    the Telnet Protocol can make a valid claim to the title of the most historically
    important application protocol in TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *A basic comprehension of the Transmission Control
    Protocol (TCP), especially its sliding window mechanism and flow control features,
    will be helpful in understanding Telnet. Those topics are covered in Chapters
    [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER")
    and [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES").*'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Overview, History, and Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The history of Telnet actually goes back over a decade before the modern TCP/IP
    protocol suite that we know today. As I mentioned in my overview of FTP, the early
    developers of TCP/IP internetworking technologies identified two overall application
    needs for networks to fill: enabling *direct access* to resources and also allowing
    *indirect access* to resources. FTP was created for indirect access, by allowing
    users to retrieve a resource from a remote host, use it locally, and if desired,
    copy it back to its source. Telnet was designed for direct access, by allowing
    users to access a remote machine and use it as if they were connected to it locally.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Telnet was initially developed in the late 1960s. This was well before the
    era of the small personal computers that so many of us use exclusively today.
    All computers of that period were large and usually shared by many users. To work
    on a computer, you had to access a physical terminal connected to that machine,
    which was usually specially tailored to the needs and requirements of the host.
    Two specific issues resulted from this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: If an organization had several different computers, each user needed a separate
    terminal to access each computer that he or she used. This was expensive and inefficient.
    I can recall reading a quote from a book that compared this situation to having
    a room containing a number of television sets, each of which could only display
    a single channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps a more significant issue was the difficulty in allowing a user at one
    site to access and use a machine at another site. The only method at the time
    for accomplishing this was to install a dedicated data circuit from the site of
    the computer to the site of the user, to connect the user's terminal to the remote
    machine. Again, each circuit would enable access to only one machine. Every combination
    of user and computer required a separate, expensive circuit to be installed and
    maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to both of these issues was to create a more general way of allowing
    any terminal to access any computer. The underlying internetwork provided the
    mechanism for communicating information between computers. This became the physical
    network connecting sites and the TCP/IP protocol suite connecting networks. On
    top of this ran an application protocol that allowed a user to establish a session
    to any networked computer and use it. That application protocol is Telnet.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet was the first application protocol demonstrated on the fledgling ARPAnet,
    in 1969\. The first RFC specifically defining Telnet was RFC 97, "First Cut at
    a Proposed Telnet Protocol," published in February 1971\. Development of Telnet
    continued throughout the 1970s, with quite a number of different RFCs devoted
    to revisions of the protocol and discussions of issues related to it. It took
    many years to refine Telnet and resolve all the difficulties that were associated
    with its development. The final version of the protocol, "Telnet Protocol Specification,"
    was published as RFC 854 in May 1983\. Over the years, other RFCs have been published
    to clarify the use of the protocol and address various issues such as authentication.
    There are also a number of other RFCs that define Telnet options, as discussed
    in the "Telnet Options and Option Negotiation" section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental Telnet Concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At first glance, it may be surprising that Telnet took so long to develop, because
    in theory, it should be a very simple protocol to define. All it needs to do is
    send keystrokes and program output over the network like any other protocol. Its
    definition would be simple if every terminal and computer used the same communication
    method, but they do not. Telnet becomes complicated because it needs to allow
    a terminal from one manufacturer to be able to talk to a computer that may use
    a very different data representation.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet solves this problem by defining a method that ensures compatibility between
    terminal types and computers, while allowing special features to be used by computers
    and terminals that agree to support them. The protocol is built on a foundation
    of three main concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Virtual Terminal (NVT)** Telnet defines a standardized, fictional
    terminal called the *Network Virtual Terminal (NVT)* that is used for universal
    communication by all devices. A Telnet client takes input from a user and translates
    it from its native form to the NVT format to send to a Telnet server running on
    a remote computer. The server translates from NVT to whatever representation the
    computer being accessed requires. The process is reversed when data is sent from
    the remote computer back to the user. This system allows clients and servers to
    communicate even if they use entirely different hardware and internal data representations.
    Special Telnet commands are interspersed with the data to allow the client and
    server devices to perform various functions needed to manage the operation of
    the protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Options and Option Negotiation** Having Telnet clients and servers act as
    NVTs avoids incompatibilities between devices, but does so by stripping all terminal-specific
    functionality to provide a common base representation that is understood by everyone.
    Since there are many cases where more intelligent terminals and computers may
    wish to use more advanced communication features and services, Telnet defines
    a rich set of options and a mechanism by which a Telnet client and server can
    negotiate their use. If the client and server agree on the use of an option, it
    can be enabled; if not, they can always fall back on the NVT to ensure basic communication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric Operation** While Telnet is a client/server protocol, it is specifically
    designed to not make assumptions about the nature of the client and server software.
    Once a Telnet session is established, the computers can each send and receive
    data as equals. They can also each initiate the negotiation of options. This makes
    the protocol extremely flexible and has led to its use in a variety of places,
    as discussed in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Telnet is most often associated with remote login, which is its common traditional
    use. A user typically uses a Telnet client program to open a Telnet connection
    to a remote server, which then treats the Telnet client like a local terminal,
    allowing the user to log in and access the server's resources as if he were using
    a directly attached terminal. Telnet is still used this way quite extensively
    by UNIX users, who often need to log in to remote hosts from their local machines
    (I use Telnet in this manner every day to access a machine hundreds of miles away).
    However, this use of Telnet is not nearly as common among the majority of Internet
    users who work on Windows or Apple computers, where network resources are accessed
    not through direct login, but by other means.
  prefs: []
  type: TYPE_NORMAL
- en: Although remote login is a big part of what Telnet is about, the protocol was
    not inherently designed for that specific function. When Telnet is used to access
    a remote device, the protocol itself is used only to set up the connection between
    the client and server machines, encode data to be transmitted according to the
    rules of the Telnet NVT, and facilitate the negotiation and use of options. The
    client and server devices decide whether Telnet is used for remote access or for
    some other purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility, combined with Telnet's age in the TCP/IP suite, has led to
    its being adopted for a variety of other protocols. Since Telnet doesn't make
    assumptions about what a client is and what a server is, any program or application
    can use it. Many of the file and message transfer applications—such as FTP, Simple
    Mail Transfer Protocol (SMTP), Network News Transfer Protocol (NNTP), and Hypertext
    Transfer Protocol (HTTP)—communicate by sending text commands and messages, and
    use Telnet's NVT specification to ensure the compatibility of communication between
    devices. They don't actually establish Telnet sessions or use features like option
    negotiation; they just send data in a manner consistent with how Telnet works.
    Thus, even though modern Internet users may never intentionally invoke Telnet
    specifically, they use it indirectly every time they send or receive email or
    browse the Web. Administrators can even use Telnet client software to access devices
    such as FTP and HTTP servers, and send those devices commands manually.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Telnet* is one of the oldest protocols in the TCP/IP suite,
    first developed in the 1960s to allow a user on one computer system to directly
    access and use another. It is most often used for remote login, with Telnet client
    software on a user''s machine establishing a session with a Telnet server on a
    remote host to let the user work with the host as if connected directly. To ensure
    compatibility between terminals and hosts that use different hardware and software,
    communication between Telnet client and server software is based on a simplified,
    fictional data representation, called the *Network Virtual Terminal (NVT)*, which
    can be enhanced through the negotiation of options.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Connections and Client/Server Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Telnet's overall function is to define a means by which a user or process on
    one machine can access and use another machine as if it were locally connected.
    This makes Telnet inherently client/server in operation, like so many other application
    protocols in TCP/IP. Usually, the Telnet client is a piece of software that acts
    as an interface to the user, processing keystrokes and user commands and presenting
    output from the remote machine. The Telnet server is a program running on a remote
    computer that has been set up to allow remote sessions.
  prefs: []
  type: TYPE_NORMAL
- en: TCP Sessions and Client/Server Communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Telnet is used for the interactive communication of data and commands between
    a client and server over a prolonged period of time, and is thus strongly based
    on the concept of a *session*. For this reason, Telnet runs over the connection-oriented
    Transmission Control Protocol (TCP). Telnet servers listen for connections on
    well-known TCP port number 23\. When a client wants to access a particular server,
    it initiates a TCP connection to the appropriate server, which responds to set
    up a TCP connection using the standard TCP three-way handshake (described in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")).'
  prefs: []
  type: TYPE_NORMAL
- en: The TCP connection is maintained for the duration of the Telnet session, which
    can remain alive for hours, days, or even weeks at a time. The quality of service
    features of TCP guarantee that data is received reliably and in order, and ensure
    that data is not sent at too high a rate for either client or server. A machine
    offering Telnet service can support multiple simultaneous sessions with different
    users, keeping each distinct by identifying it using the IP address and port number
    of the client.
  prefs: []
  type: TYPE_NORMAL
- en: Since TCP is a full-duplex protocol, both the client and server can send information
    at will over the Telnet session. By default, both devices begin by using the standard
    NVT method for encoding data and control commands (which we will explore fully
    a little later in this chapter). They can also negotiate the use of Telnet options
    to provide greater functionality for the session. While option negotiation can
    occur at any time, it is normal for there to be a burst of such option exchanges
    when a Telnet session is first established and only occasional option command
    exchanges thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: With the TCP connection in place and the Telnet session active, the client and
    server software begin their normal jobs of interfacing the user to the remote
    host. To the user, the Telnet session appears fundamentally the same as sitting
    down at a terminal directly connected to the remote host. In most cases, the server
    will begin the user's session by sending a login prompt to ask for a user name
    and password. The Telnet client will accept this information from the user and
    send it to the server. Assuming the information is valid, the user will be logged
    in and can use the host in whatever manner her account authorizes.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the Telnet overview, even though the protocol is commonly used
    for remote login, it does not need to be used in this manner. The administrator
    of the computer that is running the Telnet server determines how it is to be used
    on that machine. As just one example, a Telnet server can be interfaced directly
    to a process or program providing a service. I can recall years ago using an Internet
    server that provided weather information to the public using Telnet. After using
    the protocol to connect to that machine, users were presented not with a login
    prompt, but with a menu of weather display options. Today, the Web has replaced
    most of such facilities, as it is far better suited to this type of information
    retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Telnet is a client/server protocol that uses TCP to establish
    a session between a user terminal and a remote host. The Telnet client software
    takes input from the user and sends it to the server, which feeds it to the host
    machine''s operating system. The Telnet server takes output from the host and
    sends it to the client to display to the user. While Telnet is most often used
    to implement remote login capability, it is not specifically designed for logins.
    The protocol is general enough to allow it to be used for a variety of functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Use of Telnet to Access Other Servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Telnet NVT representation is used by a variety of other protocols such
    as SMTP and HTTP. This means that the same Telnet client that allows you to access
    a Telnet server can be used to directly access other application servers. All
    you need to do is specify the port number corresponding to the service. For example,
    the following command will allow you to directly interface to a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will not receive a login prompt, but instead the server will wait for you
    to send an HTTP Request message, as if you were a web browser. If you enter a
    valid request, the server will send you an HTTP Response message. Used in this
    way, Telnet can be very valuable as a diagnostic tool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Telnet Network Virtual Terminal (NVT) data representation
    has been adopted by a host of other TCP/IP protocols as the basis for their messaging
    systems. Telnet client software can thus be used not only to connect to Telnet
    servers, but also to connect to servers of protocols such as SMTP and HTTP, which
    is useful for diagnostic purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Communications Model and the Network Virtual Terminal (NVT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At its heart, Telnet is a rather simple protocol. Once a TCP connection is
    made and the Telnet session begins, the only real task for the client and server
    software is to capture input and output, and redirect it over the network. So,
    when the user presses a key on his local terminal, the Telnet client software
    captures it and sends it over the network to the remote machine. There, the Telnet
    server software sends the keypress to the operating system, which treats it as
    if it had been typed locally. When the operating system produces output, the process
    is reversed: Telnet server software captures the output and sends it over the
    network to the user''s client program, which displays it on the printer or monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: To invoke two well-known clichés, I could say that this looks good on paper,
    but that the devil is in the details. This simplified implementation would work
    only if every computer and terminal used the exact same hardware, software, and
    data representation. Of course, this is far from the case today, and was even
    worse when Telnet was being developed. Computers back in the "good old days" were
    highly proprietary and not designed to interoperate. They differed in numerous
    ways—from the type of keyboard a terminal used and the keystrokes it could send,
    to the number of characters per line and lines per screen on a terminal, to the
    character set used to encode data and control functions. In short, Computer A
    was designed to accept input in a particular form from its own terminals, and
    not those of Computer B.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a fairly common issue in the world of networking, and one to
    which I can draw a real-world analogy to help explain the problem and how it may
    be solved. Suppose that an important international conference was attended by
    30 ambassadors from different nations, each of which had one assistant. Every
    ambassador and assistant pair spoke only their own language and thus could only
    speak to each other—just like a computer and terminal designed to interface only
    to each other. To allow the assistant from one country to speak to the ambassador
    from the others, one solution would be to train the assistants to speak the languages
    of all the other attending nations. Back in the computing world, this would be
    like defining the Telnet Protocol so that every Telnet client software implementation
    understood how to speak to every computer in existence. This would work, but it
    would be quite impractical and difficult to do.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to define a single common language and have all the
    ambassadors and assistants learn it. While this would require some work, it would
    be a lot less than requiring people to learn dozens of languages. Each ambassador
    and assistant would speak both a native language and this chosen common language.
    Each could communicate with all of the others using this common language, without
    needing to know all of the languages that might be used by anyone at the conference.
    Even more important, if an ambassador and assistant showed up at the conference
    speaking a new, 31st language, all the other delegates wouldn't need to learn
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet uses a very similar approach for dealing with its problem of hardware
    and software compatibility. Rather than having terminals and hosts communicate
    using their various native languages, all Telnet clients and servers agree to
    send data and commands that adhere to a fictional, virtual terminal type call
    the NVT.
  prefs: []
  type: TYPE_NORMAL
- en: The NVT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NVT defines a set of rules for how information is formatted and sent, such
    as character set, line termination, and how information about the Telnet session
    itself is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Each Telnet client running on a terminal understands both its native language
    and the NVT language. When users enter information on their local terminal, it
    is converted to NVT form for transmission over the network. When the Telnet server
    receives this information, it translates it from NVT form to the format that the
    remote host expects to receive it. The identical process is performed for transmissions
    from the server to the client, in reverse. This is illustrated in [Figure 87-1](ch87.html#telnet_communication_and_the_network_vir
    "Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet
    uses the Network Virtual Terminal (NVT) representation to allow a user terminal
    and remote host that use different internal formats to communicate.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Telnet communication and the Network Virtual Terminal (NVT) Telnet uses the
    Network Virtual Terminal (NVT) representation to allow a user terminal and remote
    host that use different internal formats to communicate.](httpatomoreillycomsourcenostarchimages288325.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet
    uses the Network Virtual Terminal (NVT) representation to allow a user terminal
    and remote host that use different internal formats to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Telnet *Network Virtual Terminal (NVT)* is a uniform data
    representation that ensures the compatibility of communication between terminals
    and hosts that may use very different hardware, software, and data formats. The
    Telnet client translates user input from the terminal''s native form to NVT form
    for transport to the Telnet server, where it is converted to the host''s internal
    format. The process is reversed for output from the host to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: The NVT is defined to consist of a logical keyboard for input and a logical
    printer for output (the age of the protocol is reflected in these terms; decades
    ago there were no monitors, all output was on paper). NVT uses the 7-bit *United
    States ASCII (US-ASCII)* character set. Each character is encoded using one 8-bit
    byte.
  prefs: []
  type: TYPE_NORMAL
- en: However, a client and server can use Telnet options to negotiate other data
    representations, including the transmission of either extended ASCII or even full
    8-bit binary data.
  prefs: []
  type: TYPE_NORMAL
- en: NVT ASCII Control Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular ASCII consists of 95 regular, printable characters (codes 32 through
    126) and 33 control codes (0 through 31 and 127). The Telnet standard specifies
    that the output device must be able to handle all the printable characters, and
    it mandates how several of the other common ASCII control codes should be interpreted.
    Of these codes, three (0, 10, and 13) are required to be accepted by all Telnet
    software; five others are optional, but if supported, must be interpreted in a
    manner consistent with the Telnet specification. [Table 87-1](ch87.html#interpretation_of_standard_telnet_nvt_as
    "Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes") describes
    the standard Telnet NVT ASCII control codes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| ASCII Value (Decimal) | ASCII Character Code | ASCII Character | Description
    | Support Optional/Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | NUL | Null | No operation (no effect on output). | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | BEL | Bell | Produces an audible or visible signal on the output without
    moving the print head. This notification may be used to get the user''s attention,
    as in the case of an error. | Optional |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | BS | Backspace | Moves the print position one character to the left.
    | Optional |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | HT | Horizontal Tab | Moves the printer to the next horizontal tab stop.
    The standard does not specify how devices agree on tab stop positions; this can
    be negotiated using Telnet options. | Optional |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | LF | Line Feed | Moves the printer to the next line, keeping the print
    position the same. | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | VT | Vertical Tab | Moves the print line to the next vertical tab stop.
    As with the HT character, devices must use an option to come to an agreement on
    vertical tab stop positions. | Optional |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | FF | Form Feed | Moves the printer to the top of the next page (or on
    a display, clears the screen and positions the cursor at the top). | Optional
    |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | CR | Carriage Return | Moves the printer to the left margin of the current
    print line. | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: The Telnet NVT scheme defines the combination of the carriage return (CR) and
    line feed (LF) characters to represent the end of a line of ASCII text. The literal
    meaning of these two characters is return to the left margin (the CR) and go to
    the next line (the LF). However, NVT treats the CRLF sequence as more than just
    two independent characters; they are taken collectively to define a *logical end-of-line
    character*. This is necessary because not all terminal types define an end of
    line using both CR and LF. Translation of end-of-line characters between the native
    and NVT formats is one of the functions that Telnet client and server software
    must perform to ensure compatibility between terminals and hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Telnet NVT format is based on 7-bit US-ASCII, with each
    byte carrying one character. The standard specifies that devices must handle all
    standard printable ASCII characters, as well as three mandatory control characters.
    Two of these are the carriage return (CR) and line feed (LF) characters; when
    combined, these define the logical end of a line of text. The Telnet standard
    also describes the interpretation of five other optional ASCII control characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Half-Duplex and Full-Duplex Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another artifact of the age of Telnet is that for maximum compatibility, the
    NVT specification is designed under the assumption of half-duplex operation: only
    one device can transmit at a time. A device that is sending data is supposed to
    end its transmission with the special Telnet Go Ahead command, telling the other
    device that it may now transmit (the next section describes Telnet protocol commands).
    This is similar to how people using walkie-talkies end each transmission with
    "Over," to tell their partners that they may now respond.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, modern networks operate in a full-duplex mode, and using half-duplex
    communication would be needlessly inefficient. In most cases, the Telnet client
    and server agree to use an option (Suppress Go Ahead) that eliminates the need
    to send this command. However, having this as the default is a good example of
    how NVT acts as a least common denominator in Telnet, in case the simpler operating
    mode is needed by either device.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Protocol Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the input that users enter at a terminal takes the form of data and
    commands that are sent to the application program they are using. However, computer
    systems also provide a means by which users can instruct the terminal to send
    certain commands that control how the terminal itself operates, and how it interacts
    with the computer to which it is connected. The best example of this is the command
    to interrupt a process, which is usually sent by pressing a special key or key
    combination on the user terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Telnet needs to have a way to allow such commands to be entered by the user.
    However, here we run into the same problem that arises in the communication of
    data between terminals and computers: a lack of uniformity in representation.
    While all terminals and computers support the ability to interrupt a running program,
    for example, they may each use a different keystroke to invoke it. For example,
    on most UNIX systems, the key combination ctrl-C interrupts a program, but typing
    this on a Windows system will not (it usually represents the copy data function!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the problem is the same as the one we ran into in representing data flow,
    it''s not too surprising that the solution is the same: the use of a universal
    representation for a set of standard commands to be passed between the terminal
    and host computer. All keystrokes that represent these commands are translated
    to the standard Telnet codes for transmission, and then translated to the specific
    needs of the host computer. So, if a user presses ctrl-C on a UNIX terminal where
    this is defined as the interrupt function, instead of sending that exact keystroke,
    the Telnet client sends the special Telnet Interrupt Process command, which is
    translated by the Telnet server to the command code appropriate for the connected
    host.'
  prefs: []
  type: TYPE_NORMAL
- en: The Telnet standard includes a number of these special codes to allow a user
    to control the operation of the remote computer. It also defines a set of commands
    that are specific to the Telnet Protocol itself; these let the Telnet client and
    Telnet server software communicate. Collectively, these are called Telnet *protocol
    commands*.
  prefs: []
  type: TYPE_NORMAL
- en: All Telnet commands are sent in the same communication stream as regular data.
    They are represented using special byte values in the range from 240 to 254\.
    To differentiate between data bytes of these values and Telnet commands, every
    command is preceded by a special *escape character*, given the name *Interpret
    As Command (IAC)*. IAC has a value of 255; when the recipient sees this character,
    it knows the next byte is a command, not data. So, since the Telnet Interrupt
    Process command has the value 244, to send this command, the Telnet client would
    transmit the byte 255 and then 244\. If the actual data byte value 255 needs to
    be sent, it is transmitted as two 255 bytes. Some Telnet commands also include
    additional bytes of data, which are sent after the command code itself. A good
    example is the use of parameters in Telnet option negotiation, as you will see
    in the "Telnet Options and Option Negotiation" section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Telnet Protocol defines a set of *protocol commands* that
    are used for two purposes: first, to represent standard control functions that
    need to be sent between a terminal and host, such as the command to interrupt
    a process, and second, to enable protocol communication between the Telnet client
    and server software. Protocol commands are sent in the normal data communication
    stream over the Telnet session''s TCP connection. Each is represented by a byte
    value from 240 to 254, and is preceded by the Interpret As Command (IAC) command,
    byte value 255, which tells the recipient that the next byte in the stream is
    a command.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering at this point why the IAC character is needed at all. After
    all, Telnet uses US-ASCII, which is 7-bit data in the byte range of 0 to 127,
    and the Telnet commands have values higher than 127\. One general rationale for
    using the IAC escape character is to be explicit that a command is being sent.
    A more specific reason is to accommodate the optional sending of 8-bit binary
    data over Telnet, which the client and server can negotiate. If this mode were
    enabled and commands were not preceded by the IAC character, this would require
    all data bytes with values from 240 to 255 to be marked somehow so they would
    be interpreted as data and not commands. It is more efficient to include an extra
    byte for commands than data, since commands are sent less frequently. By escaping
    commands, only data byte value 255 requires two bytes to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 87-2](ch87.html#telnet_protocol_commands-id001 "Table 87-2. Telnet Protocol
    Commands") lists the Telnet protocol commands in numerical byte value order, showing
    for each its command code and name, and describing its meaning and use.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 87-2. Telnet Protocol Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Byte Value (Decimal) | Command Code | Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 240 | SE | Subnegotiation End | Marks the end of a Telnet option subnegotiation,
    used with the SB code to specify more specific option parameters. See the "Telnet
    Options and Option Negotiation" section later in this chapter for details. |'
  prefs: []
  type: TYPE_TB
- en: '| 241 | NOP | No Operation | Null command; does nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| 242 | DM | Data Mark | Used to mark the end of a sequence of data that the
    recipient should scan for urgent Telnet commands. See the discussion of Telnet
    interrupt handling in the following section for details. |'
  prefs: []
  type: TYPE_TB
- en: '| 243 | BRK | Break | Represents the pressing of the "break" or "attention"
    key on the terminal. |'
  prefs: []
  type: TYPE_TB
- en: '| 244 | IP | Interrupt Process | Tells the recipient to interrupt, abort, suspend,
    or terminate the process currently in use. |'
  prefs: []
  type: TYPE_TB
- en: '| 245 | AO | Abort Output | Instructs the remote host to continue running the
    current process but discard all remaining output from it. This may be needed if
    a program starts to send unexpectedly large amounts of data to the user. |'
  prefs: []
  type: TYPE_TB
- en: '| 246 | AYT | Are You There | May be used to check that the remote host is
    still "alive." When this character is sent, the remote host returns some type
    of output to indicate that it is still functioning. |'
  prefs: []
  type: TYPE_TB
- en: '| 247 | EC | Erase Character | Instructs the recipient to delete the last undeleted
    character from the data stream. Used to undo the sending of a character. |'
  prefs: []
  type: TYPE_TB
- en: '| 248 | EL | Erase Line | Tells the recipient to delete all characters from
    the data stream back to (but not including) the last end-of-line (CRLF) sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 249 | GA | Go Ahead | Used in Telnet half-duplex mode to signal the other
    device that it may transmit. |'
  prefs: []
  type: TYPE_TB
- en: '| 250 | SB | Subnegotiation | Marks the beginning of a Telnet option subnegotiation,
    used when an option requires the client and server to exchange parameters. See
    the "Telnet Options and Option Negotiation" section later in this chapter for
    a full description. |'
  prefs: []
  type: TYPE_TB
- en: '| 251 | WILL | Will Perform | In Telnet option negotiation, indicates that
    the device sending this code is willing to perform or continue performing a particular
    option. |'
  prefs: []
  type: TYPE_TB
- en: '| 252 | WONT | Won''t Perform | In Telnet option negotiation, indicates that
    the device sending this code is either not willing to perform a particular option
    or is now refusing to continue to perform it. |'
  prefs: []
  type: TYPE_TB
- en: '| 253 | DO | Do Perform | In Telnet option negotiation, requests that the other
    device perform a particular option or confirms the expectation that the other
    device will perform that option. |'
  prefs: []
  type: TYPE_TB
- en: '| 254 | DONT | Don''t Perform | In Telnet option negotiation, specifies that
    the other party not perform an option or confirms a device''s expectation that
    the other party not perform an option. |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | IAC | Interpret As Command | Precedes command values 240 through 254
    as described in the preceding descriptions. A pair of IAC bytes in a row represents
    the data value 255. |'
  prefs: []
  type: TYPE_TB
- en: Perhaps ironically, the Telnet commands are not used as much today as they were
    when Telnet was in its early days, because many of the compatibility issues that
    we discussed earlier no longer exist. ASCII has become the standard character
    set of the computing world, so many of the functions such as aborting output or
    interrupting a process no longer require the use of Telnet commands. They are
    still widely used, however, for internal Telnet operations such as option negotiation.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Interrupt Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the bytes of data sent from a Telnet client to a server are received in
    the order that they were sent, and vice versa. This is the way that we expect
    an application to operate. In fact, ensuring that data is not received out of
    order is one of the jobs that we assume of the reliable transport protocol TCP,
    over which Telnet runs. However, this can cause a problem for Telnet because of
    the way Telnet sends both data and commands over the same connection.
  prefs: []
  type: TYPE_NORMAL
- en: The most important case where this issue arises is when a user needs to interrupt
    a process. Suppose that you are using Telnet to run an interactive program that
    takes user input, processes it, and then produces output. You are merrily typing
    away when you notice that you haven't seen any output from the program for a while.
    It has apparently hung up due to a programming error or other glitch.
  prefs: []
  type: TYPE_NORMAL
- en: If you were using the program on a directly connected terminal, you would simply
    use the key or keystroke command appropriate to that terminal to interrupt or
    abort the process and restart it. Instead, you are using Telnet, so you enter
    the appropriate keystroke, which gets converted to the special Telnet Interrupt
    Process command code (byte value 244, preceded by the Telnet Interpret As Command
    code, 255).
  prefs: []
  type: TYPE_NORMAL
- en: Since Telnet uses only a single stream for commands and data, that code is placed
    into the TCP data stream to be sent over to the Telnet server. Since you were
    entering data for a while, that Telnet Interrupt Process code will be sitting
    behind a bunch of regular data bytes. Now the remote process has stopped reading
    this data, which means the TCP receive buffer on the server will start to fill
    up. The Interrupt Process command will thus remain stuck in the buffer, waiting
    to be read. In fact, if the number of data bytes in front of the command is high
    enough, the TCP buffer on the server may fill entirely, causing the server to
    close the client's TCP send window. This means the Interrupt Process command will
    wait in the client's outgoing TCP queue and *never* be sent to the remote host!
  prefs: []
  type: TYPE_NORMAL
- en: What we need here is some way to be able to flag the Interrupt Process command,
    so that it can be sent to the remote host regardless of the number of data bytes
    outstanding in front of it. If you've already perused the chapters devoted to
    TCP, you may be thinking that you have already read about a feature of that protocol
    that seems ideally suited for this exact problem, and you would be correct! The
    TCP urgent function (described in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE
    FORMATTING AND DATA TRANSFER")) allows an important piece of data to be marked
    so that it is given priority over regular data, a process sometimes called *out-of-band
    signaling* (because the signal is outside the normal data stream). Telnet uses
    this feature of TCP to define what it calls the *synch function*.
  prefs: []
  type: TYPE_NORMAL
- en: When needed, the synch function is invoked by the client sending the special
    Telnet Data Mark (DM) protocol command, while instructing its TCP layer to mark
    that data as urgent. The URG bit in the TCP segment carrying this command causes
    it to bypass TCP's normal flow control mechanism so it is sent over to the remote
    host. The Telnet server software, seeing the synch in the data stream, searches
    through all of the data in its buffer looking only for Telnet control commands
    such as Interrupt Process, Abort Output, and Are You There. These commands are
    then executed immediately. The server continues to search for important commands
    up to the point where the Data Mark command is seen. All intervening data is discarded;
    it will need to be retransmitted. After the Data Mark is processed, the server
    returns to normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible for the server to use the synch function in communication
    with the user on the client device. For example, if the user sends the Abort Output
    command to the server, she is telling the server to discard all remaining output
    from the current process. The server will stop sending that output, and can also
    use the synch function to clear all outstanding data that is waiting in buffers
    to be sent to the client machine (since it causes data to be discarded).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Telnet protocol commands are sent in the same stream with user
    data, which means a problem with the remote host that stops the flow of data might
    cause user commands to become backed up and never received by the host. Since
    this may include commands issued by the user to try to fix the problem on the
    host, this can be a serious problem. To alleviate this situation, Telnet includes
    the *synch function*, which uses TCP''s urgent data transmission feature to force
    the receipt of essential commands, even when regular data is not being processed.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Options and Option Negotiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic Telnet NVT specification solves the problem of compatibility between
    different terminal and computer types by defining a common representation for
    data and commands that every Telnet client and server uses. The price for this
    universal representation, however, is very high: All of the advanced or special
    capabilities of terminals and hosts are stripped off. The result is a language
    that everyone can speak but that is not capable of much more than basic conversation.'
  prefs: []
  type: TYPE_NORMAL
- en: The creators of Telnet recognized that, while it was important to define NVT
    as a common base to ensure cross-device compatibility, it was also essential that
    some means be provided by which clients and servers could agree to use more advanced
    means of communication. They defined a set of *Telnet options* and a mechanism
    by which a Telnet client and server can *negotiate* which options they want to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Most Telnet options are used for improving the efficiency of how data is transferred
    between devices. For example, by default, the NVT assumes half-duplex operation
    with each device, requiring it to use the Go Ahead command after each transmission.
    However, virtually all hardware now supports full-duplex communication, so devices
    will usually agree to use the Suppress Go Ahead option to eliminate the need to
    send this character. Similarly, it is possible for devices to negotiate the sending
    of 8-bit binary data instead of the standard 7-bit ASCII of the Telnet NVT.
  prefs: []
  type: TYPE_NORMAL
- en: The process of Telnet option negotiation is described in the main Telnet standard
    document, RFC 854, as well as a companion document, RFC 855, "Telnet Option Specifications."
    The options themselves are described in a separate set of Internet standards.
    Several of these were published at the same time as RFCs 854 and 855; others were
    defined earlier as part of previous versions of Telnet; and still others have
    been added over the years. There are now several dozen different Telnet options
    in existence. A master list is maintained by Internet Assigned Numbers Authority
    (IANA), just as it maintains other TCP/IP parameters. An up-to-date listing of
    all Telnet options can be found on the IANA website at [http://www.iana.org/assignments/telnet-options/](http://www.iana.org/assignments/telnet-options/).
  prefs: []
  type: TYPE_NORMAL
- en: Common Telnet Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each Telnet option is identified using a decimal byte code with a possible value
    of 0 to 254\. The value 255 is reserved to extend the option list should more
    than 255 options ever be needed. Each option also has a text code string associated
    with it, which is often used as a symbol in place of the code number in both protocol
    discussions and diagnostic output. [Table 87-3](ch87.html#common_telnet_options-id001
    "Table 87-3. Common Telnet Options") lists some of the more interesting Telnet
    options and provides a brief description of each.
  prefs: []
  type: TYPE_NORMAL
- en: Table 87-3. Common Telnet Options
  prefs: []
  type: TYPE_NORMAL
- en: '| Option Number | Option Code | Option Name | Description | Defining RFC |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | TRANSMIT-BINARY | Binary Transmission | Allows devices to send data in
    8-bit binary form instead of 7-bit ASCII. | 856 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | ECHO | Echo | Allows devices to negotiate any of a variety of different
    echo modes. (When you press a key on a terminal, you also expect to see the character
    you entered appear on the terminal screen as output; this is called echoing the
    input.) | 857 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | SUPPRESS-GO-AHEAD | Suppress Go Ahead | Allows devices not operating
    in half-duplex mode to no longer need to end transmissions using the Telnet Go
    Ahead command. | 858 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | STATUS | Status | Lets a device request the status of a Telnet option.
    | 859 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | TIMING-MARK | Timing Mark | Allows devices to negotiate the insertion
    of a special timing mark into the data stream, which is used for synchronization.
    | 860 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | NAOCRD | Output Carriage Return Disposition | Lets the devices negotiate
    how carriage returns will be handled. | 652 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | NAOHTS | Output Horizontal Tab Stops | Allows the devices to determine
    what horizontal tab stop positions will be used for output display. | 653 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | NAOHTD | Output Horizontal Tab Stop Disposition | Allows the devices
    to negotiate how horizontal tabs will be handled and by which end of the connection.
    | 654 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | NAOFFD | Output Form Feed Disposition | Allows the devices to negotiate
    how form feed characters will be handled. | 655 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | NAOVTS | Output Vertical Tab Stops | Used to determine what vertical
    tab stop positions will be used for output display. | 656 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | NAOVTD | Output Vertical Tab Disposition | Lets devices negotiate the
    disposition of vertical tab stops. | 657 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | NAOLFD | Output Line Feed Disposition | Allows devices to decide how
    line feed characters should be handled. | 658 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | EXTEND-ASCII | Extended ASCII | Lets devices agree to use extended ASCII
    for transmissions and negotiate how it will be used. | 698 |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | TERMINAL-TYPE | Terminal Type | Allows the client and server to negotiate
    the use of a specific terminal type. If they agree, this allows the output from
    the server to be ideally customized to the needs of the particular terminal the
    user is using. | 1091 |'
  prefs: []
  type: TYPE_TB
- en: '| 31 | NAWS | Negotiate About Window Size | Permits communication of the size
    of the terminal window. | 1073 |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | TERMINAL-SPEED | Terminal Speed | Allows devices to report on the current
    terminal speed. | 1079 |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | TOGGLE-FLOW-CONTROL | Remote Flow Control | Allows flow control between
    the client and the server to be enabled and disabled. | 1372 |'
  prefs: []
  type: TYPE_TB
- en: '| 34 | LINEMODE | Line Mode | Allows the client to send data one line at a
    time instead of one character at a time. This improves performance by replacing
    a large number of tiny TCP transmissions with a smaller number of larger ones.
    | 1184 |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | AUTHENTICATION | Authentication | Lets the client and server negotiate
    a method of authentication to secure connections. | 1416 |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Telnet NVT specification ensures that all devices using
    Telnet can talk to each other, but accomplishes this communication at the lowest
    level. To allow the use of more sophisticated formats and services, Telnet defines
    a number of *options*. If a client and server both implement a particular option,
    they can enable its use through a process of *negotiation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Option Negotiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first stage in Telnet option negotiation is for the client and server to
    decide whether they want to enable a particular option. One of the aspects of
    Telnet's symmetry of operation is that either device may choose to initiate the
    use of an option. The initiating device may either specify that it wants to start
    using an option or that it wants the other device to start using it. The responding
    device may agree or disagree. An option can be enabled only if both devices agree
    to its use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This negotiation is performed using four Telnet protocol commands: WILL, WONT,
    DO, and DONT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify that it wants to start using an option, the initiator sends the
    WILL command to the other device. There are two possible replies by the responding
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DO** Sent to indicate agreement that the initiator should use the option;
    it is then considered enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DONT** Sent to specify that the initiator must not use the option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the initiator wants the other device to start using an option, it sends
    the DO command. That device may respond in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WILL** Sent to specify that the responding device will agree to use the option;
    the option is enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WONT** Sent to tell the initiator that the responder will not use the option
    requested.'
  prefs: []
  type: TYPE_NORMAL
- en: The symmetry of Telnet and the fact that both DO and WILL can be used either
    to initiate a negotiation or respond to one make Telnet's option negotiation potentially
    complicated. Since either device can initiate negotiation of an option at any
    time, this could result in acknowledgment loops if both devices were to try to
    enable an option simultaneously or each kept responding to the other's replies.
    For this reason, the Telnet standard specifies restrictions on when the WILL and
    DO commands are used. One is that a device may send a negotiation command only
    to request a change in the status of an option; it cannot send DO or WILL just
    to confirm or reinforce the current state of the option. Another is that a device
    receiving a request to start using an option it is already using should not acknowledge
    it using DO or WILL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an option may be activated only if both devices agree to use it, either
    may disable the use of an option at any time by sending one of these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WONT** Sent by a device to indicate that it is going to stop using an option.
    The other device must respond with DONT as a confirmation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DONT** Sent by a device to indicate that it wants the other device to stop
    using an option. The other device must respond with WONT.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Either device may choose to negotiate the use of a Telnet option.
    The initiator uses the WILL command to specify that it wants to start using a
    particular option; if the other device agrees, it responds with DO; otherwise,
    it sends DONT. Alternatively, the initiator can use the DO command to indicate
    that it wants the other device to start using an option; that device responds
    with WILL if it agrees to do so or WONT if it does not. Either device may disable
    the use of an option at any time by sending the other a WONT or DONT command.'
  prefs: []
  type: TYPE_NORMAL
- en: Option Subnegotiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the DO/DONT/WILL/WONT negotiation just described serves only to enable
    or disable an option. Some options, such as the binary transmission option (TRANSMIT-BINARY),
    are either only off or on; in which case, this option negotiation is sufficient.
    Other options require that after they are enabled, the client and server exchange
    parameters to control how the option works. For example, the TERMINAL-TYPE option
    requires some way for the client to send the server the name of the terminal.
    Telnet allows the client and server to send an arbitrary amount of data related
    to the option using a process called *option subnegotiation*.
  prefs: []
  type: TYPE_NORMAL
- en: A device begins the subnegotiation process by sending a special sequence of
    Telnet protocol commands and data. First, the device sends the SB (subnegotiation)
    command, followed by the option number and parameters as defined by the particular
    option, and then ending the subnegotiation data by sending the SE (subnegotiation
    end) command. Both SB and SE must be preceded by the Interpret As Command (IAC)
    command byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the terminal type negotiation as an example. Suppose the server
    supports this option and would like the client to use it. The server starts option
    negotiation by sending the DO command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the client agrees, it will respond with the WILL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the terminal type option is in effect, but the server still doesn''t know
    which terminal the client is using. It can prompt the client to provide that information
    by sending this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The client receiving this option subnegotiation command will respond with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The WILL and DO commands only turn on a Telnet option that
    a client and server agree to use. In some cases, an option requires additional
    information to be sent between the client and server device for it to function
    properly. This is accomplished through a process of *option subnegotiation*. Either
    device sends the other a set of data relevant to the option, bracketed by the
    SB (subnegotiation) and SE (subnegotiation end) Telnet protocol commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Berkeley Remote (r) Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP has achieved success in large part due to its universality—it has been
    implemented on virtually every major computing platform. While the suite is thus
    not specific to any operating system, there is no denying that its history is
    closely tied to a particular one—UNIX. Most of the computers on the early Internet
    used UNIX, and the development of TCP/IP has paralleled that of UNIX in a number
    of respects.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important organizations involved in the development of UNIX,
    and thus TCP/IP indirectly, was the University of California at Berkeley (UCB).
    The USB-developed well-known *Berkeley Software Distribution (BSD)* UNIX has been
    in widespread use for over 20 years. They also developed a set of commands for
    BSD UNIX to facilitate various remote operation functions over a TCP/IP internetwork.
    Each of these programs begins with the letter *r* (for remote), so they have come
    to be known as both the *Berkeley remote commands* (or utilities) and also simply
    the *r commands*. Since their initial creation, they have been adopted for most
    variations of UNIX and some other operating systems as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *This section will probably make much more sense
    to those who have some understanding of the UNIX operating system than those who
    do not.*.'
  prefs: []
  type: TYPE_NORMAL
- en: Berkeley Remote Login (rlogin)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The head of the Berkeley remote protocol family is the remote login command,
    `rlogin`. As the name clearly implies, the purpose of this program is to allow
    a user on a UNIX host to log in to another host over a TCP/IP internetwork. Since
    Telnet is also often used for remote login, `rlogin` and Telnet are sometimes
    considered alternatives to each other for TCP/IP remote login. While they can
    be used in a similar way, they are quite different in a few respects.
  prefs: []
  type: TYPE_NORMAL
- en: From a conceptual standpoint, Telnet is designed as a protocol to enable terminal/host
    communication. As I mentioned in the Telnet overview earlier in this chapter,
    that protocol was not designed specifically for the purpose of remote login. In
    contrast, `rlogin` was intended for that specific purpose, and this is reflected
    in its operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol requires `rlogin` server software to be running on the host that
    is going to allow remote access; it is usually called `rlogind` (for `rlogin`
    *daemon*, the latter word being the standard UNIX term for a background server
    process). The server listens for incoming connection requests on TCP port 513\.
    Users who want to remotely log in to the server run the `rlogin` command on their
    local host and specify the name of the server. The client makes a TCP connection
    to the server and then sends to the server a string containing the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The login name of the user on the client machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The login name that the user wants to use on the server (which is often the
    same as the user's login name on the client, but not always)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control information such as the type and speed of the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server processes this information and begins the login process. It will
    normally prompt the user for a password to log in to the remote host. Assuming
    the password is correct, the user will be logged in to the remote host and can
    use it as if the user were locally connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a practical standpoint, the `rlogin` command is much simpler than Telnet;
    it does not support Telnet''s full command structure, nor capabilities such as
    option negotiation. It does include a small set of commands, however. The client
    is able to send to the server one key piece of information: the current size of
    the terminal window in use. The server is able to tell the client to turn on or
    off flow control, request that the client send it the current window size, or
    ask the client to flush pending output that the server has sent, up to a certain
    point in the data stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Some organizations have many different UNIX hosts that are used every day, and
    needing to constantly type passwords when using `rlogin` can be somewhat of a
    chore. On these systems, it is possible for administrators to set up control files
    that specify combinations of host names, user names, and passwords. If set up
    correctly, this enables an authorized user to use `rlogin` to remotely access
    a host automatically, without needing to enter either a login name or password.
  prefs: []
  type: TYPE_NORMAL
- en: As originally designed, `rlogin` is a classic example of a protocol from the
    early days of TCP/IP, since it emphasizes simplicity and usability over security.
    This is especially true of the automated login process just described. The original
    schemes used by `rlogin` for authentication are considered inadequate for modern
    TCP/IP internetworks, especially those connected to the Internet. Later versions
    of `rlogin` have been enhanced with more secure authorization methods. There is
    also a newer program called `slogin` (for *secure login*) that uses stronger authentication
    and encryption, which is intended to replace `rlogin` on newer systems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Berkeley remote, or *r*, commands facilitate remote operations
    between UNIX hosts on a TCP/IP internetwork. The base command of the family is
    the *remote login* command, `rlogin`, which allows a device on one host to access
    and use another as if it were locally connected to it. rlogin is often used as
    an alternative to Telnet. It is simpler than Telnet, both conceptually and practically.'
  prefs: []
  type: TYPE_NORMAL
- en: Berkeley Remote Shell (rsh)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user would normally use `rlogin` when he needs to log in to a server to perform
    a number of tasks. There are some situations, however, where a user needs to only
    enter one command on a remote host. With `rlogin`, the user would need to log
    in to the host, execute the command, and then log back out again. This isn't exactly
    an earth-shattering amount of inconvenience, especially when the correct configuration
    files are set up to allow automatic login. Over the course of time, however, all
    the extra logging in and out can become tedious. As a convenience, a variation
    of `rlogin`, called `rsh` (for *remote shell*), allows a user to access a remote
    host and execute a single command on it without requiring the login and logout
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shell *is the standard term used in UNIX to refer to the user interface that
    accepts commands from the user and displays output on the screen*.
  prefs: []
  type: TYPE_NORMAL
- en: The `rsh` command is based on `rlogin` and works in much the same way, except
    that it is oriented around executing a command rather than establishing a persistent
    login session. The server process on the remote host is usually called `rshd`
    (for *remote shell daemon*) and listens for incoming `rsh` requests. When one
    is received, the user is logged in through the same mechanism as `rlogin`. The
    command runs on the remote host, and then the user is automatically logged out.
  prefs: []
  type: TYPE_NORMAL
- en: '`rsh` is most useful when automatic login is employed, so that the program
    can be run without the need for the user to enter a login name or password. In
    that case, it is possible to have programs use `rsh` to automatically run commands
    on remote hosts without the need for human intervention, which opens up a number
    of possibilities for UNIX users. The normal UNIX user interface concepts of *standard
    input (stdin), standard output (stdout), and standard error (stderr)* also apply
    to `rsh`, so you can use it to execute a remote command and redirect the output
    to a local file. For example, the following command would let a user get a listing
    of his home directory on the host server and store it in the local file named
    remotelist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The `rsh` (remote shell) command is similar to the Berkeley
    `rlogin` command, but instead of opening a login session on a remote host, it
    executes a single, user-provided command. `rsh` can be helpful for users who need
    to perform a quick operation on a remote host, and it can also be employed by
    other programs to automate network tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Since `rsh` is based on `rlogin`, all of the concerns that apply to `rlogin`
    are also relevant here, especially with regard to security. (We really don't want
    unauthorized users running commands on our servers!) As with `rlogin`, newer versions
    of `rsh` support more advanced authentication options than the original software.
    Also, just as `slogin` is a newer, more secure version of `rlogin`, there is a
    program called `ssh` (for *secure shell*) that replaces `rsh` on many systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*On some systems, if* `rsh` *is entered without a command specified to execute,
    an interactive remote session is established, exactly as if the* `rlogin` *command
    had been entered instead of* `rsh`.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Berkeley Remote Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rlogin` and `rsh` commands are the generic members of the Berkeley *r*
    family of programs that allow remote access to a host. To complement these, the
    developers also defined a small number of specific remote commands. These are
    essentially remote versions of some of the more common UNIX functions. Instead
    of the command being applied to only one system, however, it is used between two
    systems or across all systems on a TCP/IP network.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these commands are based on `rlogin` in the same way as `rsh` is. They
    work in the same way, but instead of opening a session or passing a user-specified
    command to the remote host, they execute a particular function. The following
    are the most common of these remote commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Copy (**`rcp`**)** This is the remote version of the UNIX copy (`cp`)
    command. It allows a file to be copied between the local host and the remote host
    or between two remote hosts. The usual syntax is basically the same as the regular
    `cp` command, but the source and/or destination is specified as being on a remote
    host. The `rcp` command can be used in a manner similar to FTP, but is much simpler
    and less capable. Or, to put it another way, `rcp` is to FTP what `rlogin` is
    to Telnet. (That''s not a perfect analogy, but it''s pretty close.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Uptime (**`ruptime`**)** The UNIX command `uptime` displays how long
    a computer has been running since it was last booted, along with information related
    to its current load. `ruptime` is the remote version of this command; it displays
    the current status of each machine on the network (up or down), how long each
    up machine has been up since its last boot, and its load statistics.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Who (**`rwho`**)** This is the remote version of the `who` command.
    Where `who` shows all the users logged on to the host where it is run, `rwho`
    shows all users logged on to all machines on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ruptime` and `rwho` commands both rely on the presence of the `rwhod` (for
    *remote who daemon*) running in the background on networked machines. These processes
    routinely share information with each other about host uptime and who is logged
    on to each system, so it can be quickly displayed when either `ruptime` or `rwho`
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: On some operating systems, other remote commands may also be implemented. As
    with `rlogin` and `rsh`, security issues may apply to these commands, and there
    may be efficiency concerns with others (such as `rwho`). For these reasons, on
    many networks, these commands are no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Relay Chat Protocol (IRC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary advantage that electronic mail (email) offers over conventional
    mail is *speed*. Instead of needing to wait for days or weeks for a message to
    be delivered, it usually arrives in minutes or even seconds. This makes email
    far more useful than the regular postal service for most types of information
    transfer. There are some cases, however, where speed of delivery is not sufficient
    to make email an ideal mechanism for communication. One such case is where a *dialogue*
    is required between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that even though email may be delivered very quickly, it uses a decoupled
    model of communication. Say that Ellen sends an email to Jane. The message may
    show up in Jane's inbox in a matter of seconds, but Jane may not be around to
    read it at the time it arrives. Jane might not see the message until hours later.
    Then Jane would send a response to Ellen, who might not see it for a while. If
    the subject they are discussing requires several dozen iterations of this sort,
    it could take a very long time before the exchange is completed.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, of course, most of us would never use email for such a conversation,
    preferring instead that high-tech communication device that we call the telephone.
    Many people using computers realized that it would be useful to have a way for
    two or more people to interactively discuss issues in a manner similar to a telephone
    conversation. In the online world, this is commonly called *chatting*, and one
    of the first and most important application protocols designed to implement it
    in TCP/IP was the *Internet Relay Chat (IRC) Protocol*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the widespread use of the Internet, people with computers would often
    communicate by dialing in to a bulletin board system (*BBS)* or other proprietary
    service. IRC was originally created by a gentleman from Finland named Jarkko Oikarinen,
    based on his experience with chat applications on BBSes. He wrote the first client
    and server software in 1988\. The protocol was later formally defined in RFC 1459,
    "Internet Relay Chat Protocol," published May 1993\. In April 2000, the IRC standard
    was revised and enhanced with several new extended capabilities, and published
    as a set of four smaller documents: RFCs 2810 through 2813\. Each of these focuses
    on one particular area of IRC functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*RFC 1459 has the experimental RFC status, and the RFC 2810 to 2813 group is
    designated Informational. This makes IRC optional; it does not need to be implemented
    on TCP/IP devices*.'
  prefs: []
  type: TYPE_NORMAL
- en: IRC Communication Model and Client/Server Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IRC is an interesting protocol in that it is not based strictly on the standard
    client/server model of TCP/IP protocol operation. *IRC servers* are TCP/IP machines
    that run IRC server software. They are configured with information that allows
    them to establish TCP connections to each other. IRC uses TCP because the connections
    are maintained over a long period of time, and reliable transport of data is required.
    Server connections are used to exchange control information and user data, forming
    a logical *IRC network* at the application level, which allows any server to send
    to any other server, using intermediate servers as conduits. Servers are managed
    by *IRC operators (IRCops)* who have special privileges that allow them to ensure
    that everything runs smoothly on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The IRC network forms the backbone of the IRC communication service. A user
    can access the network by running *IRC client* software on any TCP/IP-enabled
    device. The user enters the name of one of the servers on the network and establishes
    a TCP connection to that server. This causes the user to be connected directly
    to one server, and thus, indirectly to all of the others on the network. This
    allows that user to send and receive messages to and from all other users connected
    either to the user's server or other servers.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging and IRC Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common type of communication in IRC is *group messaging*, which is
    accomplished using *IRC channels*. A channel is a virtual meeting place of sorts
    and is also sometimes called a *chat room* (though IRC purists scoff at the use
    of that term). Every IRC network has hundreds or even thousands of different channels,
    each of which is dedicated to a particular type of discussion, ranging from the
    serious to the silly. For example, a group of people interested in talking about
    meteorology could establish a channel called #weather, where they would meet regularly
    to discuss various aspects of climatology and interesting weather events.'
  prefs: []
  type: TYPE_NORMAL
- en: IRC is an inherently text-based protocol (though it is also possible to use
    IRC clients to transfer arbitrary files between users, including images and executable
    programs). To communicate in a channel, all a user needs to do is enter text in
    the appropriate spot in the IRC client program, and then the program automatically
    sends this text to every other member of the channel. The IRC network handles
    the relaying of these messages in real time from the sender's connected server
    to other servers in the network, and then to all user machines on those servers.
    When other users see the first user's message, they can reply with messages of
    their own, which will, in turn, be propagated across the network. Each IRC user
    chooses a nickname (often abbreviated *nick*) that is like a *handle* used for
    communication while connected to the network.
  prefs: []
  type: TYPE_NORMAL
- en: IRC also supports one-to-one communication, which can be used for private conversation.
    To use this method, a user just needs the nickname of another user to whom she
    wants to talk. She uses a special command to send messages directly to that user,
    who can respond in kind. This is not a secure form of communication, since the
    messages are not encrypted, and they pass through servers where they could be
    monitored. However, there is so much traffic on a typical IRC network that any
    given message is unlikely to be monitored.
  prefs: []
  type: TYPE_NORMAL
- en: The IRC Protocol defines a rich command set that allows users to perform essential
    functions, such as joining or leaving a channel, changing nicknames, changing
    servers, setting operating modes for channels, and so forth. The exact command
    set and features available depend both on the specific software used for the user's
    IRC client and the features available on the IRC network itself. Not all IRC networks
    run the same version of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: IRC and the Modern Internet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IRC became very popular in the early 1990s because of the powerful way that
    it allows users from anywhere on the Internet to meet and share information dynamically.
    It acts like a text-based telephone, but users across the globe don't have the
    expense of long-distance calls.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important characteristics of IRC is its open-ended nature; it
    gives every person the freedom to communicate in whatever way he or she considers
    best. For example, every IRC channel has an owner, who has certain rights related
    to how the channel is used, including the ability to decide who should be allowed
    in the channel. This may seem autocratic, but IRC lets anyone start a new channel
    instantly and become that channel's owner, without the need for prior registration
    or authorization. This means that if you don't like how a particular channel is
    run, you can start your own with a minimum of fuss. You are not forced to adhere
    to anyone's rules, other than the rules set forth for the server (which are usually
    just intended to prevent abuse).
  prefs: []
  type: TYPE_NORMAL
- en: This same principle extends to the IRC networks themselves. There isn't just
    one single IRC network; there are dozens of different ones. Some are large, well-established
    networks that may have more than 100 servers and thousands of users; others are
    smaller and devoted to specific areas of interest or geographical regions. Anyone
    can set up their own IRC network if they have the hardware and software, and some
    organizations have set up private, dedicated IRC servers for their own use.
  prefs: []
  type: TYPE_NORMAL
- en: IRC is considered by many to be the most important ancestor of the related interactive
    applications collectively known as *instant messaging*. These services are offered
    by several organizations, including America Online (AOL), Yahoo, and Microsoft's
    MSN. The idea behind them is very similar to that of IRC. Each allows a message
    sent by one user to be displayed immediately to another, though most are focused
    primarily on user-to-user messages rather than group messaging. Instant messaging
    has surpassed IRC in overall use, perhaps due to the large subscriber base of
    services like AOL. However, IRC is still widely used by thousands of enthusiasts
    on a daily basis for both entertainment and business purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This final chapter on application protocols is a bit different from the previous
    ones. It doesn't describe applications designed for end users. Rather, it discusses
    a set of TCP/IP troubleshooting utilities and protocols, which are normally the
    province of internetwork administrators. Even though millions of people use TCP/IP
    every day without even knowing that these applications exist—much less how they
    work—they are critically important to those who maintain TCP/IP internetworks.
    Since many of you are studying TCP/IP so that you can implement and administer
    this technology, understanding how these applications work is well worth your
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide an overview of a number of software utilities that
    are commonly employed to help set up, configure, and maintain TCP/IP internetworks.
    These programs allow a network administrator to perform functions such as checking
    the identity of a host, verifying connectivity between two hosts, checking the
    path of routers between devices, examining the configuration of a computer, and
    looking up a Domain Name System (DNS) domain name.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to provide explanations of the general purpose and
    function of troubleshooting utilities, so you will know how they can help you
    manage TCP/IP networks. As part of these descriptions, I demonstrate the typical
    syntax used to invoke each utility in both UNIX and Windows. Due to variations
    in software implementations, you will need to consult your operating system documentation
    for the details on exactly how each program should be used on your network. On
    Windows systems, try `<`*`program`*`> /?` to see the syntax of the program; on
    UNIX/Linux, try `man <`*`program`*`>`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *Many of the software tools described in this section
    are designed to manage the operation of other TCP/IP protocols, such as the Internet
    Protocol (IP), the Domain Name System (DNS), and the Dynamic Host Configuration
    Protocol (DHCP). To fully appreciate how these utilities work, you need to understand
    the basics of these and other key TCP/IP protocols. In particular, a number of
    the utilities discussed here communicate use Internet Control Message Protocol
    (ICMP) messages, so I would recommend familiarity with ICMP (discussed in [Part II-6](pt09.html
    "Part II-6. IP SUPPORT PROTOCOLS")) before proceeding*.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Host Name Utility (hostname)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental of tasks in diagnosing problems with a networked
    computer is identifying it. Just as the first thing we usually do when we meet
    someone is exchange names, one of the first actions an administrator takes when
    accessing a device is to determine its name, if it is not known. This is accomplished
    using the `hostname` utility.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall from our discussion of TCP/IP name systems in [Part III-1](pt12.html
    "Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION") that
    there are two different ways that hosts can be named. The first way is to manually
    assign flat names to devices using host tables or equivalent means; this is most
    often used for devices that not going to be accessed on the public Internet. The
    second is to give a device a domain name within DNS. The `hostname` utility can
    be used for both types of named hosts, but it functions in a slightly different
    way for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'On most systems, including Windows and many UNIX implementations, the `hostname`
    utility is very simple. When you enter the command by itself on a line with no
    arguments, it displays the full name of the host. If it is entered with the `-s`
    (short) parameter and the host name is a fully qualified DNS domain name, only
    the local label of the node is shown and not the full domain name; if the host
    has a flat (non-DNS) name, the `-s` parameter has no effect. Here is a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hostname` utility is also intended to allow an administrator to set the
    name of a host. The syntax for this is also simple; you just supply the name of
    the host as a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, in most implementations, the use of the `hostname` command for setting
    a device's name is either disabled or restricted. In Windows systems, a special
    applet in the Control Panel is used to set the device's name; attempting to set
    it using `hostname` will result in an error message. In UNIX, the superuser of
    the system can use `hostname` to set the device's name, but it is more common
    for this to be done by other means, such as editing the configuration file `/etc/hosts`.
    If a simple flat name is being assigned to this host, the administrator has full
    control over it. However, if DNS is used, then the proper procedures for registering
    the name must be followed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The* `hostname` *utility is not, strictly speaking, tied into the operation
    of DNS or other formal mechanisms for identifying a host. It simply displays what
    the administrator has set it to show. It makes sense for this to be set to the
    host''s DNS name, but there may be exceptions, such as in small networks that
    might not use DNS*.'
  prefs: []
  type: TYPE_NORMAL
- en: In most operating systems, the `-s` parameter is the only one that this command
    supports. The parameter is not supported on all implementations of the `hostname`
    command, however. On some implementations, if you use `hostname -s`, the system
    may report its host name as being *–s*. On certain Linux systems, the `hostname`
    utility includes a few additional parameters that allow different ways for the
    host name to be displayed, as well as some miscellaneous functions such as showing
    the version number of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The simplest and most basic of TCP/IP administrative utilities
    is hostname, which returns the name of the host on which it is run.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Communication Verification Utility (ping)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common problems that network administrators are asked to solve
    is that two hosts are not able to communicate. For example, a user on a corporate
    network might not be able to retrieve one of his files from a local server, or
    another user might be having difficulty loading her favorite website. In these
    and similar situations, one important step in diagnosing the problem is to verify
    that basic communication is possible between the TCP/IP software stacks on the
    two machines. This is most often done using the `ping` utility, or `ping6` in
    Internet Protocol version 6 (IPv6) implementations. The IPv6 version of `ping`
    works in much the same way as IPv4 ping, but `ping6`'s options and parameters
    reflect the changes made in addressing and routing in IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some people say that* `ping` *is an acronym for Packet Internet Groper, while
    others insist that it is actually based on the use of the term to refer to a sonar
    pulse sent by a submarine to check for nearby objects. I really don''t know which
    of these is true, but I prefer the second explanation. Consider that the utility
    works in a way similar to a sonar ping, and that it was originally written by
    a gentleman named Mike Muuss, who worked at the United States Army Ballistics
    Research Laboratory*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ping` is one of the most commonly used diagnostic utilities, and it is present
    in just about every TCP/IP implementation. It is usually implemented and accessed
    as a command-line utility, though there are also now graphical and menu-based
    versions of the program on some operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Operation of the ping Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ping` utility is implemented using Internet Control Message Protocol (ICMP)
    Echo (Request) and Echo Reply messages, which are designed specifically for this
    type of diagnostic use. When Device A sends an ICMP Echo message to Device B,
    Device B responds by sending an ICMP Echo Reply message back to Device A. The
    same functionality exists in ICMPv6, the IPv6 version of ICMP; the ICMPv6 Echo
    and Echo Reply messages differ from the IPv4 ones only slightly in their field
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would seem to indicate that `ping` would be an extremely simple utility
    that would send one Echo message and wait to see if an Echo Reply was received
    back. If so, this would mean that the two devices were able to communicate; if
    not, this would indicate a problem somewhere on the internetwork between the two.
    However, almost all `ping` implementations are much more complex than this. They
    use multiple sets of Echo and Echo Reply messages, along with considerable internal
    logic, to allow an administrator to determine all of the following, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the two devices can communicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether congestion or other problems exist that might allow communication to
    succeed sometimes but cause it to fail in others, seen as packet loss; if so,
    how bad the loss is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much time it takes to send a simple ICMP message between devices, which
    gives an indication of the overall latency between the hosts and also indicates
    if there are certain types of problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Use of ping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most basic use of the `ping` command is to enter it by itself with the IP
    address of a host. Virtually all implementations also allow you to use a host
    name, which will be resolved to an IP address automatically. When you invoke the
    utility with no additional options, it uses default values for parameters such
    as what size message to send, how many messages to be sent, how long to wait for
    a reply, and so on. The utility will transmit a series of Echo messages to the
    host and report back whether or not a reply was received for each. If a reply
    is seen, it will also indicate how long it took for the response to be received.
    When the program is finished, it will provide a statistical summary showing what
    percentage of the Echo messages received a reply and the average amount of time
    it took for them to be received.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While the inability to get a response from a device to a* `ping` *has traditionally
    been interpreted as a problem in communication, this is not always necessarily
    the case. In the current era of increased security consciousness, some networks
    are set up to not respond to Echo messages, to protect against attacks that use
    floods of such messages. In this case, a* `ping` *will fail, even though the host
    may be quite reachable*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 88-1](ch88s02.html#verifying_communication_using_the_ping_u "Example 88-1. Verifying
    communication using the ping utility") shows an example of using the `ping` command
    on a Windows XP computer (mine!), which, by default, sends four 32-byte Echo messages
    and allows four seconds before considering an Echo message lost. I use a satellite
    Internet connection that has fairly high latency and also occasionally drops packets.
    This isn''t great for me, but it is useful for illustrating how `ping` works.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-1. Verifying communication using the ping utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Methods of Diagnosing Connectivity Problems Using ping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most people find that using `ping` with default settings is enough for their
    needs. In fact, the utility can be used in this simplest form to perform a surprising
    number of diagnostic checks. In many cases, you can use the `ping` command to
    diagnose connectivity problems by issuing it multiple times in sequence, often
    starting with checks at or close to the transmitting device and then proceeding
    outward toward the other device with which the communication problem has been
    observed. Here are some examples of how ping can be used in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Device TCP/IP Stack Operation** By performing a `ping` on the device''s
    own address, you can verify that its internal TCP/IP stack is working. This can
    also be done using the standard IP loopback address, 127.0.0.1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Network Connectivity** If the internal test succeeds, it''s a good
    idea to do a `ping` on another device on the local network, to verify that local
    communication is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Router Operation** If there is no problem on the local network, it
    makes sense to `ping` whatever local router the device is using to make sure it
    is operating and reachable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Name Resolution Functionality** If a `ping` performed on a DNS domain
    name fails, you should try it with the device''s IP address instead. If that works,
    this implies either a problem with domain name configuration or resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Host Operation** If all the preceding checks succeed, you can try
    performing a `ping` to a remote host to see if it responds. If it does not, you
    can try a different remote host. If that one works, it is possible that the problem
    is actually with the first remote device itself and not with your local device.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The TCP/IP ping utility is used to verify the ability of two
    devices on a TCP/IP internetwork to communicate. It operates by having one device
    send ICMP Echo (Request) messages to another, which responds with Echo Reply messages.
    The program can be helpful in diagnosing a number of connectivity issues, especially
    if it is used to test the ability to communicate with other devices in different
    locations. It also allows the average round-trip delay to exchange messages with
    another device to be estimated.'
  prefs: []
  type: TYPE_NORMAL
- en: ping Options and Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the basic uses described in the previous sections, all `ping`
    implementations include a number of options and parameters that allow an administrator
    to fine-tune how it works. They allow ping to be used for more extensive or specific
    types of testing. For example, `ping` can be set in a mode where it sends Echo
    messages continually, to check for an intermittent problem over a long period
    of time. You can also increase the size of the messages sent or the frequency
    with which they are transmitted, to test the ability of the local network to handle
    large amounts of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other utilities described in this chapter, the exact features of
    the `ping` program are implementation-dependent. Even though UNIX and Windows
    systems often include many of the same options, they usually use completely different
    option codes. [Table 88-1](ch88s02.html#common_unix_ping_utility_options_and_par
    "Table 88-1. Common UNIX ping Utility Options and Parameters") shows some of the
    more important options that are often defined for the utility on many UNIX systems,
    and where appropriate, the parameters supplied with the option. [Table 88-2](ch88s02.html#common_windows_ping_utility_options_and_
    "Table 88-2. Common Windows ping Utility Options and Parameters") shows `ping`
    options for a typical Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-1. Common UNIX ping Utility Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c <`*`count`*`>` | Specifies the number of Echo messages that should be
    sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | Flood mode; sends Echo packets at high speed to stress test a network.
    This can cause serious problems if not used carefully! |'
  prefs: []
  type: TYPE_TB
- en: '| `-i <`*`wait-interval`*`>` | Tells the utility how long to wait between transmissions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-m <`*`ttl-value`*`>` | Overrides the default Time to Live (TTL) value for
    outgoing Echo messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Numeric output only; suppresses lookups of DNS host names to save
    time. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p <`*`pattern`*`>` | Allows a byte pattern to be specified for inclusion
    in the transmitted Echo messages. This can be useful for diagnosing certain odd
    problems that may occur only with certain types of transmissions. |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Quiet output; only summary lines are displayed at the start and end
    of the program''s execution, while the lines for each individual message are suppressed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-R` | Tells the utility to include the Record Route IP option, so the route
    taken by the ICMP Echo message can be displayed. This option is not supported
    by all implementations. Using the `traceroute` utility (described in the next
    section) is usually a better idea. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s <`*`packet-size`*`>` | Specifies the size of outgoing message to use.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-S <`*`src-addr`*`>` | On devices that have multiple IP interfaces (addresses),
    allows a `ping` sent from one interface to use an address from one of the others.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-t <`*`timeout`*`>` | Specifies a timeout period, in seconds, after which
    the `ping` utility will terminate, regardless of how many requests or replies
    have been sent or received. |'
  prefs: []
  type: TYPE_TB
- en: Table 88-2. Common Windows ping Utility Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | If the target device is specified as an IP address, forces the address
    to be resolved to a DNS host name and displayed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | Sets the Don''t Fragment bit in the outgoing datagram. |'
  prefs: []
  type: TYPE_TB
- en: '| `-i <`*`ttl-value`*`>` | Specifies the Time to Live (TTL) value to be used
    for outgoing Echo messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-j <`*`host-list`*`>` | Sends the outgoing messages using the specified
    loose source route. |'
  prefs: []
  type: TYPE_TB
- en: '| `-k <`*`host-list`*`>` | Sends the outgoing messages using the indicated
    strict source route. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l <`*`buffer-size`*`>` | Specifies the size of the data field in the transmitted
    Echo messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n <`*`count`*`>` | Tells the utility how many Echo messages to send. |'
  prefs: []
  type: TYPE_TB
- en: '| `-r <`*`count`*`>` | Specifies the use of the Record Route IP option and
    the number of hops to be recorded. It''s usually preferable to use the `traceroute`
    utility (described in the next section). |'
  prefs: []
  type: TYPE_TB
- en: '| `-s <`*`count`*`>` | Specifies the use of the IP Timestamp option to record
    the arrival time of the Echo and Echo Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t` | Sends Echo messages continuously until the program is interrupted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-w <`*`timeout`*`>` | Specifies how long the program should wait for each
    Echo Reply before giving up, in milliseconds (default is 4,000, for 4 seconds).
    |'
  prefs: []
  type: TYPE_TB
- en: TCP/IP Route Tracing Utility (traceroute)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ping` utility is extremely helpful for checking whether two devices are
    able to communicate with each other. However, it provides very little information
    regarding what is going on between those two devices. In the event that `ping`
    shows either a total inability to communicate or intermittent connectivity with
    high loss of transmitted data, administrators need to know more about what is
    happening to IP datagrams as they are carried across the internetwork. This is
    especially important when the two devices are far from each other, especially
    if you are trying to reach a server on the public Internet.
  prefs: []
  type: TYPE_NORMAL
- en: I described in my overview of IP datagram delivery that when two devices are
    not on the same network, data sent between them must be delivered from one network
    to the next until it reaches its destination. This means that any time data is
    sent from Device A on one network to Device B on another, it follows a route,
    which may not be the same for each transmission. When communication problems arise,
    it is very useful to be able to check the specific route taken by data between
    two devices. A special route tracing utility is provided for this function, called
    `traceroute` (abbreviated `tracert` in Windows systems, a legacy of the old eight-character
    limit for DOS program names).
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 equivalent of this program is called `traceroute6`, which functions
    in a very similar manner to its IPv4 predecessor. It obviously uses IPv6 datagrams
    instead of IPv4 ones, and responses from traced devices are in the form of ICMPv6
    Time Exceeded and Destination Unreachable messages rather than their ICMPv4 counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of the traceroute Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the `ping` utility, `traceroute` is implemented using ICMP messages. However,
    unlike `ping`, `traceroute` was not originally designed to use a special ICMP
    message type intended exclusively for route tracing. Instead, it makes clever
    use of the IP and ICMP features that are designed to prevent routing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the IP datagram format includes a Time to Live (TTL) field. This
    field is set to the maximum number of times that a datagram may be forwarded before
    it must be discarded; it exists to prevent datagrams from circling an internetwork
    endlessly. If a datagram must be discarded due to expiration of the TTL field,
    the device that discards it is supposed to send an ICMP Time Exceeded message
    back to the device that sent the discarded datagram. (This is explained in detail
    in [Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS").)
    Under normal circumstances, this occurs only when there is a problem, such as
    a router loop or another misconfiguration issue. What `traceroute` does is to
    force each router in a route to report back to it by intentionally setting the
    TTL value in test datagrams to a value too low to allow them to reach their destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have Device A and Device B, which are separated by Routers R1 and
    R2—three hops total (A to R1, R1 to R2 and R2 to B). If you do a `traceroute`
    from Device A to Device B, here''s what happens (see [Figure 88-1](ch88s03.html#operation_of_the_traceroutetracert_utili
    "Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility
    identifies the devices in a route by forcing them to report back failures to route
    datagrams with parameters intentionally set to invalid values. The first message
    sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router
    R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The
    second message has a TTL value of 2, so it will be dropped and reported by Router
    R2\. The third message will pass both routers and get to the destination host,
    Device B, but since the message is deliberately chosen with a bogus port number,
    this will cause an ICMP Destination Unreachable message to be returned. These
    error messages identify the sequence of devices in the route between Devices A
    and B.")):'
  prefs: []
  type: TYPE_NORMAL
- en: The `traceroute` utility sends a dummy User Datagram Protocol (UDP) message
    (sometimes called a *probe*) to a port number that is intentionally selected to
    be invalid. The TTL field of the IP datagram is set to 1\. When Router R1 receives
    the message, it decrements the field, which will make its value 0\. That router
    discards the probe and sends an ICMP Time Exceeded message back to Device A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Device A sends a second UDP message with the TTL field set to 2\. This time,
    Router R1 reduces the TTL value to 1 and sends it to Router R2, which reduces
    the TTL field to 0 and sends a Time Exceeded message back to Device A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Device A sends a third UDP message, with the TTL field set to 3\. This time,
    the message will pass through both routers and be received by Device B. However,
    since the port number was invalid, the message is rejected by Device B, which
    sends back a Destination Unreachable message to Device A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So Device A sends out three messages to Device B, and it gets back three error
    messages and is happy about it! The route to Device B is thus indicated by the
    identities of the devices sending back the error messages, in sequence. By keeping
    track of the time between when it sent each UDP message and received back the
    corresponding error message, the `traceroute` utility can also display how long
    it took to communicate with each device. In practice, usually three dummy messages
    are sent with each TTL value, so their transit times can be averaged by the user
    if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Not all* `traceroute` *utility implementations use the technique described
    here. Microsoft''s* `tracert` *works by sending ICMP Echo messages with increasing
    TTL values, rather than UDP packets. It knows it has reached the final host when
    it gets back an Echo Reply message. A special ICMP Traceroute message was also
    developed in 1993, which was intended to improve the efficiency of* `traceroute`
    *by eliminating the need to send many UDP messages for each route tracing. Despite
    its technical advantages, since this message was introduced long after TCP/IP
    was widely deployed, it never became a formal Internet standard and its use is
    not seen as often as the traditional method*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operation of the traceroute/tracert utility The traceroute utility identifies
    the devices in a route by forcing them to report back failures to route datagrams
    with parameters intentionally set to invalid values. The first message sent by
    Device A here has a Time to Live (TTL) value of 1, which will cause Router R1
    it to drop it and send an ICMP Time Exceeded message back to Device A. The second
    message has a TTL value of 2, so it will be dropped and reported by Router R2\.
    The third message will pass both routers and get to the destination host, Device
    B, but since the message is deliberately chosen with a bogus port number, this
    will cause an ICMP Destination Unreachable message to be returned. These error
    messages identify the sequence of devices in the route between Devices A and B.](httpatomoreillycomsourcenostarchimages288327.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility
    identifies the devices in a route by forcing them to report back failures to route
    datagrams with parameters intentionally set to invalid values. The first message
    sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router
    R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The
    second message has a TTL value of 2, so it will be dropped and reported by Router
    R2\. The third message will pass both routers and get to the destination host,
    Device B, but since the message is deliberately chosen with a bogus port number,
    this will cause an ICMP Destination Unreachable message to be returned. These
    error messages identify the sequence of devices in the route between Devices A
    and B.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The `traceroute` utility takes the idea behind ping one step
    further, allowing administrators to not only check communication between two devices,
    but also letting them see a list of all the intermediate devices between the pair.
    It works by having the initiating host send a series of test datagrams with TTL
    values that cause each to expire sequentially at each device on the route. The
    `traceroute` program also shows how much time it takes to communicate with each
    device between the sending host and a destination device.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Use of the traceroute Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili "Example 88-2. Route
    tracing using the traceroute utility") shows an example of a `traceroute` sent
    between two of the UNIX computers I use on a regular basis. I added the `-q2`
    parameter to change the default of three dummy messages per hop to two, so the
    output would fit better on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-2. Route tracing using the traceroute utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the servers are separated by 14 hops. Notice how the elapsed time
    generally increases as the distance from the transmitting device increases, but
    it is not consistent because of random elements in the delay between any two devices
    (see the incongruously large value in hop 10, for example). Also notice the asterisk
    (*) in the seventh hop, which means that no response was received before the timeout
    period for the second transmission with a TTL value of 7\. Finally, there is no
    report at all for hop 13\. This machine may have been configured not to send Time
    Exceeded messages.
  prefs: []
  type: TYPE_NORMAL
- en: Additional unusual results may be displayed under certain circumstances. For
    example, the `traceroute` program may display a code such a `!H`, `!N`, or `!P`
    to indicate receipt of an unexpected Destination Unreachable message for a host,
    network, or protocol, respectively. Other error messages may also exist, depending
    on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: traceroute Options and Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is the case with `ping`, `traceroute` can be used with an IP address or host
    name. If no parameters are supplied, default values will be used for key parameters.
    On the system I use, the defaults are three probes for each TTL value, a maximum
    of 64 hops tested, and packets 40 bytes in size. However, my implementation also
    supports a number of options and parameters to give me more control over how the
    utility functions (such as the `-q` parameter I used in [Example 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili
    "Example 88-2. Route tracing using the traceroute utility")). Some of the typical
    options available in UNIX systems are described in [Table 88-3](ch88s03.html#common_unix_traceroute_utility_options_a
    "Table 88-3. Common UNIX traceroute Utility Options and Parameters"). A smaller
    set of options exists in Windows, as shown in [Table 88-4](ch88s03.html#common_windows_tracert_utility_options_a
    "Table 88-4. Common Windows tracert Utility Options and Parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-3. Common UNIX traceroute Utility Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-g <`*`host-list`*`>` | Specifies a source route to be used for the trace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-M <`*`initial-ttl-value`*`>` | Overrides the default value of 1 for the
    initial TTL value of the first outgoing probe message. |'
  prefs: []
  type: TYPE_TB
- en: '| `-m <`*`max-ttl-value`*`>` | Sets the maximum TTL value to be used. This
    limits how long a route the utility will attempt to trace. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Displays the route using numeric addresses only, rather than showing
    both IP addresses and host names. This speeds up the display by saving the utility
    from needing to perform reverse DNS lookups on all the devices in the route (ICMP
    messages use IP addresses, not domain names). |'
  prefs: []
  type: TYPE_TB
- en: '| `-p <`*`port-number`*`>` | Specifies the port number to be used as the destination
    of the probe messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-q <`*`queries`*`>` | Tells the utility how many probes to send to each
    device in the route (the default is 3). |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Tells the program to bypass the normal routing tables and send directly
    to a host on an attached network. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s <`*`src-addr`*`>` | On devices that have multiple IP interfaces (addresses),
    allows the device to use an address from one interface on a `traceroute` using
    another interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `-S` | Instructs the program to display a summary of how many probes did
    not receive a reply. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Sets verbose output mode, which informs the user of all ICMP messages
    received during the trace. |'
  prefs: []
  type: TYPE_TB
- en: '| `-w <`*`wait-time`*`>` | Specifies how long the utility should wait for a
    reply to each probe, in seconds (the typical default is 3 to 5). |'
  prefs: []
  type: TYPE_TB
- en: Table 88-4. Common Windows tracert Utility Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | Displays the route using numeric addresses only, rather than showing
    both IP addresses and host names, for faster display. This is the same as the
    `-n` option on UNIX systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `-h <`*`maximum-hops`*`>` | Specifies the maximum number of hops to use for
    tracing (the default is 30). |'
  prefs: []
  type: TYPE_TB
- en: '| `-j <`*`host-list`*`>` | Sends the outgoing probes using the specified loose
    source route. |'
  prefs: []
  type: TYPE_TB
- en: '| `-w <`*`wait-time`*`>` | Specifies how long to wait for a reply to each probe,
    in milliseconds (the default is 4,000, for 4 seconds). |'
  prefs: []
  type: TYPE_TB
- en: TCP/IP Address Resolution Protocol Utility (arp)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All devices on an internetwork are considered to be virtually connected at layer
    3, since the process of routing lets any device communicate with any other device.
    However, there is no way for devices on distant networks to communicate directly.
    The internetwork communication at layer 3 actually consists of a number of steps,
    called *hops*, that carry the data from its source to destination. Each hop in
    a route requires that data be sent between a pair of hardware devices, and each
    transmission must use layer 2 hardware addresses. Since TCP/IP uses layer 3 addresses,
    this means each hop requires that we translate the IP address of the target of
    the hop to a hardware address. This is called *address resolution*; the reasons
    why it is needed and the methods used for it are explained in detail in [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)").
  prefs: []
  type: TYPE_NORMAL
- en: In TCP/IP, address resolution functions are performed by the aptly named Address
    Resolution Protocol (ARP). When a device needs to transmit to a device with a
    particular IP address, it can use ARP's request/reply messaging protocol to find
    out which hardware device corresponds to that IP address. However, each such message
    exchange takes time and network bandwidth, so for efficiency, every device maintains
    an ARP cache, which is a table containing mappings between IP and hardware addresses.
    The ARP cache table can contain a combination of static cache entries that are
    manually inserted for frequently accessed devices, and dynamic entries, which
    are entered automatically when a request/reply resolution is done. The next time
    it is necessary to send a device mapped in the ARP cache table, the lookup process
    can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow administrators to manage this ARP cache table, TCP/IP devices include
    an `arp` utility. It has the following three basic functions, which are invoked
    using three different versions of the command (which, for once, are the same in
    UNIX and Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARP Cache Table Display** When the `-a` option is used with the utility,
    it displays the current contents of the ARP cache table. The syntax is `arp -d
    <`*`host-name`*`>`. Each entry in the table shows the IP address and hardware
    address pair for one device (interface, actually). Usually, it also indicates
    whether each entry is static or dynamic. The exact format of the display varies
    from one implementation to the next; some programs show IP addresses, others show
    host names, and still others may show both. Some systems default to displaying
    host names but allow the `-n` option to also be used to force only IP addresses
    (not names) to be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARP Cache Table Entry Addition** This version allows an administrator to
    make a new manual ARP cache table entry that maps the given host name to the specified
    hardware address. The syntax is `arp -s <`*`host-name`*`> <`*`hw-addr`*`>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARP Cache Table Entry Deletion** Using `arp` with the `-d` option removes
    the specified cache entry from the table. Some implementations allow the addition
    of another parameter to specify that all entries should be removed from the cache.
    The basic syntax is `arp -d <`*`host-name`*`>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The TCP/IP arp utility is used by an administrator to inspect
    or modify a host''s ARP cache table, which contains mappings between TCP/IP host
    names and IP addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Certain versions of the software may also supplement these basic commands with
    additional features. One common additional option on UNIX systems is the ability
    to specify a file from which cache table entries may be read, using the syntax
    `arp -f <`*`file-name`*`>`. This saves a considerable amount of time and effort
    compared to typing each entry manually using `arp -s`.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the operating system may allow only authorized users to access
    options that cause the ARP cache table to be changed. This is especially true
    of the delete function.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP DNS Name Resolution and Lookup Utilities (nslookup, host, and dig)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DNS is a critically important part of TCP/IP internetworks, especially the
    modern Internet, because it allows hosts to be accessed using easily remembered
    names rather than confusing numerical addresses. Two different primary types of
    devices are involved in the operation of DNS: DNS name servers that store information
    about domains and DNS resolvers that query DNS servers to transform names into
    addresses, as well as perform other necessary functions.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS resolvers are employed by Internet users on a continual basis to translate
    DNS names into address, but under normal circumstances, they are always invoked
    indirectly. Each time a user types a DNS name into a program such as a web browser
    or File Transfer Protocol (FTP) client—or even uses it in one of the other utilities
    described in this chapter, such as `ping` or `traceroute`—the resolver automatically
    performs the name resolution without the user having to ask. For this reason,
    there is no need for users to manually resolve DNS names into addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, administrators often do need to perform a DNS resolution manually.
    For example, when troubleshooting a problem, the administrator may know a host''s
    name but not its address. In the case of a security problem, the address may show
    up in a log file but the host name may not be known. In addition, even though
    users do not need to know the specifics of the resource records that define a
    DNS domain, administrators often need to be able to check these details, to make
    sure a domain is set up properly. Administrators also need some way to be able
    to diagnose problems with DNS servers themselves. To support all of these needs,
    modern TCP/IP implementations come equipped with one or more DNS name resolution
    and information lookup utilities. Here, we will look at three such utilities:
    `nslookup`, `host`, and `dig`.'
  prefs: []
  type: TYPE_NORMAL
- en: The nslookup Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common DNS diagnostic utilities is `nslookup` (for name server
    lookup), which has been around for many years. The details of how the program
    is implemented depend on the operating system, though most of them offer versions
    that are quite similar in operation and settings. The utility can normally be
    used in two modes: interactive or noninteractive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The noninteractive version of `nslookup` is the simplest, and it is most often
    used when an administrator wants to just quickly translate a name into an address
    or vice versa. To run this version, issue the `nslookup` command using the following
    simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<`*`host`*`>` can be a DNS domain name, for performing a normal resolution,
    or it may be an IP address, for a reverse resolution to return the associated
    DNS domain name. The `<`*`server`*`>` parameter is optional; if it's omitted,
    the program uses the default name server of the host where the command was issued.
    [Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u "Example 88-3. DNS
    name resolution using the nslookup utility") shows a simple example of noninteractive
    use of `nslookup`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-3. DNS name resolution using the nslookup utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example was done on my home PC that uses the Starband satellite Internet
    service, which is configured to use Starband's name server (`ns1-mar.starband.com`).
    The answer provided here is labeled *non-authoritative*, because it came from
    the Starband name server's DNS cache, rather than one of the DNS name servers
    that is a DNS authority for [www.pcguide.com](http://www.pcguide.com).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*It is also possible to specify one or more options to modify the behavior
    of the lookup in noninteractive mode. These options are the same as the parameters
    controlled by the* `nslookup` *set command described in [Table 88-5](ch88s05.html#typical_nslookup_utility_commands
    "Table 88-5. Typical nslookup Utility Commands"). They are specified by preceding
    them with a dash. For example*, `nslookup -timeout=10 www.pcguide.com` *would
    perform the same lookup as in [Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "Example 88-3. DNS name resolution using the nslookup utility"), but with the
    timeout interval set to 10 seconds*.'
  prefs: []
  type: TYPE_NORMAL
- en: The interactive mode of `nslookup` is selected by simply issuing the name of
    the command with no parameters. This will cause the program to display the current
    default name server's DNS name and address, and then provide a prompt at which
    the administrator may enter commands. Interactive mode allows someone to perform
    multiple lookups easily without having to type `nslookup` each time. More important,
    it provides more convenient control over the types of information that can be
    requested and how the lookups are performed.
  prefs: []
  type: TYPE_NORMAL
- en: You can usually determine the exact command set available in an `nslookup` implementation
    by issuing the command `help` or `?` at the `nslookup` prompt. [Table 88-5](ch88s05.html#typical_nslookup_utility_commands
    "Table 88-5. Typical nslookup Utility Commands") shows some of the commands that
    are usually found in most `nslookup` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-5. Typical nslookup Utility Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command and Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<`*`host`*`> [<`*`server`*`>]` | Look up the specified host, optionally
    using the specified DNS name server. Note that there is no actual command here;
    you just enter the name directly at the command prompt. |'
  prefs: []
  type: TYPE_TB
- en: '| `server <`*`server`*`>` | Change the default server to `<`*`server`*`>`,
    using information obtained from the current default server. |'
  prefs: []
  type: TYPE_TB
- en: '| `lserver <`*`server`*`>` | Change the default server to `<`*`server`*`>`,
    using information obtained from the initial name server; that is, the system''s
    default server that was in place when the `nslookup` command was started (prior
    to any preceding changes of the current name server in this session). |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | Changes the default name server to one of the DNS root name servers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ls [-t <`*`type`*`>] <`*`name`*`>` | Requests a list of information available
    for the specified domain name, by conducting a zone transfer. By default, the
    host names and addresses associated with the domain are listed; the `-t` option
    may be used to restrict the output to a particular record type. Other options
    may also be defined. (Most servers restrict the use of zone transfers to designated
    slave servers, so this command may not work for ordinary clients.) |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | Displays help information (usually a list of valid commands and
    options). |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Same as `help` (works on only some systems). |'
  prefs: []
  type: TYPE_TB
- en: '| `set all` | Displays the current value of all `nslookup` options. |'
  prefs: []
  type: TYPE_TB
- en: '| `set <`*`option`*`>[=<`*`value`*`>]` | Sets an option to control the behavior
    of the utility. Most implementations include quite a number of options, some of
    which are controlled by just specifying a keyword, while others require a value
    for the option. For example, `set recurse` tells the program to use recursive
    resolution, while `set norecurse` turns it off. `set retry=3` sets the number
    of retries to 3. |'
  prefs: []
  type: TYPE_TB
- en: '| `exit` | Quits the program. |'
  prefs: []
  type: TYPE_TB
- en: 'The `nslookup` utility is widely deployed on both UNIX and Windows systems,
    but the program is not without its critics. The complaints about it mainly center
    around its use of nonstandard methods of obtaining information, rather than standard
    resolution routines. I have also read reports that it can produce spurious results
    in some cases. One example of a significant problem with the command is that it
    will abort if it is unable to perform a reverse lookup of its own IP address.
    This can cause confusion, because users mistake that error for an error trying
    to find the name they were looking up. For this and other reasons, a number of
    people in UNIX circles consider `nslookup` to be a hack of sorts. In some newer
    UNIX systems, `nslookup` has been deprecated (still included in the operating
    system for compatibility, but not recommended and may be removed in the future).
    Instead, a pair of newer utilities is provided: `host` and `dig`.'
  prefs: []
  type: TYPE_NORMAL
- en: The host Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `host` utility is most often used for simple queries such as those normally
    performed using `nslookup`''s noninteractive mode. It is invoked in the same way
    as noninteractive `nslookup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is also similar to that of noninteractive `nslookup`, but less verbose.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even though `host` does not operate interactively, it includes a number of options
    that can allow an administrator to get the same information that would have been
    obtained using `nslookup`'s interactive mode. Some of the more common options
    are shown in [Table 88-6](ch88s05.html#typical_host_utility_options_and_paramet
    "Table 88-6. Typical host Utility Options and Parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-6. Typical host Utility Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | Turns on debug mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Provides a complete list of information for a domain; this is similar
    to the `ls` command in interactive `nslookup`. This may be used with the `-t`
    option to select only a particular type of resource record for the domain. |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Disables recursion in the request. When this is specified, only the
    server directly queried will return any information; it will not query other servers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-t <`*`query-type`*`>` | Specifies a query for a particular resource record
    type, allowing any type of DNS information to be retrieved. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Uses verbose mode for output (additional details are provided). |'
  prefs: []
  type: TYPE_TB
- en: '| `-w` | Waits as long as necessary for a response (no timeout). |'
  prefs: []
  type: TYPE_TB
- en: The dig Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second alternative to `nslookup` is `dig`, which stands for Domain Information
    Groper (likely a play on the supposed origin of the name `ping`). It differs from
    the `host` command in that it provides considerably more information about a domain,
    even when invoked in the simplest of ways. It is also quite a bit more complicated,
    with a large number of options and features, such as a batch mode for obtaining
    information about many domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax for the `dig` command is different from that of `nslookup`
    and `host`. If you specify a nondefault name server, it is prepended with an at
    sign (@) and comes before the host to be looked up. You can also specify a specific
    type of resource record, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 88-4](ch88s05.html#dns_name_resolution_using_the_nslo-id001 "Example 88-4. DNS
    name resolution using the nslookup utility") shows the output from running `dig`
    on the same domain ([www.pcguide.com](http://www.pcguide.com)) that I used as
    an example for nslookup ([Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "Example 88-3. DNS name resolution using the nslookup utility")) and `host`. You
    can see that it provides much more information about the domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-4. DNS name resolution using the nslookup utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The* `dig` *utility is very useful, but has still not been implemented on
    some systems. Fortunately, there is an online* `dig` *utility you can access using
    your browser on the Internet. Find it at* [http://www.gont.com.ar/tools/dig](http://www.gont.com.ar/tools/dig).'
  prefs: []
  type: TYPE_NORMAL
- en: The `dig` command includes dozens of options and settings. Since this chapter
    is already getting very long and `dig` is by far the most advanced of the three
    utilities, I will stop here. Consult your system's documentation for the full
    instructions on how `dig` works and a list of its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Most TCP/IP implementations provide one or more utilities that
    can be employed by an administrator to manually resolve DNS domain names to IP
    addresses or perform related searches for DNS information. One of the most common
    is nslookup, which allows a host name to be translated to an address or vice versa;
    it has both interactive and noninteractive modes. On some operating systems, nslookup
    has been replaced by the host utility for simple DNS lookups and by the dig program
    for more detailed inspections of DNS resource information.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP DNS Registry Database Lookup Utility (whois/nicname)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilities such as `nslookup` and `host` allow administrators to resolve a DNS
    domain name to an address and also view detailed information about a domain's
    resource records. There are cases, however, where administrators need to know
    its DNS registration information, rather technical information about a domain.
    This includes details such as which organization owns the domain, when its registration
    expires, and who are the designated contacts who manage it.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of DNS, all domain names were centrally registered by a single
    authority, called the Internet Network Information Center (InterNIC or just NIC).
    To allow Internet users to look up information about domains and contacts, InterNIC
    set up a special server. To allow users to retrieve information from this server,
    developers created a protocol called both `nicname` and `whois`. It was initially
    described in RFC 812 (in 1982) and then later in RFC 943 (in 1985). Over time,
    the name `whois` has become the preferred of the two, and it is the one used today
    for the utility program that allows an administrator to look up DNS registration
    data. (It can also be used to look up information about IP addresses, but is used
    for that purpose much less commonly.)
  prefs: []
  type: TYPE_NORMAL
- en: As the Internet grew and expanded, it moved away from having a single centralized
    authority. The modern Internet has a hierarchical structure of authorities that
    are responsible for registering domain names in different portions of the DNS
    name space. In recent years, this has been further complicated by the deregulation
    process that allows multiple registries for the generic top-level domains such
    as .COM, .NET, and .ORG. All of this means that more work is needed to look up
    domain registration information, since it is distributed across many databases
    on different servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier for administrators to find information about domains in this
    large distributed database, modern TCP/IP implementations generally come with
    an intelligent version of the `whois` utility. It is able to accept as input the
    name of a domain and automatically locate the appropriate registry in which that
    domain''s information is located. The utility is usually used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this syntax, `<`*`domain`*`>` represents the name about which registration
    information is requested. The administrator can use the `-h` parameter to force
    the program to query a particular whois server, but again, this is usually not
    required. Some implementations also include other options that can be used to
    direct queries to particular registries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 88-5](ch88s06.html#dns_domain_registry_lookup_using_the_who "Example 88-5. DNS
    domain registry lookup using the whois program") shows the sample output of the
    `whois` command on a FreeBSD UNIX machine (I have stripped out some of the preliminary
    general information and legal disclaimers to shorten the listing).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-5. DNS domain registry lookup using the whois program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the registrar of the domain [pcguide.com](http://pcguide.com)
    is pairNIC, the DNS registry division of pair Networks, the company I have used
    for web hosting for many years (since 1997, as you can see). This output is public
    information and lets anyone who has an interest in pcguide.com determine that
    I own the domain and learn how to contact me. (No, 555-5555 is not my real phone
    number.) It also tells them that pair Networks runs the name servers that contain
    domain information for my domain.
  prefs: []
  type: TYPE_NORMAL
- en: Many operating systems, including Windows, do not come with a `whois` command
    implementation, but there are third-party programs that will support the function.
    In recent years, many different organizations have also set up websites that implement
    the `whois` function, which is much more convenient and user-friendly to those
    more accustomed to graphical user interface operating systems like Windows. Many
    of these sites are provided as free services by DNS registrars, so customers can
    check if a name they are interested in is already taken, and if so, by whom.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of some of these systems is that they usually do not have the intelligence
    to check all the different registries where domain name records are stored. In
    most cases, a `whois` service provided by a registrar will search for names only
    in the particular top-level domains in which the registrar operates. So, if the
    registrar deals with .COM, .ORG, and .NET, it may support `whois` queries only
    for those top-level domains. To check the registration information for domains
    in more obscure domains, such as some of the less common geopolitical (country
    code) domains, a considerable amount of searching may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The TCP/IP `whois` utility allows registration information
    to be displayed for a DNS domain, such as its owner, contact information, and
    the date that its registration expires. The program is most commonly found on
    UNIX operating systems, where it is given intelligence that allows it to automatically
    query the correct servers to find the information for most domains. Newer Web-based
    `whois` utilities also exist, but they are usually limited to displaying information
    about domains in only a specific subset of top-level domains.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Network Status Utility (netstat)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given how complex TCP/IP is, it's actually quite amazing that most of the time,
    all of the different protocols, services, and programs perform their jobs both
    efficiently and silently. Most of us don't even realize just how much is going
    on in the background, and that's as it should be. On the other hand, when a problem
    does occur on a TCP/IP network, the administrator charged with fixing it needs
    to obtain as much information as possible about what all those bits and pieces
    of the suite are doing behind the scenes. The network status utility, `netstat`,
    serves this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `netstat` program is very simple in concept, being designed for only one
    purpose: to show information about the operation of TCP/IP on a device. The complexity
    of TCP/IP, however, leads to `netstat` being rather elaborate itself. The program
    can provide a large variety of information. As usual, the options and output of
    `netstat` depend on the particular operating system type and version. It is somewhat
    different on UNIX and Windows machines, so I will describe each platform''s version
    separately.'
  prefs: []
  type: TYPE_NORMAL
- en: The UNIX netstat Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On most UNIX systems, the `netstat` utility is very full-featured, with a typical
    implementation including dozens of options that can be used to control what information
    is displayed. These options may not all be used simultaneously; rather, they are
    arranged into option groups, each of which presents one class of information.
    Within each group, one option is mandatory, and that is the one that identifies
    the group, and hence the general kind of information that will be displayed. Other
    options are also possible in each group, which are optional and modify the command
    to provide better control of exactly what is output. In essence, `netstat` is
    like many related utilities rolled into one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio "Table 88-7. Typical
    UNIX netstat Option Groups, Options, and Parameters") provides a simplified summary
    of the option groups for a typical UNIX `netstat` implementation, in this case
    FreeBSD.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option Group, Options, and Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat [-AaLSW] [-f <`*`family`*`>] [-p <`*`protocol`*`>] [-n]` | Default
    invocation of `netstat`, with no mandatory options. It prompts the utility to
    display a list of active sockets on the host machine. The other options shown
    can be used to control what precisely is output; for example, `-a` also shows
    server processes. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -i [-abdt] [-f <`*`family`*`>] [-n] netstat -I <`*`interface`*`>
    [-abdt] [-f <`*`family`*`>] [-n]` | Tells `netstat` to provide information about
    all network interfaces (`-i`) or a particular network interface (`-I <`*`interface`*`>`).
    The `-a` option shows multicast addresses as well, `-b` displays bytes of data
    in and out on the interface, `-d` shows the number of dropped packets, and `-t`
    displays the value of watchdog timers. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -w <`*`interval`*`> -d [-I <`*`interface`*`>]` | Displays packet
    traffic information on all interfaces every `<`*`interval`*`>` seconds, or just
    on the specified interface if `-I <`*`interface`*`>` is included. If `-d` is included,
    it also indicates the number of dropped packets. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -s [-s] [-z] [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | Shows
    systemwide statistics for each of the protocols on the system (which may be modified
    to show information for only a particular address family or protocol). If the
    `-s` option is repeated, counters that have a value of zero are suppressed. The
    `-z` option resets the statistics after they are displayed. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -i -s [-f <`*`family`*`>] [-p <`*`protocol`*`>] netstat -I <`*`interface`*`>
    -s [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | Displays statistics as for `netstat
    -s`, but on a per-interface basis rather than aggregated for the whole system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -m` | Outputs memory management routine statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -r [-Aa] [-f <`*`family`*`>] [-n] [-W]` | Displays the contents
    of the host''s routing tables. The options `-A` and `-a` provide additional information
    about the routes. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -rs [-s]` | Displays routing statistics. The `-s` option suppresses
    counters with a zero value. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -g [-W] [-f <`*`family`*`>]` | Shows multicast routing information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -gs [-s] [-f <`*`family`*`>]` | Shows multicast routing statistics.
    The `-s` option suppresses counters with a zero value. |'
  prefs: []
  type: TYPE_TB
- en: Most of the options shown in the option groups in [Table 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio
    "Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters") are
    particular to those groups; for example, you cannot use `-s` when issuing the
    command `netstat -i`. However, there are also a number of universal options that
    can be used with more than one of these groups to modify the behavior of `netstat`
    variations in a consistent way. These options are described in [Table 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "Table 88-8. Typical UNIX netstat Universal Options and Parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-8. Typical UNIX netstat Universal Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-f <`*`family`*`>` | Limits the output of the command to information on
    a particular protocol address family, for hosts running multiple protocol suites.
    For example, the address family for regular TCP/IP is `inet`; for IPv6, it is
    `inet6`. Others may also be supported. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p <`*`protocol`*`>` | Restricts output to data related only to a particular
    protocol, such as IP, TCP, UDP, or ICMP. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Shows network addresses in numeric form, instead of showing them as
    symbolic names. Also shows ports as numbers instead of converting well-known UDP
    and TCP port numbers to the protocol names that use them (for example, 23 rather
    than telnet). |'
  prefs: []
  type: TYPE_TB
- en: '| `-W` | Suppresses the automatic truncation of addresses (which is sometimes
    done for display formatting). |'
  prefs: []
  type: TYPE_TB
- en: 'The `netstat` command can produce a startling amount of output, especially
    if you do not restrict it with some of the options in [Table 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "Table 88-8. Typical UNIX netstat Universal Options and Parameters"). This is
    particularly true for `netstat` by itself and with the `-s` option. [Example 88-6](ch88s07.html#sample_connections_list_from_the_unix_ne
    "Example 88-6. Sample connections list from the UNIX netstat utility") shows sample
    output from running "plain" `netstat`, but I have truncated the list of connections
    so it would not be too long (I also reformatted the listing so it would fit on
    the page better). Notice the last column, which shows the current state of the
    TCP connection (see the TCP finite state machine description in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-6. Sample connections list from the UNIX netstat utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 88-7](ch88s07.html#sample_ip_statistics_from_the_unix_netst "Example 88-7. Sample
    IP statistics from the UNIX netstat utility") shows an example of the output of
    `netstat -s.` Here, I have limited the output by using `-p ip` to tell the program
    to show me only the statistics for IP.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-7. Sample IP statistics from the UNIX netstat utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Windows netstat Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Windows `netstat` utility is quite a bit simpler than the UNIX one, because
    it has a lot fewer options. This is good news for those learning about the program,
    but not so wonderful for those who want maximum power and flexibility in using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Like the UNIX `netstat` version, the Windows utility has a set of options groups
    that dictate the general type of information shown, and a few universal options
    that can be used with multiple groups. The option groups and generic options are
    shown in Tables [Table 88-9](ch88s07.html#typical_windows_netstat_option_groups_op
    "Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters")
    and [Table 88-10](ch88s07.html#typical_windows_netstat_universal_option "Table 88-10. Typical
    Windows netstat Universal Options and Parameters"), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option Group, Options, and Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat [-n] [-o] [<`*`interval`*`>] netstat -a [-n] [-o]` | When called
    with no mandatory options, `netstat` displays information about active TCP connections.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[-p <`*`protocol`*`> [<`*`interval`*`>]` | Displays all active TCP connections,
    as well as both TCP and UDP ports to which the host is listening. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -e [<`*`interval`*`>]` | Shows statistics for Ethernet interfaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -r [<`*`interval`*`>]` | Displays the current routing table for
    the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `netstat -s [-p <`*`protocol`*`>] [<`*`interval`*`>]` | Displays TCP/IP statistics
    for the system by protocol. |'
  prefs: []
  type: TYPE_TB
- en: Table 88-10. Typical Windows netstat Universal Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Displays network addresses in numeric form instead of symbolic name
    form. Also shows ports in numeric form instead of displaying standard process
    names associated with well-known UDP or TCP port numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `-o` | Displays the process ID associated with each connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p <`*`protocol`*`>` | Limits the display to only the information associated
    with the specified protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `<`*`interval`*`>` | Causes the `netstat` command to be repeated every `<`*`interval`*`>`
    seconds, rather than just displaying its information once. This can be used with
    any of the `netstat` option groups. For example, `netstat -s 5` displays TCP/IP
    statistics every 5 seconds. |'
  prefs: []
  type: TYPE_TB
- en: The output from the Windows `netstat` program is fairly similar to that of the
    UNIX utility when the same or similar options are given, but the UNIX version
    usually provides more details. [Example 88-8](ch88s07.html#sample_icmp_statistics_from_the_windows_
    "Example 88-8. Sample ICMP statistics from the Windows netstat utility") shows
    an example illustrating TCP/IP statistics on my home Windows XP machine, using
    `-p icmp` to restrict the output to ICMP statistics only.
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-8. Sample ICMP statistics from the Windows netstat utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 88-9](ch88s07.html#sample_routing_table_display_from_the_wi "Example 88-9. Sample
    routing table display from the Windows netstat utility") shows the routing table
    display from `netstat` (which I modified slightly to fit the page). You would
    get similar output using the UNIX `netstat -s -p icmp` or `netstat -r` command,
    but with additional information.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-9. Sample routing table display from the Windows netstat utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** TCP/IP implementations include the `netstat` utility to allow
    information about network status to be displayed. On UNIX systems, `netstat` is
    a full-featured program with many options arranged into option groups, each of
    which shows a particular type of information about the operation of TCP/IP protocols.
    On Windows systems, `netstat` is somewhat more limited in function, but it still
    can display a considerable amount of information.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Configuration Utilities (ifconfig, ipconfig, and winipcfg)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A significant part of any network administrator's job is setting up and maintaining
    the devices that make a TCP/IP network function, a process generally called *configuration*.
    Networked hosts consist of both hardware and software that work together to implement
    all the layers and functions of the protocol stack. An administrator uses hardware
    tools to configure physical devices, performing tasks such as installing network
    interface cards, connecting cables, and manipulating switches and other hardware
    settings. Similarly, administrators need tools to configure the software that
    runs TCP/IP interfaces and controls the operation of higher-layer protocols on
    networked hosts. UNIX administrators use the `ifconfig` utility. On Windows NT,
    2000, and XP, the configuration tool is `ipconfig`. Earlier versions of Windows
    have the `winipcfg` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The ifconfig Utility for UNIX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On UNIX systems, administrators use the interface configuration utility, `ifconfig`,
    to view and modify the software settings that control how TCP/IP functions on
    a host. It is a very powerful program that allows an administrator to set up and
    manage a very wide array of network settings. The implementation of `ifconfig`
    varies greatly between flavors of UNIX; while most are similar in general terms,
    they may have different options and syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `ifconfig` program for a variety of purposes: to create or
    remove a network interface, change its settings, or simply examine the existing
    configuration. Thus, like the `netstat` utility, `ifconfig` is like several related
    programs combined into one, and how it works depends on the syntax you used to
    invoke it. And also like `netstat`, `ifconfig` has a number of universal options
    that can be applied to many of its different uses.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 88-11](ch88s08.html#typical_unix_ifconfig_syntaxes_options_a "Table 88-11. Typical
    UNIX ifconfig Syntaxes, Options, and Parameters") provides a simplified summary
    of the different functions that `ifconfig` can perform and the syntaxes that are
    used to specify each in a typical UNIX implementation (NetBSD in this case). You
    can use `ifconfig` to modify an interface''s configuration by setting any of several
    dozen configuration parameters, using the syntax shown in the last row of that
    table. [Table 88-12](ch88s08.html#typical_unix_ifconfig_universal_options_ "Table 88-12. Typical
    UNIX ifconfig Universal Options and Parameters") describes the common options
    and parameters that can be used for many of these different modes. I have provided
    a brief description of some sample parameters in [Table 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters") (see
    your `ifconfig` documentation for a complete list).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-11. Typical UNIX ifconfig Syntaxes, Options, and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Syntax, Options and Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig [-L] [-m] <`*`interface`*`>` | When `ifconfig` is called with just
    an interface specification and no other options (other than possibly `-L` and
    `-m`), it displays the configuration information for that network interface.Note
    that entering `ifconfig` by itself with no interface displays just help information
    for the parameter. To see all interfaces, use the `-a` parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [<`*`family`*`>]` | Displays information
    about all the interfaces on the host. The output may be restricted using the universal
    parameters shown or by specifying an address family (see [Table 88-12](ch88s08.html#typical_unix_ifconfig_universal_options_
    "Table 88-12. Typical UNIX ifconfig Universal Options and Parameters")). |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig -l [-b] [-d] [-u] [-s]` | Lists all available interfaces on the
    system. |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig <`*`interface`*`> create` | Creates the specified logical network
    interface on the host, which is then configured using the syntax shown in the
    last row of this table. Note that some variations of UNIX allow certain parameters
    to be set at the time of creation. |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig <`*`interface`*`> destroy` | Destroys the specified logical interface.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ifconfig <`*`interface`*`> [<`*`family`*`>] [<`*`address`*`> [<`*`dest-address`*`>]]
    [<`*`parameters`*`>]` | Configures parameters for a particular interface on the
    host. If the address is being set, it is the first parameter specified, after
    the optional address family, if present. The `<dest-address>` is used to specify
    a destination address for a point-to-point link. After this, any of several dozen
    parameters may be specified for the interface, some of which are shown in [Table 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters"). |'
  prefs: []
  type: TYPE_TB
- en: Table 88-12. Typical UNIX ifconfig Universal Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-L` | Displays the address lifetime for IPv6 addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | Displays all supported media for the interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | Limits the display of interface information to broadcast interfaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | Shows only interfaces that are presently down (disabled). |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | Shows only interfaces that are presently up (operational). |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Shows only interfaces that may be connected. |'
  prefs: []
  type: TYPE_TB
- en: '| `<`*`family`*`>` | Specifies a particular address family, either to limit
    output or indicate what address type is being configured. The value `inet` is
    used for IPv4 and `inet6` for IPv6. |'
  prefs: []
  type: TYPE_TB
- en: Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `alias / -alias` | Establishes or removes a network address alias. |'
  prefs: []
  type: TYPE_TB
- en: '| `arp / -arp` | Enables or disables the use of ARP on this interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | Removes the specified network address. |'
  prefs: []
  type: TYPE_TB
- en: '| `down` | Marks an interface as being down, disabling it. |'
  prefs: []
  type: TYPE_TB
- en: '| `media <`*`type`*`>` | Sets the media type of the interface to a particular
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `mtu <`*`n`*`>` | Sets the maximum transmission unit (MTU) of the interface.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `netmask <`*`mask`*`>` | Sets the network or subnet mask for the interface''s
    address. |'
  prefs: []
  type: TYPE_TB
- en: '| `pref`ixlen <*`n`*`>` | Same as `netmask` but allows the mask to be specified
    using a CIDR-style prefix length. |'
  prefs: []
  type: TYPE_TB
- en: '| `up` | Sets an interface up, enabling it. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Since creating, destroying, or modifying interfaces can cause a host to stop
    working properly, administrative (superuser) rights are generally required on
    most systems in order to do anything with* `ifconfig` *other than examining the
    existing configuration*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 88-10](ch88s08.html#sample_output_of_the_unix_ifconfig_-a_co "Example 88-10. Sample
    output of the UNIX ifconfig -a command") shows sample output of the `ifconfig
    -a` command on one of the UNIX machines I use regularly, showing the settings
    for its interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-10. Sample output of the UNIX ifconfig -a command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The ipconfig for Windows NT, 2000, and XP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows takes a somewhat different approach to network configuration than UNIX.
    As described in the previous section, you can use the UNIX `ifconfig` program
    both to view and modify a wide range of configuration parameters. In Windows,
    however, most setup and parameter modification is done using the Windows Control
    Panel. Windows does include a utility that is somewhat similar to UNIX's `ifconfig`,
    but it has far less functionality and is used mainly to inspect the existing configuration,
    not change it. It also allows an administrator to easily perform a few simple
    functions on a host.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows NT, 2000, and XP, the equivalent of `ifconfig` is a command-line
    utility called `ipconfig`. Like `ifconfi`g, the Windows utility is controlled
    using options that are supplied to the program. However, because it is so much
    simpler than `ifconfig`, there are only a few options, as summarized in [Table 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "Table 88-14. Typical Windows ipconfig Options and Parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-14. Typical Windows ipconfig Options and Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Option/Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (none) | When called with no options or parameters, `ipconfig` displays the
    IP address, subnet mask, and default gateway for each interface on the host. |'
  prefs: []
  type: TYPE_TB
- en: '| `/all` | Similar to calling `ipconfig` with no options, but displays more
    detailed configuration information about the host''s interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| `/release [<`*`adapter`*`>]` | Releases (terminates) the DHCP lease on either
    the specified adapter (interface) or all interfaces, if none is provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `/`renew [<*`adapter`*`>]` | Manually renews the DHCP lease for either the
    specified adapter (interface) or all adapters, if none is mentioned. |'
  prefs: []
  type: TYPE_TB
- en: '| `/displaydns` | Displays the contents of the host''s DNS resolver cache.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/flushdns` | Clears the host''s DNS resolver cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `/re`gisterdns | Refreshes (renews) all DHCP leases and also reregisters
    any DNS names associated with the host. |'
  prefs: []
  type: TYPE_TB
- en: '| `/showclassid <`*`adapter`*`>` | Displays DHCP class IDs associated with
    this adapter (these are used to arrange clients into groups that are given different
    treatment by DHCP servers). The adapter must be specified, even if there is only
    one. |'
  prefs: []
  type: TYPE_TB
- en: '| `/setclassid <`*`adapter`*`> [<`*`classid`*`>]` | Modifies the DHCP class
    ID for the specified adapter. |'
  prefs: []
  type: TYPE_TB
- en: As mentioned earlier, `ipconfig` is most often used to just examine the existing
    configuration. You can see from the list of options in [Table 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "Table 88-14. Typical Windows ipconfig Options and Parameters") that most of the
    other uses of `ipconfig` are related to controlling the operation of protocols
    such as DNS and the Dynamic Host Configuration Protocol (DHCP), rather than configuring
    a host. One common use of `ipconfig` is to force a host to seek out a new DHCP
    lease, which can be done using `ipconfig /release` followed by `ipconfig /renew`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 88-11](ch88s08.html#simplified_configuration_information_fro "Example 88-11. Simplified
    configuration information from the Windows ipconfig utility") shows an example
    of the output from using the `ipconfig` command without any options. For detailed
    information on interfaces, you can use the `/all` option, as shown in the example
    in [Example 88-12](ch88s08.html#detailed_configuration_information_from_ "Example 88-12. Detailed
    configuration information from the Windows ipconfig utility") (which I''ve modified
    slightly so it is easier to read).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 88-11. Simplified configuration information from the Windows ipconfig
    utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example 88-12. Detailed configuration information from the Windows ipconfig
    utility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The winipcfg Utility for Windows 95, 98, and Me
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows 95, 98, and Me have a graphical tool called `winipcfg`, instead of the
    `ipconfig` command-line utility. This program allows you to examine the configuration
    parameters in much the same way as `ipconfig`, and also to release and renew DHCP
    leases, but it does not support the other options of `ipconfig` (such as displaying
    the host's DNS cache). An example of the main `winipcfg` screen is shown in [Figure 88-2](ch88s08.html#windows_9598me_winipcfg_utility_the_wini
    "Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used
    in older, consumer-oriented versions of Windows to check the configuration of
    a host and release/renew DHCP leases.").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** On UNIX systems, the `ifconfig` utility can be used to display
    or modify a large number of TCP/IP configuration settings. Windows systems provide
    either the command-line utility `ipconfig` or the graphical tool winipcfg. Both
    let an administrator see basic TCP/IP configuration information for a host and
    allow tasks to be performed such as renewing a DHCP lease, but they are otherwise
    quite limited compared with the UNIX `ifconfig` program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows 95/98/Me winipcfg utility The winipcfg utility can be used in older,
    consumer-oriented versions of Windows to check the configuration of a host and
    release/renew DHCP leases.](httpatomoreillycomsourcenostarchimages288329.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used
    in older, consumer-oriented versions of Windows to check the configuration of
    a host and release/renew DHCP leases.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous TCP/IP Troubleshooting Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as you set up a network, it will very quickly develop problems that
    you will need to address. Recognizing that the complexity of TCP/IP internetworks
    would make diagnosing certain problems difficult, the suite's architects defined
    a number of miscellaneous utility protocols that can be helpful in testing and
    troubleshooting networks. Despite having been around for more than 20 years, these
    protocols are somewhat obscure and get little attention. However, even though
    they are no longer implemented on many systems, I feel they are worth a quick
    look.
  prefs: []
  type: TYPE_NORMAL
- en: These simple protocols are designed to be implemented as services that run on
    TCP/IP servers. Each listens for requests on a dedicated well-known port number
    and then responds with a particular type of information. These protocols can be
    used with both TCP and UDP, enabling each transport protocol to be tested. In
    the case of UDP, the server counts each UDP datagram sent to it as a request and
    sends a response to it. When used with TCP, a connection is first established
    by the client to the server. In some of the protocols, this connection is then
    used to send data continuously between the client and server; in others, the establishment
    of the connection is considered an implied request to the server, which will immediately
    send a response and then close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 88-15](ch88s09.html#miscellaneous_tcpip_troubleshootin-id001 "Table 88-15. Miscellaneous
    TCP/IP Troubleshooting Protocols") provides a brief description of each of these
    troubleshooting protocols under both UDP and TCP. I have shown for each the port
    number that the service uses and also the RFC that defines it.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 88-15. Miscellaneous TCP/IP Troubleshooting Protocols
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol | Well-Known Port Number | Defining RFC | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Echo Protocol | 7 | 862 | Echoes received data back to its originator. When
    used on UDP, the payload of each message is simply packaged into a return UDP
    datagram and sent back. For TCP, each byte sent by the client is echoed back by
    the server until the connection is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| Discard Protocol | 9 | 863 | Throws away all data that is sent to it. |'
  prefs: []
  type: TYPE_TB
- en: '| Character Generator Protocol | 19 | 864 | Generates random characters of
    data and sends them to a device. When used with UDP, each UDP message sent to
    the server causes it to send back a UDP message containing a random amount (0
    to 512 bytes) of data. When used with TCP, the server just starts sending characters
    as soon as a client establishes a connection, and continues until the connection
    is terminated by the client. |'
  prefs: []
  type: TYPE_TB
- en: '| Quote of the Day Protocol | 17 | 865 | Sends a short message (selected by
    the server''s administrator) to a client device. For UDP, the message is sent
    for each incoming UDP message; for TCP, the message is sent by the server once
    when the connection is established, which is then closed. |'
  prefs: []
  type: TYPE_TB
- en: '| Active Users | 11 | 866 | Sends a list of active users to a device. For UDP,
    the list is sent for each incoming UDP message; if it is longer than 512 bytes,
    it will be sent in multiple messages. For TCP, the list is sent automatically
    when the connection is made to the server, and then the connection is terminated.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Daytime Protocol | 13 | 867 | Returns the current time on the server in human-readable
    form, in response to receipt of a UDP message or an incoming TCP connection. |'
  prefs: []
  type: TYPE_TB
- en: '| Time Protocol | 37 | 868 | Returns the current time in machine-readable form—specifically,
    the number of seconds since midnight, January 1, 1900 GMT. The time is sent for
    each UDP message received by the server or upon establishment of a TCP connection.Note
    that this protocol cannot be used for time synchronization of servers, because
    it does not compensate for variability in the time required for the messages to
    be carried over the internetwork. |'
  prefs: []
  type: TYPE_TB
