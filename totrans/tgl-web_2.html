<html><head></head><body><div class="part" title="Part&#xA0;I.&#xA0;Anatomy of the Web"><div class="titlepage"><div><div><h1 class="title"><a id="anatomy_of_the_web"/>Part I. Anatomy of the Web</h1></div></div></div><div class="partintro" id="id2683742" title="Anatomy of the Web"><div/><p>The first part of this book focuses on the principal concepts that govern the operation of web browsers, namely, the protocols, document formats, and programming languages that make it all tick. Because all the familiar, user-visible security mechanisms employed in modern browsers are profoundly intertwined with these inner workings, the bare internals deserve a fair bit of attention before we wander off deeper into the woods.</p></div></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;It Starts with a URL"><div class="titlepage"><div><div><h1 class="title"><a id="it_starts_with_a_url"/>Chapter 2. It Starts with a URL</h1></div></div></div><p>The most recognizable hallmark of the Web is a simple text string known as the <span class="emphasis"><em>Uniform Resource Locator (URL)</em></span>. Each well-formed, fully qualified URL is meant to conclusively address and uniquely identify a single resource on a remote server (and in doing so, implement a couple of related, auxiliary functions). The URL syntax is the cornerstone of the address bar, the most important user interface (UI) security indicator in every browser.<a class="indexterm" id="IDX-CHP-2-0001"/></p><p>In addition to true URLs used for content retrieval, several classes of <span class="emphasis"><em>pseudo-URLs</em></span> use a similar syntax to provide convenient access to browser-level features, including the integrated scripting engine, several special document-rendering modes, and so on. Perhaps unsurprisingly, these pseudo-URL actions can have a significant impact on the security of any site that decides to link to them.<a class="indexterm" id="IDX-CHP-2-0002"/></p><p>The ability to figure out how a particular URL will be interpreted by the browser, and the side effects it will have, is one of the most basic and common security tasks attempted by humans and web applications alike, but it can be a problematic one. The generic URL syntax, the work of Tim Berners-Lee, is codified primarily in RFC 3986;<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-1">94</a>]</sup> its practical uses on the Web are outlined in RFCs 1738,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-2">95</a>]</sup> 2616,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-3">96</a>]</sup> and a couple of other, less-significant standards. These documents are remarkably detailed, resulting in a fairly complex parsing model, but they are not precise enough to lead to harmonious, compatible implementations in all client software. In addition, individual software vendors have chosen to deviate from the specifications for their own reasons.<a class="indexterm" id="IDX-CHP-2-0003"/><a class="indexterm" id="IDX-CHP-2-0004"/><a class="indexterm" id="IDX-CHP-2-0005"/><a class="indexterm" id="IDX-CHP-2-0006"/><a class="indexterm" id="IDX-CHP-2-0007"/><a class="indexterm" id="IDX-CHP-2-0008"/><a class="indexterm" id="IDX-CHP-2-0009"/><a class="indexterm" id="IDX-CHP-2-0010"/><a class="indexterm" id="IDX-CHP-2-0011"/><a class="indexterm" id="IDX-CHP-2-0012"/><a class="indexterm" id="IDX-CHP-2-0013"/><a class="indexterm" id="IDX-CHP-2-0014"/><a class="indexterm" id="IDX-CHP-2-0015"/><a class="indexterm" id="IDX-CHP-2-0016"/><a class="indexterm" id="IDX-CHP-2-0017"/></p><p>Let’s have a closer look at how the humble URL works in practice.</p><div class="sect1" title="Uniform Resource Locator Structure"><div class="titlepage"><div><div><h1 class="title"><a id="uniform_resource_locator_structure"/>Uniform Resource Locator Structure</h1></div></div></div><p><a class="xref" href="ch02.html#structure_of_an_absolute_url" title="Figure 2-1. Structure of an absolute URL">Figure 2-1</a> shows the format of a <span class="emphasis"><em>fully qualified absolute URL</em></span>, one that specifies all information required to access a particular resource and that does not depend in any way on where the navigation began. In contrast, a <span class="emphasis"><em>relative URL</em></span>, such as <span class="emphasis"><em>../file.php?text=hello+world</em></span>, omits some of this information and must be interpreted in the context of a base URL associated with the current browsing context.<a class="indexterm" id="IDX-CHP-2-0018"/></p><div class="figure"><a id="structure_of_an_absolute_url"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1303"/><img alt="Structure of an absolute URL" src="httpatomoreillycomsourcenostarchimages949989.png.jpg"/></div></div><p class="title">Figure 2-1. Structure of an absolute URL</p></div><p>The segments of the absolute URL seem intuitive, but each comes with a set of gotchas, so let’s review them now.</p><div class="sect2" title="Scheme Name"><div class="titlepage"><div><div><h2 class="title"><a id="scheme_name"/>Scheme Name</h2></div></div></div><p>The <span class="emphasis"><em>scheme name</em></span> is a case-insensitive string that ends with a single colon, indicating the protocol to be used to retrieve the resource. The official registry of valid URL schemes is maintained by the <span class="emphasis"><em>Internet Assigned Numbers Authority</em></span> (<span class="emphasis"><em>IANA</em></span>), a body more widely known for its management of the IP address space.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-4">97</a>]</sup> IANA’s current list of valid scheme names includes several dozen entries such as <span class="emphasis"><em>http:</em></span>, <span class="emphasis"><em>https:</em></span>, and <span class="emphasis"><em>ftp:</em></span>; in practice, a much broader set of schemes is informally recognized by common browsers and third-party applications, some which have special security consequences. (Of particular interest are several types of pseudo-URLs, such as <span class="emphasis"><em>data:</em></span> or <span class="emphasis"><em>javascript:</em></span>, as discussed later in this chapter and throughout the remainder of this book.)<a class="indexterm" id="IDX-CHP-2-0019"/><a class="indexterm" id="IDX-CHP-2-0020"/></p><p>Before they can do any further parsing, browsers and web applications need to distinguish fully qualified absolute URLs from relative ones. The presence of a valid scheme in front of the address is meant to be the key difference, as defined in RFC 1738: In a compliant absolute URL, only the alphanumerics “+”, “−”, and “.” may appear before the required “:”. In practice, however, browsers deviate from this guidance a bit. All ignore leading newlines and white spaces. Internet Explorer ignores the entire nonprintable character range of ASCII codes 0x01 to 0x1F. Chrome additionally skips 0x00, the NUL character. Most implementations also ignore newlines and tabs in the middle of scheme names, and Opera accepts high-bit characters in the string.<a class="indexterm" id="IDX-CHP-2-0021"/><a class="indexterm" id="IDX-CHP-2-0022"/><a class="indexterm" id="IDX-CHP-2-0023"/><a class="indexterm" id="IDX-CHP-2-0024"/><a class="indexterm" id="IDX-CHP-2-0025"/><a class="indexterm" id="IDX-CHP-2-0026"/><a class="indexterm" id="IDX-CHP-2-0027"/><a class="indexterm" id="IDX-CHP-2-0028"/><a class="indexterm" id="IDX-CHP-2-0029"/><a class="indexterm" id="IDX-CHP-2-0030"/></p><p>Because of these incompatibilities, applications that depend on the ability to differentiate between relative and absolute URLs must conservatively reject any anomalous syntax—but as we will soon find out, even this is not enough.</p></div><div class="sect2" title="Indicator of a Hierarchical URL"><div class="titlepage"><div><div><h2 class="title"><a id="indicator_of_a_hierarchical_url"/>Indicator of a Hierarchical URL</h2></div></div></div><p>In order to comply with the generic syntax rules laid out in RFC 1738, every absolute, hierarchical URL is required to contain the fixed string “//” right before the authority section. If the string is missing, the format and function of the remainder of the URL is undefined for the purpose of that specification and must be treated as an opaque, scheme-specific value.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An example of a nonhierarchical URL is the <span class="emphasis"><em>mailto:</em></span> protocol, used to specify email addresses and possibly a subject line (<span class="emphasis"><em>mailto:</em></span><span class="email"><a class="email" href="mailto:user@example.com?subject=Hello+world">user@example.com?subject=Hello+world</a></span>). Such URLs are passed down to the default mail client without making any further attempt to parse them.</p></div><p>The concept of a generic, hierarchical URL syntax is, in theory, an elegant one. It ought to enable applications to extract some information about the address without knowing how a particular scheme works. For example, without a preconceived notion of the <span class="emphasis"><em>wacky-widget:</em></span> protocol, and by applying the concept of generic URL syntax alone, the browser could decide that <a class="ulink" href="http://example.com/test1/">http://example.com/test1/</a> and <span class="emphasis"><em>wacky-widget://example.com/test2/</em></span> reference the same, trusted remote host.</p><p>Regrettably, the specification has an interesting flaw: The aforementioned RFC says nothing about what the implementer should do when encountering URLs where the scheme is known to be nonhierarchical but where a “//” prefix still appears, or vice versa. In fact, a reference parser implementation provided in RFC 1630 contains an unintentional loophole that gives a counterintuitive meaning to the latter class of URLs. In RFC 3986, published some years later, the authors sheepishly acknowledge this flaw and permit implementations to try to parse such URLs for compatibility reasons. As a consequence, many browsers interpret the following examples in unexpected ways:<a class="indexterm" id="IDX-CHP-2-0031"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bolditalic">http:example.com/</span> In Firefox, Chrome, and Safari, this address may be treated identically to <a class="ulink" href="http://example.com/">http://example.com/</a> when no fully qualified base URL context exists and as a relative reference to a directory named <span class="emphasis"><em>example.com</em></span> when a valid base URL is available.</p></li><li class="listitem"><p><span class="bolditalic">javascript://example.com/%0Aalert(1)</span> This string is interpreted as a valid nonhierarchical pseudo-URL in all modern browsers, and the JavaScript <span class="emphasis"><em>alert(1)</em></span> code will execute, showing a simple dialog window.<a class="indexterm" id="IDX-CHP-2-0032"/><a class="indexterm" id="IDX-CHP-2-0033"/><a class="indexterm" id="IDX-CHP-2-0034"/><a class="indexterm" id="IDX-CHP-2-0035"/><a class="indexterm" id="IDX-CHP-2-0036"/><a class="indexterm" id="IDX-CHP-2-0037"/><a class="indexterm" id="IDX-CHP-2-0038"/><a class="indexterm" id="IDX-CHP-2-0039"/><a class="indexterm" id="IDX-CHP-2-0040"/><a class="indexterm" id="IDX-CHP-2-0041"/></p></li><li class="listitem"><p><span class="bolditalic">mailto://user@example.com</span> Internet Explorer accepts this URL as a valid nonhierarchical reference to an email address; the “//” part is simply skipped. Other browsers disagree.</p></li></ul></div></div><div class="sect2" title="Credentials to Access the Resource"><div class="titlepage"><div><div><h2 class="title"><a id="credentials_to_access_the_resource"/>Credentials to Access the Resource</h2></div></div></div><p>The credentials portion of the URL is optional. This location can specify a username, and perhaps a password, that may be required to retrieve the data from the server. The method through which these credentials are exchanged is not specified as a part of the abstract URL syntax, and it is always protocol specific. For those protocols that do not support authentication, the behavior of a credential-bearing URL is simply undefined.<a class="indexterm" id="IDX-CHP-2-0042"/></p><p>When no credentials are supplied, the browser will attempt to fetch the resource anonymously. In the case of HTTP and several other protocols, this means not sending any authentication data; for FTP, it involves logging into a guest account named <span class="emphasis"><em>ftp</em></span> with a bogus password.</p><p>Most browsers accept almost any characters, other than general URL section delimiters, in this section with two exceptions: Safari, for unclear reasons, rejects a broader set of characters, including “&lt;”, “&gt;”, “{”, and “}”, while Firefox also rejects newlines.<sup>[<a class="footnote" href="#ftn.CHP-2-FN-1" id="CHP-2-FN-1">10</a>]</sup></p></div><div class="sect2" title="Server Address"><div class="titlepage"><div><div><h2 class="title"><a id="server_address"/>Server Address</h2></div></div></div><p>For all fully qualified hierarchical URLs, the server address section must specify a case-insensitive DNS name (such as <span class="emphasis"><em>example.com</em></span>), a raw IPv4 address (such as <span class="emphasis"><em>127.0.0.1</em></span>), or an IPv6 address in square brackets (such as <span class="emphasis"><em>[0:0:0:0:0:0:0:1]</em></span>), indicating the location of a server hosting the requested resource. Firefox will also accept IPv4 addresses and hostnames in square brackets, but other implementations reject them immediately.</p><p>Although the RFC permits only canonical notations for IP addresses, standard C libraries used by most applications are much more relaxed, accepting noncanonical IPv4 addresses that mix octal, decimal, and hexadecimal notation or concatenate some or all of the octets into a single integer. As a result, the following options are recognized as equivalent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bolditalic">http://127.0.0.1/</span> This is a canonical representation of an IPv4 address.</p></li><li class="listitem"><p><span class="bolditalic">http://0x7f.1/</span> This is a representation of the same address that uses a hexadecimal number to represent the first octet and concatenates all the remaining octets into a single decimal value.</p></li><li class="listitem"><p><span class="bolditalic">http://017700000001/</span> The same address is denoted using a 0-prefixed octal value, with all octets concatenated into a single 32-bit integer.</p></li></ul></div><p>A similar laid-back approach can be seen with DNS names. Theoretically, DNS labels need to conform to a very narrow character set (specifically, alphanumerics, “.”, and “-”, as defined in RFC 1035<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-5">98</a>]</sup>), but many browsers will happily ask the underlying operating system resolver to look up almost anything, and the operating system will usually also not make a fuss. The exact set of characters accepted in the hostname and passed to the resolver varies from client to client. Safari is most rigorous, while Internet Explorer is the most permissive. Perhaps of note, several control characters in the 0x0A-0x0D and 0xA0-0xAD ranges are ignored by most browsers in this portion of the URL.<a class="indexterm" id="IDX-CHP-2-0043"/><a class="indexterm" id="IDX-CHP-2-0044"/><a class="indexterm" id="IDX-CHP-2-0045"/><a class="indexterm" id="IDX-CHP-2-0046"/><a class="indexterm" id="IDX-CHP-2-0047"/><a class="indexterm" id="IDX-CHP-2-0048"/><a class="indexterm" id="IDX-CHP-2-0049"/><a class="indexterm" id="IDX-CHP-2-0050"/><a class="indexterm" id="IDX-CHP-2-0051"/><a class="indexterm" id="IDX-CHP-2-0052"/><a class="indexterm" id="IDX-CHP-2-0053"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>One fascinating behavior of the URL parsers in all of the mainstream browsers is their willingness to treat the character “<span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1603"/><img alt="" src="httpatomoreillycomsourcenostarchimages949991.png"/></span>” (ideographic full stop, Unicode point U+3002) identically to a period in hostnames but not anywhere else in the URL. This is reportedly because certain Chinese keyboard mappings make it much easier to type this symbol than the expected 7-bit ASCII value.</p></div></div><div class="sect2" title="Server Port"><div class="titlepage"><div><div><h2 class="title"><a id="server_port"/>Server Port</h2></div></div></div><p>This server port is an optional section that describes a nonstandard network port to connect to on the previously specified server. Virtually all application-level protocols supported by browsers and third-party applications use TCP or UDP as the underlying transport method, and both TCP and UDP rely on 16-bit port numbers to separate traffic between unrelated services running on a single machine. Each scheme is associated with a default port on which servers for that protocol are customarily run (80 for HTTP, 21 for FTP, and so on), but the default can be overridden at the URL level.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An interesting and unintended side effect of this feature is that browsers can be tricked into sending attacker-supplied data to random network services that do not speak the protocol the browser expects them to. For example, one may point a browser to <a class="ulink" href="http://mail.example.com:25/">http://mail.example.com:25/</a>, where 25 is a port used by the Simple Mail Transfer Protocol (SMTP) service rather than HTTP. This fact has caused a range of security problems and prompted a number of imperfect workarounds, as discussed in more detail in <a class="xref" href="pt02.html" title="Part II. Browser Security Features">Part II</a> of this book.<a class="indexterm" id="IDX-CHP-2-0054"/></p></div></div><div class="sect2" title="Hierarchical File Path"><div class="titlepage"><div><div><h2 class="title"><a id="hierarchical_file_path"/>Hierarchical File Path</h2></div></div></div><p>The next portion of the URL, the hierarchical file path, is envisioned as a way to identify a specific resource to be retrieved from the server, such as <span class="emphasis"><em>/documents/2009/my_diary.txt</em></span>. The specification quite openly builds on top of the Unix directory semantics, mandating the resolution of “/../” and “/./” segments in the path and providing a directory-based method for sorting out relative references in non-fully qualified URLs.</p><p>Using the filesystem model must have seemed like a natural choice in the 1990s, when web servers acted as simple gateways to a collection of static files and the occasional executable script. But since then, many contemporary web application frameworks have severed any remaining ties with the filesystem, interfacing directly with database objects or registered locations in resident program code. Mapping these data structures to well-behaved URL paths is possible but not always practiced or practiced carefully. All of this makes automated content retrieval, indexing, and security testing more complicated than it should be.<a class="indexterm" id="IDX-CHP-2-0055"/><a class="indexterm" id="IDX-CHP-2-0056"/><a class="indexterm" id="IDX-CHP-2-0057"/><a class="indexterm" id="IDX-CHP-2-0058"/><a class="indexterm" id="IDX-CHP-2-0059"/><a class="indexterm" id="IDX-CHP-2-0060"/><a class="indexterm" id="IDX-CHP-2-0061"/><a class="indexterm" id="IDX-CHP-2-0062"/></p></div><div class="sect2" title="Query String"><div class="titlepage"><div><div><h2 class="title"><a id="query_string"/>Query String</h2></div></div></div><p>The query string is an optional section used to pass arbitrary, nonhierarchical parameters to the resource earlier identified by the path. One common example is passing user-supplied terms to a server-side script that implements the search functionality, such as:</p><a id="I_programlisting1_d1e1677"/><pre class="programlisting">http://example.com/<strong class="userinput"><code>search.php?query=Hello+world</code></strong></pre><p>Most web developers are accustomed to a particular layout of the query string; this familiar format is generated by browsers when handling HTML-based forms and follows this syntax:</p><a id="I_programlisting1_d1e1683"/><pre class="programlisting">name1=value1&amp;name2=value2...</pre><p>Surprisingly, such layout is not mandated in the URL RFCs. Instead, the query string is treated as an opaque blob of data that may be interpreted by the final recipient as it sees fit, and unlike the path, it is not encumbered with specific parsing rules.</p><p>Hints of the commonly used format can be found in an informational RFC 1630,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-6">99</a>]</sup> in a mail-related RFC 2368,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-7">100</a>]</sup> and in HTML specifications dealing with forms.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-8">101</a>]</sup> None of this is binding, and therefore, while it may be impolite, it is not a mistake for web applications to employ arbitrary formats for whatever data they wish to put in that part of the URL.<a class="indexterm" id="IDX-CHP-2-0063"/></p></div><div class="sect2" title="Fragment ID"><div class="titlepage"><div><div><h2 class="title"><a id="fragment_id"/>Fragment ID</h2></div></div></div><p>The fragment ID is an opaque value with a role similar to the query string but that provides optional instructions for the client application rather than the server. (In fact, the value is not supposed to be sent to the server at all.) Neither the format nor function of the fragment ID is clearly specified in the RFCs, but it is hinted that it may be used to address “subresources” in the retrieved document or to provide other document-specific rendering cues.</p><p>In practice, fragment identifiers have only a single sanctioned use in the browser: that of specifying the name of an anchor HTML element for in-document navigation. The logic is simple. If an anchor name is supplied in the URL and a matching HTML tag can be located, the document will be scrolled to that location for viewing; otherwise, nothing happens. Because the information is encoded in the URL, this particular view of a lengthy document could be easily shared with others or bookmarked. In this use, the meaning of a fragment ID is limited to scrolling an existing document, so there is no need to retrieve any new data from the server when only this portion of the URL is updated in response to user actions.</p><p>This interesting property has led to another, more recent and completely ad hoc use of this value: to store miscellaneous state information needed by client-side scripts. For example, consider a map-browsing application that puts the currently viewed map coordinates in the fragment identifier so that it will know to resume from that same location if the link is bookmarked or shared. Unlike updating the query string, changing the fragment ID on-the-fly will not trigger a time-consuming page reload, making this data-storage trick a killer feature.<a class="indexterm" id="IDX-CHP-2-0064"/><a class="indexterm" id="IDX-CHP-2-0065"/><a class="indexterm" id="IDX-CHP-2-0066"/><a class="indexterm" id="IDX-CHP-2-0067"/><a class="indexterm" id="IDX-CHP-2-0068"/><a class="indexterm" id="IDX-CHP-2-0069"/><a class="indexterm" id="IDX-CHP-2-0070"/><a class="indexterm" id="IDX-CHP-2-0071"/></p></div><div class="sect2" title="Putting It All Together Again"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together_again"/>Putting It All Together Again</h2></div></div></div><p>Each of the aforementioned URL segments is delimited by certain reserved characters: slashes, colons, question marks, and so on. To make the whole approach usable, these delimiting characters should not appear anywhere in the URL for any other purpose. With this assumption in mind, imagine a sample algorithm to split absolute URLs into the aforementioned functional parts in a manner at least vaguely consistent with how browsers accomplish this task. A reasonably decent example of such an algorithm could be:<a class="indexterm" id="IDX-CHP-2-0072"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>STEP 1: Extract the scheme name</strong></span>.</span></dt><dd><p>Scan for the first “:” character. The part of the URL to its left is the scheme name. Bail out if the scheme name does not conform to the expected set of characters; the URL may need to be treated as a relative one if so.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 2: Consume the hierarchical URL identifier</strong></span>.</span></dt><dd><p>The string “//” should follow the scheme name. Skip it if found; bail out if not.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In some parsing contexts, implementations will be just as happy with zero, one, or even three or more slashes instead of two, for usability reasons. In the same vein, from its inception, Internet Explorer accepted backslashes (\) in lieu of slashes in any location in the URL, presumably to assist inexperienced users.<sup>[<a class="footnote" href="#ftn.CHP-2-FN-2" id="CHP-2-FN-2">11</a>]</sup> All browsers other than Firefox eventually followed this trend and recognize URLs such as <span class="emphasis"><em>http:\\example.com\</em></span>.</p></div></dd><dt><span class="term"><span class="strong"><strong>STEP 3: Grab the authority section</strong></span>.</span></dt><dd><p>Scan for the next “/”, “?”, or “#”, whichever comes first, to extract the authority section from the URL. As mentioned above, most browsers will also accept “\” as a delimiter in place of a forward slash, which may need to be accounted for. The semicolon (;) is another acceptable authority delimiter in browsers other than Internet Explorer and Safari; the reason for this decision is unknown.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 3A: Find the credentials, if any</strong></span>.</span></dt><dd><p>Once the authority section is extracted, locate the at symbol (@) in the substring. If found, the leading snippet constitutes login credentials, which should be further tokenized at the first occurrence of a colon (if present) to split the login and password data.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 3B: Extract the destination address</strong></span>.</span></dt><dd><p>The remainder of the authority section is the destination address. Look for the first colon to separate the hostname from the port number. A special case is needed for bracket-enclosed IPv6 addresses, too.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 4: Identify the path (if present)</strong></span>.</span></dt><dd><p>If the authority section is followed immediately by a forward slash—or for some implementations, a backslash or semicolon, as noted earlier—scan for the next “?”, “#”, or end-of-string, whichever comes first. The text in between constitutes the path section, which should be normalized according to Unix path semantics.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 5: Extract the query string (if present)</strong></span>.</span></dt><dd><p>If the last successfully parsed segment is followed by a question mark, scan for the next “#” character or end-of-string, whichever comes first. The text in between is the query string.</p></dd><dt><span class="term"><span class="strong"><strong>STEP 6: Extract the fragment identifier (if present)</strong></span>.</span></dt><dd><p>If the last successfully parsed segment is followed by “#”, everything from that character to the end-of-string is the fragment identifier. Either way, you’re done!</p></dd></dl></div><p>This algorithm may seem mundane, but it reveals subtle details that even seasoned programmers normally don’t think about. It also illustrates that it is extremely difficult for casual users to understand how a particular URL may be parsed. Let's start with this fairly simple case:</p><a id="I_programlisting1_d1e1835"/><pre class="programlisting">http://example.com&amp;gibberish=1234@167772161/</pre><p>The target of this URL—a concatenated IP address that decodes to 10.0.0.1—is not readily apparent to a nonexpert, and many users would believe they are visiting <span class="emphasis"><em>example.com</em></span> instead.<sup>[<a class="footnote" href="#ftn.CHP-2-FN-3" id="CHP-2-FN-3">12</a>]</sup> But all right, that was an easy one! So let’s have a peek at this syntax instead:</p><a id="I_programlisting1_d1e1846"/><pre class="programlisting">http://example.com\@coredump.cx/</pre><p>In Firefox, that URL will take the user to <span class="emphasis"><em>coredump.cx</em></span>, because <span class="emphasis"><em>example.com\</em></span> will be interpreted as a valid value for the login field. In almost all other browsers, “\” will be interpreted as a path delimiter, and the user will land on <span class="emphasis"><em>example.com</em></span> instead.</p><p>An even more frustrating example exists for Internet Explorer. Consider this:<a class="indexterm" id="IDX-CHP-2-0073"/><a class="indexterm" id="IDX-CHP-2-0074"/><a class="indexterm" id="IDX-CHP-2-0075"/><a class="indexterm" id="IDX-CHP-2-0076"/><a class="indexterm" id="IDX-CHP-2-0077"/><a class="indexterm" id="IDX-CHP-2-0078"/></p><a id="I_programlisting1_d1e1883"/><pre class="programlisting">http://example.com;.coredump.cx/</pre><p>Microsoft’s browser permits “;” in the hostname and successfully resolves this label, thanks to the appropriate configuration of the <span class="emphasis"><em>coredump.cx</em></span> domain. Most other browsers will autocorrect the URL to <span class="emphasis"><em>http://example.com/;.coredump.cx</em></span> and take the user to <span class="emphasis"><em>example.com</em></span> instead (except for Safari, where the syntax causes an error). If this looks messy, remember that we are just getting started with how browsers work!</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-1" id="ftn.CHP-2-FN-1">10</a>] </sup>This is possibly out of the concern for FTP, which transmits user credentials without any encoding; in this protocol, a newline transmitted as is would be misinterpreted by the server as the beginning of a new FTP command. Other browsers may transmit FTP credentials in noncompliant percent-encoded form or simply strip any problematic characters later on.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-2" id="ftn.CHP-2-FN-2">11</a>] </sup>Unlike UNIX-derived operating systems, Microsoft Windows uses backslashes instead of slashes to delimit file paths (say, <span class="emphasis"><em>c:\windows\system32\calc.exe</em></span>). Microsoft probably tried to compensate for the possibility that users would be confused by the need to type a different type of a slash on the Web or hoped to resolve other possible inconsistencies with <span class="emphasis"><em>file:</em></span> URLs and similar mechanisms that would be interfacing directly with the local filesystem. Other Windows filesystem specifics (such as case insensitivity) are not replicated, however.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-3" id="ftn.CHP-2-FN-3">12</a>] </sup>This particular @-based trick was quickly embraced to facilitate all sorts of online fraud targeted at casual users. Attempts to mitigate its impact ranged from the heavy-handed and oddly specific (e.g., disabling URL-based authentication in Internet Explorer or crippling it with warnings in Firefox) to the fairly sensible (e.g., hostname highlighting in the address bar of several browsers).</p></div></div></div>
<div class="sect1" title="Reserved Characters and Percent Encoding"><div class="titlepage"><div><div><h1 class="title"><a id="reserved_characters_and_percent_encoding"/>Reserved Characters and Percent Encoding</h1></div></div></div><p>The URL-parsing algorithm outlined in the previous section relies on the assumption that certain reserved, syntax-delimiting characters will not appear literally in the URL in any other capacity (that is, they won’t be a part of the username, request path, and so on). These generic, syntax-disrupting delimiters are:<a class="indexterm" id="IDX-CHP-2-0079"/></p><a id="I_programlisting1_d1e1906"/><pre class="programlisting">: / ? # [ ] @</pre><p>The RFC also names a couple of lower-tier delimiters without giving them any specific purpose, presumably to allow scheme- or application-specific features to be implemented within any of the top-level sections:</p><a id="I_programlisting1_d1e1910"/><pre class="programlisting">! $ &amp; ' ( ) * + , ; =</pre><p>All of the above characters are in principle off-limits, but there are legitimate cases where one would want to include them in the URL (for example, to accommodate arbitrary search terms entered by the user and passed to the server in the query string). Therefore, rather than ban them, the standard provides a method to encode all spurious occurrences of these values. The method, simply called <span class="emphasis"><em>percent encoding</em></span> or <span class="emphasis"><em>URL encoding</em></span>, substitutes characters with a percent sign (<code class="literal">%</code>) followed by two hexadecimal digits representing a matching ASCII value. For example, “<code class="literal">/</code>” will be encoded as <span class="emphasis"><em>%2F</em></span> (uppercase is customary but not enforced). It follows that to avoid ambiguity, the naked percent sign itself must be encoded as <span class="emphasis"><em>%25</em></span>. Any intermediaries that handle existing URLs (browsers and web applications included) are further compelled never to attempt to decode or encode reserved characters in relayed URLs, because the meaning of such a URL may suddenly change.<a class="indexterm" id="IDX-CHP-2-0080"/></p><p>Regrettably, the immutability of reserved characters in existing URLs is at odds with the need to respond to any URLs that are technically illegal because they misuse these characters and that are encountered by the browser in the wild. This topic is not covered by the specifications at all, which forces browser vendors to improvise and causes cross-implementation inconsistencies. For example, should the URL <span class="emphasis"><em>http://a@b@c/</em></span> be translated to <span class="emphasis"><em>http://a@b%40c/</em></span> or perhaps to <span class="emphasis"><em>http://a%40b@c/</em></span>? Internet Explorer and Safari think the former makes more sense; other browsers side with the latter view.</p><p>The remaining characters not in the reserved set are not supposed to have any particular significance within the URL syntax itself. However, some (such as nonprintable ASCII control characters) are clearly incompatible with the idea that URLs should be human readable and transport-safe. Therefore, the RFC outlines a confusingly named subset of <span class="emphasis"><em>unreserved</em></span> characters (consisting of alphanumerics, “<code class="literal">-</code>”, “<code class="literal">.</code>”, “<code class="literal">_</code>”, and “<code class="literal">˜</code>”) and says that only this subset and the reserved characters in their intended capacity are formally allowed to appear in the URL as is.<a class="indexterm" id="IDX-CHP-2-0081"/><a class="indexterm" id="IDX-CHP-2-0082"/><a class="indexterm" id="IDX-CHP-2-0083"/><a class="indexterm" id="IDX-CHP-2-0084"/><a class="indexterm" id="IDX-CHP-2-0085"/><a class="indexterm" id="IDX-CHP-2-0086"/><a class="indexterm" id="IDX-CHP-2-0087"/><a class="indexterm" id="IDX-CHP-2-0088"/><a class="indexterm" id="IDX-CHP-2-0089"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Curiously, these unreserved characters are only <span class="emphasis"><em>allowed</em></span> to appear in an unescaped form; they are not <span class="emphasis"><em>required</em></span> to do so. User agents may encode or decode them at whim, and doing so does not change the meaning of the URL at all. This property brings up yet another way to confuse users: the use of noncanonical representations of unreserved characters. Specifically, all of the following are equivalent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="http://example.com/">http://example.com/</a></p></li><li class="listitem"><p><span class="emphasis"><em>http://%65xample.%63om/</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/</em></span><sup>[<a class="footnote" href="#ftn.CHP-2-FN-4" id="CHP-2-FN-4">13</a>]</sup><a class="indexterm" id="IDX-CHP-2-0090"/><a class="indexterm" id="IDX-CHP-2-0091"/></p></li></ul></div></div><p>A number of otherwise nonreserved, printable characters are excluded from the so-called unreserved set. Because of this, strictly speaking, the RFCs require them to be unconditionally percent encoded. However, since browsers are not explicitly tasked with the enforcement of this rule, it is not taken very seriously. In particular, all browsers allow “<code class="literal">^</code>”, “<code class="literal">{</code>”, “<code class="literal">|</code>”, and “<code class="literal">}</code>” to appear in URLs without escaping and will send these characters to the server as is. Internet Explorer further permits “<code class="literal">&lt;</code>”, “<code class="literal">&gt;</code>”, and “<code class="literal">`</code>” to go through; Internet Explorer, Firefox, and Chrome all accept “<code class="literal">\</code>”; Chrome and Internet Explorer will permit a double quote; and Opera and Internet Explorer both pass the nonprintable character 0x7F (DEL) as is.</p><p>Lastly, contrary to the requirements spelled out in the RFC, most browsers also do not encode fragment identifiers at all. This poses an unexpected challenge to client-side scripts that rely on this string and expect certain potentially unsafe characters never to appear literally. We will revisit this topic in <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>.</p><div class="sect2" title="Handling of Non-US-ASCII Text"><div class="titlepage"><div><div><h2 class="title"><a id="handling_of_non-us-ascii_text"/>Handling of Non-US-ASCII Text</h2></div></div></div><p>Many languages used around the globe rely on characters outside the basic, 7-bit ASCII character set or the default 8-bit code page traditionally used by all PC-compatible systems (CP437). Heck, some languages depend on alphabets that are not based on Latin at all.</p><p>In order to accommodate the needs of an often-ignored but formidable non-English user base, various 8-bit code pages with an alternative set of high-bit characters were devised long before the emergence of the Web: ISO 8859-1, CP850, and Windows 1252 for Western European languages; ISO 8859-2, CP852, and Windows 1250 for Eastern and Central Europe; and KOI8-R and Windows 1251 for Russia. And, because several alphabets could not be accommodated in the 256-character space, we saw the rise of complex variable-width encodings, such as Shift JIS for katakana.<a class="indexterm" id="IDX-CHP-2-0092"/><a class="indexterm" id="IDX-CHP-2-0093"/><a class="indexterm" id="IDX-CHP-2-0094"/></p><p>The incompatibility of these character maps made it difficult to exchange documents between computers configured for different code pages. By the early 1990s, this growing problem led to the creation of <span class="emphasis"><em>Unicode</em></span>—a sort of universal character set, too large to fit within 8 bits but meant to encompass practically all regional scripts and specialty pictographs known to man. Unicode was followed by UTF-8, a relatively simple, variable-width representation of these characters, which was theoretically safe for all applications capable of handling traditional 8-bit formats. Unfortunately, UTF-8 required more bytes to encode high-bit characters than did most of its competitors, and to many users, this seemed wasteful and unnecessary. Because of this criticism, it took well over a decade for UTF-8 to gain traction on the Web, and it only did so long after all the relevant protocols had solidified.<a class="indexterm" id="IDX-CHP-2-0095"/></p><p>This unfortunate delay had some bearing on the handling of URLs that contain user input. Browsers needed to accommodate such use very early on, but when the developers turned to the relevant standards, they found no meaningful advice. Even years later, in 2005, the RFC 3986 had just this to say:<a class="indexterm" id="IDX-CHP-2-0096"/></p><div class="blockquote"><blockquote class="blockquote"><p>In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification.</p><p>Percent-encoded octets . . . may be used within a URI to represent characters outside the range of the US-ASCII coded character set if this representation is allowed by the scheme or by the protocol element in which the URI is referenced. Such a definition should specify the character encoding used to map those characters to octets prior to being percent-encoded for the URI.</p></blockquote></div><p>Alas, despite this wishful thinking, none of the remaining standards addressed this topic. It was always possible to put raw high-bit characters in a URL, but without knowing the code page they should be interpreted in, the server would not be able to tell if that <span class="emphasis"><em>%B1</em></span> was supposed to mean “±”, “ą”, or some other squiggly character specific to the user’s native script.</p><p>Sadly, browser vendors have not taken the initiative and come up with a consistent solution to this problem. Most browsers internally transcode URL path segments to UTF-8 (or ISO 8859-1, if sufficient), but then they generate the query string in the code page of the referring page instead. In certain cases, when URLs are entered manually or passed to certain specialized APIs, high-bit characters may be also downgraded to their 7-bit US-ASCII look-alikes, replaced with question marks, or even completely mangled due to implementation flaws.</p><p>Poorly implemented or not, the ability to pass non-English characters in query strings and paths scratched an evident itch. The traditional percent-encoding approach left just one URL segment completely out in the cold: High-bit input could not be allowed as is when specifying the name of the destination server, because at least in principle, the well-established DNS standard permitted only period-delimited alphanumerics and dashes to appear in domain names—and while nobody adhered to the rules, the set of exceptions varied from one name server to another.<a class="indexterm" id="IDX-CHP-2-0097"/></p><p>An astute reader might wonder why this limitation would matter; that is, why was it important to have localized domain names in non-Latin alphabets, too? That question may be difficult to answer now. Quite simply, several folks thought a lack of these encodings would prevent businesses and individuals around the world from fully embracing and enjoying the Web—and, rightly or not, they were determined to make it happen.</p><p>This pursuit led to the formation of the Internationalized Domain Names in Applications (IDNA). First, RFC 3490,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-9">102</a>]</sup> which outlined a rather contrived scheme to encode arbitrary Unicode strings using alphanumerics and dashes, and then RFC 3492,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-10">103</a>]</sup> which described a way to apply this encoding to DNS labels using a format known as <span class="emphasis"><em>Punycode</em></span>. Punycode looked roughly like this:<a class="indexterm" id="IDX-CHP-2-0098"/><a class="indexterm" id="IDX-CHP-2-0099"/><a class="indexterm" id="IDX-CHP-2-0100"/><a class="indexterm" id="IDX-CHP-2-0101"/></p><a id="I_programlisting1_d1e2144"/><pre class="programlisting">xn--[US-ASCII part]-[encoded Unicode data]</pre><p>A compliant browser presented with a technically illegal URL that contained a literal non-US-ASCII character anywhere in the hostname was supposed to transform the name to Punycode before performing a DNS lookup. Consequently, when presented with Punycode in an existing URL, it should put a decoded, human-readable form of the string in the address bar.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Combining all these incompatible encoding strategies can make for an amusing mix. Consider this example URL of a made-up Polish-language towel shop:</p></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e2152"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages949993.png.jpg"/></div></div><p>Of all the URL-based encoding approaches, IDNA soon proved to be the most problematic. In essence, the domain name in the URL shown in the browser’s address bar is one of the most important security indicators on the Web, as it allows users to quickly differentiate sites they trust and have done business with from the rest of the Internet. When the hostname shown by the browser consists of 38 familiar and distinctive characters, only fairly careless victims will be tricked into thinking that their favorite <span class="emphasis"><em>examp</em></span><span class="bolditalic">l</span><span class="emphasis"><em>e.com</em></span> domain and an impostor <span class="emphasis"><em>examp</em></span><span class="bolditalic">1</span><span class="emphasis"><em>e.com</em></span> site are the same thing. But IDNA casually and indiscriminately extended these 38 characters to some 100,000 glyphs supported by Unicode, many of which look exactly alike and are separated from each other based on functional differences alone.</p><p>How bad is it? Let’s consider Cyrillic, for example. This alphabet has a number of homoglyphs that look practically identical to their Latin counterparts but that have completely different Unicode values and resolve to completely different Punycode DNS names:<a class="indexterm" id="IDX-CHP-2-0102"/><a class="indexterm" id="IDX-CHP-2-0103"/><a class="indexterm" id="IDX-CHP-2-0104"/><a class="indexterm" id="IDX-CHP-2-0105"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td rowspan="2" style="text-align: left" valign="top"><p>Latin</p></td><td style="text-align: left" valign="top"><p>a</p></td><td style="text-align: left" valign="top"><p>c</p></td><td style="text-align: left" valign="top"><p>e</p></td><td style="text-align: left" valign="top"><p>i</p></td><td style="text-align: left" valign="top"><p>j</p></td><td style="text-align: left" valign="top"><p>o</p></td><td style="text-align: left" valign="top"><p>p</p></td><td style="text-align: left" valign="top"><p>s</p></td><td style="text-align: left" valign="top"><p>x</p></td><td style="text-align: left" valign="top"><p>y</p></td></tr><tr><td style="text-align: left" valign="top"><p>U+0061</p></td><td style="text-align: left" valign="top"><p>U+0063</p></td><td style="text-align: left" valign="top"><p>U+0065</p></td><td style="text-align: left" valign="top"><p>U+0069</p></td><td style="text-align: left" valign="top"><p>U+006A</p></td><td style="text-align: left" valign="top"><p>U+006F</p></td><td style="text-align: left" valign="top"><p>U+0070</p></td><td style="text-align: left" valign="top"><p>U+0073</p></td><td style="text-align: left" valign="top"><p>U+0078</p></td><td style="text-align: left" valign="top"><p>U+0079</p></td></tr><tr><td rowspan="2" style="text-align: left" valign="top"><p>Cyrillic</p></td><td style="text-align: left" valign="top"><p>a</p></td><td style="text-align: left" valign="top"><p>c</p></td><td style="text-align: left" valign="top"><p>e</p></td><td style="text-align: left" valign="top"><p>i</p></td><td style="text-align: left" valign="top"><p>j</p></td><td style="text-align: left" valign="top"><p>o</p></td><td style="text-align: left" valign="top"><p>p</p></td><td style="text-align: left" valign="top"><p>s</p></td><td style="text-align: left" valign="top"><p>x</p></td><td style="text-align: left" valign="top"><p>y</p></td></tr><tr><td style="text-align: left" valign="top"><p>U+0430</p></td><td style="text-align: left" valign="top"><p>U+0441</p></td><td style="text-align: left" valign="top"><p>U+0435</p></td><td style="text-align: left" valign="top"><p>U+0456</p></td><td style="text-align: left" valign="top"><p>U+0458</p></td><td style="text-align: left" valign="top"><p>U+043E</p></td><td style="text-align: left" valign="top"><p>U+0440</p></td><td style="text-align: left" valign="top"><p>U+0455</p></td><td style="text-align: left" valign="top"><p>U+0445</p></td><td style="text-align: left" valign="top"><p>U+0443</p></td></tr></tbody></table></div><p>When IDNA was proposed and first implemented in browsers, nobody seriously considered the consequences of this issue. Browser vendors apparently assumed that DNS registrars would prevent people from registering look-alike names, and registrars figured it was the browser vendors’ problem to have unambiguous visuals in the address bar.</p><p>In 2002 the significance of the problem was finally recognized by all parties involved. That year, Evgeniy Gabrilovich and Alex Gontmakher published “The Homograph Attack,”<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-11">104</a>]</sup> a paper exploring the vulnerability in great detail. They noted that any registrar-level work-arounds, even if implemented, would have a fatal flaw. An attacker could always purchase a wholesome top-level domain and then, on his own name server, set up a subdomain record that, with the IDNA transformation applied, would decode to a string visually identical to <span class="emphasis"><em>example.com/</em></span> (the last character being merely a nonfunctional look-alike of the actual ASCII slash). The result would be:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e2342"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages949995.png.jpg"/></div></div><p>There is nothing that a registrar can do to prevent this attack, and the ball is in the browser vendors’ court. But what options do they have, exactly?</p><p>As it turns out, there aren’t many. We now realize that the poorly envisioned IDNA standard cannot be fixed in a simple and painless way. Browser developers have responded to this risk by reverting to incomprehensible Punycode when a user’s locale does not match the script seen in a particular DNS label (which causes problems when browsing foreign sites or when using imported or simply misconfigured computers); permitting IDNA only in certain country-specific, top-level domains (ruling out the use of internationalized domain names in <span class="emphasis"><em>.com</em></span> and other high-profile TLDs); and blacklisting certain “bad” characters that resemble slashes, periods, white spaces, and so forth (a fool’s errand, given the number of typefaces used around the world).</p><p>These measures are drastic enough to severely hinder the adoption of internationalized domain names, probably to a point where the standard’s lingering presence causes more security problems than it brings real usability benefits to non-English users.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-4" id="ftn.CHP-2-FN-4">13</a>] </sup>Similar noncanonical encodings were widely used for various types of social engineering attacks, and consequently, various countermeasures have been deployed through the years. As usual, some of these countermeasures are disruptive (for example, Firefox flat out rejects percent-encoded text in hostnames), and some are fairly good (such as the forced “canonicalization” of the address bar by decoding all the unnecessarily encoded text for display purposes).</p></div></div></div>
<div class="sect1" title="Common URL Schemes and Their Function"><div class="titlepage"><div><div><h1 class="title"><a id="common_url_schemes_and_their_function"/>Common URL Schemes and Their Function</h1></div></div></div><p>Let’s leave the bizarre world of URL parsing behind us and go back to the basics. Earlier in this chapter, we implied that certain schemes may have unexpected security consequences and that because of this, any web application handling user-supplied URLs must be cautious. To explain this point a bit better, it is useful to review all the URL schemes commonly supported in a typical browser environment. These can be combined into four basic groups.<a class="indexterm" id="IDX-CHP-2-0106"/><a class="indexterm" id="IDX-CHP-2-0107"/><a class="indexterm" id="IDX-CHP-2-0108"/><a class="indexterm" id="IDX-CHP-2-0109"/><a class="indexterm" id="IDX-CHP-2-0110"/><a class="indexterm" id="IDX-CHP-2-0111"/><a class="indexterm" id="IDX-CHP-2-0112"/><a class="indexterm" id="IDX-CHP-2-0113"/><a class="indexterm" id="IDX-CHP-2-0114"/><a class="indexterm" id="IDX-CHP-2-0115"/><a class="indexterm" id="IDX-CHP-2-0116"/><a class="indexterm" id="IDX-CHP-2-0117"/><a class="indexterm" id="IDX-CHP-2-0118"/><a class="indexterm" id="IDX-CHP-2-0119"/><a class="indexterm" id="IDX-CHP-2-0120"/><a class="indexterm" id="IDX-CHP-2-0121"/><a class="indexterm" id="IDX-CHP-2-0122"/><a class="indexterm" id="IDX-CHP-2-0123"/><a class="indexterm" id="IDX-CHP-2-0124"/><a class="indexterm" id="IDX-CHP-2-0125"/><a class="indexterm" id="IDX-CHP-2-0126"/><a class="indexterm" id="IDX-CHP-2-0127"/><a class="indexterm" id="IDX-CHP-2-0128"/></p><div class="sect2" title="Browser-Supported, Document-Fetching Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="browser-supported_comma_document-fetchin"/>Browser-Supported, Document-Fetching Protocols</h2></div></div></div><p>These schemes, handled internally by the browser, offer a way to retrieve arbitrary content using a particular transport protocol and then display it using common, browser-level rendering logic. This is the most rudimentary and the most expected function of a URL.</p><p>The list of commonly supported schemes in this category is surprisingly short: <span class="emphasis"><em>http:</em></span> (RFC 2616), the primary transport mode used on the Web and the focus of the next chapter of this book; <span class="emphasis"><em>https:</em></span>, an encrypted version of HTTP (RFC 2818<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-12">105</a>]</sup>); and <span class="emphasis"><em>ftp:</em></span>, an older file transfer protocol (RFC 959<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-13">106</a>]</sup>). All browsers also support <span class="emphasis"><em>file:</em></span> (previously also known as <span class="emphasis"><em>local:</em></span>), a system-specific method for accessing the local filesystem or NFS and SMB shares. (This last scheme is usually not directly accessible through Internet-originating pages, though.)</p><p>Two additional, obscure cases also deserve a brief mention: built-in support for the <span class="emphasis"><em>gopher:</em></span> scheme, one of the failed predecessors of the Web (RFC 1436<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-14">107</a>]</sup>), which is still present in Firefox, and <span class="emphasis"><em>shttp:</em></span>, an alternative, failed take on HTTPS (RFC 2660<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-15">108</a>]</sup>), still recognized in Internet Explorer (but today, simply aliased to HTTP).</p></div><div class="sect2" title="Protocols Claimed by Third-Party Applications and Plug-ins"><div class="titlepage"><div><div><h2 class="title"><a id="protocols_claimed_by_third-party_applica"/>Protocols Claimed by Third-Party Applications and Plug-ins</h2></div></div></div><p>For these schemes, matching URLs are simply dispatched to external, specialized applications that implement functionality such as media playback, document viewing, or IP telephony. At this point, the involvement of the browser (mostly) ends.</p><p>Scores of external protocol handlers exist today, and it would take another thick book to cover them all. Some of the most common examples include the <span class="emphasis"><em>acrobat:</em></span> scheme, predictably routed to Adobe Acrobat Reader; <span class="emphasis"><em>callto:</em></span> and <span class="emphasis"><em>sip:</em></span> schemes claimed by all sorts of instant messengers and telephony software; <span class="emphasis"><em>daap:</em></span>, <span class="emphasis"><em>itpc:</em></span>, and <span class="emphasis"><em>itms:</em></span> schemes used by Apple iTunes; <span class="emphasis"><em>mailto:</em></span>, <span class="emphasis"><em>news:</em></span>, and <span class="emphasis"><em>nntp:</em></span> protocols claimed by mail and Usenet clients; <span class="emphasis"><em>mmst:</em></span>, <span class="emphasis"><em>mmsu:</em></span>, <span class="emphasis"><em>msbd:</em></span>, and <span class="emphasis"><em>rtsp:</em></span> protocols for streaming media players; and so on. Browsers are sometimes also included on the list. The previously mentioned <span class="emphasis"><em>firefoxurl:</em></span> scheme launches Firefox from within another browser, while <span class="emphasis"><em>cf:</em></span> gives access to Chrome from Internet Explorer.<a class="indexterm" id="IDX-CHP-2-0129"/><a class="indexterm" id="IDX-CHP-2-0130"/></p><p>For the most part, when these schemes appear in URLs, they usually have no impact on the security of the web applications that allow them to go through (although this is not guaranteed, especially in the case of plug-in-supported content). It is worth noting that third-party protocol handlers tend to be notoriously buggy and are sometimes abused to compromise the operating system. Therefore, restricting the ability to navigate to mystery protocols is a common courtesy to the user of any reasonably trustworthy website.<a class="indexterm" id="IDX-CHP-2-0131"/><a class="indexterm" id="IDX-CHP-2-0132"/><a class="indexterm" id="IDX-CHP-2-0133"/><a class="indexterm" id="IDX-CHP-2-0134"/><a class="indexterm" id="IDX-CHP-2-0135"/><a class="indexterm" id="IDX-CHP-2-0136"/><a class="indexterm" id="IDX-CHP-2-0137"/><a class="indexterm" id="IDX-CHP-2-0138"/><a class="indexterm" id="IDX-CHP-2-0139"/><a class="indexterm" id="IDX-CHP-2-0140"/><a class="indexterm" id="IDX-CHP-2-0141"/><a class="indexterm" id="IDX-CHP-2-0142"/><a class="indexterm" id="IDX-CHP-2-0143"/><a class="indexterm" id="IDX-CHP-2-0144"/><a class="indexterm" id="IDX-CHP-2-0145"/><a class="indexterm" id="IDX-CHP-2-0146"/></p></div><div class="sect2" title="Nonencapsulating Pseudo-Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="nonencapsulating_pseudo-protocols"/>Nonencapsulating Pseudo-Protocols</h2></div></div></div><p>An array of protocols is reserved to provide convenient access to the browser’s scripting engine and other internal functions, without actually retrieving any remote content and perhaps without establishing an isolated document context to display the result. Many of these pseudo-protocols are highly browser-specific and are either not directly accessible from the Internet or are incapable of doing harm. However, there are several important exceptions to this rule.</p><p>Perhaps the best-known exception is the <span class="emphasis"><em>javascript:</em></span> scheme (in earlier years, also available under aliases such as <span class="emphasis"><em>livescript:</em></span> or <span class="emphasis"><em>mocha:</em></span> in Netscape browsers). This scheme gives access to the JavaScript-programming engine in the context of the currently viewed website. In Internet Explorer, <span class="emphasis"><em>vbscript:</em></span> offers similar capabilities through the proprietary Visual Basic interface.</p><p>Another important case is the <span class="emphasis"><em>data:</em></span> protocol (RFC 2397<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-16">109</a>]</sup>), which permits short, inline documents to be created without any extra network requests and sometimes inherits much of their operating context from the referring page. An example of a <span class="emphasis"><em>data:</em></span> URL is:</p><a id="I_programlisting1_d1e2622"/><pre class="programlisting"><em class="replaceable"><code>data:text/plain,Why,%20hello%20there!</code></em></pre><p>These externally accessible pseudo-URLs are of acute significance to site security. When navigated to, their payload may execute in the context of the originating domain, possibly stealing sensitive data or altering the appearance of the page for the affected user. We’ll discuss the specific capabilities of browser scripting languages in <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>, but as you might expect, they are substantial. (URL context inheritance rules, on the other hand, are the focus of <a class="xref" href="ch10.html" title="Chapter 10. Origin Inheritance">Chapter 10</a>.)</p></div><div class="sect2" title="Encapsulating Pseudo-Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="encapsulating_pseudo-protocols"/>Encapsulating Pseudo-Protocols</h2></div></div></div><p>This special class of pseudo-protocols may be used to prefix any other URL in order to force a special decoding or rendering mode for the retrieved resource. Perhaps the best-known example is the <span class="emphasis"><em>view-source:</em></span> scheme supported by Firefox and Chrome, used to display the pretty-printed source of an HTML page. This scheme is used in the following way:</p><a id="I_programlisting1_d1e2639"/><pre class="programlisting">view-source:http://www.example.com/</pre><p>Other protocols that function similarly include <span class="emphasis"><em>jar:</em></span>, which allows content to be extracted from ZIP files on the fly in Firefox; <span class="emphasis"><em>wyciwyg:</em></span> and <span class="emphasis"><em>view-cache:</em></span>, which give access to cached pages in Firefox and Chrome respectively; an oddball <span class="emphasis"><em>feed:</em></span> scheme, which is meant to access news feeds in Safari;<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-17">110</a>]</sup> and a host of poorly documented protocols associated with the Windows help subsystem and other components of Microsoft Windows (<span class="emphasis"><em>hcp:</em></span>, <span class="emphasis"><em>its:</em></span>, <span class="emphasis"><em>mhtml:</em></span>, <span class="emphasis"><em>mk:</em></span>, <span class="emphasis"><em>ms-help:</em></span>, <span class="emphasis"><em>ms-its:</em></span>, and <span class="emphasis"><em>ms-itss:</em></span>).<a class="indexterm" id="IDX-CHP-2-0147"/><a class="indexterm" id="IDX-CHP-2-0148"/></p><p>The common property of many encapsulating protocols is that they allow the attacker to hide the actual URL that will be ultimately interpreted by the browser from naïve filters: <code class="literal">view-source:javascript:</code> (or even <code class="literal">view-source:view-source:javascript:</code>) followed by malicious code is a simple way to accomplish this. Some security restrictions may be present to limit such trickery, but they should not be relied upon. Another significant problem, recurring especially with Microsoft’s <span class="emphasis"><em>mhtml:</em></span>, is that using the protocol may ignore some of the content directives provided by the server on HTTP level, possibly leading to widespread misery.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-2-FT-18">111</a>]</sup><a class="indexterm" id="IDX-CHP-2-0149"/><a class="indexterm" id="IDX-CHP-2-0150"/><a class="indexterm" id="IDX-CHP-2-0151"/><a class="indexterm" id="IDX-CHP-2-0152"/></p></div><div class="sect2" title="Closing Note on Scheme Detection"><div class="titlepage"><div><div><h2 class="title"><a id="closing_note_on_scheme_detection"/>Closing Note on Scheme Detection</h2></div></div></div><p>The sheer number of pseudo-protocols is the primary reason why web applications need to carefully screen user-supplied URLs. The wonky and browser-specific URL-parsing patterns, coupled with the open-ended nature of the list of supported schemes, means that it is unsafe to simply blacklist known bad schemes; for example, a check for <span class="emphasis"><em>javascript:</em></span> may be circumvented if this keyword is spliced with a tab or a newline, replaced with <span class="emphasis"><em>vbscript:</em></span>, or prefixed with another encapsulating scheme.</p></div></div>
<div class="sect1" title="Resolution of Relative URLs"><div class="titlepage"><div><div><h1 class="title"><a id="resolution_of_relative_urls"/>Resolution of Relative URLs</h1></div></div></div><p>Relative URLs have been mentioned on several occasions earlier in the chapter, and they deserve some additional attention at this point, too. The reason for their existence is that on almost every web page on the Internet, a considerable number of URLs will reference resources hosted on that same server, perhaps in the same directory. It would be inconvenient and wasteful to require a fully qualified URL to appear in the document every time such a reference is needed, so short, relative URLs (such as <span class="emphasis"><em>../other_file.txt</em></span>) are used instead. The missing details are inferred from the URL of the referring document.</p><p>Because relative URLs are allowed to appear in exactly the same scenarios in which any absolute URL may appear, a method to distinguish between the two is necessary within the browser. Web applications also benefit from the ability to make the distinction, because most types of URL filters may want to scrutinize absolute URLs only and allow local references through as is.</p><p>The specification may make this task seem very simple: If the URL string does not begin with a valid scheme name followed by a semicolon and, preferably, a valid “//” sequence, it should be interpreted as a relative reference. And if no context for parsing such a relative URL exists, it should be rejected. Everything else is a safe relative link, right?</p><p>Predictably, it’s not as easy as it seems. First, as outlined in previous sections, the accepted set of characters in a valid scheme name, and the patterns accepted in lieu of “//”, vary from one implementation to another. Perhaps more interestingly, it is a common misconception that relative links can point only to resources on the same server; quite a few other, less-obvious variants of relative URLs exist.</p><p>Let’s have a quick peek at the known classes of relative URLs to better illustrate this possibility.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Scheme, but no authority present</strong></span> (<span class="bolditalic">http:foo.txt</span>)</span></dt><dd><p>This infamous loophole is hinted at in RFC 3986 and attributed to an oversight in one of the earlier specs. While said specs descriptively classified such URLs as (invalid) absolute references, they also provided a promiscuous reference-parsing algorithm keen on interpreting them incorrectly.</p><p>In the latter interpretation, these URLs would set a new protocol and path, query, or fragment ID but have the authority section copied over from the referring location. This syntax is accepted by several browsers, but inconsistently. For example, in some cases, <span class="emphasis"><em>http:foo.txt</em></span> may be treated as a relative reference, while <span class="emphasis"><em>https:example.com</em></span> may be parsed as an absolute one!</p></dd><dt><span class="term"><span class="strong"><strong>No scheme, but authority present</strong></span> (<span class="bolditalic">//example.com</span>)</span></dt><dd><p>This is another notoriously confusing but at least well-documented quirk. While <span class="emphasis"><em>/example.com</em></span> is areference to a local resource on the current server, the standard compels browsers to treat <span class="emphasis"><em>//example.com</em></span> as a very different case: a reference to a different authority over the current protocol. In this scenario, the scheme will be copied over from the referring location, and all other URL details will be derived from the relative URL.</p></dd><dt><span class="term"><span class="strong"><strong>No scheme, no authority, but path present</strong></span> (<span class="bolditalic">../notes.txt</span>)</span></dt><dd><p>This is the most common variant of a relative link. Protocol and authority information is copied over from the referring URL. If the relative URL does not start with a slash, the path will also be copied over up to the rightmost “/”. For example, if the base URL is <a class="ulink" href="http://www.example.com/files/">http://www.example.com/files/</a>, the path is the same, but in <a class="ulink" href="http://www.example.com/files/index.html">http://www.example.com/files/index.html</a>, the filename is truncated. The new path is then appended, and standard path normalization follows on the concatenated value. The query string and fragment ID are derived only from the relative URL.</p></dd><dt><span class="term"><span class="strong"><strong>No scheme, no authority, no path, but query string present</strong></span> (<span class="bolditalic">?search=bunnies</span>)</span></dt><dd><p>In this scenario, protocol, authority, and path information are copied verbatim from the referring URL. The query string and fragment ID are derived from the relative URL.</p></dd><dt><span class="term"><span class="strong"><strong>Only fragment ID present</strong></span> (<span class="bolditalic">#bunnies</span>)</span></dt><dd><p>All information except for the fragment ID is copied verbatim from the referring URL; only the fragment ID is substituted. Following this type of relative URL does not cause the page to be reloaded under normal circumstances, as noted earlier.</p></dd></dl></div><p>Because of the risk of potential misunderstandings between application-level URL filters and the browser when handling these types of relative references, it is a good design practice never to output user-supplied relative URLs verbatim. Where feasible, they should be explicitly rewritten to absolute references, and all security checks should be carried out against the resulting fully qualified address instead.</p><div class="sidebar"><a id="security_engineering_cheat_sheet"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Constructing Brand-New URLs Based on User Input</span><a class="indexterm" id="IDX-CHP-2-0153"/><a class="indexterm" id="IDX-CHP-2-0154"/><a class="indexterm" id="IDX-CHP-2-0155"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>If you allow user-supplied data in path, query, or fragment ID:</strong></span> If one of the section delimiters manages to get through without proper escaping, the URL may have a different effect from what you intended (for example, linking one of the user-visible HTML buttons to the wrong server-side action). It is okay to err on the side of caution: When inserting an attacker-controlled field value, you can simply percent-escape everything but alphanumerics.</p></li><li class="listitem"><p><span class="strong"><strong>If you allow user-supplied scheme name or authority section:</strong></span> This is a major code injection and phishing risk! Apply the relevant input-validation rules outlined below.</p></li></ul></div><p><span class="bolditalic">When Designing URL Input Filters</span><a class="indexterm" id="IDX-CHP-2-0156"/><a class="indexterm" id="IDX-CHP-2-0157"/><a class="indexterm" id="IDX-CHP-2-0158"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Relative URLs:</strong></span> Disallow or explicitly rewrite them to absolute references to avoid trouble. Anything else is very likely unsafe.</p></li><li class="listitem"><p><span class="strong"><strong>Scheme name:</strong></span> Permit only known prefixes, such as <span class="emphasis"><em>http://</em></span>, <span class="emphasis"><em>https://</em></span>, or <span class="emphasis"><em>ftp://</em></span>. Do not use blacklisting instead; it is extremely unsafe.</p></li><li class="listitem"><p><span class="strong"><strong>Authority section:</strong></span> Hostname should contain only alphanumerics, “-”, and “.” and can only be followed by “/”, “?”, “#”, or end-of-string. Allowing anything else will backfire. If you need to examine the hostname, make sure to make a proper right-hand substring match.</p><p>In rare cases, you might need to account for IDNA, IPv6 bracket notation, port numbers, or HTTP credentials in the URL. If so, you must fully parse the URL, validate all sections and reject anomalous values, and reserialize them into a nonambiguous, canonical, well-escaped representation.</p></li></ul></div><p><span class="bolditalic">When Decoding Parameters Received Through URLs</span><a class="indexterm" id="IDX-CHP-2-0159"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Do not assume that any particular character will be escaped just because the standard says so or because your browser does it. Before echoing back any URL-derived values or putting them inside database queries, new URLs, and so on, scrub them carefully for dangerous characters.</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;Hypertext Transfer Protocol"><div class="titlepage"><div><div><h1 class="title"><a id="hypertext_transfer_protocol"/>Chapter 3. Hypertext Transfer Protocol</h1></div></div></div><p>The next essential concept we need to discuss is the Hypertext Transfer Protocol (HTTP): the core transfer mechanism of the Web and the preferred method for exchanging URL-referenced documents between servers and clients. Despite having hypertext in its name, HTTP and the actual hypertext content (the HTML language) often exist independent of each other. That said, they are intertwined in sometimes surprising ways.<a class="indexterm" id="IDX-CHP-3-0001"/><a class="indexterm" id="IDX-CHP-3-0002"/></p><p>The history of HTTP offers interesting insight into its authors’ ambitions and the growing relevance of the Internet. Tim Berners-Lee’s earliest 1991 draft of the protocol (HTTP/0.9<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-1">112</a>]</sup>) was barely one and a half pages long, and it failed to account for even the most intuitive future needs, such as extensibility needed to transmit non-HTML data.<a class="indexterm" id="IDX-CHP-3-0003"/></p><p>Five years and several iterations of the specification later, the first official HTTP/1.0 standard (RFC 1945<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-2">113</a>]</sup>) tried to rectify many of these shortcomings in about 50 densely packed pages of text. Fast-forward to 1999, and in HTTP/1.1 (RFC 2616<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-3">114</a>]</sup>), the seven credited authors attempted to anticipate almost every possible use of the protocol, creating an opus over 150 pages long. That’s not all: As of this writing, the current work on HTTPbis,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-4">115</a>]</sup> essentially a replacement for the HTTP/1.1 specification, comes to 360 pages or so. While much of the gradually accumulated content is irrelevant to the modern Web, this progression makes it clear that the desire to tack on new features far outweighs the desire to prune failed ones.<a class="indexterm" id="IDX-CHP-3-0004"/><a class="indexterm" id="IDX-CHP-3-0005"/><a class="indexterm" id="IDX-CHP-3-0006"/><a class="indexterm" id="IDX-CHP-3-0007"/><a class="indexterm" id="IDX-CHP-3-0008"/><a class="indexterm" id="IDX-CHP-3-0009"/><a class="indexterm" id="IDX-CHP-3-0010"/><a class="indexterm" id="IDX-CHP-3-0011"/><a class="indexterm" id="IDX-CHP-3-0012"/><a class="indexterm" id="IDX-CHP-3-0013"/></p><p>Today, all clients and servers support a not-entirely-accurate superset of HTTP/1.0, and most can speak a reasonably complete dialect of HTTP/1.1, with a couple of extensions bolted on. Despite the fact that there is no practical need to do so, several web servers, and all common browsers, also maintain backward compatibility with HTTP/0.9.</p><div class="sect1" title="Basic Syntax of HTTP Traffic"><div class="titlepage"><div><div><h1 class="title"><a id="basic_syntax_of_http_traffic"/>Basic Syntax of HTTP Traffic</h1></div></div></div><p>At a glance, HTTP is a fairly simple, text-based protocol built on top of TCP/IP.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-1" id="CHP-3-FN-1">14</a>]</sup> Every HTTP session is initiated by establishing a TCP connection to the server, typically to port 80, and then issuing a request that outlines the requested URL. In response, the server returns the requested file and, in the most rudimentary use case, tears down the TCP connection immediately thereafter.</p><p>The original HTTP/0.9 protocol provided no room for any additional metadata to be exchanged between the participating parties. The client request always consisted of a single line, starting with GET, followed by the URL path and query string, and ending with a single CRLF newline (ASCII characters 0x0D 0x0A; servers were also advised to accept a lone LF). A sample HTTP/0.9 request might have looked like this:</p><a id="I_programlisting2_d1e3005"/><pre class="programlisting">GET /fuzzy_bunnies.txt</pre><p>In response to this message, the server would have immediately returned the appropriate HTML payload. (The specification required servers to wrap lines of the returned document at 80 characters, but this advice wasn’t really followed.)</p><p>The HTTP/0.9 approach has a number of substantial deficiencies. For example, it offers no way for browsers to communicate users’ language preferences, supply a list of supported document types, and so on. It also gives servers no way to tell a client that the requested file could not be found, that it has moved to a different location, or that the returned file is not an HTML document to begin with. Finally, the scheme is not kind to server administrators: When the transmitted URL information is limited to only the path and query strings, it is impossible for a server to host multiple websites, distinguished by their hostnames, under one IP address—and unlike DNS records, IP addresses don’t come cheap.<a class="indexterm" id="IDX-CHP-3-0014"/><a class="indexterm" id="IDX-CHP-3-0015"/><a class="indexterm" id="IDX-CHP-3-0016"/><a class="indexterm" id="IDX-CHP-3-0017"/><a class="indexterm" id="IDX-CHP-3-0018"/><a class="indexterm" id="IDX-CHP-3-0019"/><a class="indexterm" id="IDX-CHP-3-0020"/><a class="indexterm" id="IDX-CHP-3-0021"/><a class="indexterm" id="IDX-CHP-3-0022"/><a class="indexterm" id="IDX-CHP-3-0023"/><a class="indexterm" id="IDX-CHP-3-0024"/><a class="indexterm" id="IDX-CHP-3-0025"/></p><p>In order to fix these shortcomings (and to make room for future tweaks), HTTP/1.0 and HTTP/1.1 standards embrace a slightly different conversation format: The first line of a request is modified to include protocol version information, and it is followed by zero or more <span class="emphasis"><em>name: value</em></span> pairs (also known as <span class="emphasis"><em>headers</em></span>), each occupying a separate line. Common request headers included in such requests are <span class="emphasis"><em>User-Agent</em></span> (browser version information), <span class="emphasis"><em>Host</em></span> (URL hostname), <span class="emphasis"><em>Accept</em></span> (supported MIME document types<sup>[<a class="footnote" href="#ftn.CHP-3-FN-2" id="CHP-3-FN-2">15</a>]</sup>), <span class="emphasis"><em>Accept-Language</em></span> (supported language codes), and <span class="emphasis"><em>Referer</em></span> (a misspelled field indicating the originating page for the request, if known).</p><p>These headers are terminated with a single empty line, which may be followed by any payload the client wishes to pass to the server (the length of which must be explicitly specified with an additional <span class="emphasis"><em>Content-Length</em></span> header). The contents of the payload are opaque from the perspective of the protocol itself; in HTML, this location is commonly used for submitting form data in one of several possible formats, though this is in no way a requirement.</p><p>Overall, a simple HTTP/1.1 request may look like this:</p><a id="I_programlisting2_d1e3096"/><pre class="programlisting">POST /fuzzy_bunnies/bunny_dispenser.php HTTP/1.1
Host: www.fuzzybunnies.com
User-Agent: Bunny-Browser/1.7
Content-Type: text/plain
Content-Length: 17
Referer: http://www.fuzzybunnies.com/main.html

I REQUEST A BUNNY</pre><p>The server is expected to respond to this query by opening with a line that specifies the supported protocol version, a numerical status code (used to indicate error conditions and other special circumstances), and an optional, human-readable status message. A set of self-explanatory headers comes next, ending with an empty line. The response continues with the contents of the requested resource:</p><a id="I_programlisting2_d1e3101"/><pre class="programlisting">HTTP/1.1 200 OK
Server: Bunny-Server/0.9.2
Content-Type: text/plain
Connection: close

BUNNY WISH HAS BEEN GRANTED</pre><p>RFC 2616 also permits the response to be compressed in transit using one of three supported methods (<span class="emphasis"><em>gzip</em></span>, <span class="emphasis"><em>compress</em></span>, <span class="emphasis"><em>deflate</em></span>), unless the client explicitly opts out by providing a suitable <span class="emphasis"><em>Accept-Encoding</em></span> header.<a class="indexterm" id="IDX-CHP-3-0026"/><a class="indexterm" id="IDX-CHP-3-0027"/><a class="indexterm" id="IDX-CHP-3-0028"/><a class="indexterm" id="IDX-CHP-3-0029"/><a class="indexterm" id="IDX-CHP-3-0030"/></p><div class="sect2" title="The Consequences of Supporting HTTP/0.9"><div class="titlepage"><div><div><h2 class="title"><a id="the_consequences_of_supporting_http_soli"/>The Consequences of Supporting HTTP/0.9</h2></div></div></div><p>Despite the improvements made in HTTP/1.0 and HTTP/1.1, the unwelcome legacy of the “dumb” HTTP/0.9 protocol lives on, even if it is normally hidden from view. The specification for HTTP/1.0 is partly to blame for this, because it requested that all future HTTP clients and servers support the original, half-baked draft. Specifically, section 3.1 says:</p><div class="blockquote"><blockquote class="blockquote"><p>HTTP/1.0 clients must . . . understand any valid response in the format of HTTP/0.9 or HTTP/1.0.</p></blockquote></div><p>In later years, RFC 2616 attempted to backtrack on this requirement (section 19.6: “It is beyond the scope of a protocol specification to mandate compliance with previous versions.”), but acting on the earlier advice, all modern browsers continue to support the legacy protocol as well.</p><p>To understand why this pattern is dangerous, recall that HTTP/0.9 servers reply with nothing but the requested file. There is no indication that the responding party actually understands HTTP and wishes to serve an HTML document. With this in mind, let’s analyze what happens if the browser sends an HTTP/1.1 request to an unsuspecting SMTP service running on port 25 of <span class="emphasis"><em>example.com</em></span>:</p><a id="I_programlisting2_d1e3154"/><pre class="programlisting">GET /<strong class="userinput"><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi!</code></strong> HTTP/1.1
Host: example.com:25
...</pre><p>Because the SMTP server doesn’t understand what is going on, it’s likely to respond this way:</p><a id="I_programlisting2_d1e3161"/><pre class="programlisting">220 example.com ESMTP
500 5.5.1 Invalid command: "GET /<strong class="userinput"><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi!</code></strong> HTTP/1.1"
500 5.1.1 Invalid command: "Host: example.com:25"
...
421 4.4.1 Timeout</pre><p>All browsers willing to follow the RFC are compelled to accept these messages as the body of a valid HTTP/0.9 response and assume that the returned document is, indeed, HTML. These browsers will interpret the quoted attacker-controlled snippet appearing in one of the error messages as if it comes from the owners of a legitimate website at <span class="emphasis"><em>example.com</em></span>. This profoundly interferes with the browser security model discussed in <a class="xref" href="pt02.html" title="Part II. Browser Security Features">Part II</a> of this book and, therefore, is pretty bad.</p></div><div class="sect2" title="Newline Handling Quirks"><div class="titlepage"><div><div><h2 class="title"><a id="newline_handling_quirks"/>Newline Handling Quirks</h2></div></div></div><p>Setting aside the radical changes between HTTP/0.9 and HTTP/1.0, several other core syntax tweaks were made later in the game. Perhaps most notably, contrary to the letter of earlier iterations, HTTP/1.1 asks clients not only to honor newlines in the CRLF and LF format but also to recognize a lone CR character. Although this recommendation is disregarded by the two most popular web servers (IIS and Apache), it is followed on the client side by all browsers except Firefox.<a class="indexterm" id="IDX-CHP-3-0031"/><a class="indexterm" id="IDX-CHP-3-0032"/><a class="indexterm" id="IDX-CHP-3-0033"/><a class="indexterm" id="IDX-CHP-3-0034"/><a class="indexterm" id="IDX-CHP-3-0035"/><a class="indexterm" id="IDX-CHP-3-0036"/><a class="indexterm" id="IDX-CHP-3-0037"/><a class="indexterm" id="IDX-CHP-3-0038"/><a class="indexterm" id="IDX-CHP-3-0039"/><a class="indexterm" id="IDX-CHP-3-0040"/><a class="indexterm" id="IDX-CHP-3-0041"/></p><p>The resulting inconsistency makes it easier for application developers to forget that not only LF but also CR characters must be stripped from any attacker-controlled values that appear anywhere in HTTP headers. To illustrate the problem, consider the following server response, where a user-supplied and insufficiently sanitized value appears in one of the headers, as highlighted in bold:</p><a id="I_programlisting2_d1e3224"/><pre class="programlisting">HTTP/1.1 200 OK[CR][LF]
Set-Cookie: last_search_term=<strong class="userinput"><code>[CR][CR]&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi!</code></strong>[CR][LF]
[CR][LF]
Action completed.</pre><p>To Internet Explorer, this response may appear as:</p><a id="I_programlisting2_d1e3231"/><pre class="programlisting">HTTP/1.1 200 OK
Set-Cookie: last_search_term=

<strong class="userinput"><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi!</code></strong>

Action completed.</pre><p>In fact, the class of vulnerabilities related to HTTP header newline smuggling—be it due to this inconsistency or just due to a failure to filter any type of a newline—is common enough to have its own name: <span class="emphasis"><em>header injection</em></span> or <span class="emphasis"><em>response splitting</em></span>.<a class="indexterm" id="IDX-CHP-3-0042"/><a class="indexterm" id="IDX-CHP-3-0043"/></p><p>Another little-known and potentially security-relevant tweak is support for multiline headers, a change introduced in HTTP/1.1. According to the standard, any header line that begins with a whitespace is treated as a continuation of the previous one. For example:</p><a id="I_programlisting2_d1e3252"/><pre class="programlisting">X-Random-Comment: This is a very long string,
  so why not wrap it neatly?</pre><p>Multiline headers are recognized in client-issued requests by IIS and Apache, but they are not supported by Internet Explorer, Safari, or Opera. Therefore, any implementation that relies on or simply permits this syntax in any attacker-influenced setting may be in trouble. Thankfully, this is rare.</p></div><div class="sect2" title="Proxy Requests"><div class="titlepage"><div><div><h2 class="title"><a id="proxy_requests"/>Proxy Requests</h2></div></div></div><p>Proxies are used by many organizations and Internet service providers to intercept, inspect, and forward HTTP requests on behalf of their users. This may be done to improve performance (by allowing certain server responses to be cached on a nearby system), to enforce network usage policies (for example, to prevent access to porn), or to offer monitored and authenticated access to otherwise separated network environments.<a class="indexterm" id="IDX-CHP-3-0044"/><a class="indexterm" id="IDX-CHP-3-0045"/><a class="indexterm" id="IDX-CHP-3-0046"/><a class="indexterm" id="IDX-CHP-3-0047"/></p><p>Conventional HTTP proxies depend on explicit browser support: The application needs to be configured to make a modified request to the proxy system, instead of attempting to talk to the intended destination. To request an HTTP resource through such a proxy, the browser will normally send a request like this:</p><a id="I_programlisting2_d1e3279"/><pre class="programlisting">GET http://www.fuzzybunnies.com/ HTTP/1.1
User-Agent: Bunny-Browser/1.7
Host: www.fuzzybunnies.com
...</pre><p>The key difference between the above example and the usual syntax is the presence of a fully qualified URL in the first line of the request (<a class="ulink" href="http://www.fuzzybunnies.com/">http://www.fuzzybunnies.com/</a>), instructing the proxy where to connect to on behalf of the user. This information is somewhat redundant, given that the <span class="emphasis"><em>Host</em></span> header already specifies the hostname; the only reason for this overlap is that the mechanisms evolved independent of each other. To avoid being fooled by co-conspiring clients and servers, proxies should either correct any mismatching <span class="emphasis"><em>Host</em></span> headers to match the request URL or associate cached content with a particular URL-<span class="emphasis"><em>Host</em></span> pair and not just one of these values.</p><p>Many HTTP proxies also allow browsers to request non-HTTP resources, such as FTP files or directories. In these cases, the proxy will wrap the response in HTTP, and perhaps convert it to HTML if appropriate, before returning it to the user.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-3" id="CHP-3-FN-3">16</a>]</sup> That said, if the proxy does not understand the requested protocol, or if it is simply inappropriate for it to peek into the exchanged data (for example, inside encrypted sessions), a different approach must be used. A special type of a request, CONNECT, is reserved for this purpose but is not further explained in the HTTP/1.1 RFC. The relevant request syntax is instead outlined in a separate, draft-only specification from 1998.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-5">116</a>]</sup> It looks like this:</p><a id="I_programlisting2_d1e3302"/><pre class="programlisting">CONNECT www.fuzzybunnies.com:1234 HTTP/1.1
User-Agent: Bunny-Browser/1.7
...</pre><p>If the proxy is willing and able to connect to the requested destination, it acknowledges this request with a specific HTTP response code, and the role of this protocol ends. At that point, the browser will begin sending and receiving raw binary data within the established TCP stream; the proxy, in turn, is expected to forward the traffic between the two endpoints indiscriminately.<a class="indexterm" id="IDX-CHP-3-0048"/><a class="indexterm" id="IDX-CHP-3-0049"/><a class="indexterm" id="IDX-CHP-3-0050"/><a class="indexterm" id="IDX-CHP-3-0051"/><a class="indexterm" id="IDX-CHP-3-0052"/><a class="indexterm" id="IDX-CHP-3-0053"/><a class="indexterm" id="IDX-CHP-3-0054"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Hilariously, due to a subtle omission in the draft spec, many browsers have incorrectly processed the nonencrypted, proxy-originating error responses returned during an attempt to establish an encrypted connection. The affected implementations interpreted such plaintext responses as though they originated from the destination server over a secure channel. This glitch effectively eliminated all assurances associated with the use of encrypted communications on the Web. It took over a decade to spot and correct the flaw.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-6">117</a>]</sup></p></div><p>Several other classes of lower-level proxies do not use HTTP to communicate directly with the browser but nevertheless inspect the exchanged HTTP messages to cache content or enforce certain rules. The canonical example of this is a transparent proxy that silently intercepts traffic at the TCP/IP level. The approach taken by transparent proxies is unusually dangerous: Any such proxy can look at the destination IP and the <span class="emphasis"><em>Host</em></span> header sent in the intercepted connection, but it has no way of immediately telling if that destination IP is genuinely associated with the specified server name. Unless an additional lookup and correlation is performed, co-conspiring clients and servers can have a field day with this behavior. Without these additional checks, the attacker simply needs to connect to his or her home server and send a misleading <span class="emphasis"><em>Host:</em></span> <a class="ulink" href="http://www.google.com">www.google.com</a> header to have the response cached for all other users as though genuinely coming from <a class="ulink" href="http://www.google.com">www.google.com</a>.</p></div><div class="sect2" title="Resolution of Duplicate or Conflicting Headers"><div class="titlepage"><div><div><h2 class="title"><a id="resolution_of_duplicate_or_conflicting_h"/>Resolution of Duplicate or Conflicting Headers</h2></div></div></div><p>Despite being relatively verbose, RFC 2616 does a poor job of explaining how a compliant parser should resolve potential ambiguities and conflicts in the request or response data. Section 19.2 of this RFC (“Tolerant Applications”) recommends relaxed and error-tolerant parsing of certain fields in “unambiguous” cases, but the meaning of the term itself is, shall we say, not particularly unambiguous.</p><p>For example, because of a lack of specification-level advice, roughly half of all browsers will favor the first occurrence of a particular HTTP header, and the rest will favor the last one, ensuring that almost every header injection vulnerability, no matter how constrained, is exploitable for at least some percentage of targeted users. On the server side, the situation is similarly random: Apache will honor the first <span class="emphasis"><em>Host</em></span> header seen, while IIS will completely reject a request with multiple instances of this field.<a class="indexterm" id="IDX-CHP-3-0055"/></p><p>On a related note, the relevant RFCs contain no explicit prohibition on mixing potentially conflicting HTTP/1.0 and HTTP/1.1 headers and no requirement for HTTP/1.0 servers or clients to ignore all HTTP/1.1 syntax. Because of this design, it is difficult to predict the outcome of indirect conflicts between HTTP/1.0 and HTTP/1.1 directives that are responsible for the same thing, such as <span class="emphasis"><em>Expires</em></span> and <span class="emphasis"><em>Cache-Control</em></span>.<a class="indexterm" id="IDX-CHP-3-0056"/><a class="indexterm" id="IDX-CHP-3-0057"/><a class="indexterm" id="IDX-CHP-3-0058"/><a class="indexterm" id="IDX-CHP-3-0059"/><a class="indexterm" id="IDX-CHP-3-0060"/><a class="indexterm" id="IDX-CHP-3-0061"/><a class="indexterm" id="IDX-CHP-3-0062"/><a class="indexterm" id="IDX-CHP-3-0063"/><a class="indexterm" id="IDX-CHP-3-0064"/><a class="indexterm" id="IDX-CHP-3-0065"/><a class="indexterm" id="IDX-CHP-3-0066"/></p><p>Finally, in some rare cases, header conflict resolution is outlined in the spec very clearly, but the purpose of permitting such conflicts to arise in the first place is much harder to understand. For example, HTTP/1.1 clients are required to send the <span class="emphasis"><em>Host</em></span> header on all requests, but servers (not just proxies!) are also required to recognize absolute URLs in the first line of the request, as opposed to the traditional path- and query-only method. This rule permits a curiosity such as this:</p><a id="I_programlisting2_d1e3421"/><pre class="programlisting">GET http://www.fuzzybunnies.com/ HTTP/1.1
Host: www.bunnyoutlet.com</pre><p>In this case, section 5.2 of RFC 2616 instructs clients to disregard the nonfunctional (but still mandatory!) <span class="emphasis"><em>Host</em></span> header, and many implementations follow this advice. The problem is that underlying applications are likely to be unaware of this quirk and may instead make somewhat important decisions based on the inspected header value.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When complaining about the omissions in the HTTP RFCs, it is important to recognize that the alternatives can be just as problematic. In several scenarios outlined in that RFC, the desire to explicitly mandate the handling of certain corner cases led to patently absurd outcomes. One such example is the advice on parsing dates in certain HTTP headers, at the request of section 3.3 in RFC 1945. The resulting implementation (the <span class="emphasis"><em>prtime.c</em></span> file in the Firefox codebase<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-7">118</a>]</sup>) consists of close to 2,000 lines of extremely confusing and unreadable C code just to decipher the specified date, time, and time zone in a sufficiently fault-tolerant way (for uses such as deciding cache content expiration).<a class="indexterm" id="IDX-CHP-3-0067"/><a class="indexterm" id="IDX-CHP-3-0068"/></p></div></div><div class="sect2" title="Semicolon-Delimited Header Values"><div class="titlepage"><div><div><h2 class="title"><a id="semicolon-delimited_header_values"/>Semicolon-Delimited Header Values</h2></div></div></div><p>Several HTTP headers, such as <span class="emphasis"><em>Cache-Control</em></span> or <span class="emphasis"><em>Content-Disposition</em></span>, use a semicolon-delimited syntax to cram several separate <span class="emphasis"><em>name=value</em></span> pairs into a single line. The reason for allowing this nested notation is unclear, but it is probably driven by the belief that it will be a more efficient or a more intuitive approach that using several separate headers that would always have to go hand in hand.</p><p>Some use cases outlined in RFC 2616 permit <span class="emphasis"><em>quoted-string</em></span> as the right-hand parameter in such pairs. <span class="emphasis"><em>Quoted-string</em></span> is a syntax in which a sequence of arbitrary printable characters is surrounded by double quotes, which act as delimiters. Naturally, the quote mark itself cannot appear inside the string, but—importantly—a semicolon or a whitespace may, permitting many otherwise problematic values to be sent as is.</p><p>Unfortunately for developers, Internet Explorer does not cope with the <span class="emphasis"><em>quoted-string</em></span> syntax particularly well, effectively rendering this encoding scheme useless. The browser will parse the following line (which is meant to indicate that the response is a downloadable file rather than an inline document) in an unexpected way:<a class="indexterm" id="IDX-CHP-3-0069"/><a class="indexterm" id="IDX-CHP-3-0070"/><a class="indexterm" id="IDX-CHP-3-0071"/><a class="indexterm" id="IDX-CHP-3-0072"/><a class="indexterm" id="IDX-CHP-3-0073"/><a class="indexterm" id="IDX-CHP-3-0074"/></p><a id="I_programlisting2_d1e3497"/><pre class="programlisting">Content-Disposition: attachment; filename="<strong class="userinput"><code>evil_file.exe;</code></strong>.txt"</pre><p>In Microsoft’s implementation, the filename will be truncated at the semicolon character and will appear to be <span class="emphasis"><em>evil_file.exe</em></span>. This behavior creates a potential hazard to any application that relies on examining or appending a “safe” filename extension to an attacker-controlled filename and otherwise correctly checks for the quote character and newlines in this string.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An additional <span class="emphasis"><em>quoted-pair</em></span> mechanism is provided to allow quotes (and any other characters) to be used safely in the string when prefixed by a backslash. This mechanism appears to be specified incorrectly, however, and not supported by any major browser except for Opera. For <span class="emphasis"><em>quoted-pair</em></span> to work properly, stray “\” characters would need to be banned from the <span class="emphasis"><em>quoted-string</em></span>, which isn’t the case in RFC 2616. <span class="emphasis"><em>Quoted-pair</em></span> also permits any <span class="emphasis"><em>CHAR</em></span>-type token to be quoted, including newlines, which is incompatible with other HTTP-parsing rules.</p></div><p>It is also worth noting that when duplicate semicolon-delimited fields are found in a single HTTP header, their order of precedence is not defined by the RFC. In the case of <span class="emphasis"><em>filename=</em></span> in <span class="emphasis"><em>Content-Disposition</em></span>, all mainstream browsers use the first occurrence. But there is little consistency elsewhere. For example, when extracting the <span class="emphasis"><em>URL=</em></span> value from the <span class="emphasis"><em>Refresh</em></span> header (used to force reloading the page after a specified amount of time), Internet Explorer 6 will fall back to the last instance, yet all other browsers will prefer the first one. And when handling <span class="emphasis"><em>Content-Type</em></span>, Internet Explorer, Safari, and Opera will use the first <span class="emphasis"><em>charset=</em></span> value, while Firefox and Chrome will rely on the last.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Food for thought: A fascinating but largely non-security-related survey of dozens of inconsistencies associated with the handling of just a single HTTP header—<span class="emphasis"><em>Content-Disposition</em></span>—can be found on a page maintained by Julian Reschke: <a class="ulink" href="http://greenbytes.de/tech/tc2231/">http://greenbytes.de/tech/tc2231/</a>.</p></div></div><div class="sect2" title="Header Character Set and Encoding Schemes"><div class="titlepage"><div><div><h2 class="title"><a id="header_character_set_and_encoding_scheme"/>Header Character Set and Encoding Schemes</h2></div></div></div><p>Like the documents that laid the groundwork for URL handling, all subsequent HTTP specs have largely avoided the topic of dealing with non-US-ASCII characters inside header values. There are several plausible scenarios where non-English text may legitimately appear in this context (for example, the filename in <span class="emphasis"><em>Content-Disposition</em></span>), but when it comes to this, the expected browser behavior is essentially undefined.</p><p>Originally, RFC 1945 permitted the TEXT token (a primitive broadly used to define the syntax of other fields) to contain 8-bit characters, providing the following definition:<a class="indexterm" id="IDX-CHP-3-0075"/><a class="indexterm" id="IDX-CHP-3-0076"/><a class="indexterm" id="IDX-CHP-3-0077"/><a class="indexterm" id="IDX-CHP-3-0078"/><a class="indexterm" id="IDX-CHP-3-0079"/><a class="indexterm" id="IDX-CHP-3-0080"/><a class="indexterm" id="IDX-CHP-3-0081"/><a class="indexterm" id="IDX-CHP-3-0082"/><a class="indexterm" id="IDX-CHP-3-0083"/><a class="indexterm" id="IDX-CHP-3-0084"/><a class="indexterm" id="IDX-CHP-3-0085"/><a class="indexterm" id="IDX-CHP-3-0086"/><a class="indexterm" id="IDX-CHP-3-0087"/></p><a id="I_programlisting2_d1e3622"/><pre class="programlisting">OCTET          = &lt;any 8-bit sequence of data&gt;
 CTL           = &lt;any US-ASCII control character
                  (octets 0 - 31) and DEL (127)&gt;
 TEXT          = &lt;any OCTET except CTLs,
                  but including LWS&gt;</pre><p>The RFC followed up with cryptic advice: When non-US-ASCII characters are encountered in a TEXT field, clients and servers <span class="emphasis"><em>may</em></span> interpret them as ISO-8859-1, the standard Western European code page, but they don’t have to. Later, RFC 2616 copied and pasted the same specification of TEXT tokens but added a note that non-ISO-8859-1 strings must be encoded using a format outlined in RFC 2047,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-8">119</a>]</sup> originally created for email communications. Fair enough; in this simple scheme, the encoded string opens with a “=?” prefix, followed by a character-set name, a “?q?” or “?b?” encoding-type indicator (<span class="emphasis"><em>quoted-printable</em></span><sup>[<a class="footnote" href="#ftn.CHP-3-FN-4" id="CHP-3-FN-4">17</a>]</sup> or <span class="emphasis"><em>base64</em></span>,<sup>[<a class="footnote" href="#ftn.CHP-3-FN-5" id="CHP-3-FN-5">18</a>]</sup> respectively), and lastly the encoded string itself. The sequence ends with a “?=” terminator. An example of this may be:</p><a id="I_programlisting2_d1e3648"/><pre class="programlisting">Content-Disposition: attachment; filename="=<strong class="userinput"><code>?utf-8?q?Hi=21.txt?=</code></strong>"</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The RFC should also have stated that any spurious “=?...?=” patterns must never be allowed as is in the relevant headers, in order to avoid unintended decoding of values that were not really encoded to begin with.</p></div><p>Sadly, the support for this RFC 2047 encoding is spotty. It is recognized in some headers by Firefox and Chrome, but other browsers are less cooperative. Internet Explorer chooses to recognize URL-style percent encoding in the <span class="emphasis"><em>Content-Disposition</em></span> field instead (a habit also picked up by Chrome) and defaults to UTF-8 in this case. Firefox and Opera, on the other hand, prefer supporting a peculiar percent-encoded syntax proposed in RFC 2231,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-9">120</a>]</sup> a striking deviation from how HTTP syntax is supposed to look:</p><a id="I_programlisting2_d1e3663"/><pre class="programlisting">Content-Disposition: attachment; filename*=<strong class="userinput"><code>utf-8'en-us'Hi%21.txt</code></strong></pre><p>Astute readers may notice that there is no single encoding scheme supported by all browsers at once. This situation prompts some web application developers to resort to using raw high-bit values in the HTTP headers, typically interpreted as UTF-8, but doing so is somewhat unsafe. In Firefox, for example, a long-standing glitch causes UTF-8 text to be mangled when put in the <span class="emphasis"><em>Cookie</em></span> header, permitting attacker-injected cookie delimiters to materialize in unexpected places.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-10">121</a>]</sup> In other words, there are no easy and robust solutions to this mess.<a class="indexterm" id="IDX-CHP-3-0088"/><a class="indexterm" id="IDX-CHP-3-0089"/><a class="indexterm" id="IDX-CHP-3-0090"/><a class="indexterm" id="IDX-CHP-3-0091"/></p><p>When discussing character encodings, the problem of handling of the NUL character (0x00) probably deserves a mention. This character, used as a string terminator in many programming languages, is technically prohibited from appearing in HTTP headers (except for the aforementioned, dysfunctional <span class="emphasis"><em>quoted-pair</em></span> syntax), but as you may recall, parsers are encouraged to be tolerant. When this character is allowed to go through, it is likely to have unexpected side effects. For example, <span class="emphasis"><em>Content-Disposition</em></span> headers are truncated at NUL by Internet Explorer, Firefox, and Chrome but not by Opera or Safari.</p></div><div class="sect2" title="Referer Header Behavior"><div class="titlepage"><div><div><h2 class="title"><a id="referer_header_behavior"/>Referer Header Behavior</h2></div></div></div><p>As mentioned earlier in this chapter, HTTP requests may include a <span class="emphasis"><em>Referer</em></span> header. This header contains the URL of a document that triggered the current navigation in some way. It is meant to help with certain troubleshooting tasks and to promote the growth of the Web by emphasizing cross-references between related web pages.</p><p>Unfortunately, the header may also reveal some information about user browsing habits to certain unfriendly parties, and it may leak sensitive information that is encoded in the URL query parameters on the referring page. Due to these concerns, and the subsequent poor advice on how to mitigate them, the header is often misused for security or policy enforcement purposes, but it is not up to the task. The main problem is that there is no way to differentiate between a client that is not providing the header because of user privacy preferences, one that is not providing it because of the type of navigation taking place, and one that is deliberately tricked into hiding this information by a malicious referring site.<a class="indexterm" id="IDX-CHP-3-0092"/></p><p>Normally, this header is included in most HTTP requests (and preserved across HTTP-level redirects), except in the following scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>After organically entering a new URL into the address bar or opening a bookmarked page.</p></li><li class="listitem"><p>When the navigation originates from a pseudo-URL document, such as <span class="emphasis"><em>data:</em></span> or <span class="emphasis"><em>javascript:</em></span>.</p></li><li class="listitem"><p>When the request is a result of redirection controlled by the <span class="emphasis"><em>Refresh</em></span> header (but not a <span class="emphasis"><em>Location</em></span>-based one).</p></li><li class="listitem"><p>Whenever the referring site is encrypted but the requested page isn’t. According to RFC 2616 section 15.1.2, this is done for privacy reasons, but it does not make a lot of sense. The <span class="emphasis"><em>Referer</em></span> string is still disclosed to third parties when one navigates from one encrypted domain to an unrelated encrypted one, and rest assured, the use of encryption is not synonymous with trustworthiness.</p></li><li class="listitem"><p>If the user decides to block or spoof the header by tweaking browser settings or installing a privacy-oriented plug-in.</p></li></ul></div><p>As should be apparent, four out of five of these conditions can be purposefully induced by any rogue site.<a class="indexterm" id="IDX-CHP-3-0093"/><a class="indexterm" id="IDX-CHP-3-0094"/><a class="indexterm" id="IDX-CHP-3-0095"/><a class="indexterm" id="IDX-CHP-3-0096"/><a class="indexterm" id="IDX-CHP-3-0097"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-1" id="ftn.CHP-3-FN-1">14</a>] </sup><span class="emphasis"><em>Transmission Control Protocol (TCP)</em></span> is one of the core communications protocols of the Internet, providing the transport layer to any application protocols built on top of it. TCP offers reasonably reliable, peer-acknowledged, ordered, session-based connectivity between networked hosts. In most cases, the protocol is also fairly resilient against blind packet spoofing attacks attempted by other, nonlocal hosts on the Internet.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-2" id="ftn.CHP-3-FN-2">15</a>] </sup>MIME type (aka <span class="emphasis"><em>Internet media type</em></span>) is a simple, two-component value identifying the class and format of any given computer file. The concept originated in RFC 2045 and RFC 2046, where it served as a way to describe email attachments. The registry of official values (such as <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>audio/mpeg</em></span>) is currently maintained by IANA, but ad hoc types are fairly common.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-3" id="ftn.CHP-3-FN-3">16</a>] </sup>In this case, some HTTP headers supplied by the client may be used internally by the proxy, but they will not be transmitted to the non-HTTP endpoint, which creates some interesting, if non-security-relevant, protocol ambiguities.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-4" id="ftn.CHP-3-FN-4">17</a>] </sup><span class="emphasis"><em>Quoted-printable</em></span> is a simple encoding scheme that replaces any nonprintable or otherwise illegal characters with the equal sign (=) followed by a 2-digit hexadecimal representation of the 8-bit character value to be encoded. Any stray equal signs in the input text must be replaced with “=3D” as well.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-5" id="ftn.CHP-3-FN-5">18</a>] </sup><span class="emphasis"><em>Base64</em></span> is a non-human-readable encoding that encodes arbitrary 8-bit input using a 6-bit alphabet of case-sensitive alphanumerics, “+”, and “/”. Every 3 bytes of input map to 4 bytes of output. If the input does not end at a 3-byte boundary, this is indicated by appending one or two equal signs at the end of the output string.</p></div></div></div>
<div class="sect1" title="HTTP Request Types"><div class="titlepage"><div><div><h1 class="title"><a id="http_request_types"/>HTTP Request Types</h1></div></div></div><p>The original HTTP/0.9 draft provided a single method (or “verb”) for requesting a document: GET. The subsequent proposals experimented with an increasingly bizarre set of methods to permit interactions other than retrieving a document or running a script, including such curiosities as SHOWMETHOD, CHECKOUT, or—why not—SPACEJUMP.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-11">122</a>]</sup></p><p>Most of these thought experiments have been abandoned in HTTP/1.1, which settles on a more manageable set of eight methods. Only the first two request types—GET and POST—are of any significance to most of the modern Web.<a class="indexterm" id="IDX-CHP-3-0098"/></p><div class="sect2" title="GET"><div class="titlepage"><div><div><h2 class="title"><a id="get"/>GET</h2></div></div></div><p>The GET method is meant to signify information retrieval. In practice, it is used for almost all client-server interactions in the course of a normal browsing session. Regular GET requests carry no browser-supplied payloads, although they are not strictly prohibited from doing so.</p><p>The expectation is that GET requests should not have, to quote the RFC, “significance of taking an action other than retrieval” (that is, they should make no persistent changes to the state of the application). This requirement is increasingly meaningless in modern web applications, where the application state is often not even managed entirely on the server side; consequently, the advice is widely ignored by application developers.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-6" id="CHP-3-FN-6">19</a>]</sup></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In HTTP/1.1, clients may ask the server for any set of possibly noncontiguous or overlapping fragments of the target document by specifying the <span class="emphasis"><em>Range</em></span> header on GET (and, less commonly, on some other types of requests). The server is not obliged to comply, but where the mechanism is available, browsers may use it to resume aborted downloads.</p></div></div><div class="sect2" title="POST"><div class="titlepage"><div><div><h2 class="title"><a id="post"/>POST</h2></div></div></div><p>The POST method is meant for submitting information (chiefly HTML forms) to the server for processing. Because POST actions may have persistent side effects, many browsers ask the user to confirm before reloading any content retrieved with POST, but for the most part, GET and POST are used in a quasi-interchangeable manner.</p><p>POST requests are commonly accompanied by a payload, the length of which is indicated by the <span class="emphasis"><em>Content-Length</em></span> header. In the case of plain HTML, the payload may consist of URL-encoded or MIME-encoded form data (a format detailed in <a class="xref" href="ch04.html" title="Chapter 4. Hypertext Markup Language">Chapter 4</a>), although again, the syntax is not constrained at the HTTP level in any special way.</p></div><div class="sect2" title="HEAD"><div class="titlepage"><div><div><h2 class="title"><a id="head"/>HEAD</h2></div></div></div><p>HEAD is a rarely used request type that is essentially identical to GET but that returns only the HTTP headers, and not the actual payload, for the requested content. Browsers generally do not issue HEAD requests on their own, but the method is sometimes employed by search engine bots and other automated tools, for example, to probe for the existence of a file or to check its modification time.<a class="indexterm" id="IDX-CHP-3-0099"/><a class="indexterm" id="IDX-CHP-3-0100"/><a class="indexterm" id="IDX-CHP-3-0101"/><a class="indexterm" id="IDX-CHP-3-0102"/><a class="indexterm" id="IDX-CHP-3-0103"/></p></div><div class="sect2" title="OPTIONS"><div class="titlepage"><div><div><h2 class="title"><a id="options"/>OPTIONS</h2></div></div></div><p>OPTIONS is a metarequest that returns the set of supported methods for a particular URL (or “*”, meaning the server in general) in a response header. The OPTIONS method is almost never used in practice, except for server fingerprinting; because of its limited value, the returned information may not be very accurate.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>For the sake of completeness, we need to note that OPTIONS requests are also a cornerstone of a proposed cross-domain request authorization scheme, and as such, they may gain some prominence soon. We will revisit this scheme, and explore many other upcoming browser security features, in <a class="xref" href="ch16.html" title="Chapter 16. New and Upcoming Security Features">Chapter 16</a>.</p></div></div><div class="sect2" title="PUT"><div class="titlepage"><div><div><h2 class="title"><a id="put"/>PUT</h2></div></div></div><p>A PUT request is meant to allow files to be uploaded to the server at the specified target URL. Because browsers do not support PUT, intentional file-upload capabilities are almost always implemented through POST to a server-side script, rather than with this theoretically more elegant approach.</p><p>That said, some nonweb HTTP clients and servers may use PUT for their own purposes. Just as interestingly, some web servers may be misconfigured to process PUT requests indiscriminately, creating an obvious security risk.</p></div><div class="sect2" title="DELETE"><div class="titlepage"><div><div><h2 class="title"><a id="delete"/>DELETE</h2></div></div></div><p>DELETE is a self-explanatory method that complements PUT (and that is equally uncommon in practice).</p></div><div class="sect2" title="TRACE"><div class="titlepage"><div><div><h2 class="title"><a id="trace"/>TRACE</h2></div></div></div><p>TRACE is a form of “ping” request that returns information about all the proxy hops involved in processing a request and echoes the original request as well. TRACE requests are not issued by web browsers and are seldom used for legitimate purposes. TRACE’s primary use is for security testing, where it may reveal interesting details about the internal architecture of HTTP servers in a remote network. Precisely for this reason, the method is often disabled by server administrators.</p></div><div class="sect2" title="CONNECT"><div class="titlepage"><div><div><h2 class="title"><a id="connect"/>CONNECT</h2></div></div></div><p>The CONNECT method is reserved for establishing non-HTTP connections through HTTP proxies. It is not meant to be issued directly to servers. If the support for CONNECT request is enabled accidentally on a particular server, it may pose a security risk by offering an attacker a way to tunnel TCP traffic into an otherwise protected network.<a class="indexterm" id="IDX-CHP-3-0104"/><a class="indexterm" id="IDX-CHP-3-0105"/><a class="indexterm" id="IDX-CHP-3-0106"/><a class="indexterm" id="IDX-CHP-3-0107"/><a class="indexterm" id="IDX-CHP-3-0108"/><a class="indexterm" id="IDX-CHP-3-0109"/><a class="indexterm" id="IDX-CHP-3-0110"/><a class="indexterm" id="IDX-CHP-3-0111"/><a class="indexterm" id="IDX-CHP-3-0112"/><a class="indexterm" id="IDX-CHP-3-0113"/><a class="indexterm" id="IDX-CHP-3-0114"/></p></div><div class="sect2" title="Other HTTP Methods"><div class="titlepage"><div><div><h2 class="title"><a id="other_http_methods"/>Other HTTP Methods</h2></div></div></div><p>A number of other request methods may be employed by other nonbrowser applications or browser extensions; the most popular set of HTTP extensions may be WebDAV, an authoring and version-control protocol described in RFC 4918.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-12">123</a>]</sup></p><p>Further, the <span class="emphasis"><em>XMLHttpRequest</em></span> API nominally allows client-side JavaScript to make requests with almost arbitrary methods to the originating server—although this last functionality is heavily restricted in certain browsers (we will look into this in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>).</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-6" id="ftn.CHP-3-FN-6">19</a>] </sup>There is an anecdotal (and perhaps even true) tale of an unfortunate webmaster by the name of John Breckman. According to the story, John’s website has been accidentally deleted by a search engine-indexing robot. The robot simply unwittingly discovered an unauthenticated, GET-based administrative interface that John had built for his site . . . and happily followed every “delete” link it could find.</p></div></div></div>
<div class="sect1" title="Server Response Codes"><div class="titlepage"><div><div><h1 class="title"><a id="server_response_codes"/>Server Response Codes</h1></div></div></div><p>Section 10 of RFC 2616 lists nearly 50 status codes that a server may choose from when constructing a response. About 15 of these are used in real life, and the rest are used to indicate increasingly bizarre or unlikely states, such as “402 Payment Required” or “415 Unsupported Media Type.” Most of the RFC-listed states do not map cleanly to the behavior of modern web applications; the only reason for their existence is that somebody hoped they eventually would.</p><p>A few codes are worth memorizing because they are common or carry special meaning, as discussed below.</p><div class="sect2" title="200-299: Success"><div class="titlepage"><div><div><h2 class="title"><a id="colon_success"/>200-299: Success</h2></div></div></div><p>This range of status codes is used to indicate a successful completion of a request:</p><div class="variablelist"><p class="title"/><dl><dt><span class="term"><span class="strong"><strong>200 OK</strong></span></span></dt><dd><p>This is a normal response to a successful GET or POST. The browser will display the subsequently returned payload to the user or will process it in some other context-specific way.</p></dd><dt><span class="term"><span class="strong"><strong>204 No Content</strong></span></span></dt><dd><p>This code is sometimes used to indicate a successful request to which no verbose response is expected. A 204 response aborts navigation to the URL that triggered it and keeps the user on the originating page.</p></dd><dt><span class="term"><span class="strong"><strong>206 Partial Content</strong></span></span></dt><dd><p>This code is like 200, except that it is returned by servers in response to range requests. The browser must already have a portion of the document (or it would not have issued a range request) and will normally inspect the <span class="emphasis"><em>Content-Range</em></span> response header to reassemble the document before further processing it.</p></dd></dl></div></div><div class="sect2" title="300-399: Redirection and Other Status Messages"><div class="titlepage"><div><div><h2 class="title"><a id="colon_redirection_and_other_status"/>300-399: Redirection and Other Status Messages</h2></div></div></div><p>These codes are used to communicate a variety of states that do not indicate an error but that require special handling on the browser end:<a class="indexterm" id="IDX-CHP-3-0115"/><a class="indexterm" id="IDX-CHP-3-0116"/><a class="indexterm" id="IDX-CHP-3-0117"/><a class="indexterm" id="IDX-CHP-3-0118"/><a class="indexterm" id="IDX-CHP-3-0119"/><a class="indexterm" id="IDX-CHP-3-0120"/><a class="indexterm" id="IDX-CHP-3-0121"/><a class="indexterm" id="IDX-CHP-3-0122"/><a class="indexterm" id="IDX-CHP-3-0123"/><a class="indexterm" id="IDX-CHP-3-0124"/><a class="indexterm" id="IDX-CHP-3-0125"/></p><div class="variablelist"><p class="title"/><dl><dt><span class="term"><span class="strong"><strong>301 Moved Permanently, 302 Found, 303 See Other</strong></span></span></dt><dd><p>This response instructs the browser to retry the request at a new location, specified in the <span class="emphasis"><em>Location</em></span> response header. Despite the distinctions made in the RFC, when encountering any of these response codes, all modern browsers replace POST with GET, remove the payload, and then resubmit the request automatically.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Redirect messages may contain a payload, but if they do, this message will not be shown to the user unless the redirection is not possible (for example, because of a missing or unsupported <span class="emphasis"><em>Location</em></span> value). In fact, in some browsers, display of the message may be suppressed even in that scenario.</p></div></dd><dt><span class="term"><span class="strong"><strong>304 Not Modified</strong></span></span></dt><dd><p>This nonredirect response instructs the client that the requested document hasn’t been modified in relation to the copy the client already has. This response is seen after conditional requests with headers such as <span class="emphasis"><em>If-Modified-Since</em></span>, which are issued to revalidate the browser document cache. The response body is not shown to the user. (If the server responds this way to an unconditional request, the result will be browser-specific and may be hilarious; for example, Opera will pop up a nonfunctional download prompt.)</p></dd><dt><span class="term"><span class="strong"><strong>307 Temporary Redirect</strong></span></span></dt><dd><p>Similar to 302, but unlike with other modes of redirection, browsers will not downgrade POST to GET when following a 307 redirect. This code is not commonly used in web applications, and some browsers do not behave very consistently when handling it.</p></dd></dl></div></div><div class="sect2" title="400-499: Client-Side Error"><div class="titlepage"><div><div><h2 class="title"><a id="colon_client-side_error"/>400-499: Client-Side Error</h2></div></div></div><p>This range of codes is used to indicate error conditions caused by the behavior of the client:</p><div class="variablelist"><p class="title"/><dl><dt><span class="term"><span class="strong"><strong>400 Bad Request (and related messages)</strong></span></span></dt><dd><p>The server is unable or unwilling to process the request for some unspecified reason. The response payload will usually explain the problem to some extent and will be typically handled by the browser just like a 200 response.</p><p>More specific variants, such as “411 Length Required,” “405 Method Not Allowed,” or “414 Request-URI Too Long,” also exist. It’s anyone’s guess as to why not specifying <span class="emphasis"><em>Content-Length</em></span> when required has a dedicated 411 response code but not specifying <span class="emphasis"><em>Host</em></span> deserves only a generic 400 one.</p></dd><dt><span class="term"><span class="strong"><strong>401 Unauthorized</strong></span></span></dt><dd><p>This code means that the user needs to provide protocol-level HTTP authentication credentials in order to access the resource. The browser will usually prompt the user for login information next, and it will present a response body only if the authentication process is unsuccessful. This mechanism will be explained in more detail shortly, in <a class="xref" href="ch03s08.html" title="HTTP Authentication">HTTP Authentication</a> in <a class="xref" href="ch03s08.html" title="HTTP Authentication">HTTP Authentication</a>.</p></dd><dt><span class="term"><span class="strong"><strong>403 Forbidden</strong></span></span></dt><dd><p>The requested URL exists but can’t be accessed for reasons other than incorrect HTTP authentication. Reasons may involve insufficient filesystem permissions, a configuration rule that prevents this request from being processed, or insufficient credentials of some sort (e.g., invalid cookies or an unrecognized source IP address). The response will usually be shown to the user.<a class="indexterm" id="IDX-CHP-3-0126"/><a class="indexterm" id="IDX-CHP-3-0127"/><a class="indexterm" id="IDX-CHP-3-0128"/><a class="indexterm" id="IDX-CHP-3-0129"/><a class="indexterm" id="IDX-CHP-3-0130"/><a class="indexterm" id="IDX-CHP-3-0131"/><a class="indexterm" id="IDX-CHP-3-0132"/><a class="indexterm" id="IDX-CHP-3-0133"/></p></dd><dt><span class="term"><span class="strong"><strong>404 Not Found</strong></span></span></dt><dd><p>The requested URL does not exist. The response body is typically shown to the user.</p></dd></dl></div></div><div class="sect2" title="500-599: Server-Side Error"><div class="titlepage"><div><div><h2 class="title"><a id="colon_server-side_error"/>500-599: Server-Side Error</h2></div></div></div><p>This is a class of error messages returned in response to server-side problems:</p><div class="variablelist"><p class="title"/><dl><dt><span class="term"><span class="strong"><strong>500 Internal Server Error, 503 Service Unavailable, and so on</strong></span></span></dt><dd><p>The server is experiencing a problem that prevents it from fulfilling the request. This may be a transient condition, a result of misconfiguration, or simply the effect of requesting an unexpected location. The response is normally shown to the user.</p></dd></dl></div></div><div class="sect2" title="Consistency of HTTP Code Signaling"><div class="titlepage"><div><div><h2 class="title"><a id="consistency_of_http_code_signaling"/>Consistency of HTTP Code Signaling</h2></div></div></div><p>Because there is no immediately observable difference between returning most 2xx, 4xx, and 5xx codes, these values are not selected with any special zeal. In particular, web applications are notorious for returning “200 OK” even when an application error has occurred and is communicated on the resulting page. (This is one of the many factors that make automated testing of web applications much harder than it needs to be.)</p><p>On rare occasions, new and not necessarily appropriate HTTP codes are invented for specific uses. Some of these are standardized, such as a couple of messages introduced in the WebDAV RFC.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-13">124</a>]</sup> Others, such as Microsoft’s Microsoft Exchange “449 Retry With” status, are not.</p></div></div>
<div class="sect1" title="Keepalive Sessions"><div class="titlepage"><div><div><h1 class="title"><a id="keepalive_sessions"/>Keepalive Sessions</h1></div></div></div><p>Originally, HTTP sessions were meant to happen in one shot: Make one request for each TCP connection, rinse, and repeat. The overhead of repeatedly completing a three-step TCP handshake (and forking off a new process in the traditional Unix server design model) soon proved to be a bottleneck, so HTTP/1.1 standardized the idea of keepalive sessions instead.<a class="indexterm" id="IDX-CHP-3-0134"/></p><p>The existing protocol already gave the server an understanding of where the client request ended (an empty line, optionally followed by <span class="emphasis"><em>Content-Length</em></span> bytes of data), but to continue using the existing connection, the client also needed to know the same about the returned document; the termination of a connection could no longer serve as an indicator. Therefore, keepalive sessions require the response to include a <span class="emphasis"><em>Content-Length</em></span> header too, always specifying the amount of data to follow. Once this many payload bytes are received, the client knows it is okay to send a second request and begin waiting for another response.</p><p>Although very beneficial from a performance standpoint, the way this mechanism is designed exacerbates the impact of HTTP request and response-splitting bugs. It is deceptively easy for the client and the server to get out of sync on which response belongs to which request. To illustrate, let’s consider a server that thinks it is sending a single HTTP response, structured as follows:<a class="indexterm" id="IDX-CHP-3-0135"/><a class="indexterm" id="IDX-CHP-3-0136"/><a class="indexterm" id="IDX-CHP-3-0137"/><a class="indexterm" id="IDX-CHP-3-0138"/></p><a id="I_programlisting2_d1e4150"/><pre class="programlisting">HTTP/1.1 200 OK[CR][LF]
Set-Cookie: term=<strong class="userinput"><code>[CR]Content-Length: 0[CR][CR]HTTP/1.1 200 OK[CR]Gotcha: Yup</code></strong>[CR][LF]
Content-Length: 17[CR][LF]
[CR][LF]
Action completed.</pre><p>The client, on the other hand, may see two responses and associate the first one with its most current request and the second one with the yet-to-be-issued query<sup>[<a class="footnote" href="#ftn.CHP-3-FN-7" id="CHP-3-FN-7">20</a>]</sup> (which may even be addressed to a different hostname on the same IP):</p><a id="I_programlisting2_d1e4161"/><pre class="programlisting">HTTP/1.1 200 OK
Set-Cookie: term=
Content-Length: 0

<strong class="userinput"><code>HTTP/1.1 200 OK</code></strong>
<strong class="userinput"><code>Gotcha: Yup</code></strong>
<strong class="userinput"><code>Content-Length: 17</code></strong>

Action completed.</pre><p>If this response is seen by a caching HTTP proxy, the incorrect result may also be cached globally and returned to other users, which is really bad news. A much safer design for keepalive sessions would involve specifying the length of both the headers and the payload up front or using a randomly generated and unpredictable boundary to delimit every response. Regrettably, the design does neither.</p><p>Keepalive connections are the default in HTTP/1.1 unless they are explicitly turned off (<span class="emphasis"><em>Connection: close</em></span>) and are supported by many HTTP/1.0 servers when enabled with a <span class="emphasis"><em>Connection: keep-alive</em></span> header. Both servers and browsers can limit the number of concurrent requests serviced per connection and can specify the maximum amount of time an idle connection is kept around.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-7" id="ftn.CHP-3-FN-7">20</a>] </sup>In principle, clients could be designed to sink any unsolicited server response data before issuing any subsequent requests in a keepalive session, limiting the impact of the attack. This proposal is undermined by the practice of HTTP pipelining, however; for performance reasons, some clients are designed to dump multiple requests at once, without waiting for a complete response in between.</p></div></div></div>
<div class="sect1" title="Chunked Data Transfers"><div class="titlepage"><div><div><h1 class="title"><a id="chunked_data_transfers"/>Chunked Data Transfers</h1></div></div></div><p>The significant limitation of <span class="emphasis"><em>Content-Length</em></span>-based keepalive sessions is the need for the server to know in advance the exact size of the returned response. This is a pretty simple task when dealing with static files, as the information is already available in the filesystem. When serving dynamically generated data, the problem is more complicated, as the output must be cached in its entirety before it is sent to the client. The challenge becomes insurmountable if the payload is very large or is produced gradually (think live video streaming). In these cases, precaching to compute payload size is simply out of the question.<a class="indexterm" id="IDX-CHP-3-0139"/><a class="indexterm" id="IDX-CHP-3-0140"/><a class="indexterm" id="IDX-CHP-3-0141"/><a class="indexterm" id="IDX-CHP-3-0142"/><a class="indexterm" id="IDX-CHP-3-0143"/></p><p>In response to this challenge, RFC 2616 section 3.6.1 gives servers the ability to use <span class="emphasis"><em>Transfer-Encoding: chunked</em></span>, a scheme in which the payload is sent in portions as it becomes available. The length of every portion of the document is declared up front using a hexadecimal integer occupying a separate line, but the total length of the document is indeterminate until a final zero-length chunk is seen.</p><p>A sample chunked response may look like this:</p><a id="I_programlisting2_d1e4218"/><pre class="programlisting">HTTP/1.1 200 OK
Transfer-Encoding: chunked
...

5
Hello
6
world!
0</pre><p>There are no significant downsides to supporting chunked data transfers, other than the possibility of pathologically large chunks causing integer overflows in the browser code or needing to resolve mismatches between <span class="emphasis"><em>Content-Length</em></span> and chunk length. (The specification gives precedence to chunk length, although any attempts to handle this situation gracefully appear to be ill-advised.) All the popular browsers deal with these conditions properly, but new implementations need to watch their backs.</p></div>
<div class="sect1" title="Caching Behavior"><div class="titlepage"><div><div><h1 class="title"><a id="caching_behavior"/>Caching Behavior</h1></div></div></div><p>For reasons of performance and bandwidth conservation, HTTP clients and some intermediaries are eager to cache HTTP responses for later reuse. This must have seemed like a simple task in the early days of the Web, but it is increasingly fraught with peril as the Web encompasses ever more sensitive, user-specific information and as this information is updated more and more frequently.</p><p>RFC 2616 section 13.4 states that GET requests responded to with a range of HTTP codes (most notably, “200 OK” and “301 Moved Permanently”) may be implicitly cached in the absence of any other server-provided directives. Such a response may be stored in the cache indefinitely, and may be reused for any future requests involving the same request method and destination URL, even if other parameters (such as <span class="emphasis"><em>Cookie</em></span> headers) differ. There is a prohibition against caching requests that use HTTP authentication (see <a class="xref" href="ch03s08.html" title="HTTP Authentication">HTTP Authentication</a> in <a class="xref" href="ch03s08.html" title="HTTP Authentication">HTTP Authentication</a>), but other authentication methods, such as cookies, are not recognized in the spec.</p><p>When a response is cached, the implementation may opt to revalidate it before reuse, but doing so is not required most of the time. Revalidation is achieved by request with a special conditional header, such as <span class="emphasis"><em>If-Modified-Since</em></span> (followed by a date recorded on the previously cached response) or <span class="emphasis"><em>If-None-Match</em></span> (followed by an opaque <span class="emphasis"><em>ETag</em></span> header value that the server returned with an earlier copy). The server may respond with a “304 Not Modified” code or return a newer copy of the resource.<a class="indexterm" id="IDX-CHP-3-0144"/><a class="indexterm" id="IDX-CHP-3-0145"/><a class="indexterm" id="IDX-CHP-3-0146"/><a class="indexterm" id="IDX-CHP-3-0147"/><a class="indexterm" id="IDX-CHP-3-0148"/><a class="indexterm" id="IDX-CHP-3-0149"/><a class="indexterm" id="IDX-CHP-3-0150"/><a class="indexterm" id="IDX-CHP-3-0151"/><a class="indexterm" id="IDX-CHP-3-0152"/><a class="indexterm" id="IDX-CHP-3-0153"/><a class="indexterm" id="IDX-CHP-3-0154"/><a class="indexterm" id="IDX-CHP-3-0155"/><a class="indexterm" id="IDX-CHP-3-0156"/><a class="indexterm" id="IDX-CHP-3-0157"/><a class="indexterm" id="IDX-CHP-3-0158"/><a class="indexterm" id="IDX-CHP-3-0159"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>Date/If-Modified-Since</em></span> and <span class="emphasis"><em>ETag/If-None-Match</em></span> header pairs, when coupled with <span class="emphasis"><em>Cache-Control: private</em></span>, offer a convenient and entirely unintended way for websites to store long-lived, unique tokens in the browser.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-14">125</a>]</sup> The same can also be achieved by depositing a unique token inside a cacheable JavaScript file and returning “304 Not Modified” to all future conditional requests to the token-generating location. Unlike purpose-built mechanisms such as HTTP cookies (discussed in the next section), users have very little control over what information is stored in the browser cache, under what circumstances, and for how long.<a class="indexterm" id="IDX-CHP-3-0160"/></p></div><p>Implicit caching is highly problematic, and therefore, servers almost always should resort to using explicit HTTP-caching directives. To assist with this, HTTP/1.0 provides an <span class="emphasis"><em>Expires</em></span> header that specifies the date by which the cached copy should be discarded; if this value is equal to the <span class="emphasis"><em>Date</em></span> header provided by the server, the response is noncacheable. Beyond that simple rule, the connection between <span class="emphasis"><em>Expires</em></span> and <span class="emphasis"><em>Date</em></span> is unspecified: It is not clear whether <span class="emphasis"><em>Expires</em></span> should be compared to the system clock on the caching system (which is problematic if the client and server clocks are not in sync) or evaluated based on the <span class="emphasis"><em>Expires - Date</em></span> delta (which is more robust, but which may stop working if <span class="emphasis"><em>Date</em></span> is accidentally omitted). Firefox and Opera use the latter interpretation, while other browsers prefer the former one. In most browsers, an invalid <span class="emphasis"><em>Expires</em></span> value also inhibits caching, but depending on it is a risky bet.<a class="indexterm" id="IDX-CHP-3-0161"/></p><p>HTTP/1.0 clients can also include a <span class="emphasis"><em>Pragma: no-cache</em></span> request header, which may be interpreted by the proxy as an instruction to obtain a new copy of the requested resource, instead of returning an existing one. Some HTTP/1.0 proxies also recognize a nonstandard <span class="emphasis"><em>Pragma: no-cache</em></span> response header as an instruction not to make a copy of the document.</p><p>In contrast, HTTP/1.1 embraces a far more substantial approach to caching directives, introducing a new <span class="emphasis"><em>Cache-Control</em></span> header. The header takes values such as <span class="emphasis"><em>public</em></span> (the document is cacheable publicly), <span class="emphasis"><em>private</em></span> (proxies are not permitted to cache), <span class="emphasis"><em>no-cache</em></span> (which is a bit confusing—the response may be cached but should not be reused for future requests),<sup>[<a class="footnote" href="#ftn.CHP-3-FN-8" id="CHP-3-FN-8">21</a>]</sup> and <span class="emphasis"><em>no-store</em></span> (absolutely no caching at all). Public and private caching directives may be accompanied with a qualifier such as <span class="emphasis"><em>max-age</em></span>, specifying the maximum time an old copy should be kept, or <span class="emphasis"><em>must-revalidate</em></span>, requesting a conditional request to be made before content reuse.</p><p>Unfortunately, it is typically necessary for servers to return both HTTP/1.0 and HTTP/1.1 caching directives, because certain types of legacy commercial proxies do not understand <span class="emphasis"><em>Cache-Control</em></span> correctly. In order to reliably prevent caching over HTTP, it may be necessary to use the following set of response headers:<a class="indexterm" id="IDX-CHP-3-0162"/><a class="indexterm" id="IDX-CHP-3-0163"/><a class="indexterm" id="IDX-CHP-3-0164"/><a class="indexterm" id="IDX-CHP-3-0165"/><a class="indexterm" id="IDX-CHP-3-0166"/><a class="indexterm" id="IDX-CHP-3-0167"/><a class="indexterm" id="IDX-CHP-3-0168"/><a class="indexterm" id="IDX-CHP-3-0169"/><a class="indexterm" id="IDX-CHP-3-0170"/><a class="indexterm" id="IDX-CHP-3-0171"/><a class="indexterm" id="IDX-CHP-3-0172"/></p><a id="I_programlisting2_d1e4444"/><pre class="programlisting">Expires: [current date]
Date: [current date]
Pragma: no-cache
Cache-Control: no-cache, no-store</pre><p>When these caching directives disagree, the behavior is difficult to predict: Some browsers will favor HTTP/1.1 directives and give precedence to <span class="emphasis"><em>no-cache</em></span>, even if it is mistakenly followed by <span class="emphasis"><em>public</em></span>; others don’t.</p><p>Another risk of HTTP caching is associated with unsafe networks, such as public Wi-Fi networks, which allow an attacker to intercept requests to certain URLs and return modified, long-cacheable contents on requests to the victim. If such a poisoned browser cache is then reused on a trusted network, the injected content will unexpectedly resurface. Perversely, the victim does not even have to visit the targeted application: A reference to a carefully chosen sensitive domain can be injected by the attacker into some other context. There are no good solutions to this problem yet; purging your browser cache after visiting Starbucks may be a very good idea.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-8" id="ftn.CHP-3-FN-8">21</a>] </sup>The RFC is a bit hazy in this regard, but it appears that the intent is to permit the cached document to be used for purposes such as operating the “back” and “forward” navigation buttons in a browser but not when a proper page load is requested. Firefox follows this approach, while all other browsers consider <span class="emphasis"><em>no-cache</em></span> and <span class="emphasis"><em>no-store</em></span> to be roughly equivalent.</p></div></div></div>
<div class="sect1" title="HTTP Cookie Semantics"><div class="titlepage"><div><div><h1 class="title"><a id="http_cookie_semantics"/>HTTP Cookie Semantics</h1></div></div></div><p>HTTP cookies are not a part of RFC 2616, but they are one of the more important protocol extensions used on the Web. The cookie mechanism allows servers to store short, opaque <span class="emphasis"><em>name=value</em></span> pairs in the browser by sending a <span class="emphasis"><em>Set-Cookie</em></span> response header and to receive them back on future requests via the client-supplied <span class="emphasis"><em>Cookie</em></span> parameter. Cookies are by far the most popular way to maintain sessions and authenticate user requests; they are one of the four canonical forms of <span class="emphasis"><em>ambient authority</em></span><sup>[<a class="footnote" href="#ftn.CHP-3-FN-9" id="CHP-3-FN-9">22</a>]</sup> on the Web (the other forms being built-in HTTP authentication, IP checking, and client certificates).<a class="indexterm" id="IDX-CHP-3-0173"/><a class="indexterm" id="IDX-CHP-3-0174"/></p><p>Originally implemented in Netscape by Lou Montulli around 1994, and described in a brief four-page draft document,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-15">126</a>]</sup> the mechanism has not been outlined in a proper standard in the last 17 years. In 1997, RFC 2109<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-16">127</a>]</sup> attempted to document the status quo, but somewhat inexplicably, it also proposed a number of sweeping changes that, to this day, make this specification substantially incompatible with the actual behavior of any modern browser. Another ambitious effort—<span class="emphasis"><em>Cookie2</em></span>—made an appearance in RFC 2965,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-17">128</a>]</sup> but a decade later, it still has virtually no browser-level support, a situation that is unlikely to change. A new effort to write a reasonably accurate cookie specification—RFC 6265<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-18">129</a>]</sup>—was wrapped up shortly before the publication of this book, finally ending this specification-related misery.<a class="indexterm" id="IDX-CHP-3-0175"/><a class="indexterm" id="IDX-CHP-3-0176"/><a class="indexterm" id="IDX-CHP-3-0177"/><a class="indexterm" id="IDX-CHP-3-0178"/><a class="indexterm" id="IDX-CHP-3-0179"/><a class="indexterm" id="IDX-CHP-3-0180"/><a class="indexterm" id="IDX-CHP-3-0181"/><a class="indexterm" id="IDX-CHP-3-0182"/><a class="indexterm" id="IDX-CHP-3-0183"/><a class="indexterm" id="IDX-CHP-3-0184"/><a class="indexterm" id="IDX-CHP-3-0185"/></p><p>Because of the prolonged absence of any real standards, the actual implementations evolved in very interesting and sometimes incompatible ways. In practice, new cookies can be set using <span class="emphasis"><em>Set-Cookie</em></span> headers followed by a single <span class="emphasis"><em>name=value</em></span> pair and a number of optional semicolon-delimited parameters defining the scope and lifetime of the cookie.</p><div class="variablelist"><p class="title"/><dl><dt><span class="term"><span class="strong"><strong>Expires</strong></span></span></dt><dd><p>Specifies the expiration date for a cookie in a format similar to that used for <span class="emphasis"><em>Date</em></span> or <span class="emphasis"><em>Expires</em></span> HTTP headers. If a cookie is served without an explicit expiration date, it is typically kept in memory for the duration of a browser session (which, especially on portable computers with suspend functionality, can easily span several weeks). Definite-expiry cookies may be routinely saved to disk and persist across sessions, unless a user’s privacy settings explicitly prevent this possibility.</p></dd><dt><span class="term"><span class="strong"><strong>Max-age</strong></span></span></dt><dd><p>This alternative, RFC-suggested expiration mechanism is not supported in Internet Explorer and therefore is not used in practice.</p></dd><dt><span class="term"><span class="strong"><strong>Domain</strong></span></span></dt><dd><p>This parameter allows the cookie to be scoped to a domain broader than the hostname that returned the <span class="emphasis"><em>Set-Cookie</em></span> header. The exact rules and security consequences of this scoping mechanism are explored in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Contrary to what is implied in RFC 2109, it is not possible to scope cookies to a specific hostname when using this parameter. For example, <span class="emphasis"><em>domain=example.com</em></span> will always match <a class="ulink" href="http://www.example.com">www.example.com</a> as well. Omitting <span class="emphasis"><em>domain</em></span> is the only way to create host-scoped cookies, but even this approach is not working as expected in Internet Explorer.</p></div></dd><dt><span class="term"><span class="strong"><strong>Path</strong></span></span></dt><dd><p>Allows the cookie to be scoped to a particular request path prefix. This is not a viable security mechanism for the reasons explained in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>, but it may be used for convenience, to prevent identically named cookies used in various parts of the application from colliding with each other.</p></dd><dt><span class="term"><span class="strong"><strong>Secure attribute</strong></span></span></dt><dd><p>Prevents the resulting cookie from being sent over nonencrypted connections.</p></dd><dt><span class="term"><span class="strong"><strong>HttpOnly attribute</strong></span></span></dt><dd><p>Removes the ability to read the cookie through the <span class="emphasis"><em>document.cookie</em></span> API in JavaScript. This is a Microsoft extension, although it is now supported by all mainstream browsers.</p></dd></dl></div><p>When making future requests to a domain for which valid cookies are found in the cookie jar, browsers will combine all applicable <span class="emphasis"><em>name=value</em></span> pairs into a single, semicolon-delimited <span class="emphasis"><em>Cookie</em></span> header, without any additional metadata, and return them to the server. If too many cookies need to be sent on a particular request, server-enforced header size limits will be exceeded, and the request may fail; there is no method for recovering from this condition, other than manually purging the cookie jar.</p><p>Curiously, there is no explicit method for HTTP servers to delete unneeded cookies. However, every cookie is uniquely identified by a name-domain-path tuple (the <span class="emphasis"><em>secure</em></span> and <span class="emphasis"><em>httponly</em></span> attributes are ignored), which permits an old cookie of a known scope to be simply overwritten. Furthermore, if the overwriting cookie has an <span class="emphasis"><em>expires</em></span> date in the past, it will be immediately dropped, effectively giving a contrived way to purge the data.<a class="indexterm" id="IDX-CHP-3-0186"/><a class="indexterm" id="IDX-CHP-3-0187"/><a class="indexterm" id="IDX-CHP-3-0188"/><a class="indexterm" id="IDX-CHP-3-0189"/><a class="indexterm" id="IDX-CHP-3-0190"/><a class="indexterm" id="IDX-CHP-3-0191"/><a class="indexterm" id="IDX-CHP-3-0192"/><a class="indexterm" id="IDX-CHP-3-0193"/><a class="indexterm" id="IDX-CHP-3-0194"/><a class="indexterm" id="IDX-CHP-3-0195"/><a class="indexterm" id="IDX-CHP-3-0196"/><a class="indexterm" id="IDX-CHP-3-0197"/><a class="indexterm" id="IDX-CHP-3-0198"/><a class="indexterm" id="IDX-CHP-3-0199"/><a class="indexterm" id="IDX-CHP-3-0200"/></p><p>Although RFC 2109 requires multiple comma-separated cookies to be accepted within a single <span class="emphasis"><em>Set-Cookie</em></span> header, this approach is dangerous and is no longer supported by any browser. Firefox allows multiple cookies to be set in a single step via the <span class="emphasis"><em>document.cookie</em></span> JavaScript API, but inexplicably, it requires newlines as delimiters instead. No browser uses commas as <span class="emphasis"><em>Cookie</em></span> delimiters, and recognizing them on the server side should be considered unsafe.</p><p>Another important difference between the spec and reality is that cookie values are supposed to use the <span class="emphasis"><em>quoted-string</em></span> format outlined in HTTP specs (see <a class="xref" href="ch03.html#semicolon-delimited_header_values" title="Semicolon-Delimited Header Values">Semicolon-Delimited Header Values</a> in <a class="xref" href="ch03.html#semicolon-delimited_header_values" title="Semicolon-Delimited Header Values">Semicolon-Delimited Header Values</a>), but only Firefox and Opera recognize this syntax in practice. Reliance on <span class="emphasis"><em>quoted-string</em></span> values is therefore unsafe, and so is allowing stray quote characters in attacker-controlled cookies.</p><p>Cookies are not guaranteed to be particularly reliable. User agents enforce modest settings on the number and size of cookies permitted per domain and, as a misguided privacy feature, may also restrict their lifetime. Because equally reliable user tracking may be achieved by other means, such as the <span class="emphasis"><em>ETag/If-None-Match</em></span> behavior outlined in the previous section, the efforts to restrict cookie-based tracking probably do more harm than good.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-9" id="ftn.CHP-3-FN-9">22</a>] </sup><span class="emphasis"><em>Ambient authority</em></span> is a form of access control based on a global and persistent property of the requesting entity, rather than any explicit form of authorization that would be valid only for a specific action. A user-identifying cookie included indiscriminately on every outgoing request to a remote site, without any consideration for why this request is being made, falls into that category.</p></div></div></div>
<div class="sect1" title="HTTP Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="http_authentication"/>HTTP Authentication</h1></div></div></div><p>HTTP authentication, as specified in RFC 2617,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-19">130</a>]</sup> is the original credential-handling mechanism envisioned for web applications, one that is now almost completely extinct. The reasons for this outcome might have been the inflexibility of the associated browser-level UIs, the difficulty of accommodating more sophisticated non-password-based authentication schemes, or perhaps the inability to exercise control over how long credentials are cached and what other domains they are shared with.</p><p>In any case, the basic scheme is fairly simple. It begins with the browser making an unauthenticated request, to which the server responds with a “401 Unauthorized” code.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-10" id="CHP-3-FN-10">23</a>]</sup> The server must also include a <span class="emphasis"><em>WWW-Authenticate</em></span> HTTP header, specifying the requested authentication method, the <span class="emphasis"><em>realm</em></span> string (an arbitrary identifier to which the entered credentials should be bound), and other method-specific parameters, if applicable.</p><p>The client is expected to obtain the credentials in one way or the other, encode them in the <span class="emphasis"><em>Authorization</em></span> header, and retry the original request with this header included. According to the specification, for performance reasons, the same <span class="emphasis"><em>Authorization</em></span> header may also be included on subsequent requests to the same server path prefix without the need for a second <span class="emphasis"><em>WWW-Authenticate</em></span> challenge. It is also permissible to reuse the same credentials in response to any <span class="emphasis"><em>WWW-Authenticate</em></span> challenges elsewhere on the server, if the <span class="emphasis"><em>realm</em></span> string and the authentication method match.<a class="indexterm" id="IDX-CHP-3-0201"/><a class="indexterm" id="IDX-CHP-3-0202"/><a class="indexterm" id="IDX-CHP-3-0203"/><a class="indexterm" id="IDX-CHP-3-0204"/><a class="indexterm" id="IDX-CHP-3-0205"/><a class="indexterm" id="IDX-CHP-3-0206"/><a class="indexterm" id="IDX-CHP-3-0207"/><a class="indexterm" id="IDX-CHP-3-0208"/><a class="indexterm" id="IDX-CHP-3-0209"/></p><p>In practice, this advice is not followed very closely: Other than Safari and Chrome, most browsers ignore the <span class="emphasis"><em>realm</em></span> string or take a relaxed approach to path matching. On the flip side, all browsers scope cached credentials not only to the destination server but also to a specific protocol and port, a practice that offers some security benefits.</p><p>The two credential-passing methods specified in the original RFC are known as <span class="emphasis"><em>basic</em></span> and <span class="emphasis"><em>digest</em></span>. The first one essentially sends the passwords in plaintext, encoded as <span class="emphasis"><em>base64</em></span>. The other computes a one-time cryptographic hash that protects the password from being viewed in plaintext and prevents the <span class="emphasis"><em>Authorization</em></span> header from being replayed later. Unfortunately, modern browsers support both methods and do not distinguish between them in any clear way. As a result, attackers can simply replace the word <span class="emphasis"><em>digest</em></span> with <span class="emphasis"><em>basic</em></span> in the initial request to obtain a clean, plaintext password as soon as the user completes the authentication dialog. Surprisingly, section 4.8 of the RFC predicted this risk and offered some helpful yet ultimately ignored advice:<a class="indexterm" id="IDX-CHP-3-0210"/></p><div class="blockquote"><blockquote class="blockquote"><p>User agents should consider measures such as presenting a visual indication at the time of the credentials request of what authentication scheme is to be used, or remembering the strongest authentication scheme ever requested by a server and produce a warning message before using a weaker one. It might also be a good idea for the user agent to be configured to demand Digest authentication in general, or from specific sites.</p></blockquote></div><p>In addition to these two RFC-specified authentication schemes, some browsers also support less-common methods, such as Microsoft’s <span class="emphasis"><em>NTLM</em></span> and <span class="emphasis"><em>Negotiate</em></span>, used for seamless authentication with Windows domain credentials.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-20">131</a>]</sup></p><p>Although HTTP authentication is seldom encountered on the Internet, it still casts a long shadow over certain types of web applications. For example, when an external, attacker-supplied image is included in a thread on a message board, and the server hosting that image suddenly decides to return “401 Unauthorized” on some requests, users viewing the thread will be presented out of the blue with a somewhat cryptic password prompt. After double-checking the address bar, many will probably confuse the prompt for a request to enter their forum credentials, and these will be immediately relayed to the attacker’s image-hosting server. Oops.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-10" id="ftn.CHP-3-FN-10">23</a>] </sup>The terms <span class="emphasis"><em>authentication</em></span> and <span class="emphasis"><em>authorization</em></span> appear to be used interchangeably in this RFC, but they have a distinctive meaning elsewhere in information security. <span class="emphasis"><em>Authentication</em></span> is commonly used to refer to the process of proving your identity, whereas <span class="emphasis"><em>authorization</em></span> is the process of determining whether your previously established credentials permit you to carry out a specific privileged action.</p></div></div></div>
<div class="sect1" title="Protocol-Level Encryption and Client Certificates"><div class="titlepage"><div><div><h1 class="title"><a id="protocol-level_encryption_and_client_cer"/>Protocol-Level Encryption and Client Certificates</h1></div></div></div><p>As should now be evident, all information in HTTP sessions is exchanged in plaintext over the network. In the 1990s, this would not have been a big deal: Sure, plaintext exposed your browsing choices to nosy ISPs, and perhaps to another naughty user on your office network or an overzealous government agency, but that seemed no worse than the behavior of SMTP, DNS, or any other commonly used application protocol. Alas, the growing popularity of the Web as a commerce platform has aggravated the risk, and substantial network security regression caused by the emergence of inherently unsafe public wireless networks put another nail in that coffin.<a class="indexterm" id="IDX-CHP-3-0211"/><a class="indexterm" id="IDX-CHP-3-0212"/><a class="indexterm" id="IDX-CHP-3-0213"/><a class="indexterm" id="IDX-CHP-3-0214"/><a class="indexterm" id="IDX-CHP-3-0215"/><a class="indexterm" id="IDX-CHP-3-0216"/><a class="indexterm" id="IDX-CHP-3-0217"/><a class="indexterm" id="IDX-CHP-3-0218"/><a class="indexterm" id="IDX-CHP-3-0219"/><a class="indexterm" id="IDX-CHP-3-0220"/></p><p>After several less successful hacks, a straightforward solution to this problem was proposed in RFC 2818:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-21">132</a>]</sup> Why not encapsulate normal HTTP requests within an existing, multipurpose Transport Layer Security (TLS, aka SSL) mechanism developed several years earlier? This transport method leverages public key cryptography<sup>[<a class="footnote" href="#ftn.CHP-3-FN-11" id="CHP-3-FN-11">24</a>]</sup> to establish a confidential, authenticated communication channel between the two endpoints, without requiring any HTTP-level tweaks.<a class="indexterm" id="IDX-CHP-3-0221"/><a class="indexterm" id="IDX-CHP-3-0222"/></p><p>In order to allow web servers to prove their identity, every HTTPS-enabled web browser ships with a hefty set of public keys belonging to a variety of <span class="emphasis"><em>certificate authorities</em></span>. Certificate authorities are organizations that are trusted by browser vendors to cryptographically attest that a particular public key belongs to a particular site, hopefully after validating the identity of the person who requests such attestation and after verifying his claim to the domain in question.<a class="indexterm" id="IDX-CHP-3-0223"/></p><p>The set of trusted organizations is diverse, arbitrary, and not particularly well documented, which often prompts valid criticisms. But in the end, the system usually does the job reasonably well. Only a handful of bloopers have been documented so far (including a recent high-profile compromise of a company named Comodo<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-22">133</a>]</sup>), and no cases of widespread abuse of CA privileges are on the record.</p><p>As to the actual implementation, when establishing a new HTTPS connection, the browser receives a signed public key from the server, verifies the signature (which can’t be forged without having access to the CA’s private key), checks that the signed <span class="emphasis"><em>cn</em></span> (common name) or <span class="emphasis"><em>subjectAltName</em></span> fields in the certificate indicate that this certificate is issued for the server the browser wants to talk to, and confirms that the key is not listed on a public revocation list (for example, due to being compromised or obtained fraudulently). If everything checks out, the browser can proceed by encrypting messages to the server with that public key and be certain that only that specific party will be able to decrypt them.</p><p>Normally, the client remains anonymous: It generates a temporary encryption key, but that process does not prove the client’s identity. Such a proof can be arranged, though. Client certificates are embraced internally by certain organizations and are adopted on a national level in several countries around the world (e.g., for e-government services). Since the usual purpose of a client certificate is to provide some information about the real-world identity of the user, browsers usually prompt before sending them to newly encountered sites, for privacy reasons; beyond that, the certificate may act as yet another form of ambient authority.<a class="indexterm" id="IDX-CHP-3-0224"/><a class="indexterm" id="IDX-CHP-3-0225"/><a class="indexterm" id="IDX-CHP-3-0226"/></p><p>It is worth noting that although HTTPS as such is a sound scheme that resists both passive and active attackers, it does very little to hide the evidence of access to a priori public information. It does not mask the rough HTTP request and response sizes, traffic directions, and timing patterns in a typical browsing session, thus making it possible for unsophisticated, passive attackers to figure out, for example, which embarrassing page on Wikipedia is being viewed by the victim over an encrypted channel. In fact, in one extreme case, Microsoft researchers illustrated the use of such packet profiling to reconstruct user keystrokes in an online application.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-23">134</a>]</sup><a class="indexterm" id="IDX-CHP-3-0227"/></p><div class="sect2" title="Extended Validation Certificates"><div class="titlepage"><div><div><h2 class="title"><a id="extended_validation_certificates"/>Extended Validation Certificates</h2></div></div></div><p>In the early days of HTTPS, many public certificate authorities relied on fairly pedantic and cumbersome user identity and domain ownership checks before they would sign a certificate. Unfortunately, in pursuit of convenience and in the interest of lowering prices, some now require little more than a valid credit card and the ability to put a file on the destination server in order to complete the verification process. This approach renders most of the certificate fields other than <span class="emphasis"><em>cn</em></span> and <span class="emphasis"><em>subjectAltName</em></span> untrustworthy.</p><p>To address this problem, a new type of certificate, tagged using a special flag, is being marketed today at a significantly higher price: <span class="emphasis"><em>Extended Validation SSL (EV SSL)</em></span>. These certificates are expected not only to prove domain ownership but also more reliably attest to the identity of the requesting party, following a manual verification process. EV SSL is recognized by all modern browsers by making portion of the address bar blue or green. Although having this tier of certificates is valuable, the idea of coupling a higher-priced certificate with an indicator that vaguely implies a “higher level of security” is often criticized as a cleverly disguised money-making scheme.<a class="indexterm" id="IDX-CHP-3-0228"/><a class="indexterm" id="IDX-CHP-3-0229"/><a class="indexterm" id="IDX-CHP-3-0230"/></p></div><div class="sect2" title="Error-Handling Rules"><div class="titlepage"><div><div><h2 class="title"><a id="error-handling_rules"/>Error-Handling Rules</h2></div></div></div><p>In an ideal world, HTTPS connections that involve a suspicious certificate error, such as a grossly mismatched hostname or an unrecognized certification authority, should simply result in a failure to establish the connection. Less-suspicious errors, such as a recently expired certificate or a hostname mismatch, perhaps could be accompanied by just a gentle warning.</p><p>Unfortunately, most browsers have indiscriminately delegated the responsibility for understanding the problem to the user, trying hard (and ultimately failing) to explain cryptography in layman’s terms and requiring the user to make a binary decision: Do you actually want to see this page or not? (<a class="xref" href="ch03s09.html#an_example_certificate_warning_dialog_in" title="Figure 3-1. An example certificate warning dialog in the still-popular Internet Explorer 6">Figure 3-1</a> shows one such prompt.)</p><div class="figure"><a id="an_example_certificate_warning_dialog_in"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4987"/><img alt="An example certificate warning dialog in the still-popular Internet Explorer 6" src="httpatomoreillycomsourcenostarchimages949997.png.jpg"/></div></div><p class="title">Figure 3-1. An example certificate warning dialog in the still-popular Internet Explorer 6</p></div><p>The language and appearance of SSL warnings has evolved through the years toward increasingly dumbed-down (but still problematic) explanations of the problem and more complicated actions required to bypass the warning. This trend may be misguided: Studies show that over 50 percent of even the most frightening and disruptive warnings are clicked through.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-3-FT-24">135</a>]</sup> It is easy to blame the users, but ultimately, we may be asking them the wrong questions and offering exactly the wrong choices. Simply, if it is believed that clicking through the warning is advantageous in some cases, offering to open the page in a clearly labeled “sandbox” mode, where the harm is limited, would be a more sensible solution. And if there is no such belief, any override capabilities should be eliminated entirely (a goal sought by <span class="emphasis"><em>Strict Transport Security</em></span>, an experimental mechanism that will be discussed in <a class="xref" href="ch16.html" title="Chapter 16. New and Upcoming Security Features">Chapter 16</a>).<a class="indexterm" id="IDX-CHP-3-0231"/><a class="indexterm" id="IDX-CHP-3-0232"/></p><div class="sidebar"><a id="security_engineering_cheat_sheet-id1"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Handling User-Controlled Filenames in Content-Disposition Headers</span><a class="indexterm" id="IDX-CHP-3-0233"/><a class="indexterm" id="IDX-CHP-3-0234"/><a class="indexterm" id="IDX-CHP-3-0235"/><a class="indexterm" id="IDX-CHP-3-0236"/><a class="indexterm" id="IDX-CHP-3-0237"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>If you do not need non-Latin characters:</strong></span> Strip or substitute any characters except for alphanumerics, “.”, “-”, and “_”. To protect your users against potentially harmful or deceptive filenames, you may also want to confirm that at least the first character is alphanumeric and substitute all but the rightmost period with something else (e.g., an underscore).</p><p>Keep in mind that allowing quotes, semicolons, backslashes, and control characters (0x00-0x1F) will introduce vulnerabilities.</p></li><li class="listitem"><p><span class="strong"><strong>If you need non-Latin names:</strong></span> You must use RFC 2047, RFC 2231, or URL-style percent encoding in a browser-dependent manner. Make sure to filter out control characters (0x00-0x1F) and escape any semicolons, backslashes, and quotes.</p></li></ul></div><p><span class="bolditalic">When Putting User Data in HTTP Cookies</span><a class="indexterm" id="IDX-CHP-3-0238"/><a class="indexterm" id="IDX-CHP-3-0239"/><a class="indexterm" id="IDX-CHP-3-0240"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Percent-encode everything except for alphanumerics</strong></span>. Better yet, use base64. Stray quote characters, control characters (0x00-0x1F), high-bit characters (0x80-0xFF), commas, semicolons, and backslashes may allow new cookie values to be injected or the meaning and scope of existing cookies to be altered.</p></li></ul></div><p><span class="bolditalic">When Sending User-Controlled Location Headers</span><a class="indexterm" id="IDX-CHP-3-0241"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Consult the cheat sheet in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a></strong></span>. Parse and normalize the URL, and confirm that the scheme is on a whitelist of permissible values and that you are comfortable redirecting to the specified host.</p><p>Make sure that any control and high-bit characters are escaped properly. Use Punycode for hostnames and percent-encoding for the remainder of the URL.</p></li></ul></div><p><span class="bolditalic">When Sending User-Controlled Redirect Headers</span><a class="indexterm" id="IDX-CHP-3-0242"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Follow the advice provided for Location</strong></span>. Note that semicolons are unsafe in this header and cannot be escaped reliably, but they also happen to have a special meaning in some URLs. Your choice is to reject such URLs altogether or to percent-encode the “;” character, thereby violating the RFC-mandated syntax rules.</p></li></ul></div><p><span class="bolditalic">When Constructing Other Types of User-Controlled Requests or Responses</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Examine the syntax and potential side effects of the header in question</strong></span>. In general, be mindful of control and high-bit characters, commas, quotes, backslashes, and semicolons; other characters or strings may be of concern on a case-by-case basis. Escape or substitute these values as appropriate.</p></li><li class="listitem"><p><span class="strong"><strong>When building a new HTTP client, server, or proxy:</strong></span> Do not create a new implementation unless you absolutely have to. If you can’t help it, read this chapter thoroughly and aim to mimic an existing mainstream implementation closely. If possible, ignore the RFC-provided advice about fault tolerance and bail out if you encounter any syntax ambiguities.</p></li></ul></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-11" id="ftn.CHP-3-FN-11">24</a>] </sup>Public key cryptography relies on asymmetrical encryption algorithms to create a pair of keys: a private one, kept secret by the owner and required to decrypt messages, and a public one, broadcast to the world and useful only to encrypt traffic to that recipient, not to decrypt it.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;Hypertext Markup Language"><div class="titlepage"><div><div><h1 class="title"><a id="hypertext_markup_language"/>Chapter 4. Hypertext Markup Language</h1></div></div></div><p>The Hypertext Markup Language (HTML) is the primary method of authoring online documents. One of the earliest written accounts of this language is a brief summary posted on the Internet by Tim Berners-Lee in 1991.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-1">136</a>]</sup> His proposal outlines an SGML-derived syntax that allows text documents to be annotated with inline hyperlinks and several types of layout aids. In the following years, this specification evolved gradually under the direction of Sir Berners-Lee and Dan Connolly, but it wasn’t until 1995, at the onset of the First Browser Wars, that a reasonably serious and exhaustive specification of the language (HTML 2.0) made it to RFC 1866.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-2">137</a>]</sup><a class="indexterm" id="IDX-CHP-4-0001"/><a class="indexterm" id="IDX-CHP-4-0002"/><a class="indexterm" id="IDX-CHP-4-0003"/></p><p>From that point on, all hell broke loose: For the next few years, competing browser vendors kept introducing all sorts of flashy, presentation-oriented features and tweaked the language to their liking. Several attempts to amend the original RFC have been undertaken, but ultimately the IETF-managed standardization approach proved to be too inflexible. The newly formed World Wide Web Consortium took over the maintenance of the language and eventually published the HTML 3.2 specification in 1997.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-3">138</a>]</sup><a class="indexterm" id="IDX-CHP-4-0004"/><a class="indexterm" id="IDX-CHP-4-0005"/><a class="indexterm" id="IDX-CHP-4-0006"/><a class="indexterm" id="IDX-CHP-4-0007"/><a class="indexterm" id="IDX-CHP-4-0008"/><a class="indexterm" id="IDX-CHP-4-0009"/><a class="indexterm" id="IDX-CHP-4-0010"/><a class="indexterm" id="IDX-CHP-4-0011"/><a class="indexterm" id="IDX-CHP-4-0012"/><a class="indexterm" id="IDX-CHP-4-0013"/><a class="indexterm" id="IDX-CHP-4-0014"/><a class="indexterm" id="IDX-CHP-4-0015"/><a class="indexterm" id="IDX-CHP-4-0016"/><a class="indexterm" id="IDX-CHP-4-0017"/><a class="indexterm" id="IDX-CHP-4-0018"/></p><p>The new specification tried to reconcile the differences in browser implementations while embracing many of the bells and whistles that appealed to the public, such as customizable text colors and variable typefaces. Ultimately, though, HTML 3.2 proved to be a step back for the clarity of the language and had only limited success in catching up with the facts.</p><p>In the following years, the work on HTML 4 and 4.01<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-4">139</a>]</sup> focused on pruning HTML of all accumulated excess and on better explaining how document elements should be interpreted and rendered. It also defined an alternative, strict XHTML syntax derived from XML, which was much easier to consistently parse but more punishing to write. Despite all this work, however, only a small fraction of all websites on the Internet could genuinely claim compliance with any of these standards, and little or no consistency in parsing modes and error recovery could be seen on the client end. Consequently, some of the work on improving the core language fizzled out, and the W3C turned its attention to stylesheets, the Document Object Model, and other more abstract or forward-looking challenges.<a class="indexterm" id="IDX-CHP-4-0019"/></p><p>In the late 2000s, some of the low-level work has been revived under the banner of HTML5,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-5">140</a>]</sup> an ambitious project to normalize almost every aspect of the language syntax and parsing, define all the related APIs, and more closely police browser behavior in general. Time will tell if it will be successful; until then, the language itself, and each of the four leading parsing engines,<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">25</a>]</sup> come with their own set of frustrating quirks.</p><div class="sect1" title="Basic Concepts Behind HTML Documents"><div class="titlepage"><div><div><h1 class="title"><a id="basic_concepts_behind_html_documents"/>Basic Concepts Behind HTML Documents</h1></div></div></div><p>From a purely theoretical standpoint, HTML relies on a fairly simple syntax: a hierarchical structure of tags, <span class="emphasis"><em>name=value</em></span> tag parameters, and text nodes (forming the actual document body) in between. For example, a simple document with a title, a heading, and a hyperlink may look like this:</p><a id="I_programlisting3_d1e5223"/><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello world&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to our example page&lt;/h1&gt;
    &lt;a href="http://www.example.com/"&gt;Click me!&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>This syntax puts some constraints on what may appear inside a parameter value or inside the document body. Five characters—angle brackets, single and double quotes, and an ampersand—are reserved as the building blocks of the HTML markup, and these need to be avoided or escaped in some way when used outside of their intended function. The most important rules are:<a class="indexterm" id="IDX-CHP-4-0020"/><a class="indexterm" id="IDX-CHP-4-0021"/><a class="indexterm" id="IDX-CHP-4-0022"/><a class="indexterm" id="IDX-CHP-4-0023"/><a class="indexterm" id="IDX-CHP-4-0024"/><a class="indexterm" id="IDX-CHP-4-0025"/><a class="indexterm" id="IDX-CHP-4-0026"/><a class="indexterm" id="IDX-CHP-4-0027"/><a class="indexterm" id="IDX-CHP-4-0028"/><a class="indexterm" id="IDX-CHP-4-0029"/><a class="indexterm" id="IDX-CHP-4-0030"/><a class="indexterm" id="IDX-CHP-4-0031"/><a class="indexterm" id="IDX-CHP-4-0032"/><a class="indexterm" id="IDX-CHP-4-0033"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Stray ampersands (&amp;) should never appear in most sections of an HTML document.</p></li><li class="listitem"><p>Both types of angle brackets are obviously problematic inside a tag, unless properly quoted.</p></li><li class="listitem"><p>The left angle bracket (&lt;) is a hazard inside a text node.</p></li><li class="listitem"><p>Quote characters appearing inside a tag can have undesirable effects, depending on their exact location, but are harmless in text nodes.</p></li></ul></div><p>To allow these characters to appear in problematic locations without causing side effects, an ampersand-based encoding scheme, discussed in <a class="xref" href="ch04s03.html" title="Entity Encoding">Entity Encoding</a> in <a class="xref" href="ch04s02.html#html_parsing_survival_tips" title="HTML Parsing Survival Tips">HTML Parsing Survival Tips</a>, is provided.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Of course, the availability of such an encoding scheme is not a guarantee of its use. The failure to properly filter out or escape reserved characters when displaying user-controlled data is the cause of a range of extremely common and deadly web application security flaws. A particularly well-known example of this is <span class="emphasis"><em>cross-site scripting (XSS)</em></span>, an attack in which malicious, attacker-provided JavaScript code is unintentionally echoed back somewhere in the HTML markup, effectively giving the attacker full control over the appearance and operation of the targeted site.<a class="indexterm" id="IDX-CHP-4-0034"/></p></div><div class="sect2" title="Document Parsing Modes"><div class="titlepage"><div><div><h2 class="title"><a id="document_parsing_modes"/>Document Parsing Modes</h2></div></div></div><p>For any HTML document, a top-level <span class="emphasis"><em>&lt;!DOCTYPE&gt;</em></span> directive may be used to instruct the browser to parse the file in a manner that at least superficially conforms to one of the officially defined standards; to a more limited extent, the same signal can be conveyed by the <span class="emphasis"><em>Content-Type</em></span> header, too. Of all the available parsing modes, the most striking difference exists between XHTML and traditional HTML. In the traditional mode, parsers will attempt to recover from most types of syntax errors, including unmatched opening and closing tags. In addition, tag and parameter names will be considered case insensitive, parameter values will not always need to be quoted, and certain types of tags, such as <span class="emphasis"><em>&lt;img&gt;</em></span>, will be closed implicitly. In other words, the following input will be grudgingly tolerated:</p><a id="I_programlisting3_d1e5322"/><pre class="programlisting">&lt;hTmL&gt;
  &lt;BODY&gt;
    &lt;IMG src="/hello_world.jpg"&gt;
    &lt;a HREF=http://www.example.com/&gt;
      Click me!
    &lt;/oops&gt;
&lt;/html&gt;</pre><p>The XML mode, on the other hand, is strict: All tags need to be balanced carefully, named using the proper case, and closed explicitly. (The XML-specific self-closing tag syntax, such as <span class="emphasis"><em>&lt;img /&gt;</em></span>, is permitted.) In addition, most syntax mistakes, even trivial ones, will result in an error and prevent the document from being displayed at all.<a class="indexterm" id="IDX-CHP-4-0035"/><a class="indexterm" id="IDX-CHP-4-0036"/><a class="indexterm" id="IDX-CHP-4-0037"/><a class="indexterm" id="IDX-CHP-4-0038"/><a class="indexterm" id="IDX-CHP-4-0039"/><a class="indexterm" id="IDX-CHP-4-0040"/><a class="indexterm" id="IDX-CHP-4-0041"/><a class="indexterm" id="IDX-CHP-4-0042"/><a class="indexterm" id="IDX-CHP-4-0043"/><a class="indexterm" id="IDX-CHP-4-0044"/><a class="indexterm" id="IDX-CHP-4-0045"/><a class="indexterm" id="IDX-CHP-4-0046"/><a class="indexterm" id="IDX-CHP-4-0047"/><a class="indexterm" id="IDX-CHP-4-0048"/><a class="indexterm" id="IDX-CHP-4-0049"/><a class="indexterm" id="IDX-CHP-4-0050"/><a class="indexterm" id="IDX-CHP-4-0051"/><a class="indexterm" id="IDX-CHP-4-0052"/><a class="indexterm" id="IDX-CHP-4-0053"/><a class="indexterm" id="IDX-CHP-4-0054"/></p><p>Unlike the regular flavor of HTML, XML-based documents may also elegantly incorporate sections using other XML-compliant markup formats, such as MathML, a mathematical formula markup language. This is done by specifying a different <span class="emphasis"><em>xmlns</em></span> namespace setting for a particular tag, with no need for one-off, language-level hacks.</p><p>The last important difference worth mentioning here is that traditional HTML parsing strategies feature a selection of special modes, entered into after certain tags are encountered and exited only when a specific terminator string is seen; everything in between is interpreted as non-HTML text. Some examples of such special tags include <span class="emphasis"><em>&lt;style&gt;</em></span>, <span class="emphasis"><em>&lt;script&gt;</em></span>, <span class="emphasis"><em>&lt;textarea&gt;</em></span>, or <span class="emphasis"><em>&lt;xmp&gt;</em></span>. In practical implementations, these modes are exited only when a literal, case-insensitive match on <span class="emphasis"><em>&lt;/style</em></span>, <span class="emphasis"><em>&lt;/script</em></span>, or a similar matching value, is made; any other markup inside such a block will not be interpreted as HTML. (Interestingly, there is one officially obsolete tag, <span class="emphasis"><em>&lt;plaintext&gt;</em></span>, that cannot be exited at all; it stays in effect for the remainder of the document.)</p><p>In comparison, the XML mode is more predictable. It generally forbids stray “&lt;” and “&amp;” characters inside the document, but it provides a special syntax, starting with “&lt;![CDATA[” and ending with “]]&gt;”, as a way to encapsulate any raw text inside an arbitrary tag. For example:</p><a id="I_programlisting3_d1e5434"/><pre class="programlisting">&lt;script&gt;
&lt;![CDATA[
  alert('&gt;&gt;&gt; Hello world! &lt;&lt;&lt;');
]]&gt;
&lt;/script&gt;</pre><p>The other notable special parsing mode available in both XHTML and normal HTML is a comment block. In XML, it quite simply begins with “&lt;!--” and ends with “--&gt;”. In the traditional HTML parser in Firefox versions prior to 4, any occurrence of “--”, later followed by “&gt;”, is also considered good enough.</p></div><div class="sect2" title="The Battle over Semantics"><div class="titlepage"><div><div><h2 class="title"><a id="the_battle_over_semantics"/>The Battle over Semantics</h2></div></div></div><p>The low-level syntax of the language aside, HTML is also the subject of a fascinating conceptual struggle: a clash between the ideology and the reality of the online world. Tim Berners-Lee always championed the vision of a <span class="emphasis"><em>semantic web</em></span>, an interconnected system of documents in which every functional block, such as a citation, a snippet of code, a mailing address, or a heading, has its meaning explained by an appropriate machine-readable tag (say, <span class="emphasis"><em>&lt;cite&gt;</em></span>, <span class="emphasis"><em>&lt;code&gt;</em></span>, <span class="emphasis"><em>&lt;address&gt;</em></span>, or <span class="emphasis"><em>&lt;h1&gt;</em></span> to <span class="emphasis"><em>&lt;h6&gt;</em></span>).</p><p>This approach, he and other proponents argued, would make it easier for machines to crawl, analyze, and index the content in a meaningful way, and in the near future, it would enable computers to reason using the sum of human knowledge. According to this philosophy, the markup language should provide a way to stylize the appearance of a document, but only as an afterthought.<a class="indexterm" id="IDX-CHP-4-0055"/><a class="indexterm" id="IDX-CHP-4-0056"/><a class="indexterm" id="IDX-CHP-4-0057"/><a class="indexterm" id="IDX-CHP-4-0058"/><a class="indexterm" id="IDX-CHP-4-0059"/><a class="indexterm" id="IDX-CHP-4-0060"/><a class="indexterm" id="IDX-CHP-4-0061"/><a class="indexterm" id="IDX-CHP-4-0062"/></p><p>Sir Berners-Lee has never given up on this dream, but in this one regard, the actual usage of HTML proved to be very different from what he wished for. Web developers were quick to pragmatically distill the essence of HTML 3.2 into a handful of presentation-altering but semantically neutral tags, such as <span class="emphasis"><em>&lt;font&gt;</em></span>, <span class="emphasis"><em>&lt;b&gt;</em></span>, and <span class="emphasis"><em>&lt;pre&gt;</em></span>, and saw no reason to explain further the structure of their documents to the browser. W3C attempted to combat this trend but with limited success. Although tags such as <span class="emphasis"><em>&lt;font&gt;</em></span> have been successfully obsoleted and largely abandoned in favor of CSS, this is only because stylesheets offered more powerful and consistent visual controls. With the help of CSS, the developers simply started relying on a soup of semantically agnostic <span class="emphasis"><em>&lt;span&gt;</em></span> and <span class="emphasis"><em>&lt;div&gt;</em></span> tags to build everything from headings to user-clickable buttons, all in a manner completely opaque to any automated content extraction tools.</p><p>Despite having had a lasting impact on the design of the language, in some ways, the idea of a semantic web may be becoming obsolete: Online content less frequently maps to the concept of a single, viewable document, and HTML is often reduced to providing a convenient drawing surface and graphic primitives for JavaScript applications to build their interfaces with.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">25</a>] </sup>To process HTML documents, Internet Explorer uses the Trident engine (aka MSHTML); Firefox and some derived products use Gecko; Safari, Chrome, and several other browsers use WebKit; and Opera relies on Presto. With the exception of WebKit, a collaborative open source effort maintained by several vendors, these engines are developed largely in-house by their respective browser teams.</p></div></div></div>
<div class="sect1" title="Understanding HTML Parser Behavior"><div class="titlepage"><div><div><h1 class="title"><a id="understanding_html_parser_behavior"/>Understanding HTML Parser Behavior</h1></div></div></div><p>The fundamentals of HTML syntax outlined in the previous sections are usually enough to understand the meaning of well-formed HTML and XHTML documents. When the XHTML dialect is used, there is little more to the story: The minimal fault-tolerance of the parser means that anomalous syntax almost always leads simply to a parsing error. Alas, the picture is very different with traditional, laid-back HTML parsers, which aggressively second-guess the intent of the page developer even in very ambiguous or potentially harmful situations.<a class="indexterm" id="IDX-CHP-4-0063"/></p><p>Since an accurate understanding of user-supplied markup is essential to designing many types of security filters, let’s have a quick look at some of these behaviors and quirks. To begin, consider the following reference snippet:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e5530"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages949999.png.jpg"/></div></div><p>Web developers are usually surprised to learn that this syntax can be drastically altered without changing its significance to the browser. For example, Internet Explorer will allow an NUL character (0x00) to be inserted in the location marked at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5537"/><img alt="" src="httpatomoreillycomsourcenostarchimages950001.png"/></span>, a change that is likely to throw all naïve HTML filters off the trail. It is also not widely known that the whitespaces at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5543"/><img alt="" src="httpatomoreillycomsourcenostarchimages950003.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5549"/><img alt="" src="httpatomoreillycomsourcenostarchimages950005.png"/></span> can be substituted with uncommon vertical tab (0x0B) or form feed (0x0C) characters in all browsers and with a nonbreaking UTF-8 space (0xA0) in Opera.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-2" id="CHP-4-FN-2">26</a>]</sup> Oh, and here's a really surprising bit: In Firefox, the whitespace at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5562"/><img alt="" src="httpatomoreillycomsourcenostarchimages950003.png"/></span> can also be replaced with a single, regular slash—yet the one at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5569"/><img alt="" src="httpatomoreillycomsourcenostarchimages950005.png"/></span> can’t.<a class="indexterm" id="IDX-CHP-4-0064"/><a class="indexterm" id="IDX-CHP-4-0065"/><a class="indexterm" id="IDX-CHP-4-0066"/><a class="indexterm" id="IDX-CHP-4-0067"/><a class="indexterm" id="IDX-CHP-4-0068"/><a class="indexterm" id="IDX-CHP-4-0069"/><a class="indexterm" id="IDX-CHP-4-0070"/><a class="indexterm" id="IDX-CHP-4-0071"/><a class="indexterm" id="IDX-CHP-4-0072"/><a class="indexterm" id="IDX-CHP-4-0073"/><a class="indexterm" id="IDX-CHP-4-0074"/><a class="indexterm" id="IDX-CHP-4-0075"/><a class="indexterm" id="IDX-CHP-4-0076"/><a class="indexterm" id="IDX-CHP-4-0077"/></p><p>Moving on, the location marked <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5632"/><img alt="" src="httpatomoreillycomsourcenostarchimages950007.png"/></span> is also of note. In this spot, NUL characters are ignored by most parsers, as are many types of whitespaces. Not long ago, WebKit browsers accepted a slash in this location, but recent parser improvements have eliminated this quirk.<a class="indexterm" id="IDX-CHP-4-0078"/><a class="indexterm" id="IDX-CHP-4-0079"/></p><p>Quote characters are a yet another topic of interest. Website developers know that single and double quotes can be used to put a string containing whitespaces or angle brackets in an HTML parameter, but it usually comes as a surprise that Internet Explorer also honors backticks (`) instead of real quotes in the location marked <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5648"/><img alt="" src="httpatomoreillycomsourcenostarchimages950009.png"/></span>. Similarly, few people realize that in any browser, an implicit whitespace is inserted after a quoted parameter, and that the explicit whitespace at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5654"/><img alt="" src="httpatomoreillycomsourcenostarchimages950011.png"/></span> can therefore be skipped without changing the meaning of the tag.</p><p>The security impact of these patterns is not always easy to appreciate, but consider an HTML filter tasked with scrubbing an <span class="emphasis"><em>&lt;img&gt;</em></span> tag with an attacker-controlled <span class="emphasis"><em>title</em></span> parameter. Let’s say that in the input markup, this parameter is not quoted if it contains no whitespaces and angle brackets—a design that can be seen on a popular blogging site. This practice may appear safe at first, but in the following two cases, a malicious, injected <span class="emphasis"><em>onerror</em></span> parameter will materialize inside a tag:</p><a id="I_programlisting3_d1e5671"/><pre class="programlisting">&lt;img ... title=""onerror="alert(1)"&gt;</pre><p>and</p><a id="I_programlisting3_d1e5675"/><pre class="programlisting">&lt;img ... title=``onerror=`alert(1)`&gt;</pre><p>Yet another wonderful quote-related quirk in Internet Explorer makes this job even more complicated. While most browsers recognize quoting only when it is used at the beginning of a parameter value, Internet Explorer simply checks for any occurrence of an equal sign (=) followed by a quote and will parse this syntax in a rather unexpected way:</p><a id="I_programlisting3_d1e5680"/><pre class="programlisting">&lt;img src=test.jpg?value="&gt;Yes, we are still inside a tag!"&gt;</pre><div class="sect2" title="Interactions Between Multiple Tags"><div class="titlepage"><div><div><h2 class="title"><a id="interactions_between_multiple_tags"/>Interactions Between Multiple Tags</h2></div></div></div><p>Parsing a single tag can be a daunting task, but as you might imagine, anomalous arrangements of multiple HTML tags will be even less predictable. Consider the following trivial example:</p><a id="I_programlisting3_d1e5687"/><pre class="programlisting">&lt;i &lt;b&gt;</pre><p>When presented with such syntax, most browsers only interpret <span class="emphasis"><em>&lt;i&gt;</em></span> and treat the “&lt;b” string as an invalid tag parameter. Firefox versions before 4, however, would automatically close the <span class="emphasis"><em>&lt;i&gt;</em></span> tag first when encountering an angle bracket and, in the end, will interpret both <span class="emphasis"><em>&lt;i&gt;</em></span> and <span class="emphasis"><em>&lt;b&gt;</em></span>. In the spirit of fault tolerance, until recently WebKit followed that model, too.<a class="indexterm" id="IDX-CHP-4-0080"/><a class="indexterm" id="IDX-CHP-4-0081"/><a class="indexterm" id="IDX-CHP-4-0082"/><a class="indexterm" id="IDX-CHP-4-0083"/><a class="indexterm" id="IDX-CHP-4-0084"/><a class="indexterm" id="IDX-CHP-4-0085"/><a class="indexterm" id="IDX-CHP-4-0086"/></p><p>A similar behavior can be observed in previous versions of Firefox when dealing with tag names that contain invalid characters (in this case, the equal sign). Instead of doing its best to ignore the entire block, the parser would simply reset and interpret the quoted tag:</p><a id="I_programlisting3_d1e5733"/><pre class="programlisting">&lt;i="&lt;b&gt;"&gt;</pre><p>The handling of tags that are not closed before the end of the file is equally fascinating. For example, the following snippet will prompt most browsers to interpret the <span class="emphasis"><em>&lt;i&gt;</em></span> tag or ignore the entire string, but Internet Explorer and Opera use a different backtracking approach and will see <span class="emphasis"><em>&lt;b&gt;</em></span> instead:</p><a id="I_programlisting3_d1e5743"/><pre class="programlisting">&lt;i foo="&lt;b&gt;" [EOF]</pre><p>In fact, Firefox versions prior to version 4 engaged in far-fetched reparsing whenever particular special tags, such as <span class="emphasis"><em>&lt;title&gt;</em></span>, were not closed before the end of the document:</p><a id="I_programlisting3_d1e5750"/><pre class="programlisting">&lt;title&gt;This text will be interpreted as a title
&lt;i&gt;This text will be shown as document body!
[EOF]</pre><p>The last two parsing quirks have interesting security consequences in any scenario where the attacker may be able to interrupt page load prematurely. Even if the markup is otherwise fairly well sanitized, the meaning of the document may change in a very unexpected way.</p></div><div class="sect2" title="Explicit and Implicit Conditionals"><div class="titlepage"><div><div><h2 class="title"><a id="explicit_and_implicit_conditionals"/>Explicit and Implicit Conditionals</h2></div></div></div><p>To further complicate the job of HTML parsing, some browsers exhibit behaviors that can be used to conditionally skip some of the markup in a document. For example, in an attempt to help novice users of Microsoft’s Active Server Pages development platform, Internet Explorer treats <span class="emphasis"><em>&lt;% ... %&gt;</em></span> blocks as a completely nonstandard comment, hiding any markup between these two character sequences. Another Internet Explorer-specific feature is explicit conditional expressions interpreted by the parser and smuggled inside standard HTML comment blocks:<a class="indexterm" id="IDX-CHP-4-0087"/></p><a id="I_programlisting3_d1e5765"/><pre class="programlisting">&lt;!--[if IE 6]&gt;
  Markup that will be parsed only for Internet Explorer 6
&lt;![endif]—&gt;</pre><p>Many other quirks of this type are related to the idiosyncrasies of SGML and XML. For example, due to the comment-handling behavior mentioned earlier in an aside, browsers disagree on how to parse !- and ?-directives (such as <span class="emphasis"><em>&lt;!DOCTYPE&gt;</em></span> or <span class="emphasis"><em>&lt;?xml&gt;</em></span>), whether to allow XML-style CDATA blocks in non-XHTML modes, and on what precedence to give to overlapping special parsing mode tags (such as “<span class="emphasis"><em>&lt;style&gt;&lt;!-- &lt;/style&gt; --&gt;</em></span>”).<a class="indexterm" id="IDX-CHP-4-0088"/><a class="indexterm" id="IDX-CHP-4-0089"/><a class="indexterm" id="IDX-CHP-4-0090"/><a class="indexterm" id="IDX-CHP-4-0091"/><a class="indexterm" id="IDX-CHP-4-0092"/><a class="indexterm" id="IDX-CHP-4-0093"/><a class="indexterm" id="IDX-CHP-4-0094"/><a class="indexterm" id="IDX-CHP-4-0095"/><a class="indexterm" id="IDX-CHP-4-0096"/><a class="indexterm" id="IDX-CHP-4-0097"/><a class="indexterm" id="IDX-CHP-4-0098"/></p></div><div class="sect2" title="HTML Parsing Survival Tips"><div class="titlepage"><div><div><h2 class="title"><a id="html_parsing_survival_tips"/>HTML Parsing Survival Tips</h2></div></div></div><p>The set of parsing behaviors discussed in the previous sections is by no means exhaustive. In fact, an entire book has been written on this topic: Inquisitive readers are advised to grab <span class="emphasis"><em>Web Application Obfuscation</em></span> (Syngress, 2011) by Mario Heiderich, Eduardo Alberto Vela Nava, Gareth Heyes, and David Lindsay—and then weep about the fate of humanity. The bottom line is that building HTML filters that try to block known dangerous patterns, and allow the remaining markup as is, is simply not feasible.</p><p>The only reasonable approach to tag sanitization is to employ a realistic parser to translate the input document into a hierarchical in-memory document tree, and then scrub this representation for all unrecognized tags and parameters, as well as any undesirable tag/parameter/value configurations. At that point, the tree can be carefully reserialized into a well-formed, well-escaped HTML that will not flex any of the error correction muscles in the browser itself. Many developers think that a simpler design should be possible, but eventually they discover the reality the hard way.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-2" id="ftn.CHP-4-FN-2">26</a>] </sup>The behavior exhibited by Opera is particularly sneaky: The Unicode whitespace is not recognized by many standard library functions used in server-side HTML sanitizers, such as <span class="emphasis"><em>isspace(...)</em></span> in libc. This increases the risk of implementation glitches.</p></div></div></div>
<div class="sect1" title="Entity Encoding"><div class="titlepage"><div><div><h1 class="title"><a id="entity_encoding"/>Entity Encoding</h1></div></div></div><p>Let’s talk about character encoding again. As noted on the first pages of this chapter, certain reserved characters are generally unsafe inside text nodes and tag parameter values, and they will often lead to outright syntax errors in XHTML. In order to allow such characters to be used safely (and to allow a convenient way to embed high-bit text), a simple ampersand-prefixed, semicolon-terminated encoding scheme, known as entity encoding, is available to developers.</p><p>The most familiar use of this encoding method is the inclusion of certain predefined, named entities. Only a handful of these are specified for XML, but several hundred more are scattered in HTML specifications and supported by all modern browsers. In this approach, <span class="emphasis"><em>&amp;lt;</em></span> is used to insert a left angle bracket; <span class="emphasis"><em>&amp;gt;</em></span> substitutes a right angle bracket; <span class="emphasis"><em>&amp;amp;</em></span> replaces the ampersand itself; while, say, <span class="emphasis"><em>&amp;rarr;</em></span> is a nice Unicode arrow.<a class="indexterm" id="IDX-CHP-4-0099"/><a class="indexterm" id="IDX-CHP-4-0100"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In XHTML documents, additional named entities can be defined using the <span class="emphasis"><em>&lt;!ENTITY&gt;</em></span> directive and made to resolve to internally defined strings or to the contents of an external file URL. (This last option is obviously unsafe if allowed when processing untrusted content; the resulting attack is sometimes called <span class="emphasis"><em>External XML Entity</em></span>, or XXE for short.)</p></div><p>In addition to the named entities, it is also possible to insert an arbitrary ASCII or Unicode character using a decimal <span class="emphasis"><em>&amp;#number;</em></span> notation. In this case, <span class="emphasis"><em>&amp;#60;</em></span> maps to a left angle bracket; <span class="emphasis"><em>&amp;#62;</em></span> substitutes a right one; and <span class="emphasis"><em>&amp;#128569;</em></span> is, I kid you not, a Unicode 6.0 character named “smiling cat face with tears of joy.” Hexadecimal notation can also be used if the number is prefixed with “x”. In this variant, the left angle bracket becomes <span class="emphasis"><em>&amp;#x3c;</em></span>, etc.<a class="indexterm" id="IDX-CHP-4-0101"/><a class="indexterm" id="IDX-CHP-4-0102"/></p><p>The HTML parser recognizes entity encoding inside text nodes and parameter values and decodes it transparently when building an in-memory representation of the document tree. Therefore, the following two cases are functionally identical:</p><a id="I_programlisting3_d1e5894"/><pre class="programlisting">&lt;img src="http://www.example.com"&gt;</pre><p>and</p><a id="I_programlisting3_d1e5898"/><pre class="programlisting">&lt;img src="ht&amp;#x74;p&amp;#x3a;//www.example.com"&gt;</pre><p>The following two examples, on the other hand, will not work as expected, as the encoding interferes with the structure of the tag itself:</p><a id="I_programlisting3_d1e5902"/><pre class="programlisting">&lt;img src&amp;#x3d;"http://www.example.com"&gt;</pre><p>and</p><a id="I_programlisting3_d1e5907"/><pre class="programlisting">&lt;img s&amp;#x72;c="http://www.example.com"&gt;</pre><p>The largely transparent behavior of entity encoding makes it important to correctly resolve it prior to making any security decisions about the contents of a document and, if applicable, to properly restore it in the sanitized output later on. To illustrate, the following syntax must be recognized as an absolute reference to a <span class="emphasis"><em>javascript:</em></span> pseudo-URL and not to a cryptic fragment ID inside a relative resource named “./javascript&amp;”:</p><a id="I_programlisting3_d1e5914"/><pre class="programlisting">&lt;a href="javascript&amp;#x3a;alert(1)"&gt;</pre><p>Unfortunately, even the simple task of recognizing and parsing HTML entities can be tricky. In traditional parsing, for example, entities may often be accepted even if the trailing semicolon is omitted, as long as the next character is not an alphanumeric. (In Firefox, dashes and periods are also accepted in entity names.) Numeric entities are even more problematic, as they may have an overlong notation with an arbitrary number of trailing zeros. Moreover, if the numerical value is higher than 232, the standard size of an integer on many computer architectures, the corresponding character may be computed incorrectly.<a class="indexterm" id="IDX-CHP-4-0103"/></p><p>Developers working with XHTML should be aware of a potential pitfall in that dialect, too. Although HTML entities are not recognized in most of the special parsing modes, XHTML differs from traditional HTML in that tags such as <span class="emphasis"><em>&lt;script&gt;</em></span> and <span class="emphasis"><em>&lt;style&gt;</em></span> do not automatically toggle a special parsing mode on their own. Instead, an explicit <span class="emphasis"><em>&lt;![CDATA[...]]&gt;</em></span> block around any scripts or stylesheets is required to achieve a comparable effect. Therefore, the following snippet with an attacker-controlled string (otherwise scrubbed for angle brackets, quotes, backslashes, and newlines) is perfectly safe in HTML, but not in XHTML:<a class="indexterm" id="IDX-CHP-4-0104"/><a class="indexterm" id="IDX-CHP-4-0105"/><a class="indexterm" id="IDX-CHP-4-0106"/><a class="indexterm" id="IDX-CHP-4-0107"/><a class="indexterm" id="IDX-CHP-4-0108"/><a class="indexterm" id="IDX-CHP-4-0109"/><a class="indexterm" id="IDX-CHP-4-0110"/><a class="indexterm" id="IDX-CHP-4-0111"/><a class="indexterm" id="IDX-CHP-4-0112"/><a class="indexterm" id="IDX-CHP-4-0113"/><a class="indexterm" id="IDX-CHP-4-0114"/><a class="indexterm" id="IDX-CHP-4-0115"/></p><a id="I_programlisting3_d1e5979"/><pre class="programlisting">&lt;script&gt;
  var tmp = 'I am harmless! &amp;#x27;+alert(1);// Or am I?';
  ...
&lt;/script&gt;</pre></div>
<div class="sect1" title="HTTP/HTML Integration Semantics"><div class="titlepage"><div><div><h1 class="title"><a id="http_solidus_html_integration_semantics"/>HTTP/HTML Integration Semantics</h1></div></div></div><p>From <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>, we recall that HTTP headers may give new meaning to the entire response (<span class="emphasis"><em>Location</em></span>, <span class="emphasis"><em>Transfer-Encoding</em></span>, and so on), change the way the payload is presented (<span class="emphasis"><em>Content-Type</em></span>, <span class="emphasis"><em>Content-Disposition</em></span>), or affect the client-side environment in other, auxiliary ways (<span class="emphasis"><em>Refresh</em></span>, <span class="emphasis"><em>Set-Cookie</em></span>, <span class="emphasis"><em>Cache-Control</em></span>, <span class="emphasis"><em>Expires</em></span>, etc.).</p><p>But what if an HTML document is delivered through a non-HTTP protocol or loaded from a local file? Clearly, in this case, there is no simple way to express or preserve this information. We can part with some of it easily, but parameters such as the MIME type or the character set are essential, and losing them forces browsers to improvise later on. (Consider, for example, that charsets such as UTF-7, UTF-16, and UTF-32 are not ASCII-compatible and, therefore, HTML documents can’t even be parsed without determining which of these transformations needs to be used.)</p><p>The security consequences of the browser-level heuristics used to detect character sets and document types will be explored in detail in <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a>. Meanwhile, the problem of preserving protocol-level information within a document is somewhat awkwardly addressed by a special HTML directive, <span class="emphasis"><em>&lt;meta http-equiv=...&gt;</em></span>. By the time the browser examines the markup, many content-handling decisions must have already been made, but some tweaks are still on the table; for example, it may be possible to adjust the charset to a generally compatible value or to specify <span class="emphasis"><em>Refresh</em></span>, <span class="emphasis"><em>Set-Cookie</em></span>, and caching directives.<a class="indexterm" id="IDX-CHP-4-0116"/></p><p>As an illustration of permissible syntax, consider the following directive that, when appearing in an 8-bit ASCII document, will clarify for the browser that the charset of the document is UTF-8 and not, say, ISO-8859-1:</p><a id="I_programlisting3_d1e6035"/><pre class="programlisting">&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;</pre><p>On the flip side, all of the following directives will fail, because at this point it is too late to switch to an incompatible UTF-32 encoding, change the document type to a video format, or execute a redirect instead of parsing the file:<a class="indexterm" id="IDX-CHP-4-0117"/><a class="indexterm" id="IDX-CHP-4-0118"/><a class="indexterm" id="IDX-CHP-4-0119"/><a class="indexterm" id="IDX-CHP-4-0120"/><a class="indexterm" id="IDX-CHP-4-0121"/><a class="indexterm" id="IDX-CHP-4-0122"/></p><a id="I_programlisting3_d1e6061"/><pre class="programlisting">&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-32"&gt;
&lt;meta http-equiv="Content-Type" content="video/mpeg"&gt;
&lt;meta http-equiv="Location" content="http://www.example.com"&gt;</pre><p>Be mindful that when <span class="emphasis"><em>http-equiv</em></span> values conflict with each other, or contradict the HTTP headers received from the server earlier on, their behavior is not consistent and should not be relied upon. For example, the first supported <span class="emphasis"><em>charset=</em></span> value usually prevails (and HTTP headers have precedence over <span class="emphasis"><em>&lt;meta&gt;</em></span> in this case), but with several conflicting <span class="emphasis"><em>Refresh</em></span> values, the behavior is highly browser-specific.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some browsers will attempt to speculatively extract &lt;meta http-equiv&gt; information before actually parsing the document, which may lead to embarrassing mistakes. For example, a security bug recently fixed in Firefox 4 caused the browser to interpret the following statement as a character set declaration: <span class="emphasis"><em>&lt;meta http-equiv="Refresh" content="10;http://www.example.com/charset=utf-7"&gt;</em></span>.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-4-FT-6">141</a>]</sup></p></div></div>
<div class="sect1" title="Hyperlinking and Content Inclusion"><div class="titlepage"><div><div><h1 class="title"><a id="hyperlinking_and_content_inclusion"/>Hyperlinking and Content Inclusion</h1></div></div></div><p>One of the most important and security-relevant features of HTML is, predictably, the ability to link to and embed external content. HTTP-level features such as <span class="emphasis"><em>Location</em></span> and <span class="emphasis"><em>Refresh</em></span> aside, this can be accomplished in a couple of straightforward ways.</p><div class="sect2" title="Plain Links"><div class="titlepage"><div><div><h2 class="title"><a id="plain_links"/>Plain Links</h2></div></div></div><p>The following markup demonstrates the most familiar and most basic method for referencing external content from within a document:</p><a id="I_programlisting3_d1e6100"/><pre class="programlisting">&lt;a href="http://www.example.com/"&gt;Click me!&lt;/a&gt;</pre><p>This hyperlink may point to any of the browser-recognized schemes, including pseudo-URLs (<span class="emphasis"><em>data:</em></span>, <span class="emphasis"><em>javascript:</em></span>, and so on) and protocols handled by external applications (such as <span class="emphasis"><em>mailto:</em></span>). Clicking on the text (or any HTML elements) nested inside such a <span class="emphasis"><em>&lt;a href=...&gt;</em></span> block will typically prompt the browser to navigate away from the linking document and go to the specified location, if meaningfully possible for the protocol used.</p><p>An optional <span class="emphasis"><em>target</em></span> parameter may be used to target other windows or document views for navigation. The parameter must specify the name of the target view. If the name cannot be found, or if access is denied, the default behavior is typically to open a new window instead. The conditions in which access may be denied are the topic of <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>.</p><p>Four special target names can be used, too (as shown on the left of <a class="xref" href="ch04s05.html#predefined_targets_for_hyperlinks" title="Figure 4-1. Predefined targets for hyperlinks">Figure 4-1</a>): <span class="emphasis"><em>_blank</em></span> always opens a brand-new window, <span class="emphasis"><em>_parent</em></span> navigates a higher-level view that embeds the link-bearing document (if any), and <span class="emphasis"><em>_top</em></span> always navigates the top-level browser window, no matter how many document embedding levels are in between. Oh, right, the fourth special target, <span class="emphasis"><em>_self</em></span>, is identical to not specifying a value at all and exists for no reason whatsoever.<a class="indexterm" id="IDX-CHP-4-0123"/><a class="indexterm" id="IDX-CHP-4-0124"/><a class="indexterm" id="IDX-CHP-4-0125"/><a class="indexterm" id="IDX-CHP-4-0126"/><a class="indexterm" id="IDX-CHP-4-0127"/><a class="indexterm" id="IDX-CHP-4-0128"/><a class="indexterm" id="IDX-CHP-4-0129"/><a class="indexterm" id="IDX-CHP-4-0130"/></p><div class="figure"><a id="predefined_targets_for_hyperlinks"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e6169"/><img alt="Predefined targets for hyperlinks" src="httpatomoreillycomsourcenostarchimages950013.png.jpg"/></div></div><p class="title">Figure 4-1. Predefined targets for hyperlinks</p></div></div><div class="sect2" title="Forms and Form-Triggered Requests"><div class="titlepage"><div><div><h2 class="title"><a id="forms_and_form-triggered_requests"/>Forms and Form-Triggered Requests</h2></div></div></div><p>An HTML form can be thought of as an information-gathering hyperlink: When the “submit” button is clicked, a dynamic request is constructed on the fly from the data collected via any number of input fields. Forms allow user input and files to be uploaded to the server, but in almost every other way, the result of submitting a form is similar to following a normal link.<a class="indexterm" id="IDX-CHP-4-0131"/></p><p>A simple form markup may look like this:</p><a id="I_programlisting3_d1e6184"/><pre class="programlisting">&lt;form method=GET action="/process_form.cgi"&gt;
  Given name: &lt;input type=text name=given&gt;
  Family name: &lt;input type=text name=family&gt;
  ...
  &lt;input type=submit value="Click here when done!"&gt;
&lt;/form&gt;</pre><p>The <span class="emphasis"><em>action</em></span> parameter works like the <span class="emphasis"><em>href</em></span> value used for normal links, with one minor difference: If the value is absent, the form will be submitted to the location of the current document, whereas any destination-free <span class="emphasis"><em>&lt;a&gt;</em></span> links will simply not work at all. An optional <span class="emphasis"><em>target</em></span> parameter may also be specified and will behave as outlined in the previous section.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Unusually, unlike <span class="emphasis"><em>&lt;a&gt;</em></span> tags, forms cannot be nested inside each other, and only the top-level <span class="emphasis"><em>&lt;form&gt;</em></span> tag will remain operational in such a case.</p></div><p>When the <span class="emphasis"><em>method</em></span> value is set to GET or is simply not present at all, all the nested field names and their current values will be escaped using the familiar percent-encoding scheme outlined in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a>, but with two rather arbitrary differences. First, the space character (0x20) will be substituted with the plus sign, rather than encoded as “%20”. Second, following from this, any existing plus signs need to be encoded as “%2B”, or else they will be misinterpreted as spaces.<a class="indexterm" id="IDX-CHP-4-0132"/><a class="indexterm" id="IDX-CHP-4-0133"/><a class="indexterm" id="IDX-CHP-4-0134"/><a class="indexterm" id="IDX-CHP-4-0135"/></p><p>Encoded <span class="emphasis"><em>name=value</em></span> pairs are then delimited with ampersands and combined into a single string, such as this:</p><a id="I_programlisting3_d1e6235"/><pre class="programlisting">given=Erwin+Rudolf+Josef+Alexander&amp;family=Schr%C3%B6dinger</pre><p>The resulting value is inserted into the query part of the destination URL (replacing any existing contents of that section) and submitted to the server. The received response is then shown to the user in the targeted viewport.</p><p>The situation is a bit more complicated if the <span class="emphasis"><em>method</em></span> parameter is set to POST. For that type of HTTP request, three data submission formats are available. In the default mode (referred to as <span class="emphasis"><em>application/x-www-form-urlencoded</em></span>), the message is constructed the same way as for GET but is transmitted in the request payload instead, leaving the query string and all other parts of the destination URL intact.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-3" id="CHP-4-FN-3">27</a>]</sup></p><p>The existence of the second POST submission mode, triggered by specifying <span class="emphasis"><em>enctype="text/plain"</em></span> on the <span class="emphasis"><em>&lt;form&gt;</em></span> tag, is difficult to justify. In this mode, field names and values will not be percent encoded at all (but, depending on the browser, plus signs may be used to substitute for spaces), and a newline delimiter will be used in place of an ampersand. The resulting format is essentially useless, as it can’t be parsed unambiguously: Form-originating newlines and equal signs are indistinguishable from browser inserted ones.</p><p>The last mode is triggered with <span class="emphasis"><em>enctype="multipart/form-data"</em></span> and must be used whenever submitting user-selected files through a form (which is possible with a special <span class="emphasis"><em>&lt;input type="file"&gt;</em></span> tag). The resulting request body consists of a series of short MIME messages corresponding to every submitted field.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-4" id="CHP-4-FN-4">28</a>]</sup> These messages are delimited with a client-selected random, unique boundary token that should otherwise not appear in the encapsulated data:<a class="indexterm" id="IDX-CHP-4-0136"/></p><a id="I_programlisting3_d1e6277"/><pre class="programlisting">POST /process_form.cgi HTTP/1.1
...
Content-Type: multipart/form-data; boundary=random1234

--random1234
Content-Disposition: form-data; name="given"

Erwin Rudolf Josef Alexander
--random1234
Content-Disposition: form-data; name="family"

Schrödinger
--random1234
Content-Disposition: form-data; name="file"; filename="cat_names.txt"
Content-Type: text/plain

(File contents follow)
--random1234--</pre><p>Despite the seemingly open-ended syntax of the tag, other request methods and submission formats are not supported by any browser, and this is unlikely to change. For a short while, the HTML5 standard tried to introduce PUT and DELETE methods in forms, but this proposal was quickly shot down.<a class="indexterm" id="IDX-CHP-4-0137"/><a class="indexterm" id="IDX-CHP-4-0138"/><a class="indexterm" id="IDX-CHP-4-0139"/></p></div><div class="sect2" title="Frames"><div class="titlepage"><div><div><h2 class="title"><a id="frames"/>Frames</h2></div></div></div><p>Frames are a form of markup that allows the contents of one HTML document to be displayed in a rectangular region of another, embedding page. Several framing tags are supported by modern browsers, but the most common way of achieving this goal is with a hassle-free and flexible inline frame:<a class="indexterm" id="IDX-CHP-4-0140"/></p><a id="I_programlisting3_d1e6302"/><pre class="programlisting">&lt;iframe src="http://www.example.com/"&gt;&lt;/iframe&gt;</pre><p>In traditional HTML documents, this tag puts the parser in one of the special parsing modes, and all text between the opening and the closing tag will simply be ignored in frame-aware browsers. In legacy browsers that do not understand <span class="emphasis"><em>&lt;iframe&gt;</em></span>, the markup between the opening and closing tags is processed normally, however, offering a decidedly low-budget, conditional rendering directive. This conditional behavior is commonly used to provide insightful advice such as “This page must be viewed in a browser that supports frames.”</p><p>The frame is a completely separate document view that in many aspects is identical to a new browser window. (It even enjoys its own JavaScript execution context.) Like browser windows, frames can be equipped with a <span class="emphasis"><em>name</em></span> parameter and then targeted from <span class="emphasis"><em>&lt;a&gt;</em></span> and <span class="emphasis"><em>&lt;form&gt;</em></span> tags.</p><p>The constraints on the <span class="emphasis"><em>src</em></span> URL for framed content are roughly similar to the rules enforced on regular links. This includes the ability to point frames to javascript: or to load externally handled protocols that leave the frame empty and open the target application in a new process.</p><p>Frames are of special interest to web security, as they allow almost unconstrained types of content originating from unrelated websites to be combined onto a single page. We will have a second look at the problems associated with this behavior in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>.</p></div><div class="sect2" title="Type-Specific Content Inclusion"><div class="titlepage"><div><div><h2 class="title"><a id="type-specific_content_inclusion"/>Type-Specific Content Inclusion</h2></div></div></div><p>In addition to content-agnostic link navigation and document framing, HTML also provides multiple ways for a more lightweight inclusion of several predefined types of external content.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Images</strong></span></span></dt><dd><p>Image files can be retrieved and displayed on a page using <span class="emphasis"><em>&lt;img&gt;</em></span> tags, via stylesheets, and through a legacy <span class="emphasis"><em>background=</em></span> parameter on markup such as <span class="emphasis"><em>&lt;body&gt;</em></span> or <span class="emphasis"><em>&lt;table&gt;</em></span>.<a class="indexterm" id="IDX-CHP-4-0141"/><a class="indexterm" id="IDX-CHP-4-0142"/><a class="indexterm" id="IDX-CHP-4-0143"/><a class="indexterm" id="IDX-CHP-4-0144"/><a class="indexterm" id="IDX-CHP-4-0145"/><a class="indexterm" id="IDX-CHP-4-0146"/><a class="indexterm" id="IDX-CHP-4-0147"/><a class="indexterm" id="IDX-CHP-4-0148"/><a class="indexterm" id="IDX-CHP-4-0149"/><a class="indexterm" id="IDX-CHP-4-0150"/><a class="indexterm" id="IDX-CHP-4-0151"/><a class="indexterm" id="IDX-CHP-4-0152"/><a class="indexterm" id="IDX-CHP-4-0153"/><a class="indexterm" id="IDX-CHP-4-0154"/><a class="indexterm" id="IDX-CHP-4-0155"/><a class="indexterm" id="IDX-CHP-4-0156"/><a class="indexterm" id="IDX-CHP-4-0157"/><a class="indexterm" id="IDX-CHP-4-0158"/><a class="indexterm" id="IDX-CHP-4-0159"/><a class="indexterm" id="IDX-CHP-4-0160"/><a class="indexterm" id="IDX-CHP-4-0161"/><a class="indexterm" id="IDX-CHP-4-0162"/><a class="indexterm" id="IDX-CHP-4-0163"/><a class="indexterm" id="IDX-CHP-4-0164"/></p><p>The most popular image type on the Internet is a lossy but very efficient JPEG file, followed by lossless and more featured (but slower) PNG. An increasingly obsolete lossless GIF format is also supported by every browser, and so is the rarely encountered and usually uncompressed Windows bitmap file (BMP). An increasing number of rendering engines support SVG, an XML-based vector graphics and animation format, too, but the inclusion of such images through the <span class="emphasis"><em>&lt;img&gt;</em></span> tag is subject to additional restrictions.</p><p>The list of recognized image types can be wrapped up with odds and ends such as Windows metafiles (WMF and EMF), Windows Media Photo (WDP and HDP), Windows icons (ICO), animated PNG (APNG), TIFF images, and—more recently—WebP. Browser support for these is far from universal, however.</p></dd><dt><span class="term"><span class="strong"><strong>Cascading stylesheets</strong></span></span></dt><dd><p>These text-based files can be loaded with a <span class="emphasis"><em>&lt;link rel=stylesheet href=...&gt;</em></span> tag—even though <span class="emphasis"><em>&lt;style src=...&gt;</em></span> would be a more intuitive choice—and may redefine the visual aspects of almost any other HTML tag within their parent document (and in some cases, even include embedded JavaScript). The syntax and function of CSS are the subject of <a class="xref" href="ch05.html" title="Chapter 5. Cascading Style Sheets">Chapter 5</a>.<a class="indexterm" id="IDX-CHP-4-0165"/></p><p>In the absence of the appropriate <span class="emphasis"><em>charset</em></span> value in the <span class="emphasis"><em>Content-Type</em></span> header for the downloaded stylesheet, the encoding according to which this subresource will be interpreted can be specified by the including party through the <span class="emphasis"><em>charset</em></span> parameter of the <span class="emphasis"><em>&lt;link&gt;</em></span> tag.<a class="indexterm" id="IDX-CHP-4-0166"/></p></dd><dt><span class="term"><span class="strong"><strong>Scripts</strong></span></span></dt><dd><p>Scripts are text-based programs included with <span class="emphasis"><em>&lt;script&gt;</em></span> tags and are executed in a manner that gives them full control over the host document. The primary scripting language for the Web is JavaScript, although an embedded version of Visual Basic is also supported in Internet Explorer and can be used at will. <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a> takes an in-depth look at client-side scripts and their capabilities.<a class="indexterm" id="IDX-CHP-4-0167"/></p><p>As with CSS, in the absence of valid <span class="emphasis"><em>Content-Type</em></span> data, the charset according to which the script is interpreted may be controlled by the including party.</p></dd><dt><span class="term"><span class="strong"><strong>Plug-in content</strong></span></span></dt><dd><p>This category spans miscellaneous binary files included with <span class="emphasis"><em>&lt;embed&gt;</em></span> or <span class="emphasis"><em>&lt;object&gt;</em></span> tags or via an obsolete, Java-specific <span class="emphasis"><em>&lt;applet&gt;</em></span> tag. Browser plug-in content follows its own security rules, which are explored to some extent in <a class="xref" href="ch08.html" title="Chapter 8. Content Rendering with Browser Plug-ins">Chapter 8</a> and <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. In many cases, it is safe to consider plug-in-supported content as equivalent to or more powerful than JavaScript.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The standard permits certain types of browser-supported documents, such as <span class="emphasis"><em>text/html</em></span> or <span class="emphasis"><em>text/plain</em></span>, to be loaded through <span class="emphasis"><em>&lt;object&gt;</em></span> tags, in which case they form a close equivalent of <span class="emphasis"><em>&lt;iframe&gt;</em></span>. This functionality is not used in practice, and the rationale behind it is difficult to grasp.<a class="indexterm" id="IDX-CHP-4-0168"/><a class="indexterm" id="IDX-CHP-4-0169"/><a class="indexterm" id="IDX-CHP-4-0170"/><a class="indexterm" id="IDX-CHP-4-0171"/><a class="indexterm" id="IDX-CHP-4-0172"/><a class="indexterm" id="IDX-CHP-4-0173"/><a class="indexterm" id="IDX-CHP-4-0174"/><a class="indexterm" id="IDX-CHP-4-0175"/><a class="indexterm" id="IDX-CHP-4-0176"/></p></div></dd><dt><span class="term"><span class="strong"><strong>Other supplementary content</strong></span></span></dt><dd><p>This category includes various rendering cues that may or may not be honored by the browser; they are most commonly provided through <span class="emphasis"><em>&lt;link&gt;</em></span> directives. Examples include website icons (known as “favicons”), alternative versions of a page, and chapter navigation links.</p></dd></dl></div><p>Several other once-supported content inclusion methods, such as the <span class="emphasis"><em>&lt;bgsound&gt;</em></span> tag for background music, were commonplace in the past but have fallen out of grace. On the other hand, as a part of HTML5, new tags such as <span class="emphasis"><em>&lt;video&gt;</em></span> and <span class="emphasis"><em>&lt;audio&gt;</em></span> are expected to gain popularity soon.</p><p>There is relatively little consistency in what URL schemes are accepted for type-specific content retrieval. It should be expected that protocols routed to external applications will be rejected, as they do not have a sensible meaning in this context, but beyond this, not many assumptions should be made. As a security precaution, most browsers will also reject scripting-related schemes when loading images and stylesheets, although Internet Explorer 6 and Opera do not follow this practice. As of this writing, <span class="emphasis"><em>javascript:</em></span> URLs are also permitted on <span class="emphasis"><em>&lt;embed&gt;</em></span> and <span class="emphasis"><em>&lt;applet&gt;</em></span> tags in Firefox but not, for example, on <span class="emphasis"><em>&lt;img&gt;</em></span>.</p><p>For almost all of the type-specific content inclusion methods, <span class="emphasis"><em>Content-Type</em></span> and <span class="emphasis"><em>Content-Disposition</em></span> headers provided by the server will typically be ignored (perhaps except for the <span class="emphasis"><em>charset=</em></span> value), as may be the HTTP response code itself. It is best to assume that whenever the body of any server-provided resource is even vaguely recognizable as one of the data formats enumerated in this section, it may be interpreted as such.</p></div><div class="sect2" title="A Note on Cross-Site Request Forgery"><div class="titlepage"><div><div><h2 class="title"><a id="a_note_on_cross-site_request_forgery"/>A Note on Cross-Site Request Forgery</h2></div></div></div><p>On all types of cross-domain navigation, the browser will transparently include any ambient credentials; consequently, to the server, a request legitimately originating from its own client-side code will appear roughly the same as a request originating from a rogue third-party site, and it may be granted the same privileges.</p><p>Applications that fail to account for this possibility when processing any sensitive, state-changing requests are said to be vulnerable to <span class="emphasis"><em>cross-site request forgery</em></span> (<span class="emphasis"><em>XSRF</em></span> or <span class="emphasis"><em>CSRF</em></span>). This vulnerability can be mitigated in a number of ways, the most common of which is to include a secret user- and session-specific value on such requests (as an additional query parameter or a hidden form field). The attacker will not be able to obtain this value, as read access to cross-domain documents is restricted by the same-origin policy (see <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>).</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id2"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">Good Engineering Hygiene for All HTML Documents</span><a class="indexterm" id="IDX-CHP-4-0177"/><a class="indexterm" id="IDX-CHP-4-0178"/><a class="indexterm" id="IDX-CHP-4-0179"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Always output consistent, valid, and browser-supported <span class="emphasis"><em>Content-Type</em></span> and <span class="emphasis"><em>charset</em></span> information to prevent the document from being interpreted contrary to your original intent.</p></li></ul></div><p><span class="bolditalic">When Generating HTML Documents with Attacker-Controlled Bits</span><a class="indexterm" id="IDX-CHP-4-0180"/></p><p>This task is difficult to perform consistently across the entire web application, and it is one of the most significant sources of web application security flaws. Consider using context-sensitive auto-escaping frameworks, such as <span class="emphasis"><em>JSilver</em></span> or <span class="emphasis"><em>CTemplate</em></span>, to automate it. If that is not possible, read on.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>User-supplied content in text body:</strong></span> Always entity-encode “&lt;”, “&gt;”, and “&amp;”. Note that certain other patterns may be dangerous in certain non-ASCII-compatible output encodings. If applicable, consult <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a>.</p><p>Keep in mind that some Unicode metacharacters (e.g., U+202E) alter the direction or flow of the subsequent text. It may be desirable to remove them in particularly sensitive uses.</p></li><li class="listitem"><p><span class="strong"><strong>Tag-specific</strong></span> <span class="bolditalic">style</span> <span class="strong"><strong>and</strong></span> <span class="bolditalic">on*</span> <span class="strong"><strong>parameters:</strong></span> Multiple levels of escaping are required. This practice is extremely error prone, meaning not really something to attempt. If it is absolutely unavoidable, review the cheat sheets in <a class="xref" href="ch05.html" title="Chapter 5. Cascading Style Sheets">Chapter 5</a> and <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>.</p></li><li class="listitem"><p><span class="strong"><strong>All other HTML parameter values:</strong></span> Always use quotes around attacker-controlled input. Entity-encode “&lt;”, “&gt;”, “&amp;”, and any stray quotes. Remember that some parameters require additional validation. For URLs, see the cheat sheet in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a>.</p><p>Never attempt to blacklist known bad values in URLs or any other parameters; doing so will backfire and may lead to script execution flaws.</p></li><li class="listitem"><p><span class="strong"><strong>Special parsing modes (e.g.</strong></span>, <span class="bolditalic">&lt;script&gt;</span> <span class="strong"><strong>and</strong></span> <span class="bolditalic">&lt;style&gt;</span> <span class="strong"><strong>blocks):</strong></span> For values appearing inside quoted strings, replace quote characters, backslash, “&lt;”, “&gt;”, and all nonprintable characters with language-appropriate escape codes. For values appearing outside strings, exercise extreme caution and allow only carefully validated, known, alphanumeric values.</p><p>In XHTML mode, remember to wrap the entire script section in a CDATA block. Avoid cases that require multiple levels of encoding, such as building parameters to the JavaScript <span class="emphasis"><em>eval(...)</em></span> function using attacker-supplied strings. Never place user-controlled data inside HTML comments, !-type or ?-type tags, and other nonessential or unusually parsed blocks.</p></li></ul></div><p><span class="bolditalic">When Converting HTML to Plaintext</span><a class="indexterm" id="IDX-CHP-4-0181"/><a class="indexterm" id="IDX-CHP-4-0182"/><a class="indexterm" id="IDX-CHP-4-0183"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A common mistake is to strip only well-formed tags. Remember that all left-angle brackets must be removed, even if no matching right-angle bracket is found. To minimize the risk of errors, always entity-escape angle brackets and ampersands in the generated output, too.</p></li></ul></div><p><span class="bolditalic">When Writing a Markup Filter for User Content</span><a class="indexterm" id="IDX-CHP-4-0184"/><a class="indexterm" id="IDX-CHP-4-0185"/><a class="indexterm" id="IDX-CHP-4-0186"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Read this chapter carefully. Use a reasonably robust HTML parser to build an in-memory document tree. Walk the tree, removing any unrecognized or unnecessary tags and parameters and scrubbing any undesirable tags/parameters/value combinations.</p><p>When done, reserialize the document, making sure to apply proper escaping rules to parameter values and text content. (See the first tip on this cheat sheet.) Be aware of the impact of special parsing modes.</p></li><li class="listitem"><p>Because of the somewhat counterintuitive namespace interactions with JavaScript, do not allow <span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>id</em></span> parameters on user-supplied markup—at least not without reading <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a> first.</p></li><li class="listitem"><p>Do not attempt to sanitize an existing, serialized document in place. Doing so inevitably leads to security problems.</p></li></ul></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-3" id="ftn.CHP-4-FN-3">27</a>] </sup>This has the potential for confusion, as the same parameter may appear both in the query string and in the POST payload. There is no consistency in how various server-side web applications frameworks resolve this conflict.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-4" id="ftn.CHP-4-FN-4">28</a>] </sup>MIME (Multipurpose Internet Mail Extensions) is a data format intended for encapsulating and safely transmitting various types of documents in email messages. The format makes several unexpected appearances in the browser world. For example, <span class="emphasis"><em>Content-Type</em></span> file format identifiers also have unambiguous MIME roots.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;Cascading Style Sheets"><div class="titlepage"><div><div><h1 class="title"><a id="cascading_style_sheets"/>Chapter 5. Cascading Style Sheets</h1></div></div></div><p>As the Web matured through the 1990s, website developers increasingly needed a consistent and flexible way to control the appearance of HTML documents; the collection of random, vendor-specific tag parameters available at the time simply would not do. After reviewing several competing proposals, W3C eventually settled on <span class="emphasis"><em>Cascading Style Sheets (CSS)</em></span>, a fairly simple text-based page appearance description language proposed by Håkon Wium Lie.<a class="indexterm" id="IDX-CHP-5-0001"/><a class="indexterm" id="IDX-CHP-5-0002"/></p><p>The initial CSS level 1 specification saw the light of day by the end of 1996,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-5-FT-1">142</a>]</sup> but further revisions of this document continued until 2008. The initial draft of CSS level 2 followed in December 1998 and has yet to be finalized as of 2011. The work on the most recent iteration, level 3, started in 2005 and also continues to this day. Although most of the individual features envisioned for CSS2 and CSS3 have been adopted by all modern browsers after years of trial and error, many subtle details vary significantly from one implementation to another, and the absence of a finalized standard likely contributes to this.</p><p>Despite the differences from one browser to another, CSS is a very powerful tool. With only a couple of constraints, stylesheets permit almost every HTML tag to be scaled, positioned, and decorated nearly arbitrarily, thereby overcoming the constraints originally placed on it by the underlying markup language; in some implementations, JavaScript programs can be embedded in the CSS presentation directives as well. The job of placing user-controlled values inside stylesheets, or recoding any externally provided CSS, is therefore of great interest to web application security.<a class="indexterm" id="IDX-CHP-5-0003"/><a class="indexterm" id="IDX-CHP-5-0004"/><a class="indexterm" id="IDX-CHP-5-0005"/><a class="indexterm" id="IDX-CHP-5-0006"/><a class="indexterm" id="IDX-CHP-5-0007"/><a class="indexterm" id="IDX-CHP-5-0008"/></p><div class="sect1" title="Basic CSS Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="basic_css_syntax"/>Basic CSS Syntax</h1></div></div></div><p>Stylesheets can be placed in an HTML document in three ways: inlined globally for the entire document with a <span class="emphasis"><em>&lt;style&gt;</em></span> block, retrieved from an external URL via the <span class="emphasis"><em>&lt;link rel=stylesheet&gt;</em></span> directive, or attached to a specific tag using the <span class="emphasis"><em>style</em></span> parameter. In addition, XML-based documents (including XHTML) may also leverage a little-known <span class="emphasis"><em>&lt;?xml-stylesheet href=... ?&gt;</em></span> directive to achieve the same goal.</p><p>The first two methods of inclusion require a fully qualified stylesheet consisting of any number of selectors (directives describing which HTML tags the following ruleset will apply to) followed by semicolon-delimited <span class="emphasis"><em>name: value</em></span> rules between curly brackets. Here is a simple example of such syntax, defining the appearance of <span class="emphasis"><em>&lt;img&gt;</em></span>, <span class="emphasis"><em>&lt;span&gt;</em></span>, and <span class="emphasis"><em>&lt;div&gt;</em></span> tags:</p><a id="I_programlisting4_d1e6858"/><pre class="programlisting">img {
  border-size: 1px;
  border-style: solid;
}

span, div {
  color: red;
}</pre><p>Selectors can reference a particular type of a tag (such as <span class="emphasis"><em>img</em></span>), a period-prefixed name of a class of tags (for example, <span class="emphasis"><em>.photos</em></span>, which will apply to all tags with an inline <span class="emphasis"><em>class=photos</em></span> parameter), or a combination of both (<span class="emphasis"><em>img.company_logo</em></span>). Selector suffixes such as <span class="emphasis"><em>:hover</em></span> or <span class="emphasis"><em>:visited</em></span> may also be used to make the selector match only under certain circumstances, such as when the mouse hovers over the content or when a particular displayed hyperlink has already been visited before.</p><p>So-called <span class="emphasis"><em>complex selectors</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-5-FT-2">143</a>]</sup> are an interesting feature introduced in CSS2 and extended in CSS3. They allow any given ruleset to apply only to tags with particular strings appearing in parameter values or that are positioned in a particular relation to other markup. One example of such a selector is this:</p><a id="I_programlisting4_d1e6887"/><pre class="programlisting">a[href^="ftp:"] {
  /* Styling applicable only to FTP links. */
}</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Oh, while we are at it: As evident in this example, C-style <em class="replaceable"><code>/*...*/</code></em> comment blocks are permitted in CSS syntax anywhere outside a quoted string. On the flip side, <em class="replaceable"><code>//</code></em>-style comments are not recognized at all.<a class="indexterm" id="IDX-CHP-5-0009"/><a class="indexterm" id="IDX-CHP-5-0010"/><a class="indexterm" id="IDX-CHP-5-0011"/><a class="indexterm" id="IDX-CHP-5-0012"/><a class="indexterm" id="IDX-CHP-5-0013"/><a class="indexterm" id="IDX-CHP-5-0014"/><a class="indexterm" id="IDX-CHP-5-0015"/><a class="indexterm" id="IDX-CHP-5-0016"/><a class="indexterm" id="IDX-CHP-5-0017"/><a class="indexterm" id="IDX-CHP-5-0018"/><a class="indexterm" id="IDX-CHP-5-0019"/><a class="indexterm" id="IDX-CHP-5-0020"/><a class="indexterm" id="IDX-CHP-5-0021"/><a class="indexterm" id="IDX-CHP-5-0022"/><a class="indexterm" id="IDX-CHP-5-0023"/><a class="indexterm" id="IDX-CHP-5-0024"/><a class="indexterm" id="IDX-CHP-5-0025"/><a class="indexterm" id="IDX-CHP-5-0026"/><a class="indexterm" id="IDX-CHP-5-0027"/></p></div><div class="sect2" title="Property Definitions"><div class="titlepage"><div><div><h2 class="title"><a id="property_definitions"/>Property Definitions</h2></div></div></div><p>Inside the <span class="emphasis"><em>{ ... }</em></span> block that follows a selector, as well as inside the <span class="emphasis"><em>style</em></span> parameter attached to a specific tag, any number of <span class="emphasis"><em>name: value</em></span> rules can be used to redefine almost every aspect of how the affected markup is displayed. Visibility, shape, color, screen position, rendering order, local or remote typeface, and even any additional text (<span class="emphasis"><em>content</em></span> property supported on certain pseudo-classes) and mouse cursor shape are all up for grabs.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-1" id="CHP-5-FN-1">29</a>]</sup> Simple types of automation, such as counters for numbered lists, are available through CSS rules as well.</p><p>Property values can be formatted as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Raw text</strong></span> This method is used chiefly to specify numerical values (with optional units), RGB vectors and named colors, and other predefined keywords (“absolute,” “left,” “center,” etc.).</p></li><li class="listitem"><p><span class="strong"><strong>Quoted strings</strong></span> Single or double quotes should be placed around any nonkeyword values, but there is little consistency in how this rule is enforced. For example, quoting is not required around typeface names or certain uses of URLs, but it is necessary for the aforementioned <span class="emphasis"><em>content</em></span> property.</p></li><li class="listitem"><p><span class="strong"><strong>Functional notation</strong></span> Two parameter-related pseudo-functions are mentioned in the original CSS specification: <span class="emphasis"><em>rgb(...)</em></span>, for converting individual RGB color values into a single color code, and <span class="emphasis"><em>url(...)</em></span>, required for URLs in most but not all contexts. On top of this, several more pseudo-functions have been rolled out in recent years, including <span class="emphasis"><em>scale(...)</em></span>, <span class="emphasis"><em>rotate(...)</em></span>, or <span class="emphasis"><em>skew(...)</em></span>.</p><p>A proprietary <span class="emphasis"><em>expression(...)</em></span> function is also available in Internet Explorer; it permits JavaScript statements to be inserted within CSS. This function is one of the most important reasons why attacker-controlled stylesheets can be a grave security risk.</p></li></ul></div></div><div class="sect2" title="@ Directives and XBL Bindings"><div class="titlepage"><div><div><h2 class="title"><a id="at_the_rate_directives_and_xbl_bindings"/>@ Directives and XBL Bindings</h2></div></div></div><p>In addition to selectors and properties, several @-prefixed directives are recognized in stand-alone stylesheets. All of them modify the meaning of the stylesheet; for example, by specifying the namespace or the display media that the stylesheet should be applied to. But two special directives also affect the behavior of the parsing process. The first of these is <span class="emphasis"><em>@charset</em></span>, which sets the charset of the current CSS block; the other is <span class="emphasis"><em>@import</em></span>, which inserts an external file into the stylesheet.</p><p>The <span class="emphasis"><em>@import</em></span> directive itself serves as a good example of the idiosyncrasies of CSS parsing; the parser views all of the following examples as equivalent:<a class="indexterm" id="IDX-CHP-5-0028"/><a class="indexterm" id="IDX-CHP-5-0029"/><a class="indexterm" id="IDX-CHP-5-0030"/><a class="indexterm" id="IDX-CHP-5-0031"/><a class="indexterm" id="IDX-CHP-5-0032"/></p><a id="I_programlisting4_d1e7064"/><pre class="programlisting">@import "foo.css";
@import url('foo.css');
@import'foo.css';</pre><p>In Firefox, external content directives, including JavaScript code, may be also loaded from an external source using the <span class="emphasis"><em>-moz-binding</em></span> property, a vendor-specific way to weave XML Binding Language<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-5-FT-3">144</a>]</sup> files (an obscure method of providing automation to XML content) into the document. There is some talk of supporting XBL in other browsers, too, at which point the name of the property would change and the XSS risk may or may not be addressed in some way.<a class="indexterm" id="IDX-CHP-5-0033"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>As can be expected, the handling of pseudo-URLs in <span class="emphasis"><em>@import, url(...)</em></span> and other CSS-based content inclusion schemes is a potential security risk. While most current browsers do not accept scripting-related schemes in these contexts, Internet Explorer 6 allows them without reservations, thereby creating a code injection vector if the URL is not validated carefully enough.</p></div></div><div class="sect2" title="Interactions with HTML"><div class="titlepage"><div><div><h2 class="title"><a id="interactions_with_html"/>Interactions with HTML</h2></div></div></div><p>It follows from the discussion in the previous chapter that for any stylesheets inlined in HTML documents, HTML parsing is performed first and is completely independent of CSS syntax rules. Therefore, it is unsafe to place certain HTML syntax characters inside CSS properties, as in the following example, even when quoted properly. A common mistake is permitting this:</p><a id="I_programlisting4_d1e7089"/><pre class="programlisting">&lt;style&gt;
some_descriptor {
  background: url('http://www.example.com/<strong class="userinput"><code>&lt;/style&gt;&lt;h1&gt;Gotcha!'</code></strong>);
}
&lt;/style&gt;</pre><p>We’ll discuss a way to encode problematic characters in stylesheets shortly, but first, let’s have a quick look at another very distinctive property of CSS.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-1" id="ftn.CHP-5-FN-1">29</a>] </sup>The ability to redefine mouse cursors using an arbitrary bitmap has predictably resulted in some security bugs. An oversized cursor combined with script-based mouse position tracking could be used to obscure or replace important elements of the browser UI and trick the user into doing something dangerous.</p></div></div></div>
<div class="sect1" title="Parser Resynchronization Risks"><div class="titlepage"><div><div><h1 class="title"><a id="parser_resynchronization_risks"/>Parser Resynchronization Risks</h1></div></div></div><p>An undoubtedly HTML-inspired behavior that sets CSS apart from most other languages is that compliant parsers are expected to continue after encountering a syntax error and restart at the next matching curly bracket (some superficial nesting-level tracking is mandated by the spec). In particular, the following stylesheet snippet, despite being obviously malformed, will still apply the specified border style to all <span class="emphasis"><em>&lt;img&gt;</em></span> tags:</p><a id="I_programlisting4_d1e7104"/><pre class="programlisting">a {
  $$$ This syntax makes absolutely no sense $$$
  !(@*#)!!@ 123
}

img {
  border: 1px solid red;
}</pre><p>This unusual behavior creates an opportunity to exploit parser incompatibilities in an interesting way: If there is any way to derail a particular CSS implementation with inputs that seem valid to other parsers, the resynchronization logic may cause the attacked browser to resume parsing at an incorrect location, such as in the middle of an attacker-supplied string.<a class="indexterm" id="IDX-CHP-5-0034"/><a class="indexterm" id="IDX-CHP-5-0035"/><a class="indexterm" id="IDX-CHP-5-0036"/><a class="indexterm" id="IDX-CHP-5-0037"/><a class="indexterm" id="IDX-CHP-5-0038"/></p><p>A naïve illustration of this issue may be Internet Explorer’s support for multiline string literals. In this browser, it is seemingly safe not to scrub CR and LF characters in user-supplied CSS strings, so some webmasters may allow it. Unfortunately, the same pattern will cause any other browser to resume at an unexpected offset and interpret the <span class="emphasis"><em>evil_rule</em></span> ruleset:</p><a id="I_programlisting4_d1e7136"/><pre class="programlisting">some_benign_selector {
  content: <strong class="userinput"><code>'Attacker-controlled text...</code></strong>
            <strong class="userinput"><code>} evil_rule { margin-left: −1000px; }';</code></strong>
}</pre><p>The support for multiline strings is a Microsoft-specific extension, and the aforementioned problem is easily fixed by avoiding such noncompliant syntax to begin with. Unfortunately, other desynchronization risks are introduced by the standard itself. For example, recall complex selectors: This CSS3 syntax makes no sense to pre-CSS3 parsers. In the following example, an older implementation may bail out after encountering an unexpected angle bracket and resume parsing from the attacker-supplied <span class="emphasis"><em>evil_rule</em></span> instead:</p><a id="I_programlisting4_d1e7149"/><pre class="programlisting">a[href^=<strong class="userinput"><code>'} evil_rule { margin-left: −1000px; }'</code></strong>] {
  /* Harmless, validated rules here. */
}</pre><p>The still-popular browser Internet Explorer 6 would be vulnerable to this trick.</p></div>
<div class="sect1" title="Character Encoding"><div class="titlepage"><div><div><h1 class="title"><a id="character_encoding"/>Character Encoding</h1></div></div></div><p>To make it possible to quote reserved or otherwise problematic characters inside strings, CSS offers an unorthodox escaping scheme: a backslash (\) followed by one to six hexadecimal digits. For example, according to this scheme, the letter <span class="emphasis"><em>e</em></span> may be encoded as “\65”, “\065”, or “\000065”. Alas, only the last syntax, “\000065”, will be unambiguous if the next character happens to be a valid hexadecimal digit; encoding “teak” as “t\65ak” would not work as expected, because the escape sequence would be interpreted as “\65A”, an Arabic sign in the Unicode character map.<a class="indexterm" id="IDX-CHP-5-0039"/></p><p>To avoid this problem, the specification embraces an awkward compromise: A whitespace can follow an escape sequence and will be interpreted as a terminator, and then removed from the string (e.g., “t\65 ak”). Regrettably, more familiar and predictable fixed-length C-style escape sequences such as <span class="emphasis"><em>\ x65</em></span> cannot be used instead.<a class="indexterm" id="IDX-CHP-5-0040"/></p><p>In addition to the numerical escaping scheme, it is also possible to place a backslash in front of a character that is not a valid hexadecimal digit. In this case, the subsequent character will be treated as a literal. This mechanism is useful for encoding quote characters and the backslash itself, but it should not be used to escape HTML control characters such as angle brackets. The aforementioned precedence of HTML parsing over CSS parsing renders this approach inadequate.</p><p>In a bizarre twist, due to somewhat ambiguous guidance in the W3C drafts, many CSS parsers recognize arbitrary escape sequences in locations other than quote-enclosed strings. To add insult to injury, in Internet Explorer, the substitution of these sequences apparently takes place before the pseudo-function syntax is parsed, effectively making the following two examples equivalent:</p><a id="I_programlisting4_d1e7179"/><pre class="programlisting">color: expression(alert(1))</pre><a id="I_programlisting4_d1e7181"/><pre class="programlisting">color: expression\028 alert \028 1 \029 \029</pre><p>Even more confusingly, in a misguided bid to maintain fault tolerance, Microsoft’s implementation does not recognize backslash escape codes inside <span class="emphasis"><em>url(...)</em></span> values; this is, once more, to avoid hurting the feelings of users who type the wrong type of a slash when specifying a URL.</p><p>These and similar quirks make the detection of known dangerous CSS syntax extremely error prone.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id3"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Loading Remote Stylesheets</span><a class="indexterm" id="IDX-CHP-5-0041"/><a class="indexterm" id="IDX-CHP-5-0042"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You are linking the security of your site to the originating domain of the stylesheet. Even in browsers that do not support JavaScript expressions inside stylesheets, features such as conditional selectors and <span class="emphasis"><em>url(...)</em></span> references can be used to exfiltrate portions of your site.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-5-FT-4">145</a>]</sup></p></li><li class="listitem"><p>When in doubt, make a local copy of the data instead.</p></li><li class="listitem"><p>On HTTPS sites, require stylesheets to be served over HTTPS as well.</p></li></ul></div><p><span class="bolditalic">When Putting Attacker-Controlled Values into CSS</span><a class="indexterm" id="IDX-CHP-5-0043"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Strings and URLs inside stand-alone blocks</strong></span>. Always use quotes. Backslash-escape all control characters (0x00-0x1F), “\”, “&lt;”, “&gt;”, “{“, “}”, and quotes using numerical codes. It is also preferable to escape high-bit characters. For URLs, consult the cheat sheet in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a> to avoid code injection vulnerabilities.</p></li><li class="listitem"><p><span class="strong"><strong>Strings in</strong></span> <span class="bolditalic">style</span> <span class="strong"><strong>parameters</strong></span>. Multiple levels of escaping are involved. The process is error prone, so do not attempt it unless absolutely necessary. If it is unavoidable, apply the above CSS escaping rules first and then apply HTML parameter encoding to the resulting string.</p></li><li class="listitem"><p><span class="strong"><strong>Nonstring attributes</strong></span>. Allow only whitelisted alphanumeric keywords and carefully validated numerical values. Do not attempt to reject known bad patterns instead.</p></li></ul></div><p><span class="bolditalic">When Filtering User-Supplied CSS</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Remove all content outside of functional rulesets. Do not preserve or generate user-controlled comment blocks, @-directives, and so on.</p></li><li class="listitem"><p>Carefully validate selector syntax, permitting only alphanumerics; underscores; whitespaces; and correctly positioned colons, periods, and commas before “{”. Do not permit complex text-matching selectors; they are unsafe.</p></li><li class="listitem"><p>Parse and validate every rule in the { ... } block. Permit only whitelisted properties with well-understood consequences and confirm that they take expected, known safe values. Note that strings passed to certain properties may sometimes be interpreted as URLs even in the absence of a <span class="emphasis"><em>url(...)</em></span> wrapper.</p></li><li class="listitem"><p>Encode every parameter value using the rules outlined earlier in this section. Bail out on any syntax abnormalities.</p></li><li class="listitem"><p>Keep in mind that unless specifically prevented from doing so, CSS may position user content outside the intended drawing area or redefine the appearance of any part of the UI of your application. The safest way to avoid this problem is to display the untrusted content inside a separate frame.</p></li></ul></div><p><span class="bolditalic">When Allowing User-Specified Class Values on HTML Markup</span><a class="indexterm" id="IDX-CHP-5-0044"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ensure that user-supplied content can’t reuse class names that are used for any part of the application UI. If a separate frame is not being used, it’s advisable to maintain separate namespace prefixes.</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Browser-Side Scripts"><div class="titlepage"><div><div><h1 class="title"><a id="browser-side_scripts"/>Chapter 6. Browser-Side Scripts</h1></div></div></div><p>The first browser scripting engine debuted in Netscape Navigator around 1995, thanks to the work of Brendan Eich. The integrated Mocha language, as it was originally called, gave web developers the ability to manipulate HTML documents, display simple, system-level dialogs, open and reposition browser windows, and use other basic types of client-side automation in a hassle-free way.<a class="indexterm" id="IDX-CHP-6-0001"/><a class="indexterm" id="IDX-CHP-6-0002"/><a class="indexterm" id="IDX-CHP-6-0003"/><a class="indexterm" id="IDX-CHP-6-0004"/><a class="indexterm" id="IDX-CHP-6-0005"/><a class="indexterm" id="IDX-CHP-6-0006"/><a class="indexterm" id="IDX-CHP-6-0007"/><a class="indexterm" id="IDX-CHP-6-0008"/></p><p>While iterating through beta releases, Netscape eventually renamed Mocha LiveScript, and after an awkward branding deal was struck with Sun Microsystems, JavaScript was chosen as the final name. The similarities between Brendan’s Mocha and Sun’s Java were few, but the Netscape Corporation bet that this odd marketing-driven marriage would secure JavaScript’s dominance in the more lucrative server world. It made this sentiment clear in a famously confusing 1995 press release that introduced the language to the world and immediately tried to tie it to an impressive range of random commercial products:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-1">146</a>]</sup><a class="indexterm" id="IDX-CHP-6-0009"/></p><div class="blockquote"><blockquote class="blockquote"><p><span class="strong"><strong>Netscape and Sun Announce JavaScript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet</strong></span></p><p>[ . . . ]</p><p>Netscape Navigator Gold 2.0 enables developers to create and edit JavaScript scripts, while Netscape LiveWire enables JavaScript programs to be installed, run and managed on Netscape servers, both within the enterprise and across the Internet. Netscape LiveWire Pro adds support for JavaScript connectivity to high-performance relational databases from Illustra, Informix, Microsoft, Oracle and Sybase. Java and JavaScript support are being built into all Netscape products to provide a unified, front-to-back, client/server/tool environment for building and deploying live online applications.</p></blockquote></div><p>Despite Netscape’s misplaced affection for Java, the value of JavaScript for client-side programming seemed clear, including to the competition. In 1996 Microsoft responded by shipping a near-verbatim copy of JavaScript in Internet Explorer 3.0 along with a counterproposal of its own: a Visual Basic-derived language dubbed VBScript. Perhaps because it was late to the party, and perhaps because of VBScript’s clunkier syntax, Microsoft’s alternative failed to gain prominence or even any cross-browser support. In the end, JavaScript secured its position in the market, and in part due to Microsoft’s failure, no new scripting languages have been attempted in mainstream browsers since.<a class="indexterm" id="IDX-CHP-6-0010"/><a class="indexterm" id="IDX-CHP-6-0011"/><a class="indexterm" id="IDX-CHP-6-0012"/></p><p>Encouraged by the popularity of the JavaScript language, Netscape handed over some of the responsibility for maintaining it to an independent body, the European Computer Manufacturers Association (ECMA). The new overseers successfully released ECMAScript, 3rd edition in 1999<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-2">147</a>]</sup> but had substantially more difficulty moving forward from there. The 4th edition, an ambitious overhaul of the language, was eventually abandoned after several years of bickering between the vendors, and a scaled-down 5th edition,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-3">148</a>]</sup> published in 2009, still enjoys only limited (albeit steadily improving) browser support. The work on a new iteration, called “Harmony,” begun in 2008, still has not been finalized. Absent an evolving and widely embraced standard, vendor-specific extensions of the language are common, but they usually cause only pain.<a class="indexterm" id="IDX-CHP-6-0013"/><a class="indexterm" id="IDX-CHP-6-0014"/></p><div class="sect1" title="Basic Characteristics of JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="basic_characteristics_of_javascript"/>Basic Characteristics of JavaScript</h1></div></div></div><p>JavaScript is a fairly simple language meant to be interpreted at runtime. It has vaguely C-influenced syntax (save for pointer arithmetic); a straightforward classless object model, said to be inspired by a little-known programming language named Self; automatic garbage collection; and weak, dynamic typing.</p><p>JavaScript as such has no built-in I/O mechanisms. In the browser, limited abilities to interact with the host environment are offered through a set of predefined methods and properties that map to native code inside the browser, but unlike what can be seen in many other programming languages, these interfaces are fairly limited and purpose built.<a class="indexterm" id="IDX-CHP-6-0015"/><a class="indexterm" id="IDX-CHP-6-0016"/><a class="indexterm" id="IDX-CHP-6-0017"/></p><p>Most of the core features of JavaScript are fairly unremarkable and should be familiar to developers already experience with C, C++, or, to a lesser extent, Java. A simple JavaScript program might look like this:<a class="indexterm" id="IDX-CHP-6-0018"/></p><a id="I_programlisting5_d1e7387"/><pre class="programlisting">var text = "Hi mom!";

function display_string(str) {
  alert(str);
  return 0;
}

// This will display "Hi mom!".
display_str(text);</pre><p>Because it is beyond the scope of this book to provide a more detailed overview of the semantics of JavaScript, we’ll summarize only some of its more unique and security-relevant properties later in this chapter. For readers looking for a more systematic introduction to the language, Marijn Haverbeke’s <span class="emphasis"><em>Eloquent JavaScript</em></span> (No Starch Press, 2011) is a good choice.</p><div class="sect2" title="Script Processing Model"><div class="titlepage"><div><div><h2 class="title"><a id="script_processing_model"/>Script Processing Model</h2></div></div></div><p>Every HTML document displayed in a browser—be it in a separate window or in a frame—is given a separate instance of the JavaScript execution environment, complete with an individual namespace for all global variables and functions created by the loaded scripts. All scripts executing in the context of a particular document share this common sandbox and can also interact with other contexts through browser-supplied APIs. Such cross-document interactions must be done in a very explicit way; accidental interference is unlikely. Superficially, script-isolation rules are reminiscent of the process-compartmentalization model in modern multitasking operating systems but a lot less inclusive.</p><p>Within a particular execution context, all encountered JavaScript blocks are processed individually and almost always in a well-defined order. Each code block must consist of any number of self-contained, well-formed syntax units and will be processed in three distinct, consequent steps: parsing, function resolution, and code execution.</p><div class="sect3" title="Parsing"><div class="titlepage"><div><div><h3 class="title"><a id="parsing"/>Parsing</h3></div></div></div><p>The parsing stage validates the syntax of the script block and, usually, converts it to an intermediate binary representation, which can be subsequently executed at a more reasonable speed. The code has no global effects until this step completes successfully. In case of syntax errors, the entire problematic block is abandoned, and the parser proceeds to the next available chunk of code.</p><p>To illustrate the behavior of a compliant JavaScript parser, consider the following HTML snippet:<a class="indexterm" id="IDX-CHP-6-0019"/><a class="indexterm" id="IDX-CHP-6-0020"/></p><a id="I_programlisting5_d1e7418"/><pre class="programlisting">&lt;script&gt;    <em class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>block #1:</em></span></span></em>
var my_variable1 = 1;
var my_variable2 =
&lt;/script&gt;

&lt;script&gt;    <em class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>block #2:</em></span></span></em>
2;
&lt;/script&gt;</pre><p>Contrary to what developers schooled in C may be accustomed to, the above sequence is not equivalent to the following snippet:</p><a id="I_programlisting5_d1e7430"/><pre class="programlisting">&lt;script&gt;
var my_variable1 = 1;
var my_variable2 = 2;
&lt;/script&gt;</pre><p>This is because <span class="emphasis"><em>&lt;script&gt;</em></span> blocks are not concatenated before parsing. Instead, the first script segment will simply cause a syntax error (an assignment with a missing right-hand value), resulting in the entire block being ignored and not reaching execution stage. The fact that the whole segment is abandoned before it can have any global side effects also means that the original example is not equivalent to this:</p><a id="I_programlisting5_d1e7437"/><pre class="programlisting">&lt;script&gt;
var my_variable1 = 1;
&lt;/script&gt;

&lt;script&gt;
2;
&lt;/script&gt;</pre><p>This sets JavaScript apart from many other scripting languages such as Bash, where the parsing stage is not separated from execution in such a strong way.</p><p>What will happen in the original example provided earlier in this section is that the first block will be ignored but the second one (<span class="emphasis"><em>&lt;script&gt;2;&lt;/script&gt;</em></span>) will be parsed properly. That second block will amount to a no-op when executed, however, because it uses a pure, numerical expression as a code statement.</p></div><div class="sect3" title="Function Resolution"><div class="titlepage"><div><div><h3 class="title"><a id="function_resolution"/>Function Resolution</h3></div></div></div><p>Once the parsing stage is completed successfully, the next step involves registering every named, global function that the parser found within the currently processed block. Past this point, each function found will be reachable from the subsequently executed code. Because of this extra pre-execution step, the following syntax will work flawlessly (contrary to what programmers may be accustomed to in C or C++, <span class="emphasis"><em>hello_world()</em></span> will be registered before the first code statement—a call to said function—is executed):<a class="indexterm" id="IDX-CHP-6-0021"/></p><a id="I_programlisting5_d1e7457"/><pre class="programlisting">&lt;script&gt;
hello_world();

function hello_world() {
  alert('Hi mom!');
}
&lt;/script&gt;</pre><p>On the other hand, the modified example below will not have the desired effect:</p><a id="I_programlisting5_d1e7461"/><pre class="programlisting">&lt;script&gt;
hello_world();
&lt;/script&gt;

&lt;script&gt;
function hello_world() {
  alert('Hi mom!');
}
&lt;/script&gt;</pre><p>This modified case will fail with a runtime error because individual blocks of code are not processed simultaneously but, rather, are looked at based on the order in which they are made available to the JavaScript engine. The block that defines <span class="emphasis"><em>hello_world()</em></span> will not yet be parsed when the first block is already executing.</p><p>To further complicate the picture, the mildly awkward global name resolution model outlined here applies only to functions, not to variable declarations. Variables are registered sequentially at execution time, in a way similar to other interpreted scripting languages. Consequently, the following code sample, which merely replaces our global <span class="emphasis"><em>hello_world()</em></span> with an unnamed function assigned to a global variable, will not work as planned:<a class="indexterm" id="IDX-CHP-6-0022"/></p><a id="I_programlisting5_d1e7478"/><pre class="programlisting">&lt;script&gt;
hello_world();

var hello_world = function() {
  alert('Hi mom!');
}
&lt;/script&gt;</pre><p>In this case, the assignment to the <span class="emphasis"><em>hello_world</em></span> variable will not be done by the time the <span class="emphasis"><em>hello_world()</em></span> call is attempted.</p></div><div class="sect3" title="Code Execution"><div class="titlepage"><div><div><h3 class="title"><a id="code_execution"/>Code Execution</h3></div></div></div><p>Once function resolution is completed, the JavaScript engine normally proceeds with the ordered execution of all statements outside of function blocks. The execution of a script may fail at this point due to an unhandled exception or for a couple of other, more esoteric reasons. If such an error is encountered, however, any resolved functions within the offending code block will remain callable, and any effects of the already executed code will persist in the current scripting context.<a class="indexterm" id="IDX-CHP-6-0023"/><a class="indexterm" id="IDX-CHP-6-0024"/><a class="indexterm" id="IDX-CHP-6-0025"/><a class="indexterm" id="IDX-CHP-6-0026"/></p><p>Exception recovery and several other JavaScript execution characteristics are illustrated by the following lengthy but interesting code snippet:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7514"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages950015.png.jpg"/></div></div><p>Try to follow this example on your own and see if you agree with the annotations provided on the right.</p><p>As should be evident from this exercise, any unexpected and unhandled exceptions have an unusual consequence: They may leave the application in an inconsistent but still potentially executable state. Because exceptions are meant to prevent error propagation caused by unanticipated errors, this design is odd—especially given that on many other fronts (such as the ban on <span class="emphasis"><em>goto</em></span> statements), JavaScript exhibits a more fundamentalist stance.</p></div></div><div class="sect2" title="Execution Ordering Control"><div class="titlepage"><div><div><h2 class="title"><a id="execution_ordering_control"/>Execution Ordering Control</h2></div></div></div><p>In order to properly analyze the security properties of certain common web application design patterns, it is important to understand the JavaScript engine’s execution ordering and timing model. Thankfully, this model is remarkably sane.</p><p>Virtually all JavaScript living within a particular execution context is executed synchronously. The code can’t be reentered due to an external event while it is still executing, and there is no support for threads that would be able to simultaneously modify any shared memory. While the execution engine is busy, the processing of events, timers, page navigation requests, and so on, is postponed; in most cases, the entire browser, or at least the HTML renderer, will also remain largely unresponsive. Only once the execution stops and the scripting engine enters an idle state will the processing of queued events resume. At this point, the JavaScript code may be entered again.<a class="indexterm" id="IDX-CHP-6-0027"/><a class="indexterm" id="IDX-CHP-6-0028"/><a class="indexterm" id="IDX-CHP-6-0029"/><a class="indexterm" id="IDX-CHP-6-0030"/><a class="indexterm" id="IDX-CHP-6-0031"/><a class="indexterm" id="IDX-CHP-6-0032"/></p><p>Further, JavaScript offers no <span class="emphasis"><em>sleep(...)</em></span> or <span class="emphasis"><em>pause(...)</em></span> function to temporarily release the CPU and later resume execution from the same location. Instead, if a programmer desires to postpone the execution of a script, it is necessary to register a timer to initiate a new execution flow later on. This flow will need to start at the beginning of a specified handler function (or at the beginning of an ad hoc, self-contained snippet of code provided when setting up a timer). Although these design decisions can be annoying, they substantially reduce the risk of race conditions in the resulting code.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>There are several probably unintentional loopholes in this synchronous execution model. One of them is the possibility of code execution while the execution of another piece of JavaScript is temporarily suspended after calling <span class="emphasis"><em>alert(...)</em></span> or <span class="emphasis"><em>showModalDialog(...)</em></span>. Such corner cases do not come into play very often, though.</p></div><p>The disruptive, browser-blocking behavior of busy JavaScript loops requires the implementation of some mitigation on the browser level. We will explore these mitigations in detail in <a class="xref" href="ch14.html" title="Chapter 14. Dealing with Rogue Scripts">Chapter 14</a>. For now, suffice it to say that they have another highly unusual consequence: Any endless loop may, in fact, terminate, in a fashion similar to throwing an unhandled exception. The engine will then return to the idle state but will remain operational, the offending code will remain callable, and all timers and event handlers will stay in place.<a class="indexterm" id="IDX-CHP-6-0033"/></p><p>When triggered on purpose by the attacker, the ability to unexpectedly terminate the execution of CPU-intensive code may put the application in an inconsistent state by aborting an operation that the author expects to always complete successfully. And that’s not all: Another, closely related consequence of these semantics should become evident in <a class="xref" href="ch06.html#javascript_object_notation_and_other_dat" title="JavaScript Object Notation and Other Data Serializations">JavaScript Object Notation and Other Data Serializations</a> in <a class="xref" href="ch06.html#javascript_object_notation_and_other_dat" title="JavaScript Object Notation and Other Data Serializations">JavaScript Object Notation and Other Data Serializations</a>.</p></div><div class="sect2" title="Code and Object Inspection Capabilities"><div class="titlepage"><div><div><h2 class="title"><a id="code_and_object_inspection_capabilities"/>Code and Object Inspection Capabilities</h2></div></div></div><p>The JavaScript language has a rudimentary provision for inspecting the decompiled source code of any nonnative functions, simply by invoking the <span class="emphasis"><em>toString()</em></span> or <span class="emphasis"><em>toSource()</em></span> method on any function that the developer wishes to examine. Beyond that capability, opportunities to inspect the flow of programs are limited. Applications may leverage access to the in-memory representation of their host document and look up all inlined <span class="emphasis"><em>&lt;script&gt;</em></span> blocks, but there is no direct visibility into any remotely loaded or dynamically generated code. Some insight into the call stack may also be gained through a nonstandard <span class="emphasis"><em>caller</em></span> property, but there is also no way to tell which line of code is being currently executed or which one is coming up next.</p><p>The ability to dynamically create new JavaScript code is a more prominent part of the language. It is possible to instruct the engine to synchronously interpret strings passed to the built-in <span class="emphasis"><em>eval(...)</em></span> function. For example, this will display an alert dialog:<a class="indexterm" id="IDX-CHP-6-0034"/><a class="indexterm" id="IDX-CHP-6-0035"/><a class="indexterm" id="IDX-CHP-6-0036"/><a class="indexterm" id="IDX-CHP-6-0037"/><a class="indexterm" id="IDX-CHP-6-0038"/></p><a id="I_programlisting5_d1e7626"/><pre class="programlisting">eval("alert(\"Hi mom!\")")</pre><p>Syntax errors in any input text provided to <span class="emphasis"><em>eval(...)</em></span> will cause this function to throw an exception. Similarly, if parsing succeeds, any unhandled exceptions thrown by the interpreted code will be passed down to the caller. Finally, in the absence of syntax errors or runtime problems, the value of the last statement evaluated by the engine while executing the supplied code will be used as the return value of <span class="emphasis"><em>eval(...)</em></span> itself.<a class="indexterm" id="IDX-CHP-6-0039"/></p><p>In addition to this function, other browser-level mechanisms can be leveraged to schedule deferred parsing and execution of new JavaScript blocks once the execution engine returns to the idle state. Examples of such mechanisms include timers (<span class="emphasis"><em>setTimeout</em></span>, <span class="emphasis"><em>setInterval</em></span>), event handlers (<span class="emphasis"><em>onclick</em></span>, <span class="emphasis"><em>onload</em></span>, and so on), and interfaces to the HTML parser itself (<span class="emphasis"><em>innerHTML</em></span>, <span class="emphasis"><em>document.write(...)</em></span>, and such).</p><p>Whereas the ability to inspect the code is somewhat underhanded, runtime object introspection capabilities are well developed in JavaScript. Applications are permitted to enumerate almost any object method or property using simple <span class="emphasis"><em>for ... in</em></span> or <span class="emphasis"><em>for each ... in</em></span> iterators and can leverage operators such as <span class="emphasis"><em>typeof</em></span>, <span class="emphasis"><em>instanceof</em></span>, or “strictly equals” (===) and properties such as <span class="emphasis"><em>length</em></span> to gain additional insight into the identity of every discovered item.</p><p>All of the foregoing features make it largely impossible for scripts running in the same context to keep secrets from each other. The functionality also makes it more difficult to keep secrets across document contexts, a problem that browser vendors had to combat for a very long time—and that, as you’ll learn in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>, is still not completely a thing of the past.</p></div><div class="sect2" title="Modifying the Runtime Environment"><div class="titlepage"><div><div><h2 class="title"><a id="modifying_the_runtime_environment"/>Modifying the Runtime Environment</h2></div></div></div><p>Despite the relative simplicity of the JavaScript language, executed scripts have many unusual ways of profoundly manipulating the behavior of their own JavaScript sandbox. In some rare cases, these behaviors can impact other documents, as well.</p><div class="sect3" title="Overriding Built-Ins"><div class="titlepage"><div><div><h3 class="title"><a id="overriding_built-ins"/>Overriding Built-Ins</h3></div></div></div><p>One of the more unusual tools at the disposal of a rogue script is the ability to delete, overwrite, or shadow most of the built-in JavaScript functions and virtually all browser-supplied I/O methods. For example, consider the behavior of the following code:<a class="indexterm" id="IDX-CHP-6-0040"/><a class="indexterm" id="IDX-CHP-6-0041"/></p><a id="I_programlisting5_d1e7699"/><pre class="programlisting">// This assignment will not trigger an error.
eval = alert;

// This call will unexpectedly open a dialog prompt.
eval("Hi mom!");</pre><p>And this is just where the fun begins. In Chrome, Safari, and Opera, it is possible to subsequently remove the <span class="emphasis"><em>eval(...)</em></span> function altogether, using the <span class="emphasis"><em>delete</em></span> operator. Confusingly, attempting the same in Firefox will restore the original built-in function, undoing the effect of the original override. Finally, in Internet Explorer, the deletion attempt will generate a belated exception that seems to serve no meaningful purpose at that point.<a class="indexterm" id="IDX-CHP-6-0042"/><a class="indexterm" id="IDX-CHP-6-0043"/><a class="indexterm" id="IDX-CHP-6-0044"/><a class="indexterm" id="IDX-CHP-6-0045"/><a class="indexterm" id="IDX-CHP-6-0046"/><a class="indexterm" id="IDX-CHP-6-0047"/></p><p>Further along these lines, almost every object, including built-ins such as <span class="emphasis"><em>String</em></span> or <span class="emphasis"><em>Array</em></span>, has a freely modifiable prototype. This prototype is a master object from which all existing and future object instances derive their methods and properties (forming a crude equivalent of class inheritance present in more fully featured programming languages). The ability to tamper with object prototypes can cause rather counterintuitive behavior of newly created objects, as illustrated here:</p><a id="I_programlisting5_d1e7743"/><pre class="programlisting">Number.prototype.toString = function() {
  return "Gotcha!";
};

// This will display "Gotcha!" instead of "42":
alert(new Number(42));</pre></div><div class="sect3" title="Setters and Getters"><div class="titlepage"><div><div><h3 class="title"><a id="setters_and_getters"/>Setters and Getters</h3></div></div></div><p>More interesting features of the object model available in contemporary dialects of JavaScript are <span class="emphasis"><em>setters</em></span> and <span class="emphasis"><em>getters</em></span>: ways to supply custom code that handles reading or setting properties of the host object. Although not as powerful as operator overloading in C++, these can be used to make existing objects or object prototypes behave in even more confusing ways. In the following snippet, the acts of setting the object property and reading it back later on are both subverted easily:</p><a id="I_programlisting5_d1e7756"/><pre class="programlisting">var evil_object = {
    set foo() { alert("Gotcha!"); },
    get foo() { return 2; }
  };

// This will display "Gotcha!" and have no other effect.
evil_object.foo = 1;

// This comparison will fail.
if (evil_object.foo != 1) alert("What's going on?!");</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Setters and getters were initially developed as a vendor extension but are now standardized under ECMAScript edition 5. The feature is available in all modern browsers but not in Internet Explorer 6 or 7.<a class="indexterm" id="IDX-CHP-6-0048"/></p></div></div><div class="sect3" title="Impact on Potential Uses of the Language"><div class="titlepage"><div><div><h3 class="title"><a id="impact_on_potential_uses_of_the_language"/>Impact on Potential Uses of the Language</h3></div></div></div><p>As a result of the techniques discussed in the previous two sections, a script executing inside a context once tainted by any other untrusted content has no reliable way to examine its operating environment or take corrective action; even the behavior of simple conditional expressions or loops can’t necessarily be relied upon. The proposed enhancements to the language are likely to make the picture even more complicated. For example, the failed proposal for ECMAScript edition 4 featured full-fledged operator overloading, and this idea may return.<a class="indexterm" id="IDX-CHP-6-0049"/><a class="indexterm" id="IDX-CHP-6-0050"/><a class="indexterm" id="IDX-CHP-6-0051"/><a class="indexterm" id="IDX-CHP-6-0052"/><a class="indexterm" id="IDX-CHP-6-0053"/><a class="indexterm" id="IDX-CHP-6-0054"/><a class="indexterm" id="IDX-CHP-6-0055"/><a class="indexterm" id="IDX-CHP-6-0056"/></p><p>Even more interestingly, these design decisions also make it difficult to inspect any execution context from outside the per-page sandbox. For example, blind reliance on the reliability of the <span class="emphasis"><em>location</em></span> object of a potentially hostile document has led to a fair number of security vulnerabilities in browser plug-ins, JavaScript-based extensions, and several classes of client-side web application security features. These vulnerabilities eventually resulted in the development of browser-level workarounds designed to partially protect this specific object against sabotage, but most of the remaining object hierarchy is up for grabs.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The ability to tamper with one’s own execution context is limited in the “strict” mode of ECMAScript edition 5. This mode is not fully supported in any browser as of this writing, however, and is meant to be an opt-in, discretionary mechanism.</p></div></div></div><div class="sect2" title="JavaScript Object Notation and Other Data Serializations"><div class="titlepage"><div><div><h2 class="title"><a id="javascript_object_notation_and_other_dat"/>JavaScript Object Notation and Other Data Serializations</h2></div></div></div><p>A very important syntax structure in JavaScript is its very compact and convenient in-place object serialization, known as JavaScript Object Notation, or JSON (RFC 4627<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-4">149</a>]</sup>). This data format relies on overloading the meaning of the curly bracket symbol ({). When such a brace is used to open a fully qualified statement, it is treated in a familiar way, as the start of a nested code block. In an expression, however, it is assumed to be the beginning of a serialized object. The following example illustrates a correct use of this syntax and will display a simple prompt:</p><a id="I_programlisting5_d1e7818"/><pre class="programlisting">var impromptu_object = {
    "given_name"    : "John",
    "family_name"   : "Smith",
    "lucky_numbers" : [ 11630, 12067, 12407, 12887 ]
  };

// This will display "John".
alert(impromptu_object.given_name);</pre><p>In contrast to the unambiguous serializations of numbers, strings, or arrays, the overloading of the curly bracket means that JSON blocks will not be recognized properly when used as a standalone statement. This may seem insignificant, but it is an advantage: It prevents any server-supplied responses that comply with this syntax from being meaningfully included across domains via <span class="emphasis"><em>&lt;script src=...&gt;</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-1" id="CHP-6-FN-1">30</a>]</sup> The listing that follows will cause a syntax error, ostensibly due to an illegal quote (<span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e7843"/><img alt="" src="httpatomoreillycomsourcenostarchimages950001.png"/></span>) in what the interpreter attempts to treat as a code label,<sup>[<a class="footnote" href="#ftn.CHP-6-FN-2" id="CHP-6-FN-2">31</a>]</sup> and will have no measurable side effects:<a class="indexterm" id="IDX-CHP-6-0057"/></p><a id="I_programlisting5_d1e7864"/><pre class="programlisting">&lt;script&gt;
    {
<img alt="" src="httpatomoreillycomsourcenostarchimages950001.png"/>     "given_name"    : "John",
      "family_name"   : "Smith",
      "lucky_numbers" : [ 11630, 12067, 12407, 12887 ]
    };
    &lt;/script&gt;</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The inability to include JSON via <span class="emphasis"><em>&lt;script src=...&gt;</em></span> is an interesting property, but it is also a fragile one. In particular, wrapping the response in parentheses or square brackets, or removing quotes around the labels, will render the syntax readily executable in a standalone block, which may have observable side effects. Given the rapidly evolving syntax of JavaScript, it is not wise to bank on this particular code layout always causing a parsing error in the years to come. That said, in many noncritical uses, this level of assurance will be good enough to rely on as a simple security mechanism.</p></div><p>Once retrieved through a channel such as <span class="emphasis"><em>XMLHttpRequest</em></span>, the JSON serialization can be quickly and effortlessly converted to an in-memory object using the <span class="emphasis"><em>JSON.parse(...)</em></span> function in all common browsers, other than Internet Explorer. Unfortunately, for purposes of compatibility with Internet Explorer, and sometimes just out of custom, many developers resort to an equally fast yet far more dangerous hack:</p><a id="I_programlisting5_d1e7886"/><pre class="programlisting">var parsed_object = eval("(" + json_text + ")");</pre><p>The problem with this syntax is that the <span class="emphasis"><em>eval(...)</em></span> function used to compute the “value” of a JSON expression permits not only pure JSON inputs but any other well-formed JavaScript syntax to appear in the string. This can have undesirable, global side effects. For example, the function call embedded in this faux JSON response will execute:</p><a id="I_programlisting5_d1e7893"/><pre class="programlisting">{ "given_name": <strong class="userinput"><code>alert("Hi mom!")</code></strong>
 }</pre><p>This behavior creates an additional burden on web developers to accept JSON payloads only from trusted sources and always to correctly escape feeds produced by their own server-side code. Predictably, failure to do so has contributed a fair number of application-level security bugs.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The difficulty of getting <span class="emphasis"><em>eval(...)</em></span> right is embodied by the JSON specification (RFC 4627) itself: The allegedly secure parser implementation included in that document unintentionally permits rogue JSON responses to freely increment or decrement any program variables that happen to consist solely of the letters “a”, “e”, “f”, “l”, “n”, “r”, “s”, “t”, “u”, plus digits; that’s enough to spell “unsafe” and about 1,000 other common English words. The faulty regular expression legitimized in this RFC appears all over the Internet and will continue to do so.<a class="indexterm" id="IDX-CHP-6-0058"/><a class="indexterm" id="IDX-CHP-6-0059"/></p></div><p>Thanks to their ease of use, JSON serializations are ubiquitous in server-to-client communications across all modern web applications. The format is rivaled only by other, less secure string or array serializations and by JSONP.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-3" id="CHP-6-FN-3">32</a>]</sup> All of these schemes are incompatible with <span class="emphasis"><em>JSON.parse(...)</em></span>, however, and must rely on unsafe <span class="emphasis"><em>eval(...)</em></span> to be converted to in-memory data. The other property of these formats is that, unlike proper JSON, they will parse properly when loaded with <span class="emphasis"><em>&lt;script src=...&gt;</em></span> on a third-party page. This property is advantageous in some rare cases, but mostly it just constitutes an unobvious risk. For example, consider that even though loading an array serialization via a <span class="emphasis"><em>&lt;script&gt;</em></span> tag normally has no measurable side effects, an attacker could, at least until recent improvements, modify the setters on an <span class="emphasis"><em>Array</em></span> prototype to retrieve the supplied data. A common but often insufficient practice of prefixing a response with a <span class="emphasis"><em>while(1);</em></span> loop to prevent this attack can backfire in interesting ways if you recall the possibility of endless loops terminating in JavaScript.</p></div><div class="sect2" title="E4X and Other Syntax Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="e4x_and_other_syntax_extensions"/>E4X and Other Syntax Extensions</h2></div></div></div><p>Like HTML, JavaScript is quickly evolving. Some of the changes made to it over the years have been fairly radical and may end up turning text formats that were previously rejected by the parser into a valid JavaScript code. This, in turn, may lead to unexpected data disclosure, especially in conjunction with the extensive code and object inspection and modification capabilities discussed earlier in this chapter—and the ability to use <span class="emphasis"><em>&lt;script src=...&gt;</em></span> to load cross-domain code.</p><p>One of the more notable examples of this trend is <span class="emphasis"><em>ECMAScript for XML</em></span> (E4X),<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-5">150</a>]</sup> a completely unnecessary but elegant plan to incorporate XML syntax directly into JavaScript as an alternative to JSON-style serializations. In any E4X-compatible engine, such as Firefox, the following two snippets of code would be roughly equivalent:</p><a id="I_programlisting5_d1e7960"/><pre class="programlisting">// Normal object serialization
var my_object = { "user": {
                  "given_name": "John",
                  "family_name": "Smith",
                  "id": make_up_value()
                } };

// E4X serialization
var my_object = &lt;user&gt;
                  &lt;given_name&gt;John&lt;/given_name&gt;
                  &lt;family_name&gt;Smith&lt;/family_name&gt;
                  &lt;id&gt;{ make_up_value() }&lt;/id&gt;
                &lt;/user&gt;;</pre><p>The unexpected consequence of E4X is that, under this regime, any well-formed XML document suddenly becomes a valid <span class="emphasis"><em>&lt;script src=...&gt;</em></span> target that will parse as an expression-as-statement block. Moreover, if an attacker can strategically place “{” and “}” characters on an included page, or alter the setters for the right object prototype, the attacker may be able to extract user-specific text displayed in an unrelated document. The following example illustrates the risk:<a class="indexterm" id="IDX-CHP-6-0060"/><a class="indexterm" id="IDX-CHP-6-0061"/><a class="indexterm" id="IDX-CHP-6-0062"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7979"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages950017.png.jpg"/></div></div><p>To their credit, after several years of living with the flaw, Firefox developers decided to disallow any E4X statements that span the entirety of any parsed script, partly closing this loophole. Nevertheless, the fluidity of the language is evident, and it casts some doubt on the robustness of using of JSON responses as a defense against cross-domain script inclusion. The moment a third meaning is given to the “{” symbol or quotes-as-labels start having a purpose, the security of this server-to-client data exchange format will be substantially degraded. Be sure to plan ahead.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-1" id="ftn.CHP-6-FN-1">30</a>] </sup>Unlike most other content inclusion schemes available to scripts (such as <span class="emphasis"><em>XMLHttpRequest</em></span>), <span class="emphasis"><em>&lt;script src=...&gt;</em></span> is not subject to the cross-domain security restrictions outlined in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. Therefore, the mechanism is a security risk whenever ambient authority credentials, such as cookies, are used by the server to dynamically generate user-specific JavaScript code. This class of vulnerabilities is unimaginatively referred to as <span class="emphasis"><em>cross-site script inclusion</em></span>, or <span class="emphasis"><em>XSSI</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-2" id="ftn.CHP-6-FN-2">31</a>] </sup>Somewhat unexpectedly, JavaScript supports C-style labeled statements, such as <span class="emphasis"><em>my_label: alert(“Hi mom!”)</em></span>. This is interesting because for philosophical reasons, the language has no support for <span class="emphasis"><em>goto</em></span> and, therefore, such a label can’t be meaningfully referenced in most cases.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-3" id="ftn.CHP-6-FN-3">32</a>] </sup>JSONP literally means “JSON with padding” and stands for JSON serialization wrapped in some supplementary code that turns it into a valid, standalone JavaScript statement for convenience. Common examples may include a function call (e.g., <span class="emphasis"><em>callback_function({ ...JSON data... })</em></span>) or a variable assignment (<span class="emphasis"><em>var return_value = { ...JSON data... }</em></span>).</p></div></div></div>
<div class="sect1" title="Standard Object Hierarchy"><div class="titlepage"><div><div><h1 class="title"><a id="standard_object_hierarchy"/>Standard Object Hierarchy</h1></div></div></div><p>The JavaScript execution environment is structured around an implicit root object, which is used as the default namespace for all global variables and functions created by the program. In addition to a handful of language-mandated built-ins, this namespace is prepopulated with a hierarchy of functions that implement input and output capabilities in the browser environment. These capabilities include manipulating browser windows (<span class="emphasis"><em>open(...)</em></span>, <span class="emphasis"><em>close()</em></span>, <span class="emphasis"><em>moveTo(...)</em></span>, <span class="emphasis"><em>resizeTo(...)</em></span>, <span class="emphasis"><em>focus()</em></span>, <span class="emphasis"><em>blur()</em></span>, and such); configuring JavaScript timers (<span class="emphasis"><em>setTimeout(...)</em></span>, <span class="emphasis"><em>setInterval(...)</em></span>, and so on); displaying various UI prompts (<span class="emphasis"><em>alert(...)</em></span>, <span class="emphasis"><em>prompt(...)</em></span>, <span class="emphasis"><em>print(...)</em></span>); and performing a variety of other vendor-specific and frequently risky functions, such as accessing the system clipboard, creating bookmarks, or changing the home page.</p><p>The top-level object also provides JavaScript references to root objects belonging to related contexts, including the parent frame (<span class="emphasis"><em>parent</em></span>), the top-level document in the current browser window (<span class="emphasis"><em>top</em></span>), the window that created the current one (<span class="emphasis"><em>opener</em></span>), and all subframes of the current document (<span class="emphasis"><em>frames[]</em></span>). Several circular references to the current root object itself are also included—say, <span class="emphasis"><em>window</em></span> and <span class="emphasis"><em>self</em></span>. In browsers other than Firefox, elements with specified <span class="emphasis"><em>id</em></span> or <span class="emphasis"><em>name</em></span> parameters will be automatically registered in this namespace, too, permitting syntax such as this:</p><a id="I_programlisting5_d1e8052"/><pre class="programlisting">&lt;img id="hello" src="http://www.example.com/"&gt;
...
&lt;script&gt;
  alert(hello.src);
&lt;/script&gt;</pre><p>Thankfully, in case of any name conflicts with JavaScript variables or built-ins, <span class="emphasis"><em>id</em></span> data will not be given precedence, largely avoiding any possible interference between otherwise sanitized, user-supplied markup and in-document scripts.<a class="indexterm" id="IDX-CHP-6-0063"/><a class="indexterm" id="IDX-CHP-6-0064"/><a class="indexterm" id="IDX-CHP-6-0065"/><a class="indexterm" id="IDX-CHP-6-0066"/><a class="indexterm" id="IDX-CHP-6-0067"/><a class="indexterm" id="IDX-CHP-6-0068"/></p><p>The remainder of the top-level hierarchy consists primarily of a couple of distinguished children objects that group browser API features by theme:</p><div class="variablelist"><dl><dt><span class="term"><span class="bolditalic">location</span> <span class="strong"><strong>object</strong></span></span></dt><dd><p>This is a collection of properties and methods that allow the program to read the URL of the current document or initiate navigation to a new one. This last action, in most cases, is lethal to the caller: The current scripting context will be destroyed and replaced with a new one shortly thereafter. Updating just the fragment identifier (<span class="emphasis"><em>location.hash</em></span>) is an exception to this rule, as explained in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a>.</p><p>Note that when using <span class="emphasis"><em>location.*</em></span> data to construct new strings (HTML and JavaScript code in particular), it is unsafe to assume that it is escaped in any specific way. Internet Explorer will keep angle brackets as is in the <span class="emphasis"><em>location.search</em></span> property (which corresponds to the URL query string). Chrome, on the other hand, will escape them, but it will glance over double quotes (<code class="literal">"</code>) or backslashes. Most browsers also do not apply any escaping to the fragment ID.</p></dd><dt><span class="term"><span class="bolditalic">history</span> <span class="strong"><strong>object</strong></span></span></dt><dd><p>This hierarchy provides several infrequently used methods for moving through the per-window browsing history, in a manner similar to clicking the “back” and “forward” buttons in the browser UI. It is not possible to directly examine any of the previously visited URLs; the only option is to navigate to the history blindly by providing numerical offsets, such as <span class="emphasis"><em>history.go(-2)</em></span>. (Some recent additions to this hierarchy will be discussed in <a class="xref" href="ch17.html" title="Chapter 17. Other Browser Mechanisms of Note">Chapter 17</a>.)</p></dd><dt><span class="term"><span class="bolditalic">screen</span> <span class="strong"><strong>object</strong></span></span></dt><dd><p>A basic API for examining the dimensions of the screen and the browser window, monitor DPI, color depth, and so on. This is offered to help websites optimize the presentation of a page for a particular display device.</p></dd><dt><span class="term"><span class="bolditalic">navigator</span> <span class="strong"><strong>object</strong></span></span></dt><dd><p>An interface for querying the browser version, the underlying operating system, and the list of installed plug-ins.</p></dd><dt><span class="term"><span class="bolditalic">document</span> <span class="strong"><strong>object</strong></span></span></dt><dd><p>By far the most complex of the hierarchies, this is a doorway to the Document Object Model<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-6">151</a>]</sup> of the current page; we will have a look at this model in the following section. A couple of functions not related to document structure also appear under the <span class="emphasis"><em>document</em></span> hierarchy, usually due to arbitrary design decisions. Examples include <span class="emphasis"><em>document.cookie</em></span> for manipulating cookies, <span class="emphasis"><em>document.write(...)</em></span> for appending HTML to the current page, and <span class="emphasis"><em>document.execCommand(...)</em></span> for performing certain WYSIWYG editing tasks.<a class="indexterm" id="IDX-CHP-6-0069"/><a class="indexterm" id="IDX-CHP-6-0070"/></p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Interestingly, the information available through the <span class="emphasis"><em>navigator</em></span> and <span class="emphasis"><em>screen</em></span> objects is sufficient to uniquely fingerprint many users with a high degree of confidence. This long-known property is emphatically demonstrated by <span class="emphasis"><em>Panopticlick</em></span>, a project of the Electronic Frontier Foundation: <a class="ulink" href="https://panopticlick.eff.org/">https://panopticlick.eff.org/</a>.<a class="indexterm" id="IDX-CHP-6-0071"/><a class="indexterm" id="IDX-CHP-6-0072"/><a class="indexterm" id="IDX-CHP-6-0073"/><a class="indexterm" id="IDX-CHP-6-0074"/><a class="indexterm" id="IDX-CHP-6-0075"/><a class="indexterm" id="IDX-CHP-6-0076"/><a class="indexterm" id="IDX-CHP-6-0077"/></p></div><p>Several other language-mandated objects offer simple string-processing or arithmetic capabilities. For example, <span class="emphasis"><em>Math.random()</em></span> implements an unsafe, predictable pseudo-random number generator (a safe PRNG alternative is unfortunately not available at this time in most browsers<sup>[<a class="footnote" href="#ftn.CHP-6-FN-4" id="CHP-6-FN-4">33</a>]</sup>), while <span class="emphasis"><em>String.fromCharCode()</em></span> can be used to convert numerical values into Unicode strings. In privileged execution contexts, which are not reachable by normal web applications, a fair number of other task-specific objects will also appear.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When accessing any of the browser-supplied objects, it is important to remember that while JavaScript does not use NUL-terminated ASCIZ strings, the underlying browser (written in C or C++) sometimes will. Therefore, the outcomes of assigning NUL-containing strings to various DOM properties, or supplying them to native functions, may be unpredictable and inconsistent. Almost all browsers truncate assignments to <span class="emphasis"><em>location.*</em></span> at NUL, but only some engines will do the same when dealing with DOM <span class="emphasis"><em>*.innerHTML</em></span>.</p></div><div class="sect2" title="The Document Object Model"><div class="titlepage"><div><div><h2 class="title"><a id="the_document_object_model"/>The Document Object Model</h2></div></div></div><p>The Document Object Model, accessible through the <span class="emphasis"><em>document</em></span> hierarchy, provides a structured, in-memory representation of the current document as mapped out by the HTML parser. The resulting object tree exposes all HTML elements on the page, their tag-specific methods and properties, and the associated CSS data. This representation, not the original HTML source, is used by the browser to render and update the currently displayed document.<a class="indexterm" id="IDX-CHP-6-0078"/><a class="indexterm" id="IDX-CHP-6-0079"/></p><p>JavaScript can access the DOM in a very straightforward way, similarly to any normal objects. For example, the following snippet will go to the fifth tag within the document’s <span class="emphasis"><em>&lt;body&gt;</em></span> block, look up the first nested subtag, and set that element’s CSS color to red:</p><a id="I_programlisting5_d1e8258"/><pre class="programlisting">document.body.children[4].children[0].style.color = "red";</pre><p>To avoid having to waddle through the DOM tree in order to get to a particular deeply nested element, the browser provides several documentwide lookup functions, such as <span class="emphasis"><em>getElementById(...)</em></span> and <span class="emphasis"><em>getElementsByTagName(...)</em></span>, as well as partly redundant grouping mechanisms such as <span class="emphasis"><em>frames[]</em></span>, <span class="emphasis"><em>images[]</em></span>, or <span class="emphasis"><em>forms[]</em></span>. These features permit syntax such as the following two lines of code, both of which directly reference an element no matter where in the document hierarchy it happens to appear:</p><a id="I_programlisting5_d1e8277"/><pre class="programlisting">document.getElementsByTagName("input")[2].value = "Hi mom!";
document.images[7].src = "/example.jpg";</pre><p>For legacy reasons, the names of certain HTML elements (<span class="emphasis"><em>&lt;img&gt;</em></span>, <span class="emphasis"><em>&lt;form&gt;</em></span>, <span class="emphasis"><em>&lt;embed&gt;</em></span>, <span class="emphasis"><em>&lt;object&gt;</em></span>, and <span class="emphasis"><em>&lt;applet&gt;</em></span>) are also directly mapped to the <span class="emphasis"><em>document</em></span> namespace, as illustrated in the following snippet:<a class="indexterm" id="IDX-CHP-6-0080"/><a class="indexterm" id="IDX-CHP-6-0081"/><a class="indexterm" id="IDX-CHP-6-0082"/><a class="indexterm" id="IDX-CHP-6-0083"/></p><a id="I_programlisting5_d1e8314"/><pre class="programlisting">&lt;img name="hello" src="http://www.example.com/"&gt;

&lt;script&gt;
  alert(document.hello.src);
&lt;/script&gt;</pre><p>Unlike in the more reasonable case of <span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>id</em></span> mapping in the global namespace (see previous section), such <span class="emphasis"><em>document</em></span> entries may clobber built-in functions and objects such as <span class="emphasis"><em>getElementById</em></span> or <span class="emphasis"><em>body</em></span>. Therefore, permitting user-specified tag names, for example for the purpose of constructing forms, can be unsafe.</p><p>In addition to providing access to an abstract representation of the document, many DOM nodes may expose properties such as <span class="emphasis"><em>innerHTML</em></span> and <span class="emphasis"><em>outerHTML</em></span>, which permit a portion of the document tree to be read back as a well-formed, serialized HTML string. Interestingly, the same property can be written to in order to replace any portion of the DOM tree with the result of parsing a script-supplied snippet of HTML. One example of that last use is this:</p><a id="I_programlisting5_d1e8341"/><pre class="programlisting">document.getElementById("output").innerHTML = "<strong class="userinput"><code>&lt;b&gt;Hi mom!&lt;/b&gt;</code></strong>";</pre><p>Every assignment to <span class="emphasis"><em>innerHTML</em></span> must involve a well-formed and self-contained block of HTML that does not alter the document hierarchy outside the substituted fragment. If this condition is not met, the input will be coerced to a well-formed syntax before the substitution takes place. Therefore, the following example will not work as expected; that is, it will not display “Hi mom!” in bold and will not put the remainder of the document in italics:</p><a id="I_programlisting5_d1e8352"/><pre class="programlisting">some_element.innerHTML  = "&lt;b&gt;Hi";
some_element.innerHTML += " mom!&lt;/b&gt;&lt;i&gt;";</pre><p>Instead, each of these two assignments will be processed and corrected individually, resulting in a behavior equivalent to this:</p><a id="I_programlisting5_d1e8356"/><pre class="programlisting">some_element.innerHTML = "&lt;b&gt;Hi&lt;/b&gt; mom!&lt;i&gt;&lt;/i&gt;";</pre><p>It is important to note that the <span class="emphasis"><em>innerHTML</em></span> mechanism should be used with extreme caution. In addition to being inherently prone to markup injection if proper HTML escaping is not observed, browser implementations of the DOM-to-HTML serialization algorithms are often imperfect. A recent (now fixed) example of such a problem in WebKit<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-7">152</a>]</sup> is illustrated here:</p><a id="I_programlisting5_d1e8365"/><pre class="programlisting">&lt;textarea&gt;
  &amp;lt;/textarea&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;
&lt;/textarea&gt;</pre><p>Because of the confusion over the semantics of <span class="emphasis"><em>&lt;textarea&gt;</em></span>, this seemingly unambiguous input markup, when parsed to a DOM tree and then accessed through <span class="emphasis"><em>innerHTML</em></span>, would be incorrectly read back as:<a class="indexterm" id="IDX-CHP-6-0084"/><a class="indexterm" id="IDX-CHP-6-0085"/><a class="indexterm" id="IDX-CHP-6-0086"/><a class="indexterm" id="IDX-CHP-6-0087"/><a class="indexterm" id="IDX-CHP-6-0088"/><a class="indexterm" id="IDX-CHP-6-0089"/></p><a id="I_programlisting5_d1e8397"/><pre class="programlisting">&lt;textarea&gt;
  &lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;
&lt;/textarea&gt;</pre><p>In such a situation, even performing a no-op assignment of this serialization (such as <span class="emphasis"><em>some_element.innerHTML += ""</em></span>) would lead to unexpected script injection. Similar problems tend to plague other browsers, too. For example, Internet Explorer developers working on the <span class="emphasis"><em>innerHTML</em></span> code were unaware that MSHTML recognizes backticks (`) as quote characters and so ended up handling them incorrectly. In their implementation, the following markup:</p><a id="I_programlisting5_d1e8407"/><pre class="programlisting">&lt;img src="test.jpg" alt="``onload=alert(1)"&gt;</pre><p>would be reserialized as this:</p><a id="I_programlisting5_d1e8412"/><pre class="programlisting">&lt;img src=test.jpg alt=``onload=alert(1)&gt;</pre><p>Individual bugs aside, the situation with <span class="emphasis"><em>innerHTML</em></span> is pretty dire: Section 10.3 of the current draft of HTML5 simply acknowledges that certain script-created DOM structures are completely impossible to serialize to HTML and does not require browsers to behave sensibly in such a case. <span class="emphasis"><em>Caveat emptor!</em></span></p></div><div class="sect2" title="Access to Other Documents"><div class="titlepage"><div><div><h2 class="title"><a id="access_to_other_documents"/>Access to Other Documents</h2></div></div></div><p>Scripts may come into possession of object handles that point to the root hierarchy of another scripting context. For example, by default, every context can readily reference <span class="emphasis"><em>parent</em></span>, <span class="emphasis"><em>top</em></span>, <span class="emphasis"><em>opener</em></span>, and <span class="emphasis"><em>frames[]</em></span>, all supplied to it in the top-level object. Calling the <span class="emphasis"><em>window.open(...)</em></span> function to create a new window will also return a reference, and so will an attempt to look up an existing named window using this syntax:</p><a id="I_programlisting5_d1e8442"/><pre class="programlisting">var window_handle = window.open("", "<strong class="userinput"><code>window_name</code></strong>");</pre><p>Once the program holds a handle pointing to another scripting context, it may attempt to interact with that context, subject to security checks discussed in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. An example of a simple interaction might be as follows:</p><a id="I_programlisting5_d1e8451"/><pre class="programlisting">top.location.path = "/new_path.html";</pre><p>or</p><a id="I_programlisting5_d1e8455"/><pre class="programlisting">frames[2].document.getElementById("output").innerHTML = "Hi mom!";</pre><p>In the absence of a valid handle, JavaScript-level interaction with an unrelated document should not be possible. In particular, there is no way to look up unnamed windows opened in completely separate navigation flows, at least until their name is explicitly set by one of the visited pages (the <span class="emphasis"><em>window.name</em></span> property permits this).<a class="indexterm" id="IDX-CHP-6-0090"/><a class="indexterm" id="IDX-CHP-6-0091"/><a class="indexterm" id="IDX-CHP-6-0092"/><a class="indexterm" id="IDX-CHP-6-0093"/><a class="indexterm" id="IDX-CHP-6-0094"/><a class="indexterm" id="IDX-CHP-6-0095"/><a class="indexterm" id="IDX-CHP-6-0096"/><a class="indexterm" id="IDX-CHP-6-0097"/><a class="indexterm" id="IDX-CHP-6-0098"/><a class="indexterm" id="IDX-CHP-6-0099"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-4" id="ftn.CHP-6-FN-4">33</a>] </sup>There are a recently added <span class="emphasis"><em>window.crypto.getRandomValues(...)</em></span> API in Chrome and a currently nonoperational <span class="emphasis"><em>window.crypto.random(...)</em></span> API in Firefox.</p></div></div></div>
<div class="sect1" title="Script Character Encoding"><div class="titlepage"><div><div><h1 class="title"><a id="script_character_encoding"/>Script Character Encoding</h1></div></div></div><p>JavaScript engines support several familiar, backslash-based string-encoding methods that can be employed to escape quote characters, HTML markup, and other problematic bits in the embedded text. These methods are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C-style shorthand notation for certain control characters: <span class="emphasis"><em>\b</em></span> for backspace, <span class="emphasis"><em>\t</em></span> for horizontal tab, <span class="emphasis"><em>\v</em></span> for vertical tab, <span class="emphasis"><em>\f</em></span> for form feed, <span class="emphasis"><em>\r</em></span> for CR, and <span class="emphasis"><em>\n</em></span> for LF. This exact set of escape codes is recognized by both ECMAScript and the JSON RFC.<a class="indexterm" id="IDX-CHP-6-0100"/></p></li><li class="listitem"><p>Three-digit, zero-padded, 8-bit octal character codes with no prefix (such as “\145” instead of “e”). This C-inspired syntax is not a part of ECMAScript but is in practice supported by all scripting engines, both in normal code and in <span class="emphasis"><em>JSON.parse(...)</em></span>.</p></li><li class="listitem"><p>Two-digit, zero-padded, 8-bit hexadecimal character codes, prefixed with “x” (“e” becomes “\x65”). Again, this scheme is not endorsed by ECMAScript or RFC 4627, but having its roots in the C language, it is widely supported in practice.</p></li><li class="listitem"><p>Four-digit, zero-padded, 16-bit hexadecimal Unicode values, prefixed with “u” (“e” turns into “\u0065”). This format is sanctioned by ECMAScript and RFC 4627 and is supported by all modern browsers.</p></li><li class="listitem"><p>A backslash followed by any character other than an octal digit; “b”, “t”, “v”, “f”, “r,” or “n” characters used for other predefined escape sequences; and “x” or “u”. In this scheme, the subsequent character will be treated as a literal. ECMAScript permits this scheme to be used to escape only quotes and the backslash character itself, but in practice, any other value is accepted as well.</p><p>This approach is somewhat error prone, and as in the case of CSS, it should not be used to escape angle brackets and other HTML syntax delimiters. This is because JavaScript parsing takes place after HTML parsing, and the backslash prefix will be not treated in any special way by the HTML parser itself.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Somewhat inexplicably, Internet Explorer does not recognize the vertical tab (“\v”) shorthand, thereby creating one of the more convenient (but very naughty!) ways to test for that particular browser:</p><a id="I_programlisting5_d1e8554"/><pre class="programlisting">if ("\v" == "v") alert("Looks like Internet Explorer!");</pre></div><p>Surprisingly, the Unicode-based escaping method (but not the other ones) is also recognized outside strings. Although the idea seems arbitrary, the behavior is a bit more sensible than with CSS: Escape codes can be used only in identifiers, and they will not work as a substitute for any syntax-sensitive symbols. Therefore, the following is possible:<a class="indexterm" id="IDX-CHP-6-0101"/><a class="indexterm" id="IDX-CHP-6-0102"/><a class="indexterm" id="IDX-CHP-6-0103"/><a class="indexterm" id="IDX-CHP-6-0104"/><a class="indexterm" id="IDX-CHP-6-0105"/></p><a id="I_programlisting5_d1e8581"/><pre class="programlisting">\u0061lert("This displays a message!");</pre><p>On the other hand, any attempt to substitute the parentheses or quotes in a similar fashion would fail.</p><p>Unlike in some C or C++ implementations, stray multiline string literals are not tolerated by any JavaScript engine. That said, despite a strongly worded prohibition in ECMAScript specs, there is one exception: A lone backslash at the end of a line may be used to join multiline literals seamlessly. This behavior is illustrated below:</p><a id="I_programlisting5_d1e8587"/><pre class="programlisting">var text = 'This syntax
            is invalid.';

var text = 'This syntax, on the other hand, \
            is OK in all browsers.';</pre></div>
<div class="sect1" title="Code Inclusion Modes and Nesting Risks"><div class="titlepage"><div><div><h1 class="title"><a id="code_inclusion_modes_and_nesting_risks"/>Code Inclusion Modes and Nesting Risks</h1></div></div></div><p>As should be evident from the earlier discussions in this chapter, there are several ways to execute scripts in the context of the current page. It is probably useful to enumerate some of the most common ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Inline <span class="emphasis"><em>&lt;script&gt;</em></span> blocks</p></li><li class="listitem"><p>Remote scripts loaded with <span class="emphasis"><em>&lt;script src=...&gt;</em></span><sup>[<a class="footnote" href="#ftn.CHP-6-FN-5" id="CHP-6-FN-5">34</a>]</sup><a class="indexterm" id="IDX-CHP-6-0106"/></p></li><li class="listitem"><p><span class="emphasis"><em>javascript:</em></span> URLs in various HTML parameters and in CSS</p></li><li class="listitem"><p>CSS <span class="emphasis"><em>expression(...)</em></span> syntax and XBL bindings in certain browsers</p></li><li class="listitem"><p>Event handlers (<span class="emphasis"><em>onload</em></span>, <span class="emphasis"><em>onerror</em></span>, <span class="emphasis"><em>onclick</em></span>, etc.)</p></li><li class="listitem"><p>Timers (<span class="emphasis"><em>setTimeout</em></span>, <span class="emphasis"><em>setInterval)</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>eval(...)</em></span> calls</p></li></ul></div><p>Combining these methods often seems natural, but doing so can create very unexpected and dangerous parsing chains. For example, consider the transformation that would need to be applied to the value inserted by the server in place of <span class="emphasis"><em>user_string</em></span> in this code:</p><a id="I_programlisting5_d1e8665"/><pre class="programlisting">&lt;div onclick="setTimeout('do_stuff(\<strong class="userinput"><code>'user_string</code></strong>\')', 1000)"&gt;</pre><p>It is often difficult to notice that the value will go through no fewer than three rounds of parsing! First, the HTML parser will extract the <span class="emphasis"><em>onclick</em></span> parameter and put it into DOM; next, when the button is clicked, the first round of JavaScript parsing will extract the <span class="emphasis"><em>setTimeout(...)</em></span> syntax; and finally, one second after the initial click, the actual <span class="emphasis"><em>do_stuff(...)</em></span> sequence will be parsed and executed.<a class="indexterm" id="IDX-CHP-6-0107"/><a class="indexterm" id="IDX-CHP-6-0108"/></p><p>Therefore, in the example above, in order to survive the process, <span class="emphasis"><em>user_string</em></span> needs to be double-encoded using JavaScript backslash sequences, and then encoded again using HTML entities, in that exact order. Any different approach will likely lead to code injection.</p><p>Another tricky escaping situation is illustrated here:</p><a id="I_programlisting5_d1e8694"/><pre class="programlisting">&lt;script&gt;
var some_value = <strong class="userinput"><code>"user_string";</code></strong>
...
setTimeout("do_stuff('" + some_value + "')", 1000);
&lt;/script&gt;</pre><p>Even though the initial assignment of <span class="emphasis"><em>some_value</em></span> requires <span class="emphasis"><em>user_string</em></span> to be escaped just once, the subsequent ad hoc construction of a second-order script in the <span class="emphasis"><em>setTimeout(...)</em></span> parameter introduces a vulnerability if no additional escaping is applied beforehand.</p><p>Such coding patterns happen frequently in JavaScript programs, and they are very easy to miss. It is much better to consistently discourage them than to audit the resulting code.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-5" id="ftn.CHP-6-FN-5">34</a>] </sup>On both types of <span class="emphasis"><em>&lt;script&gt;</em></span> blocks, Microsoft supports a pseudo-dialect called <span class="emphasis"><em>JScript.Encode</em></span>. This mode can be selected by specifying a <span class="emphasis"><em>language</em></span> parameter on the <span class="emphasis"><em>&lt;script&gt;</em></span> tag and simply permits the actual script to be encoded using a trivial alphabet substitution cipher to make it unreadable to casual users. The mechanism is completely worthless from the security standpoint, as the “encryption” can be reverted easily.</p></div></div></div>
<div class="sect1" title="The Living Dead: Visual Basic"><div class="titlepage"><div><div><h1 class="title"><a id="the_living_dead_colon_visual_basic"/>The Living Dead: Visual Basic</h1></div></div></div><p>Having covered most of the needed ground related to JavaScript, it’s time for an honorable mention of the long-forgotten contender for the scripting throne. Despite 15 years of lingering in almost complete obscurity, browser-side VBScript is still supported in Internet Explorer. In most aspects, Microsoft’s language is supposed to be functionally equivalent to JavaScript, and it has access to exactly the same Document Object Model APIs and other built-in functions as JavaScript. But, as one might expect, some tweaks and extensions are present—for example, a couple of VB-specific functions in place of the JavaScript built-ins.<a class="indexterm" id="IDX-CHP-6-0109"/></p><p>There is virtually no research into the security properties of VBScript, the robustness of the parser, or its potential incompatibilities with the modern DOM. Anecdotal evidence suggests that the language receives no consistent scrutiny on Microsoft’s end, either. For example, the built-in <span class="emphasis"><em>MsgBox</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-8">153</a>]</sup> can be used to display modal, always-on-top prompts with a degree of flexibility completely unheard of in the JavaScript world, leaving <span class="emphasis"><em>alert(...)</em></span> in the dust.</p><p>It is difficult to predict how long VBScript will continue to be supported in this browser and what unexpected consequences for user and web application security it is yet to have. Only time will tell.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id4"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Loading Remote Scripts</span><a class="indexterm" id="IDX-CHP-6-0110"/><a class="indexterm" id="IDX-CHP-6-0111"/><a class="indexterm" id="IDX-CHP-6-0112"/></p><p>As with CSS, you are linking the security of your site to the originating domain of the script. When in doubt, make a local copy of the data instead. On HTTPS sites, require all scripts to be served over HTTPS.</p><p><span class="bolditalic">When Parsing JSON Received from the Server</span></p><p>Rely on <span class="emphasis"><em>JSON.parse(...)</em></span> where supported. Do not use <span class="emphasis"><em>eval(...)</em></span> or the <span class="emphasis"><em>eval</em></span>-based implementation provided in RFC 4627. Both are unsafe, especially when processing data from third parties. A later implementation from the author of RFC 4627, <span class="emphasis"><em>json2.js</em></span>,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-6-FT-9">154</a>]</sup> is probably okay.</p><p><span class="bolditalic">When Putting User-Supplied Data Inside JavaScript Blocks</span><a class="indexterm" id="IDX-CHP-6-0113"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Stand-alone strings in</strong></span> <span class="bolditalic">&lt;script&gt;</span> <span class="strong"><strong>blocks:</strong></span> Backslash-escape all control characters (0x00 - 0x1F), “\”, “&lt;”, “&gt;”, and quotes using numerical codes. It is also preferable to escape high-bit characters.</p><p>Do not rely on user-supplied strings to construct dynamic HTML. Always use safe DOM features such as <span class="emphasis"><em>innerText</em></span> or <span class="emphasis"><em>createTextNode(...)</em></span> instead. Do not use user-supplied strings to construct second-order scripts; avoid <span class="emphasis"><em>eval(...)</em></span>, <span class="emphasis"><em>setTimeout(...)</em></span>, and so on.</p></li><li class="listitem"><p><span class="strong"><strong>Stand-alone strings in separately served scripts:</strong></span> Follow the same rules as for <span class="emphasis"><em>&lt;script&gt;</em></span> blocks. If your scripts contain any sensitive, user-specific information, be sure to account for cross-site script inclusion risks; use reliable parser-busting prefixes, such as “)}]' \n”, near the beginning of a file or, at the very minimum, use a proper JSON serialization with no padding or other tweaks. Additionally, consult <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a> for tips on how to prevent cross-site scripting in non-HTML content.</p></li><li class="listitem"><p><span class="strong"><strong>Strings in inlined event handlers</strong></span>, <span class="bolditalic">javascript:</span> <span class="strong"><strong>URLs, and so on:</strong></span> Multiple levels of escaping are involved. Do not attempt this because it is error prone. If unavoidable, apply the above JS escaping rules first and then apply HTML or URL parameter encoding, as applicable, to the resulting string. Never use in conjunction with <span class="emphasis"><em>eval(...)</em></span>, <span class="emphasis"><em>setTimeout(...)</em></span>, <span class="emphasis"><em>innerHTML</em></span>, and such.</p></li><li class="listitem"><p><span class="strong"><strong>Nonstring content:</strong></span> Allow only whitelisted alphanumeric keywords and carefully validated numerical values. Do not attempt to reject known bad patterns instead.</p></li></ul></div><p><span class="bolditalic">When Interacting with Browser Objects on the Client Side</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Generating HTML content on the client side:</strong></span> Do not resort to <span class="emphasis"><em>innerHTML</em></span>, <span class="emphasis"><em>document.write(...)</em></span>, and similar tools because they are prone to introducing cross-site scripting flaws, often in unexpected ways. Use safe methods such as <span class="emphasis"><em>createElement(...)</em></span> and <span class="emphasis"><em>appendChild(...)</em></span> and properties such as <span class="emphasis"><em>innerText</em></span> or <span class="emphasis"><em>textContent</em></span> to construct the document instead.</p></li><li class="listitem"><p><span class="strong"><strong>Relying on user-controlled data:</strong></span> Make no assumptions about the escaping rules applied to any values read back from the browser and, in particular, to <span class="emphasis"><em>location</em></span> properties and other external sources of URLs, which are inconsistent and vary from one implementation to another. Always do your own escaping.</p></li></ul></div><p><span class="bolditalic">If You Want to Allow User-Controlled Scripts on Your Page</span><a class="indexterm" id="IDX-CHP-6-0114"/></p><p>It is virtually impossible to do this safely. Experimental JavaScript rewriting frameworks, such as Caja (<a class="ulink" href="http://code.google.com/p/google-caja/">http://code.google.com/p/google-caja/</a>), are the only portable option. Also see <a class="xref" href="ch16.html" title="Chapter 16. New and Upcoming Security Features">Chapter 16</a> for information on sandboxed frames, an upcoming alternative for embedding untrusted gadgets on web pages.<a class="indexterm" id="IDX-CHP-6-0115"/></p></div></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Non-HTML Document Types"><div class="titlepage"><div><div><h1 class="title"><a id="non-html_document_types"/>Chapter 7. Non-HTML Document Types</h1></div></div></div><p>In addition to HTML documents, about a dozen other file formats are recognized and displayed by the rendering engines of modern web browsers; a list that is likely to grow over time.<a class="indexterm" id="IDX-CHP-7-0001"/></p><p>Because of the powerful scripting capabilities available in some of these formats, and because of the antics of browser-content handling, the set of natively supported non-HTML inputs deserves a closer examination at this point, even if a detailed discussion of some of their less-obvious security consequences—such as <span class="emphasis"><em>content sniffing</em></span>—will have to wait until <a class="xref" href="pt02.html" title="Part II. Browser Security Features">Part II</a> of this book.</p><div class="sect1" title="Plaintext Files"><div class="titlepage"><div><div><h1 class="title"><a id="plaintext_files"/>Plaintext Files</h1></div></div></div><p>Perhaps the most prosaic type of non-HTML document recognized by every single browser is a plaintext file. In this rendering mode, the input is simply displayed as is, typically using a nonproportional typeface, and save for optional character set transcoding, the data is not altered in any way.<a class="indexterm" id="IDX-CHP-7-0002"/></p><p>All browsers recognize plaintext files served with <span class="emphasis"><em>Content-Type: text/plain</em></span> in the HTTP headers. In all implementations but Internet Explorer, plaintext is also the fallback display method for headerless HTTP/0.9 responses and HTTP/1.<span class="emphasis"><em>x</em></span> data with <span class="emphasis"><em>Content-Type</em></span> missing; in both these cases, plaintext is used when all other content detection heuristics fail. (Internet Explorer unconditionally falls back to HTML rendering, true to the letter of Tim Berners-Lee’s original protocol drafts.)<a class="indexterm" id="IDX-CHP-7-0003"/><a class="indexterm" id="IDX-CHP-7-0004"/><a class="indexterm" id="IDX-CHP-7-0005"/><a class="indexterm" id="IDX-CHP-7-0006"/><a class="indexterm" id="IDX-CHP-7-0007"/><a class="indexterm" id="IDX-CHP-7-0008"/><a class="indexterm" id="IDX-CHP-7-0009"/><a class="indexterm" id="IDX-CHP-7-0010"/><a class="indexterm" id="IDX-CHP-7-0011"/><a class="indexterm" id="IDX-CHP-7-0012"/><a class="indexterm" id="IDX-CHP-7-0013"/><a class="indexterm" id="IDX-CHP-7-0014"/><a class="indexterm" id="IDX-CHP-7-0015"/><a class="indexterm" id="IDX-CHP-7-0016"/></p><p>For the convenience of developers, most browsers also automatically map several other MIME types, including <span class="emphasis"><em>application/javascript</em></span> and friends<sup>[<a class="footnote" href="#ftn.CHP-7-FN-1" id="CHP-7-FN-1">35</a>]</sup> or <span class="emphasis"><em>text/css</em></span>, to plaintext. Interestingly, <span class="emphasis"><em>application/json</em></span>, the value mandated for JSON responses in RFC 4627, is not on the list (perhaps because it is seldom used in practice).<a class="indexterm" id="IDX-CHP-7-0017"/><a class="indexterm" id="IDX-CHP-7-0018"/></p><p>Plaintext rendering has no specific security consequences. That said, due to a range of poor design decisions in other browser components and in third-party code, even seemingly harmless non-HTML formats are at a risk of being misidentified as, for example, HTML. Attacker-controlled plaintext documents are of special concern because their layout is often fairly unconstrained and therefore particularly conducive to being misidentified. <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a> dissects these threats and provides advice on how to mitigate the risk.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-1" id="ftn.CHP-7-FN-1">35</a>] </sup>The official MIME type for JavaScript is <span class="emphasis"><em>application/javascript</em></span>, as per RFC 4329, but about a dozen other values have been used in the past (e.g., <span class="emphasis"><em>text/javascript, application/x-javascript, application/ecmascript</em></span>).</p></div></div></div>
<div class="sect1" title="Bitmap Images"><div class="titlepage"><div><div><h1 class="title"><a id="bitmap_images"/>Bitmap Images</h1></div></div></div><p>Browser-rendering engines recognize direct navigation to the same set of bitmap image formats that are normally supported in HTML documents when loaded via the <span class="emphasis"><em>&lt;img&gt;</em></span> tag, including JPEG, PNG, GIF, BMP, and a couple more. When the user navigates directly to such a resource, the decoded bitmap is shown in the document window, allowing the user little more than the ability to scroll, zoom in and out, and save the file to disk.</p><p>In the absence of <span class="emphasis"><em>Content-Type</em></span> information, images are detected based on file header checks. When a <span class="emphasis"><em>Content-Type</em></span> value is present, it is compared with about a dozen predefined image types, and the user is routed accordingly. But if an attempt to decode the image fails, file headers are used to make a second guess. It is therefore possible (but, for the reasons explored in <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a>, often unwise) to serve a GIF file as <span class="emphasis"><em>image/jpeg</em></span>.<a class="indexterm" id="IDX-CHP-7-0019"/></p><p>As with text files, bitmap images are a passive resource and carry no unusual security risks.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-2" id="CHP-7-FN-2">36</a>]</sup> However, whenever serving user-supplied images, remember that attackers will have a degree of control over the data, even if the format is carefully validated and scaled or recompressed. Therefore, the concerns about such a document format being misinterpreted by a browser or a plug-in still remain.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-2" id="ftn.CHP-7-FN-2">36</a>] </sup>Naturally, exploitable coding errors occasionally happen in all programs that deal with complex data formats, and image parsers are no exception.</p></div></div></div>
<div class="sect1" title="Audio and Video"><div class="titlepage"><div><div><h1 class="title"><a id="audio_and_video"/>Audio and Video</h1></div></div></div><p>For a very long time, browsers had no built-in support for playing audio and video content, save for an obscure and oft-ridiculed <span class="emphasis"><em>&lt;bgsound&gt;</em></span> tag in Internet Explorer, which to this day can be used to play simple MID or WAV files. In the absence of real, cross-browser multimedia playback functionality, audio and video were almost exclusively the domain of browser plug-ins, whether purpose-built (such as Windows Media Player or Apple QuickTime) or generic (Adobe Flash, Microsoft Silverlight, and so on).<a class="indexterm" id="IDX-CHP-7-0020"/><a class="indexterm" id="IDX-CHP-7-0021"/><a class="indexterm" id="IDX-CHP-7-0022"/><a class="indexterm" id="IDX-CHP-7-0023"/><a class="indexterm" id="IDX-CHP-7-0024"/><a class="indexterm" id="IDX-CHP-7-0025"/><a class="indexterm" id="IDX-CHP-7-0026"/><a class="indexterm" id="IDX-CHP-7-0027"/><a class="indexterm" id="IDX-CHP-7-0028"/><a class="indexterm" id="IDX-CHP-7-0029"/><a class="indexterm" id="IDX-CHP-7-0030"/><a class="indexterm" id="IDX-CHP-7-0031"/><a class="indexterm" id="IDX-CHP-7-0032"/><a class="indexterm" id="IDX-CHP-7-0033"/><a class="indexterm" id="IDX-CHP-7-0034"/><a class="indexterm" id="IDX-CHP-7-0035"/><a class="indexterm" id="IDX-CHP-7-0036"/></p><p>The ongoing work on HTML5 seeks to change this through support for <span class="emphasis"><em>&lt;audio&gt;</em></span> and <span class="emphasis"><em>&lt;video&gt;</em></span> tags: convenient, scriptable methods to interface with built-in media decoders. Unfortunately, there is substantial vendor-level disagreement as to which video formats to support and what patent consequences this decision may have. For example, while many browsers already support Ogg Theora (a free, open source, but somewhat niche codec), spirited arguments surrounding the merits of supporting the very popular but patent- and royalty-encumbered H.264 format and the prospects of a new, Google-backed WebM alternative will probably continue for the foreseeable future.<a class="indexterm" id="IDX-CHP-7-0037"/></p><p>As with other passive media formats (and unlike some types of plug-in-rendered content!), neither <span class="emphasis"><em>&lt;bgsound&gt;</em></span> nor HTML5 multimedia are expected to have any unusual implications for web application security, as long as the possibility of content misidentification is mitigated appropriately.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-3" id="CHP-7-FN-3">37</a>]</sup></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-3" id="ftn.CHP-7-FN-3">37</a>] </sup>But some far-fetched interactions between various technologies are a distinct possibility. For example, what if the <span class="emphasis"><em>&lt;audio&gt;</em></span> tag supports raw, uncompressed audio and is pointed to a sensitive nonaudio document, and then the proposed HTML5 microphone API is used by another website to capture the resulting waveform and reconstruct the contents of the file?</p></div></div></div>
<div class="sect1" title="XML-Based Documents"><div class="titlepage"><div><div><h1 class="title"><a id="xml-based_documents"/>XML-Based Documents</h1></div></div></div><p>Readers who found the handling of the formats discussed so far to be too sane for their tastes are in for a well-deserved treat. The largest and definitely most interesting family of browser-supported non-HTML document types relies on the common XML syntax and provides more than a fair share of interesting surprises.</p><p>Several of the formats belonging to this category are forwarded to specialized, single-purpose XML analyzers, usually based on the received <span class="emphasis"><em>Content-Type</em></span> value or other simple heuristics. But more commonly, the payload is routed to the same parser that is relied upon to render XHTML documents and then displayed using this common pipeline.</p><p>In the latter case, the actual meaning of the document is determined by the URL-like <span class="emphasis"><em>xmlns</em></span> namespace directives present in the markup itself, and the namespace parameter may have nothing to do with the value originally supplied in <span class="emphasis"><em>Content-Type</em></span>. Quite simply, there is no mechanism that would prevent a document served as <span class="emphasis"><em>application/mathml+xml</em></span> from containing nothing but XHTML markup and beginning with <span class="emphasis"><em>&lt;html &gt;</em></span>.</p><p>In the most common scenario, the namespace for the entire XML file is defined only once and is attached to the top-level tag. In principle, however, any number of different <span class="emphasis"><em>xmlns</em></span> directives may appear in a single file, giving different meanings to each section of the document. For example:<a class="indexterm" id="IDX-CHP-7-0038"/><a class="indexterm" id="IDX-CHP-7-0039"/></p><a id="I_programlisting6_d1e9190"/><pre class="programlisting">&lt;html &gt;
  &lt;u&gt;Hello world!&lt;/u&gt;
  &lt;svg &gt;
    &lt;line x1="0" y1="0" x2="100" y2="100" style="stroke: red" /&gt;
  &lt;/svg&gt;
&lt;/html&gt;</pre><p>Faced with such input, the general-purpose renderer will usually do its best to make sense of all the recognized namespaces and assemble the markup into a single, consistent document with a normal Document Object Model representation. And, if any one of the recognized namespaces happens to support scripting, any embedded scripts will execute, too.</p><p>Because of the somewhat counterintuitive <span class="emphasis"><em>xmlns</em></span> handling behavior, <span class="emphasis"><em>Content-Type</em></span> is not a suitable way to control how a particular XML document will be parsed; the presence of a particular top-level <span class="emphasis"><em>xmlns</em></span> directive is also not a guarantee that no other data formats will be honored later on. Any attacker-controlled XML-based formats must therefore be handled with care and sanitized very thoroughly.</p><div class="sect2" title="Generic XML View"><div class="titlepage"><div><div><h2 class="title"><a id="generic_xml_view"/>Generic XML View</h2></div></div></div><p>In most browsers, a valid XML document with no renderer-recognized namespaces present anywhere in the markup will be shown as an interactive, pretty-printed representation of the document tree, as shown in <a class="xref" href="ch07s04.html#firefox_displaying_an_xml_document_with" title="Figure 7-1. Firefox displaying an XML document with no recognized namespaces">Figure 7-1</a>. This mode is not particularly useful to end users, but it can aid debugging.</p><p>That said, when any of the namespaces in the document is known to the browser (even when the top-level one is not recognized at all!), the document will be rendered differently: All recognized markup will work as intended, all unsupported tags will simply have no effect, and any text between them will be shown as is.</p><p>To illustrate this rendering strategy, consider the following input:</p><a id="I_programlisting6_d1e9216"/><pre class="programlisting">&lt;foo &gt;
     &lt;u&gt;Hello&lt;/u&gt;
     &lt;html &gt;
     &lt;u&gt;world!&lt;/u&gt;
  &lt;/html&gt;
&lt;/foo&gt;</pre><p>The above example will be rendered as “Hello world!” The first <span class="emphasis"><em>&lt;u&gt;</em></span> tag, with no semantics-defining namespace associated with it, will have no visible effect. The second one will be understood as an XHTML tag that triggers underlining.</p><div class="figure"><a id="firefox_displaying_an_xml_document_with"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e9226"/><img alt="Firefox displaying an XML document with no recognized namespaces" src="httpatomoreillycomsourcenostarchimages950019.png.jpg"/></div></div><p class="title">Figure 7-1. Firefox displaying an XML document with no recognized namespaces</p></div><p>The consequences of this fault-tolerant approach to the rendering of unknown XML documents and unrecognized namespaces are subtle but fairly important. For example, it will not be safe to proxy an unsanitized RSS feed, even though this format is typically routed to a specialized renderer and thus not subject to XSS risks. Any browser with no built-in RSS reader may fall back to generic rendering and then find HTML buried deep inside the feed.<a class="indexterm" id="IDX-CHP-7-0040"/></p></div><div class="sect2" title="Scalable Vector Graphics"><div class="titlepage"><div><div><h2 class="title"><a id="scalable_vector_graphics"/>Scalable Vector Graphics</h2></div></div></div><p>Scalable Vector Graphics (SVG)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-1">155</a>]</sup> is a quickly evolving, XML-based vector graphics format. First published in 2001 by W3C, it is noteworthy for its integrated animation capabilities and direct JavaScript scripting features. The following example of a vector image draws a circle and displays a message when this circle is clicked:<a class="indexterm" id="IDX-CHP-7-0041"/><a class="indexterm" id="IDX-CHP-7-0042"/></p><a id="I_programlisting6_d1e9251"/><pre class="programlisting">&lt;svg &gt;
  &lt;script&gt;&lt;![CDATA[
    function clicked() { alert("Hi mom!"); }
  ]]&gt;&lt;/script&gt;
  &lt;circle onclick="clicked()" cx="50" cy="50"
          r="50" fill="pink" /&gt;
&lt;/svg&gt;</pre><p>The SVG file format is recognized all modern browsers except for Internet Explorer prior to 9, and it is handled by the general-purpose XML renderer. SVG images can be embedded into XHTML with an appropriate <span class="emphasis"><em>xmlns</em></span> directive or inlined in non-XML HTML5 documents using a predefined <span class="emphasis"><em>&lt;svg&gt;</em></span> tag.<a class="indexterm" id="IDX-CHP-7-0043"/><a class="indexterm" id="IDX-CHP-7-0044"/><a class="indexterm" id="IDX-CHP-7-0045"/><a class="indexterm" id="IDX-CHP-7-0046"/><a class="indexterm" id="IDX-CHP-7-0047"/></p><p>Interestingly, in several browsers the format can also be placed in a stand-alone XML document and then viewed directly, or it can be loaded on third-party pages via the <span class="emphasis"><em>&lt;img&gt;</em></span> markup. While it is safe to load SVG images via <span class="emphasis"><em>&lt;img&gt;</em></span> (scripting should be disabled in this scenario), it is fairly dangerous to host user-supplied SVG data because in cases of direct navigation, all embedded scripts will execute in the context of the hosting domain. This unexpected problem means that serving any externally originating SVG images will require very careful syntax sanitization to eliminate non-SVG <span class="emphasis"><em>xmlns</em></span> content from the XML container and to permit only certain types of markup in the remainder of the document.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>Content-Disposition</em></span> header on the relevant HTTP responses is a potential workaround that permits SVG to be included via <span class="emphasis"><em>&lt;img&gt;</em></span> but not accessed directly. This approach is not perfect, but it limits the risk. Using a throwaway domain to host such images is another possibility.</p></div></div><div class="sect2" title="Mathematical Markup Language"><div class="titlepage"><div><div><h2 class="title"><a id="mathematical_markup_language"/>Mathematical Markup Language</h2></div></div></div><p>Mathematical Markup Language (MathML)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-2">156</a>]</sup> is a fairly straightforward means to facilitate the semantic, if a bit verbose, representation of mathematical equations. The standard was originally proposed by the W3C in 1998, and it has been substantially refined through the years. Because of its somewhat niche application, MathML needed over a decade to gain partial support in Opera and Firefox browsers, but it is slowly gaining acceptance today. In the browsers that support the language, it may be placed in a standalone file or inline in XHTML and HTML5 documents.</p><p>Unlike SVG, MathML has no additional security considerations beyond those associated with generically handled XML.</p></div><div class="sect2" title="XML User Interface Language"><div class="titlepage"><div><div><h2 class="title"><a id="xml_user_interface_language"/>XML User Interface Language</h2></div></div></div><p>The XML User Interface Language (XUL)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-3">157</a>]</sup> is a presentation markup language created by Mozilla specifically for building browser-based applications, rather than documents. XUL exists because although modern HTML is often powerful enough to build basic graphical user interfaces, it is not particularly convenient for certain specialized tasks that desktop applications excel in, such as implementing common dialog windows or system menus.<a class="indexterm" id="IDX-CHP-7-0048"/></p><p>XUL is not currently supported by any browser other than Firefox and appears to be disabled in the recent release, Firefox 6. In Firefox, it is handled by the general-purpose renderer, based on the appropriate <span class="emphasis"><em>xmlns</em></span> namespace. Firefox uses XUL for much of its internal UI, but otherwise the language is seldom encountered on the Internet.</p><p>From the standpoint of web application security, Internet-originating XUL documents can be considered roughly equivalent to HTML documents. Essentially, the language has JavaScript scripting capabilities and allows broad control over the appearance of the rendered page. Other than that property, it has no unusual quirks.<a class="indexterm" id="IDX-CHP-7-0049"/><a class="indexterm" id="IDX-CHP-7-0050"/><a class="indexterm" id="IDX-CHP-7-0051"/><a class="indexterm" id="IDX-CHP-7-0052"/><a class="indexterm" id="IDX-CHP-7-0053"/><a class="indexterm" id="IDX-CHP-7-0054"/><a class="indexterm" id="IDX-CHP-7-0055"/><a class="indexterm" id="IDX-CHP-7-0056"/></p></div><div class="sect2" title="Wireless Markup Language"><div class="titlepage"><div><div><h2 class="title"><a id="wireless_markup_language"/>Wireless Markup Language</h2></div></div></div><p>Wireless Markup Language (WML)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-4">158</a>]</sup> is a largely obsolete “optimized” HTML syntax developed in the 1990s by a consortium of mobile handset manufacturers and cellular network operators. This XML-based language, a part of the Wireless Application Protocol suite (WAP), offered a simplified weblike browsing experience for pre-smartphone devices with limited bandwidth and CPU resources.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-4" id="CHP-7-FN-4">38</a>]</sup> A simple WML page might have looked like this:<a class="indexterm" id="IDX-CHP-7-0057"/><a class="indexterm" id="IDX-CHP-7-0058"/><a class="indexterm" id="IDX-CHP-7-0059"/><a class="indexterm" id="IDX-CHP-7-0060"/></p><a id="I_programlisting6_d1e9378"/><pre class="programlisting">&lt;wml&gt;
  &lt;card title="Hello world!"&gt;
      &lt;a href="elsewhere.wml"&gt;Click here!&lt;/a&gt;
  &lt;/card&gt;
&lt;/wml&gt;</pre><p>Because WAP services needed to be engineered independently of normal HTML content and had to deal with closed and underspecified client architectures and other carrier-imposed restrictions, WML never became as popular as its proponents hoped. In almost all developed markets, WML has been displaced by fast, Internet-enabled smartphones with fully featured HTML browsers. Nevertheless, the legacy of the language lives on, and it is still routed to specialized renderers in Opera and in Internet Explorer Mobile.</p><p>In the browsers that support the format, it is often possible to use WML-based scripts. There are two methods to achieve this. The canonical way is to use WMLScript (WMLS), a JavaScript-derived execution environment that depends on stand-alone script files, coupled with an extremely inconsiderate abuse of fragment IDs for an equivalent of possibly attacker-controlled <span class="emphasis"><em>eval(...)</em></span> statements:</p><a id="I_programlisting6_d1e9387"/><pre class="programlisting">&lt;a href="scriptfile.wmls#some_function()"&gt;Click here!&lt;/a&gt;</pre><p>The other method of executing scripts, available in more featured browsers, is to simply embed normal <span class="emphasis"><em>javascript:</em></span> URLs or insert <span class="emphasis"><em>&lt;script&gt;</em></span> blocks into the WML file.</p></div><div class="sect2" title="RSS and Atom Feeds"><div class="titlepage"><div><div><h2 class="title"><a id="rss_and_atom_feeds"/>RSS and Atom Feeds</h2></div></div></div><p><span class="emphasis"><em>Feeds</em></span> are a standardized way for clients to periodically poll sites of interest to users (such as their favorite blogs) for machine-readable updates to said sites’ content. Really Simple Syndication (RSS)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-5">159</a>]</sup> and Atom<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-7-FT-6">160</a>]</sup> are two superficially similar but fiercely competing XML-based feed formats. The first (RSS) is popular; the second (Atom) is said to be good.<a class="indexterm" id="IDX-CHP-7-0061"/><a class="indexterm" id="IDX-CHP-7-0062"/><a class="indexterm" id="IDX-CHP-7-0063"/></p><p>Built-in, specialized RSS and Atom renderers are available in Firefox, Safari, and Opera. The determination to route an XML document to these modules is based on simple, browser-specific heuristics, such as the top-level tag being named <span class="emphasis"><em>&lt;rss&gt;</em></span> or <span class="emphasis"><em>&lt;feed&gt;</em></span> (and not having any conflicting <span class="emphasis"><em>xmlns</em></span> directives). In Firefox, RSS parsing may kick in even if <span class="emphasis"><em>Content-Type</em></span> is <span class="emphasis"><em>image/svg+xml</em></span> or <span class="emphasis"><em>text/html</em></span>. Safari will happily recognize feeds in even more unrelated MIME types.<a class="indexterm" id="IDX-CHP-7-0064"/><a class="indexterm" id="IDX-CHP-7-0065"/><a class="indexterm" id="IDX-CHP-7-0066"/><a class="indexterm" id="IDX-CHP-7-0067"/><a class="indexterm" id="IDX-CHP-7-0068"/><a class="indexterm" id="IDX-CHP-7-0069"/><a class="indexterm" id="IDX-CHP-7-0070"/><a class="indexterm" id="IDX-CHP-7-0071"/><a class="indexterm" id="IDX-CHP-7-0072"/><a class="indexterm" id="IDX-CHP-7-0073"/><a class="indexterm" id="IDX-CHP-7-0074"/></p><p>One interesting feature of both feed formats is that they permit a subset of HTML, including CSS, to be embedded in a document in a rather peculiar, indirect way: as an entity-escaped text. Here is an example of this syntax:</p><a id="I_programlisting6_d1e9490"/><pre class="programlisting">&lt;rss&gt;
  ...
  &lt;description type="html"&gt;
    &amp;lt;u&amp;gt; Underlined text! &amp;lt;/u&amp;gt;
  &lt;/description&gt;
  ...
&lt;/rss&gt;</pre><p>The subset of HTML permitted in RSS and Atom feeds is not well defined, and some feed renderers have previously permitted direct scripting or navigation to potentially dangerous pseudo-URLs. Perhaps more importantly, however, any browser that does not have built-in feed previews may render the file using the generic XML parsing approach; if such feeds are not sanitized carefully, script execution will ensue.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-4" id="ftn.CHP-7-FN-4">38</a>] </sup>Astute readers will note that XML is not a particularly good way to conserve bandwidth or CPU resources. To that effect, the WAP suite provides an alternative, binary-only serialization of XML, known as WBXML.</p></div></div></div>
<div class="sect1" title="A Note on Nonrenderable File Types"><div class="titlepage"><div><div><h1 class="title"><a id="a_note_on_nonrenderable_file_types"/>A Note on Nonrenderable File Types</h1></div></div></div><p>For the sake of completeness, it should be noted that all modern browsers support a number of specialized file formats that remain completely opaque to the renderer or to the web application layer but that are nevertheless recognized by a variety of in-browser subsystems.</p><p>A detailed investigation of these formats is beyond the scope of this book, but some notable examples include plug-in and extension installation manifests, automatic HTTP proxy autoconfiguration files (PAC), installable visual skins, Certificate Revocation Lists (CRLs), antimalware site blacklists, and downloadable TrueType and OpenType fonts.</p><p>The security properties of these mechanisms should be studied individually before deciding to allow any of these formats to be served to the user. Save for the generic content-hosting considerations outlined in <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a>, they are unlikely to harm the hosting web application directly, but they may cause problems for users.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id5"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Hosting XML-Based Document Formats</span><a class="indexterm" id="IDX-CHP-7-0075"/></p><p>Assume that the payload may be interpreted as XHTML or some other script-enabled document type, regardless of the <span class="emphasis"><em>Content-Type</em></span> and the top-level <span class="emphasis"><em>xmlns</em></span> directive. Do not allow unconstrained attacker-controlled markup anywhere inside the file. Use the <span class="emphasis"><em>Content-Disposition: attachment</em></span> if data is not meant to be viewed directly; <span class="emphasis"><em>&lt;img&gt;</em></span> and feeds will still work.</p><p><span class="bolditalic">On All Non-HTML Document Types</span><a class="indexterm" id="IDX-CHP-7-0076"/></p><p>Use correct, browser-recognized <span class="emphasis"><em>Content-Type</em></span> and <span class="emphasis"><em>charset</em></span> values. Specify the <span class="emphasis"><em>Content-Disposition: attachment</em></span> where possible. Verify and constrain output syntax. Consult the cheat sheet in <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a> to avoid security problems related to content-sniffing flaws.</p></div></div>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Content Rendering with Browser Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="content_rendering_with_browser_plug-ins"/>Chapter 8. Content Rendering with Browser Plug-ins</h1></div></div></div><p>Browser plug-ins come in many forms and shapes, but the most common variety give the ability to display new file formats in the browser, as if they were HTML. The browser simply hands over the retrieved file, provides the helper application with a rectangular drawing surface in the document window, and essentially backs away from the scene. Such content-rendering plug-ins are clearly distinguished from browser extensions, a far more numerous bunch that commonly relies on JavaScript code to tweak how the already-supported, in-browser content is presented to the user.<a class="indexterm" id="IDX-CHP-8-0001"/><a class="indexterm" id="IDX-CHP-8-0002"/></p><p>Browser plug-ins have a long and colorful history of security flaws. In fact, according to some analysts, 12 out of the 15 most frequently exploited client-side vulnerabilities in 2010 could be attributed to the quality of plug-in software.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-1">161</a>]</sup> Many of these problems are because the underlying parsers were originally not meant to handle malicious inputs gracefully and have not benefited from the intense scrutiny that the remainder of the Web has been subject to. Other problems stem from the unusual security models devised by plug-in developers and the interference between these permissions, the traditional design of web browsers, and the commonsense expectations of application developers.<a class="indexterm" id="IDX-CHP-8-0003"/><a class="indexterm" id="IDX-CHP-8-0004"/><a class="indexterm" id="IDX-CHP-8-0005"/><a class="indexterm" id="IDX-CHP-8-0006"/><a class="indexterm" id="IDX-CHP-8-0007"/><a class="indexterm" id="IDX-CHP-8-0008"/><a class="indexterm" id="IDX-CHP-8-0009"/><a class="indexterm" id="IDX-CHP-8-0010"/></p><p>We will review some of the security mechanisms used by popular plug-ins in the next chapter of this book. Before taking this dive, it makes sense to look at the ways plug-ins integrate with other online content and the common functionality they offer.</p><div class="sect1" title="Invoking a Plug-in"><div class="titlepage"><div><div><h1 class="title"><a id="invoking_a_plug-in"/>Invoking a Plug-in</h1></div></div></div><p>Content-rendering plug-ins can be activated in a couple of ways. The most popular explicit method is to use <span class="emphasis"><em>&lt;embed src=...&gt;</em></span> or <code class="literal">&lt;</code><span class="emphasis"><em>object data=...&gt;</em></span> markup in a “host” HTML document, with the <span class="emphasis"><em>src</em></span> or <span class="emphasis"><em>data</em></span> parameter pointing to the URL from which the actual plug-in-recognized document is to be retrieved. The dimensions and position of the drawable area allocated for the plug-in can be controlled with CSS (or with legacy HTML parameters).<a class="indexterm" id="IDX-CHP-8-0011"/></p><p>In this scenario, every <span class="emphasis"><em>&lt;embed&gt;</em></span> or <span class="emphasis"><em>&lt;object&gt;</em></span> tag should be accompanied by an additional <span class="emphasis"><em>type</em></span> parameter. The MIME type specified there will be compared to the list of MIME types registered by all the active plug-ins, and the retrieved file will be routed to the appropriate handler. If no match is found, a warning asking the user to download a plug-in should be theoretically displayed instead, although most browsers look at other signals before resorting to this unthinkable possibility; examining <span class="emphasis"><em>Content-Type</em></span> or the apparent file extension spotted in the URL are two common choices.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An obsolete <span class="emphasis"><em>&lt;applet&gt;</em></span> tag, used to load Java programs (roughly equivalent to <span class="emphasis"><em>&lt;object type="application/x-java-applet"&gt;</em></span>), works in a comparable way but unconditionally disregards these auxiliary signals.</p></div><p>Additional input to the plug-in is commonly passed using <span class="emphasis"><em>&lt;param&gt;</em></span> tags nested inside the <span class="emphasis"><em>&lt;object&gt;</em></span> block or through nonstandard additional parameters attached to the <span class="emphasis"><em>&lt;embed&gt;</em></span> markup itself. The former, more modern approach may look like this:</p><a id="I_programlisting7_d1e9660"/><pre class="programlisting">&lt;object data="app.swf" type="application/x-shockwave-flash"&gt;
  &lt;param name="some_param1" value="some_value1"&gt;
  &lt;param name="some_param2" value="some_value2"&gt;
  ...
&lt;/object&gt;</pre><p>In this content-inclusion mode, the <span class="emphasis"><em>Content-Type</em></span> header returned by the server when retrieving the subresource is typically ignored, unless the <span class="emphasis"><em>type</em></span> parameter is unknown to the browser. This is an unfortunate design, for reasons that will be explained shortly.</p><p>The other method for displaying plug-in content involves navigating directly to a suitable file. In this case, and in the case of <span class="emphasis"><em>&lt;embed&gt;</em></span> or <span class="emphasis"><em>&lt;object&gt;</em></span> with a missing <span class="emphasis"><em>type</em></span> parameter, the <span class="emphasis"><em>Content-Type</em></span> value obtained from the server is honored, and it will be compared with the list of plug-in-recognized MIME types. If a match is found, the content is routed to the appropriate component. If the <span class="emphasis"><em>Content-Type</em></span> lookup fails or the header is missing, some browsers will examine the response body for known content signatures; others just give up.<a class="indexterm" id="IDX-CHP-8-0012"/><a class="indexterm" id="IDX-CHP-8-0013"/><a class="indexterm" id="IDX-CHP-8-0014"/><a class="indexterm" id="IDX-CHP-8-0015"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The aforementioned content-focused methods aside, several types of plug-ins can be loaded directly from within JavaScript or VBScript programs without the need to explicitly create any HTML markup or retrieve any external data. Such is the case for ActiveX, an infamous script-to-system integration bridge available in Internet Explorer. (We will devote some time to ActiveX later in this chapter, but first things first.)<a class="indexterm" id="IDX-CHP-8-0016"/><a class="indexterm" id="IDX-CHP-8-0017"/></p></div><div class="sect2" title="The Perils of Plug-in Content-Type Handling"><div class="titlepage"><div><div><h2 class="title"><a id="the_perils_of_plug-in_content-type_handl"/>The Perils of Plug-in Content-Type Handling</h2></div></div></div><p>As noted in the previous section, in certain scenarios the <span class="emphasis"><em>Content-Type</em></span> parameter on a retrieved plug-in-handled file is ignored, and the <span class="emphasis"><em>type</em></span> parameter in the corresponding markup on the embedding page is used instead. While this decision is somewhat similar to the behavior of other type-specific content-inclusion tags (say, <span class="emphasis"><em>&lt;img&gt;</em></span>), as discussed in <a class="xref" href="ch04s05.html#type-specific_content_inclusion" title="Type-Specific Content Inclusion">Type-Specific Content Inclusion</a> in <a class="xref" href="ch04s05.html#frames" title="Frames">Frames</a>, it has some unique and ultimately disastrous consequences in the plug-in world.</p><p>The big problem is that several types of plug-ins are essentially full-fledged code execution environments and give the executed applications (<span class="emphasis"><em>applets</em></span>) a range of special privileges to interact with the originating domain. For example, a Flash file retrieved from <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> would be granted access to its originating domain (complete with a user’s cookies) when embedded on the decidedly rogue <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a>.</p><p>In such a scenario, it would seem to be important for <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> to be able to clearly communicate that a particular type of a document is indeed meant to be interpreted by a plug-in—and, consequently, that some documents aren’t meant to be used this way. Unfortunately, there is no way for this to happen: The handling of a retrieved file is fully controlled by the embedding site (in our example, by the mean-spirited bullies who own <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a>). Therefore, if the originating domain hosts any type of user-controlled content, even in a nominally harmless format (such as <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>image/jpeg</em></span>), the owners of <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> may instruct the browser to disregard the existing metadata and route that document to a plug-in of their choice. A simple markup to achieve this sinister goal may be</p><a id="I_programlisting7_d1e9759"/><pre class="programlisting">&lt;object data="http://fuzzybunnies.com/avatars/user11630.jpg"
        type="application/x-shockwave-flash"&gt;</pre><p>If this turn of events seems wrong, that’s because it is. Security researchers have repeatedly demonstrated that it is quite easy to construct documents that are, for example, simultaneously a valid image and a valid plug-in-recognized executable. The well-known “GIFAR” vulnerability, discovered in 2008 by Billy Rios,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-2">162</a>]</sup> exploited that very trick: It smuggled a Java applet inside a perfectly kosher GIF image. In response, Sun Microsystems reportedly tightened down the Java JAR file parser to mitigate the risk, but the general threat of such mistakes is still very real and will likely rear its ugly head once more.<a class="indexterm" id="IDX-CHP-8-0018"/></p><p>Interestingly, the decision by some developers to rely on <span class="emphasis"><em>Content-Type</em></span> and other signals if the <span class="emphasis"><em>type</em></span> parameter is unrecognized is almost as bad. This decision makes it impossible for the well-intentioned <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> to safely embed a harmless video from the rogues at <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> by simply specifying <span class="emphasis"><em>type="video/x-ms-wmv"</em></span>, because if any of the visitors do not have a plug-in for that specific media type, <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> will suddenly have a say in what type of plug-in should be loaded on the embedding site instead. Some browsers, such as Internet Explorer, Chrome, or Opera, may also resort to looking for apparent file extensions present in the URL, which can lead to an interesting situation where neither the embedding nor the hosting party has real control over how a document is displayed—and quite often only the attacker is in charge.<a class="indexterm" id="IDX-CHP-8-0019"/><a class="indexterm" id="IDX-CHP-8-0020"/><a class="indexterm" id="IDX-CHP-8-0021"/><a class="indexterm" id="IDX-CHP-8-0022"/><a class="indexterm" id="IDX-CHP-8-0023"/><a class="indexterm" id="IDX-CHP-8-0024"/><a class="indexterm" id="IDX-CHP-8-0025"/><a class="indexterm" id="IDX-CHP-8-0026"/><a class="indexterm" id="IDX-CHP-8-0027"/><a class="indexterm" id="IDX-CHP-8-0028"/></p><p>A much safer design would require the embedder-controlled <span class="emphasis"><em>type</em></span> parameter and the host-controlled <span class="emphasis"><em>Content-Type</em></span> header to match (at least superficially). Unfortunately, there is currently no way to make this happen. Several individual plug-ins try to play nice (for example, following a 2008 overhaul, Adobe Flash rejects applets served with <span class="emphasis"><em>Content-Disposition: attachment</em></span>, as does the built-in PDF reader in Chrome), but these improvements are few and far between.<a class="indexterm" id="IDX-CHP-8-0029"/></p></div></div></div>
<div class="sect1" title="Document Rendering Helpers"><div class="titlepage"><div><div><h1 class="title"><a id="document_rendering_helpers"/>Document Rendering Helpers</h1></div></div></div><p>A significant portion of the plug-in landscape belongs to programs that allow certain very traditional, “nonweb” document formats to be shown directly in the browser. Some of these programs are genuinely useful: Windows Media Player, RealNetworks RealPlayer, and Apple QuickTime have been the backbone of online multimedia playback for about a decade, at least until their displacement by Adobe Flash. The merits of others are more questionable, however. For example, Adobe Reader and Microsoft Office both install in-browser document viewers, increasing the user’s attack surface appreciably, though it is unclear whether these viewers offer a real benefit over opening the same document in a separate application with one extra click.<a class="indexterm" id="IDX-CHP-8-0030"/><a class="indexterm" id="IDX-CHP-8-0031"/><a class="indexterm" id="IDX-CHP-8-0032"/><a class="indexterm" id="IDX-CHP-8-0033"/><a class="indexterm" id="IDX-CHP-8-0034"/><a class="indexterm" id="IDX-CHP-8-0035"/></p><p>Of course, in a perfect world, hosting or embedding a PDF or a Word document should have no direct consequences for the security of the participating websites. Yet, predictably, the reality begs to differ. In 2009, a researcher noted that PDF-based forms that submit to <span class="emphasis"><em>javascript:</em></span> URLs can apparently lead to client-side code execution on the embedding site.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-3">163</a>]</sup> Perhaps even more troubling than this report alone, according to that researcher’s account, Adobe initially dismissed the report with the following note: “Our position is that, like an HTML page, a PDF file is active content.”</p><p>It is regrettable that the hosting party does not have full control of when this active content is detected and executed and that otherwise reasonable webmasters may think of PDFs or Word documents as just a fancy way to present text. In reality, despite their harmless appearance, in a bid to look cool, many such document formats come equipped with their own hyperlinking capabilities or even scripting languages. For example, JavaScript code can be embedded in PDF documents, and Visual Basic macros are possible in Microsoft Office files. When a script-bearing document is displayed on an HTML page, some form of a programmatic plug-in-to-browser bridge usually permits a degree of interaction with the embedding site, and the design of such bridges can vary from vaguely questionable to outright preposterous.<a class="indexterm" id="IDX-CHP-8-0036"/><a class="indexterm" id="IDX-CHP-8-0037"/><a class="indexterm" id="IDX-CHP-8-0038"/><a class="indexterm" id="IDX-CHP-8-0039"/><a class="indexterm" id="IDX-CHP-8-0040"/><a class="indexterm" id="IDX-CHP-8-0041"/><a class="indexterm" id="IDX-CHP-8-0042"/><a class="indexterm" id="IDX-CHP-8-0043"/><a class="indexterm" id="IDX-CHP-8-0044"/></p><p>In one 2007 case, Petko D. Petkov noticed that a site that hosts any PDF documents can be attacked simply by providing completely arbitrary JavaScript code in the fragment identifier. This string will be executed on the hosting page through the plug-in bridge:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-4">164</a>]</sup></p><a id="I_programlisting7_d1e9916"/><pre class="programlisting">http://example.com/random_document.pdf#foo=<strong class="userinput"><code>javascript:alert(1)</code></strong></pre><p>The two vulnerabilities outlined here are now fixed, but the lesson is that special care should be exercised when hosting or embedding any user-supplied documents in sensitive domains. The consequences of doing so are not well documented and can be difficult to predict.</p></div>
<div class="sect1" title="Plug-in-Based Application Frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="plug-in-based_application_frameworks"/>Plug-in-Based Application Frameworks</h1></div></div></div><p>The boring job of rendering documents is a well-established role for browser plug-ins, but several ambitious vendors go well beyond this paradigm. The aim of some plug-ins is simply to displace HTML and JavaScript by providing alternative, more featured platforms for building interactive web applications. That reasoning is not completely without merit: Browsers have long lacked in performance, in graphics capabilities, and in multimedia codecs, stifling some potential uses of the Web. Reliance on plug-ins is a reasonable short-term way to make a difference. On the flip side, when proprietary, patent- and copyright-encumbered plug-ins are promoted as the ultimate way to build an online ecosystem, without any intent to improve the browsers themselves, the openness of the Web inevitably suffers. Some critics, notably Steve Jobs, think that creating a tightly controlled ecosystem is exactly what several plug-in vendors, most notably Adobe, aspire to.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-5">165</a>]</sup></p><p>In response to this perceived threat of a hostile takeover of the Web, many of the shortcomings that led to the proliferation of alternative application frameworks are now being hastily addressed under the vaguely defined umbrella of HTML5; <span class="emphasis"><em>&lt;video&gt;</em></span> tags and WebGL<sup>[<a class="footnote" href="#ftn.CHP-8-FN-1" id="CHP-8-FN-1">39</a>]</sup> are the prime examples of this work. That said, some of the features available in plug-ins will probably not be captured as a part of any browser standard in the immediate future. For example, there is currently no serious plan to add inherently dangerous elevated privilege programs supported by Java or security-by-obscurity content protection schemes (euphemistically called Digital Rights Management, or DRM).<a class="indexterm" id="IDX-CHP-8-0045"/><a class="indexterm" id="IDX-CHP-8-0046"/><a class="indexterm" id="IDX-CHP-8-0047"/></p><p>Therefore, while the landscape will change dramatically in the coming years, we can expect that in one form or another, proprietary web application frameworks are here to stay.</p><div class="sect2" title="Adobe Flash"><div class="titlepage"><div><div><h2 class="title"><a id="adobe_flash"/>Adobe Flash</h2></div></div></div><p>Adobe Flash is a web application framework introduced in 1996, in the heat of the First Browser Wars. Before its acquisition by Adobe in 2005, the Flash platform was known as Macromedia Flash or Shockwave Flash (hence the <span class="emphasis"><em>.swf</em></span> file extension used for Flash files), and it is still sometimes referred to as such.<a class="indexterm" id="IDX-CHP-8-0048"/><a class="indexterm" id="IDX-CHP-8-0049"/><a class="indexterm" id="IDX-CHP-8-0050"/><a class="indexterm" id="IDX-CHP-8-0051"/><a class="indexterm" id="IDX-CHP-8-0052"/><a class="indexterm" id="IDX-CHP-8-0053"/><a class="indexterm" id="IDX-CHP-8-0054"/><a class="indexterm" id="IDX-CHP-8-0055"/></p><p>Flash is a fairly down-to-earth platform built on top of a JavaScript-based language dubbed ActionScript.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-6">166</a>]</sup> It includes a 2-D vector and bitmap graphics-rendering engine and built-in support for several image, video, and audio formats, such as the popular and efficient H.264 codec (which is used for much of today’s online multimedia).<a class="indexterm" id="IDX-CHP-8-0056"/></p><p>By most estimates, Flash is installed on around 95 to 99 percent of all desktop systems.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-7">167</a>]</sup>, <sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-8">168</a>]</sup> This user base is substantially higher than that of any other media player plug-in. (Support for the Windows Media Player and QuickTime plug-ins is available on only about 60 percent of PCs, despite aggressive bundling strategies, while the increasingly unpopular RealPlayer is still clinging to 25 percent.) The market position contributes to the product’s most significant and unexpected use: the replacement of all multimedia playback plug-ins previously relied upon for streaming video on the Web. Although the plug-in is also used for a variety of other jobs (including implementing online games, interactive advertisements, and so on), simple multimedia constitutes a disproportionately large slice of the pie.<a class="indexterm" id="IDX-CHP-8-0057"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Confusingly, a separate plug-in called Adobe Shockwave Player (without the word “Flash”) is also available, which can be used to play back content created with Adobe Director. This plug-in is sometimes mistakenly installed in place of or alongside Adobe Flash, contributing to an approximately 20 percent install base,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-9">169</a>]</sup> but it is almost always unnecessary. The security properties of this plug-in are not particularly well studied.<a class="indexterm" id="IDX-CHP-8-0058"/></p></div><div class="sect3" title="Properties of ActionScript"><div class="titlepage"><div><div><h3 class="title"><a id="properties_of_actionscript"/>Properties of ActionScript</h3></div></div></div><p>The capabilities of ActionScript in SWF files are generally analogous to those of JavaScript code embedded on HTML pages with some minor, yet interesting, differences. For example, Flash programs are free to enumerate all fonts installed on a system and collect other useful system fingerprinting signals not available to normal scripts. Flash programs can also use full screen rendering, facilitating UI spoofing attacks, and they can request access to input devices such as a camera or a microphone (this requires the user’s consent). Flash also tends to ignore browser security and privacy settings and uses its own configuration for mechanisms such as in-plug-in persistent data storage (although some improvements in this area were announced in May 2011).</p><p>The remaining features are less surprising. We’ll discuss the network and DOM access permissions of Flash applications in more detail in the next chapter, but in short, by default, every Flash applet can use the browser HTTP stack (and any ambient credentials managed therein) to talk back to its originating server, request a limited range of subresources from other sites, and navigate the current browser window or open a new one. ActionScript programs may also negotiate browser-level access to other currently running Flash applications and, in some cases, access the DOM of the embedding page. This last functionality is implemented by injecting <span class="emphasis"><em>eval(...)</em></span>-like statements into the target JavaScript context.<a class="indexterm" id="IDX-CHP-8-0059"/><a class="indexterm" id="IDX-CHP-8-0060"/><a class="indexterm" id="IDX-CHP-8-0061"/><a class="indexterm" id="IDX-CHP-8-0062"/><a class="indexterm" id="IDX-CHP-8-0063"/></p><p>ActionScript offers fertile ground for web application vulnerabilities. For example, the <span class="emphasis"><em>getURL(...)</em></span> and <span class="emphasis"><em>navigateToURL(...)</em></span> functions, used to navigate the browser or open new windows, are sometimes invoked with attacker-controlled inputs. Such a use is dangerous. Even though <span class="emphasis"><em>javascript:</em></span> URLs do not have a special meaning to Flash, the function will pass such strings to the browser, in some cases resulting in script injection on the embedding site.</p><p>Until recently, a related problem was present with other URL-handling APIs, such as <span class="emphasis"><em>loadMovie(...)</em></span>. Even though the function did not rely on the browser to load the document, it would recognize an internal <span class="emphasis"><em>asfunction:</em></span> scheme, which works similarly to <span class="emphasis"><em>eval(...)</em></span> and could be trivially leveraged to perform a call to <span class="emphasis"><em>getURL(...)</em></span>:<a class="indexterm" id="IDX-CHP-8-0064"/></p><a id="I_programlisting7_d1e10061"/><pre class="programlisting">asfunction:getURL,javascript:alert('Hi mom!')</pre><p>The issue with loading scripts from untrusted sources, discussed in <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>, also has an equivalent in the plug-in word. In Flash, it is very unsafe to invoke certain functions that affect the state of the ActionScript execution environment (such as the <span class="emphasis"><em>LoadVars.load(...)</em></span>) with attacker-controlled URLs, even if the scheme from which the resource is loaded is <span class="emphasis"><em>http:</em></span> or <span class="emphasis"><em>https:</em></span>.</p><p>Another commonly overlooked attack surface is the internal, simplified HTML parser offered by the Flash plug-in: Basic HTML markup can be assigned to properties such as <span class="emphasis"><em>TextField.htmlText</em></span> and <span class="emphasis"><em>TextArea.htmlText</em></span>. It is easy to forget that user-supplied content must be escaped correctly in this setting. Failure to do so may permit attackers to modify the appearance of the application UI or to inject potentially problematic scripting-oriented links.</p><p>Yet another class of Flash-related security bugs may arise due to design or implementation problems in the plug-in itself. For example, take the <span class="emphasis"><em>ExternalInterface.call(...)</em></span> API. It is meant to allow ActionScript to call existing JavaScript functions on the embedding page and takes two parameters: the name of the JavaScript function to call and an optional string to be passed to this routine. While it is understood that the first parameter should not be attacker controlled, it appears to be safe to put user data in the second one. In fact, the documentation provides the following code snippet outlining this specific use case:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-10">170</a>]</sup></p><a id="I_programlisting7_d1e10090"/><pre class="programlisting">ExternalInterface.call("sendToJavaScript", input.text);</pre><p>This call will result in the following <span class="emphasis"><em>eval(...)</em></span> statement being injected on the embedding page:</p><a id="I_programlisting7_d1e10098"/><pre class="programlisting">try {
  __flash__toXML(sendToJavaScript, <strong class="userinput"><code>"value of input.text"</code></strong>));
} catch (e) {
  "&lt;undefined/&gt;";
}</pre><p>When writing the code behind this call, the authors of the plug-in remembered to use backslash escaping when outputting the second parameter: <span class="emphasis"><em>hello"world</em></span> becomes <span class="emphasis"><em>hello\"world</em></span>. Unfortunately, they overlooked the need to escape any stray backslash characters, too. Because of this, if the value of <span class="emphasis"><em>input.text</em></span> is set to the following string, the embedded script will unexpectedly execute:<a class="indexterm" id="IDX-CHP-8-0065"/><a class="indexterm" id="IDX-CHP-8-0066"/><a class="indexterm" id="IDX-CHP-8-0067"/><a class="indexterm" id="IDX-CHP-8-0068"/><a class="indexterm" id="IDX-CHP-8-0069"/><a class="indexterm" id="IDX-CHP-8-0070"/></p><a id="I_programlisting7_d1e10137"/><pre class="programlisting">Hello world!\"+<strong class="userinput"><code>alert(1)</code></strong>); } catch(e) {} //</pre><p>I contacted Adobe about this particular problem in March 2010. Over a year later, its response was this: “We have not made any change to this behavior for backwards compatibility reasons.”</p><p>That seems unfortunate.</p></div></div><div class="sect2" title="Microsoft Silverlight"><div class="titlepage"><div><div><h2 class="title"><a id="microsoft_silverlight"/>Microsoft Silverlight</h2></div></div></div><p>Microsoft Silverlight is a versatile development platform built on the Windows Presentation Foundation, a GUI framework that is a part of Microsoft’s .NET stack. It debuted in 2007 and combines an Extensible Application Markup Language (XAML)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-11">171</a>]</sup> (Microsoft’s alternative to Mozilla’s XUL) with code written in one of several managed .NET languages,<sup>[<a class="footnote" href="#ftn.CHP-8-FN-2" id="CHP-8-FN-2">40</a>]</sup> such as C# or Visual Basic.<a class="indexterm" id="IDX-CHP-8-0071"/><a class="indexterm" id="IDX-CHP-8-0072"/><a class="indexterm" id="IDX-CHP-8-0073"/><a class="indexterm" id="IDX-CHP-8-0074"/><a class="indexterm" id="IDX-CHP-8-0075"/></p><p>Despite substantial design differences and a more ambitious (and confusing) architecture, this plug-in is primarily meant to compete with Adobe Flash. Many of the features available to Silverlight applications mirror those implemented in its competitor, including a nearly identical security model and a similar <span class="emphasis"><em>eval(...)</em></span>-based bridge to the embedding page. To Microsoft’s credit, Silverlight does not come with an equivalent of the <span class="emphasis"><em>asfunction:</em></span> scheme or with a built-in HTML renderer, however.</p><p>Silverlight is marketed by Microsoft fairly aggressively, and it is bundled with some editions of Internet Explorer. As a result, depending on the source, it is believed to have about a 60 to 75 percent desktop penetration.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-12">172</a>]</sup> Despite its prevalence, Silverlight is used fairly infrequently to develop actual web applications, perhaps because it usually offers no compelling advantages over its more established counterpart or because its architecture is seen as more contrived and platform-specific. (Netflix, a popular video streaming and rental service, is one of the very few high-profile websites that actually relies on Silverlight for playback on some devices.)<a class="indexterm" id="IDX-CHP-8-0076"/></p></div><div class="sect2" title="Sun Java"><div class="titlepage"><div><div><h2 class="title"><a id="sun_java"/>Sun Java</h2></div></div></div><p>Java is a programming language coupled with a platform-independent, managed-code execution platform. Developed in the early to mid-1990s by James Gosling for Sun Microsystems, Java has a well-established role as a server-side programming language and a very robust presence in many other niches, including mobile devices. Yet, from the beginning, Sun hoped that Java would also occupy a prominent place on the browser end.<a class="indexterm" id="IDX-CHP-8-0077"/><a class="indexterm" id="IDX-CHP-8-0078"/><a class="indexterm" id="IDX-CHP-8-0079"/><a class="indexterm" id="IDX-CHP-8-0080"/><a class="indexterm" id="IDX-CHP-8-0081"/><a class="indexterm" id="IDX-CHP-8-0082"/></p><p>Java in the browser predated Flash and most similar plug-ins, and the now-obsolete <span class="emphasis"><em>&lt;applet&gt;</em></span> tag is a testament to how important and unique and novel this addition must have seemed back in its day. Yet, despite this head start, the Java language is nearly extinct as an in-browser development platform, and even in its heyday it never enjoyed real prominence. It retains a remarkable 80 percent installed base, but this high percentage is attributed largely to the fact that the Java plug-in is bundled with Java Runtime Environment (JRE), a more practically useful and commonly preinstalled component that is required to run normal, desktop Java applications on the system without any involvement on the browser end.<a class="indexterm" id="IDX-CHP-8-0083"/></p><p>The reasons for the failure of Java as a browser technology are difficult to pinpoint. Perhaps it’s due to the plug-in’s poor startup performance, the clunky UI libraries that made it difficult to develop snappy and user-friendly web applications, or the history of vicious litigation between Sun and Microsoft that cast a long shadow over the future of the language on Microsoft’s operating systems.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-3" id="CHP-8-FN-3">41</a>]</sup> Whatever the reasons may be, the high install base of Java coupled with its marginal use means that the risks it creates far outweigh any potential benefits to the users. (The plug-in had close to 80 security vulnerabilities in 2010,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-13">173</a>]</sup> and the vendor is commonly criticized for patching such bugs very slowly.)</p><p>Java’s security policies are somewhat similar to those of other plug-ins, but in some aspects, such as its understanding of the same-origin policy or its ability to restrict access to the embedding page, it compares unfavorably. (The next chapter provides an overview of this.) It is also worth noting that unlike with Flash or Silverlight, certain types of cryptographically signed applets may request access to potentially dangerous OS features, such as unconstrained networking or file access, and only a user’s easily coaxed consent stands in the way.</p></div><div class="sect2" title="XML Browser Applications (XBAP)"><div class="titlepage"><div><div><h2 class="title"><a id="xml_browser_applications_open_parenthesi"/>XML Browser Applications (XBAP)</h2></div></div></div><p>XML Browser Applications (XBAP)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-14">174</a>]</sup> is Microsoft’s heavy-handed foray into the world of web application frameworks, attempted in the years during which the battle over Java started going sour and before the company released Silverlight.<a class="indexterm" id="IDX-CHP-8-0084"/><a class="indexterm" id="IDX-CHP-8-0085"/></p><p>XBAP is reminiscent of Silverlight in that it leverages the same Windows Presentation Foundation and .NET architecture. However, instead of being a self-contained and snappy browser plug-in, it depends on the large and unwieldy .NET runtime, in a manner similar to the Java plug-in’s dependence on JRE. It executes the managed code in a separate process called <span class="emphasis"><em>PresentationHost.exe</em></span>, often loading extensive dependencies at initialization time. By Microsoft’s own admission, the load time of a medium-size previously uncached application could easily reach 10 seconds or more. When the technology premiered in 2002, most users were already expecting Internet applications to be far more responsive than that.<a class="indexterm" id="IDX-CHP-8-0086"/><a class="indexterm" id="IDX-CHP-8-0087"/></p><p>The security model of XBAP applications is poorly documented and has not been researched to date, perhaps due to XBAP’s negligible real-world use and obtuse, multilayer architecture. One would reasonably expect that XBAP’s security properties would parallel the model eventually embraced for Silverlight, but with broader access to certain .NET libraries and UI widgets. And, apparently as a result of copying from Sun, XBAP programs can also be given elevated privileges when loaded from the local filesystem or signed with a cryptographic certificate.</p><p>Microsoft bundled XBAP plug-ins with its .NET framework to the point of silently installing nonremovable Windows Presentation Foundation plug-ins—not only in Internet Explorer but also in the competing Firefox and Chrome. This move stirred some well-deserved controversy, especially once the first vulnerability reports started pouring in. (Mozilla even temporarily disabled the plug-in through an automated update to protect its users.) Still, despite such bold and questionable moves to popularize it, nobody actually wanted to write XBAP applets, and inch by inch, the technology followed Java into the dustbin of history.<a class="indexterm" id="IDX-CHP-8-0088"/><a class="indexterm" id="IDX-CHP-8-0089"/><a class="indexterm" id="IDX-CHP-8-0090"/><a class="indexterm" id="IDX-CHP-8-0091"/></p><p>Eventually, Microsoft appeared to acknowledge this failure and chose to focus on Silverlight instead. Beginning with Internet Explorer 9, XBAP is disabled by default for Internet-originating content, and the dubious Firefox and Chrome plug-ins are no longer automatically pushed to users. Nevertheless, it seems reasonable to assume that at least 10 percent of all Internet users may be still browsing with a complex, partly abandoned, and largely unnecessary plug-in installed on their machines and will continue to do so for the next couple of years.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-1" id="ftn.CHP-8-FN-1">39</a>] </sup>WebGL is a fairly recent attempt to bring OpenGL-based 3D graphics to JavaScript applications. The first specification of the standard appeared in March 2011, and wide browser-level support is expected to follow.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-2" id="ftn.CHP-8-FN-2">40</a>] </sup>Managed code is not executed directly by the CPU (which would be inherently unsafe, because CPUs are not designed to enforce web security rules). Rather, it is compiled to an intermediate binary form and then interpreted at runtime by a specialized virtual machine. This approach is faster than interpreting scripts at runtime and permits custom security policy enforcement as the program is being executed.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-3" id="ftn.CHP-8-FN-3">41</a>] </sup>The legal battles started in 1997, when Microsoft decided to roll out its own (and in some ways, superior) version of the Java virtual machine. Sun Microsystems sued, hoping to win an injunction that would force Microsoft to bundle Sun’s version instead. The two companies initially settled in 2001, but shortly thereafter they headed back to court. In the final settlement in 2004, Sun walked away with $1.6 billion in cash, but Windows users were not getting any Java runtime at all.</p></div></div></div>
<div class="sect1" title="ActiveX Controls"><div class="titlepage"><div><div><h1 class="title"><a id="activex_controls"/>ActiveX Controls</h1></div></div></div><p>At its core, ActiveX is the successor to Object Linking and Embedding (OLE), a 1990 technology that made it possible for programs to reuse components of other applications in a standardized, language-independent way. A simple use case for ActiveX would be a spreadsheet application wishing to embed an editable vector image from a graphics-editing program or a simple game that wants to embed a video player.<a class="indexterm" id="IDX-CHP-8-0092"/><a class="indexterm" id="IDX-CHP-8-0093"/><a class="indexterm" id="IDX-CHP-8-0094"/></p><p>The idea is not controversial, but by the mid-1990s Microsoft had decided that ActiveX made sense in the browser, too. After all, wouldn’t websites want to benefit from the same Windows components that desktop applications could rely on? The approach violates the idea of nurturing an open, OS-independent web, but it’s otherwise impressive, as illustrated by the following JavaScript example that casually creates, edits, and saves an Excel spreadsheet:</p><a id="I_programlisting7_d1e10302"/><pre class="programlisting">var sheet = new ActiveXObject("Excel.Sheet");
sheet.ActiveSheet.Cells(42,42).Value = "Hi mom!";
sheet.SaveAs("c:\\spreadsheet.xls");
sheet.Application.Quit();</pre><p>Standards compliance aside, Microsoft’s move to ActiveX proved disastrous from a security standpoint. Many of the exposed ActiveX components were completely unprepared to behave properly when interacting with untrusted environments, and over the next 15 years, researchers discovered several hundred significant security vulnerabilities in web-accessible ActiveX controls. Heck, the simple observation that Firefox does not support this technology helped bolster its security image at the onset of the Second Browser Wars.<a class="indexterm" id="IDX-CHP-8-0095"/><a class="indexterm" id="IDX-CHP-8-0096"/><a class="indexterm" id="IDX-CHP-8-0097"/></p><p>Despite this fiasco, Microsoft stood by ActiveX defiantly, investing in gradually limiting the number of controls that could be accessed from the Internet and fixing the bugs in those it considered essential. Not until Internet Explorer 9 did Microsoft finally decide to let go: Internet Explorer 9 disables all ActiveX access by default, requiring several extra clicks to use it when needed.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The wisdom of delegating the choice to the user is unclear, especially since the permission granted to a site extends not only to legitimate content on that website but also to any payloads injected due to application bugs such as XSS. Still, Internet Explorer 9 is some improvement.</p></div></div>
<div class="sect1" title="Living with Other Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="living_with_other_plug-ins"/>Living with Other Plug-ins</h1></div></div></div><p>So far, we have covered almost all general-purpose browser plug-ins in use today. Although there is a long tail of specialized or experimental plug-ins, their use is fairly insignificant and not something that we need to take into account when surveying the overall health of the online ecosystem.</p><p>Well, with one exception. An unspecified but probably significant percentage of online users can be expected to have an assortment of web-exposed browser plug-ins or ActiveX controls that they never knowingly installed, or that they were forced to install even though it’s doubtful that they would ever benefit from the introduced functionality.</p><p>This inexcusable practice is sometimes embraced by otherwise reputable and trusted companies. For example, Adobe forces users who wish to download Adobe Flash to also install GetRight, a completely unnecessary third-party download utility. Microsoft does the same with Akamai Download Manager on its developer-oriented website, complete with a hilarious justification (emphasis mine):<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-8-FT-15">175</a>]</sup><a class="indexterm" id="IDX-CHP-8-0098"/></p><div class="blockquote"><blockquote class="blockquote"><p>What is the Akamai Download Manager and why do I <span class="emphasis"><em>have</em></span> to use it?</p><p><span class="bolditalic">To help you</span> download large files with reduced chance of interruption, <span class="bolditalic">some downloads require</span> the use of the Akamai Download Manager.</p></blockquote></div><p>The primary concern with software installed this way and exposed directly to malicious input from anywhere on the Internet is that unless it is designed with extreme care, it is likely to have vulnerabilities (and sure enough, both GetRight and Akamai Download Manager had some). Therefore, the risks of browsing with a completely unnecessary plug-in that only served a particular purpose once or twice far outweigh the purported (and usually unwanted) benefits.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id6"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Serving Plug-in-Handled Files</span><a class="indexterm" id="IDX-CHP-8-0099"/><a class="indexterm" id="IDX-CHP-8-0100"/><a class="indexterm" id="IDX-CHP-8-0101"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Data from trusted sources:</strong></span> Data from trusted sources is generally safe to host, but remember that security vulnerabilities in Flash, Java, or Silverlight applets, or in the Adobe Reader JavaScript engine, may impact the security of your domain. Avoid processing user-supplied URLs and generating or modifying user-controlled HTML from within plug-in-executed applets. Exercise caution when using the JavaScript bridge.</p></li><li class="listitem"><p><span class="strong"><strong>User-controlled simple multimedia:</strong></span> User-controlled multimedia is relatively safe to host, but be sure to validate and constrain the format, use the correct <span class="emphasis"><em>Content-Type</em></span>, and consult the cheat sheet in <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a> to avoid security problems caused by content-sniffing flaws.</p></li><li class="listitem"><p><span class="strong"><strong>User-controlled document formats:</strong></span> These are not inherently unsafe, but they have an increased risk of contributing security problems due to plug-in design flaws. Consider hosting from a dedicated domain when possible. If you need to authenticate the request to an isolated domain, do so with a single-use request token instead of by relying on cookies.</p></li><li class="listitem"><p><span class="strong"><strong>User-controlled active applications:</strong></span> These are unsafe to host in sensitive domains.</p></li></ul></div><p><span class="bolditalic">When Embedding Plug-in-Handled Files</span></p><p>Always make sure that plug-in content on HTTPS sites is also loaded over HTTPS,<sup>[<a class="footnote" href="#ftn.CHP-8-FN-4" id="CHP-8-FN-4">42</a>]</sup> and always explicitly specify the <span class="emphasis"><em>type</em></span> parameter on <span class="emphasis"><em>&lt;object&gt;</em></span> or <span class="emphasis"><em>&lt;embed&gt;</em></span>. Note that because of the non-authoritative handling of <span class="emphasis"><em>type</em></span> parameters, restraint must be exercised when embedding plug-in content from untrusted sources, especially on highly sensitive sites.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Simple multimedia:</strong></span> It is generally safe to load simple multimedia from third-party sources, with the caveats outlined above.</p></li><li class="listitem"><p><span class="strong"><strong>Document formats:</strong></span> These are usually safe, but they carry a greater potential for plug-in and browser content-handling issues than simple multimedia. Exercise caution.</p></li><li class="listitem"><p><span class="strong"><strong>Flash and Silverlight:</strong></span> In principle, Flash and Silverlight apps can be embedded safely from external sources if the appropriate security flags are present in the markup. If the flags are not specified correctly, you may end up tying the security of your site to that of the provider of the content. Consult the cheat sheet in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a> for advice.</p></li><li class="listitem"><p><span class="strong"><strong>Java:</strong></span> Java always ties the security of your service to that of the provider of the content, because DOM access to the embedding page can’t be reliably restricted. See <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. Do not load Java apps from untrusted sites.</p></li></ul></div><p><span class="bolditalic">If You Want to Write a New Browser Plug-in or ActiveX Component</span></p><p>Unless you are addressing an important, common-use case that will benefit a significant fraction of the Internet, please reconsider. If you are scratching an important itch, consider doing it in a peer-reviewed, standardized manner as a part of HTML5.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-4" id="ftn.CHP-8-FN-4">42</a>] </sup>If loading an HTTP-delivered applet on an HTTPS page is absolutely unavoidable, it is safer to place it inside an intermediate HTTP frame rather than directly inside the HTTPS document, as this prevents the applet-to-JavaScript bridge from being leveraged for attacks.</p></div></div></div></body></html>