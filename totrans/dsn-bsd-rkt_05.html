<html><head></head><body><div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="run-time_kernel_memory_patching"/>Chapter 5. RUN-TIME KERNEL MEMORY PATCHING</h1></div></div></div><p>In the previous chapters we looked at the classic method of introducing code into a running kernel: through a loadable kernel module. In this chapter we'll look at how to patch and augment a running kernel with userland code. This is accomplished by interacting with the /dev/kmem device, which allows us to read from and write to kernel virtual memory. In other words, /dev/kmem allows us to patch the various code bytes (loaded in executable memory space) that control the logic of the kernel. This is commonly referred to as <span class="emphasis"><em>run-time kernel memory patching</em></span>.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="kernel_data_access_library"/>Kernel Data Access Library</h1></div></div></div><p>The Kernel Data Access Library (libkvm) provides a uniform interface for accessing kernel virtual memory through the /dev/kmem device. The following six functions from libkvm form the basis of run-time kernel memory patching.<a id="IDX-CHP-5-0270" class="indexterm"/><a id="IDX-CHP-5-0271" class="indexterm"/><a id="IDX-CHP-5-0272" class="indexterm"/><a id="IDX-CHP-5-0266" class="indexterm"/><a id="IDX-CHP-5-0267" class="indexterm"/><a id="IDX-CHP-5-0268" class="indexterm"/><a id="IDX-CHP-5-0269" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_openfiles_function"/>The kvm_openfiles Function</h2></div></div></div><p>Access to kernel virtual memory is initialized by calling the <code class="literal">kvm_openfiles</code> function. If <code class="literal">kvm_openfiles</code> is successful, a descriptor is returned to be used in all subsequent libkvm calls. If an error is encountered, <code class="literal">NULL</code> is returned instead.<a id="IDX-CHP-5-0278" class="indexterm"/><a id="IDX-CHP-5-0273" class="indexterm"/><a id="IDX-CHP-5-0274" class="indexterm"/><a id="IDX-CHP-5-0275" class="indexterm"/><a id="IDX-CHP-5-0276" class="indexterm"/><a id="IDX-CHP-5-0277" class="indexterm"/></p><p>Here is the function prototype for <code class="literal">kvm_openfiles</code>:</p><a id="I_programlisting5_d1e4902"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;

kvm_t *
kvm_openfiles(const char *execfile, const char *corefile,
    const char *swapfile, int flags, char *errbuf);
</pre><p>The following is a brief description of each parameter.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>execfile</code></strong></span></dt><dd><p>This specifies the kernel image to be examined, which must contain a symbol table. If this parameter is set to <code class="literal">NULL</code>, the currently running kernel image is examined.</p></dd><dt><span class="term"><strong class="userinput"><code>corefile</code></strong></span></dt><dd><p>This is the kernel memory device file; it must be set to either /dev/mem or a crash dump core generated by <code class="literal">savecore(8)</code>. If this parameter is set to <code class="literal">NULL</code>, /dev/mem is used.</p></dd><dt><span class="term"><strong class="userinput"><code>swapfile</code></strong></span></dt><dd><p>This parameter is currently unused; thus, it's always set to <code class="literal">NULL</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>flags</code></strong></span></dt><dd><p>This parameter indicates the read/write access permissions for the core file. It must be set to one of the following constants:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>O_RDONLY</code></strong></span></dt><dd><p>Open for reading only.</p></dd><dt><span class="term"><strong class="userinput"><code>O_WRONLY</code></strong></span></dt><dd><p>Open for writing only.</p></dd><dt><span class="term"><strong class="userinput"><code>O_RDWR</code></strong></span></dt><dd><p>Open for reading and writing.</p></dd></dl></div></dd><dt><span class="term"><strong class="userinput"><code>errbuf</code></strong></span></dt><dd><p>If <code class="literal">kvm_openfiles</code> encounters an error, an error message is written into this parameter.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_nlist_function"/>The kvm_nlist Function</h2></div></div></div><p>The <code class="literal">kvm_nlist</code> function retrieves the symbol table entries from a kernel image.<a id="IDX-CHP-5-0279" class="indexterm"/></p><a id="I_programlisting5_d1e4992"/><pre class="programlisting">
#include &lt;kvm.h&gt;
#include &lt;nlist.h&gt;

int
kvm_nlist(kvm_t *kd, struct nlist *nl);
</pre><p>Here, <code class="literal">nl</code> is a null-terminated array of <code class="literal">nlist</code> structures. To make proper use of <code class="literal">kvm_nlist</code>, you'll need to know two fields in <code class="literal">struct nlist</code>, specifically <code class="literal">n_name</code>, which is the name of a symbol loaded in memory, and <code class="literal">n_value</code>, which is the address of the symbol.</p><p>The <code class="literal">kvm_nlist</code> function iterates through <code class="literal">nl</code>, looking up each symbol in turn through the <code class="literal">n_name</code> field; if found, <code class="literal">n_value</code> is filled out appropriately. Otherwise, it is set to <code class="literal">0</code>.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_geterr_function"/>The kvm_geterr Function</h2></div></div></div><p>The <code class="literal">kvm_geterr</code> function returns a string describing the most recent error condition on a kernel virtual memory descriptor.<a id="IDX-CHP-5-0280" class="indexterm"/></p><a id="I_programlisting5_d1e5045"/><pre class="programlisting">
#include &lt;kvm.h&gt;

char *
kvm_geterr(kvm_t *kd);
</pre><p>The results are undefined if the most recent libkvm call did not produce an error.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_read_function"/>The kvm_read Function</h2></div></div></div><p>Data is read from kernel virtual memory with the <code class="literal">kvm_read</code> function. If the read is successful, the number of bytes transferred is returned. Otherwise, <code class="literal">−1</code> is returned.<a id="IDX-CHP-5-0281" class="indexterm"/></p><a id="I_programlisting5_d1e5065"/><pre class="programlisting">
#include &lt;kvm.h&gt;

ssize_t
kvm_read(kvm_t *kd, unsigned long addr, void *buf, size_t nbytes);
</pre><p>Here, <code class="literal">nbytes</code> indicates the number of bytes to be read from the kernel space address <code class="literal">addr</code> to the buffer <code class="literal">buf</code>.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_write_function"/>The kvm_write Function</h2></div></div></div><p>Data is written to kernel virtual memory with the <code class="literal">kvm_write</code> function.<a id="IDX-CHP-5-0282" class="indexterm"/></p><a id="I_programlisting5_d1e5091"/><pre class="programlisting">
#include &lt;kvm.h&gt;

ssize_t
kvm_write(kvm_t *kd, unsigned long addr, const void *buf, size_t nbytes);
</pre><p>The return value is usually equal to the <code class="literal">nbytes</code> argument, unless an error has occurred, in which case <code class="literal">−1</code> is returned instead. In this definition, <code class="literal">nbytes</code> indicates the number of bytes to be written to <code class="literal">addr</code> from <code class="literal">buf</code>.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_kvm_close_function"/>The kvm_close Function</h2></div></div></div><p>An open kernel virtual memory descriptor is closed by calling the <code class="literal">kvm_close</code> function.<a id="IDX-CHP-5-0285" class="indexterm"/><a id="IDX-CHP-5-0283" class="indexterm"/><a id="IDX-CHP-5-0284" class="indexterm"/></p><a id="I_programlisting5_d1e5135"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;

int
kvm_close(kvm_t *kd);
</pre><p>If <code class="literal">kvm_close</code> is successful, <code class="literal">0</code> is returned. Otherwise, <code class="literal">−1</code> is returned.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="patching_code_bytes"/>Patching Code Bytes</h1></div></div></div><p>Now, equipped with the functions from the previous section, let's patch some kernel virtual memory. I'll start with a very basic example. Listing 5-1 is a system call module that acts like an over-caffeinated "Hello, world!" function.</p><a id="I_programlisting5_d1e5153"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;

/* The system call function. */
static int
hello(struct thread *td, void *syscall_args)
{
        int i;
        ❶for (i = 0; i &lt; 10; i++)
                printf("FreeBSD Rocks!\n");

        return(0);
}

/* The sysent for the new system call. */
static struct sysent hello_sysent = {
        0,                      /* number of arguments */
        hello                   /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;
        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);
}

SYSCALL_MODULE(hello, &amp;offset, &amp;hello_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 5-1: hello.c</em></span></p><p>As you can see, if we execute this system call, we'll get some very annoying output. To make this system call less annoying, we can patch out ❶ the <code class="literal">for</code> loop, which will remove the nine additional calls to <code class="literal">printf</code>. However, before we can do that, we'll need to know what this system call looks like when it's loaded in main memory.</p><a id="I_programlisting5_d1e5166"/><pre class="programlisting">
$ <strong class="userinput"><code>objdump -dR ./hello.ko</code></strong>

./hello.ko:     file format elf32-i386-freebsd

Disassembly of section .text:

00000480 &lt;hello&gt;:
 480:   55                      push   %ebp
 481:   89 e5                   mov    %esp,%ebp
 483:   53                      push   %ebx
 484:   bb 09 00 00 00          mov    $0x9,%ebx
 489:   83 ec 04                sub    $0x4,%esp
 48c:   8d 74 26 00             lea    0x0(%esi),%esi
 490:   c7 04 24 0d 05 00 00    movl   $0x50d,(%esp)
                        493: R_386_RELATIVE     *ABS*
 497:   e8 fc ff ff ff          call   498 &lt;hello+0x18&gt;
                        498: R_386_PC32 printf
 49c:   4b                      dec    %ebx
 49d:   79 f1                   jns    490 &lt;hello+0x10&gt;
 49f:   83 c4 04                add    $0x4,%esp
 4a2:   31 c0                   xor    %eax,%eax
 4a4:   5b                      pop    %ebx
 4a5:   c9                      leave
 4a6:   c3                      ret
 4a7:   89 f6                   mov    %esi,%esi
 4a9:   8d bc 27 00 00 00 00    lea    0x0(%edi),%edi
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The binary <em class="replaceable"><code>hello.ko</code></em> was compiled explicitly without the <em class="replaceable"><code>-funroll-loops</code></em> option.</p></div><p>Notice the instruction at address 49d, which causes the instruction pointer to jump back to address 490 if the sign flag is not set. This instruction is, more or less, the <code class="literal">for</code> loop in hello.c. Therefore, if we <code class="literal">nop</code> it out, we can make the <code class="literal">hello</code> system call somewhat bearable. The program in Listing 5-2 does just that.</p><a id="I_programlisting5_d1e5191"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;
#include &lt;limits.h&gt;
#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;

#define SIZE    0x30

/* Replacement code. */
unsigned char nop_code[] =
        "\x90\x90";             /* nop          */

int
main(int argc, char *argv[])
{
        int i, offset;
        char errbuf[_POSIX2_LINE_MAX];
        kvm_t *kd;
        struct nlist nl[] = { {NULL}, {NULL}, };
        unsigned char hello_code[SIZE];

        /* Initialize kernel virtual memory access. */
        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);
        if (kd == NULL) {
                fprintf(stderr, "ERROR: %s\n", errbuf);
                exit(-1);
        }

        nl[0].n_name = "hello";

        /* Find the address of hello. */
        if (kvm_nlist(kd, nl) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (!nl[0].n_value) {
                fprintf(stderr, "ERROR: Symbol %s not found\n",
                    nl[0].n_name);
                exit(-1);
        }
        /* Save a copy of hello. */
        if (kvm_read(kd, nl[0].n_value, hello_code, SIZE) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Search through hello for the jns instruction. */

        ❶ for (i = 0; i &lt; SIZE; i++) {
                if (hello_code[i] == 0x79) {
                        offset = i;
                        break;
                }
        }

        /* Patch hello. */
        if (kvm_write(kd, nl[0].n_value + offset, nop_code,
           ❷sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Close kd. */
        if (kvm_close(kd) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 5-2: fix_hello.c</em></span></p><p>Notice how ❶ I search through the first 48 bytes of <code class="literal">hello</code>, looking for the <code class="literal">jns</code> instruction, instead of using a hard-coded offset. Depending on your compiler version, compiler flags, base system, and so on, it is entirely possible for hello.c to compile differently. Therefore, it's useless to determine the location of <code class="literal">jns</code> ahead of time.</p><p>In fact, it's possible that when compiled, hello.c will not even include a <code class="literal">jns</code> instruction, as there are multiple ways to represent a <code class="literal">for</code> loop in machine code. Furthermore, recall that the disassembly of <code class="literal">hello.ko</code> identified two instructions that require dynamic relocation. This means that the first 0×79 byte encountered may be part of those instructions, and not the actual <code class="literal">jns</code> instruction. That's why this is an example and not a real program.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>To get around these problems, use longer and/or more search signatures. You could also use hard-coded offsets, but your code would break on some systems.</p></div><p>Another interesting detail worth mentioning is that when I patch <code class="literal">hello</code> with <code class="literal">kvm_write</code>, I ❷ pass <code class="literal">sizeof(nop_code) - 1</code>, not <code class="literal">sizeof(nop_code)</code>, as the <code class="literal">nbytes</code> argument. In C, character arrays are null terminated; therefore, <code class="literal">sizeof(nop_code)</code> returns three. However, I only want to write two <code class="literal">nop</code>s, not two <code class="literal">nop</code>s and a <code class="literal">NULL</code>.</p><p>The following output shows the results of executing <code class="literal">hello</code> before and after running <code class="literal">fix_hello</code> on ttyv0 (i.e., the system console):</p><a id="I_programlisting5_d1e5263"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./hello.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>perl -e 'syscall(210);'</code></strong>
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
FreeBSD Rocks!
$ <strong class="userinput"><code>gcc -o fix_hello fix_hello.c -lkvm</code></strong>
$ <strong class="userinput"><code>sudo ./fix_hello</code></strong>
$ <strong class="userinput"><code>perl -e 'syscall(210);'</code></strong>
FreeBSD Rocks!
</pre><p>Success! Now let's try something a little more advanced.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="understanding_x86_call_statements"/>Understanding <span class="emphasis"><em>x</em></span>86 Call Statements</h1></div></div></div><p>In <span class="emphasis"><em>x</em></span>86 assembly the <code class="literal">call</code> statement is a control transfer instruction used to call a function or procedure. There are two types of <code class="literal">call</code> statements: <code class="literal">near</code> and <code class="literal">far</code>. For our purposes, we only need to understand <code class="literal">near call</code> statements. The following (contrived) code segment illustrates the details of a <code class="literal">near call</code>.<a id="IDX-CHP-5-0286" class="indexterm"/><a id="IDX-CHP-5-0287" class="indexterm"/><a id="IDX-CHP-5-0288" class="indexterm"/><a id="IDX-CHP-5-0289" class="indexterm"/></p><a id="I_programlisting5_d1e5342"/><pre class="programlisting">
 200:   bb 12 95 00 00          mov    $0x9512,%ebx
 205:   e8 f6 00 00 00          call   300
 20a:   b8 2f 14 00 00          mov    $0x142f,%eax
</pre><p>In the above code snippet, when the instruction pointer reaches address 205—the <code class="literal">call</code> statement—it will jump to address 300. The hexadecimal representation for a <code class="literal">call</code> statement is <code class="literal">e8</code>. However, <code class="literal">f6 00 00 00</code> is obviously not <code class="literal">300</code>. At first glance, it appears that the machine code and assembly code don't match, but in fact, they do. In a <code class="literal">near call</code>, the address of the instruction after the <code class="literal">call</code> statement is saved on the stack, so that the called procedure knows where to return to. Thus, the machine code operand for a <code class="literal">call</code> statement is the address of the called procedure, minus the address of the instruction following the <code class="literal">call</code> statement (<code class="literal">0×300</code> – <code class="literal">0×20a</code> = <code class="literal">0xf6</code>). This explains why the machine code operand for <code class="literal">call</code> is <code class="literal">f6 00 00 00</code> in this example, not <code class="literal">00 03 00 00</code>. This is an important point that will come into play shortly.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="patching_call_statements"/>Patching Call Statements</h2></div></div></div><p>Going back to Listing 5-1, let's say that when we <code class="literal">nop</code> out the <code class="literal">for</code> loop, we also want <code class="literal">hello</code> to call <code class="literal">uprintf</code> instead of <code class="literal">printf</code>. The program in Listing 5-3 patches <code class="literal">hello</code> to do just that.<a id="IDX-CHP-5-0290" class="indexterm"/><a id="IDX-CHP-5-0291" class="indexterm"/></p><a id="I_programlisting5_d1e5432"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;
#include &lt;limits.h&gt;
#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;

#define SIZE    0x30

/* Replacement code. */
unsigned char nop_code[] =
        "\x90\x90";             /* nop          */

int
main(int argc, char *argv[])
{
        int i, jns_offset, call_offset;
        char errbuf[_POSIX2_LINE_MAX];
        kvm_t *kd;
        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, };
        unsigned char hello_code[SIZE], call_operand[4];

        /* Initialize kernel virtual memory access. */
        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);
        if (kd == NULL) {
                fprintf(stderr, "ERROR: %s\n", errbuf);
                exit(-1);
        }

        nl[0].n_name = "hello";
        nl[1].n_name = "uprintf";

        /* Find the address of hello and uprintf. */
        if (❶kvm_nlist(kd, nl) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (!nl[0].n_value) {
                fprintf(stderr, "ERROR: Symbol %s not found\n",
                    nl[0].n_name);
                exit(-1);
        }

        if (!nl[1].n_value) {
                fprintf(stderr, "ERROR: Symbol %s not found\n",
                    nl[1].n_name);
                exit(-1);
        }

        /* Save a copy of hello. */
        if (kvm_read(kd, nl[0].n_value, hello_code, SIZE) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }
        /* Search through hello for the jns and call instructions. */
        for (i = 0; i &lt; SIZE; i++) {
                if (hello_code[i] == 0x79)
                        jns_offset = i;
                if (hello_code[i] == 0xe8)
                        ❷call_offset = i;
        }

        /* Calculate the call statement operand. */
        *(unsigned long *)&amp;call_operand[0] = ❸nl[1].n_value -
            ❹(nl[0].n_value + call_offset + 5);

        /* Patch hello. */
        if (kvm_write(kd, nl[0].n_value + jns_offset, nop_code,
            sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (❺kvm_write(kd, nl[0].n_value + call_offset + 1, call_operand,
            sizeof(call_operand)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Close kd. */
        if (kvm_close(kd) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 5-3: fix_hello_improved.c</em></span></p><p>Notice how <code class="literal">hello</code> is patched to invoke <code class="literal">uprintf</code> instead of <code class="literal">printf</code>. First, the addresses of <code class="literal">hello</code> and <code class="literal">uprintf</code> are ❶ stored in <code class="literal">nl[0].n_value</code> and <code class="literal">nl[1].n_value</code>, respectively. Next, the relative address of <code class="literal">call</code> within <code class="literal">hello</code> is ❷ stored in <code class="literal">call_offset</code>. Then, a new <code class="literal">call</code> statement operand is calculated by subtracting ❹ the address of the instruction following <code class="literal">call</code> from ❸ the address of <code class="literal">uprintf</code>. This value is stored in <code class="literal">call_operand[]</code>. Finally, the old <code class="literal">call</code> statement operand is ❺ overwritten with <code class="literal">call_operand[]</code>.</p><p>The following output shows the results of executing <code class="literal">hello</code>, before and after running <code class="literal">fix_hello_improved</code> on ttyv1:</p><a id="I_programlisting5_d1e5497"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./hello.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>perl -e 'syscall(210);'</code></strong>
$ <strong class="userinput"><code>gcc -o fix_hello_improved fix_hello_improved.c -lkvm</code></strong>
$ <strong class="userinput"><code>sudo ./fix_hello_improved</code></strong>
$ <strong class="userinput"><code>perl -e 'syscall(210);'</code></strong>
FreeBSD Rocks!
</pre><p>Success! At this point, you should have no trouble patching any kernel code byte. However, what happens when the patch you want to apply is too big and will overwrite nearby instructions that you require? The answer is . . .</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="allocating_kernel_memory"/>Allocating Kernel Memory</h1></div></div></div><p>In this section I'll describe a set of core functions and macros used to allocate and deallocate kernel memory. We'll put these functions to use later on, when we explicitly solve the problem outlined above.<a id="IDX-CHP-5-0292" class="indexterm"/><a id="IDX-CHP-5-0293" class="indexterm"/><a id="IDX-CHP-5-0294" class="indexterm"/><a id="IDX-CHP-5-0295" class="indexterm"/><a id="IDX-CHP-5-0296" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_malloc_function"/>The malloc Function</h2></div></div></div><p>The <code class="literal">malloc</code> function allocates a specified number of bytes of memory in kernel space. If successful, a kernel virtual address (that is suitably aligned for storage of any data object) is returned. If an error is encountered, <code class="literal">NULL</code> is returned instead.<a id="IDX-CHP-5-0297" class="indexterm"/></p><p>Here is the function prototype for <code class="literal">malloc</code>:</p><a id="I_programlisting5_d1e5576"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/malloc.h&gt;

void *
malloc(unsigned long size, struct malloc_type *type, int flags);
</pre><p>The following is a brief description of each parameter.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">size</code></span></dt><dd><p>This specifies the amount of uninitialized kernel memory to allocate.</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>This parameter is used to perform statistics on memory usage and for basic sanity checks. (Memory statistics can be viewed by running the command <code class="literal">vmstat -m</code>.) Typically, I'll set this parameter to <code class="literal">M_TEMP</code>, which is the <code class="literal">malloc_type</code> for miscellaneous temporary data buffers.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For more on <em class="replaceable"><code>struct malloc_type</code></em>, see the malloc(9) manual page.</p></div><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>flags</code></strong></span></dt><dd><p>This parameter further qualifies <code class="literal">malloc</code>'s operational characteristics. It can be set to any of the following values:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>M_ZERO</code></strong></span></dt><dd><p>This causes the allocated memory to be set to zero.</p></dd><dt><span class="term"><strong class="userinput"><code>M_NOWAIT</code></strong></span></dt><dd><p>This causes <code class="literal">malloc</code> to return <code class="literal">NULL</code> if the allocation request cannot be fulfilled immediately. This flag should be set when calling <code class="literal">malloc</code> in an interrupt context.</p></dd><dt><span class="term"><strong class="userinput"><code>M_WAITOK</code></strong></span></dt><dd><p>This causes <code class="literal">malloc</code> to sleep and wait for resources if the allocation request cannot be fulfilled immediately. If this flag is set, <code class="literal">malloc</code> cannot return <code class="literal">NULL</code>.</p></dd></dl></div></dd></dl></div><p>Either <code class="literal">M_NOWAIT</code> or <code class="literal">M_WAITOK</code> must be specified.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_malloc_macro"/>The MALLOC Macro</h2></div></div></div><p>For compatibility with legacy code, the <code class="literal">malloc</code> function is called with the <code class="literal">MALLOC</code> macro, which is defined as follows:<a id="IDX-CHP-5-0298" class="indexterm"/></p><a id="I_programlisting5_d1e5685"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/malloc.h&gt;

MALLOC(space, cast, unsigned long size, struct malloc_type *type, int flags);
</pre><p>This macro is functionally equivalent to:</p><a id="I_programlisting5_d1e5689"/><pre class="programlisting">
(space) = (cast)malloc((u_long)(size), type, flags)
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_free_function"/>The free Function</h2></div></div></div><p>To deallocate kernel memory that was previously allocated by <code class="literal">malloc</code>, call the <code class="literal">free</code> function.<a id="IDX-CHP-5-0299" class="indexterm"/></p><a id="I_programlisting5_d1e5707"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/malloc.h&gt;

void
free(void *addr, struct malloc_type *type);
</pre><p>Here, <code class="literal">addr</code> is the memory address returned by a previous <code class="literal">malloc</code> call, and <code class="literal">type</code> is its associated <code class="literal">malloc_type</code>.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_free_macro"/>The FREE Macro</h2></div></div></div><p>For compatibility with legacy code, the <code class="literal">free</code> function is called with the <code class="literal">FREE</code> macro, which is defined as follows:<a id="IDX-CHP-5-0300" class="indexterm"/></p><a id="I_programlisting5_d1e5739"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/malloc.h&gt;

FREE(void *addr, struct malloc_type *type);
</pre><p>This macro is functionally equivalent to:</p><a id="I_programlisting5_d1e5743"/><pre class="programlisting">
free((addr), type)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>At some point in 4BSD's history, part of its <em class="replaceable"><code>malloc</code></em> algorithm was inline in a macro, which is why there is a <em class="replaceable"><code>MALLOC</code></em> macro in addition to a function call.<sup>[<a id="CHP-5-FN-1" href="#ftn.CHP-5-FN-1" class="footnote">1</a>]</sup> However, FreeBSD's <em class="replaceable"><code>malloc</code></em> algorithm is just a function call. Thus, unless you are writing legacy-compatible code, the use of the <em class="replaceable"><code>MALLOC</code></em> and <em class="replaceable"><code>FREE</code></em> macros is discouraged.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id6"/>Example</h2></div></div></div><p>Listing 5-4 shows a system call module designed to allocate kernel memory. The system call is invoked with two arguments: a long integer containing the amount of memory to allocate and a long integer pointer to store the returned address.<a id="IDX-CHP-5-0301" class="indexterm"/></p><a id="I_programlisting5_d1e5780"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/malloc.h&gt;

struct kmalloc_args {
        unsigned long size;
        unsigned long *addr;
};

/* System call to allocate kernel virtual memory. */
static int
kmalloc(struct thread *td, void *syscall_args)
{
        struct kmalloc_args *uap;
        uap = (struct kmalloc_args *)syscall_args;

        int error;
        unsigned long addr;

        ❶MALLOC(addr, unsigned long, uap-&gt;size, M_TEMP, M_NOWAIT);
        ❷error = copyout(&amp;addr, uap-&gt;addr, sizeof(addr));

        return(error);
}

/* The sysent for the new system call. */
static struct sysent kmalloc_sysent = {
        2,                      /* number of arguments */
        kmalloc                 /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;
/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);
}

SYSCALL_MODULE(kmalloc, &amp;offset, &amp;kmalloc_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 5-4: kmalloc.c</em></span></p><p>As you can see, this code simply ❶ calls the <code class="literal">MALLOC</code> macro to allocate <code class="literal">uap-&gt;size</code> amount of kernel memory, and then ❷ copies out the returned address to user space.</p><p>Listing 5-5 is the user space program designed to execute the system call above.</p><a id="I_programlisting5_d1e5795"/><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;

int
main(int argc, char *argv[])
{
        int syscall_num;
        struct module_stat stat;

        unsigned long addr;

        if (argc != 2) {
                printf("Usage:\n%s &lt;size&gt;\n", argv[0]);
                exit(0);
        }

        stat.version = sizeof(stat);
        modstat(modfind("kmalloc"), &amp;stat);
        syscall_num = stat.data.intval;
        syscall(syscall_num, (unsigned long)atoi(argv[1]), &amp;addr);
        printf("Address of allocated kernel memory: 0x%x\n", addr);

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 5-5: interface.c</em></span></p><p>This program uses the <code class="literal">modstat</code>/<code class="literal">modfind</code> approach (described in <a class="xref" href="ch01.html" title="Chapter 1. LOADABLE KERNEL MODULES">Chapter 1</a>) to pass the first command-line argument to <code class="literal">kmalloc</code>; this argument should contain the amount of kernel memory to allocate. It then outputs the kernel virtual address where the recently allocated memory is located.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-1" href="#CHP-5-FN-1" class="para">1</a>] </sup><sup>1</sup> John Baldwin, personal communication, 2006–2007.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="allocating_kernel_memory_from_user_space"/>Allocating Kernel Memory from User Space</h1></div></div></div><p>Now that you've seen how to "properly" allocate kernel memory using module code, let's do it using run-time kernel memory patching. Here is the algorithm (Cesare, 1998, as cited in sd and devik, 2001) we'll be using:<a id="IDX-CHP-5-0302" class="indexterm"/><a id="IDX-CHP-5-0303" class="indexterm"/><a id="IDX-CHP-5-0304" class="indexterm"/><a id="IDX-CHP-5-0305" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Retrieve the in-memory address of the <code class="literal">mkdir</code> system call.</p></li><li class="listitem"><p>Save <code class="literal">sizeof(kmalloc)</code> bytes of <code class="literal">mkdir</code>.</p></li><li class="listitem"><p>Overwrite <code class="literal">mkdir</code> with <code class="literal">kmalloc</code>.</p></li><li class="listitem"><p>Call <code class="literal">mkdir</code>.</p></li><li class="listitem"><p>Restore <code class="literal">mkdir</code>.</p></li></ol></div><p>With this algorithm, you are basically patching a system call with your own code, issuing the system call (which will execute your code instead), and then restoring the system call. This algorithm can be used to execute any piece of code in kernel space without a KLD.</p><p>However, keep in mind that when you overwrite a system call, any process that issues or is currently executing the system call will break, resulting in a kernel panic. In other words, inherent to this algorithm is a race condition or concurrency issue.<a id="IDX-CHP-5-0306" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id7"/>Example</h2></div></div></div><p>Listing 5-6 shows a user space program designed to allocate kernel memory. This program is invoked with one command-line argument: an integer containing the number of bytes to allocate.</p><a id="I_programlisting5_d1e5889"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;
#include &lt;limits.h&gt;
#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
/* Kernel memory allocation (kmalloc) function code.
❶unsigned char kmalloc[] =
        "\x55"                          /* push   %ebp                  */
        "\xb9\x01\x00\x00\x00"          /* mov    $0x1,%ecx             */
        "\x89\xe5"                      /* mov    %esp,%ebp             */
        "\x53"                          /* push   %ebx                  */
        "\xba\x00\x00\x00\x00"          /* mov    $0x0,%edx             */
        "\x83\xec\x10"                  /* sub    $0x10,%esp            */
        "\x89\x4c\x24\x08"              /* mov    %ecx,0x8(%esp)        */
        "\x8b\x5d\x0c"                  /* mov    0xc(%ebp),%ebx        */
        "\x89\x54\x24\x04"              /* mov    %edx,0x4(%esp)        */
        "\x8b\x03"                      /* mov    (%ebx),%eax           */
        "\x89\x04\x24"                  /* mov    %eax,(%esp)           */
        "\xe8\xfc\xff\xff\xff"          /* call   4e2 &lt;kmalloc+0x22&gt;    */
        "\x89\x45\xf8"                  /* mov    %eax,0xfffffff8(%ebp) */
        "\xb8\x04\x00\x00\x00"          /* mov    $0x4,%eax             */
        "\x89\x44\x24\x08"              /* mov    %eax,0x8(%esp)        */
        "\x8b\x43\x04"                  /* mov    0x4(%ebx),%eax        */
        "\x89\x44\x24\x04"              /* mov    %eax,0x4(%esp)        */
        "\x8d\x45\xf8"                  /* lea    0xfffffff8(%ebp),%eax */
        "\x89\x04\x24"                  /* mov    %eax,(%esp)           */
        "\xe8\xfc\xff\xff\xff"          /* call   500 &lt;kmalloc+0x40&gt;    */
        "\x83\xc4\x10"                  /* add    $0x10,%esp            */
        "\x5b"                          /* pop    %ebx                  */
        "\x5d"                          /* pop    %ebp                  */
        "\xc3"                          /* ret                          */
        "\x8d\xb6\x00\x00\x00\x00";     /* lea    0x0(%esi),%esi        */

/*
 * The relative address of the instructions following the call statements
 * within kmalloc.
 */
#define OFFSET_1        0x26
#define OFFSET_2        0x44

int
main(int argc, char *argv[])
{

        int i;
        char errbuf[_POSIX2_LINE_MAX];
        kvm_t *kd;
        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, {NULL}, {NULL}, };
        unsigned char mkdir_code[sizeof(kmalloc)];
        unsigned long addr;

        if (argc != 2) {
                printf("Usage:\n%s &lt;size&gt;\n", argv[0]);
                exit(0);
        }

        /* Initialize kernel virtual memory access. */
        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);
        if (kd == NULL) {
                fprintf(stderr, "ERROR: %s\n", errbuf);
                exit(-1);
        }

        nl[0].n_name = "mkdir";
        nl[1].n_name = "M_TEMP";
        nl[2].n_name = "malloc";
        nl[3].n_name = "copyout";

        /* Find the address of mkdir, M_TEMP, malloc, and copyout. */
        if (kvm_nlist(kd, nl) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        for (i = 0; i &lt; 4; i++) {
                if (!nl[i].n_value) {
                        fprintf(stderr, "ERROR: Symbol %s not found\n",
                            nl[i].n_name);
                        exit(-1);
                }
        }

        /*
         * Patch the kmalloc function code to contain the correct addresses
         * for M_TEMP, malloc, and copyout.
         */
        *(unsigned long *)&amp;kmalloc[10] = nl[1].n_value;
        *(unsigned long *)&amp;kmalloc[34] = nl[2].n_value -
            (nl[0].n_value + OFFSET_1);
        *(unsigned long *)&amp;kmalloc[64] = nl[3].n_value -
            (nl[0].n_value + OFFSET_2);

        /* Save sizeof(kmalloc) bytes of mkdir. */
        if (kvm_read(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Overwrite mkdir with kmalloc. */
        if (kvm_write(kd, nl[0].n_value, kmalloc, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Allocate kernel memory. */
        syscall(136, (unsigned long)atoi(argv[1]), &amp;addr);
        printf("Address of allocated kernel memory: 0x%x\n", addr);

        /* Restore mkdir. */
        if (kvm_write(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Close kd. */
        if (kvm_close(kd) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 5-6: kmalloc_reloaded.c</em></span></p><p>In the preceding code, the ❶ <code class="literal">kmalloc</code> function code was generated by disassembling the <code class="literal">kmalloc</code> system call from Listing 5-4:</p><a id="I_programlisting5_d1e5902"/><pre class="programlisting">
$ <strong class="userinput"><code>objdump -dR ./kmalloc.ko</code></strong>

./kmalloc.ko:     file format elf32-i386-freebsd

Disassembly of section .text:

000004c0 &lt;kmalloc&gt;:
 4c0:   55                      push   %ebp
 4c1:   b9 01 00 00 00          mov    $0x1,%ecx
 4c6:   89 e5                   mov    %esp,%ebp
 4c8:   53                      push   %ebx
 4c9:   ba 00 00 00 00          mov    $0x0,%edx
                        ❶4ca: R_386_32   M_TEMP
 4ce:   83 ec 10                sub    $0x10,%esp
 4d1:   89 4c 24 08             mov    %ecx,0x8(%esp)
 4d5:   8b 5d 0c                mov    0xc(%ebp),%ebx
 4d8:   89 54 24 04             mov    %edx,0x4(%esp)
 4dc:   8b 03                   mov    (%ebx),%eax
 4de:   89 04 24                mov    %eax,(%esp)
 4e1:   e8 fc ff ff ff          call   4e2 &lt;kmalloc+0x22&gt;
                        ❷4e2: R_386_PC32 malloc
 4e6:   89 45 f8                mov    %eax,0xfffffff8(%ebp)
 4e9:   b8 04 00 00 00          mov    $0x4,%eax
 4ee:   89 44 24 08             mov    %eax,0x8(%esp)
 4f2:   8b 43 04                mov    0x4(%ebx),%eax
 4f5:   89 44 24 04             mov    %eax,0x4(%esp)
 4f9:   8d 45 f8                lea    0xfffffff8(%ebp),%eax
 4fc:   89 04 24                mov    %eax,(%esp)
 4ff:   e8 fc ff ff ff          call   500 &lt;kmalloc+0x40&gt;
                        ❸500: R_386_PC32 copyout
 504:   83 c4 10                add    $0x10,%esp
 507:   5b                      pop    %ebx
 508:   5d                      pop    %ebp
 509:   c3                      ret
 50a:   8d b6 00 00 00 00       lea    0x0(%esi),%esi
</pre><p>Notice how <code class="literal">objdump(1)</code> reports three instructions that require dynamic relocation. The first, at offset 10, is ❶ for the address of <code class="literal">M_TEMP</code>. The second, at offset 34, is ❷ for the <code class="literal">malloc</code> call statement operand. And the third, at offset 64, is ❸ for the <code class="literal">copyout</code> call statement operand.</p><p>In kmalloc_reloaded.c, we account for this in our <code class="literal">kmalloc</code> function code with the following five lines:</p><a id="I_programlisting5_d1e5926"/><pre class="programlisting">
        *(unsigned long *)&amp;kmalloc[10] = ❶nl[1].n_value;
        *(unsigned long *)&amp;kmalloc[34] = ❷nl[2].n_value -
            ❸(nl[0].n_value + OFFSET_1);
        *(unsigned long *)&amp;kmalloc[64] = ❹nl[3].n_value -
            ❺(nl[0].n_value + OFFSET_2);
</pre><p>Notice how <code class="literal">kmalloc</code> is patched at offset 10 with ❶ the address of <code class="literal">M_TEMP</code>. It is also patched at offsets 34 and 64 with ❷ the address of <code class="literal">malloc</code> minus ❸ the address of the instruction following the <code class="literal">malloc</code> call, and ❹ the address of <code class="literal">copyout</code> minus ❺ the address of the instruction following the <code class="literal">copyout</code> call, respectively.</p><p>The following output shows <code class="literal">kmalloc_reloaded</code> in action:</p><a id="I_programlisting5_d1e5955"/><pre class="programlisting">
$ <strong class="userinput"><code>gcc -o kmalloc_reloaded kmalloc_reloaded.c -lkvm</code></strong>
$ <strong class="userinput"><code>sudo ./kmalloc_reloaded 10</code></strong>
Address of allocated kernel memory: 0xc1bb91b0
</pre><p>To verify the kernel memory allocation, you can use a kernel-mode debugger like <code class="literal">ddb(4)</code>:</p><a id="I_programlisting5_d1e5968"/><pre class="programlisting">
KDB: enter: manual escape to debugger
[thread pid 13 tid 100003 ]
Stopped at      kdb_enter+0x2c: leave
db&gt; <strong class="userinput"><code>examine/x 0xc1bb91b0</code></strong>
0xc1bb91b0:     70707070
db&gt;
0xc1bb91b4:     70707070
db&gt;
0xc1bb91b8:     dead7070
</pre></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="inline_function_hooking"/>Inline Function Hooking</h1></div></div></div><p>Recall the problem posed at the end of <a class="xref" href="ch05s03.html#patching_call_statements" title="Patching Call Statements">Patching Call Statements</a>: What do you do when you want to patch some kernel code, but your patch is too big and will overwrite nearby instructions that you require? The answer is: You use an inline function hook.<a id="IDX-CHP-5-0311" class="indexterm"/><a id="IDX-CHP-5-0307" class="indexterm"/><a id="IDX-CHP-5-0308" class="indexterm"/><a id="IDX-CHP-5-0309" class="indexterm"/><a id="IDX-CHP-5-0310" class="indexterm"/></p><p>In general, an inline function hook places an unconditional jump within the body of a function to a region of memory under your control. This memory will contain the "new" code you want the function to execute, the code bytes that were overwritten by the unconditional jump, and an unconditional jump back to the original function. This will extend functionality while preserving original behavior. Of course, you don't have to preserve the original behavior.<a id="IDX-CHP-5-0312" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id8"/>Example</h2></div></div></div><p>In this section we'll patch the <code class="literal">mkdir</code> system call with an inline function hook so that it will output the phrase "Hello, world!\n" each time it creates a directory.<a id="IDX-CHP-5-0313" class="indexterm"/><a id="IDX-CHP-5-0314" class="indexterm"/></p><p>Now, let's take a look at the disassembly of <code class="literal">mkdir</code> to see where we should place the jump, which bytes we need to preserve, and where we should jump back to.</p><a id="I_programlisting5_d1e6027"/><pre class="programlisting">
$ <strong class="userinput"><code>nm /boot/kernel/kernel | grep mkdir</code></strong>
c04dfc00 T devfs_vmkdir
c06a84e0 t handle_written_mkdir
c05bfa10 T kern_mkdir
c05bfec0 T mkdir
c07d1f40 B mkdirlisthd
c04ef6a0 t msdosfs_mkdir
c06579e0 t nfs4_mkdir
c066a910 t nfs_mkdir
c067a830 T nfsrv_mkdir
c07515b6 r nfsv3err_mkdir
c06c32e0 t ufs_mkdir
c07b8d20 D vop_mkdir_desc
c05b77f0 T vop_mkdir_post
c07b8d44 d vop_mkdir_vp_offsets
$ <strong class="userinput"><code>objdump -d --start-address=0xc05bfec0 /boot/kernel/kernel</code></strong>

/boot/kernel/kernel:     file format elf32-i386-freebsd

Disassembly of section .text:

c05bfec0 &lt;mkdir&gt;:
c05bfec0:       55                      push   %ebp
c05bfec1:       89 e5                   mov    %esp,%ebp
c05bfec3:       83 ec 10                sub    $0x10,%esp
c05bfec6:       8b 55 0c                mov    0xc(%ebp),%edx
c05bfec9:       8b 42 04                mov    0x4(%edx),%eax
c05bfecc:       89 44 24 0c             mov    %eax,0xc(%esp)
c05bfed0:       31 c0                   xor    %eax,%eax
c05bfed2:       89 44 24 08             mov    %eax,0x8(%esp)
c05bfed6:       8b 02                   mov    (%edx),%eax
c05bfed8:       89 44 24 04             mov    %eax,0x4(%esp)
c05bfedc:       8b 45 08                mov    0x8(%ebp),%eax
c05bfedf:       89 04 24                mov    %eax,(%esp)
c05bfee2:       e8 29 fb ff ff          call   c05bfa10 &lt;kern_mkdir&gt;
c05bfee7:       c9                      leave
c05bfee8:       c3                      ret
c05bfee9:       8d b4 26 00 00 00 00    lea    0x0(%esi),%esi
</pre><p>Because I want to extend the functionality of <code class="literal">mkdir</code>, rather than change it, the best place for the unconditional jump is at the beginning. An unconditional jump requires seven bytes. If you overwrite the first seven bytes of <code class="literal">mkdir</code>, the first three instructions will be eliminated, and the fourth instruction (which starts at offset six) will be mangled. Therefore, we'll need to save the first four instructions (i.e., the first nine bytes) in order to preserve <code class="literal">mkdir</code>'s functionality; this also means that you should jump back to offset nine to resume execution from the fifth instruction.</p><p>Before committing to this plan, however, let's look at the disassembly of <code class="literal">mkdir</code> on a different machine.</p><a id="I_programlisting5_d1e6051"/><pre class="programlisting">
$ <strong class="userinput"><code>nm /boot/kernel/kernel | grep mkdir</code></strong>
c047c560 T devfs_vmkdir
c0620e40 t handle_written_mkdir
c0556ca0 T kern_mkdir
c0557030 T mkdir
c071d57c B mkdirlisthd
c048a3e0 t msdosfs_mkdir
c05e2ed0 t nfs4_mkdir
c05d8710 t nfs_mkdir
c05f9140 T nfsrv_mkdir
c06b4856 r nfsv3err_mkdir
c063a670 t ufs_mkdir
c0702f40 D vop_mkdir_desc
c0702f64 d vop_mkdir_vp_offsets
$ <strong class="userinput"><code>objdump -d --start-address=0xc0557030 /boot/kernel/kernel</code></strong>

/boot/kernel/kernel:     file format elf32-i386-freebsd

Disassembly of section .text:

c0557030 &lt;mkdir&gt;:
c0557030:       55                      push   %ebp
c0557031:       31 c9                   xor    %ecx,%ecx
c0557033:       89 e5                   mov    %esp,%ebp
c0557035:       83 ec 10                sub    $0x10,%esp
c0557038:       8b 55 0c                mov    0xc(%ebp),%edx
c055703b:       8b 42 04                mov    0x4(%edx),%eax
c055703e:       89 4c 24 08             mov    %ecx,0x8(%esp)
c0557042:       89 44 24 0c             mov    %eax,0xc(%esp)
c0557046:       8b 02                   mov    (%edx),%eax
c0557048:       89 44 24 04             mov    %eax,0x4(%esp)
c055704c:       8b 45 08                mov    0x8(%ebp),%eax
c055704f:       89 04 24                mov    %eax,(%esp)
c0557052:       e8 49 fc ff ff          call   c0556ca0 &lt;kern_mkdir&gt;
c0557057:       c9                      leave
c0557058:       c3                      ret
c0557059:       8d b4 26 00 00 00 00    lea    0x0(%esi),%esi
</pre><p>Notice how the two disassemblies are quite different. In fact, this time around the fifth instruction starts at offset eight, not nine. If the code were to jump back to offset nine, it would most definitely crash this system. What this boils down to is that when writing an inline function hook, in general, you'll have to avoid using hard-coded offsets if you want to apply the hook to a wide range of systems.</p><p>Looking back at the two disassemblies, notice how <code class="literal">mkdir</code> calls <code class="literal">kern_mkdir</code> every time. Therefore, we can jump back to that (i.e., 0xe8). In order to preserve <code class="literal">mkdir</code>'s functionality, we'll now have to save every byte up to, but not including, 0xe8.</p><p>Listing 5-7 shows my <code class="literal">mkdir</code> inline function hook.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>To save space, the <code class="literal">kmalloc</code> function code is omitted.</p></div><a id="I_programlisting5_d1e6084"/><pre class="programlisting">
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;
#include &lt;limits.h&gt;
#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;

/* Kernel memory allocation (kmalloc) function code. */
unsigned char kmalloc[] =
. . .

/*
 * The relative address of the instructions following the call statements
 * within kmalloc.
 */
#define K_OFFSET_1      0x26
#define K_OFFSET_2      0x44

/* "Hello, world!\n" function code. */
❶unsigned char hello[] =
        "\x48"                          /* H                            */
        "\x65"                          /* e                            */
        "\x6c"                          /* l                            */
        "\x6c"                          /* l                            */
        "\x6f"                          /* o                            */
        "\x2c"                          /* ,                            */
        "\x20"                          /*                              */
        "\x77"                          /* w                            */
        "\x6f"                          /* o                            */
        "\x72"                          /* r                            */
        "\x6c"                          /* l                            */
        "\x64"                          /* d                            */
        "\x21"                          /* !                            */
        "\x0a"                          /* \n                           */
        "\x00"                          /* NULL                         */
        "\x55"                          /* push   %ebp                  */
        "\x89\xe5"                      /* mov    %esp,%ebp             */
        "\x83\xec\x04"                  /* sub    $0x4,%esp             */
        "\xc7\x04\x24\x00\x00\x00\x00"  /* movl   $0x0,(%esp)           */
        "\xe8\xfc\xff\xff\xff"          /* call   uprintf               */
        "\x31\xc0"                      /* xor    %eax,%eax             */
        "\x83\xc4\x04"                  /* add    $0x4,%esp             */
        "\x5d";                         /* pop    %ebp                  */
/*
 * The relative address of the instruction following the call uprintf
 * statement within hello.
 */
#define H_OFFSET_1      0x21

/* Unconditional jump code. */
unsigned char jump[] =
        "\xb8\x00\x00\x00\x00"          /* movl   $0x0,%eax             */
        "\xff\xe0";                     /* jmp    *%eax                 */

int
main(int argc, char *argv[])
{
        int i, call_offset;
        char errbuf[_POSIX2_LINE_MAX];
        kvm_t *kd;
        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, {NULL}, {NULL},
            {NULL}, };
        unsigned char mkdir_code[sizeof(kmalloc)];
        unsigned long addr, size;

        /* Initialize kernel virtual memory access. */
        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);
        if (kd == NULL) {
                fprintf(stderr, "ERROR: %s\n", errbuf);
                exit(-1);
        }

        nl[0].n_name = "mkdir";
        nl[1].n_name = "M_TEMP";
        nl[2].n_name = "malloc";
        nl[3].n_name = "copyout";
        nl[4].n_name = "uprintf";

        /*
         * Find the address of mkdir, M_TEMP, malloc, copyout,
         * and uprintf.
         */
        if (kvm_nlist(kd, nl) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        for (i = 0; i &lt; 5; i++) {
                if (!nl[i].n_value) {
                        fprintf(stderr, "ERROR: Symbol %s not found\n",
                            nl[i].n_name);
                        exit(-1);
                }
        }

        /* Save sizeof(kmalloc) bytes of mkdir. */
        if (kvm_read(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }
        /* Search through mkdir for call kern_mkdir. */
        for (i = 0; i &lt; sizeof(kmalloc); i++) {
                if (mkdir_code[i] == 0xe8) {
                        call_offset = i;
                        break;
                }
        }

        /* Determine how much memory you need to allocate. */
        size = (unsigned long)sizeof(hello) + (unsigned long)call_offset +
            (unsigned long)sizeof(jump);

        /*
         * Patch the kmalloc function code to contain the correct addresses
         * for M_TEMP, malloc, and copyout.
         */
        *(unsigned long *)&amp;kmalloc[10] = nl[1].n_value;
        *(unsigned long *)&amp;kmalloc[34] = nl[2].n_value -
            (nl[0].n_value + K_OFFSET_1);
        *(unsigned long *)&amp;kmalloc[64] = nl[3].n_value -
            (nl[0].n_value + K_OFFSET_2);

        /* Overwrite mkdir with kmalloc. */
        if (kvm_write(kd, nl[0].n_value, kmalloc, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Allocate kernel memory. */
        syscall(136, size, &amp;addr);

        /* Restore mkdir. */
        if (kvm_write(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /*
         * Patch the "Hello, world!\n" function code to contain the
         * correct addresses for the "Hello, world!\n" string and uprintf.
         */
        *(unsigned long *)&amp;hello[24] = addr;
        *(unsigned long *)&amp;hello[29] = nl[4].n_value - (addr + H_OFFSET_1);

        /*
         * Place the "Hello, world!\n" function code into the recently
         * allocated kernel memory.
         */
        if (kvm_write(kd, addr, hello, sizeof(hello)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /*
         * Place all the mkdir code up to but not including call kern_mkdir
         * after the "Hello, world!\n" function code.
         */
        if (kvm_write(kd, addr + (unsigned long)sizeof(hello) - 1,
            mkdir_code, call_offset) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /*
         * Patch the unconditional jump code to jump back to the call
         * kern_mkdir statement within mkdir.
         */
        *(unsigned long *)&amp;jump[1] = nl[0].n_value +
            (unsigned long)call_offset;

        /*
         * Place the unconditional jump code into the recently allocated
         * kernel memory, after the mkdir code.
         */
        if (kvm_write(kd, addr + (unsigned long)sizeof(hello) - 1 +
            (unsigned long)call_offset, jump, sizeof(jump)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /*
         * Patch the unconditional jump code to jump to the start of the
         * "Hello, world!\n" function code.
         */
        ❷*(unsigned long *)&amp;jump[1] = addr + 0x0f;

        /*
         * Overwrite the beginning of mkdir with the unconditional
         * jump code.
         */
        if (kvm_write(kd, nl[0].n_value, jump, sizeof(jump)) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Close kd. */
        if (kvm_close(kd) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 5-7: mkdir_patch.c</em></span></p><p>As you can see, employing an inline function hook is relatively straightforward (although it's somewhat lengthy). In fact, the only piece of code you haven't seen before is ❶ the <code class="literal">"Hello, world!\n"</code> function code. It is rather simplistic, but there are two important points about it.</p><p>First, notice how the first 15 bytes of <code class="literal">hello</code> are actually data; to be exact, these bytes make up the string <code class="literal">Hello, world!\n</code>. The actual assembly language instructions don't start until offset 15. This is why the unconditional jump code, which overwrites <code class="literal">mkdir</code>, is ❷ set to <code class="literal">addr + 0x0f</code>.</p><p>Second, note <code class="literal">hello</code>'s final three instructions. The first zeros out the <code class="literal">%eax</code> register, the second cleans up the stack, and the last restores the <code class="literal">%ebp</code> register. This is done so that when <code class="literal">mkdir</code> actually begins executing, it's as if the hook never happened.</p><p>The following output shows <code class="literal">mkdir_patch</code> in action:</p><a id="I_programlisting5_d1e6127"/><pre class="programlisting">
$ <strong class="userinput"><code>gcc -o mkdir_patch mkdir_patch.c -lkvm</code></strong>
$ <strong class="userinput"><code>sudo ./mkdir_patch</code></strong>
$ <strong class="userinput"><code>mkdir TESTING</code></strong>
Hello, world!
$ <strong class="userinput"><code>ls -F</code></strong>
TESTING/       mkdir_patch*   mkdir_patch.c
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="gotchas"/>Gotchas</h2></div></div></div><p>Because mkdir_patch.c is a simple example, it fails to reveal some typical gotchas associated with inline function hooking.</p><p>First, by placing an unconditional jump within the body of a function, whose behavior you intend to preserve, there is a good chance that you'll cause a kernel panic. This is because the unconditional jump code requires the use of a general-purpose register; however, it is likely that within the body of a function, all the general-purpose registers will already be in use. To get around this, push the register you are going to use onto the stack before jumping, and then pop it off after.<a id="IDX-CHP-5-0315" class="indexterm"/></p><p>Second, if you copy a <code class="literal">call</code> or jump statement and place it into a different region of memory, you can't execute it as is; you have to adjust its operand first. This is because a <code class="literal">call</code> or jump statement's machine code operand is a relative address.</p><p>Finally, it's possible for your code to be preempted while patching, and during that time, your target function may execute in its incomplete state. Therefore, if possible, you should avoid patching with multiple writes.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="cloaking_system_call_hooks"/>Cloaking System Call Hooks</h1></div></div></div><p>Before concluding this chapter, let's take a brief look at a nontrivial application for run-time kernel memory patching: cloaking system call hooks. That is, implementing a system call hook without patching the system call table or any system call function. This is achieved by patching the system call dispatcher with an inline function hook so it references a Trojan system call table instead of the original. This renders the original table functionless, but maintains its integrity, enabling the Trojan table to direct system call requests to any handler you like.<a id="IDX-CHP-5-0318" class="indexterm"/><a id="IDX-CHP-5-0316" class="indexterm"/><a id="IDX-CHP-5-0317" class="indexterm"/></p><p>Because the code to do this is rather lengthy (it's longer than mkdir_patch.c), I'll simply explain how it's done and leave the actual code to you.</p><p>The system call dispatcher in FreeBSD is <code class="literal">syscall</code>, which is implemented in the file /sys/i386/i386/trap.c as follows.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the interest of saving space, any code irrelevant to this discussion is omitted.</p></div><a id="I_programlisting5_d1e6191"/><pre class="programlisting">
void
syscall(frame)
        struct trapframe frame;
{
        caddr_t params;
        struct sysent *callp;
        struct thread *td = curthread;
        struct proc *p = td-&gt;td_proc;
        register_t orig_tf_eflags;
        u_int sticks;
        int error;
        int narg;
        int args[8];
        u_int code;
. . .
        if (code &gt;= p-&gt;p_sysent-&gt;sv_size)
                callp = &amp;p-&gt;p_sysent-&gt;sv_table[0];
        else
                ❶callp = &amp;p-&gt;p_sysent-&gt;sv_table[code];
. . .
}
</pre><p>In <code class="literal">syscall</code>, line ❶ references the system call table and stores the address of the system call to be dispatched into <code class="literal">callp</code>. Here is what this line looks like disassembled:</p><a id="I_programlisting5_d1e6201"/><pre class="programlisting">
 486:   64 a1 00 00 00 00       mov    %fs:0x0,%eax
 48c:   8b 00                   mov    (%eax),%eax
 48e:   8b 80 a0 01 00 00       mov    0x1a0(%eax),%eax
 494:   8b 40 04                mov    0x4(%eax),%eax
</pre><p>The first instruction loads <code class="literal">curthread</code>, the currently running thread (i.e., the <code class="literal">%fs</code> segment register), into <code class="literal">%eax</code>. The first field in a <code class="literal">thread</code> structure is a pointer to its associated <code class="literal">proc</code> structure; hence, the second instruction loads the current process into <code class="literal">%eax</code>. The next instruction loads <code class="literal">p_sysent</code> into <code class="literal">%eax</code>. This can be verified, as the <code class="literal">p_sysent</code> field (which is a <code class="literal">sysentvec</code> pointer) is located at an offset of 0x1a0 within a <code class="literal">proc</code> structure. The last instruction loads the system call table into <code class="literal">%eax</code>. This can be verified, as the <code class="literal">sv_table</code> field is located at an offset of 0x4 within a <code class="literal">sysentvec</code> structure. This last line is the one you'll need to scan for and patch. However, be aware that, depending on the system, the system call table can be loaded into a different general-purpose register.</p><p>Also, after Trojaning the system call table, any system call modules that are loaded won't work. However, since you now control the system calls responsible for loading a module, this can be fixed.</p><p>That's about it! All you really need to do is patch one spot. Of course, the devil is in the details. (In fact, all the gotchas I listed in <a class="xref" href="ch05s06.html#gotchas" title="Gotchas">Gotchas</a> are a direct result of trying to patch that one spot.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you Trojan your own system call table, you'll null the effects of traditional system call hooking. In other words, this technique of cloaking system calls can be applied defensively.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="concluding_remarks-id5"/>Concluding Remarks</h1></div></div></div><p>Run-time kernel memory patching is one of the strongest techniques for modifying software logic. Theoretically, you can use it to rewrite the entire operating system on the fly. Furthermore, it's somewhat difficult to detect, depending on where you place your patches and whether or not you use inline function hooks.</p><p>At the time of this writing, a technique to cloak run-time kernel memory patching has been published. See "Raising The Bar For Windows Rootkit Detection" by Jamie Butler and Sherri Sparks, published in <span class="emphasis"><em>Phrack</em></span> magazine, issue 63. Although this article is written from a Windows perspective, the theory can be applied to any <span class="emphasis"><em>x</em></span>86 operating system.<a id="IDX-CHP-5-0319" class="indexterm"/></p><p>Finally, like most rootkit techniques, run-time kernel memory patching has legitimate uses. For example, Microsoft calls it <span class="emphasis"><em>hot patching</em></span> and uses it to patch systems without requiring a reboot.<a id="IDX-CHP-5-0320" class="indexterm"/></p></div></body></html>