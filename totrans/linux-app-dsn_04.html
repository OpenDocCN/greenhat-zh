<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page43"/><img src="../images/67-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter4"/><a href="toc.html#chapter4"><b>BUILDING AND SECURING DAEMONS</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">At the heart of almost all Linux appliances is one or more daemons, the background programs that provide a network or system service. You can get an idea of the daemons available on your Linux system by looking in the /etc/ rc.d/init.d directory or by using the ps ax command to show the daemons you have running on your system.</p>&#13;
<p class="indent1">The term <i>daemon</i> refers to a program that runs in the background without a controlling terminal. Daemons also run in their own process group in order to avoid inadvertently receiving signals meant for other processes. A daemon usually redirects standard input, output, and error to /dev/null or to a log file. Many daemons use a Process ID file (or pidfile) to enforce mutual exclusion to a resource; this prevents more than one copy of the daemon from running at the same time.</p>&#13;
<p class="indent"><a id="page44"/>This chapter shows you how to build and secure the daemons you’ll be using in your appliances. It’s divided into three main sections.</p>&#13;
<ul>&#13;
<li>How to Build a Daemon</li>&#13;
<li>How to Secure a Daemon</li>&#13;
<li>A Prototype Daemon</li>&#13;
</ul>&#13;
<p class="secl"><a id="chapter4.1"/><a href="toc.html#chapter4.1"><b>How to Build a Daemon</b></a></p>&#13;
<p class="noindent">This section shows you how to build a daemon and offers a brief explanation of why each step is needed. Your application may not require all of the steps listed, and you may need to do them in a different order to meet your needs, but this will give you a general idea, nonetheless.</p>&#13;
<ol>&#13;
<li>Load the configuration.</li>&#13;
<li>Go into the background.</li>&#13;
<li>Become the process and session leader.</li>&#13;
<li>Set the working directory.</li>&#13;
<li>Redirect stdin, stdout, and stderr.</li>&#13;
<li>Set up logging.</li>&#13;
<li>Set group IDs and user IDs.</li>&#13;
<li>Check for a pidfile.</li>&#13;
<li>Set the umask.</li>&#13;
<li>Set up signal handlers.</li>&#13;
</ol>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>The sample daemon presented later in this chapter includes code for each of these steps. Some of the following sections use code taken from the sample daemon.</i></p>&#13;
<p class="secs"><a id="chapter4.2"/><a href="toc.html#chapter4.2"><i><b>Load the Daemon’s Configuration</b></i></a></p>&#13;
<p class="noindent">When a daemon starts, it needs to load a set of parameters that govern its operation. This usually means parsing options on the command line and reading settings from a configuration file.</p>&#13;
<p class="indent">The command line used to start the daemon often contains entries such as the location of the configuration file, the user and group IDs to use while running, and whether or not the program should become a daemon or stay as a foreground process. Some daemons let you specify the daemon’s working directory as well as whether or not to do a chroot() before starting.</p>&#13;
<p class="indent">There is a precedence to the configuration information. Specifically, compiled-in values are always loaded first, since they are loaded when the program starts. Next, the configuration values from the configuration file are loaded, overwriting the compiled-in values. Finally, the values from the command line are loaded, overwriting the values from the configuration file.</p>&#13;
<p class="indent">Compiled-in values should focus more on security than functionality, since an attacker might delete or modify the configuration file as part of a break in. As a security precaution, some daemons refuse to run if they cannot open and load a configuration file.</p>&#13;
<p class="indent"><a id="page45"/>Since the configuration file is often specified on the command line, your program may need to make two passes through it: once to get the configuration file and a second time to parse the command line again after the configuration file has been loaded. Parameters on the command line are often used while debugging, so their values normally override those in the configuration file.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>Make sure your program does a sanity check by verifying the consistency of the configuration and that it reports errors or exits if any problems are found.</i></p>&#13;
<p class="secs"><a id="chapter4.3"/><a href="toc.html#chapter4.3"><i><b>Go into the Background</b></i></a></p>&#13;
<p class="noindent">Once the configuration is loaded, the next step is for the process to (optionally) go into the background, where it can detach itself from the controlling terminal. This is achieved by calling the fork() function to create a child process. The parent process should exit after the fork.</p>&#13;
<p class="indent">In order to go into the background, the child process closes the file descriptors of the controlling terminal. The result is that we have a <i>background process</i> that is not attached to a controlling terminal.</p>&#13;
<p class="indent">Your code might look like this example in which the parent process forks and exits, leaving the child process to continue setting up the daemon:</p>&#13;
<p class="imgl"><img src="../images/69-1.jpg" alt=""/></p>&#13;
<p class="indent">There are two times when you should not send your process into the background: when debugging (since you want your terminal to remain the controlling terminal for the program so that you see any diagnostic messages and can kill the program if you need to), and when you want to automatically respawn your program if it dies. In the latter case, the daemon should remain in the foreground so that the parent process will receive control when the daemon exits (whether gracefully or due to some error).</p>&#13;
<p class="indent">The following example shell script shows how you can automatically respawn a daemon.</p>&#13;
<p class="imgl"><img src="../images/69-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page46"/>Two common alternatives to a shell script monitor are to add your daemon to /etc/inittab and let the init process respawn it, or to write a custom monitor program to respawn the various daemons on the appliance. The /etc/inittab approach might save memory and a few entries in the process table, and you don’t need to write any new software. The script to respawn mydaemon could be replaced with a single line in /etc/inittab. If the default runlevel is 3, the line might appear as:</p>&#13;
<p class="ex">ap:3:respawn:/usr/local/bin/mydaemon</p>&#13;
<p class="indent">The word <i>respawn</i> tells the init program to restart mydaemon if it dies.</p>&#13;
<p class="secs"><a id="chapter4.4"/><a href="toc.html#chapter4.4"><i><b>Become the Process and Session Leader</b></i></a></p>&#13;
<p class="noindent">The Linux kernel assigns each process to a process group and to a session, both of which are used in the distribution of signals. In a <i>session,</i> all the processes are typically started from an xterm window or from a virtual console login. In a <i>process group,</i> all the processes are started in a command-line pipe. Each session has only one process group that receives input from the controlling terminal; that process group is called the <i>foreground process group.</i></p>&#13;
<p class="indent">For example, open an xterm or log in to a virtual console, and enter these commands:</p>&#13;
<p class="ex">cat | sort | uniq | tr a d &amp;<br/>cat | sort | uniq | tr a d</p>&#13;
<p class="indent">From another xterm or console, the output of ps xj might appear as:</p>&#13;
<p class="imgl"><img src="../images/70-1.jpg" alt=""/></p>&#13;
<p class="indent">All of the processes from the first command line will appear in a process group with <img src="../images/1.jpg" alt=""/> the cat process (PID 5327 in the above example) as the process leader.</p>&#13;
<p class="indent">Now look at the Process Group ID (PGID) column in the output of ps xj. All of the programs on each command line have the PGID set to the PID of the cat command that starts the command line. All the commands for the first line have a PGID of 5327, and all the commands for the second line have a PGID of 5331. The second command <img src="../images/2.jpg" alt=""/>, the one you did not put into the background, is the foreground process group for the session, so its PID (5331) is the Session Group ID (TPGID) for all of the processes running in the xterm session. Recall that the session leader (5331 in this example) is the process that gets standard input from the terminal (hence the term Terminal Process Group ID, TPGID).</p>&#13;
<p class="indent"><a id="page47"/>The reason for having separate IDs for the process group and session is that if you kill a process group, you want the kernel to send the TERM signal to all of the processes in the group. The same is true if you want to kill the processes in a session.</p>&#13;
<p class="indent">We don’t want a daemon to receive signals that were not meant for it, and so we want the daemon to be in its own session and its own process group. Here is code that shows how to use setsid() to make your daemon a session and process group leader:</p>&#13;
<p class="imgl"><img src="../images/71-1.jpg" alt=""/></p>&#13;
<p class="indent">As an exercise, you might try typing the ps jax command and examining the sessions, process groups, and foreground process groups for the daemons running on your system. You should be able to tell which processes belong to the different session and process groups.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>As a security precaution, do another fork() after calling setsid() and have the parent exit immediately, leaving the child to continue as the daemon. This removes the session leader status of the daemon in such a way that it can never regain a controlling terminal.</i></p>&#13;
<p class="secs"><a id="chapter4.5"/><a href="toc.html#chapter4.5"><i><b>Set the Working Directory</b></i></a></p>&#13;
<p class="noindent">Daemons traditionally use the root directory, /, as the working directory. This allows the daemon to continue working even if most other filesystems are unmounted. Using the root directory also makes it easier to put your daemon into a chroot jail for added security. (Chroot jails are described in “Chroot if Possible” on page 59.)</p>&#13;
<p class="indent">Some daemons let you specify the working directory in the configuration file or on the command line. Whether you use the root directory, the /tmp directory, or a value from the configuration file, you should be deliberate in specifying the working directory of your daemon.</p>&#13;
<p class="indent">Use chdir() to set the working directory of your daemon.</p>&#13;
<p class="secs"><a id="chapter4.6"/><a href="toc.html#chapter4.6"><i><b>Redirect stdin, stdout, and stderr</b></i></a></p>&#13;
<p class="noindent">To remove itself from the controlling terminal, a daemon redirects the stdin, stdout, and stderr file descriptors by closing and then reopening them (usually to the /dev/null device). A daemon inherits all of the open file descriptors of the parent. For this reason, many daemons loop through all possible file descriptors and close each one. You can get the maximum number of file descriptors from OPEN_MAX at compile time or from mx = getdtablesize(); at run time.</p>&#13;
<p class="indent"><a id="page48"/>Once you’ve closed all open files, it is good practice to reopen stdin, stdout, and stderr; some libraries write to stderr, and therefore stderr should be initialized with a valid file descriptor. Instead of using /dev/null, some daemons open a log file as stderr.</p>&#13;
<p class="indent">The following code redirects these three file descriptors by closing them and then reopening them to the /dev/null device. The code also closes all file descriptors up to the maximum returned from getdtablesize().</p>&#13;
<p class="imgl"><img src="../images/72-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter4.7"/><a href="toc.html#chapter4.7"><i><b>Set Up Logging</b></i></a></p>&#13;
<p class="noindent">Your daemon should report errors and other events of interest. While you are working on the daemon, you will want to see debugging information, and you may want to record your daemon’s activity when it is in operation. Logging can fill all of these needs.</p>&#13;
<p class="indent">The three common destinations for log messages are syslog, stderr, and a log file. It is fairly common to see debugging information directed to stderr, errors directed to syslog, and activity logs put into files.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>If you save log files to a local disk, you should probably run crond and have logrotate delete old log files. Be sure to add any custom log files to logrotate’s configuration.</i></p>&#13;
<p class="indent1">If you’re building a network appliance, you may want to send both errors and usage logs to syslog, then configure syslog to send log messages to a log host on the network instead of saving them in local disk files. This helps minimize your appliance’s disk requirements and, since all log message are saved on one host, makes it easier to analyze the messages.</p>&#13;
<p class="indent"><a id="page49"/>Many daemons let you set the verbosity of debug logging with a parameter on the command line. For example, typing -d 5 might turn on debugging output with a verbosity level of 5.</p>&#13;
<p class="indent">There is no standard meaning for the debug levels in Linux. Some daemons have a simple on/off option, while others use a level between 0 and 9. Some daemons let you turn debugging on and off while the program is running by sending it SIGUSR1 and SIGUSR2 signals, and some daemons read the debug level from the configuration file.</p>&#13;
<p class="indent">On a large project with several developers, you may want to have separate debug levels for different parts of the code so that each developer can independently control the logging in his or her code. It is also nice if you can set the debug levels while the program is running. (Chapter 6 covers logging in greater detail, and shows how we use RTA to modify debug levels at run time.)</p>&#13;
<p class="secs"><a id="chapter4.8"/><a href="toc.html#chapter4.8"><i><b>Set Group and User IDs</b></i></a></p>&#13;
<p class="noindent">Many daemons start from inittab or from the rc scripts at boot time; others are started by cron. Thus, most daemons start with a root user ID, which presents a security risk if the program is ever compromised.</p>&#13;
<p class="indent">To limit possible damage if the program is compromised, many daemons drop root privileges as soon as possible. For example, a webserver might drop root privileges as soon as it has bound to TCP port 80.</p>&#13;
<p class="indent">Likewise, your daemon should drop root privileges if at all possible. But if not root, which user IDs and group IDs should you use? Many applications create their own users and groups. (A quick look at /etc/passwd and /etc/group confirms this.) If you decide to create a user for your daemon, try to keep the user shell as /bin/nologin. Your daemon can get the user IDs and group IDs from the configuration file or from the command line.</p>&#13;
<p class="indent">You can drop root privileges and become another user by using the setuid() system call. Other routines that can change the user ID include seteuid() and setreuid(), which set both the real and effective user IDs. Your needs should dictate which of these to use.</p>&#13;
<p class="indent">The following code from our sample daemon <img src="../images/1.jpg" alt=""/> gets the user ID (UID) name from Config[], a global configuration table, and calls <img src="../images/2.jpg" alt=""/> getpwnam() to convert the name to a numeric UID. A call to <img src="../images/3.jpg" alt=""/> setuid() sets the UID for the daemon. Our routine to set the group ID (GID) is similar, using setgid() instead of setuid(). (The LOG macro is explained later.)</p>&#13;
<p class="imgl"><img src="../images/73-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page50"/><img src="../images/74-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter4.9"/><a href="toc.html#chapter4.9"><i><b>Check for a pidfile</b></i></a></p>&#13;
<p class="noindent">Many daemons require exclusive access to the computer’s resources, such as a TCP port or a printer. In these cases, there should not be two instances of the daemon running, as both instances cannot have exclusive access to a resource. The most common way to reserve access is through the use of a pidfile.</p>&#13;
<p class="indent">The <i>pidfile</i> is a text file containing the process ID (PID) of the running daemon and is usually located at /var/run/<i>xxx</i>.pid, where <i>xxx</i> is the name of the daemon. For example, you might see the following in /var/run:</p>&#13;
<p class="imgl"><img src="../images/74-2.jpg" alt=""/></p>&#13;
<p class="indent">When a daemon starts, it checks to see if a pidfile exists. If the file does not exist, the daemon creates it and writes its own PID there. If the file does exist, the daemon checks to see if the process specified in the file is still running. Then it reads the PID from the file and calls kill(0) to send a signal to the process (this is just a test, kill(0) won’t actually terminate a running process). If the kill() succeeds, it means that the process specified in the file was running and able to accept the signal, so the new daemon can simply exit (optionally logging the event). There is no way to atomically check for and create a pidfile, so you have to use a Linux file lock to be sure another instance of the daemon does not also create a pidfile. The code given later in this section illustrates how to use a file lock.</p>&#13;
<p class="indent">As a security precaution, you may want to configure your appliance so that one process is not allowed to kill() another. To do so, check for the existence of the daemon by looking for its PID in the /proc directory. If the PID specified in the pidfile is not running, the new daemon overwrites the pidfile with its PID and continues. (Your daemon should also verify that a process with a matching PID is an instance of your daemon and not some other program that happens to have a PID matching the one in the pidfile.)</p>&#13;
<p class="indent"><a id="page51"/>Stale pidfiles are a nuisance, so when your daemon exits, it should remove its pidfile. Write a subroutine that deletes the pidfile and use atexit() to register the subroutine for execution at program termination. You may also want to modify your rc.sysinit or other initialization scripts to delete all of the old pidfiles from /var/run.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>Be sure to delete stale pidfiles early in the boot sequence before the daemon is started so that your system initialization does not inadvertently remove active pidfiles.</i></p>&#13;
<p class="indent1">The name and location of the pidfile is often in the configuration file; if it is not there, it can be passed in from the command line. Being able to specify the pidfile in the configuration file or on the command line makes it easier to run multiple instances of the daemon should the need arise (during debugging, for instance).</p>&#13;
<p class="indent">The code below is taken from our sample daemon and presents one approach to the voluntary mutual exclusion of a pidfile. We <img src="../images/1.jpg" alt=""/> get the name of the pidfile and try to open it. If the open succeeds, we read the PID from the file and <img src="../images/2.jpg" alt=""/> try to send a signal to the process. If the kill() call succeeds, it means the process specified in the pidfile is still running and this instance should exit. If the pidfile exists, but the process it specifies is not running, the pidfile is stale and should be <img src="../images/3.jpg" alt=""/> removed. If this instance of the daemon is the valid one, it <img src="../images/4.jpg" alt=""/> creates a pidfile, <img src="../images/5.jpg" alt=""/> locks it, and <img src="../images/6.jpg" alt=""/> writes the PID into it.</p>&#13;
<p class="imgl"><img src="../images/75-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page52"/><img src="../images/76-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter4.10"/><a href="toc.html#chapter4.10"><i><b>Set the umask</b></i></a></p>&#13;
<p class="noindent">The umask command sets the default read/write permissions for files created in the current shell. It is generally good practice to set the umask of your daemon to 0, which forces you to explicitly set the permissions of any files you create.</p>&#13;
<p class="indent">Because there is no need to save the old value of the umask, we cast the return value to void:</p>&#13;
<p class="ex">(void) umask((mode_t) 000);</p>&#13;
<p class="secs"><a id="chapter4.11"/><a href="toc.html#chapter4.11"><i><b>Set Up Signal Handlers</b></i></a></p>&#13;
<p class="noindent">A <i>signal handler is</i> a function that is compiled with the rest of your application. Instead of directly invoking the function, you use signal or sigaction to tell the operating system to call the function when a signal arrives.</p>&#13;
<p class="indent">The last step in setting up a daemon is to configure the signal handlers. The requirements for your application dictate which signals to catch and how to handle them. Running the man 7 signal command will give you an idea of the signals you might want to catch. Some of the most common signals and actions are:</p>&#13;
<p class="bl"><a id="page53"/><b><span class="bb">SIGHUP</span></b> Reread the configuration file and reinitialize as appropriate. Close and reopen any log files to give logrotate a chance to work.</p>&#13;
<p class="bl"><span class="bb"><b>SIGTERM</b>, <b>SIGQUIT</b></span> Do a graceful shutdown of the daemon and exit.</p>&#13;
<p class="bl"><span class="bb"><b>SIGUSR1</b></span> Toggle debug mode on or off.</p>&#13;
<p class="bl"><span class="bb"><b>SIGCHLD</b></span> Handle the death of any child processes.</p>&#13;
<p class="indent1">You should consult both the man page for sigaction() and your favorite Linux programming book before implementing your signal handler, but this simple example might help you get started:</p>&#13;
<p class="imgl"><img src="../images/77-1.jpg" alt=""/></p>&#13;
<p class="indent">The routine that will handle the signal is passed an integer with the signal number. The routine should be of type void.</p>&#13;
<p class="imgl"><img src="../images/77-2.jpg" alt=""/></p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>The code in a signal handler is not executed in the main execution path of your program, and since a signal can occur while the signal handler itself is running, signal handlers must be reentrant.</i></p>&#13;
<p class="indent1">Writing reentrant code can be a little tricky, and you might want to consider just setting a volatile flag and having your main loop examine the flag periodically, leaving the real work to be done in the main loop. The flag has to be volatile so that the compiler does not optimize away tests for it in the main loop. If you decide to do more than set a flag in your signal handler, make sure that all the glibc and system calls in your signal handler are reentrant safe.</p>&#13;
<p class="secl"><a id="chapter4.12"/><a href="toc.html#chapter4.12"><b>How to Secure a Daemon</b></a></p>&#13;
<p class="noindent">This section will give you some general guidelines to help you write more secure programs. However, because your daemon’s security is much too important to use this document as the sole source of your security information, we urge you to read the books listed in the bibliography at the end of this chapter. The information here is really just an overview of the points you need to consider. Furthermore, this section does not tell you how to secure the Linux kernel or your appliance in general.</p>&#13;
<p class="indent"><a id="page54"/>We’ll break the topic of daemon security into three sections:</p>&#13;
<ul>&#13;
<li>Designing a secure daemon</li>&#13;
<li>Writing a secure daemon</li>&#13;
<li>Limiting damage in case of a breach</li>&#13;
</ul>&#13;
<p class="secs"><a id="chapter4.13"/><a href="toc.html#chapter4.13"><i><b>Designing a Secure Daemon</b></i></a></p>&#13;
<p class="noindent">Securing your daemon starts when you begin thinking about its specification, architecture, and design. You have the greatest ability to make your application secure when you lay out your daemon’s foundation.</p>&#13;
<p class="indent">By secure, we mean that the daemon should respond to errors and malicious attacks in a predictable way. This implies that we must first detect errors (and attacks) and then handle them appropriately. One way to think about this is to always have a plan for each possible error condition and attack.</p>&#13;
<p class="secls"><b>Always Have an Escape Plan</b></p>&#13;
<p class="noindent">Many buildings post escape plans next to elevators and stairwells. The escape plan is a map showing the best route to take in case of an emergency. As you design your daemon, think about how you will recover or escape from each possible error condition. Laying the foundation for a good escape plan early makes it less burdensome for you to add the code after your daemon has been developed.</p>&#13;
<p class="indent">An exit may mean a core dump and program termination, or it may mean aborting a single request, closing a network connection, or performing some other error recovery. Program termination may be appropriate if you detect an error during startup or during a configuration change, or if for any reason you think security has been breached. For example, if your daemon is a network server handling client requests, it may be appropriate to close a network connection if the daemon receives a badly formed request.</p>&#13;
<p class="indent">In practice, having an error escape plan usually means that all of your subroutines return an error code. No matter how deeply nested your subroutine calls are, you should be able to pass an error indicator up the chain of subroutine returns. An event-driven or state-machine-driven program can use a flag or separate state to indicate an error.</p>&#13;
<p class="indent">Your escape should always begin with a log message describing the location of the error and the inputs that generated it. You can have two log messages, one to detect the error, and another, at a higher level, to report how you’ve decided to handle the error.</p>&#13;
<p class="secls"><b>Be Restrictive</b></p>&#13;
<p class="noindent">When designing a daemon from scratch, you can specify its operation in detail. Your specification and the resulting code should allow only the simplest subset of requests and configuration data. Setting a tight standard will make your daemon more secure and may help eliminate subtle bugs.</p>&#13;
<p class="indent"><a id="page55"/>For example, let’s consider restrictions you could place on configuration or other internal filenames. Type the following at a bash prompt (noting the placement of single and double quotes):</p>&#13;
<p class="imgl"><img src="../images/79-1.jpg" alt=""/></p>&#13;
<p class="indent">Amazing, isn’t it? The above command works. The string, cd ..; cd ..; cd ..; cd etc; echo 'nameserver 1.2.3.4'&gt;resolv.conf is a perfectly valid Linux filename. While bash must honor this as a valid filename, you do not need to. Consider stating in your specification that filenames are limited to the characters [_a-zA-Z/.] but the sequences .. and // are invalid. In addition, the maximum length of a Linux path and filename is PATH_MAX in limits.h and is usually set to 4096 characters. You might want to restrict filename lengths to the minimum that your daemon needs.</p>&#13;
<p class="indent">Filenames are just one example. Give some thought to other ways in which you can tighten your daemon’s specification.</p>&#13;
<p class="secs"><a id="chapter4.14"/><a href="toc.html#chapter4.14"><i><b>Write a Secure Daemon</b></i></a></p>&#13;
<p class="noindent">Security is only as good as the weakest link in its chain. Designing a secure daemon is not enough. You must also <i>write</i> a secure daemon.</p>&#13;
<p class="secls"><b>Validate Input</b></p>&#13;
<p class="noindent">Many of the recent Linux vulnerabilities stem from buffer overruns that allow an intruder to place executable code on the stack. The most effective defense against this kind of attack is to validate all input from a user or from any non-secure source. Verify string lengths and make sure strings do not contain any illegal characters. Verify that integers are reasonable, relative to their uses, and that counting integers are always positive.</p>&#13;
<p class="indent">Perform as much application-specific checking as possible before committing other resources. For example, make sure that HTTP requests are well formed and that SQL statements are valid. Checking early helps prevent the problem of trying to back out of a request once you’ve allocated buffers, sockets, or other resources for the request.</p>&#13;
<p class="indent">Do not let any malformed input into your daemon. Remember: If it’s only 99 percent right, then it’s still wrong.</p>&#13;
<p class="secls"><b>Check All Return Codes</b></p>&#13;
<p class="noindent">One of the best things you can do to enhance security is to check all return codes, especially from system calls. Normally, this would seem like a burden, but if you’ve laid out your design with an error escape plan, you’ll find that it does not take a lot of thought or effort to test every return code.</p>&#13;
<p class="secls"><a id="page56"/><b>Avoid Buffer Overrun Attacks</b></p>&#13;
<p class="noindent">Some library functions are considered unsafe because they do not limit how much memory they will overwrite. For example, the strcpy() function is considered unsafe, while the strncpy() function is considered safe.</p>&#13;
<p class="indent">Nevertheless, we are not convinced that the strn routines are all that safe, since they do not guarantee that the resulting string is null terminated. The best thing to do is to check the length of the string before doing a copy. Let’s look at some examples.</p>&#13;
<p class="imgl"><img src="../images/80-1.jpg" alt=""/></p>&#13;
<p class="indent">While it uses more code, the above protects the program and reports source strings that might be part of an attack on your program.</p>&#13;
<p class="indent">Several other function families are considered unsafe. Specifically, these include strcat(), sprintf(), gets(), and scanf().</p>&#13;
<p class="secls"><b>Other Security Software</b></p>&#13;
<p class="noindent">Even if you follow the best coding practices, you may want the added protection of the following software:</p>&#13;
<p class="bl1"><b>IBM’s ProPolice</b> GNU Compiler Collection (GCC) patch to help prevent buffer overruns</p>&#13;
<p class="bl1"><b>StackGuard</b> GCC patch to help prevent buffer overruns</p>&#13;
<p class="bl1"><b>Libsafe</b> Alternate library for strcpy() and other unsafe functions</p>&#13;
<p class="bl1"><b>grsecurity</b> Kernel patch that can (among other things) make the stack non-executable</p>&#13;
<p class="bl1"><b>Systrace</b> Kernel patch that can limit which system calls your daemon can make</p>&#13;
<p class="indent1"><a id="page57"/>We strongly recommend using grsecurity and configuring your system so that code is never executed from the stack. This feature uses the hardware in the memory management unit and will not affect your program’s performance.</p>&#13;
<p class="secs"><a id="chapter4.15"/><a href="toc.html#chapter4.15"><i><b>Limit Damage in Case of a Breach</b></i></a></p>&#13;
<p class="noindent">Almost every major Linux application has, at one time or another, been found to be vulnerable. Since the same may happen to your daemon at some point, you want to limit the amount of risk a compromised daemon might present to the appliance.</p>&#13;
<p class="secls"><b>Prevent Library and Path Attacks</b></p>&#13;
<p class="noindent">If an attacker gains access to your appliance, he might be able to run your daemon having first set LD_LIBRARY_PATH or PATH to point to compromised libraries and commands. If your program is Set User ID (SUID) root, your attacker has just gained complete root control over your appliance. Don’t despair. There are a few things you can do to limit disaster in the event that your daemon is compromised.</p>&#13;
<p class="indent">First, do not run your application with an SUID of root. This is easier on an appliance than on a multi-user system where programs like passwd and the X server must be SUID root. It is better to drop root privileges or to run as a non-privileged user. (You’ll learn a few more details about this in the next section.)</p>&#13;
<p class="indent">The second defense is to do a static build of your daemon using -static as an option to your gcc invocation. A statically linked executable might not increase the size of your executable as much as you’d imagine, and if you are using chroot jails, it might actually save disk space. Statically linked executables usually load faster, too.</p>&#13;
<p class="indent">Another way to prevent a library or path attack is to ignore the environment variables that tell your program where to look for shared object libraries and system commands. If you are really security conscious, use the glibc clearenv() function to undefine all environment variables. You will need to give the full path to any commands you run with system(), but this is probably a good idea anyway.</p>&#13;
<p class="secls"><b>Avoid Root Privileges</b></p>&#13;
<p class="noindent">Attackers want root privileges so they can take control of your appliance. If you run your daemon as root, you make your daemon a target for their attacks. Avoid root privileges if at all possible. Create a new user (with the login shell set to /bin/nologin) and use setuid() and setgid() to change to that user. This technique is used by most web- and database servers.</p>&#13;
<p class="indent">Another approach is to modify your rc initialization scripts to launch your daemon with sudo to change to the appropriate user. For example, your rc script might start your webui daemon as user <i>wuser with</i> the command:</p>&#13;
<p class="ex">sudo -l wuser webui</p>&#13;
<p class="secls"><a id="page58"/><b>Drop Root Privileges and Set Capabilities</b></p>&#13;
<p class="noindent">If you must have root privileges to open network ports below 1024 or to write to root-owned files, try to drop as many root privileges as possible. The 2.2 and later kernels make this possible with capabilities. <i>Capabilities</i> are separate permissions that perform very specific operations. Your SUID root program may drop individual capabilities and keep others.</p>&#13;
<p class="indent">The kernel keeps track of three sets of capabilities for each program:</p>&#13;
<p class="bl1"><b>Effective</b> What is currently allowed</p>&#13;
<p class="bl1"><b>Permitted</b> Maximum capabilities the process can use</p>&#13;
<p class="bl1"><b>Inherited</b> What to transfer across an execve()</p>&#13;
<p class="indent1">The system call to set capabilities is capset(). You might also be able to use cap_set_proc(), which is more portable.</p>&#13;
<p class="indent">Capabilities are seeing a lot of active development in Linux. Here is a sample of the more than 25 capabilities that your daemon should relinquish if possible. A list of all of the capabilities is available from the output of man capabilities.</p>&#13;
<p class="imgl"><img src="../images/82-1.jpg" alt=""/></p>&#13;
<p class="indent">The kernel itself honors a set of capabilities, and as the last step in your boot process, you might want to limit what the kernel can do. For example, if your kernel uses modules, at the end of system bootup, you may want to completely remove the kernel’s ability to load or remove modules.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>A full description of capabilities is beyond the scope of what we can present here. A good place to start is man capabilities on your Linux system.</i></p>&#13;
<p class="secls"><a id="page59"/><b>Chroot if Possible</b></p>&#13;
<p class="noindent">One of the oldest and most trusted techniques to limit damage in case of a breech is to run a daemon in a chroot jail. The idea is to put all of the files that your daemon will need in a directory subtree and to then tell your daemon that the top of the subtree is the “root” of the filesystem. The system call is chroot(), and it is a good way to make the rest of the real filesystem invisible in case your daemon is breeched.</p>&#13;
<p class="indent">It is fairly easy for a process owned by root to break out of a chroot jail, so be sure to drop root privileges after the chroot() call. A typical sequence of calls to build a chroot jail looks like this:</p>&#13;
<p class="ex">chdir("/var/app_jail");<br/>chroot("/var/app_jail")<br/>setuid(500);</p>&#13;
<p class="indent">Following the chroot() call, the application will be able to see only the files and directories under the directory specified in the chroot() call. You will need to close file descriptors to directories outside of the chroot jail, since they can provide a means to break out of the jail.</p>&#13;
<p class="indent">The trick in building a successful chroot jail is in limiting the number of files and devices in the jail. Of course you will need all of your daemon’s working files, but do not include the startup configuration directory if it contains, for example, where to locate the chroot jail. If your program is dynamically linked, you will need to include a /lib directory and whatever shared object libraries your program uses. Consider doing a static build of your application to avoid the necessity of adding the /lib directory.</p>&#13;
<p class="indent">The standard library logging routine, syslog(), assumes access to a Unix socket at /dev/log. Create a /dev directory in your jail and tell the system logging daemon, syslogd, to listen on an additional socket using the -a command line option. Here’s an example of how to start syslogd so that it listens on an additional socket:</p>&#13;
<p class="ex">syslogd -a /var/app_jail/dev/log</p>&#13;
<p class="indent">A common alternative to a chroot jail is a virtual machine. Programs such as VMware, VServer, and User-mode Linux all provide more isolation than a chroot jail but at the cost of higher memory or CPU requirements.</p>&#13;
<p class="secl"><a id="chapter4.16"/><a href="toc.html#chapter4.16"><b>A Prototype Daemon</b></a></p>&#13;
<p class="noindent">This book includes a bootable CD that turns a PC into a Linux-based appliance. The programming effort for the book’s sample appliance was divided among the authors, with each of us writing some of the programs. To make the appliance code easier for you to read (and easier for us to write), we decided to start by building a common core for each of our programs.</p>&#13;
<p class="indent"><a id="page60"/>The code for the empty daemon is available as part of the code for our appliance, and you can get it from the CD or from the book’s website. We’ve tried to build the empty daemon to reflect all of the lessons learned in the sections above, and you are welcome to copy our empty daemon code and use it as you see fit.</p>&#13;
<p class="secl"><a id="chapter4.17"/><a href="toc.html#chapter4.17"><b>Summary</b></a></p>&#13;
<p class="noindent">In this chapter we have demonstrated the initialization steps a typical daemon takes—for example, redirecting stdin, stdout, and stderr, and going into the background. We’ve also introduced some concepts and techniques that you might use to make your daemons more secure.</p>&#13;
<p class="secl"><a id="chapter4.18"/><a href="toc.html#chapter4.18"><b>Further Reading</b></a></p>&#13;
<p class="noindent">We’ve found the following books useful in determining how to secure a daemon.</p>&#13;
<ul>&#13;
<li><i>Secure Programming for Linux and Unix HOWTO</i> by David A. Wheeler (<a href="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</a>, 2003)</li>&#13;
<li><i>Real World Linux Security</i> by Bob Toxen (Prentice Hall, 2000)</li>&#13;
<li><i>Network Security Hacks</i> by Andrew Lockart (O’Reilly, 2004)</li>&#13;
<li><i>SSH, The Secure Shell: The Definitive Guide</i> by Daniel J. Barrett and Richard E. Silverman (O’Reilly, 2001)</li>&#13;
<li><i>Linux Security</i> by Shadab Siddiqui (Premier Press, 2002)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>