<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Hello Recursion!"><div class="titlepage"><div><div><h1 class="title"><a id="hello_recursion_exclamation"/>Chapter 4. Hello Recursion!</h1></div></div></div><p>In this chapter, we’ll take a look at recursion. We’ll learn why it’s important in Haskell programming and how we can find very concise and elegant solutions to problems by thinking recursively.<a id="IDX-CHP-4-0001" class="indexterm"/><a id="IDX-CHP-4-0002" class="indexterm"/><a id="IDX-CHP-4-0003" class="indexterm"/><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/></p><p>Recursion is a way of defining functions in which a function is applied inside its own definition. In other words, the function calls itself. If you still don’t know what recursion is, read this sentence. (Haha! Just kidding!)<a id="IDX-CHP-4-0006" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e4972"/><img src="httpatomoreillycomsourcenostarchimages802540.png.jpg" alt="image with no caption"/></div></div><p>Kidding aside, the strategy of a recursively defined function is to break down the problem at hand into smaller problems of the same kind and then try to solve those subproblems, breaking them down further if necessary. Eventually we reach the <span class="emphasis"><em>base case</em></span> (or base cases) of the problem, which can’t be broken down any more and whose solutions need to be explicitly (non-recursively) defined by the programmer.</p><p>Definitions in mathematics are often recursive. For instance, we can specify the <span class="emphasis"><em>Fibonacci sequence</em></span> recursively as follows: We define the first two Fibonacci numbers directly by saying that <span class="emphasis"><em>F</em></span>(0) = 0 and <span class="emphasis"><em>F</em></span>(1) = 1, meaning that the zeroth and first Fibonacci numbers are 0 and 1, respectively. These are our base cases.<a id="IDX-CHP-4-0007" class="indexterm"/><a id="IDX-CHP-4-0008" class="indexterm"/><a id="IDX-CHP-4-0009" class="indexterm"/><a id="IDX-CHP-4-0010" class="indexterm"/><a id="IDX-CHP-4-0011" class="indexterm"/></p><p>Then we specify that for any natural number other than 0 or 1, the corresponding Fibonacci number is the sum of the previous two Fibonacci numbers. In other words, <span class="emphasis"><em>F(n)</em></span> = <span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>n</em></span>-1) + <span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>n</em></span>-2). For example, <span class="emphasis"><em>F</em></span>(3) is <span class="emphasis"><em>F</em></span>(2) + <span class="emphasis"><em>F</em></span>(1), which in turn breaks down as (<span class="emphasis"><em>F</em></span>(1) + <span class="emphasis"><em>F</em></span>(0)) + <span class="emphasis"><em>F</em></span>(1). Because we’ve now come down to nothing but nonrecursively defined Fibonacci numbers, we can safely say that the value of <span class="emphasis"><em>F</em></span>(3) is 2.</p><p>Recursion is important in Haskell because, unlike with imperative languages, you do computations in Haskell by declaring <span class="emphasis"><em>what</em></span> something is rather than specifying <span class="emphasis"><em>how</em></span> you compute it. That’s why Haskell isn’t about issuing your computer a sequence of steps to execute, but rather about directly defining what the desired result is, often in a recursive manner.</p><div class="sect1" title="Maximum Awesome"><div class="titlepage"><div><div><h1 class="title"><a id="maximum_awesome"/>Maximum Awesome</h1></div></div></div><p>Let’s take a look at an existing Haskell function and see how we can write the function ourselves if we shift our brains into the “R” gear (for “recursion”).</p><p>The <code class="literal">maximum</code> function takes a list of things that can be put in order (i.e., instances of the <code class="literal">Ord</code> type class) and returns the largest of them. It can be expressed very elegantly using recursion.</p><p>Before we discuss a recursive solution, think about how you might implement the <code class="literal">maximum</code> function imperatively. You’d probably set up a variable to hold the current maximum value, then you’d loop through every element of the list. If the current element is bigger than the current maximum value, you’d replace the maximum value with that element. The maximum value that remains at the end of the loop would be the final result.</p><p>Now let’s see how we’d define it recursively. First, we need to define a base case: We say that the maximum of a singleton list is equal to the only element in it. But what if the list has more than one element? Well, then we check which is bigger: the first element (the head) or the maximum of the rest of the list (the tail). Here’s the code for our recursive <code class="literal">maximum'</code> function:</p><a id="I_programlisting4_d1e5088"/><pre class="programlisting">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error "maximum of empty list!"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)</pre><p>As you can see here, pattern matching is really useful for defining recursive functions. Being able to match and deconstruct values makes it easy to break down the maximum-finding problem into the relevant cases and recursive subproblems.</p><p>The first pattern says that if the list is empty, the program should crash. This makes sense, because we just can’t say what the maximum of an empty list is. The second pattern says that if <code class="literal">maximum'</code> is passed a singleton list, it should just return that list’s only element.</p><p>Our third pattern represents the meat of the recursion. The list is split into a head and a tail. We call the head <code class="literal">x</code> and the tail <code class="literal">xs</code>. Then, we make use of our old friend, the <code class="literal">max</code> function. The <code class="literal">max</code> function takes two things and returns whichever of them is larger. If <code class="literal">x</code> is larger than the largest element in <code class="literal">xs</code>, our function will return <code class="literal">x</code>, otherwise it will return the largest element in <code class="literal">xs</code>. But how does our <code class="literal">maximum'</code> find the largest element in <code class="literal">xs</code>? Simple—by calling itself, recursively!<a id="IDX-CHP-4-0012" class="indexterm"/><a id="IDX-CHP-4-0013" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e5140"/><img src="httpatomoreillycomsourcenostarchimages802542.png.jpg" alt="image with no caption"/></div></div><p>Let’s work through this code with a specific example, just in case you’re having trouble visualizing how <code class="literal">maximum'</code> works. If we call <code class="literal">maximum'</code> on <code class="literal">[2,5,1]</code>, the first two patterns don’t match the function call. However, the third pattern does, so the list value is split into <code class="literal">2</code> and <code class="literal">[5,1]</code>, and <code class="literal">maximum'</code> is called with <code class="literal">[5,1]</code>.</p><p>For this new call to <code class="literal">maximum'</code>, <code class="literal">[5,1]</code> matches the third pattern, and once again the input list is split—this time into <code class="literal">5</code> and <code class="literal">[1]</code>—and <code class="literal">maximum'</code> is recursively called on <code class="literal">[1]</code>. This is a singleton list, so the newest call now matches one of our base cases and returns <code class="literal">1</code> as a result.</p><p>Now, we go up a level, comparing <code class="literal">5</code> to <code class="literal">1</code> with the use of the <code class="literal">max</code> function. <code class="literal">1</code> was the result of our last recursive call. Since <code class="literal">5</code> is larger, we now know that the maximum of <code class="literal">[5,1]</code> is <code class="literal">5</code>.</p><p>Finally, comparing <code class="literal">2</code> to the maximum of <code class="literal">[5,1]</code>, which we now know is <code class="literal">5</code>, we obtain the answer to the original problem. Since <code class="literal">5</code> is greater than <code class="literal">2</code>, we can now say that <code class="literal">5</code> is the maximum of <code class="literal">[2,5,1]</code>.</p></div></div>
<div class="sect1" title="A Few More Recursive Functions"><div class="titlepage"><div><div><h1 class="title"><a id="a_few_more_recursive_functions"/>A Few More Recursive Functions</h1></div></div></div><p>Now that we’ve seen how to think recursively, let’s implement a few more functions this way. Like <code class="literal">maximum</code>, these functions already exist in Haskell, but we’re going to write our own versions to exercise the recursive muscle fibers in the recursive muscles of our recursive muscle groups. Let’s get buff!</p><div class="sect2" title="replicate"><div class="titlepage"><div><div><h2 class="title"><a id="replicate"/>replicate</h2></div></div></div><p>First off, we’ll implement <code class="literal">replicate</code>. Remember that <code class="literal">replicate</code> takes an <code class="literal">Int</code> and a value, and returns a list that has several repetitions of that value (namely, however many the <code class="literal">Int</code> specifies). For instance, <code class="literal">replicate 3 5</code> returns a list of three fives: <code class="literal">[5,5,5]</code>.<a id="IDX-CHP-4-0014" class="indexterm"/></p><p>Let’s think about the base cases. We immediately know what to return if we’re asked to replicate something zero or fewer times. If we try to replicate something zero times, we should get an empty list. And we declare that the result should be the same for negative numbers, because replicating an item fewer than zero times doesn’t make sense.<a id="IDX-CHP-4-0015" class="indexterm"/><a id="IDX-CHP-4-0016" class="indexterm"/></p><p>In general, a list with <code class="literal">n</code> repetitions of <code class="literal">x</code> is a list with <code class="literal">x</code> as its head and a tail consisting of <code class="literal">x</code> replicated <code class="literal">n-1</code> times. We get the following code:</p><a id="I_programlisting4_d1e5306"/><pre class="programlisting">replicate' :: Int -&gt; a -&gt; [a]
replicate' n x
    | n &lt;= 0    = []
    | otherwise = x : replicate' (n-1) x</pre><p>We used guards here instead of patterns because we’re testing for a Boolean condition.</p></div><div class="sect2" title="take"><div class="titlepage"><div><div><h2 class="title"><a id="take"/>take</h2></div></div></div><p>Next up, we’ll implement <code class="literal">take</code>. This function returns a specified number of elements from a specified list. For instance, <code class="literal">take 3 [5,4,3,2,1]</code> will return <code class="literal">[5,4,3]</code>. If we try to take zero or fewer elements from a list, we should get an empty list, and if we try to take anything at all from an empty list, we should get an empty list. Notice that those are our two base cases. Now let’s write the function:<a id="IDX-CHP-4-0017" class="indexterm"/></p><a id="I_programlisting4_d1e5329"/><pre class="programlisting">take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a]
take' n _
    | n &lt;= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs</pre><p>Notice that in the first pattern, which specifies that we get an empty list if we try to take zero or fewer elements from a list, we use the <code class="literal">_</code> placeholder to match the list value, because we don’t really care what it is in this case. Also notice that we use a guard, but without an <code class="literal">otherwise</code> part. That means that if <code class="literal">n</code> turns out to be more than 0, the matching will fall through to the next pattern.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e5343"/><img src="httpatomoreillycomsourcenostarchimages802544.png.jpg" alt="image with no caption"/></div></div><p>The second pattern indicates that if we try to take any number of things at all from an empty list, we get an empty list.</p><p>The third pattern breaks the list into a head and a tail. We call the head <code class="literal">x</code> and the tail <code class="literal">xs</code>. Then we state that taking <code class="literal">n</code> elements from a list is the same as creating a list that has <code class="literal">x</code> as its first element and <code class="literal">n-1</code> elements from <code class="literal">xs</code> as its remaining elements.<a id="IDX-CHP-4-0018" class="indexterm"/><a id="IDX-CHP-4-0019" class="indexterm"/><a id="IDX-CHP-4-0020" class="indexterm"/><a id="IDX-CHP-4-0021" class="indexterm"/><a id="IDX-CHP-4-0022" class="indexterm"/><a id="IDX-CHP-4-0023" class="indexterm"/><a id="IDX-CHP-4-0024" class="indexterm"/></p></div><div class="sect2" title="reverse"><div class="titlepage"><div><div><h2 class="title"><a id="reverse"/>reverse</h2></div></div></div><p>The <code class="literal">reverse</code> function takes a list and returns a list with the same elements, but in the reverse order. Once again, the empty list is the base case, since trying to reverse an empty list just results in the empty list. What about the rest of the function? Well, if we split the original list into its head and tail, the reversed list that we want is the reverse of the tail, with the head stuck at the end:<a id="IDX-CHP-4-0025" class="indexterm"/><a id="IDX-CHP-4-0026" class="indexterm"/></p><a id="I_programlisting4_d1e5418"/><pre class="programlisting">reverse' :: [a] -&gt; [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]</pre></div><div class="sect2" title="repeat"><div class="titlepage"><div><div><h2 class="title"><a id="repeat"/>repeat</h2></div></div></div><p>The <code class="literal">repeat</code> function takes an element and returns an infinite list composed of that element. A recursive implementation of <code class="literal">repeat</code> is really easy:<a id="IDX-CHP-4-0027" class="indexterm"/></p><a id="I_programlisting4_d1e5436"/><pre class="programlisting">repeat' :: a -&gt; [a]
repeat' x = x:repeat' x</pre><p>Calling <code class="literal">repeat 3</code> will give us a list that starts with <code class="literal">3</code> as the head and has an infinite amount of <code class="literal">3</code>s as the tail. So calling <code class="literal">repeat 3</code> evaluates to <code class="literal">3:repeat 3</code>, which evaluates to <code class="literal">3:(3:repeat 3)</code>, which evaluates to <code class="literal">3:(3:(3:repeat 3))</code>, and so on. <code class="literal">repeat 3</code> will never finish evaluating. However, <code class="literal">take 5 (repeat 3)</code> will give us a list of five <code class="literal">3</code>s. Essentially, it’s like calling <code class="literal">replicate 5 3</code>.</p><p>This is a nice example of how we can successfully use recursion that doesn’t have a base case to make infinite lists—we just have to be sure to chop them off somewhere along the way.</p></div><div class="sect2" title="zip"><div class="titlepage"><div><div><h2 class="title"><a id="zip"/>zip</h2></div></div></div><p><code class="literal">zip</code> is another function for working with lists that we’ve met in <a class="xref" href="ch01.html" title="Chapter 1. Starting Out">Chapter 1</a>. It takes two lists and zips them together. For instance, calling <code class="literal">zip [1,2,3] [7,8]</code> returns <code class="literal">[(1,7),(2,8)]</code> (the function truncates the longer list to match the length of the shorter one).<a id="IDX-CHP-4-0028" class="indexterm"/></p><p>Zipping something with an empty list just returns an empty list, which gives us our base case. However, <code class="literal">zip</code> takes two lists as parameters, so there are actually two base cases:</p><a id="I_programlisting4_d1e5501"/><pre class="programlisting">zip' :: [a] -&gt; [b] -&gt; [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys</pre><p>The first two patterns are our base cases: If the first or second list is empty, we return an empty list. The third pattern says that zipping two lists together is equivalent to pairing up their heads, then appending their zipped tails to that.<a id="IDX-CHP-4-0029" class="indexterm"/></p><p>For example, if we call <code class="literal">zip'</code> with <code class="literal">[1,2,3]</code> and <code class="literal">['a','b']</code>, the function will form <code class="literal">(1,'a')</code> as the first element of the result, then zip together <code class="literal">[2,3]</code> and <code class="literal">[b]</code> to obtain the rest of the result. After one more recursive call, the function will try to zip <code class="literal">[3]</code> with <code class="literal">[]</code>, which matches one of the base case patterns. The final result is then computed directly as <code class="literal">(1,'a'):((2,'b'):[])</code>, which is just <code class="literal">[(1,'a'),(2,'b')]</code>.</p></div><div class="sect2" title="elem"><div class="titlepage"><div><div><h2 class="title"><a id="elem"/>elem</h2></div></div></div><p>Let’s implement one more standard library function: <code class="literal">elem</code>. This function takes a value and a list, and checks whether the value is a member of the list. Once again, the empty list is a base case—an empty list contains no values, so it certainly can’t have the one we’re looking for. In general, the value we’re looking for might be at the head of the list if we’re lucky; otherwise, we have to check whether it’s in the tail. Here’s the code:</p><a id="I_programlisting4_d1e5549"/><pre class="programlisting">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs</pre></div></div>
<div class="sect1" title="Quick, Sort!"><div class="titlepage"><div><div><h1 class="title"><a id="quick_comma_sort_exclamation"/>Quick, Sort!</h1></div></div></div><p>The problem of sorting a list containing elements that can be put in order (like numbers) naturally lends itself to a recursive solution. There are many approaches to recursively sorting lists, but we’ll look at one of the coolest ones: <span class="emphasis"><em>quicksort</em></span>. First we’ll go over how the algorithm works, and then we’ll implement it in Haskell.<a id="IDX-CHP-4-0030" class="indexterm"/><a id="IDX-CHP-4-0031" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e5568"/><img src="httpatomoreillycomsourcenostarchimages802546.png.jpg" alt="image with no caption"/></div></div><div class="sect2" title="The Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="the_algorithm"/>The Algorithm</h2></div></div></div><p>The quicksort algorithm works like this. You have a list that you want to sort, say <code class="literal">[5,1,9,4,6,7,3]</code>. You select the first element, which is <code class="literal">5</code>, and put all the other list elements that are less than or equal to <code class="literal">5</code> on its left side. Then you take the ones that are greater than <code class="literal">5</code> and put them on its right side. If you did this, you’d have a list that looks like this: <code class="literal">[1,4,3,5,9,6,7]</code>. In this example, <code class="literal">5</code> is called the <span class="emphasis"><em>pivot</em></span>, because we chose to compare the other elements to it and move them to its left and right sides. The only reason we chose the first element as the pivot is because it will be easy to snag using pattern matching. But really, any element can be the pivot.</p><p>Now, we recursively sort all the elements that are on the left and right sides of the pivot by calling the same function on them. The final result is a completely sorted list!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e5603"/><img src="httpatomoreillycomsourcenostarchimages802548.png.jpg" alt="image with no caption"/></div></div><p>The above diagram illustrates how quicksort works on our example. When we want to sort <code class="literal">[5,1,9,4,6,7,3]</code>, we decide that the first element is our pivot. Then we sandwich it in between <code class="literal">[1,4,3]</code> and <code class="literal">[9,6,7]</code>. Once we’ve done that, we sort <code class="literal">[1,4,3]</code> and <code class="literal">[9,6,7]</code> by using the same approach.</p><p>To sort <code class="literal">[1,4,3]</code>, we choose the first element, <code class="literal">1</code>, as the pivot and we make a list of elements that are less than or equal to <code class="literal">1</code>. That turns out to be the empty list, <code class="literal">[]</code>, because <code class="literal">1</code> is the smallest element in <code class="literal">[1,4,3]</code>. The elements larger than <code class="literal">1</code> go to its right, so that’s <code class="literal">[4,3]</code>. Again, <code class="literal">[4,3]</code> is sorted in the same way. It too will eventually be broken up into empty lists and put back together.</p><p>The algorithm then returns to the right side of <code class="literal">1</code>, which has the empty list on its left side. Suddenly, we have <code class="literal">[1,3,4]</code>, which is sorted. This is kept on the left side of the <code class="literal">5</code>.</p><p>Once the elements on the right side of the <code class="literal">5</code> are sorted in the same way, we will have a completely sorted list: <code class="literal">[1,3,4,5,6,7,9]</code>.</p></div><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code"/>The Code</h2></div></div></div><p>Now that we’re familiar with the quicksort algorithm, let’s dive into its implementation in Haskell:</p><a id="I_programlisting4_d1e5679"/><pre class="programlisting">quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = [a | a &lt;- xs, a &lt;= x]
        larger = [a | a &lt;- xs, a &gt; x]
    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger</pre><p>The type signature of our function is <code class="literal">quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>, and the empty list is the base case, as we just saw.<a id="IDX-CHP-4-0032" class="indexterm"/></p><p>Remember, we’ll put all the elements less than or equal to <code class="literal">x</code> (our pivot) to its left. To retrieve those elements, we use the list comprehension <code class="literal">[a | a &lt;- xs, a &lt;= x]</code>. This list comprehension will draw from <code class="literal">xs</code> (all the elements that aren’t our pivot) and keep only those that satisfy the condition <code class="literal">a &lt;= x</code>, meaning those elements that are less than or equal to <code class="literal">x</code>. We then get the list of elements larger than <code class="literal">x</code> in a similar fashion.</p><p>We use <code class="literal">let</code> bindings to give the two lists handy names: <code class="literal">smallerOrEqual</code> and <code class="literal">larger</code>. Finally, we use the list concatenation operator (<code class="literal">++</code>) and a recursive application of our <code class="literal">quicksort</code> function to express that we want our final list to be made of a sorted <code class="literal">smallerOrEqual</code> list, followed by our pivot, followed by a sorted <code class="literal">larger</code> list.</p><p>Let’s give our function a test drive to see if it behaves correctly:</p><a id="I_programlisting4_d1e5738"/><pre class="programlisting">ghci&gt; quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
[1,2,2,3,3,4,4,5,6,7,8,9,10]
ghci&gt; quicksort "the quick brown fox jumps over the lazy dog"
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"</pre><p>Now that’s what I’m talking about!</p></div></div>
<div class="sect1" title="Thinking Recursively"><div class="titlepage"><div><div><h1 class="title"><a id="thinking_recursively"/>Thinking Recursively</h1></div></div></div><p>We’ve used recursion quite a bit in this chapter, and as you’ve probably noticed, there’s a pattern to it. You start by defining a base case: simple, nonrecursive solution that holds when the input is trivial. For example, the result of sorting an empty list is the empty list, because—well, what else could it be?</p><p>Then, you break your problem down into one or many subproblems and recursively solve those by applying the same function to them. You then build up your final solution from those solved subproblems. For instance, when sorting, we broke our list into two lists, plus a pivot. We sorted each of those lists separately by applying the same function to them. When we got the results, we joined them into one big sorted list.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e5751"/><img src="httpatomoreillycomsourcenostarchimages802550.png.jpg" alt="image with no caption"/></div></div><p>The best way to approach recursion is to identify base cases and think about how you can break the problem at hand into something similar, but smaller. If you’ve correctly chosen the base cases and subproblems, you don’t even have to think about the details of how everything will happen. You can just trust that the solutions of the subproblems are correct, and then you can just build up your final solutions from those smaller solutions.</p></div></body></html>