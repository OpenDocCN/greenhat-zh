["```\nfmap :: (b -> c) -> Either a b -> Either a c\n```", "```\ninstance Functor IO where\n    fmap f action = do\n        result <- action\n        return (f result)\n```", "```\nmain = do line <- getLine\n          let line' = reverse line\n          putStrLn $ \"You said \" ++ line' ++ \" backwards!\"\n          putStrLn $ \"Yes, you said \" ++ line' ++ \" backwards!\"\n```", "```\nmain = do line <- fmap reverse getLine\n          putStrLn $ \"You said \" ++ line ++ \" backwards!\"\n          putStrLn $ \"Yes, you really said \" ++ line ++ \" backwards!\"\n```", "```\nimport Data.Char\nimport Data.List\n\nmain = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine\n          putStrLn line\n```", "```\n$ ./fmapping_io\nhello there\nE-R-E-H-T- -O-L-L-E-H\n```", "```\n(\\xs -> intersperse '-' (reverse (map toUpper xs)))\n```", "```\ninstance Functor ((->) r) where\n    fmap f g = (\\x -> f (g x))\n```", "```\nfmap :: (a -> b) -> f a -> f b\n```", "```\nfmap :: (a -> b) -> ((->) r a) -> ((->) r b)\n```", "```\nfmap :: (a -> b) -> (r -> a) -> (r -> b)\n```", "```\ninstance Functor ((->) r) where\n    fmap = (.)\n```", "```\nghci> :t fmap (*3) (+100)\nfmap (*3) (+100) :: (Num a) => a -> a\nghci> fmap (*3) (+100) 1\n303\nghci> (*3) `fmap` (+100) $ 1\n303\nghci> (*3) . (+100) $ 1\n303\nghci> fmap (show . (*3)) (+100) 1\n\"303\"\n```", "```\nfmap :: (Functor f) => (a -> b) -> f a -> f b\n```", "```\nghci> :t fmap (*2)\nfmap (*2) :: (Num a, Functor f) => f a -> f a\nghci> :t fmap (replicate 3)\nfmap (replicate 3) :: (Functor f) => f a -> f [a]\n```", "```\nghci> fmap (replicate 3) [1,2,3,4]\n[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]\nghci> fmap (replicate 3) (Just 4)\nJust [4,4,4]\nghci> fmap (replicate 3) (Right \"blah\")\nRight [\"blah\",\"blah\",\"blah\"]\nghci> fmap (replicate 3) Nothing\nNothing\nghci> fmap (replicate 3) (Left \"foo\")\nLeft \"foo\"\n```", "```\nghci> fmap id (Just 3)\nJust 3\nghci> id (Just 3)\nJust 3\nghci> fmap id [1..5]\n[1,2,3,4,5]\nghci> id [1..5]\n[1,2,3,4,5]\nghci> fmap id []\n[]\nghci> fmap id Nothing\nNothing\n```", "```\ninstance Functor Maybe where\n    fmap f (Just x) = Just (f x)\n    fmap f Nothing = Nothing\n```", "```\ndata CMaybe a = CNothing | CJust Int a deriving (Show)\n```", "```\nghci> CNothing\nCNothing\nghci> CJust 0 \"haha\"\nCJust 0 \"haha\"\nghci> :t CNothing\nCNothing :: CMaybe a\nghci> :t CJust 0 \"haha\"\nCJust 0 \"haha\" :: CMaybe [Char]\nghci> CJust 100 [1,2,3]\nCJust 100 [1,2,3]\n```", "```\ninstance Functor CMaybe where\n    fmap f CNothing = CNothing\n    fmap f (CJust counter x) = CJust (counter+1) (f x)\n```", "```\nghci> fmap (++\"ha\") (CJust 0 \"ho\")\nCJust 1 \"hoha\"\nghci> fmap (++\"he\") (fmap (++\"ha\") (CJust 0 \"ho\"))\nCJust 2 \"hohahe\"\nghci> fmap (++\"blah\") CNothing\nCNothing\n```", "```\nghci> fmap id (CJust 0 \"haha\")\nCJust 1 \"haha\"\nghci> id (CJust 0 \"haha\")\nCJust 0 \"haha\"\n```", "```\nghci> :t fmap (++) (Just \"hey\")\nfmap (++) (Just \"hey\") :: Maybe ([Char] -> [Char])\nghci> :t fmap compare (Just 'a')\nfmap compare (Just 'a') :: Maybe (Char -> Ordering)\nghci> :t fmap compare \"A LIST OF CHARS\"\nfmap compare \"A LIST OF CHARS\" :: [Char -> Ordering]\nghci> :t fmap (\\x y z -> x + y / z) [3,4,5,6]\nfmap (\\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]\n```", "```\nghci> let a = fmap (*) [1,2,3,4]\nghci> :t a\na :: [Integer -> Integer]\nghci> fmap (\\f -> f 9) a\n[9,18,27,36]\n```", "```\nclass (Functor f) => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n```", "```\nf (a -> b) -> f a -> f b\n```", "```\ninstance Applicative Maybe where\n    pure = Just\n    Nothing <*> _ = Nothing\n    (Just f) <*> something = fmap f something\n```", "```\nghci> Just (+3) <*> Just 9\nJust 12\n\nghci> pure (+3) <*> Just 10\nJust 13\nghci> pure (+3) <*> Just 9\nJust 12\nghci> Just (++\"hahah\") <*> Nothing\nNothing\nghci> Nothing <*> Just \"woot\"\nNothing\n```", "```\nghci> pure (+) <*> Just 3 <*> Just 5\nJust 8\nghci> pure (+) <*> Just 3 <*> Nothing\nNothing\nghci> pure (+) <*> Nothing <*> Just 5\nNothing\n```", "```\npure (+) <*> Just 3 <*> Just 5\n```", "```\n(pure (+) <*> Just 3) <*> Just 5\n```", "```\n(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n```", "```\nghci> (++) <$> Just \"johntra\" <*> Just \"volta\"\nJust \"johntravolta\"\n```", "```\nghci> (++) \"johntra\" \"volta\"\n\"johntravolta\"\n```", "```\ninstance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n```", "```\nghci> pure \"Hey\" :: [String]\n[\"Hey\"]\nghci> pure \"Hey\" :: Maybe String\nJust \"Hey\"\n```", "```\nghci> [(*0),(+100),(^2)] <*> [1,2,3]\n[0,0,0,101,102,103,1,4,9]\n```", "```\nghci> [(+),(*)] <*> [1,2] <*> [3,4]\n[4,5,5,6,3,4,6,8]\n```", "```\nghci> (++) <$> [\"ha\",\"heh\",\"hmm\"] <*> [\"?\",\"!\",\".\"]\n[\"ha?\",\"ha!\",\"ha.\",\"heh?\",\"heh!\",\"heh.\",\"hmm?\",\"hmm!\",\"hmm.\"]\n```", "```\nghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]\n[16,20,22,40,50,55,80,100,110]\n```", "```\nghci> (*) <$> [2,5,10] <*> [8,10,11]\n[16,20,22,40,50,55,80,100,110]\n```", "```\nghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]\n[55,80,100,110]\n```", "```\ninstance Applicative IO where\n    pure = return\n    a <*> b = do\n        f <- a\n        x <- b\n        return (f x)\n```", "```\nmyAction :: IO String\nmyAction = do\n    a <- getLine\n    b <- getLine\n    return $ a ++ b\n```", "```\nmyAction :: IO String\nmyAction = (++) <$> getLine <*> getLine\n```", "```\nmain = do\n    a <- (++) <$> getLine <*> getLine\n    putStrLn $ \"The two lines concatenated turn out to be: \" ++ a\n```", "```\ninstance Applicative ((->) r) where\n    pure x = (\\_ -> x)\n    f <*> g = \\x -> f x (g x)\n```", "```\nghci> (pure 3) \"blah\"\n3\n```", "```\nghci> pure 3 \"blah\"\n3\n```", "```\nghci> :t (+) <$> (+3) <*> (*100)\n(+) <$> (+3) <*> (*100) :: (Num a) => a -> a\nghci> (+) <$> (+3) <*> (*100) $ 5\n508\n```", "```\nghci> (\\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5\n[8.0,10.0,2.5]\n```", "```\ninstance Applicative ZipList where\n        pure x = ZipList (repeat x)\n        ZipList fs <*> ZipList xs = ZipList (zipWith (\\f x -> f x) fs xs)\n```", "```\nghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]\n[101,102,103]\nghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]\n[101,102,103]\nghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]\n[5,3,3,4]\nghci> getZipList $ (,,) <$> ZipList \"dog\" <*> ZipList \"cat\" <*> ZipList \"rat\"\n[('d','c','r'),('o','a','a'),('g','t','t')]\n```", "```\nliftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\n```", "```\nliftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n```", "```\nghci> fmap (\\x -> [x]) (Just 4)\nJust [4]\n```", "```\nghci> liftA2 (:) (Just 3) (Just [4])\nJust [3,4]\nghci> (:) <$> Just 3 <*> Just [4]\nJust [3,4]\n```", "```\nsequenceA :: (Applicative f) => [f a] -> f [a]\nsequenceA [] = pure []\nsequenceA (x:xs) = (:) <$> x <*> sequenceA xs\n```", "```\nsequenceA [Just 1, Just 2]}\n```", "```\n(:) <$> Just 1 <*> sequenceA [Just 2]\n```", "```\n(:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA [])\n```", "```\n(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just [])\n```", "```\n(:) <$> Just 1 <*> Just [2]\n```", "```\nsequenceA :: (Applicative f) => [f a] -> f [a]\nsequenceA = foldr (liftA2 (:)) (pure [])\n```", "```\nghci> sequenceA [Just 3, Just 2, Just 1]\nJust [3,2,1]\nghci> sequenceA [Just 3, Nothing, Just 1]\nNothing\nghci> sequenceA [(+3),(+2),(+1)] 3\n[6,5,4]\nghci> sequenceA [[1,2,3],[4,5,6]]\n[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]\nghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]\n[]\n```", "```\nghci> map (\\f -> f 7) [(>4),(<10),odd]\n[True,True,True]\nghci> and $ map (\\f -> f 7) [(>4),(<10),odd]\nTrue\n```", "```\nghci> sequenceA [(>4),(<10),odd] 7\n[True,True,True]\nghci> and $ sequenceA [(>4),(<10),odd] 7\nTrue\n```", "```\nghci> sequenceA [[1,2,3],[4,5,6]]\n[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]\nghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]\n[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]\nghci> sequenceA [[1,2],[3,4]]\n[[1,3],[1,4],[2,3],[2,4]]\nghci> [[x,y] | x <- [1,2], y <- [3,4]]\n[[1,3],[1,4],[2,3],[2,4]]\nghci> sequenceA [[1,2],[3,4],[5,6]]\n[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]\nghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]\n[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]\n```", "```\nghci> sequenceA [getLine, getLine, getLine]\nheyh\nho\nwoo\n[\"heyh\",\"ho\",\"woo\"]\n```"]