<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;FILTERING FLOWS"><div class="titlepage"><div><div><h1 class="title"><a id="filtering_flows"/>Chapter 4. FILTERING FLOWS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e4319"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>The good news is, you now have actual data about your network. The bad news is, you have far too much data about your network. An Internet T1 might generate millions of flow records in a single day, while a busy Ethernet core might generate billions or more. How can you possibly manage or evaluate that heap of data? You must filter your data to display only interesting flows. The <code class="literal">flow-nfilter</code> program lets you include or exclude flows as needed.<a class="indexterm" id="IDX-CHP-4-0001"/></p><p>You can filter traffic in almost any way you can imagine. For example, if a particular server is behaving oddly, you can filter on its IP address. If you're interested in HTTP traffic, you can filter on TCP port 80. You can reduce your data to include only interesting traffic, which will help you evaluate and diagnose issues. For example, if you have a large internal corporate network, you might want to view only the traffic exchanged with a particular branch office, filtering on all of its network addresses.</p><p>In <a class="xref" href="ch03.html" title="Chapter 3. VIEWING FLOWS">Chapter 3</a>, you viewed flow information by running <code class="literal">flow-cat</code> and feeding the resulting data stream to <code class="literal">flow-print</code>. Filtering takes place between these two processes: <code class="literal">flow-nfilter</code> accepts the data stream from <code class="literal">flow-cat</code> and examines each flow. Flows that match the filter pass on to <code class="literal">flow-print</code> (or other flow-processing programs); flows that do not match the filter drop from the data stream.<a class="indexterm" id="IDX-CHP-4-0002"/><a class="indexterm" id="IDX-CHP-4-0003"/></p><div class="sect1" title="Filter Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="filter_fundamentals"/>Filter Fundamentals</h1></div></div></div><p>In this chapter, you'll start by building a few simple filters. Once you understand the basics of filter construction, you'll examine the various filter types and functions in depth.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Define your filters in the file <span class="emphasis"><em>filter.cfg</em></span>, which is probably in <span class="emphasis"><em>/usr/local/flow-tools/etc/cfg/filter.cfg</em></span> or <span class="emphasis"><em>/usr/local/etc/flow-tools/filter.cfg</em></span>, depending on your operating system and how you installed flow-tools.</p></div><div class="sect2" title="Common Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="common_primitives"/>Common Primitives</h2></div></div></div><p>You'll build your filters out of <span class="emphasis"><em>primitives</em></span>. A primitive is a simple traffic characteristic, such as "port 80," "TCP," or "IP address 192.0.2.1." For example, those three primitives could be combined to create one filter that passes all TCP traffic to the host 192.0.2.1 on port 80.<a class="indexterm" id="IDX-CHP-4-0004"/><a class="indexterm" id="IDX-CHP-4-0005"/></p><p><code class="literal">flow-nfilter</code> supports more than a dozen different primitives and can compare them with flows in more than two dozen different ways. A primitive looks much like this:</p><a id="I_programlisting4_d1e4399"/><pre class="programlisting">filter-primitive <em class="replaceable"><code>name</code></em>
❶    type <em class="replaceable"><code>primitive-type</code></em>
❷    permit <em class="replaceable"><code>value</code></em></pre><p>The first line defines a filtering primitive and assigns the primitive a name.</p><p>The type at ❶ defines the characteristic you want to match on, such as an IP address, a port, or a time. (I'll cover the most commonly useful filter types.)</p><p>The permit statement at ❷ defines the values you're looking for. By default, a primitive denies everything, so you must explicitly state what your filter permits. Alternatively, you could use a <code class="literal">deny</code> statement to create a primitive that matches everything except what you're looking for and explicitly put a <code class="literal">default permit</code> statement at the end.</p><p>For example, a complete primitive that matches the IP address 192.168.1.1 looks like this:</p><a id="I_programlisting4_d1e4423"/><pre class="programlisting">filter-primitive ❶ 192.0.2.1
❷    type ip-address
❸    permit 192.0.2.1</pre><p>At ❶ I've named my primitive after the address it matches. You can use any one-word name that makes sense to you, such as "mailserver" or "firewall," if you prefer. The <code class="literal">ip-address</code> primitive at ❷ matches network addresses. Finally, at ❸ this primitive matches any IP address equal to 192.0.2.1. If you include this primitive in a filter, it will pass traffic to or from this IP address only.<a class="indexterm" id="IDX-CHP-4-0006"/><a class="indexterm" id="IDX-CHP-4-0007"/><a class="indexterm" id="IDX-CHP-4-0008"/><a class="indexterm" id="IDX-CHP-4-0009"/></p><p>Similarly, the following primitive defines port 25:</p><a id="I_programlisting4_d1e4451"/><pre class="programlisting">filter-primitive ❶ port25
    type ❷ ip-port
    permit 25</pre><p>Although I could have called this primitive <code class="literal">25</code>, at ❶ I used the name <code class="literal">port25</code> to make it absolutely clear that this primitive matches a port because the number 25 by itself could be a number of seconds, a count of octets or packets per second, an autonomous system, a floor number, and so on. (An IP address is unmistakable, so using the address as a name probably won't confuse you.)</p><p>The <code class="literal">ip-port</code> primitive at ❷ is another commonly used filter component. Including this primitive in a filter means that the filter will pass traffic only on port 25.</p><p>The default <span class="emphasis"><em>filter.cfg</em></span> includes a primitive for TCP traffic, as shown here:</p><a id="I_programlisting4_d1e4471"/><pre class="programlisting">filter-primitive ❶ TCP
    type ❷ ip-protocol
    permit ❸ tcp</pre><p>You're unlikely to mistake the name TCP at ❶ for anything other than the protocol, but the <code class="literal">ip-protocol</code> primitive at ❷ lets you create a primitive for any TCP/IP protocol. Of course, if you have obscure network protocols, you'll probably need to create additional protocol primitives, and your permit statements at ❸ can use either the protocol number or the protocol name from <span class="emphasis"><em>/etc/protocols</em></span>.</p><p>Each primitive can include only one type of match. For example, the following is invalid:</p><a id="I_programlisting4_d1e4483"/><pre class="programlisting">filter-primitive bogus-primitive
❶    type ip-port
     permit 25
❷    type ip-address
     permit 192.0.2.1</pre><p>This primitive tries to match on both a port number (❶) and an IP address (❷). A primitive cannot do this. To filter out connections to the IP address 192.0.2.1 on port 25, you must assemble a filter from multiple primitives.</p><p>Now that you have a few primitives, you can create your first filter.</p></div><div class="sect2" title="Creating a Simple Filter with Conditions and Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_simple_filter_with_conditions"/>Creating a Simple Filter with Conditions and Primitives</h2></div></div></div><p>Combine primitives into filters with the <code class="literal">filter-definition</code> keyword, like so:<a class="indexterm" id="IDX-CHP-4-0010"/><a class="indexterm" id="IDX-CHP-4-0011"/><a class="indexterm" id="IDX-CHP-4-0012"/><a class="indexterm" id="IDX-CHP-4-0013"/><a class="indexterm" id="IDX-CHP-4-0014"/><a class="indexterm" id="IDX-CHP-4-0015"/><a class="indexterm" id="IDX-CHP-4-0016"/></p><a id="I_programlisting4_d1e4524"/><pre class="programlisting">❶ filter-definition <em class="replaceable"><code>name</code></em>
❷     match <em class="replaceable"><code>condition primitive1</code></em>
      match <em class="replaceable"><code>condition primitive1</code></em>
      ...</pre><p>Every filter begins with <code class="literal">filter-definition</code> (❶) and a name. Filters can share a name with a primitive but not with other filter definitions.</p><p>The filter contains a series of <code class="literal">match</code> keywords (❷), followed by conditions and primitives. The <code class="literal">match</code> keyword specifies the part of the flow this entry checks and the primitive to compare it to.</p><p>Conditions include things such as IP addresses, ports, protocols, types of service, and so on. All of the conditions listed must match for the filter to match a flow. For example, the following filter combines the <code class="literal">TCP</code> primitive and the <code class="literal">port25</code> primitive:</p><a id="I_programlisting4_d1e4556"/><pre class="programlisting">filter-definition TCPport25
❶    match ip-protocol TCP
❷    match ip-source-port port25</pre><p>This filter passes all flows coming from TCP port 25. Any flow that does not come from TCP port 25 will not pass through the filter.</p><p>Although primitives and conditions look similar, their names can differ. For example, both filter conditions and filter primitives use the <code class="literal">ip-protocol</code> keyword (❶). When matching ports, however, primitives use the <code class="literal">ip-port</code> keyword (❷), but filter definitions use the <code class="literal">ip-source-port</code> and <code class="literal">ip-destination-port</code> keywords instead.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The most common cause of filtering errors is using incorrect keywords. Use filter keywords only in filters, and use primitive keywords only in primitives.</p></div><div class="sidebar"><a id="naming_conventions_for_filters_and_primi"/><p class="title">NAMING CONVENTIONS FOR FILTERS AND PRIMITIVES</p><p>Assign names to your filters and primitives carefully. If you initially choose ambiguous or confusing names, you'll trip over them when you have dozens or hundreds of filters! Make your names easy to recognize and unmistakable in purpose.</p><p>Primitives can share a name with a filter. For example, you can name a primitive TCP and a filter TCP, but you cannot name two primitives TCP or two filters UDP. Also, filter and primitive names are case insensitive. You cannot name one primitive <code class="literal">tcp</code> and another primitive TCP.</p></div></div><div class="sect2" title="Using Your Filter"><div class="titlepage"><div><div><h2 class="title"><a id="using_your_filter"/>Using Your Filter</h2></div></div></div><p>Use <code class="literal">flow-nfilter</code>'s <code class="literal">-F</code> option and the filter name to pass only the traffic that matches your filters. For example, here I'm printing only the flows that match the <code class="literal">TCPport25</code> report:<a class="indexterm" id="IDX-CHP-4-0017"/><a class="indexterm" id="IDX-CHP-4-0018"/><a class="indexterm" id="IDX-CHP-4-0019"/><a class="indexterm" id="IDX-CHP-4-0020"/><a class="indexterm" id="IDX-CHP-4-0021"/><a class="indexterm" id="IDX-CHP-4-0022"/><a class="indexterm" id="IDX-CHP-4-0023"/></p><a id="I_programlisting4_d1e4631"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat * | flow-nfilter -F TCPport25 | flow-print | less</code></strong>
srcIP            dstIP            prot  srcPort  dstPort  octets      packets
192.0.2.37       216.82.253.163   6     25       62627    1294        12
192.0.2.36       81.30.219.92     6     25       63946    1064        15
203.16.60.9      192.0.2.36       6     25       1054     1628        31
...</pre><p>In this example, you can see only the flows where the protocol is 6 (TCP) and the source port is 25. This filter would be useful if you were investigating mail issues, for example. The filter shows that the mail server sent traffic from port 25, and hence the network level of the mail system is functioning.</p></div></div></div>
<div class="sect1" title="Useful Primitives"><div class="titlepage"><div><div><h1 class="title"><a id="useful_primitives"/>Useful Primitives</h1></div></div></div><p>Now that you understand how primitives and filters work together, I'll discuss primitives in depth. <code class="literal">flow-nfilter</code> supports many different primitives, but I'll cover only the most commonly useful ones here. The <code class="literal">flow-nfilter</code> man page includes the complete primitive list, but this book contains every one that I have used during several years of flow analysis.</p><div class="sect2" title="Protocol, Port, and Control Bit Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="protocol_comma_port_comma_and_control_bi"/>Protocol, Port, and Control Bit Primitives</h2></div></div></div><p>Filtering on network protocol and port information is one of the most common ways to strip a list of flow records down to only interesting traffic.</p><div class="sect3" title="IP Protocol Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="ip_protocol_primitives"/>IP Protocol Primitives</h3></div></div></div><p>You saw a basic IP protocol primitive earlier, but you can check for protocols other than TCP. For example, if you use IPSec, OSPF, or other network protocols that run over IP but that are not over TCP or UDP, you'll eventually need to view them separately. Filtering by protocol is the only way to differentiate between network applications that share port numbers, such as syslog (UDP/514) and rsh (TCP/514).<a class="indexterm" id="IDX-CHP-4-0024"/></p><p>When defining a protocol filter, you can use either the protocol number or name from <span class="emphasis"><em>/etc/protocols</em></span>. I prefer to use the number so that <span class="emphasis"><em>/etc/protocols</em></span> changes won't interfere with traffic analysis. For example, OSPF runs over protocol 89, so here's a filter to match it:</p><a id="I_programlisting4_d1e4672"/><pre class="programlisting">filter-primitive OSPF
    type ip-protocol
    permit 89</pre><p>Similarly, IPSec uses two different protocols: ESP (protocol 50) and AH (protocol 51). The following primitive matches all IPSec traffic. (Separate multiple entries with commas.)<a class="indexterm" id="IDX-CHP-4-0025"/><a class="indexterm" id="IDX-CHP-4-0026"/><a class="indexterm" id="IDX-CHP-4-0027"/><a class="indexterm" id="IDX-CHP-4-0028"/><a class="indexterm" id="IDX-CHP-4-0029"/><a class="indexterm" id="IDX-CHP-4-0030"/><a class="indexterm" id="IDX-CHP-4-0031"/><a class="indexterm" id="IDX-CHP-4-0032"/></p><a id="I_programlisting4_d1e4704"/><pre class="programlisting">filter-primitive IPSec
    type ip-protocol
    permit 50,51</pre><p>Although the IPSec protocols don't have port numbers, <code class="literal">flow-nfilter</code> can show you how much bandwidth an IPSec VPN between any two points uses and where your VPN clients connect from.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The default <span class="emphasis"><em>filter.cfg</em></span> includes primitives for TCP, UDP, and ICMP.<a class="indexterm" id="IDX-CHP-4-0033"/></p></div></div><div class="sect3" title="Port Number Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="port_number_primitives"/>Port Number Primitives</h3></div></div></div><p>Most network applications run on one or more ports. By filtering your output to include the port only for the network service you're interested in, you ease troubleshooting. To do so, use the <code class="literal">ip-port</code> primitive you saw earlier.</p><a id="I_programlisting4_d1e4730"/><pre class="programlisting">filter-primitive port80
    type ip-port
    permit 80</pre><p>A single primitive can include multiple ports, separated with commas like so:</p><a id="I_programlisting4_d1e4734"/><pre class="programlisting">filter-primitive webPorts
    type ip-port
    permit 80,443</pre><p>If you have a long list of ports, you can give each its own line and add comments. This example includes services that run over TCP (telnet and POP3) as well as UDP (SMB).</p><a id="I_programlisting4_d1e4738"/><pre class="programlisting">filter-primitive unwantedPorts
    type ip-port
    permit 23   #telnet
    permit 110  #unencrypted POP3
    permit 138  #Windows SMB
...</pre><p>You can also create primitives for ranges of ports.</p><a id="I_programlisting4_d1e4742"/><pre class="programlisting">filter-primitive msSqlRpc
    type ip-port
    permit 1024-5000</pre><p>IP port primitives can use names from <span class="emphasis"><em>/etc/services</em></span>, but I recommend using numbers to insulate you from changes or errors in that file. <code class="literal">flow-print</code> and <code class="literal">flow-report</code> can perform number-to-name translations if necessary.</p></div><div class="sect3" title="TCP Control Bit Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="tcp_control_bit_primitives"/>TCP Control Bit Primitives</h3></div></div></div><p>Filtering by TCP control bits identifies abnormal network flows. Use the <code class="literal">ip-tcp-flags</code> primitive to filter by control bits. (See <a class="xref" href="ch03s03.html" title="TCP Control Bits and Flow Records">TCP Control Bits and Flow Records</a> in <a class="xref" href="ch03s03.html" title="TCP Control Bits and Flow Records">TCP Control Bits and Flow Records</a>.)<a class="indexterm" id="IDX-CHP-4-0034"/><a class="indexterm" id="IDX-CHP-4-0035"/><a class="indexterm" id="IDX-CHP-4-0036"/><a class="indexterm" id="IDX-CHP-4-0037"/><a class="indexterm" id="IDX-CHP-4-0038"/><a class="indexterm" id="IDX-CHP-4-0039"/></p><a id="I_programlisting4_d1e4792"/><pre class="programlisting">filter-primitive syn-only
    type ip-tcp-flags
    permit 0x2</pre><p>This primitive matches flows with only a SYN control bit, also known as a <span class="emphasis"><em>SYN-only flow</em></span>. Either the server never responded to the request, a firewall blocked the connection request, or no server exists at the destination address.</p><p>These flows are fairly common on the naked Internet, where viruses and automated port scanners constantly probe every Internet address, but they should be comparatively uncommon on your internal network. Numerous SYN-only flows on an internal network usually indicate misconfigured software, a virus infection, or actual intruder probes.</p><p>Similarly, you can filter on flows that contain only an RST. An RST-only flow indicates that a connection request was received and immediately rejected, generally because a host is requesting service on a TCP port that isn't open. For example, if you ask a host for a web page when that host doesn't run a web server, you'll probably get a TCP RST.<a class="indexterm" id="IDX-CHP-4-0040"/></p><a id="I_programlisting4_d1e4806"/><pre class="programlisting">filter-primitive rst-only
    type ip-tcp-flags
    permit 0x4</pre><p>Although a certain level of this activity is normal, identifying the peak senders of SYN-only and RST-only flows can narrow down performance problems and unnecessary network congestion.</p><p>To identify flows with multiple control bits set, add the control bits together. For example, flows that contain only the SYN and RST control bits indicate system problems. To identify these flows, write a filter that matches SYN+RST packets.</p><a id="I_programlisting4_d1e4812"/><pre class="programlisting">filter-primitive syn-rst
    type ip-tcp-flags
    permit 0x6  # 0x2 (SYN) plus 0x4 (RST)</pre><p>Once you start examining TCP control bits on even a small network, you'll find all sorts of problems and quickly ruin your blissful ignorance.</p></div><div class="sect3" title="ICMP Type and Code Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="icmp_type_and_code_primitives"/>ICMP Type and Code Primitives</h3></div></div></div><p>Different ICMP type and code messages can illuminate network activity. Although you can filter flows based on ICMP type and code, it's not exactly easy to do so.</p><p>Flows encode the ICMP type and code as the destination port. A primitive that matches a particular type and code uses the <code class="literal">ip-port</code> primitive. ICMP type and code are usually expressed as hexadecimal, but <code class="literal">ip-port</code> takes decimal values. (Use <a class="xref" href="ch03s04.html#common_icmp_types_and_associated_codes_i" title="Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal">Table 3-4</a> in <a class="xref" href="ch03s04.html#types_and_codes_in_icmp" title="Types and Codes in ICMP">Types and Codes in ICMP</a> to identify the appropriate decimal values.)<a class="indexterm" id="IDX-CHP-4-0041"/><a class="indexterm" id="IDX-CHP-4-0042"/><a class="indexterm" id="IDX-CHP-4-0043"/><a class="indexterm" id="IDX-CHP-4-0044"/><a class="indexterm" id="IDX-CHP-4-0045"/><a class="indexterm" id="IDX-CHP-4-0046"/><a class="indexterm" id="IDX-CHP-4-0047"/></p><p>For example, suppose you're looking for hosts that send ICMP redirects. Redirects are ICMP type 5 and come in two codes, 0 (redirect subnet) and 1 (redirect host). In hexadecimal, these would be 500 and 501. <a class="xref" href="ch03s04.html#common_icmp_types_and_associated_codes_i" title="Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal">Table 3-4</a> shows their decimal values as 1280 and 1281, so write a primitive like this:<a class="indexterm" id="IDX-CHP-4-0048"/></p><a id="I_programlisting4_d1e4870"/><pre class="programlisting">filter-primitive redirects
    type ip-port
    permit 1280-1281
    default deny</pre><p>Used in a filter by itself, this primitive would pass ICMP, TCP, and UDP flows. When you create the actual filter, use both this primitive and the ICMP primitive to see only ICMP redirects.</p></div></div><div class="sect2" title="IP Address and Subnet Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_and_subnet_primitives"/>IP Address and Subnet Primitives</h2></div></div></div><p>Filtering flows by addresses and subnets lets you narrow down data to hosts and networks of interest.</p><div class="sect3" title="IP Addresses"><div class="titlepage"><div><div><h3 class="title"><a id="ip_addresses"/>IP Addresses</h3></div></div></div><p>Primitives for IP addresses use the <code class="literal">ip-address</code> type. It's reasonable to name primitives after the IP address they match, because IP addresses are difficult to confuse with other types of filter primitives.<a class="indexterm" id="IDX-CHP-4-0049"/><a class="indexterm" id="IDX-CHP-4-0050"/></p><a id="I_programlisting4_d1e4897"/><pre class="programlisting">filter-primitive 192.0.2.1
    type ip-address
    permit 192.0.2.1</pre><p>One primitive can include any number of addresses.</p><a id="I_programlisting4_d1e4901"/><pre class="programlisting">filter-primitive MailServers
    type ip-address
    permit 192.0.2.10
    permit 192.0.2.11</pre><p>A primitive such as this <code class="literal">MailServers</code> example lets you match multiple hosts that serve a particular function, such as "all web servers," "all file servers," and so on.</p></div><div class="sect3" title="Subnet Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="subnet_primitives"/>Subnet Primitives</h3></div></div></div><p>Primitives can also match subnets using the <code class="literal">ip-address-mask</code> and <code class="literal">ip-address-prefix</code> primitives. Flow-tools provides two different formats for subnets, <code class="literal">ip-address-mask</code> and <code class="literal">ip-address-prefix</code>, to match the two common notations for expressing subnets.</p><p>The <code class="literal">ip-address-mask</code> primitive expects a full IP network address with the netmask in decimal form, as follows:<a class="indexterm" id="IDX-CHP-4-0051"/><a class="indexterm" id="IDX-CHP-4-0052"/><a class="indexterm" id="IDX-CHP-4-0053"/></p><a id="I_programlisting4_d1e4943"/><pre class="programlisting">filter-primitive our-network
    type ip-address-mask
    permit 192.0.2.0 255.255.255.0</pre><p>This primitive matches all hosts with an IP between 192.0.2.0 and 192.0.2.255.</p><p>The <code class="literal">ip-address-prefix</code> primitive uses prefix (slash) notation.</p><a id="I_programlisting4_d1e4952"/><pre class="programlisting">filter-primitive our-network
    type ip-address-prefix
    permit 192.168.0/24
    permit 192.168.1/24</pre><p>You can include multiple subnets, each on its own line, in the subnet primitive, and the subnet masks or prefixes do not have to be equal in all the entries. For example, the following is a perfectly valid primitive:</p><a id="I_programlisting4_d1e4956"/><pre class="programlisting">filter-primitive mixed-netmasks
    type ip-address-prefix
    permit 192.168.0/23
    permit 192.168.2/24</pre><p>This primitive matches any IP address between 192.168.0.0 and 192.168.2.255.</p></div></div><div class="sect2" title="Time, Counter, and Double Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="time_comma_counter_comma_and_double_prim"/>Time, Counter, and Double Primitives</h2></div></div></div><p>You can filter flows by times during the day or by arbitrary counter values.</p><div class="sect3" title="Comparison Operators in Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="comparison_operators_in_primitives"/>Comparison Operators in Primitives</h3></div></div></div><p>Time and counter primitives use logical comparison operators, as shown in <a class="xref" href="ch04s02.html#time_and_counter_comparison_operators" title="Table 4-1. Time and Counter Comparison Operators">Table 4-1</a>.<a class="indexterm" id="IDX-CHP-4-0054"/></p><div class="table"><a id="time_and_counter_comparison_operators"/><p class="title">Table 4-1. Time and Counter Comparison Operators</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Time and Counter Comparison Operators"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Operator</p></th><th style="text-align: left" valign="bottom"><p>Comparison</p></th><th style="text-align: left" valign="bottom"><p>Time</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">gt</code></p></td><td style="text-align: left" valign="top"><p>Greater than</p></td><td style="text-align: left" valign="top"><p>Later than</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ge</code></p></td><td style="text-align: left" valign="top"><p>Greater than or equal to</p></td><td style="text-align: left" valign="top"><p>This time or later</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">lt</code></p></td><td style="text-align: left" valign="top"><p>Less than</p></td><td style="text-align: left" valign="top"><p>Earlier than</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">le</code></p></td><td style="text-align: left" valign="top"><p>Less than or equal to</p></td><td style="text-align: left" valign="top"><p>Earlier than or equal to</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">eq</code></p></td><td style="text-align: left" valign="top"><p>Equal</p></td><td style="text-align: left" valign="top"><p>Exactly this time</p></td></tr></tbody></table></div></div><p>Use these comparison operators <span class="emphasis"><em>only</em></span> in time and counter primitives, not in filter definitions.</p></div><div class="sect3" title="Time Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="time_primitives"/>Time Primitives</h3></div></div></div><p>To filter according to when flows began or stopped, use a <code class="literal">time</code> primitive. For example, here, you're looking for flows that stop or start some time during the minute of 8:03 <span class="keycap"><strong>am</strong></span>.<a class="indexterm" id="IDX-CHP-4-0055"/><a class="indexterm" id="IDX-CHP-4-0056"/><a class="indexterm" id="IDX-CHP-4-0057"/><a class="indexterm" id="IDX-CHP-4-0058"/><a class="indexterm" id="IDX-CHP-4-0059"/><a class="indexterm" id="IDX-CHP-4-0060"/></p><a id="I_programlisting4_d1e5087"/><pre class="programlisting">filter-primitive 0803
    type time
    permit eq 08:03</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember, flow records use a 24-hour clock, so 8:03 <span class="keycap"><strong>pm</strong></span> is filtered as 20:03.</p></div><p>You can narrow down a time period even further. For example, if you know that the traffic you're interested in started and stopped during the second of 8:03:30 <span class="keycap"><strong>am</strong></span>, you can write a primitive for that.</p><a id="I_programlisting4_d1e5100"/><pre class="programlisting">filter-primitive 0803
    type time
    permit eq 08:03:30</pre><p>You cannot filter on millisecond time intervals. Sensors and collectors are rarely accurate to milliseconds, however.</p><p>To define a time interval, use other comparison operators. For example, suppose you know that something happened on your network between 7:58 <span class="keycap"><strong>am</strong></span> and 8:03 <span class="keycap"><strong>am</strong></span>. To filter traffic during this time period, define a time window from 7:58 to 8:03, inclusive, with the <code class="literal">ge</code> and <code class="literal">lt</code> operators, like so:</p><a id="I_programlisting4_d1e5118"/><pre class="programlisting">filter-primitive crashTime
    type time
    permit ge 07:58
    permit le 08:03</pre><p>Although you can control the data you report on by selecting which flow files to analyze, using times helps narrow your searches even further. This is invaluable when examining large files, and it demonstrates the need for accurate time on your network.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">flow-nfilter</code> also supports the <code class="literal">time-date</code> primitive for a specific date and time, such as January 20, 2011, at 8:03 <span class="keycap"><strong>am</strong></span>. If you're interested in a specific date, however, you're better off analyzing the flow files for that date. Flow files are named for the year, month, day, and time of their creation for a reason.</p></div></div><div class="sect3" title="Counter Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="counter_primitives"/>Counter Primitives</h3></div></div></div><p>The <code class="literal">counter</code> primitive lets you create filters like "more than 100 octets" or "between 500 and 700 packets." When creating filters of this sort, use one or more comparison operators with integers to define counters, as follows:</p><a id="I_programlisting4_d1e5141"/><pre class="programlisting">filter-primitive clipping
    type counter
    permit gt 10000</pre><p>This particular filter would pass anything that has more than 10,000 of what you're trying to measure. As another example, suppose you want to look at flows that last only 1,000 milliseconds (1 second) or longer. Here's how you could do that:<a class="indexterm" id="IDX-CHP-4-0061"/><a class="indexterm" id="IDX-CHP-4-0062"/><a class="indexterm" id="IDX-CHP-4-0063"/><a class="indexterm" id="IDX-CHP-4-0064"/></p><a id="I_programlisting4_d1e5163"/><pre class="programlisting">filter-primitive 1second
    type counter
    permit ge 1000</pre><p>Or, perhaps you want only flows of 1KB or larger.</p><a id="I_programlisting4_d1e5167"/><pre class="programlisting">filter-primitive 1kB
    type counter
    permit ge 1024</pre><p>You can use multiple comparisons in a counter. For example, here, I'm permitting everything greater than 1,000 and less than 2,000:</p><a id="I_programlisting4_d1e5171"/><pre class="programlisting">filter-primitive average
    type counter
    permit gt 1000
    permit lt 2000</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>When using the <code class="literal">counter</code> primitive, keep in mind that counters work only when filtering based on octets, packets, and/or duration. Counters will not match TCP ports or IP addresses.</p></div></div><div class="sect3" title="Double Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="double_primitives"/>Double Primitives</h3></div></div></div><p>No, a <code class="literal">double</code> primitive isn't twice as primitive as the rest of flow-tools. A <code class="literal">double</code> primitive is a <code class="literal">counter</code> with a decimal point. It matches either packets per second or bits per second.</p><p>For example, suppose you want to ignore all connections that send 100 or more packets per second. You need a primitive to define the 100 part of that.</p><a id="I_programlisting4_d1e5195"/><pre class="programlisting">filter-primitive lessThan100
    type double
    permit lt 100.0</pre><p>You'll see how to tie this to the number of packets per second in a filter definition, but this primitive defines the "less than 100" part of the filter.</p><p>Like the <code class="literal">counter</code> primitive, the <code class="literal">double</code> cannot match arbitrary data. It can match only octets, packets, and duration.</p></div></div><div class="sect2" title="Interface and BGP Primitives"><div class="titlepage"><div><div><h2 class="title"><a id="interface_and_bgp_primitives"/>Interface and BGP Primitives</h2></div></div></div><p>Flow records exported from a router include routing information, but most of this information is useful only if you're using dynamic routing such as Border Gateway Protocol (BGP). If you are not using BGP or other dynamic routing protocols, you can skip this section.</p><div class="sect3" title="Identifying Interface Numbers Using SNMP"><div class="titlepage"><div><div><h3 class="title"><a id="identifying_interface_numbers_using_snmp"/>Identifying Interface Numbers Using SNMP</h3></div></div></div><p>Most router configuration interfaces (such as Cisco's command line) give each router interface a human-friendly name such as FastEthernet0 or Serial1/0. Internally, the router knows each interface by a number. The router uses the interface number in flow records, rather than the human-friendly name.<a class="indexterm" id="IDX-CHP-4-0065"/><a class="indexterm" id="IDX-CHP-4-0066"/><a class="indexterm" id="IDX-CHP-4-0067"/><a class="indexterm" id="IDX-CHP-4-0068"/></p><p>The simplest way to get the list of interface names and their corresponding numbers is through Simple Network Management Protocol (SNMP). If you're using multiple Internet providers, you almost certainly have some sort of SNMP capability. Most Unix-like systems include the net-snmp software suite, so I'll use that as an example. Other SNMP browsers should present similar results.</p><p>Remember, SNMP presents information as a hierarchical tree. To get a list of network interfaces, check the <code class="literal">RFC1213-MIB::ifDescr</code> branch of the SNMP tree. To see interface names and numbers, use <code class="literal">snmpwalk</code> to query the router's <code class="literal">RFC1213-MIB::ifDescr</code> values. If your MIB browser doesn't support human-friendly names, <code class="literal">RFC1213-MIB::ifDescr</code> is equivalent to <code class="literal">.1.3.6.1.2.1.2.2.1.2</code>.<a class="indexterm" id="IDX-CHP-4-0069"/></p><a id="I_programlisting4_d1e5256"/><pre class="programlisting"># <strong class="userinput"><code>snmpwalk -v</code></strong> ❶ <strong class="userinput"><code><em class="replaceable"><code>2</code></em></code></strong> <strong class="userinput"><code>-c</code></strong> ❷ <strong class="userinput"><code><em class="replaceable"><code>community</code></em></code></strong> ❸ <strong class="userinput"><code><em class="replaceable"><code>router</code></em></code></strong>
 <strong class="userinput"><code>RFC1213-MIB::ifDescr</code></strong>
RFC1213-MIB::ifDescr.❹1 = STRING: ❺ "FastEthernet0/0"
RFC1213-MIB::ifDescr.2 = STRING: "FastEthernet0/1"
RFC1213-MIB::ifDescr.4 = STRING: "Null0"
RFC1213-MIB::ifDescr.5 = STRING: "T1 0/0/0"
RFC1213-MIB::ifDescr.6 = STRING: "T1 0/0/1"
RFC1213-MIB::ifDescr.7 = STRING: "Serial0/0/0:0"
RFC1213-MIB::ifDescr.8 = STRING: "Serial0/0/1:1"
RFC1213-MIB::ifDescr.9 = STRING: "Tunnel1"</pre><p>In the previous example, at ❶ you query a router with SNMP version 2, using its community name (❷) and the router's hostname or IP address (❸). In response, you get a list of router interface names.</p><p>The SNMP index is the router's internal number for the interface. For example, at ❹ interface 1 is named <span class="emphasis"><em>FastEthernet0/0</em></span> (❺). Interface 7 is named <span class="emphasis"><em>Serial0/0/0:0</em></span>, and so on.</p><p>Network engineers should notice that of the eight interfaces listed, interface 4 (null0) is a logical interface and should never see any traffic. Similarly, interfaces 5 and 6 are not real interfaces; they are interface cards supporting interfaces 7 and 8. Only five of the eight interfaces should ever pass traffic.</p><p>By default, Cisco routers can change their interface numbering on a reboot, which prevents gaps in interface numbering when interfaces are added or removed. Interface numbers that change arbitrarily really confuse long-term reporting, however. I recommend making your router maintain consistent interface numbering across reboots. It's true that this leaves gaps in the interface list; note the absence of interface 3 on the example router. On the other hand, interface 7 is always Serial 0/0/0:0, even years later. Tell a Cisco device to leave interface numbering unchanged with the configuration option <code class="literal">snmp-server ifindex persist</code>.<a class="indexterm" id="IDX-CHP-4-0070"/></p><p>Also, note that if you have multiple routers exporting data to a single collector, you must separate the data to get meaningful interface information. For example, interface 8 on router A might be a local Ethernet interface, while interface 8 on router B might be an upstream T1 interface. You can filter data by exporter IP address, but this creates the need for an extra layer of filtering.<a class="indexterm" id="IDX-CHP-4-0071"/><a class="indexterm" id="IDX-CHP-4-0072"/><a class="indexterm" id="IDX-CHP-4-0073"/><a class="indexterm" id="IDX-CHP-4-0074"/><a class="indexterm" id="IDX-CHP-4-0075"/></p><p>I'll use the previous interface list in the upcoming examples. Interfaces 1 and 2 are local Ethernet ports, interfaces 7 and 8 are T1 circuits to two different Internet service providers, and interface 9 is a VPN tunnel. The other interfaces should never see traffic.</p></div><div class="sect3" title="Interface Number Primitive"><div class="titlepage"><div><div><h3 class="title"><a id="interface_number_primitive"/>Interface Number Primitive</h3></div></div></div><p>Filtering by interface passes only the traffic that traversed that interface. Use the <code class="literal">ifindex</code> primitive for this purpose.<a class="indexterm" id="IDX-CHP-4-0076"/></p><a id="I_programlisting4_d1e5338"/><pre class="programlisting">filter-primitive vpnInterface
    type ifindex
    permit 9</pre><p>Interface 9 is the VPN interface. Filtering on it shows you only traffic that goes over the VPN.</p><p>(You can list multiple interfaces on one line.)</p><a id="I_programlisting4_d1e5344"/><pre class="programlisting">filter-primitive localEthernet
    type ifindex
    permit 1,2</pre><p>Filtering by interface lets you focus on how traffic flows between particular network segments.</p></div><div class="sect3" title="Autonomous System Primitives"><div class="titlepage"><div><div><h3 class="title"><a id="autonomous_system_primitives"/>Autonomous System Primitives</h3></div></div></div><p>The Autonomous System (AS) is the core of BGP routing, and routers with BGP peers include AS number information in their flow exports. You can pull out traffic from particular AS numbers with the <code class="literal">as</code> primitive as follows:</p><a id="I_programlisting4_d1e5356"/><pre class="programlisting">filter-primitive uunet
    type as
    permit 701</pre><p>You can list multiple AS numbers separated by commas on a single line, or you can even list a range of AS numbers. Of course, you can also add multiple AS numbers on separate lines. (ARIN, RIPE, and other AS registrars frequently issue AS numbers to large organizations in blocks, so you might need to create such a filter.)</p><a id="I_programlisting4_d1e5360"/><pre class="programlisting">filter-primitive uunet
    type as
    permit 701-705</pre><p>You can also write filters for route announcement prefix length using the <code class="literal">ip-address-prefix-len</code> primitive. I haven't found a use for a filter that says "Show me all the routes we're getting that are /25 or longer," but carriers and transit providers might find it useful to identify clients that are trying to announce tiny networks.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">5</a>]</sup><a class="indexterm" id="IDX-CHP-4-0077"/><a class="indexterm" id="IDX-CHP-4-0078"/><a class="indexterm" id="IDX-CHP-4-0079"/><a class="indexterm" id="IDX-CHP-4-0080"/><a class="indexterm" id="IDX-CHP-4-0081"/><a class="indexterm" id="IDX-CHP-4-0082"/><a class="indexterm" id="IDX-CHP-4-0083"/><a class="indexterm" id="IDX-CHP-4-0084"/><a class="indexterm" id="IDX-CHP-4-0085"/><a class="indexterm" id="IDX-CHP-4-0086"/><a class="indexterm" id="IDX-CHP-4-0087"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">5</a>] </sup>If you're not a transit provider but are trying to announce tiny networks, the lesson you should learn here is this: Tiny route announcements won't work, and if they do, they can find you.</p></div></div></div>
<div class="sect1" title="Filter Match Statements"><div class="titlepage"><div><div><h1 class="title"><a id="filter_match_statements"/>Filter Match Statements</h1></div></div></div><p>To assemble primitives into filters, use <code class="literal">match</code> statements. <code class="literal">flow-nfilter</code> compares each flow against every <code class="literal">match</code> statement in a filter, and if a flow fits every <code class="literal">match</code> statement, the flow passes through. If the flow does not fit every <code class="literal">match</code> statement, the flow is removed from the data stream.</p><p>Many match types have names that are similar to their associated primitives. For example, the <code class="literal">ip-protocol</code> primitive has a corresponding <code class="literal">ip-protocol</code> match. Other primitives have no single matching condition. For example, the <code class="literal">ip-port</code> primitive can match either the <code class="literal">ip-source-port</code> primitive or the <code class="literal">ip-destination-port</code> primitive. If you use an incorrect <code class="literal">match</code> statement in your configuration, <code class="literal">flow-nfilter</code> exits with an error.</p><p>Filter definitions support many different types of match condition. The <code class="literal">flow-nfilter</code> manual page has the complete list, but the ones I find useful are described here.</p><div class="sect2" title="Protocols, Ports, and Control Bits"><div class="titlepage"><div><div><h2 class="title"><a id="protocols_comma_ports_comma_and_control"/>Protocols, Ports, and Control Bits</h2></div></div></div><p>Matching protocols and ports is very common. Control bits and ICMP type and code are less common but powerful in a different way.</p><div class="sect3" title="Network Protocol Filters"><div class="titlepage"><div><div><h3 class="title"><a id="network_protocol_filters"/>Network Protocol Filters</h3></div></div></div><p>Use the <code class="literal">ip-protocol</code> match type to check each flow against an <code class="literal">ip-protocol</code> primitive.</p><p>I previously defined a primitive for OSPF. Here I'm using that primitive to pass only OSPF traffic:</p><a id="I_programlisting4_d1e5479"/><pre class="programlisting">filter-definition OSPF
  match ip-protocol OSPF</pre><p>Listing multiple protocol primitives in a filter will cause no packets to match. After all, very few single flows are both TCP and UDP.</p></div><div class="sect3" title="Source or Destination Port Filters"><div class="titlepage"><div><div><h3 class="title"><a id="source_or_destination_port_filters"/>Source or Destination Port Filters</h3></div></div></div><p><code class="literal">flow-nfilter</code> has separate matches for source ports (<code class="literal">ip-source-port</code>) and destination ports (<code class="literal">ip-destination-port</code>). These match against the <code class="literal">ip-port</code> primitive. Here I'm using the <code class="literal">port80</code> primitive defined earlier to filter traffic to a web server:<a class="indexterm" id="IDX-CHP-4-0088"/><a class="indexterm" id="IDX-CHP-4-0089"/><a class="indexterm" id="IDX-CHP-4-0090"/></p><a id="I_programlisting4_d1e5516"/><pre class="programlisting">filter-definition port80
    match ip-destination-port port80</pre><p>To match multiple ports for one service, define a primitive that includes all the ports for that service. For example, earlier I defined a <code class="literal">webTraffic</code> primitive for ports 80 and 443.</p><a id="I_programlisting4_d1e5523"/><pre class="programlisting">filter-definition webTraffic
    match ip-destination-port webTraffic</pre><p>Use the <code class="literal">ip-source-port</code> similarly. For example, to capture traffic leaving your web server, filter the flows leaving ports 80 and 443. (You'll see how to write reports that match both arriving and departing traffic in <a class="xref" href="ch04s05.html" title="Logical Operators in Filter Definitions">Logical Operators in Filter Definitions</a> in <a class="xref" href="ch04s05.html" title="Logical Operators in Filter Definitions">Logical Operators in Filter Definitions</a>.)</p><a id="I_programlisting4_d1e5534"/><pre class="programlisting">filter-definition webTraffic
    match ip-source-port webTraffic</pre></div><div class="sect3" title="TCP Control Bit Filters"><div class="titlepage"><div><div><h3 class="title"><a id="tcp_control_bit_filters"/>TCP Control Bit Filters</h3></div></div></div><p>Use the <code class="literal">ip-tcp-flags</code> keyword to match TCP control bit primitives. For example, I previously defined a <code class="literal">rst-only</code> primitive that matched flows that contained TCP resets only.<a class="indexterm" id="IDX-CHP-4-0091"/></p><a id="I_programlisting4_d1e5552"/><pre class="programlisting">filter-definition resets
    match ip-tcp-flags rst-only</pre><p>This filter displays only the flows that match the <code class="literal">rst-only</code> primitive. You don't need to specify a protocol, because flow records contain control bits only for TCP flows. You could use very similar filters for the other TCP control bit primitives.</p></div><div class="sect3" title="ICMP Type and Code Filters"><div class="titlepage"><div><div><h3 class="title"><a id="icmp_type_and_code_filters"/>ICMP Type and Code Filters</h3></div></div></div><p>Remember that flows record the ICMP type and code in the destination port field of ICMP flows. However, unlike TCP control bits, which appear only in the records of TCP flows, destination ports appear in TCP, UDP, and ICMP flows. To specifically match ICMP type and code, your filter must include the destination port and the protocol as follows:<a class="indexterm" id="IDX-CHP-4-0092"/></p><a id="I_programlisting4_d1e5569"/><pre class="programlisting">filter-definition redirects
❶    match ip-destination-port redirects
❷    match ip-protocol ICMP</pre><p>I previously defined a <code class="literal">redirects</code> primitive at ❶ that matched both codes within the ICMP redirect type. Here, I'm adding a match (❷) for the <code class="literal">ICMP</code> protocol primitive as well. This filter passes only the flows that contain ICMP redirects.</p></div></div><div class="sect2" title="Addresses and Subnets"><div class="titlepage"><div><div><h2 class="title"><a id="addresses_and_subnets"/>Addresses and Subnets</h2></div></div></div><p><code class="literal">flow-nfilter</code> supports two match types for IP addresses: source (<code class="literal">ip-source-address</code>) or destination address (<code class="literal">ip-destination-address</code>). These match types can work on any of the three IP address primitives: <code class="literal">ip-address</code>, <code class="literal">ip-address-mask</code>, or <code class="literal">ip-address-prefix</code>.<a class="indexterm" id="IDX-CHP-4-0093"/><a class="indexterm" id="IDX-CHP-4-0094"/><a class="indexterm" id="IDX-CHP-4-0095"/><a class="indexterm" id="IDX-CHP-4-0096"/><a class="indexterm" id="IDX-CHP-4-0097"/><a class="indexterm" id="IDX-CHP-4-0098"/><a class="indexterm" id="IDX-CHP-4-0099"/><a class="indexterm" id="IDX-CHP-4-0100"/><a class="indexterm" id="IDX-CHP-4-0101"/><a class="indexterm" id="IDX-CHP-4-0102"/><a class="indexterm" id="IDX-CHP-4-0103"/></p><p>You can match the source address on one line and the destination address on another line. For example, suppose you have an <code class="literal">ip-address-prefix</code> primitive for your client's network and another for your web servers. The following definition passes traffic from your client to your web server:</p><a id="I_programlisting4_d1e5648"/><pre class="programlisting">filter-definition clientsToWeb
    match ip-destination-address webServers
    match ip-source-address clientNetwork</pre><p>You cannot list multiple matches of the same type in a single filter because a single flow cannot have multiple source or destination addresses! To pass traffic from several source or destination addresses, use a primitive that contains all the desired addresses.</p><p>The next filter captures data coming into the server from web clients. You need a corresponding report to catch traffic from your web servers to the client network (or a slightly more complicated filter to capture traffic moving in both directions, as you'll see in <a class="xref" href="ch04s05.html" title="Logical Operators in Filter Definitions">Logical Operators in Filter Definitions</a> in <a class="xref" href="ch04s05.html" title="Logical Operators in Filter Definitions">Logical Operators in Filter Definitions</a>). Because you want to see only web traffic, you also filter with primitives for web traffic and TCP.</p><a id="I_programlisting4_d1e5658"/><pre class="programlisting">filter-definition clientsToWebHttpTraffic
    match ip-port webTraffic
    match ip-protocol TCP
    match ip-destination-address webServers
    match ip-source-address clientNetwork</pre><p>You'll see other ways to achieve this same effect in <a class="xref" href="ch04s04.html" title="Using Multiple Filters">Using Multiple Filters</a> in <a class="xref" href="ch04s03.html#next-hop_address_filters" title="Next-Hop Address Filters">Next-Hop Address Filters</a>.</p></div><div class="sect2" title="Filtering by Sensor or Exporter"><div class="titlepage"><div><div><h2 class="title"><a id="filtering_by_sensor_or_exporter"/>Filtering by Sensor or Exporter</h2></div></div></div><p>Multiple flow sensors can export to a single collector, but at times you'll want to see only the flows that came from a particular sensor. You can use the <code class="literal">ip-exporter-address</code> match with any IP address primitive to create a filter that passes flows from a particular sensor, as follows:</p><a id="I_programlisting4_d1e5674"/><pre class="programlisting">filter-primitive router1
    type ip-address
    permit 192.0.2.1

filter-definition router1-exports
    match ip-exporter-address router1</pre><p>This particular filter passes only the flows exported from the router at 192.0.2.1.</p></div><div class="sect2" title="Time Filters"><div class="titlepage"><div><div><h2 class="title"><a id="time_filters"/>Time Filters</h2></div></div></div><p>The <code class="literal">start-time</code> and <code class="literal">end-time</code> match types let you filter on when flows begin and end, using the <code class="literal">time</code> primitive. For example, the following sample captures all flows that take place entirely within a particular minute, using the <code class="literal">0803</code> time primitive defined earlier:<a class="indexterm" id="IDX-CHP-4-0104"/><a class="indexterm" id="IDX-CHP-4-0105"/><a class="indexterm" id="IDX-CHP-4-0106"/><a class="indexterm" id="IDX-CHP-4-0107"/><a class="indexterm" id="IDX-CHP-4-0108"/><a class="indexterm" id="IDX-CHP-4-0109"/><a class="indexterm" id="IDX-CHP-4-0110"/><a class="indexterm" id="IDX-CHP-4-0111"/><a class="indexterm" id="IDX-CHP-4-0112"/></p><a id="I_programlisting4_d1e5729"/><pre class="programlisting">filter-definition 0803
    match start-time 0803
    match end-time 0803</pre><p>You can define a filter to match flows starting or ending at any time that you can express with a primitive.</p><p>In most cases, you won't have accurate time information about problems. Human beings have a notoriously fuzzy time sense: "A few minutes ago" might be anything from 30 seconds to an hour, and after a few days even that is unreliable. Remember that each flow file covers a five-minute period. Most of the time you're better off searching entire flow files for issues rather than trying to filter on times. I find that filtering on times is useful only on very large flow files and then only when you have precise timing information from the flow files themselves. A human saying that the website broke at 8:15 <span class="keycap"><strong>am</strong></span> is not reliable. If your flow records say that you had unusual traffic at 8:15 <span class="keycap"><strong>am</strong></span>, however, you might want to see what else happened during that minute. Filtering on times can be useful in that instance.</p></div><div class="sect2" title="Clipping Levels"><div class="titlepage"><div><div><h2 class="title"><a id="clipping_levels"/>Clipping Levels</h2></div></div></div><p>A <span class="emphasis"><em>clipping level</em></span> is the point at which you start ignoring data. For example, you might not care about flows that contain tiny amounts of data, or perhaps you want to see only tiny flows. To clip data, you can set clipping levels on the amount of traffic transmitted, the connection speed, and the duration of connections.<a class="indexterm" id="IDX-CHP-4-0113"/></p><div class="sect3" title="Octets, Packets, and Duration Filters"><div class="titlepage"><div><div><h3 class="title"><a id="octets_comma_packets_comma_and_duration"/>Octets, Packets, and Duration Filters</h3></div></div></div><p>Use <code class="literal">counter</code> primitives to filter based on the number of octets per flow, the packets per flow, or the duration of flows. For example, earlier I defined a primitive for 1KB or larger. Let's use that primitive now to remove the tiny connections from the flow data.<a class="indexterm" id="IDX-CHP-4-0114"/></p><a id="I_programlisting4_d1e5763"/><pre class="programlisting">filter-definition 1kBplus
    match octets 1kB</pre><p>Similarly, you created a primitive for anything that totaled 1,000 or more, called <code class="literal">1second</code>. You can write a filter that uses this primitive to allow only flows of 1,000 milliseconds (1 second) or longer.</p><a id="I_programlisting4_d1e5770"/><pre class="programlisting">filter-definition over1second
    match duration 1second</pre><p>Counters are arbitrary numbers and can apply to octets, packets, or duration. For example, if you want a filter that includes only flows with 1,024 or more packets, you could easily reuse the <code class="literal">1kB</code> primitive for that.<a class="indexterm" id="IDX-CHP-4-0115"/><a class="indexterm" id="IDX-CHP-4-0116"/><a class="indexterm" id="IDX-CHP-4-0117"/><a class="indexterm" id="IDX-CHP-4-0118"/><a class="indexterm" id="IDX-CHP-4-0119"/><a class="indexterm" id="IDX-CHP-4-0120"/><a class="indexterm" id="IDX-CHP-4-0121"/><a class="indexterm" id="IDX-CHP-4-0122"/><a class="indexterm" id="IDX-CHP-4-0123"/></p><a id="I_programlisting4_d1e5809"/><pre class="programlisting">filter-definition 1024plusPackets
    match packets 1kB</pre><p>Even though you can, I try not to reuse primitives in this way. You never hear of a kilobyte of packets! Such filters confuse me. Being confused while trying to identify network problems is not good.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-2" id="CHP-4-FN-2">6</a>]</sup></p></div><div class="sect3" title="Packets or Bits per Second Filters"><div class="titlepage"><div><div><h3 class="title"><a id="packets_or_bits_per_second_filters"/>Packets or Bits per Second Filters</h3></div></div></div><p>Perhaps you're interested in how quickly connections move or you're interested only in the really fast or really slow connections. If so, you can use <code class="literal">double</code> primitives to filter based on packets per second or bits per second.</p><p>For example, earlier you defined a <code class="literal">double</code> primitive for less than 100. You can use this for either packets per second or bits per second.</p><a id="I_programlisting4_d1e5829"/><pre class="programlisting">filter-definition lessThan100pps
    match pps lessThan100

filter-definition lessThan100bps
    match bps lessThan100</pre><p>In this particular case, I don't mind reusing the <code class="literal">lessThan100</code> primitive, because the name isn't so closely tied to a particular data type.</p></div></div><div class="sect2" title="BGP and Routing Filters"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_and_routing_filters"/>BGP and Routing Filters</h2></div></div></div><p>You can filter flows based on the routing information included in the flow records. (If you are not using BGP, you can skip this section.)</p><div class="sect3" title="Autonomous System Number Filters"><div class="titlepage"><div><div><h3 class="title"><a id="autonomous_system_number_filters"/>Autonomous System Number Filters</h3></div></div></div><p>The <code class="literal">source-as</code> and <code class="literal">destination-as</code> match types let you match based on AS numbers. For example, this filter lets you see what traffic you're receiving (from what was the UUnet network) using the <code class="literal">uunet</code> AS primitive defined earlier:</p><a id="I_programlisting4_d1e5855"/><pre class="programlisting">filter-definition uunet
    match source-as uunet</pre><p>You could also turn this around to create a filter to permit the traffic you're sending to UUnet systems.</p></div><div class="sect3" title="Next-Hop Address Filters"><div class="titlepage"><div><div><h3 class="title"><a id="next-hop_address_filters"/>Next-Hop Address Filters</h3></div></div></div><p>The <span class="emphasis"><em>next hop</em></span> is the IP address where a router sends a flow. This is usually the IP address on the remote end of an ISP circuit (for outgoing flows) or the external address of your firewall (for inbound flows). Routers include the next hop in flow records. However, software flow sensors like <code class="literal">softflowd</code> know nothing of interfaces on remote hosts or how packets are routed, so flows exported from software flow sensors do not contain next-hop addresses.<a class="indexterm" id="IDX-CHP-4-0124"/><a class="indexterm" id="IDX-CHP-4-0125"/><a class="indexterm" id="IDX-CHP-4-0126"/><a class="indexterm" id="IDX-CHP-4-0127"/><a class="indexterm" id="IDX-CHP-4-0128"/><a class="indexterm" id="IDX-CHP-4-0129"/><a class="indexterm" id="IDX-CHP-4-0130"/><a class="indexterm" id="IDX-CHP-4-0131"/><a class="indexterm" id="IDX-CHP-4-0132"/><a class="indexterm" id="IDX-CHP-4-0133"/><a class="indexterm" id="IDX-CHP-4-0134"/><a class="indexterm" id="IDX-CHP-4-0135"/></p><p>Now suppose that the next-hop IP address for one of your Internet providers is 61.118.12.45. To filter all traffic leaving your network via that ISP, you could use a primitive and a definition like this:</p><a id="I_programlisting4_d1e5919"/><pre class="programlisting">filter-primitive ispA
    type ip-address
    permit 61.118.12.45

filter-definition ispA
    match ip-nexthop-address ispA</pre><p>The <code class="literal">ip-nexthop-address</code> match type works with the primitives <code class="literal">ip-address</code>, <code class="literal">ip-address-mask</code>, and <code class="literal">ip-address-prefix</code>.</p></div><div class="sect3" title="Interface Filters"><div class="titlepage"><div><div><h3 class="title"><a id="interface_filters"/>Interface Filters</h3></div></div></div><p>Another way to filter by provider or network segment is to filter by the router interface. The match types <code class="literal">input-interface</code> and <code class="literal">output-interface</code> let you filter by traffic arriving or leaving your router.</p><p>You defined a primitive for router interface 9 earlier. Here I'm using it in a filter:</p><a id="I_programlisting4_d1e5948"/><pre class="programlisting">filter-definition vpn
    match input-interface vpnInterface</pre><p>This shows traffic entering the router on this interface.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-2" id="ftn.CHP-4-FN-2">6</a>] </sup>I don't need to waste my time calling myself an idiot because I gave a filter an ambiguous name. Many other people are delighted to call me an idiot for all sorts of reasons.</p></div></div></div>
<div class="sect1" title="Using Multiple Filters"><div class="titlepage"><div><div><h1 class="title"><a id="using_multiple_filters"/>Using Multiple Filters</h1></div></div></div><p>Suppose you want to identify all traffic between two machines. You could define primitives for those two hosts and then write a filter that specifically defines those hosts. However, this common situation will keep you very busy writing new filters. Instead, I find it much easier to define smaller filters and tie them together on the command line.<a class="indexterm" id="IDX-CHP-4-0136"/></p><p>You can invoke <code class="literal">flow-nfilter</code> repeatedly in a single command. Find the flow files for the times you're interested in, filter them for the first host, and then filter them a second time for the second host.</p><a id="I_programlisting4_d1e5965"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-* |</code></strong> ❶ <strong class="userinput"><code>flow-nfilter -F host1 |</code></strong> ❷
 <strong class="userinput"><code>flow-nfilter -F host2 | flow-print | less</code></strong></pre><p>The first <code class="literal">flow-nfilter</code> invocation at ❶ passes only flows that include traffic from <code class="literal">host1</code>. The second at ❷ passes only flows that include traffic from <code class="literal">host2</code>.<a class="indexterm" id="IDX-CHP-4-0137"/><a class="indexterm" id="IDX-CHP-4-0138"/><a class="indexterm" id="IDX-CHP-4-0139"/><a class="indexterm" id="IDX-CHP-4-0140"/></p><p>Similarly, you can write separate filters for certain protocols, like all web traffic. You previously created a filter for all HTTP and HTTPS traffic, called <code class="literal">webTraffic</code>.<a class="indexterm" id="IDX-CHP-4-0141"/></p><a id="I_programlisting4_d1e6010"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-* |</code></strong> ❶ <strong class="userinput"><code>flow-nfilter -F host1 |</code></strong> ❷
 <strong class="userinput"><code>flow-nfilter -F webTraffic | flow-print | less</code></strong></pre><p>The first filter at ❶ passes only traffic for the interesting host, and the second (❷) passes only HTTP and HTTPS traffic.</p><p>You can create simple filters for important hosts and subnets on your network. For example, if you have a customer who reports problems reaching your website, you could write one flow filter for your site and one for the customer's addresses and use them both to see what traffic passed between your networks. You could then look for SYN-only or RST-only flows that would indicate problems. Or you might find that traffic from the customer's network never reaches you at all. In any case, these two filters will tell you exactly what traffic appeared on your network and how it behaved.</p><p>By combining filters on the command line, you will write fewer filters and get more use out of the filters you create.</p></div>
<div class="sect1" title="Logical Operators in Filter Definitions"><div class="titlepage"><div><div><h1 class="title"><a id="logical_operators_in_filter_definitions"/>Logical Operators in Filter Definitions</h1></div></div></div><p>When you put multiple match conditions in a filter definition, <code class="literal">flow-nfilter</code> places a logical "and" between them. For example, the following filter shows all traffic that runs over TCP and has a source port of 25. This passes an email server's responses to a connection.</p><a id="I_programlisting4_d1e6034"/><pre class="programlisting">filter-definition TCPport25
    match ip-protocol TCP
    match ip-source-port port25</pre><p>You can use other logical operators to build very complicated filters.</p><div class="sect2" title="Logical &quot;or&quot;"><div class="titlepage"><div><div><h2 class="title"><a id="logical_quotation_mark_or_quotation_mark"/>Logical "or"</h2></div></div></div><p>When I try to analyze a connection problem, I usually want to see both sides of the conversation. I want a filter that will show connections to port 25 as well as from port 25. For this, use the <code class="literal">or</code> operator as follows:</p><a id="I_programlisting4_d1e6046"/><pre class="programlisting">filter-definition email
     match ip-protocol TCP
     match ip-source-port port25
❶    or
❷    match ip-protocol TCP
❸    match ip-destination-port port25</pre><p>After the <code class="literal">or</code> statement at ❶, a whole new filter definition begins. Although I listed <code class="literal">TCP</code> in the first filter, if you're interested in TCP in the second filter, you must repeat the match on TCP at ❷, after which you can add the new <code class="literal">match</code> statement at ❸ to catch flows that end on port 25. Now, if you apply this filter to your flow data, you'll see something like this:<a class="indexterm" id="IDX-CHP-4-0142"/><a class="indexterm" id="IDX-CHP-4-0143"/></p><a id="I_programlisting4_d1e6067"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-20.12* | flow-nfilter -F email | flow-print | less</code></strong>
  srcIP            dstIP            prot  srcPort  dstPort  octets      packets
❶ 217.199.0.33     192.0.2.37       6     5673     25       192726      298
❷ 192.0.2.37       217.199.0.33     6     25       5673     8558        181
  206.165.246.249  192.0.2.37       6     38904    25       13283       22
  192.0.2.37       206.165.246.249  6     25       38904    1484        16
  ...</pre><p>The first flow at ❶ is from a remote IP to the address of the local email server, with a destination port of 25. This is an incoming mail transmission. The second flow at ❷ is from the mail server to the same remote IP address; it's coming from port 25. This is the response to the first flow.</p><p>I could use more sophisticated <code class="literal">flow-print</code> formats to view this in more detail, run <code class="literal">flow-report</code> on this data to check for errors, or add another filter to specifically point out TCP errors in the email stream. This simple check shows me that the mail server is exchanging substantial amounts of traffic on TCP port 25, however. I would tell my mail administrator to check the logs for errors or provide more information.</p></div><div class="sect2" title="Filter Inversion"><div class="titlepage"><div><div><h2 class="title"><a id="filter_inversion"/>Filter Inversion</h2></div></div></div><p>Sometimes it's easier to write a filter for the traffic you're <span class="emphasis"><em>not</em></span> interested in. For example, suppose you want to see all the traffic to or from your email servers that isn't email. Although you could write primitives that included all port numbers except those for email, that's annoying and tedious.</p><p>Instead, use the <code class="literal">invert</code> keyword to reverse the meaning of a filter, like so:</p><a id="I_programlisting4_d1e6095"/><pre class="programlisting">filter-definition not-email
❶    invert
     match ip-protocol TCP
     match ip-source-port port25
     or
     match ip-protocol TCP
     match ip-destination-port port25</pre><p>By adding <code class="literal">invert</code> to the report at ❶, you pass everything that doesn't match the defined filters. In this example, I'm passing every network transaction that doesn't involve TCP port 25.</p><p>But there's a problem with this filter: It will match all nonemail traffic on all the hosts for which you're capturing data. You, however, need to view only traffic for your email hosts.</p><p>To solve this problem, you could add your email servers into the <code class="literal">not-email</code> filter, but the email servers both send and receive email. You would need a definition section for remote servers connecting to your mail servers, a section for your servers' response to those remote servers, a third section for your mail servers connecting to remote mail servers, and a fourth for the remote servers' responses to your servers' requests. That's pretty ugly.<a class="indexterm" id="IDX-CHP-4-0144"/><a class="indexterm" id="IDX-CHP-4-0145"/><a class="indexterm" id="IDX-CHP-4-0146"/><a class="indexterm" id="IDX-CHP-4-0147"/><a class="indexterm" id="IDX-CHP-4-0148"/></p><p>It's much simpler to define a separate filter that strips the flow data down to just the email servers and then to concatenate the two, as follows:</p><a id="I_programlisting4_d1e6132"/><pre class="programlisting">❶     filter-primitive emailServers
      type ip-address
      permit 192.0.2.37
      permit 192.0.2.36

❷     filter-definition emailServers
      match ip-source-address emailServers
      or
      match ip-destination-address emailServers</pre><p>The <code class="literal">emailServers</code> primitive at ❶ includes the IP addresses of all the mail servers. Next, at ❷ I create a filter definition to match all traffic leaving or going to those servers. Then, to see all nonemail traffic to or from my email servers, I do this:</p><a id="I_programlisting4_d1e6139"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat * |</code></strong> ❶ <strong class="userinput"><code>flow-nfilter -F emailServers |</code></strong> ❷
 <strong class="userinput"><code>flow-nfilter -F not-email | flow-print | less</code></strong></pre><p>The <code class="literal">emailServers</code> filter at ❶ passes only the flows that involve my email servers. The <code class="literal">not-email</code> filter at ❷ passes only flows that are not SMTP. By combining these two filters, I see only interesting traffic. I'll probably need to adjust the filter further to remove other uninteresting traffic, such as DNS queries to the DNS server, but I'm almost there.</p><p>Of course, after reviewing the filtered traffic, I can go ask my email administrator why he's running his own DNS server on the mail server instead of using the corporate name servers and why he browses the Web from those machines instead of using the proxy server and its adult content filters.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-3" id="CHP-4-FN-3">7</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-3" id="ftn.CHP-4-FN-3">7</a>] </sup>Yes, I could take this straight to human resources, but HR won't wash and wax my car.</p></div></div></div>
<div class="sect1" title="Filters and Variables"><div class="titlepage"><div><div><h1 class="title"><a id="filters_and_variables"/>Filters and Variables</h1></div></div></div><p>Flow-tools also includes filters that can be configured on the command line, which can be useful for very simple filters, such as identifying traffic from a particular IP address. The default filters that use these are fairly limited, but they'll suffice for simple traffic analysis. It's also easy to write your own variable-driven reports.</p><div class="sect2" title="Using Variable-Driven Filters"><div class="titlepage"><div><div><h2 class="title"><a id="using_variable-driven_filters"/>Using Variable-Driven Filters</h2></div></div></div><p>The filters that are configurable on the command line use three variables: <code class="literal">ADDR</code> (address), <code class="literal">PORT</code> (port), and <code class="literal">PROT</code> (protocol). These support five reports, letting you filter by protocol as well as by source and destination address and port: <code class="literal">ip-src-addr</code>, <code class="literal">ip-dst-addr</code>, <code class="literal">ip-src-port</code>, <code class="literal">ip-dest-port</code>, and <code class="literal">ip-prot</code>.<a class="indexterm" id="IDX-CHP-4-0149"/><a class="indexterm" id="IDX-CHP-4-0150"/><a class="indexterm" id="IDX-CHP-4-0151"/><a class="indexterm" id="IDX-CHP-4-0152"/><a class="indexterm" id="IDX-CHP-4-0153"/><a class="indexterm" id="IDX-CHP-4-0154"/><a class="indexterm" id="IDX-CHP-4-0155"/><a class="indexterm" id="IDX-CHP-4-0156"/></p><p>Suppose your boss calls. She's connecting from a random open wireless hotspot in some inconvenient city and can't get into the corporate VPN concentrator. You get her IP address, either by asking her for it or by accessing system logs to see where she's coming from. To see all the traffic coming to your network from her IP, without writing a custom filter, you could use a command-line variable on the flow files for that time window. For example, if she's at the IP address 192.0.2.8, you'd use a command like this:</p><a id="I_programlisting4_d1e6229"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat * | flow-nfilter -F ip-src-addr</code></strong> ❶ <strong class="userinput"><code>-v ADDR=192.0.2.8 | flow-print</code></strong></pre><p>The <code class="literal">-v</code> argument at ❶ tells <code class="literal">flow-nfilter</code> that you're assigning a value to a variable. In this example, I've assigned the value 192.0.2.8 to the variable <code class="literal">ADDR</code>. You'll see all traffic originating from that IP address.</p><div class="sidebar"><a id="when_to_use_variable-driven_filters_ques"/><p class="title">WHEN TO USE VARIABLE-DRIVEN FILTERS?</p><p>For simple filters on individual hosts and ports, use variable-driven filters. If you must filter on multiple hosts or ranges of ports, define primitives and filters in <span class="emphasis"><em>filter.cfg</em></span>.<a class="indexterm" id="IDX-CHP-4-0157"/></p></div></div><div class="sect2" title="Defining Your Own Variable-Driven Filters"><div class="titlepage"><div><div><h2 class="title"><a id="defining_your_own_variable-driven_filter"/>Defining Your Own Variable-Driven Filters</h2></div></div></div><p>Variable-driven filters take advantage of the primitives <code class="literal">VAR_ADDR</code> (address), <code class="literal">VAR_PORT</code> (port), and <code class="literal">VAR_PROT</code> (protocol), as defined in <span class="emphasis"><em>filter.cfg</em></span>. For example, the following is a default variable-driven filter that uses the <code class="literal">ADDR</code> variable. This looks exactly like a standard report, except that it uses the variable name instead of a primitive.</p><a id="I_programlisting4_d1e6278"/><pre class="programlisting">filter-definition ip-src-addr
    match ip-source-address VAR_ADDR</pre><p>Use these variables to define your own variable-driven filters. For example, I like to see all traffic to <span class="emphasis"><em>and</em></span> from a host of interest. Writing a command-line version of this report is easy.</p><a id="I_programlisting4_d1e6285"/><pre class="programlisting">filter-definition ip-addr
    match ip-destination-address VAR_ADDR
    or
    match ip-source-address VAR_ADDR</pre><p>Similarly, I prefer to see all traffic to <span class="emphasis"><em>and</em></span> from a port simultaneously.</p><a id="I_programlisting4_d1e6292"/><pre class="programlisting">filter-definition ip-port
    match ip-destination-address VAR_PORT
    or
    match ip-source-address VAR_PORT</pre><p>With these reports, I can dynamically filter for any individual host or port on the fly.<a class="indexterm" id="IDX-CHP-4-0158"/><a class="indexterm" id="IDX-CHP-4-0159"/><a class="indexterm" id="IDX-CHP-4-0160"/></p></div><div class="sect2" title="Creating Your Own Variables"><div class="titlepage"><div><div><h2 class="title"><a id="creating_your_own_variables"/>Creating Your Own Variables</h2></div></div></div><p><code class="literal">VAR_ADDR</code>, <code class="literal">VAR_PORT</code>, and <code class="literal">VAR_PROT</code> are not magic variables hard-coded into <code class="literal">flow-nfilter</code>; they're defined in <span class="emphasis"><em>filter.cfg</em></span>. Here's the definition of <code class="literal">VAR_PORT</code>:</p><a id="I_programlisting4_d1e6331"/><pre class="programlisting">filter-primitive VAR_PORT
    type ip-port
    permit ❶ @{PORT:-0}</pre><p>Most of this primitive looks like any other primitive for a port number, but the <code class="literal">permit</code> statement (❶) is very different. This example takes the variable <code class="literal">PORT</code> as defined on the command line and turns it into a number. The specifics of how this works aren't important, but you can use this sample as a model for your own primitives.</p><p>Now here's another example. I frequently work with BGP, so I need an AS number primitive.</p><a id="I_programlisting4_d1e6343"/><pre class="programlisting">❶ filter-primitive VAR_AS
❷ type as
❸ permit @{AS:-0}</pre><p>I've assigned this primitive the name <code class="literal">VAR_AS</code> at ❶ to correspond with the existing variable names, and I've assigned it the <code class="literal">as</code> type (❷). The <code class="literal">permit</code> statement at ❸ is copied from the <code class="literal">VAR_PORT</code> primitive, substituting the variable name <code class="literal">AS</code> for the port. Now I can create a filter using this variable.</p><a id="I_programlisting4_d1e6362"/><pre class="programlisting">filter-definition AS
❶    match source-as VAR_AS
     or
❷    match destination-as VAR_AS</pre><p>This closely resembles the earlier custom variable-based filters in that you pass traffic going to ❶ and from the specified AS (❷). Now you can use this filter to get the traffic to a particular autonomous system.</p><a id="I_programlisting4_d1e6366"/><pre class="programlisting"><strong class="userinput"><code># flow-cat * | flow-nfilter -F as-traffic -v AS=701 | flow-print -f 4 | less</code></strong></pre><p>When you apply this filter, you'll see only the flows involving AS number 701.</p><p>At this point, you should be able to filter traffic in any way you like. Now let's run analysis on that data.</p></div></div></body></html>