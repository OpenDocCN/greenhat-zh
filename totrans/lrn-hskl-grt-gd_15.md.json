["```\ndata Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)\n```", "```\nfreeTree :: Tree Char freeTree =\n    Node 'P'\n        (Node 'O'\n            (Node 'L'\n                (Node 'N' Empty Empty)\n                (Node 'T' Empty Empty)\n            )\n            (Node 'Y'\n                (Node 'S' Empty Empty)\n                (Node 'A' Empty Empty)\n            )\n        )\n        (Node 'L'\n            (Node 'W'\n                (Node 'C' Empty Empty)\n                (Node 'R' Empty Empty)\n            )\n            (Node 'A'\n                (Node 'A' Empty Empty)\n                (Node 'C' Empty Empty)\n            )\n        )\n```", "```\nchangeToP :: Tree Char -> Tree Char\nchangeToP (Node x l (Node y (Node _ m n) r)) = Node x l (Node y (Node 'P' m n) r)\n```", "```\ndata Direction = L | R deriving (Show)\ntype Directions = [Direction]\n\nchangeToP :: Directions -> Tree Char -> Tree Char\nchangeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r\nchangeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)\nchangeToP [] (Node _ l r) = Node 'P' l r\n```", "```\nelemAt :: Directions -> Tree a -> a\nelemAt (L:ds) (Node _ l _) = elemAt ds l\nelemAt (R:ds) (Node _ _ r) = elemAt ds r\nelemAt [] (Node x _ _) = x\n```", "```\nghci> let newTree = changeToP [R,L] freeTree\nghci> elemAt [R,L] newTree\n'P'\n```", "```\ntype Breadcrumbs = [Direction]\n```", "```\ngoLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)\ngoLeft (Node _ l _, bs) = (l, L:bs)\n```", "```\ngoRight :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)\ngoRight (Node _ _ r, bs) = (r, R:bs)\n```", "```\nghci> goLeft (goRight (freeTree, []))\n(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])\n```", "```\nx -: f = f x\n```", "```\nghci> (freeTree, []) -: goRight -: goLeft\n(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])\n```", "```\ndata Crumb a = LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)\n```", "```\ntype Breadcrumbs a = [Crumb a]\n```", "```\ngoLeft :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)\ngoLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)\n```", "```\ngoRight :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)\ngoRight (Node x l r, bs) = (r, RightCrumb x l:bs)\n```", "```\ngoUp :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)\ngoUp (t, LeftCrumb x r:bs) = (Node x t r, bs)\ngoUp (t, RightCrumb x l:bs) = (Node x l t, bs)\n```", "```\ntype Zipper a = (Tree a, Breadcrumbs a)\n```", "```\nmodify :: (a -> a) -> Zipper a -> Zipper a\nmodify f (Node x l r, bs) = (Node (f x) l r, bs)\nmodify f (Empty, bs) = (Empty, bs)\n```", "```\nghci> let newFocus = modify (\\_ -> 'P') (goRight (goLeft (freeTree, [])))\n```", "```\nghci> let newFocus = (freeTree, []) -: goLeft -: goRight -: modify (\\_ -> 'P')\n```", "```\nghci> let newFocus2 = modify (\\_ -> 'X') (goUp newFocus)\n```", "```\nghci> let newFocus2 = newFocus -: goUp -: modify (\\_ -> 'X')\n```", "```\nattach :: Tree a -> Zipper a -> Zipper a\nattach t (_, bs) = (t, bs)\n```", "```\nghci> let farLeft = (freeTree, []) -: goLeft -: goLeft -: goLeft -: goLeft\nghci> let newFocus = farLeft -: attach (Node 'Z' Empty Empty)\n```", "```\ntopMost :: Zipper a -> Zipper a\ntopMost (t, []) = (t, [])\ntopMost z = topMost (goUp z)\n```", "```\ndata List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)\n```", "```\ntype ListZipper a = ([a], [a])\n```", "```\ngoForward :: ListZipper a -> ListZipper a\ngoForward (x:xs, bs) = (xs, x:bs)\n\ngoBack :: ListZipper a -> ListZipper a\ngoBack (xs, b:bs) = (b:xs, bs)\n```", "```\nghci> let xs = [1,2,3,4]\nghci> goForward (xs, [])\n([2,3,4],[1])\nghci> goForward ([2,3,4], [1])\n([3,4],[2,1])\nghci> goForward ([3,4], [2,1])\n([4],[3,2,1])\nghci> goBack ([4], [3,2,1])\n([3,4],[2,1])\n```", "```\ntype Name = String\ntype Data = String\ndata FSItem = File Name Data | Folder Name [FSItem] deriving (Show)\n```", "```\nmyDisk :: FSItem\nmyDisk =\n    Folder \"root\"\n        [ File \"goat_yelling_like_man.wmv\" \"baaaaaa\"\n        , File \"pope_time.avi\" \"god bless\"\n        , Folder \"pics\"\n            [ File \"ape_throwing_up.jpg\" \"bleargh\"\n            , File \"watermelon_smash.gif\" \"smash!!\"\n            , File \"skull_man(scary).bmp\" \"Yikes!\"\n            ]\n        , File \"dijon_poupon.doc\" \"best mustard\"\n        , Folder \"programs\"\n            [ File \"fartwizard.exe\" \"10gotofart\"\n            , File \"owl_bandit.dmg\" \"mov eax, h00t\"\n            , File \"not_a_virus.exe\" \"really not a virus\"\n            , Folder \"source code\"\n                [ File \"best_hs_prog.hs\" \"main = print (fix error)\"\n                , File \"random.hs\" \"main = print 4\"\n                ]\n            ]\n        ]\n```", "```\ndata FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)\n```", "```\ntype FSZipper = (FSItem, [FSCrumb])\n```", "```\nfsUp :: FSZipper -> FSZipper\nfsUp (item, FSCrumb name ls rs:bs) = (Folder name (ls ++ [item] ++ rs), bs)\n```", "```\nimport Data.List (break)\n\nfsTo :: Name -> FSZipper -> FSZipper\nfsTo name (Folder folderName items, bs) =\n    let (ls, item:rs) = break (nameIs name) items\n    in  (item, FSCrumb folderName ls rs:bs)\n\nnameIs :: Name -> FSItem -> Bool\nnameIs name (Folder folderName _) = name == folderName\nnameIs name (File fileName _) = name == fileName\n```", "```\nghci> let newFocus = (myDisk, []) -: fsTo \"pics\" -: fsTo \"skull_man(scary).bmp\"\n```", "```\nghci> fst newFocus\nFile \"skull_man(scary).bmp\" \"Yikes!\"\n```", "```\nghci> let newFocus2 = newFocus -: fsUp -: fsTo \"watermelon_smash.gif\"\nghci> fst newFocus2\nFile \"watermelon_smash.gif\" \"smash!!\"\n```", "```\nfsRename :: Name -> FSZipper -> FSZipper\nfsRename newName (Folder name items, bs) = (Folder newName items, bs)\nfsRename newName (File name dat, bs) = (File newName dat, bs)\n```", "```\nghci> let newFocus = (myDisk, []) -: fsTo \"pics\" -: fsRename \"cspi\" -: fsUp\n```", "```\nfsNewFile :: FSItem -> FSZipper -> FSZipper\nfsNewFile item (Folder folderName items, bs) =\n    (Folder folderName (item:items), bs)\n```", "```\nghci> let newFocus =\n    (myDisk, []) -: fsTo \"pics\" -: fsNewFile (File \"heh.jpg\" \"lol\") -: fsUp\n```", "```\ngoLeft :: Zipper a -> Zipper a\ngoLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)\n```", "```\ngoLeft :: Zipper a -> Maybe (Zipper a)\ngoLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)\ngoLeft (Empty, _) = Nothing\n\ngoRight :: Zipper a -> Maybe (Zipper a)\ngoRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)\ngoRight (Empty, _) = Nothing\n```", "```\nghci> goLeft (Empty, [])\nNothing\nghci> goLeft (Node 'A' Empty Empty, [])\nJust (Empty,[LeftCrumb 'A' Empty])\n```", "```\ngoUp :: Zipper a -> Zipper a\ngoUp (t, LeftCrumb x r:bs) = (Node x t r, bs)\ngoUp (t, RightCrumb x l:bs) = (Node x l t, bs)\n```", "```\ngoUp :: Zipper a -> Maybe (Zipper a)\ngoUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)\ngoUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)\ngoUp (_, []) = Nothing\n```", "```\ngchi> let newFocus = (freeTree, []) -: goLeft -: goRight\n```", "```\nghci> let coolTree = Node 1 Empty (Node 3 Empty Empty)\nghci> return (coolTree, []) >>= goRight\nJust (Node 3 Empty Empty,[RightCrumb 1 Empty])\nghci> return (coolTree, []) >>= goRight >>= goRight\nJust (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])\nghci> return (coolTree, []) >>= goRight >>= goRight >>= goRight\nNothing\n```"]