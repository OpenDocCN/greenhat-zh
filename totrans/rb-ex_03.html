<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Programmer Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="programmer_utilities"/>Chapter 3. Programmer Utilities</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e3521"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>This chapter is primarily geared toward tools that reveal more about Ruby, making the programmer’s job both easier and more interesting. We’ll revisit a few topics we broached in a cursory fashion earlier in the book, this time giving them more attention.</p><div class="sect1" title="#5 What Is Truth? (boolean_golf.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp5_what_is_truth_boolean_golfrb"/>#5 What Is Truth? (boolean_golf.rb)</h1></div></div></div><p>Back in <a class="xref" href="ch01.html" title="Chapter 1. Interactive Ruby and the Ruby Environment">Chapter 1</a>, we talked about how various languages convert data from one type to another. You’ll remember that this process is called <span class="emphasis"><em>casting</em></span>, and Ruby generally requires programmers to do this explicitly, while some other languages provide shortcuts that implicitly cast data.<a class="indexterm" id="idx-CHP-3-0232"/><a class="indexterm" id="idx-CHP-3-0233"/></p><p>The one major exception to this policy in Ruby is the <span class="emphasis"><em>Boolean</em></span> type, which is either true or false. However, we noted earlier that you can also use a <code class="literal">to_b</code> method, making data conversion in Ruby completely consistent, in that it is always explicit. We’ll be doing a variation on the notion of the <code class="literal">to_b</code> method in the program below, which we call <code class="literal">boolean_golf.rb</code>. The name is inspired by a practice in the Perl community in which programmers try to accomplish a given task with as few keystrokes as possible—they score it like golf. This script accomplishes its task as succinctly as possible, without being illegibly terse.<a class="indexterm" id="idx-CHP-3-0234"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id004"/>The Code</h2></div></div></div><a id="I_programlisting3_d1e3564"/><pre class="programlisting">  #!/usr/bin/env ruby
  # boolean_<a class="indexterm" id="idx-CHP-3-0235"/>golf.rb

  =begin rdoc
  This is intended merely to add handy true? and false? methods to every
  <a class="indexterm" id="idx-CHP-3-0236"/>object. The most succinct way seemed to be declaring these particular
  methods in this order. Note that to_b (to Boolean) is an <a class="indexterm" id="idx-CHP-3-0237"/>alias to the
  true?() method.
  =end

  class Object    <em class="lineannotation"><span class="lineannotation"><a class="indexterm" id="idx-CHP-3-0238"/>Superclasses</span></em>

❶   def false?()
      not self
    end

❷   def true?()
      not false?
    end

❸   alias :to_b :true?    <em class="lineannotation"><span class="lineannotation">Metaprogramming; Symbols</span></em>

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id004"/>How It Works</h2></div></div></div><p>This program takes advantage of Ruby’s support for open classes and adds new behavior to the <a class="indexterm" id="idx-CHP-3-0239"/>Object class. Object is what old hands at Object Orientation call a superclass. <span class="emphasis"><em>Superclasses</em></span> are ancestors of other classes. In Ruby, Object happens to be the ultimate superclass, because it’s the ancestor of every other class in Ruby. This status means that methods you add to Object will be available to every single variable of any kind, at any time afterwards. This is extremely powerful, as you might expect.</p><p>The methods we’re adding are the explicit casting to Boolean methods already discussed. When we introduced the concept, we called our hypothetical method <code class="literal">to_b</code>. The program above has that method, but gets to it in a roundabout way. The first method defined in the program (at ❶) is <code class="literal">false?</code>. Remember that a method that returns a Boolean is a <span class="emphasis"><em>predicate</em></span>, and Ruby follows the Lisp tradition of naming <a class="indexterm" id="idx-CHP-3-0240"/>predicates so that they end in <a class="indexterm" id="idx-CHP-3-0241"/>question marks. The <code class="literal">false?</code> method uses Ruby’s implicit Boolean casting inside itself—it just forces its calling object into an implicit Boolean test with the <code class="literal">not</code> operator, which also reverses the Boolean value. Therefore, <code class="literal">false?</code> is the opposite of <code class="literal">to_b</code>.</p><p>Let’s show that in irb:</p><a id="I_programlisting3_d1e3639"/><pre class="programlisting">$ irb -r boolean_<a class="indexterm" id="idx-CHP-3-0242"/>golf.rb
irb(main):001:0&gt; true.<a class="indexterm" id="idx-CHP-3-0243"/>to_b
=&gt; true
irb(main):002:0&gt; false.to_b
=&gt; false
irb(main):003:0&gt; nil.to_b
=&gt; false
irb(main):004:0&gt; true.<a class="indexterm" id="idx-CHP-3-0244"/>false?
=&gt; false
irb(main):005:0&gt; false.false?
=&gt; true
irb(main):006:0&gt; nil.false?
=&gt; true</pre><p>You can see that <code class="literal">to_b</code> reports whether its calling object is considered <code class="literal">true</code> by Ruby. The <code class="literal">false?</code> method does the opposite—it returns <code class="literal">false</code> when Ruby considers the calling object <code class="literal">true</code>, and <code class="literal">true</code> when Ruby considers the calling object <code class="literal">false</code>. You can also try calling these methods on other objects, as well as calling the <code class="literal">true?</code> method (❷) on these and any other values. You’ll find that <code class="literal">true?</code> returns the same values as the <code class="literal">to_b</code> method. This program defines <code class="literal">true?</code> in a similar manner to <code class="literal">false?</code>, except instead of reversing <code class="literal">self</code>, it reverses the output of <code class="literal">false?</code>.<a class="indexterm" id="idx-CHP-3-0245"/></p><p>The methods <code class="literal">true?</code> and <code class="literal">false?</code> look familiar because they’ve been defined in the usual way. At ❸, we define <code class="literal">to_b</code> in a different way. Ruby gives us a the option of doing what’s called <span class="emphasis"><em>metaprogramming</em></span>, which allows us to manipulate our objects while we’re still in the process of defining them. In this case, we’re defining <code class="literal">to_b</code> as an <a class="indexterm" id="idx-CHP-3-0246"/>alias to the method <code class="literal">true?</code> that we just created. The code is quite readable, isn’t it? You might be curious about why we precede the names of the methods with a colon. In this use of <code class="literal">alias, :true?</code> and <code class="literal">:to_b</code> are instances of the <a class="indexterm" id="idx-CHP-3-0247"/>Symbol class, which are preceded with a colon. We’ll talk about Symbol in later chapters. At the moment, just remember that we define aliases with the keyword <code class="literal">alias</code>, the Symbol version of the new name (with an initial colon), and the Symbol version of the old name (with an initial colon), in that order. We’ll show that in our existing irb session.<a class="indexterm" id="idx-CHP-3-0248"/><a class="indexterm" id="idx-CHP-3-0249"/></p><div class="note" title="Note"><h3 class="title"><a id="note-24"/>Note</h3><p>Metaprogramming <span class="emphasis"><em>is a general term for writing programs that create or manipulate other programs. In our case, we write a program that manipulates itself, which is perhaps a little conceptually weird. It’s very powerful, however, and is used extensively in Rails. Technically, a compiler or interpreter is an example of metaprogramming, because it allows you to write a short program in a high-level language (like Ruby), which creates a program in a lower-level language (usually C) under the hood, which is then executed. Another example of a different sort of metaprogramming in this book is a script called</em></span> <em class="replaceable"><code>methinks_meta.rb</code></em>, <span class="emphasis"><em>which we’ll see in <a class="xref" href="ch09s02.html" title="#35 Mutating Strings into Weasels (methinks.rb)">#35 Mutating Strings into Weasels (methinks.rb)</a> on page 168</em></span>.</p></div></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id002"/>Hacking the Script</h2></div></div></div><p>In this irb session, we just make a not-terribly-useful alias for <code class="literal">to_i</code> with the cumbersome name <code class="literal">make_me_into_an_integer</code>. However, it does nicely demonstrate how to define aliases. We have accomplished several tasks. We added new methods to every single object in Ruby. These methods allow us to be completely pedantic about Boolean casting—in other words, we now have methods for explicit casting into Boolean values. While doing so, we refreshed our knowledge of method naming conventions and also learned a bit about both aliases and metaprogramming.<a class="indexterm" id="idx-CHP-3-0250"/></p><a id="I_programlisting3_d1e3777"/><pre class="programlisting">irb(main):007:0&gt; class String
irb(main):008:1&gt; alias :make_me_into_an_integer :to_i
irb(main):009:1&gt; end
=&gt; nil
irb(main):010:0&gt; '5'.make_me_into_an_integer
=&gt; 5</pre></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id003"/>Running the Script</h2></div></div></div><p>The easiest way to run this is with irb.</p><a id="I_programlisting3_d1e3784"/><pre class="programlisting">$ irb -r boolean_<a class="indexterm" id="idx-CHP-3-0251"/>golf.rb
irb(main):001:0&gt; true.true?
=&gt; true
irb(main):002:0&gt; true.false?
=&gt; false
irb(main):003:0&gt; nil.false?
=&gt; true</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id004"/>The Results</h2></div></div></div><p>This library file only returns either <code class="literal">true</code> or <code class="literal">false</code>, as demonstrated above.</p></div></div></div>
<div class="sect1" title="#6 Making a List (array_join.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp6_making_a_list_array_joinrb"/>#6 Making a List (array_join.rb)</h1></div></div></div><p>In the previous script, we added new methods to allow explicit Boolean casting to every Object in all of Ruby. In this example, we create a new method that is a slight variation on a method that already exists. In this case, we’re altering the way that Arrays can represent themselves <a class="indexterm" id="idx-CHP-3-0252"/>as Strings.<a class="indexterm" id="idx-CHP-3-0253"/></p><p>When we talk about <a class="indexterm" id="idx-CHP-3-0254"/>lists in natural speaking, we often separate the last item from the item before it with the word <span class="emphasis"><em>and</em></span>. This is not how Ruby handles Arrays by default. Let’s verify that in irb:<a class="indexterm" id="I_indexterm3_d1e3826"/></p><a id="I_programlisting3_d1e3829"/><pre class="programlisting">irb(main):001:0&gt; a = [0, 1, 2]
=&gt; [0, 1, 2]
irb(main):002:0&gt; a.join(' ')    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> join</code></strong> Method</span></em>
=&gt; "0 1 2"
irb(main):003:0&gt; a.join(', ')
=&gt; "0, 1, 2"
irb(main):004:0&gt; a.<a class="indexterm" id="idx-CHP-3-0255"/>join('')
=&gt; "012"</pre><p>We’re creating a variant of the method <code class="literal">join</code>, which is available to all Arrays and whose behavior we see above in the irb session. It takes the items of the Array, concatenating them together into a String, with the argument to the <code class="literal">join</code> method between each item, but not before the first item or after the last item. That’s the behavior of <code class="literal">join</code>. How can we make our own <code class="literal">join</code> that adds the String <code class="literal">and</code> before the last item? Here’s how.<a class="indexterm" id="idx-CHP-3-0256"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id005"/>The Code</h2></div></div></div><a id="I_programlisting3_d1e3865"/><pre class="programlisting">  #!/usr/bin/env ruby
  # array_<a class="indexterm" id="idx-CHP-3-0257"/>join.rb

  class Array

❶   def my_join(separator1=', ', separator2=' and ')
      modified_join(separator1, separator2)
    end

❷   <a class="indexterm" id="idx-CHP-3-0258"/>protected    <em class="lineannotation"><span class="lineannotation">Protected Methods</span></em>

❸   def modified_join!(separator1, separator2)
      last_one = self.pop()    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> pop</code></strong> Method</span></em>
      join(separator1) + separator2 + last_one.to_s
    end

❹   def modified_join(separator1, separator2)
      self.<a class="indexterm" id="idx-CHP-3-0259"/>dup.modified_join!(separator1, separator2)    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> dup</code></strong> Method</span></em>
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id005"/>How It Works</h2></div></div></div><p>In our open class modification of Array, we define a new method at ❶ called <code class="literal">my_join</code> that takes two separator arguments. It calls another method, <code class="literal">modified_join</code>, with whatever our two separator arguments are.</p><p>The <code class="literal">modified_join</code> method hasn’t been defined yet and doesn’t need to be called except within the <code class="literal">my_join</code> method. You might think that it can be a <code class="literal">private</code> method, and so would expect to see the word <span class="emphasis"><em>private</em></span> before the method definition. Instead, at ❷ you see the word <span class="emphasis"><em>protected</em></span>. Why couldn’t it just have been <span class="emphasis"><em>private</em></span>? We’ll find out very shortly.</p><p>The <code class="literal">modified_join</code> method is defined at ❹ simply as calling the new destructive method <code class="literal">modified_join!</code> on a duplicate of the calling object. We get a duplicate of the calling object simply by using the <code class="literal">dup</code> method. We define the destructive method <code class="literal">modified_join!</code> at ❸. It takes two separator arguments, just like all of our new methods in this program. It defines a new local variable called <code class="literal">last_one</code>, which is the value of the object calling the method <code class="literal">pop</code> on itself. Pop is a standard term in many languages for the operation of removing the last item from an Array. Here’s an example of popping in action, continuing our existing irb session:<a class="indexterm" id="idx-CHP-3-0260"/></p><a id="I_programlisting3_d1e3953"/><pre class="programlisting">irb(main):005:0&gt; a
=&gt; [0, 1, 2]
irb(main):006:0&gt; a.pop
=&gt; 2
irb(main):007:0&gt; a
=&gt; [0, 1]
irb(main):008:0&gt; a.pop
=&gt; 1
irb(main):009:0&gt; a
=&gt; [0]
irb(main):010:0&gt; a.pop
=&gt; 0
irb(main):011:0&gt; a
=&gt; []</pre><p>You can see that the Array called <code class="literal">a</code> is modified whenever it calls the method <code class="literal">pop</code> on itself. Why, you might ask, isn’t this method called <code class="literal">pop!</code>, since it’s destructive? That’s a good question. The answer is convention—<span class="emphasis"><em>pop</em></span> is an established term for this operation from languages that precede Ruby. If this convention bothers you, just remember that Ruby has ancestors, just like a real human spoken language does. Think about the spelling rules in English. They make little sense after the fact, but make perfect sense when you realize that English is the product of Norman soldiers trying to pick up Saxon barmaids a thousand years ago.</p><p>Ruby depends on its ancestors similarly to how a spoken language does, and given the choice between breaking either the convention of naming destructive methods with exclamation marks or of agreeing with precedent from other languages, Matz has decided to make Ruby play nicely with others.</p><p>Now we have our last item in a separate variable called <code class="literal">last_one</code>, and since <code class="literal">pop</code> is destructive, that item has been removed from the calling Array after <code class="literal">pop</code> has occurred. We’re satisfied with the way the original version of <code class="literal">join</code> works on all items before the last one, so we can just call the plain old <code class="literal">join</code> on those items. We add our second separator, and then add our last item that we popped off, <a class="indexterm" id="idx-CHP-3-0261"/>making sure that it is a String (and therefore willing to be concatenated) by calling the <code class="literal">to_s</code> method on it.</p><p>So what was all that business about using <code class="literal">protected</code> instead of <code class="literal">private</code>? The reason we used <code class="literal">protected</code> is that inside the (non-destructive) <code class="literal">modified_join</code> method, our Array doesn’t call the (destructive) <code class="literal">modified_join!</code> method on itself. Instead, it calls <code class="literal">modified_join!</code> on a duplicate of itself. It’s no longer the same object, and the duplicate won’t allow another instance to call one of its <code class="literal">private</code> methods. So what do we do? Should there be a way for an Array to call a method on another Array that isn’t available to an Integer, a String, or a Symbol? There is, and that’s exactly what the <code class="literal">protected</code> access control keyword is for. Below is some irb action showing how the program works.<a class="indexterm" id="idx-CHP-3-0262"/><a class="indexterm" id="idx-CHP-3-0263"/></p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id004"/>Running the Script</h2></div></div></div><a id="I_programlisting3_d1e4036"/><pre class="programlisting">$ irb -r array_<a class="indexterm" id="idx-CHP-3-0264"/>join.rb
irb(main):001:0&gt; a = [0, 1, 2]
=&gt; [0, 1, 2]
irb(main):002:0&gt; a.join(', ')
=&gt; "0, 1, 2"
irb(main):003:0&gt; a.my_join(', ')
=&gt; "0, 1 and 2"
irb(main):004:0&gt;</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id003"/>Hacking the Script</h2></div></div></div><p>Once you’ve tried that and are comfortable with it, change <code class="literal">protected</code> to <code class="literal">private</code> and try to run it again. It should fail on you, as shown here.<a class="indexterm" id="idx-CHP-3-0265"/></p><a id="I_programlisting3_d1e4058"/><pre class="programlisting">$ irb -r array_join.rb
irb(main):001:0&gt; a = [0, 1, 2]
=&gt; [0, 1, 2]
irb(main):002:0&gt; a.join(', ')
=&gt; "0, 1, 2"
irb(main):003:0&gt; a.my_join(', ')
<a class="indexterm" id="idx-CHP-3-0266"/>NoMethodError: private method 'modified_join!' called for [0, 1, 2]:Array
        from ./array_join.rb:14:in 'modified_join'
        from ./array_join.rb:7:in 'my_join'
        from (irb):3
        from :0
irb(main):004:0&gt;</pre><p>That <code class="literal">private</code> method error is the reason we want our non-<code class="literal">public</code> methods in this program to be <code class="literal">protected</code>, rather than <code class="literal">private</code>. That should give you basic understanding of Ruby’s access control: <code class="literal">public, private</code>, and <code class="literal">protected</code>.</p></div></div>
<div class="sect1" title="#7 Command-Line Interface (uses_cli.rb and simple_cli.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp7_command-line_interface_uses_clirb"/>#7 Command-Line Interface (uses_cli.rb and simple_cli.rb)</h1></div></div></div><p>The program <code class="literal">uses_cli.rb</code> understands command-line options, which are configuration options that you can use to make the script behave in different ways, depending on the specific values chosen. It uses specific options that have become somewhat standard, such as <code class="literal">-h</code> or <code class="literal">--help</code>. Options in the form with a single hyphen and a single letter are <span class="emphasis"><em>short options</em></span>, while those with a double hyphen and a full word are (unsurprisingly) called <span class="emphasis"><em>long options</em></span>. Let’s look at the code for <code class="literal">uses_cli.rb</code>.<a class="indexterm" id="idx-CHP-3-0267"/><a class="indexterm" id="idx-CHP-3-0268"/><a class="indexterm" id="idx-CHP-3-0269"/><a class="indexterm" id="idx-CHP-3-0270"/><a class="indexterm" id="idx-CHP-3-0271"/><a class="indexterm" id="I_indexterm3_d1e4124"/><a class="indexterm" id="I_indexterm3_d1e4127"/></p><div class="note" title="Note"><h3 class="title"><a id="note-25"/>Note</h3><p><span class="emphasis"><em>I think there is enough pedagogical value to rolling your own command-line parser to make it worthwhile, especially in a book like this. However, I should note that there are two fine built-in CLI parsers in Ruby: GetOptLong (Motoyuki Kasahara</em></span>, <a class="ulink" href="http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong">http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong</a>) <span class="emphasis"><em>and OptionParser (Nobu Nakada</em></span>, <a class="ulink" href="http://optionparser.rubyforge.org">http://optionparser.rubyforge.org</a>). <span class="emphasis"><em>I only include the URLs for information purposes; they are built in to the Ruby Standard Library, so you don’t need to download them</em></span>.<a class="indexterm" id="idx-CHP-3-0272"/><a class="indexterm" id="idx-CHP-3-0273"/><a class="indexterm" id="idx-CHP-3-0274"/><a class="indexterm" id="idx-CHP-3-0275"/><a class="indexterm" id="idx-CHP-3-0276"/></p></div><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id006"/>The Code</h2></div></div></div><a id="I_programlisting3_d1e4166"/><pre class="programlisting">  #!/usr/bin/env ruby
  # use_cli.rb

  =begin rdoc
  Please refer to the <a class="indexterm" id="idx-CHP-3-0277"/>SimpleCLI Class for documentation.
  =end

❶ <a class="indexterm" id="idx-CHP-3-0278"/>require 'simple_cli'    <em class="lineannotation"><span class="lineannotation">Require</span></em>

❷ cli = SimpleCLI.new()
  cli.<a class="indexterm" id="idx-CHP-3-0279"/>parse_opts(ARGV)</pre><p>There isn’t a whole lot here, and the script gives us almost no information, except at ❷, where it suggests that we need to look inside the <code class="literal">SimpleCLI</code> class for documentation. Why the redirection? For an example this straightforward, it’s a fair question. The Holy Grail of computer programming is the notion of <a class="indexterm" id="idx-CHP-3-0280"/>reusable code. There are many ways to accomplish that end, but one of the most enduringly successful ways is to have <a class="indexterm" id="idx-CHP-3-0281"/>external libraries of functions that are reasonably abstract, which is the role played by the <code class="literal">simple_cli.rb</code> file in our example. Some other specific file can then use that library file, as we do at ❶ in <code class="literal">uses_cli.rb</code> with the <span class="emphasis"><em>require</em></span> keyword, which takes a String argument that is the name of an external file without the .rb extension. This makes the code in that external file available to the file doing the requiring—it’s analogous to running irb with the <code class="literal">-r</code> flag. Therefore, at ❷ we can easily instantiate an instance of <code class="literal">SimpleCLI</code> that we call <code class="literal">cli</code>, to which we pass all of the <a class="indexterm" id="idx-CHP-3-0282"/>command-line options used by <code class="literal">uses_cli.rb</code>.<a class="indexterm" id="idx-CHP-3-0283"/><a class="indexterm" id="idx-CHP-3-0284"/></p><p>If we want to understand how <code class="literal">SimpleCLI</code> works, we’ll have to look at its code. Note that some of the methods in <code class="literal">SimpleCLI</code> are <span class="emphasis"><em>stubs</em></span>, meaning that they don’t do anything worthy of real production code, but they demonstrate that the options are being parsed appropriately. If you find this example useful as a scaffold or guide for your own code that you want to take command-line options, you simply replace both the types of options and their specific implementations as your needs dictate. These are only examples. Here, we instantiate <code class="literal">SimpleCLI</code> and then call its <code class="literal">parse_opts</code> method with every command-line option used in <code class="literal">uses_cli.rb</code>. Let’s see what that method does by looking at <code class="literal">simple_cli.rb</code>.<a class="indexterm" id="idx-CHP-3-0285"/></p><div class="note" title="Note"><h3 class="title"><a id="note-26"/>Note</h3><p><span class="emphasis"><em>The <em class="replaceable"><code>help</code></em> and <em class="replaceable"><code>version</code></em> command-line options have become fairly standardized, and their inclusion is generally appreciated</em></span>.</p></div><a id="I_programlisting3_d1e4269"/><pre class="programlisting">  #!/usr/bin/env ruby
  # simple_cli.rb

  =begin rdoc
  Parses command line options.
  =end
  class SimpleCLI

❶   # CONSTANTS

    OPTIONS = {    <em class="lineannotation"><span class="lineannotation">Hashes</span></em>
      :version =&gt; ['-v', '--version'],
      :help    =&gt; ['-h', '--help'],
      :reset   =&gt; ['-r', '--reset'],
    }

❷   USAGE =&lt;&lt;END_OF_USAGE    <em class="lineannotation"><span class="lineannotation">Here Docs</span></em>

  This program understands the following options:
    -v, --version : displays the current version of the program
    -h, --help    : displays a message with usage instructions
    -r, --reset   : resets the program

  With no <a class="indexterm" id="idx-CHP-3-0286"/>command-line options, the program performs its default behavior.

  END_OF_USAGE

    VERSION = "Some Project version 0.01 (Pre-Alpha)\n"

    # METHODS

❸   def parse_opts(args)
      return option_by_args(args[0]) if understand_args?(args)
      # options are not understandable, therefore display_usage
      display(USAGE)
    end

❹   private

❺   def display(content)
      puts content
    end

    def do_default()
      puts 'I am performing my default behavior'
    end

❻   def option_by_args(arg)
      return display(VERSION) if OPTIONS[:version].include?(arg)
      return display(USAGE)   if OPTIONS[:help].include?(arg)
      return reset()          if OPTIONS[:reset].include?(arg)
      do_default()
    end

    def reset()
      puts 'I am resetting myself.'
    end

❼   def understand_args?(args)
      # works in Ruby1.8
      OPTIONS.keys.any? { |key| OPTIONS[key].include?(args[0]) }    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> any?</code></strong> Method</span></em>

❽ =begin works in Ruby1.6
      return true unless args
      return true unless args[0]
      return true if args[0].size.zero?
      OPTIONS.<a class="indexterm" id="idx-CHP-3-0287"/>keys.each do |key|
        return true if OPTIONS[key].include?(args[0])    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> include?</code></strong> Method</span></em>
      end
      return false
  =end
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id006"/>How It Works</h2></div></div></div><p>This file, <code class="literal">simple_cli.rb</code>, is a basic definition of a class called <code class="literal">SimpleCLI</code>, of course, with RDoc before the class definition and some useful constants right away at ❶. We’ve seen constants before, but we declare these constants <a class="indexterm" id="idx-CHP-3-0288"/>inside of a class definition. This is actually the preferred way to use constants in Ruby. You often want to encapsulate methods inside an object, and the same is true for constants. Your code for some physics calculation cares about the speed of light, whereas your payday notification program cares about the number of days in a pay period. In our case, the <a class="indexterm" id="idx-CHP-3-0289"/>command-line parser cares about what <code class="literal">OPTIONS</code> it can understand and the <code class="literal">USAGE</code> message it should report.</p><p>The <code class="literal">OPTIONS</code> constant is a new type of data structure called a <a class="indexterm" id="idx-CHP-3-0290"/>Hash. <span class="emphasis"><em>Hashes</em></span> are <a class="indexterm" id="idx-CHP-3-0291"/>lookup tables, and are very similar to functions, in a way. You pass something into a Hash, and you receive one thing from it. That one thing never changes unless you either change what you pass into the Hash, or you change the internals of the Hash. As you can see, you declare a Hash with braces. The items to the left of the <code class="literal">=&gt;</code> are the <span class="emphasis"><em>keys</em></span> of the Hash, while the items to the right of the <code class="literal">=&gt;</code> are the <span class="emphasis"><em>values</em></span> of the Hash. If you pass in one of the keys, the Hash will return the matching value.<a class="indexterm" id="idx-CHP-3-0292"/></p><div class="note" title="Note"><h3 class="title"><a id="note-27"/>Note</h3><p><span class="emphasis"><em>Note that the one thing you receive could be a composite data type. For example, in our <em class="replaceable"><code>OPTIONS</code></em> Hash, the values you receive are Arrays. The point is that you’ll always receive the same Array for a given input value</em></span>.</p></div><p>Let’s demonstrate in irb. The way to refer to a constant within a class is with the syntax <code class="literal">Class::CONSTANT</code>, so let’s do that. Keep in mind that the Array <code class="literal">[“-v”, “--version”]</code> is the value of <code class="literal">SimpleCLI:: OPTIONS</code> class associated with the key <code class="literal">:version</code>. That means that if you pass in the Symbol <code class="literal">:version</code>, you receive the Array <code class="literal">[“-v”, “--version”]</code>.</p><a id="I_programlisting3_d1e4389"/><pre class="programlisting">$ irb -r simple_cli.rb
irb(main):001:0&gt; SimpleCLI::OPTIONS[:version]
=&gt; ["-v", "--version"]
irb(main):002:0&gt; SimpleCLI::OPTIONS[:help]
=&gt; ["-h", "--help"]
irb(main):003:0&gt; SimpleCLI::OPTIONS[:reset]
=&gt; ["-r", "--reset"]</pre><p>It works. If you compare our results in irb with the declaration of the Hash in the code, you shouldn’t be surprised by what we got. <a class="indexterm" id="idx-CHP-3-0293"/>Hashes are critically important data structures. I am particularly fond of defining them as constants within a class, so you’ll see this practice repeated many times in the course of the book.</p><div class="note" title="Note"><h3 class="title"><a id="note-28"/>Note</h3><p><span class="emphasis"><em>There are several reasons why I often have Constants within a class that are Hashes. They’re within a class because they need to be accessible within that class, but not outside it. The reason they’re often Hashes is that I often find (for whatever reason) that simple lookup tables are useful data structures to have. After you’ve read some of the functional programming information, you may find it interesting to define both lambdas and Procs as class constants as well. I find myself often doing so</em></span>.<a class="indexterm" id="idx-CHP-3-0294"/><a class="indexterm" id="idx-CHP-3-0295"/></p></div><p>The declaration of the <code class="literal">USAGE</code> constant at ❷ looks a bit odd, with the equals sign followed by two left arrows. However, this is a very useful tool for <a class="indexterm" id="idx-CHP-3-0296"/>multi-line text called a <code class="literal">here doc</code>. With a <code class="literal">here doc</code> declaration, the programmer can say that an expression should continue across multiple lines until a specific marker is reached—<code class="literal">END_OF_USAGE</code>, in this case. This is very handy for large amounts of verbatim text that you would otherwise have to build using multiple <code class="literal">print</code> or <code class="literal">puts</code> statements.<a class="indexterm" id="idx-CHP-3-0297"/><a class="indexterm" id="idx-CHP-3-0298"/></p><p>Next is a more straightforward constant called <code class="literal">VERSION</code>, which is a regular String. Its definition uses double-quote characters, because we want a newline character (notated by <code class="literal">\n</code>) at the end. The following two statements would print the same thing; the <code class="literal">\n</code> is just the way to include the newline within the String.</p><a id="I_programlisting3_d1e4450"/><pre class="programlisting">puts 'Some Project version 0.01 (Pre-Alpha)'
print "Some Project version 0.01 (Pre-Alpha)\n"</pre><p>We have our constants, so let’s move on to our <a class="indexterm" id="idx-CHP-3-0299"/>methods. The main one (and in fact, the only public one) is <code class="literal">parse_opts</code>, defined at ❸. It parses options, and its implementation should be fairly readable at this point. It returns the result of calling the <code class="literal">option_by_args</code> method if it understands the <code class="literal">args</code>, and otherwise passes its own <code class="literal">USAGE</code> message into the <code class="literal">display</code> method. I like method names that tell you what they’re supposed to do. If you care about the details, you can look inside to learn more, but the name should give you the basic information you need up front.<a class="indexterm" id="idx-CHP-3-0300"/></p><p>All of our methods, other than <code class="literal">parse_opts</code>, are <code class="literal">private</code> (❹), because they only need to be called by a <code class="literal">SimpleCLI</code> instance on itself. The <code class="literal">display, do_default</code>, and <code class="literal">reset</code> methods starting at ❺ should be pretty straightforward to you. These are the methods that you would change to do something more useful in real production code. The major logic of the class occurs in the remaining methods <code class="literal">option_by_arg</code> (❻) and <code class="literal">understand_args?</code> (❼). We know <code class="literal">understand_args?</code> is a predicate by the question mark at the end of its name, so it will be returning either <code class="literal">true</code> or <code class="literal">false</code>.<a class="indexterm" id="I_indexterm3_d1e4513"/></p><p>The <code class="literal">option_by_args</code> method checks each key of the <code class="literal">OPTIONS</code> constant, and if it finds a match, returns with the appropriate behavior. This means that it will not continue checking keys after it finds a match, so the order of the keys is important. It checks for matches using an Array predicate method called <code class="literal">include?</code>, which simply returns <code class="literal">true</code> if the argument is found in the Array and <code class="literal">false</code> if it is not. This makes it very easy to have <a class="indexterm" id="idx-CHP-3-0301"/>command-line aliases like <code class="literal">-v</code> and <code class="literal">--version</code> which mean the same thing, because either one will cause <code class="literal">include?</code> to return <code class="literal">true</code>. If <code class="literal">option_by_args</code> gets no matches, it performs its default behavior.<a class="indexterm" id="idx-CHP-3-0302"/></p><p>Key to all of this is whether or not the instance of <code class="literal">SimpleCLI</code> understands it arguments. In Ruby1.8, which this book assumes you’re using, it’s easy to determine that question using another predicate method called <code class="literal">any?</code>. It takes a block and returns <code class="literal">true</code> if the contents of that block evaluate to <code class="literal">true</code> for any of the elements of the calling object, which is usually an Array. Let’s demonstrate in irb:<a class="indexterm" id="idx-CHP-3-0303"/></p><a id="I_programlisting3_d1e4574"/><pre class="programlisting">$ irb
irb(main):001:0&gt; a = [0, 1, 2]
=&gt; [0, 1, 2]
irb(main):002:0&gt; a.any? { |i| i &gt; 1 }
=&gt; true
irb(main):003:0&gt; a.any? { |i| i &gt; 2 }
=&gt; false</pre><p>In our case, we’re checking if it’s true that the Array value returned from the <code class="literal">OPTIONS</code> Hash includes the first argument to the <code class="literal">understand_args?</code> method for any of the <a class="indexterm" id="idx-CHP-3-0304"/>keys of the <code class="literal">OPTIONS</code> Hash. As you can see, Hashes have a method called <code class="literal">keys</code> that returns all of their keys as a single Array. If our <code class="literal">any?</code> test returns <code class="literal">true</code>, that means that <code class="literal">SimpleCLI</code> knows how to react to the argument it received. The nice thing about this setup is that to make <code class="literal">SimpleCLI</code> understand more options, we just add more data to the <code class="literal">OPTIONS</code> Hash. The <code class="literal">understand_args?</code> method never has to change, only its input does. Programmers call this <span class="emphasis"><em>data-driven programming</em></span>, and generally think highly of the practice.<a class="indexterm" id="idx-CHP-3-0305"/></p><p>That’s our command-line parsing example. Let’s run this using the options shown. Just like in irb, I’ll show the output.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id005"/>Running the Script</h2></div></div></div><a id="I_programlisting3_d1e4625"/><pre class="programlisting">$ ./<a class="indexterm" id="idx-CHP-3-0306"/>uses_cli.rb -r
I am resetting myself.
$ ./uses_cli.rb -v
Some Project version 0.01 (Pre-Alpha)
$ ./uses_cli.rb -h

This program understands the following options:
  -v, --version : displays the current version of the program
  -h, --help    : displays a message with usage instructions
  -r, --reset   : resets the program

With no command-line options, the program performs its default behavior.

$ ./uses_cli.rb
I am performing my default behavior
$ ./<a class="indexterm" id="idx-CHP-3-0307"/>uses_cli.rb --reset
I am resetting myself.
$ ./uses_cli.rb --version
Some Project version 0.01 (Pre-Alpha)
$ ./uses_cli.rb --help

This program understands the following options:
  -v, --version : displays the current version of the program
  -h, --help    : displays a message with usage instructions
  -r, --reset   : resets the program

With no <a class="indexterm" id="idx-CHP-3-0308"/>command-line options, the program performs its default behavior.</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id004"/>Hacking the Script</h2></div></div></div><p>I mentioned Ruby1.8, which provides the <code class="literal">any?</code> method. One of the machines I used while writing this book only has Ruby1.6. I’ve included some alternative code inside a modified RDoc section at ❽ to show just how convenient it is to have <code class="literal">any?</code> available to us. As you can see, RDoc can be useful for things other than final comments.<a class="indexterm" id="idx-CHP-3-0309"/><a class="indexterm" id="idx-CHP-3-0310"/><a class="indexterm" id="I_indexterm3_d1e4656"/><a class="indexterm" id="I_indexterm3_d1e4659"/><a class="indexterm" id="I_indexterm3_d1e4662"/></p></div></div>
<div class="sect1" title="#8 Palindromes (palindrome.rb and palindrome2.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp8_palindromes_palindromerb_and_pali"/>#8 Palindromes (palindrome.rb and palindrome2.rb)</h1></div></div></div><p>I’m rounding out this chapter with a few shorter examples pertaining to palindromes, which are bits of text that are the same when reversed as they are when read normally. Usually, we allow cheating to ignore spaces, capitalization differences, and punctuation, so <span class="emphasis"><em>A man, a plan, a canal, Panama</em></span> qualifies as a palindrome under those conditions. While working on this book, I was reading another programming book that contained a discussion about palindromes. “Great!” I thought. “I’ll add a <code class="literal">palindrome?</code> predicate method to all Strings. It’ll be a nice simple bit to have in the chapter in which I talk about text.” So I started thinking about breaking Strings into individual characters, writing a method that would compare characters an equal distance from each end of the String, and all the other things you’d need to do in some other languages. Then I realized how easy it is to implement this method in Ruby.<a class="indexterm" id="idx-CHP-3-0311"/><a class="indexterm" id="idx-CHP-3-0312"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id007"/>The Code</h2></div></div></div><a id="I_programlisting3_d1e4685"/><pre class="programlisting">class String

  def palindrome?()
    (self == self.reverse)    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> reverse</code></strong> Method</span></em>
  end

end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id007"/>How It Works</h2></div></div></div><p>That’s it. Such an easy solution was staring me in the face the whole time. Strings can <code class="literal">reverse</code> themselves, and the definition of a palindromic String is that it is the same as itself reversed. This is when I realized that this example belongs in this chapter, because of the incredible relative ease of this task and what it implies about programmers being able to roll their own libraries.</p><p>Easy as it was to do, this version of a palindrome isn’t entirely satisfactory. For one thing, it doesn’t work for our example sentence. We need a version of the <code class="literal">palindrome?</code> predicate that is a bit more complex. Here it is. I’m placing the <a class="xref" href="ch03s03.html#hacking_the_script-id004" title="Hacking the Script">Hacking the Script</a><a class="indexterm" id="idx-CHP-3-0313"/> subsection earlier in this section because I use it to demonstrate some ideas in the <a class="xref" href="ch03s04.html#running_the_script-id006" title="Running the Script">Running the Script</a> and <a class="xref" href="ch03s04.html#the_results-id005" title="The Results">The Results</a> subsections, as I hope will become clear.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id005"/>Hacking the Script</h2></div></div></div><p>The file <code class="literal">palindrome2.rb</code> is a bit more complex, as you’ll see. But given what it does, it’s still pretty simple in Ruby, compared to some other languages.<a class="indexterm" id="idx-CHP-3-0314"/></p><a id="I_programlisting3_d1e4726"/><pre class="programlisting">  #!/usr/bin/env ruby
  # palindrome2.rb

  =begin rdoc
  Gives every &lt;b&gt;String&lt;/b&gt; the ability to identify whether it is a
  a palindrome. This version ignores all non-alphabetic characters,
  making it suitable for longer text items.
  =end

  class String

❶   DUAL_CASE_ALPHABET = ('a'..'z').to_a + ('A'..'Z').to_a

  =begin rdoc
  Contrast this with some other languages, involving iterating through each
  string index and comparing with the same index from the opposite end.
  Takes 1 optional Boolean, which indicates whether case matters.
  Assumed to be true.
  =end
❷   def palindrome?(case_matters=true)
      letters_only(case_matters) == letters_only(case_matters).reverse
    end

    private

  =begin rdoc
  Takes 1 optional Boolean, which indicates whether case matters.
  Assumed to be false.

  =end
❸   def <a class="indexterm" id="idx-CHP-3-0315"/>letters_only(case_matters=false)
      just_letters = <a class="indexterm" id="idx-CHP-3-0316"/>split('').find_all do |char|    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> find_all</code></strong> Method</span></em>
        DUAL_CASE_ALPHABET.include?(char)
      end.<a class="indexterm" id="idx-CHP-3-0317"/>join('')
      return just_letters if (case_matters)
      return just_letters.<a class="indexterm" id="idx-CHP-3-0318"/>downcase
    end

  end</pre><p>This file has the <a class="indexterm" id="idx-CHP-3-0319"/>shebang telling us that it should be run in Ruby, even though it is a library file, rather than a file that will be directly executed. Why is that? The main reason is that it would otherwise start with RDoc, which we wouldn’t want bash to try to interpret. With the shebang, this will automatically be run by Ruby if it is accidentally executed at the command line. If you’re extra paranoid, you could add the first line to <code class="literal">palindrome.rb</code>, as well.<a class="indexterm" id="idx-CHP-3-0320"/></p><div class="note" title="Note"><h3 class="title"><a id="note-29"/>Note</h3><p>Shebang <span class="emphasis"><em>is the standard Unix geek pronunciation of</em></span> <em class="replaceable"><code>#!</code></em><a class="indexterm" id="idx-CHP-3-0321"/>, <span class="emphasis"><em>which one often finds at the beginning of scripts</em></span>.</p></div><p>In this program, we want to be able to test palindromes such that we ignore all non-letters and also have the ability to ignore case if we choose to. This is easy enough to do. Our new String has a private method called <code class="literal">letters_only</code> that does what you expect it to: It compiles a new String consisting only of those characters that pass <code class="literal">DUAL_CASE_ALPHABET.include?</code>, where <code class="literal">DUAL_CASE_ALPHABET</code> (❶) is an Array of all letters, both upper- and lowercase. If it receives a <code class="literal">case_matters</code> argument that is <code class="literal">true</code>, it returns those letters as they are, otherwise it returns an all-lowercase version of those letters, which we accomplish with the <code class="literal">downcase</code> method. The <code class="literal">split</code> method breaks a String into chunks (each character, in this case), and the <code class="literal">join</code> method sews them back together with a delimiter, which in this case is the empty String.</p><p>The <code class="literal">letters_only</code> method at ❸ is handy enough that in our <code class="literal">palindrome?</code> predicate (❷), all we need to do is compare its output to the reverse of its output, and we have our more flexible palindrome detector. Let’s see it in action.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id006"/>Running the Script</h2></div></div></div><p>I have written a test program called <code class="literal">test_palidrome.rb</code> that I keep in a separate directory called <code class="literal">tests/</code>. Here is the file, followed by a bash session in which I run it.<a class="indexterm" id="idx-CHP-3-0322"/></p><a id="I_programlisting3_d1e4826"/><pre class="programlisting">#!/usr/bin/env ruby
# test_<a class="indexterm" id="idx-CHP-3-0323"/>palindrome.rb
puts "Band\tPal?\tpal?"
bands = %w[abba Abba asia Asia]
bands.each do |band|
  puts "#{band}\t#{band.palindrome?}\t#{band.palindrome?(false)}"
end</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id005"/>The Results</h2></div></div></div><a id="I_programlisting3_d1e4835"/><pre class="programlisting">$ ruby -r <a class="indexterm" id="idx-CHP-3-0324"/>palindrome2.rb tests/test_<a class="indexterm" id="idx-CHP-3-0325"/>palindrome.rb
Band    Pal?    pal?
abba    true    true
Abba    false   true
asia    false   false
Asia    false   false</pre><p>I started thinking about musical groups that both start and end with the letter <span class="emphasis"><em>A</em></span>. I didn’t get very far—but far enough to demonstrate the program, anyway. Note that we <code class="literal">require palindrome2.rb</code> at the command line, rather than with an explicit require keyword inside <code class="literal">test_palindrome.rb</code>. We can also do testing in irb, of course.</p><a id="I_programlisting3_d1e4858"/><pre class="programlisting">$ irb -r palindrome2.rb
irb(main):001:0&gt; 'Ika Yaki'.palindrome?
=&gt; false
irb(main):002:0&gt; 'Ika Yaki'.palindrome?(false)
=&gt; true
irb(main):003:0&gt; 'ika yaki'.palindrome?
=&gt; true</pre><p>We see that Japanese grilled squid (Ika Yaki) is either properly recognized as a palindrome or not, depending on the parameters we tell the <code class="literal">palindrome?</code> predicate to use. These String-related operations should get us properly prepped for the next chapter, which deals with text manipulation in greater detail. Before, that, however, we should review what was new in this chapter.</p><div class="note" title="Note"><h3 class="title"><a id="note-30"/>Note</h3><p><span class="emphasis"><em>If you try</em></span> <em class="replaceable"><code>ruby -r palindrome.rb tests/test_palindrome.rb</code></em>, <span class="emphasis"><em>the test script will fail. Can you figure out why? The reason has to do with arguments</em></span>.</p></div></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap-id001"/>Chapter Recap</h1></div></div></div><p>What was new in this chapter?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Making new predicates for explicit Boolean casting</p></li><li class="listitem"><p>Method aliases</p></li><li class="listitem"><p>Superclasses</p></li><li class="listitem"><p>Metaprogramming</p></li><li class="listitem"><p>The Symbol class</p></li><li class="listitem"><p>Arrays and the <code class="literal">join</code> method</p></li><li class="listitem"><p>The <code class="literal">protected</code> level of access control</p></li><li class="listitem"><p>The <code class="literal">dup</code> and <code class="literal">pop</code> methods</p></li><li class="listitem"><p>Making command-line interface flags</p></li><li class="listitem"><p>Library files for reusable code</p></li><li class="listitem"><p>Class constants</p></li><li class="listitem"><p>The Hash class</p></li><li class="listitem"><p>Hash keys and values</p></li><li class="listitem"><p>The <code class="literal">here doc</code> declaration</p></li><li class="listitem"><p>Newline characters within Strings</p></li><li class="listitem"><p>Using <code class="literal">Array.include?</code> to test for membership</p></li><li class="listitem"><p>The <code class="literal">any?</code> predicate</p></li><li class="listitem"><p>The <code class="literal">Hash.keys</code> method</p></li><li class="listitem"><p>A bit on Ruby1.8 vs. Ruby1.6 and the <code class="literal">any?</code> predicate</p></li><li class="listitem"><p>Palindromes and reversing Strings</p></li><li class="listitem"><p>Extracting the letters from Strings</p></li><li class="listitem"><p>Changing the case of Strings</p></li></ul></div><p>That’s even more than the last chapter, which was hardly holding your hand. Congratulations again. Let’s move on to some more complex treatment of Strings in the next chapter.</p></div></body></html>