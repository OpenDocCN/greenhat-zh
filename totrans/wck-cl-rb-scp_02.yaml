- en: Chapter 2. WEBSITE SCRIPTING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 网页脚本
- en: '![WEBSITE SCRIPTING](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![WEBSITE SCRIPTING](../Images/00001.jpg)'
- en: Ruby and the Web go together. The Internet and the World Wide Web provide so
    much information that finding specific bits of that information can be overwhelming.
    Popular search engines have made crawling the Web more manageable, but these search
    engines lack customization. If you were to write your own script, it would be
    possible to customize every aspect of what information to gather and how to present
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby和网络是相辅相成的。互联网和万维网提供了如此多的信息，以至于找到具体的信息可能会让人感到不知所措。流行的搜索引擎使得网络爬取变得更加容易管理，但这些搜索引擎缺乏定制。如果你要编写自己的脚本，就有可能定制收集信息的各个方面以及如何展示这些信息。
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you''ve heard of Ruby, then chances are you''ve heard about Ruby on Rails.
    This book doesn''t address Rails, as Ruby alone is a powerful tool for exploiting
    the Web. But if you''d like to explore web application development using Ruby,
    you should definitely check out the Rails framework* ([http://www.rubyonrails.org/](http://www.rubyonrails.org/)).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你听说过Ruby，那么你很可能也听说过Ruby on Rails。这本书不涉及Rails，因为Ruby本身就是一个强大的工具，可以用来利用网络。但如果你想探索使用Ruby进行Web应用程序开发，你绝对应该检查Rails框架*
    ([http://www.rubyonrails.org/](http://www.rubyonrails.org/))).'
- en: '* * *'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Web Page Link Validator
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页链接验证器
- en: Web Page Link Validator
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页链接验证器
- en: linkValidator.rb
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: linkValidator.rb
- en: The purpose of this script is to validate all the links on a web page. Checking
    link validity is important for several reasons. First, as a viewer, encountering
    broken links is very frustrating. Second, valid links make a site more professional.
    Finally, if your website contains a link to someone else's site and they move
    or remove a page, you have no way of knowing without specifically checking.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的目的是验证网页上的所有链接。检查链接的有效性有几个原因。首先，作为一个观众，遇到断链是非常令人沮丧的。其次，有效的链接使网站看起来更专业。最后，如果你的网站包含指向其他网站的链接，而他们移动或删除了页面，除非你特别检查，否则你无法知道。
- en: Without automating this task, a person would have to literally click each link
    to prove the paths were valid. Extremely small sites are easy to validate, but
    sites with many links are tedious and time consuming. This is an example of a
    task that, when done manually, could take several hours. With the use of some
    Ruby tricks, you can cut that time down to 10 seconds! Writing the script will
    take a little time, but it's reusable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动化这项任务，一个人就必须逐个点击每个链接来验证路径是否有效。极小的网站很容易验证，但包含许多链接的网站既繁琐又耗时。这是一个手动完成可能需要几个小时的任务的例子。通过使用一些Ruby技巧，你可以将时间缩短到10秒！编写脚本会花费一点时间，但它可以重复使用。
- en: The Code
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''uri''  require ''open-uri''  require ''rubyful_soup''   begin   
      print "\n\nEnter website to crawl (ex. http://www.google.com): "      url =
    gets      puts url      uri = URI.parse(url) ![](../Images/00002.jpg) html = open(uri).read
    ![](../Images/00003.jpg) rescue Exception => e ![](../Images/00004.jpg)      print
    "Unable to connect to the url:"       puts "ERROR ----  #{e}"   end   soup = BeautifulSoup.new(html)  ![](../Images/00005.jpg) links
    = soup.find_all(''a'').map { |a| a[''href''] }  ![](../Images/00006.jpg) links.delete_if
    { |href| href =~ /javascript|mailto/ }  ![](../Images/00007.jpg) links.each do
    |l|      if l          begin              link = URI.parse(l)              link.scheme
    ||= ''http''              link.host ||= uri.host              link.path = uri.path
    + link.path unless link.path[0] == //              link = URI.parse(link.to_s)    
              open(link).read          rescue Exception => e              puts "#{link}
    failed because #{e}"          end      end  end`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''uri''  require ''open-uri''  require ''rubyful_soup''   begin   
      print "\n\n请输入要爬取的网站（例如：http://www.google.com）: "      url = gets      puts
    url      uri = URI.parse(url) ![](../Images/00002.jpg) html = open(uri).read ![](../Images/00003.jpg) rescue
    Exception => e ![](../Images/00004.jpg)      print "无法连接到url："       puts "ERROR
    ----  #{e}"   end   soup = BeautifulSoup.new(html)  ![](../Images/00005.jpg) links
    = soup.find_all(''a'').map { |a| a[''href''] }  ![](../Images/00006.jpg) links.delete_if
    { |href| href =~ /javascript|mailto/ }  ![](../Images/00007.jpg) links.each do
    |l|      if l          begin              link = URI.parse(l)              link.scheme
    ||= ''http''              link.host ||= uri.host              link.path = uri.path
    + link.path unless link.path[0] == //              link = URI.parse(link.to_s)    
              open(link).read          rescue Exception => e              puts "#{link}
    failed because #{e}"          end      end  end`'
- en: Running the Code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'You will validate the links on any given website by first launching the script
    like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过首先以这种方式启动脚本来验证任何给定网站上的链接：
- en: '``**`ruby linkValidator.rb`**``'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby linkValidator.rb`**``'
- en: The script will present you with a prompt to enter the website you want to crawl.
    You need to enter the site with a full URL address (for example, [http://www.nostarch.com/](http://www.nostarch.com/)).
    From there, the script will list the links it had trouble accessing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会提示您输入想要爬取的网站。您需要输入带有完整URL地址的网站（例如，[http://www.nostarch.com/](http://www.nostarch.com/)）。从那里，脚本将列出它难以访问的链接。
- en: The Results
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: As a test, I ran the script against a website that shall go nameless, and the
    results are below.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，我将脚本运行在一个不便透露的网站上，结果如下。
- en: '``Enter website to crawl (ex. http://www.google.com): *`http://www.url.com`*
    http://www.url.com/products/specials.html failed because 403 Forbidden``'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '``输入要爬取的网站（例如：http://www.google.com）：*`http://www.url.com`* http://www.url.com/products/specials.html
    失败，因为 403 禁止访问```'
- en: The site contained about 50 links. Each link was validated except for one, *specials.html*.
    As you can see from the error reported, the reason the specials page was not accessible
    was due to "403 Forbidden." This happened because the site owner didn't want to
    release the specials page for public viewing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站大约有50个链接。除了一个名为 *specials.html* 的链接外，其他所有链接都经过了验证。正如从错误报告中可以看出，specials 页面无法访问的原因是
    "403 禁止访问"。这是因为网站所有者不想让公众查看 special 页面。
- en: How It Works
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: For starters, we need to talk about HTML manipulation and interfacing with websites.
    Ruby has several ways of accessing the Web, but the simplest to use, by far, is
    open_uri. If you are familiar with `wget`, then getting to know open_uri should
    be easy; with my wicked little gems, I'm halfway to scraping web pages. For Internet
    scraping activities, I typically use rubyful_soup, an HTML/XML parser for Ruby,
    in combination with uri and open_uri. The rubyful_soup gem can be installed like
    any of the other gems used throughout the book. As you follow the examples in
    the book, you will see just how powerful rubyful_soup can be.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要谈谈HTML操作和与网站交互。Ruby有几种访问网络的方式，但最简单易用的，无疑是open_uri。如果你熟悉 `wget`，那么了解open_uri应该很容易；通过我的邪恶小宝石，我已经在抓取网页的路上走了一半。对于网络抓取活动，我通常使用rubyful_soup，这是一个Ruby的HTML/XML解析器，结合uri和open_uri使用。rubyful_soup宝石可以像书中使用的其他宝石一样安装。当你跟随书中的示例时，你会看到rubyful_soup有多强大。
- en: The script begins with some error handling in case the user mistakenly enters
    a bad URL or a connection cannot be made to the root directory of the web address
    ![](../Images/00003.jpg). Either way, the user will get more than one chance to
    correct his errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本开始时有一些错误处理，以防用户错误地输入了错误的URL或无法连接到网址的根目录！[](../Images/00003.jpg)。无论如何，用户将有多于一次的机会来纠正他的错误。
- en: After the URL has been entered, it is parsed using the uri library. The URL
    you provide is opened using the `open(uri).read` command ![](../Images/00002.jpg).
    This single line opens the URL and reads in all of the HTML source code. Pretty
    cool, huh? Did you ever think scraping a web page would be so easy?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入了URL之后，它使用uri库进行解析。你提供的URL使用 `open(uri).read` 命令打开！[](../Images/00002.jpg)。这一行打开了URL并读取了所有的HTML源代码。很酷，对吧？你曾想过抓取网页会这么简单吗？
- en: If there are any issues navigating to your URL, the script will show you the
    error and print the specific error message ![](../Images/00004.jpg). Now on to
    the fun part, where rubyful_soup shows its power.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在导航到你的URL时出现任何问题，脚本将显示错误并打印出具体的错误信息！[](../Images/00004.jpg)。现在轮到有趣的部分了，这是rubyful_soup展示其力量的时刻。
- en: A new batch of rubyful_soup is made by initializing the `BeautifulSoup` and
    passing in our HTML source code. The soup allows us to easily parse the HTML source
    code. Sure, you could write a fancy regular expression or check each line for
    an `HREF`, but this feature is already supported by the soup! Just tell the soup
    to find all of the links in the source and save them to our array entitled `links`
    ![](../Images/00005.jpg). One thing we want to remove is `javascript` and `mailto`
    links because these will make the parsers unhappy when they start testing link
    validity ![](../Images/00006.jpg). Once the links are cleaned up, the script starts
    to iterate through each one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过初始化 `BeautifulSoup` 并传入我们的HTML源代码，制作了一批新的rubyful_soup。这个soup允许我们轻松解析HTML源代码。当然，你可以写一个复杂的正则表达式或者检查每一行是否有
    `HREF`，但这个功能已经由soup支持了！只需告诉soup在源代码中查找所有链接并将它们保存到我们名为 `links` 的数组中！[](../Images/00005.jpg)。我们想要移除的是
    `javascript` 和 `mailto` 链接，因为这些链接在开始测试链接有效性时会让解析器感到不高兴！[](../Images/00006.jpg)。一旦链接清理完毕，脚本开始遍历每一个链接。
- en: Because we are checking for the validity of each link, what we are really checking
    for is any link that throws an error. If no errors are thrown, we know for certain
    that the link is valid. To interpret the output, we use a little more error-handling-fu
    and start checking each link ![](../Images/00007.jpg). If the links are valid,
    the script will move on. If a link is bad, it will be logged. In this script,
    I have chosen to output the bad links to the command prompt, but you can hack
    the script to output to a text file or whatever you want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在检查每个链接的有效性，我们实际上是在检查任何会抛出错误的链接。如果没有错误被抛出，我们可以确定链接是有效的。为了解释输出，我们使用了更多的错误处理技巧，并开始检查每个链接
    ![图片](../Images/00007.jpg)。如果链接有效，脚本将继续。如果链接有问题，它将被记录。在这个脚本中，我选择将坏链接输出到命令提示符，但你也可以修改脚本以将其输出到文本文件或其他你想要的格式。
- en: Hacking the Script
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本黑客技术
- en: Another hack for this script would be to crawl the valid links that are found
    in the initial root domain. You can limit the crawler by specifying a link depth
    at which to crawl. This would allow you to crawl every link on an entire site.
    If the site isn't your own, you'd probably also want to add a delay between page
    fetches so that you wouldn't bog down the server. You could also incorporate HTTPS
    support using open_uri.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，另一个技巧是爬取在初始根域名中找到的有效链接。你可以通过指定一个爬取的链接深度来限制爬虫。这将允许你爬取整个网站上的每个链接。如果该网站不是你自己的，你可能还希望在页面抓取之间添加延迟，这样就不会拖垮服务器。你也可以使用open_uri来集成HTTPS支持。
- en: If there is a particular site you wish to crawl, you can hard-code the address
    into the script so you won't have to keep typing it. This is a great foundational
    script for more Internet scraping.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望爬取特定的网站，你可以将地址硬编码到脚本中，这样你就不必每次都输入它。这是一个非常棒的爬虫脚本基础。
- en: Orphan File Checker
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤儿文件检查器
- en: Orphan File Checker
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 孤儿文件检查器
- en: orphanCheck.rb
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: orphanCheck.rb
- en: In this section, we will be looking at the inverse of invalid link files—I will
    show you how to find files that are not linked at all. *An orphan file* is any
    file on a web server that has lost its link. Not only do these files waste space,
    they also have the potential to confuse web page administrators with superfluous
    files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看无效链接文件的逆过程——我将向你展示如何找到完全没有链接的文件。"孤儿文件"是指任何在Web服务器上丢失链接的文件。这些文件不仅浪费空间，还有可能用多余的文件让网页管理员感到困惑。
- en: I am what some may call a neat freak. I like to have things in order, just the
    way I like them. I despise clutter and wasted space. I treat my computer systems
    the same way, so I prefer to keep only the files that I need. If you have ever
    made a lot of changes or upgrades, or if you have had to share a system with other
    people, then you know how chaotic and disorganized filesystems can become. The
    orphan file checker script is unique because it gives you information that solves
    two problems. The first problem is finding out which files are not accessible
    on your web server. Secondly, the script allows you to see the files that are
    being listed that should not be. Obviously, some files are not meant to have a
    link, but you should know which ones those are before you run this script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能被一些人称为整洁狂热者。我喜欢事物井然有序，就像我喜欢的那样。我讨厌杂乱和浪费空间。我对我的计算机系统也是同样的态度，所以我更喜欢只保留我需要的文件。如果你曾经做过很多更改或升级，或者如果你曾经不得不与他人共享系统，那么你就知道文件系统可以变得多么混乱和无序。孤儿文件检查器脚本的独特之处在于它提供的信息可以解决两个问题。第一个问题是找出哪些文件在你的Web服务器上不可访问。其次，该脚本允许你看到那些不应该被列出的文件。显然，有些文件不应该有链接，但在运行此脚本之前，你应该知道哪些文件是这样的。
- en: The Code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) links = Array.new  orphans = Array.new  dir_array
    = [Dir.getwd]  ![](../Images/00003.jpg) unless File.readable?("links.txt")   
      puts "File is not readable."      exit  end   File.open(''links.txt'', ''rb'')
    do |lv|      lv.each_line do |line|          links << line.chomp      end  end   begin
         p = dir_array.shift      Dir.chdir(p)       Dir.foreach(p) do |filename|
             next if filename == ''.'' or filename == ''..''          if !File::directory?(filename)
    ![](../Images/00004.jpg)                orphans << p + File::SEPARATOR + filename
             else              dir_array << p + File::SEPARATOR + filename       
      end      end  end while !dir_array.empty?  ![](../Images/00005.jpg) orphans
    -= links   File.open("orphans.txt", "wb") do |o| ![](../Images/00006.jpg)    
      o.puts orphans  end`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) links = Array.new  orphans = Array.new  dir_array
    = [Dir.getwd]  ![](../Images/00003.jpg) unless File.readable?("links.txt")   
      puts "文件不可读。"      exit  end   File.open(''links.txt'', ''rb'') do |lv|     
    lv.each_line do |line|          links << line.chomp      end  end   begin     
    p = dir_array.shift      Dir.chdir(p)       Dir.foreach(p) do |filename|     
        next if filename == ''.'' or filename == ''..''          if !File::directory?(filename)
    ![](../Images/00004.jpg)                orphans << p + File::SEPARATOR + filename
             else              dir_array << p + File::SEPARATOR + filename       
      end      end  end while !dir_array.empty?  ![](../Images/00005.jpg) orphans
    -= links   File.open("orphans.txt", "wb") do |o| ![](../Images/00006.jpg)    
      o.puts orphans  end`'
- en: Running the Script
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'To run the script, you must have already created a file called *links.txt*
    that contains a list of all the hyperlinks on a website. This list can be accomplished
    using a modified version of "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055),
    or one of your own scripts. The format is a single file, with the full path on
    each line. The file I used for this example was based on a web page used to track
    a few of my Ruby web scripts; it looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，你必须已经创建了一个名为 *links.txt* 的文件，该文件包含网站上所有超链接的列表。这个列表可以使用 [The Code](../Text/dummy_split_076.html#filepos194055)
    上的修改版 "#10 Web Page Link Validator" 或你自己的脚本完成。格式是一个单独的文件，每行包含完整路径。我用于此示例的文件基于一个用于跟踪我一些
    Ruby 网页脚本的网页；它看起来像这样：
- en: '`/ruby/scripts/website_scripting\index.html /ruby/scripts/website_scripting\orphanCheck.rb
    /ruby/scripts/website_scripting\rssParser.rb /ruby/scripts/website_scripting\ipAdderGen.rb
    /ruby/scripts/website_scripting\formGenerator.rb`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ruby/scripts/website_scripting\index.html /ruby/scripts/website_scripting\orphanCheck.rb
    /ruby/scripts/website_scripting\rssParser.rb /ruby/scripts/website_scripting\ipAdderGen.rb
    /ruby/scripts/website_scripting\formGenerator.rb`'
- en: 'The script does all of the work; you just have to type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本完成所有工作；你只需输入：
- en: '``**`ruby orphanCheck.rb`**``'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby orphanCheck.rb`**``'
- en: Now sit back, relax, and wait for the script to write *orphans.txt*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请坐下来放松，等待脚本写入 *orphans.txt*。
- en: The Results
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The results of this script will be in a file called *orphans.txt*. The file
    will contain a complete path for each file that does not have a listing in *links.txt*.
    As you recall, the *links.txt* file contains a list of all files found on your
    website. Here''s an example *orphans.txt* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出结果将保存在名为 *orphans.txt* 的文件中。该文件将包含每个在 *links.txt* 文件中没有列出的文件的完整路径。如您所回忆的，*links.txt*
    文件包含网站上找到的所有文件的列表。以下是一个 *orphans.txt* 文件的示例：
- en: '`/ruby/scripts/website_scripting\form.html /ruby/scripts/website_scripting\linkValidator.rb
    /ruby/scripts/website_scripting\subnetting.rb /ruby/scripts/website_scripting\historicalStockParse.rb
    /ruby/scripts/website_scripting\links.txt`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ruby/scripts/website_scripting\form.html /ruby/scripts/website_scripting\linkValidator.rb
    /ruby/scripts/website_scripting\subnetting.rb /ruby/scripts/website_scripting\historicalStockParse.rb
    /ruby/scripts/website_scripting\links.txt`'
- en: These are the files that were found on the web server that were not in the *links.txt*
    file. If I wanted to share these files with the world, then I would have `<a href="link">`
    tags for them on my web page. But if these orphaned files were still in the works
    and not ready for public viewing, then there wouldn't be any issue (which was
    the case here).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在网页服务器上找到但不在 *links.txt* 文件中的文件。如果我想将这些文件与全世界分享，那么在我的网页上为它们添加 `<a href="link">`
    标签。但如果这些孤儿文件仍在制作中且尚未准备好公开查看，那么就不会有任何问题（情况就是这样）。
- en: How It Works
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: The script does not use any outside libraries, thus keeping its execution simple.
    I start by initializing the arrays that I'll be using to keep track of my links
    and orphan files ![](../Images/00002.jpg). Next, I look to ensure that my *links.txt*
    file exists. If not, then there isn't much point in continuing to run the script,
    so it exits out with a nice error message ![](../Images/00003.jpg). If *links.txt*
    does exist, then we continue by opening the file and reading in all of the contents
    line-by-line. You can change this to a *comma-separated values (CSV)* file, but
    I prefer the readability of one link per line.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本不使用任何外部库，因此保持了其执行简单。我开始初始化我将使用来跟踪我的链接和孤儿文件的数组 ![图片](../Images/00002.jpg)。接下来，我检查我的*links.txt*文件是否存在。如果不存在，那么继续运行脚本就没有太多意义了，所以它会以一个友好的错误消息退出
    ![图片](../Images/00003.jpg)。如果*links.txt*文件存在，那么我们将继续打开文件并逐行读取所有内容。你可以将其更改为*逗号分隔值
    (CSV)* 文件，但我更喜欢每行一个链接的易读性。
- en: After the links have been stored in the array `links`, the script begins to
    index every file in the current working directory. The results will be stored
    in an array called `orphans` ![](../Images/00004.jpg). If there are subdirectories,
    the script will also index those files. Presumably, you would run this in the
    root directory of your web server to take full advantage of this script.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在将链接存储在数组`links`之后，脚本开始索引当前工作目录中的每个文件。结果将存储在一个名为`orphans`的数组中 ![图片](../Images/00004.jpg)。如果有子目录，脚本也会索引那些文件。假设你会在这个脚本的根目录下运行它，以充分利用这个脚本。
- en: Now that the script has both the links and local files indexed, it is time to
    start comparing the two arrays, and see what's left ![](../Images/00005.jpg).
    I called the second array `orphans` because I will be deleting any entry that
    exists within the `link` array. Whatever is left will be files not included on
    the public-facing side of the web server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经对链接和本地文件进行了索引，是时候开始比较这两个数组，看看还剩下什么 ![图片](../Images/00005.jpg)。我称第二个数组为`orphans`，因为我将删除任何存在于`link`数组中的条目。剩下的将是不包含在公共服务器端的文件。
- en: The script ends by creating a file called *orphans.txt* in the script's directory
    and writing the results to that file ![](../Images/00006.jpg). Finally, after
    the code block is finished, the file is closed and the script finished.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本最后在脚本目录中创建一个名为*orphans.txt*的文件，并将结果写入该文件 ![图片](../Images/00006.jpg)。最后，在代码块完成后，文件被关闭，脚本结束。
- en: Form Generator
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单生成器
- en: Form Generator
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单生成器
- en: formGenerator.rb
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: formGenerator.rb
- en: When forms first came onto the HTML scene, they were underutilized tools. Now
    you can go to practically any site and find a form with one of those cool little
    submission buttons at the bottom. Google returns a whopping 60,000,000 results
    for a *submit button* search. Needless to say, web forms have become part of our
    digital lives. Forms can gather many different types of information. They can
    also anonymize a recipient's email address. If your email address is published
    on a website and an email harvester collects it, you can expect to be receiving
    a lot of spam. If you use a form on your site, your email remains hidden from
    users (and robots), but you can still receive email from your site's users. Also,
    forms allow users to communicate without a need for their own *Simple Mail Transfer
    Protocol (SMTP)* server or email service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单首次出现在HTML场景中时，它们是被低估的工具。现在你几乎可以访问任何网站，并找到底部有那种酷炫的小提交按钮的表单。谷歌为*提交按钮*搜索返回了惊人的6000万条结果。不用说，网络表单已经成为我们数字生活的一部分。表单可以收集许多不同类型的信息。它们还可以匿名化收件人的电子邮件地址。如果你的电子邮件地址发布在网站上，并且电子邮件收集器收集了它，你可以预期会收到大量的垃圾邮件。如果你在你的网站上使用表单，你的电子邮件将保持对用户（和机器人）隐藏，但你仍然可以收到来自网站用户的电子邮件。此外，表单允许用户在不需要他们自己的*简单邮件传输协议
    (SMTP)* 服务器或电子邮件服务的情况下进行通信。
- en: Forms are simple and flexible. If you want to receive customer feedback, create
    a form. If you want to conduct a survey, create a form. You get the idea.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表单简单灵活。如果你想收集客户反馈，创建一个表单。如果你想进行调查，创建一个表单。你明白这个意思。
- en: 'Knowing how to create them is a good skill to have, but an even cooler skill
    is knowing how to create them automatically! With this script, you can build forms
    on the fly or create form templates. Creating web forms is no big deal. As you
    experiment with this script, you will generate numerous form files. If you don''t
    feel like tracking each file, then use script #11, Orphan File Checker (see [Hacking
    the Script](../Text/dummy_split_080.html#filepos203147)), to clean up your mess.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '知道如何创建它们是一项很好的技能，但更酷的技能是知道如何自动创建它们！使用这个脚本，您可以即时构建表单或创建表单模板。创建网页表单并不是什么大问题。随着您对这个脚本的实验，您将生成大量的表单文件。如果您不想跟踪每个文件，那么请使用脚本
    #11，孤儿文件检查器（见 [Hacking the Script](../Text/dummy_split_080.html#filepos203147)），来清理您的混乱。'
- en: The Code
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`require ''cgi''  ![](../Images/00002.jpg) cgi = CGI.new("html4Tr")  ![](../Images/00003.jpg) print
    "Enter Form Page Title: "  title = gets.chomp  print "Enter Head Title: "  input_title
    = gets.chomp  print "Enter value for button: "  value = gets.chomp  print "Enter
    group: "  group = gets.chomp  ![](../Images/00004.jpg) $stdout = File.new("form.html","w")
     cgi.out{      CGI.pretty(          cgi.html{  ![](../Images/00005.jpg)      
                 cgi.head{ "\n"+cgi.title{title}}+                  cgi.body{"\n"
    +                      cgi.form{"\n" +                      cgi.hr +         
                cgi.h1 { "#{input_title}:" } + "\n" +                      cgi.br
    +                      cgi.checkbox(group, value) + value + cgi.br +         
                cgi.br +                      cgi.textarea("input",80,5) + "\n" +
                         cgi.br +                      cgi.submit("Send")         
                }                  }           }     )  }   $stdout.close`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''cgi''  ![](../Images/00002.jpg) cgi = CGI.new("html4Tr")  ![](../Images/00003.jpg) print
    "Enter Form Page Title: "  title = gets.chomp  print "Enter Head Title: "  input_title
    = gets.chomp  print "Enter value for button: "  value = gets.chomp  print "Enter
    group: "  group = gets.chomp  ![](../Images/00004.jpg) $stdout = File.new("form.html","w")
     cgi.out{      CGI.pretty(          cgi.html{  ![](../Images/00005.jpg)      
                 cgi.head{ "\n"+cgi.title{title}}+                  cgi.body{"\n"
    +                      cgi.form{"\n" +                      cgi.hr +         
                cgi.h1 { "#{input_title}:" } + "\n" +                      cgi.br
    +                      cgi.checkbox(group, value) + value + cgi.br +         
                cgi.br +                      cgi.textarea("input",80,5) + "\n" +
                         cgi.br +                      cgi.submit("Send")         
                }                  }           }     )  }   $stdout.close`'
- en: Running the Code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: This script takes user input to create the HTML form. Execute the script like
    any other, and follow its lead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本通过用户输入来创建 HTML 表单。像执行其他脚本一样执行此脚本，并遵循其指示。
- en: The Results
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Contents *of form.html*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`form.html` 的内容：'
- en: '`Content-Type: text/html Content-Length: 724  <!DOCTYPE HTML PUBLIC "-//W3C//DTD
    HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <HTML>   <HEAD>
        <TITLE>       No Starch Press | Errata Submissions     </TITLE>   </HEAD>
      <BODY>      <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">
          <HR>       <H1>         Wicked Cool Ruby Scripts -- Errata Submissions:
          </H1>       <BR>       <INPUT NAME="Bad Errata Submissions" TYPE="checkbox"
    VALUE="High Priority">       Super Critical!!!       <BR>       <TEXTAREA NAME="input"
    ROWS="5" COLS="80">       </TEXTAREA>       <BR>       <INPUT TYPE="submit" VALUE="Send">
        </FORM>   </BODY> </HTML>`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type: text/html Content-Length: 724  <!DOCTYPE HTML PUBLIC "-//W3C//DTD
    HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <HTML>   <HEAD>
        <TITLE>       No Starch Press | Errata Submissions     </TITLE>   </HEAD>
      <BODY>      <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">
          <HR>       <H1>         Wicked Cool Ruby Scripts -- Errata Submissions:
          </H1>       <BR>       <INPUT NAME="Bad Errata Submissions" TYPE="checkbox"
    VALUE="High Priority">       Super Critical!!!       <BR>       <TEXTAREA NAME="input"
    ROWS="5" COLS="80">       </TEXTAREA>       <BR>       <INPUT TYPE="submit" VALUE="Send">
        </FORM>   </BODY> </HTML>`'
- en: See it in action in [Figure 2-1](#filepos223333).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 2-1](#filepos223333) 中查看其效果。
- en: '![The resulting form, as seen in a web browser](../Images/00010.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![在网页浏览器中看到的最终形式](../Images/00010.jpg)'
- en: Figure 2-1. The resulting form, as seen in a web browser
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1. 在网页浏览器中看到的最终形式
- en: How It Works
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The form generation script uses the cgi library, so it is included in the `require`
    statement. I created a new document and specified that the HTML 4.0 Transitional
    version methods be used for generating my code by using `html4Tr` as the argument
    ![](../Images/00002.jpg). The other options are `html3` (HTML 3.*x*), `html4`
    (HTML 4.*x*), or `html4Fr` (HTML 4.0 with Framesets). After the cgi methods have
    been set up, the script requests information from the user ![](../Images/00003.jpg).
    This script creates a submission form with one checkbox and a text box. The example
    is a form developed for errata submissions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表单生成脚本使用 cgi 库，因此在 `require` 语句中包含它。我创建了一个新文档，并指定使用 `html4Tr` 作为参数来生成我的代码，使用
    HTML 4.0 Transitional 版本的方法 ![图片](../Images/00002.jpg)。其他选项是 `html3`（HTML 3.*x*）、`html4`（HTML
    4.*x*）或 `html4Fr`（带有框架集的 HTML 4.0）。在设置 cgi 方法之后，脚本请求用户的信息 ![图片](../Images/00003.jpg)。此脚本创建了一个包含一个复选框和一个文本框的提交表单。这个例子是为勘误表单开发的。
- en: The header of the form is requested first, followed by the title of the web
    form. Next, the value of the checkbox is presented. In this example, I gave the
    user an option of submitting the value `High Priority`, to demonstrate the checkbox
    options. Checkboxes are useful when you are looking for information that must
    be a specific choice; for example, dinner choices—`chicken` or `beef`. Finally,
    I added a text box to allow the user to detail any errors she may have found.
    Once the information is collected, the script will go to work writing a slick
    HTML form.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先请求表单的头部，然后是网页表单的标题。接下来展示复选框的值。在这个例子中，我给了用户提交值 `High Priority` 的选项，以展示复选框选项。复选框在你需要寻找必须做出特定选择的信息时很有用；例如，晚餐选择——`chicken`
    或 `beef`。最后，我添加了一个文本框，允许用户详细说明她可能发现的任何错误。一旦收集到信息，脚本将开始编写一个漂亮的 HTML 表单。
- en: Two important lines of code are included in the redirection of standard output
    ![](../Images/00004.jpg). `$stdout` is redirected to a new file called *form.html*,
    and it will capture the HTML form. The cgi method `out` is called to prepare the
    file for the creation of HTML code. Then the `pretty` method is used; although
    not necessary, it cleans up the HTML code so it resembles something you can easily
    read, with proper line spacing and indentations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准输出的重定向中包含了两个重要的代码行 ![图片](../Images/00004.jpg)。`$stdout` 被重定向到一个名为 *form.html*
    的新文件中，它将捕获 HTML 表单。调用 cgi 方法 `out` 准备文件以创建 HTML 代码。然后使用 `pretty` 方法；虽然不是必需的，但它清理了
    HTML 代码，使其易于阅读，具有适当的行间距和缩进。
- en: The `HTML` method then begins constructing each piece of our form. First comes
    the head, which we specified earlier; next is the body, with each part of the
    form ![](../Images/00005.jpg). Last, and most importantly, is the submission button,
    which I appropriately named Send. To clean up our open file, we close it and exit
    the script. Our shiny new HTML form is ready for use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `HTML` 方法开始构建我们表单的每一部分。首先是头部，这是我们之前指定的；接下来是主体，包含表单的每一部分 ![图片](../Images/00005.jpg)。最后，也是最重要的，是提交按钮，我恰当地命名为“发送”。为了清理我们打开的文件，我们关闭它并退出脚本。我们闪亮的新
    HTML 表单已准备好使用。
- en: Hacking the Script
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: The beauty of this script is in how simple writing HTML code becomes. You can
    explore the cgi library further to incorporate radio buttons, multiple groups,
    and other elements of a form. You can make this script even more flexible by specifying
    how many groups are needed and how many options should be in each group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的优点在于如何使编写 HTML 代码变得简单。你可以进一步探索 cgi 库，以包含单选按钮、多组和其他表单元素。你可以通过指定需要多少组和每组应该有多少选项来使这个脚本更加灵活。
- en: RSS Parsing
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSS 解析
- en: RSS Parsing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSS 解析
- en: rssParser.rb
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rssParser.rb
- en: '*Really Simple Syndication (RSS)* is a wonderful technology that has been gaining
    popularity since early 2000\. RSS feeds allow users to stay current on information
    that frequently changes, such as news headlines or product announcements. Many
    websites feature RSS feeds, and a feed reader is needed to extract the important
    data included in the feed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正简单的聚合（RSS）* 是一种自 2000 年初以来越来越受欢迎的奇妙技术。RSS 源允许用户保持对经常变化的信息的最新了解，例如新闻标题或产品公告。许多网站都提供
    RSS 源，需要一个源阅读器来提取源中包含的重要数据。'
- en: Distribution can extend the functionality and interoperability of information.
    Ruby has a library which allows you to customize the way feeds are retrieved,
    published, aggregated, and manipulated. This script will allow you to retrieve
    information from No Starch's blog at [http://nostarch.com/blog/?feed=rss2/](http://nostarch.com/blog/?feed=rss2/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分发可以扩展信息的功能和互操作性。Ruby有一个库，允许你自定义获取、发布、聚合和操作feed的方式。此脚本将允许你从No Starch的博客[http://nostarch.com/blog/?feed=rss2/](http://nostarch.com/blog/?feed=rss2/)获取信息。
- en: The Code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''rss/1.0''  require ''rss/2.0''  require ''open-uri''  ![](../Images/00002.jpg) source
    = "http://nostarch.com/blog/?feed=rss2" # location of rss feed  content = ""  ![](../Images/00003.jpg) open(source)
    do |info|      content = info.read  end  ![](../Images/00004.jpg) rss = RSS::Parser.parse(content,
    false)   print "Do you want to see feed descriptions (y/n)? "    input = gets.chomp   desc
    = input == ''y'' || input == ''Y''   puts "\n\nTITLE: #{rss.channel.title}"  puts
    "DESCRIPTION: #{rss.channel.description}"  puts "LINK: #{rss.channel.link}"  puts
    "PUBLICATION DATE: #{rss.channel.date} \n\n"  ![](../Images/00005.jpg) rss.items.size.times
    do |i|      puts "#{rss.items[i].date} ... #{rss.items[i].title}"      if desc
             print "#{rss.items[i].description}\n\n\n"      end  end`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''rss/1.0''  require ''rss/2.0''  require ''open-uri''  ![](../Images/00002.jpg) source
    = "http://nostarch.com/blog/?feed=rss2" # rss feed的位置  content = ""  ![](../Images/00003.jpg) open(source)
    do |info|      content = info.read  end  ![](../Images/00004.jpg) rss = RSS::Parser.parse(content,
    false)   print "你想查看feed描述吗（y/n）？ "    input = gets.chomp   desc = input == ''y''
    || input == ''Y''   puts "\n\n标题：#{rss.channel.title}"  puts "描述：#{rss.channel.description}"
     puts "链接：#{rss.channel.link}"  puts "发布日期：#{rss.channel.date} \n\n"  ![](../Images/00005.jpg) rss.items.size.times
    do |i|      puts "#{rss.items[i].date} ... #{rss.items[i].title}"      if desc
             print "#{rss.items[i].description}\n\n\n"      end  end`'
- en: Running the Code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '``**`ruby rssParser.rb`**``'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby rssParser.rb`**``'
- en: The script will then ask if you would like to see the feed descriptions along
    with the titles. Enter `yes` or `no`. If you input `no`, the script will display
    only the titles from each entry.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将询问你是否想查看feed描述以及标题。输入`yes`或`no`。如果你输入`no`，脚本将只显示每个条目的标题。
- en: The Results
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'With the descriptions turned off:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭描述：
- en: '`TITLE: The No Starch Press Blog DESCRIPTION: With more stuff, less fluff LINK:
    http://nostarch.com/blog PUBLICATION DATE: Thu, 07 Aug 2008 13:42:08 -0400  Thu,
    07 Aug 2008 13:42:08 -0400 ... Good eats in Vegas Tue, 29 Jul 2008 22:44:17 -0400
    ... Boolean Operator Thu, 10 Jul 2008 03:18:18 -0400 ... Windows Upgrade Hell
    Sat, 05 Jul 2008 02:47:27 -0400 ... Problems brewing at Google? Thu, 03 Jul 2008
    15:35:30 -0400 ... Nick Hornby on eBooks Tue, 17 Jun 2008 17:37:15 -0400 ... Happy
    Download Day! Tue, 17 Jun 2008 14:22:08 -0400 ... How to Write a Book Mon, 16
    Jun 2008 19:08:22 -0400 ... Monday Afternoon Linkfest Mon, 02 Jun 2008 04:36:47
    -0400 ... Is blogging boring? Wed, 21 May 2008 05:15:18 -0400 ... Giant LEGO Boulder`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`标题：The No Starch Press Blog 描述：内容丰富，无冗余 链接：http://nostarch.com/blog 发布日期：Thu,
    07 Aug 2008 13:42:08 -0400  Thu, 07 Aug 2008 13:42:08 -0400 ... 在拉斯维加斯的美食 Tue,
    29 Jul 2008 22:44:17 -0400 ... 布尔运算符 Thu, 10 Jul 2008 03:18:18 -0400 ... 窗口升级地狱
    Sat, 05 Jul 2008 02:47:27 -0400 ... 谷歌的问题？ Thu, 03 Jul 2008 15:35:30 -0400 ...
    尼克·霍恩比关于电子书 Tue, 17 Jun 2008 17:37:15 -0400 ... 下载快乐日！ Tue, 17 Jun 2008 14:22:08
    -0400 ... 如何写一本书 Mon, 16 Jun 2008 19:08:22 -0400 ... 周一下午链接节 Mon, 02 Jun 2008
    04:36:47 -0400 ... 博客无聊吗？ Wed, 21 May 2008 05:15:18 -0400 ... 巨大的乐高巨石`'
- en: 'With the descriptions left on:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 保持描述：
- en: '`TITLE: more stuff, less fluff DESCRIPTION: the only blog with no starch LINK:
    http://nostarch.com/blog PUBLICATION DATE: Thu, 07 Aug 2008 13:42:08 -0400  Thu,
    07 Aug 2008 13:42:08 -0400 ... Good eats in Vegas It''s DEFCON time and that means
    Vegas. And as tempting as the $1.99 buffet might be, maybe you''ve had all the
    cheap steak you want for the day. Check out Bill''s restaurant map for other ideas.
    There''s a wide range represented, from Himalayan cuisine to good ol'' American
    food. If you''ve been to any of [...]  Tue, 29 Jul 2008 22:44:17 -0400 ... Boolean
    Operator The search performed by Monica Goodling while ''vetting'' candidates
    for positions within the Department of Justice: [First name of a candidate]! and
    pre/2 [last name of a candidate] w/7 bush or gore or republican! or democrat!
    or charg! or accus! or criticiz! or blam! or defend! or iran contra or clinton
    or spotted owl or florida [...]  Thu, 10 Jul 2008 03:18:18 -0400 ... Windows Upgrade
    Hell Unfortunately, many of us here still use Windows. (I use Ubuntu almost exclusively
    now, except when I''m fixing Windows.) And, even more unfortunately, when it''s
    time for that inevitable Windows problem, I often end up having to fix it. Tonight
    I chose to upgrade one of our XP machines to XP Pro. You''d figure that would
    [...]  ---[snip]---`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`标题：更多内容，更少废话 描述：唯一一个没有淀粉的博客 链接：http://nostarch.com/blog 发布日期：Thu, 07 Aug 2008
    13:42:08 -0400 Thu, 07 Aug 2008 13:42:08 -0400 ... 拉斯维加斯的美食 DEFCON时间到了，这意味着是拉斯维加斯的时候了。虽然1.99美元的自助餐很诱人，但你可能已经吃够了当天的便宜牛排。查看Bill的餐厅地图，看看其他想法。这里有很多种类的美食，从喜马拉雅菜系到传统的美国食物。如果你去过
    [...] Tue, 29 Jul 2008 22:44:17 -0400 ... 布尔运算 在司法部内部职位候选人“审查”过程中，Monica Goodling执行的搜索：[候选人名字]!
    and pre/2 [候选人姓氏] w/7 bush or gore or republican! or democrat! or charg! or accus!
    or criticiz! or blam! or defend! or iran contra or clinton or spotted owl or florida
    [...] Thu, 10 Jul 2008 03:18:18 -0400 ... Windows升级地狱 很不幸，我们这里很多人还在使用Windows。（我现在几乎只使用Ubuntu，除非我需要修复Windows。）而且，更不幸的是，当遇到那个不可避免的Windows问题时，我经常不得不修复它。今晚我选择将我们的一台XP机器升级到XP
    Pro。你可能会认为 [...] ---[省略]---`'
- en: How It Works
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: Fortunately, this script is fairly straightforward. The script starts off identifying
    the source of the RSS feed ![](../Images/00002.jpg). This can be either a live
    website or a local file, but it must be in RSS format. Next, we initialize the
    variable content and proceed to read in all of the information from our source
    file—in this case, the source file is No Starch's blog ![](../Images/00003.jpg).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个脚本相当直接。脚本首先识别RSS源的位置 ![图片](../Images/00002.jpg)。这可以是任何活网站或本地文件，但必须是RSS格式。接下来，我们初始化变量content，并继续从我们的源文件中读取所有信息——在这个例子中，源文件是No
    Starch的博客 ![图片](../Images/00003.jpg)。
- en: After the raw data is saved in the variable content, the RSS parser begins working
    its magic. The parser will parse the RSS feed into its specific format and save
    the resulting data into a variable called `rss` ![](../Images/00004.jpg). The
    variable `rss` has a lot of properties available for manipulation, so feel free
    to dig in and see what other information you can glean from it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在将原始数据保存在变量content中后，RSS解析器开始施展其魔法。解析器会将RSS源解析成特定的格式，并将结果数据保存到名为`rss`的变量中 ![图片](../Images/00004.jpg)。变量`rss`有很多属性可供操作，所以请随意深入探索，看看你能从中获取哪些其他信息。
- en: Now that the hard part is out of the way, I decide what information will be
    presented to the user. The main information I was interested in looking at was
    dates, titles, and possibly descriptions. This way I can skim a feed for anything
    that might interest me further. The descriptions on some RSS feeds can be lengthy
    and take up a lot of space. I gave myself the option of seeing the descriptions,
    if I really needed to ![](../Images/00005.jpg). As you can see above, the output
    without lengthy descriptions is much easier to process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在困难的部分已经解决，我决定向用户展示哪些信息。我最感兴趣查看的信息是日期、标题，以及可能的描述。这样我就可以快速浏览一个信息源，寻找可能进一步吸引我的内容。一些RSS源的描述可能很长，占用很多空间。我给自己提供了查看描述的选项，如果我真的需要的话
    ![图片](../Images/00005.jpg)。正如你上面看到的，没有冗长描述的输出更容易处理。
- en: Hacking the Script
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: If you are interested in specific topics, you can incorporate a search function
    to look for particular key terms in the title of RSS entries or even in the descriptions
    themselves. Another idea is to use this script to comb several feeds, look for
    similar articles, and aggregate them for easy access. You may recall the date
    property; you can filter the results based on the date the entry was put into
    the feed. For instance, if you are looking for entries within the last week, you
    can write a conditional statement to only display the most recent information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对特定主题感兴趣，你可以加入一个搜索功能，在RSS条目的标题中或甚至在其描述中查找特定的关键词。另一个想法是使用这个脚本扫描多个源，寻找相似的文章，并将它们聚合起来以便于访问。你可能记得日期属性；你可以根据条目被放入源中的日期来过滤结果。例如，如果你正在寻找上周内的条目，你可以编写一个条件语句来仅显示最新的信息。
- en: Stock Exchange Grep
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股票交易所grep
- en: Stock Exchange Grep
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 股票交易所grep
- en: stockGrep.rb
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stockGrep.rb
- en: Stocks are awesome! I love investing in companies and watching them as they
    grow and develop into industry leaders. And watching a catastrophic failure is
    pretty interesting, too. The stock market is fascinating and complex, and many
    people spend their entire lives trying to understand it. I don't try to play the
    game or understand it; I just observe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 股票太棒了！我喜欢投资公司，并观察它们如何成长和发展成为行业领导者。观看一场灾难性的失败也同样有趣。股市既迷人又复杂，许多人花费他们的一生试图理解它。我不尝试玩游戏或理解它；我只是观察。
- en: But, whenever I see a stock that I think has promise, I like to keep an eye
    on it. I could watch the stocks through a web service or turn on the TV, but that's
    not fast enough for me. I like to get my information how, where, and when I want
    it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，每当我看到我认为有潜力的股票时，我喜欢密切关注它。我可以通过网络服务或打开电视来观察股票，但这对我来说不够快。我喜欢以我想要的方式、地点和时间获取信息。
- en: This script allows me to retrieve different pieces of information about particular
    stocks and perform actions based on certain events. For instance, this script
    could be made to send a text message when a stock reaches a pre-defined level.
    It can also aggregate several stocks in the same industry for easier comparison.
    There is so much data available in the stock market— to have the ability to extract
    the important information is priceless. This script can be modified in many different
    ways, so read through it and let your imagination run wild.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本允许我检索有关特定股票的不同信息，并根据某些事件执行操作。例如，这个脚本可以被修改为当股票达到预定义的水平时发送短信。它还可以将同一行业的多个股票聚合在一起，以便于比较。股市中有如此多的数据——能够提取重要信息是无价的。这个脚本可以以多种不同的方式修改，所以请阅读它，让你的想象力自由驰骋。
- en: The Code
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''open-uri'' ![](../Images/00002.jpg) require ''csv''  ![](../Images/00003.jpg) def
    get_info stock_symbol      puts "#{stock_symbol} Current Ticker Information" ![](../Images/00004.jpg)  
      url = "http://download.finance.yahoo.com/d/  quotes.csv?s=#{stock_symbol}&f=sl1d1t1c1ohgv&e=.csv"
         puts "Connecting to #{url}\n\n\n"  ![](../Images/00005.jpg)      csv = CSV.parse(open(url).read)    
      csv.each do |row|          puts "--------------------------------------------------"
             puts "Information current as of #{row[3]} on #{row[2]}\n\n"         
    puts "#{row[0]}''s last trade was - $#{row[1]}  (increase of #{row[4]})\n\n"   
          puts "\tOpened at $#{row[5]}"          puts "\tRange for the day $#{row[7]}
    - $#{row[6]}"      end      puts "--------------------------------------------------"
     end    print "Enter stock symbol (separate by space if > 1): "  stock_symbols
    = gets.upcase  ![](../Images/00006.jpg) stock_symbols.split.each do |symbol|   
      get_info(symbol)  end`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''open-uri'' ![图片](../Images/00002.jpg) require ''csv'' ![图片](../Images/00003.jpg) def
    get_info stock_symbol       puts "#{stock_symbol} 当前股票信息" ![图片](../Images/00004.jpg)      
    url = "http://download.finance.yahoo.com/d/     quotes.csv?s=#{stock_symbol}&f=sl1d1t1c1ohgv&e=.csv"      
    puts "连接到 #{url}\n\n\n" ![图片](../Images/00005.jpg)       csv = CSV.parse(open(url).read)      
    csv.each do |row|           puts "--------------------------------------------------"          
    puts "信息截至 #{row[3]} 在 #{row[2]}" "\n\n"           puts "#{row[0]} 的最后交易价格为 -
    $#{row[1]} (上涨了 #{row[4]})" "\n\n"           puts "\t开盘价为 $#{row[5]}"          
    puts "\t当日价格范围为 $#{row[7]} - $#{row[6]}"       end           puts "--------------------------------------------------"      
    end    print "请输入股票代码（如果有多个，请用空格分隔）: "    stock_symbols = gets.upcase    stock_symbols.split.each
    do |symbol|           get_info(symbol)       end`'
- en: Running the Code
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Running the script is easy—you give it a ticker symbol, and it pulls the data.
    That''s it. Execute the script by entering the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本很简单——你只需提供一个股票代码，它就会拉取数据。就是这样。通过输入以下内容来执行脚本：
- en: '``**`ruby stockGrep.rb`**``'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby stockGrep.rb`**``'
- en: You will then be prompted to enter the ticker symbols you want to look up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入你想要查询的股票代码。
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script can pull any information from Yahoo! Finance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可以从Yahoo! Finance获取任何信息。
- en: The Results
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Any information available from Yahoo! Finance will be output at the command
    prompt. *StockGrep.rb* outputs standard stock information in a nice format. In
    this example, I searched for Aruba Networks, Inc., which is a company that delivers
    enterprise wireless solutions. The results were promising:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! Finance上可用的任何信息都会在命令提示符中输出。*StockGrep.rb*以美观的格式输出标准股票信息。在这个例子中，我搜索了Aruba
    Networks, Inc.，这是一家提供企业无线解决方案的公司。结果很有希望：
- en: '`ARUN Current Ticker Information Connecting to http://download.finance.yahoo.com/d/quotes.csv?s=ARUN&f=sl1d1t1c1ohgv&e=.csv  --------------------------------------------------  Information
    current as of 4:00pm on 6/1/2007  ARUN''s last trade was - $20.20  (increase of
    +0.85)      Opened at $19.35     Range for the day $19.34 - $20.73 --------------------------------------------------`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARUN 当前股票代码信息 连接到 http://download.finance.yahoo.com/d/quotes.csv?s=ARUN&f=sl1d1t1c1ohgv&e=.csv
    --------------------------------------------------  信息截至2007年6月1日下午4:00  ARUN的最新交易价格为-
    $20.20（上涨+0.85）      开盘价为$19.35    当日价格范围为$19.34 - $20.73 --------------------------------------------------`'
- en: How It Works
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script begins by requiring the two libraries needed to provide full functionality
    to the script. We've already mentioned open_uri, which is the first library. For
    a reminder, see script "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055).
    The second library is csv, and it is capable of parsing comma-separated value
    files ![](../Images/00002.jpg). The returned object from Yahoo! will be a CSV
    file, as you will soon see.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先引入了两个库，以提供脚本的完整功能。我们之前提到过open_uri，这是第一个库。为了提醒，请参阅[代码](../Text/dummy_split_076.html#filepos194055)中的脚本“#10
    Web Page Link Validator”。第二个库是csv，它能够解析逗号分隔值文件！[](../Images/00002.jpg)。从Yahoo!返回的对象将是一个CSV文件，正如你很快就会看到的。
- en: Next, I define a short method that will be used to retrieve information from
    multiple ticker symbols ![](../Images/00003.jpg). If I wanted to limit the script
    to one ticker symbol at a time, this section could have been added right into
    the main body of the code. Within the method called `get_info`, the first step
    is to print the ticker symbol for the stock being analyzed. Then a custom URL
    is crafted in order to request the correct data from Yahoo! Finance ![](../Images/00004.jpg).
    Notice the `#{stock_symbol}` embedded within the URL; this is where the customization
    comes into play. When this URL is sent to Yahoo!, a comma-separated value file
    is sent back to the script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我定义了一个简短的方法，该方法将用于从多个股票代码中检索信息！[](../Images/00003.jpg)。如果我想将脚本限制为一次处理一个股票代码，这个部分可以直接添加到代码的主体中。在名为`get_info`的方法中，第一步是打印正在分析的股票代码。然后，为了从Yahoo!
    Finance请求正确数据，会构建一个自定义的URL！[](../Images/00004.jpg)。注意URL中嵌入的`#{stock_symbol}`；这就是定制的发挥作用的地方。当这个URL发送到Yahoo!时，会返回一个逗号分隔的值文件给脚本。
- en: The variable `csv` will be used to hold any data parsed by the `CSV.parse()`
    method. Each element in a CSV file will be put into an array ![](../Images/00005.jpg).
    Yahoo!'s stock files contain the same fields, so there is no guesswork involved
    in what the output should be. The six `puts` lines simply display the information
    in a user-friendly manner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`csv`将用于存储由`CSV.parse()`方法解析的任何数据。CSV文件中的每个元素都将放入一个数组！[](../Images/00005.jpg)。Yahoo!的股票文件包含相同的字段，因此在输出应该是什么方面没有猜测的余地。六个`puts`行只是以用户友好的方式显示信息。
- en: The last step of the script, which is actually the first to be executed, is
    to retrieve the stock symbols, then split them apart ![](../Images/00006.jpg).
    For each symbol that is split, the method `get_info` is called, as explained above.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一步，实际上是首先执行的一步，是检索股票代码，然后将其拆分！[](../Images/00006.jpg)。对于每个拆分的代码，都会调用上面解释的`get_info`方法。
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Warning
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Many websites continually change their products, so if the URL is no longer
    valid, you must find the new one. Updates to this script will be posted at* [http://www.nostarch.com/wcruby.htm/](http://www.nostarch.com/wcruby.htm/).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于许多网站会不断更改其产品，所以如果URL不再有效，你必须找到新的一个。此脚本的更新将发布在* [http://www.nostarch.com/wcruby.htm/](http://www.nostarch.com/wcruby.htm/)。'
- en: '* * *'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Hacking the Script
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: Several modifications can make this script even more powerful. If you are interested
    in trend analysis, you can integrate historical data into this script or even
    have the script retrieve data and write the information to another file for further
    analysis.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 几种修改可以使这个脚本更加强大。如果你对趋势分析感兴趣，可以将历史数据集成到这个脚本中，或者让脚本检索数据并将信息写入另一个文件以进行进一步分析。
- en: It's also worth considering other trends you could track using a web scraper.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得考虑使用网络爬虫跟踪的其他趋势。
- en: IP Address Generation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址生成
- en: IP Address Generation
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址生成
- en: ipAdderGen.rb
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ipAdderGen.rb
- en: Ever need to generate a range of IPs? I have found myself in several situations
    that called for just that, and I knew I didn't want to generate the list by hand.
    There isn't any magic involved, but the sheer usefulness of this script makes
    it noteworthy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是否曾需要生成一系列的IP地址？我发现自己处于需要这种情况的几种情况中，而且我知道我不想手动生成列表。这里没有魔法，但这个脚本的实用性使其变得值得注意。
- en: Working with networks on a day-to-day basis means dealing with IP addresses.
    Sometimes a simple `ping` sweep is used to identify machines on a network. This
    script generates a pre-defined list of IPs in any format I choose.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中处理网络意味着处理IP地址。有时会使用简单的 `ping` 扫描来识别网络上的机器。此脚本可以生成我选择的任何格式的预定义IP地址列表。
- en: The IPs can then be fed into other utility scripts that perform tasks with each
    machine. This script can be converted into a reusable library and integrated into
    a variety of situations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将这些IP地址输入到其他执行与每台机器相关任务的实用脚本中。此脚本可以被转换成一个可重用的库，并集成到各种场景中。
- en: The Code
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` class IP ![](../Images/00002.jpg)     def initialize(ip)          @ip = ip
         end       def to_s          @ip      end       def==(other)          to_s==other.to_s
         end  ![](../Images/00003.jpg)     def succ          return @ip if @ip ==
    "255.255.255.255"          parts = @ip.split(''.'').reverse ![](../Images/00004.jpg)  
          parts.each_with_index do |part,i|              if part.to_i < 255       
              part.succ!                  break ![](../Images/00005.jpg)          
      elsif part == "255"                  part.replace("0") unless i == 3       
          else                  raise ArgumentError, "Invalid number #{part} in IP
    address"              end          end ![](../Images/00006.jpg)         parts.reverse.join(''.'')
         end  ![](../Images/00007.jpg)     def succ!          @ip.replace(succ)   
      end  end  ![](../Images/00008.jpg) print "Input Starting IP Address: "  start_ip
    = gets.strip   print "Input Ending IP Address: "  end_ip = gets.strip  ![](../Images/00009.jpg) i
    = IP.new(start_ip)  ![](../Images/00011.jpg) ofile = File.open("ips.txt", "w")
    ![](../Images/00012.jpg) ofile.puts i.succ! until i == end_ip  ofile.close`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '` class IP ![](../Images/00002.jpg)     def initialize(ip)          @ip = ip
         end       def to_s          @ip      end       def==(other)          to_s==other.to_s
         end  ![](../Images/00003.jpg)     def succ          return @ip if @ip ==
    "255.255.255.255"          parts = @ip.split(''.'').reverse ![](../Images/00004.jpg)  
          parts.each_with_index do |part,i|              if part.to_i < 255       
              part.succ!                  break ![](../Images/00005.jpg)          
      elsif part == "255"                  part.replace("0") unless i == 3       
          else                  raise ArgumentError, "Invalid number #{part} in IP
    address"              end          end ![](../Images/00006.jpg)         parts.reverse.join(''.'')
         end  ![](../Images/00007.jpg)     def succ!          @ip.replace(succ)   
      end  end  ![](../Images/00008.jpg) print "Input Starting IP Address: "  start_ip
    = gets.strip   print "Input Ending IP Address: "  end_ip = gets.strip  ![](../Images/00009.jpg) i
    = IP.new(start_ip)  ![](../Images/00011.jpg) ofile = File.open("ips.txt", "w")
    ![](../Images/00012.jpg) ofile.puts i.succ! until i == end_ip  ofile.close`'
- en: Running the Code
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '``**`ruby ipAdderGen.rb`**``'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby ipAdderGen.rb`**``'
- en: 'It will then prompt you to submit a range of IP addresses:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将提示你提交IP地址范围：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output will be in a text file with one IP address per line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个文本文件，每行包含一个IP地址。
- en: The Results
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'After the script has been executed successfully, look for a text file called
    *ips.txt*. As expected, the output will be:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本成功执行后，查找名为 *ips.txt* 的文本文件。正如预期的那样，输出将是：
- en: '`192.168.0.1 192.168.0.2 192.168.0.3 192.168.0.4 192.168.0.5 192.168.0.6 192.168.0.7
    192.168.0.8 192.168.0.9 192.168.0.10 192.168.0.11 192.168.0.12 192.168.0.13 192.168.0.14
    192.168.0.15 192.168.0.16 192.168.0.17 192.168.0.18 192.168.0.19 192.168.0.20`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.1 192.168.0.2 192.168.0.3 192.168.0.4 192.168.0.5 192.168.0.6 192.168.0.7
    192.168.0.8 192.168.0.9 192.168.0.10 192.168.0.11 192.168.0.12 192.168.0.13 192.168.0.14
    192.168.0.15 192.168.0.16 192.168.0.17 192.168.0.18 192.168.0.19 192.168.0.20`'
- en: How It Works
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: This script has no arguments or options. The script asks the user for two IP
    addresses ![](../Images/00008.jpg). One is the start of the IP range, and the
    second is the end of it. Next, a new `IP` object is created using the defined
    `IP` class called `i` ![](../Images/00009.jpg). The final step before generating
    the IPs is to initialize the file the IP addresses will be written to, named `ofile`
    ![](../Images/00011.jpg). Now the fun begins.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本没有参数或选项。脚本会要求用户输入两个 IP 地址 ![图片](../Images/00008.jpg)。一个是 IP 范围的开始，另一个是结束。接下来，使用定义的
    `IP` 类创建一个新的 `IP` 对象，名为 `i` ![图片](../Images/00009.jpg)。在生成 IP 地址之前的最后一步是初始化将要写入
    IP 地址的文件，命名为 `ofile` ![图片](../Images/00011.jpg)。现在，有趣的部分开始了。
- en: For each item returned, the results will be output to `ofile`. Using the `IP`
    class method `succ!`, an until loop calls the `succ!` method until `i` equals
    `end_ip` ![](../Images/00012.jpg). Once the two values are equal, that means the
    ending IP address has been generated and the output file is closed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回的每个项目，结果将被输出到 `ofile`。使用 `IP` 类的 `succ!` 方法，一个 until 循环调用 `succ!` 方法，直到
    `i` 等于 `end_ip` ![图片](../Images/00012.jpg)。一旦这两个值相等，这意味着已生成结束 IP 地址，并且输出文件被关闭。
- en: 'The script relies on a custom class called `IP`, which has four methods: `initialize`,
    `to_s`, `succ`, and `succ!`. The `IP` class is important because, once an object
    is created, the IP address is stored as a class variable for easy tracking. The
    first method called, when `i` is declared, is `initialize`. This sets `@ip` to
    `start_ip` ![](../Images/00002.jpg). Next, `succ!` is called to begin creating
    the range of IPs. `succ!` calls `succ` and utilizes the `replace` method to overwrite
    the contents in `@ip` whenever `succ` returns a value ![](../Images/00007.jpg).
    The meat of the `IP` class is located in the method `succ` ![](../Images/00003.jpg).
    If `@ip` ever increments to the highest IP address, the script will return `255.255.255.255`.
    IP addresses can only go up to that value.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本依赖于一个名为 `IP` 的自定义类，它有四个方法：`initialize`、`to_s`、`succ` 和 `succ!`。`IP` 类很重要，因为一旦创建了一个对象，IP
    地址就被存储为类变量，以便于跟踪。当声明 `i` 时，首先调用的方法是 `initialize`。这会将 `@ip` 设置为 `start_ip` ![图片](../Images/00002.jpg)。接下来，调用
    `succ!` 以开始创建 IP 地址的范围。`succ!` 调用 `succ` 并使用 `replace` 方法在 `succ` 返回值时覆盖 `@ip`
    中的内容 ![图片](../Images/00007.jpg)。`IP` 类的核心位于 `succ` 方法 ![图片](../Images/00003.jpg)。如果
    `@ip` 增加到最高的 IP 地址，脚本将返回 `255.255.255.255`。IP 地址只能达到那个值。
- en: Next, the IP address, stored in `@ip`, is split apart in reverse order, using
    the period as a delimiter. The values are stored in an array called `parts`. After
    the IP address is properly separated, a new code block is called on the array
    using the `each_with_index` method to access two pieces of information—the index
    being passed and the value ![](../Images/00004.jpg). Within this block, the value
    in `part` is compared against 255, again to prohibit invalid IP addresses. If
    the value is equal to 255, then it is reset to zero ![](../Images/00005.jpg).
    The one exception to the zero reset is if the value of `i` is equal to 3, since
    that is the first octet of the IP. If `part` is less than 255, the method `succ!`
    is called and the `if/else` statement breaks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，存储在 `@ip` 中的 IP 地址以反向顺序分割，使用点作为分隔符。这些值存储在一个名为 `parts` 的数组中。在 IP 地址被正确分割后，使用
    `each_with_index` 方法调用数组上的新代码块来访问两块信息——传递的索引和值 ![图片](../Images/00004.jpg)。在这个块中，`part`
    中的值与 255 进行比较，再次以防止无效的 IP 地址。如果值等于 255，则将其重置为零 ![图片](../Images/00005.jpg)。唯一的例外是当
    `i` 的值为 3 时，因为那是 IP 的第一个八位字节。如果 `part` 小于 255，则调用 `succ!` 方法，并且 `if/else` 语句中断。
- en: After each part has been run through the code block, the IP address is put back
    together opposite of how it was taken apart. The script puts each piece back together
    using the `join` method, with periods in between the elements, all in reverse
    order ![](../Images/00006.jpg). As mentioned previously, the `succ!` method is
    called until the `end_ip` address is equal to the results of `succ!`. That's all
    there is to perfectly generating an IP address range.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个部分通过代码块运行后，IP 地址将按照拆分它的相反顺序重新组合。脚本使用 `join` 方法将每个部分重新组合起来，元素之间用点分隔，所有这些都在反向顺序中
    ![图片](../Images/00006.jpg)。如前所述，调用 `succ!` 方法，直到 `end_ip` 地址等于 `succ!` 的结果。这就是完美生成
    IP 地址范围的全部内容。
- en: Subnet Calculator
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网计算器
- en: Subnet Calculator
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网计算器
- en: subnetCalc.rb
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: subnetCalc.rb
- en: IP space is not infinite, so network administrators must be cognizant of how
    they allocate IP addresses. One way to segment a network is through the use of
    subnet masks, or *Classless Inter-Domain Routing*. In order to properly calculate
    *subnetworks*, or *subnets*, you need a few pieces of information. If you don't
    already know how to calculate subnets, then hopefully this script will enlighten
    you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址空间不是无限的，因此网络管理员必须意识到他们如何分配IP地址。一种通过使用子网掩码或*无类别域间路由*来分割网络的方法。为了正确计算*子网*或*子网掩码*，您需要一些信息。如果您不知道如何计算子网，那么希望这个脚本能给您带来启发。
- en: You can calculate the subnets by hand, but that can be time consuming, and converting
    from decimal to binary and then back to decimal again gets old after many repetitions.
    This script solves the problems of having to memorize subnet calculations. As
    long as you have the information available to input into the script, sit back
    and relax … your day just became that much easier.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动计算子网，但这可能很耗时，而且经过多次重复后，从十进制到二进制再回到十进制的转换会变得很繁琐。此脚本解决了必须记住子网计算的问题。只要您有可供脚本输入的信息，就可以放松一下……您的一天因此变得更加轻松。
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*This example is based on IPv4 addressing*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*本例基于IPv4地址*。'
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The Code
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''ipaddr''   begin      print "Enter the
    IP address: " ![](../Images/00003.jpg)     ip = IPAddr.new gets.chomp       print
    "Enter the Subnet mask: " ![](../Images/00004.jpg)     subnet_mask = IPAddr.new
    gets.chomp  ![](../Images/00005.jpg) rescue Exception => e      puts "An error
    occurred: #{e}\n\n"  end  ![](../Images/00006.jpg) subnet = ip.mask(subnet_mask.to_s)   puts
    "Subnet address is: #{subnet}\n\n"`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''ipaddr''   begin      print "Enter the
    IP address: " ![](../Images/00003.jpg)     ip = IPAddr.new gets.chomp       print
    "Enter the Subnet mask: " ![](../Images/00004.jpg)     subnet_mask = IPAddr.new
    gets.chomp  ![](../Images/00005.jpg) rescue Exception => e      puts "An error
    occurred: #{e}\n\n"  end  ![](../Images/00006.jpg) subnet = ip.mask(subnet_mask.to_s)   puts
    "Subnet address is: #{subnet}\n\n"`'
- en: Running the Code
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script is completely interactive and will guide you through the process
    of creating subnets. Just use the following command to run it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本完全交互式，会引导您完成创建子网的过程。只需使用以下命令来运行它：
- en: '``**`ruby subnetCalc.rb`**``'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby subnetCalc.rb`**``'
- en: The Results
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`Enter the IP address: 192.168.1.130 Enter the Subnet mask: 255.255.255.192
    Subnet address is: 192.168.1.128`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enter the IP address: 192.168.1.130 Enter the Subnet mask: 255.255.255.192
    Subnet address is: 192.168.1.128`'
- en: How It Works
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: To begin, the script requires the ipaddr library ![](../Images/00002.jpg), which
    is useful when working with Internet Protocol addresses. Not only does it have
    a predefined IP address data structure, but the library also includes methods
    to manipulate IPv4 and IPv6 addresses. The first part of computing a subnet address
    is defining the IP address. The user is prompted for the address, which is saved
    into `ip` ![](../Images/00003.jpg).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本需要ipaddr库 ![](../Images/00002.jpg)，这在处理互联网协议地址时非常有用。该库不仅包含预定义的IP地址数据结构，还包括用于操作IPv4和IPv6地址的方法。计算子网地址的第一步是定义IP地址。用户会被提示输入地址，该地址将被保存到`ip`
    ![](../Images/00003.jpg)。
- en: Relying on the `IPAddr` data structure, I initialized a `begin/rescue` block,
    in case there are any issues with the IP address, such as an address out of bounds.
    As a side note, I could have used a regular expression to check for IP address
    integrity, but the regular expression is quite lengthy. If an error is detected,
    the `rescue` clause catches it and outputs the specific culprit ![](../Images/00005.jpg).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`IPAddr`数据结构，我初始化了一个`begin/rescue`块，以防IP地址有任何问题，例如地址超出范围。顺便说一句，我本可以使用正则表达式来检查IP地址的完整性，但正则表达式相当长。如果检测到错误，`rescue`子句会捕获它并输出具体的错误原因
    ![](../Images/00005.jpg)。
- en: The second piece needed to calculate a subnet address is the subnet mask ![](../Images/00004.jpg).
    Next, the IP address and subnet mask are converted into decimal numbers so the
    binary arithmetic operation `AND` can be performed on the two addresses. The resulting
    binary address is converted back into decimal and is the final subnet address.
    As you will see in a moment, the `mask` method of the ipaddr library abstracts
    all of the mathematical operations, making subnet address calculations simple.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 计算子网地址所需的第二项是子网掩码 ![](../Images/00004.jpg)。接下来，将IP地址和子网掩码转换为十进制数字，以便在两个地址上执行二进制算术运算`AND`。得到的二进制地址转换回十进制，就是最终的子网地址。您很快就会看到，ipaddr库的`mask`方法抽象了所有的数学运算，使得子网地址计算变得简单。
- en: If both addresses pass inspection from the ipaddr library, the `mask` method
    is called ![](../Images/00006.jpg). The `mask` method expects a string object
    passed as the subnet mask address, so the `to_s` method is used to convert the
    `IPAddr` object. Finally, `mask` returns the subnet address, which is then displayed
    to the user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个地址都通过了ipaddr库的检查，则会调用`mask`方法 ![mask方法](../Images/00006.jpg)。`mask`方法期望传入一个字符串对象作为子网掩码地址，因此使用了`to_s`方法将`IPAddr`对象转换为字符串。最后，`mask`方法返回子网地址，然后将其显示给用户。
- en: Hacking the Script
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: You could easily convert this script to handle IPv6 addresses as well as IPv4
    addresses. I used the ipaddr library method `mask` to accomplish the binary `AND`
    function, but you could also perform the calculations explicitly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地将此脚本转换为同时处理IPv6地址和IPv4地址。我使用了ipaddr库的`mask`方法来实现二进制的`AND`操作，但您也可以显式地进行计算。
