- en: Chapter 2. WEBSITE SCRIPTING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![WEBSITE SCRIPTING](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Ruby and the Web go together. The Internet and the World Wide Web provide so
    much information that finding specific bits of that information can be overwhelming.
    Popular search engines have made crawling the Web more manageable, but these search
    engines lack customization. If you were to write your own script, it would be
    possible to customize every aspect of what information to gather and how to present
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you''ve heard of Ruby, then chances are you''ve heard about Ruby on Rails.
    This book doesn''t address Rails, as Ruby alone is a powerful tool for exploiting
    the Web. But if you''d like to explore web application development using Ruby,
    you should definitely check out the Rails framework* ([http://www.rubyonrails.org/](http://www.rubyonrails.org/)).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Web Page Link Validator
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Page Link Validator
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: linkValidator.rb
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of this script is to validate all the links on a web page. Checking
    link validity is important for several reasons. First, as a viewer, encountering
    broken links is very frustrating. Second, valid links make a site more professional.
    Finally, if your website contains a link to someone else's site and they move
    or remove a page, you have no way of knowing without specifically checking.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Without automating this task, a person would have to literally click each link
    to prove the paths were valid. Extremely small sites are easy to validate, but
    sites with many links are tedious and time consuming. This is an example of a
    task that, when done manually, could take several hours. With the use of some
    Ruby tricks, you can cut that time down to 10 seconds! Writing the script will
    take a little time, but it's reusable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''uri''  require ''open-uri''  require ''rubyful_soup''   begin   
      print "\n\nEnter website to crawl (ex. http://www.google.com): "      url =
    gets      puts url      uri = URI.parse(url) ![](../Images/00002.jpg) html = open(uri).read
    ![](../Images/00003.jpg) rescue Exception => e ![](../Images/00004.jpg)      print
    "Unable to connect to the url:"       puts "ERROR ----  #{e}"   end   soup = BeautifulSoup.new(html)  ![](../Images/00005.jpg) links
    = soup.find_all(''a'').map { |a| a[''href''] }  ![](../Images/00006.jpg) links.delete_if
    { |href| href =~ /javascript|mailto/ }  ![](../Images/00007.jpg) links.each do
    |l|      if l          begin              link = URI.parse(l)              link.scheme
    ||= ''http''              link.host ||= uri.host              link.path = uri.path
    + link.path unless link.path[0] == //              link = URI.parse(link.to_s)    
              open(link).read          rescue Exception => e              puts "#{link}
    failed because #{e}"          end      end  end`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will validate the links on any given website by first launching the script
    like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby linkValidator.rb`**``'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The script will present you with a prompt to enter the website you want to crawl.
    You need to enter the site with a full URL address (for example, [http://www.nostarch.com/](http://www.nostarch.com/)).
    From there, the script will list the links it had trouble accessing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a test, I ran the script against a website that shall go nameless, and the
    results are below.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '``Enter website to crawl (ex. http://www.google.com): *`http://www.url.com`*
    http://www.url.com/products/specials.html failed because 403 Forbidden``'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The site contained about 50 links. Each link was validated except for one, *specials.html*.
    As you can see from the error reported, the reason the specials page was not accessible
    was due to "403 Forbidden." This happened because the site owner didn't want to
    release the specials page for public viewing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For starters, we need to talk about HTML manipulation and interfacing with websites.
    Ruby has several ways of accessing the Web, but the simplest to use, by far, is
    open_uri. If you are familiar with `wget`, then getting to know open_uri should
    be easy; with my wicked little gems, I'm halfway to scraping web pages. For Internet
    scraping activities, I typically use rubyful_soup, an HTML/XML parser for Ruby,
    in combination with uri and open_uri. The rubyful_soup gem can be installed like
    any of the other gems used throughout the book. As you follow the examples in
    the book, you will see just how powerful rubyful_soup can be.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The script begins with some error handling in case the user mistakenly enters
    a bad URL or a connection cannot be made to the root directory of the web address
    ![](../Images/00003.jpg). Either way, the user will get more than one chance to
    correct his errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: After the URL has been entered, it is parsed using the uri library. The URL
    you provide is opened using the `open(uri).read` command ![](../Images/00002.jpg).
    This single line opens the URL and reads in all of the HTML source code. Pretty
    cool, huh? Did you ever think scraping a web page would be so easy?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If there are any issues navigating to your URL, the script will show you the
    error and print the specific error message ![](../Images/00004.jpg). Now on to
    the fun part, where rubyful_soup shows its power.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A new batch of rubyful_soup is made by initializing the `BeautifulSoup` and
    passing in our HTML source code. The soup allows us to easily parse the HTML source
    code. Sure, you could write a fancy regular expression or check each line for
    an `HREF`, but this feature is already supported by the soup! Just tell the soup
    to find all of the links in the source and save them to our array entitled `links`
    ![](../Images/00005.jpg). One thing we want to remove is `javascript` and `mailto`
    links because these will make the parsers unhappy when they start testing link
    validity ![](../Images/00006.jpg). Once the links are cleaned up, the script starts
    to iterate through each one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Because we are checking for the validity of each link, what we are really checking
    for is any link that throws an error. If no errors are thrown, we know for certain
    that the link is valid. To interpret the output, we use a little more error-handling-fu
    and start checking each link ![](../Images/00007.jpg). If the links are valid,
    the script will move on. If a link is bad, it will be logged. In this script,
    I have chosen to output the bad links to the command prompt, but you can hack
    the script to output to a text file or whatever you want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another hack for this script would be to crawl the valid links that are found
    in the initial root domain. You can limit the crawler by specifying a link depth
    at which to crawl. This would allow you to crawl every link on an entire site.
    If the site isn't your own, you'd probably also want to add a delay between page
    fetches so that you wouldn't bog down the server. You could also incorporate HTTPS
    support using open_uri.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If there is a particular site you wish to crawl, you can hard-code the address
    into the script so you won't have to keep typing it. This is a great foundational
    script for more Internet scraping.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Orphan File Checker
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Orphan File Checker
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: orphanCheck.rb
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will be looking at the inverse of invalid link files—I will
    show you how to find files that are not linked at all. *An orphan file* is any
    file on a web server that has lost its link. Not only do these files waste space,
    they also have the potential to confuse web page administrators with superfluous
    files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: I am what some may call a neat freak. I like to have things in order, just the
    way I like them. I despise clutter and wasted space. I treat my computer systems
    the same way, so I prefer to keep only the files that I need. If you have ever
    made a lot of changes or upgrades, or if you have had to share a system with other
    people, then you know how chaotic and disorganized filesystems can become. The
    orphan file checker script is unique because it gives you information that solves
    two problems. The first problem is finding out which files are not accessible
    on your web server. Secondly, the script allows you to see the files that are
    being listed that should not be. Obviously, some files are not meant to have a
    link, but you should know which ones those are before you run this script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) links = Array.new  orphans = Array.new  dir_array
    = [Dir.getwd]  ![](../Images/00003.jpg) unless File.readable?("links.txt")   
      puts "File is not readable."      exit  end   File.open(''links.txt'', ''rb'')
    do |lv|      lv.each_line do |line|          links << line.chomp      end  end   begin
         p = dir_array.shift      Dir.chdir(p)       Dir.foreach(p) do |filename|
             next if filename == ''.'' or filename == ''..''          if !File::directory?(filename)
    ![](../Images/00004.jpg)                orphans << p + File::SEPARATOR + filename
             else              dir_array << p + File::SEPARATOR + filename       
      end      end  end while !dir_array.empty?  ![](../Images/00005.jpg) orphans
    -= links   File.open("orphans.txt", "wb") do |o| ![](../Images/00006.jpg)    
      o.puts orphans  end`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the script, you must have already created a file called *links.txt*
    that contains a list of all the hyperlinks on a website. This list can be accomplished
    using a modified version of "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055),
    or one of your own scripts. The format is a single file, with the full path on
    each line. The file I used for this example was based on a web page used to track
    a few of my Ruby web scripts; it looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '`/ruby/scripts/website_scripting\index.html /ruby/scripts/website_scripting\orphanCheck.rb
    /ruby/scripts/website_scripting\rssParser.rb /ruby/scripts/website_scripting\ipAdderGen.rb
    /ruby/scripts/website_scripting\formGenerator.rb`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The script does all of the work; you just have to type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby orphanCheck.rb`**``'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Now sit back, relax, and wait for the script to write *orphans.txt*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The results of this script will be in a file called *orphans.txt*. The file
    will contain a complete path for each file that does not have a listing in *links.txt*.
    As you recall, the *links.txt* file contains a list of all files found on your
    website. Here''s an example *orphans.txt* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`/ruby/scripts/website_scripting\form.html /ruby/scripts/website_scripting\linkValidator.rb
    /ruby/scripts/website_scripting\subnetting.rb /ruby/scripts/website_scripting\historicalStockParse.rb
    /ruby/scripts/website_scripting\links.txt`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: These are the files that were found on the web server that were not in the *links.txt*
    file. If I wanted to share these files with the world, then I would have `<a href="link">`
    tags for them on my web page. But if these orphaned files were still in the works
    and not ready for public viewing, then there wouldn't be any issue (which was
    the case here).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script does not use any outside libraries, thus keeping its execution simple.
    I start by initializing the arrays that I'll be using to keep track of my links
    and orphan files ![](../Images/00002.jpg). Next, I look to ensure that my *links.txt*
    file exists. If not, then there isn't much point in continuing to run the script,
    so it exits out with a nice error message ![](../Images/00003.jpg). If *links.txt*
    does exist, then we continue by opening the file and reading in all of the contents
    line-by-line. You can change this to a *comma-separated values (CSV)* file, but
    I prefer the readability of one link per line.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: After the links have been stored in the array `links`, the script begins to
    index every file in the current working directory. The results will be stored
    in an array called `orphans` ![](../Images/00004.jpg). If there are subdirectories,
    the script will also index those files. Presumably, you would run this in the
    root directory of your web server to take full advantage of this script.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now that the script has both the links and local files indexed, it is time to
    start comparing the two arrays, and see what's left ![](../Images/00005.jpg).
    I called the second array `orphans` because I will be deleting any entry that
    exists within the `link` array. Whatever is left will be files not included on
    the public-facing side of the web server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The script ends by creating a file called *orphans.txt* in the script's directory
    and writing the results to that file ![](../Images/00006.jpg). Finally, after
    the code block is finished, the file is closed and the script finished.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Form Generator
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form Generator
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: formGenerator.rb
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When forms first came onto the HTML scene, they were underutilized tools. Now
    you can go to practically any site and find a form with one of those cool little
    submission buttons at the bottom. Google returns a whopping 60,000,000 results
    for a *submit button* search. Needless to say, web forms have become part of our
    digital lives. Forms can gather many different types of information. They can
    also anonymize a recipient's email address. If your email address is published
    on a website and an email harvester collects it, you can expect to be receiving
    a lot of spam. If you use a form on your site, your email remains hidden from
    users (and robots), but you can still receive email from your site's users. Also,
    forms allow users to communicate without a need for their own *Simple Mail Transfer
    Protocol (SMTP)* server or email service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Forms are simple and flexible. If you want to receive customer feedback, create
    a form. If you want to conduct a survey, create a form. You get the idea.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing how to create them is a good skill to have, but an even cooler skill
    is knowing how to create them automatically! With this script, you can build forms
    on the fly or create form templates. Creating web forms is no big deal. As you
    experiment with this script, you will generate numerous form files. If you don''t
    feel like tracking each file, then use script #11, Orphan File Checker (see [Hacking
    the Script](../Text/dummy_split_080.html#filepos203147)), to clean up your mess.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`require ''cgi''  ![](../Images/00002.jpg) cgi = CGI.new("html4Tr")  ![](../Images/00003.jpg) print
    "Enter Form Page Title: "  title = gets.chomp  print "Enter Head Title: "  input_title
    = gets.chomp  print "Enter value for button: "  value = gets.chomp  print "Enter
    group: "  group = gets.chomp  ![](../Images/00004.jpg) $stdout = File.new("form.html","w")
     cgi.out{      CGI.pretty(          cgi.html{  ![](../Images/00005.jpg)      
                 cgi.head{ "\n"+cgi.title{title}}+                  cgi.body{"\n"
    +                      cgi.form{"\n" +                      cgi.hr +         
                cgi.h1 { "#{input_title}:" } + "\n" +                      cgi.br
    +                      cgi.checkbox(group, value) + value + cgi.br +         
                cgi.br +                      cgi.textarea("input",80,5) + "\n" +
                         cgi.br +                      cgi.submit("Send")         
                }                  }           }     )  }   $stdout.close`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script takes user input to create the HTML form. Execute the script like
    any other, and follow its lead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Contents *of form.html*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`Content-Type: text/html Content-Length: 724  <!DOCTYPE HTML PUBLIC "-//W3C//DTD
    HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <HTML>   <HEAD>
        <TITLE>       No Starch Press | Errata Submissions     </TITLE>   </HEAD>
      <BODY>      <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">
          <HR>       <H1>         Wicked Cool Ruby Scripts -- Errata Submissions:
          </H1>       <BR>       <INPUT NAME="Bad Errata Submissions" TYPE="checkbox"
    VALUE="High Priority">       Super Critical!!!       <BR>       <TEXTAREA NAME="input"
    ROWS="5" COLS="80">       </TEXTAREA>       <BR>       <INPUT TYPE="submit" VALUE="Send">
        </FORM>   </BODY> </HTML>`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: See it in action in [Figure 2-1](#filepos223333).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![The resulting form, as seen in a web browser](../Images/00010.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1. The resulting form, as seen in a web browser
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The form generation script uses the cgi library, so it is included in the `require`
    statement. I created a new document and specified that the HTML 4.0 Transitional
    version methods be used for generating my code by using `html4Tr` as the argument
    ![](../Images/00002.jpg). The other options are `html3` (HTML 3.*x*), `html4`
    (HTML 4.*x*), or `html4Fr` (HTML 4.0 with Framesets). After the cgi methods have
    been set up, the script requests information from the user ![](../Images/00003.jpg).
    This script creates a submission form with one checkbox and a text box. The example
    is a form developed for errata submissions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The header of the form is requested first, followed by the title of the web
    form. Next, the value of the checkbox is presented. In this example, I gave the
    user an option of submitting the value `High Priority`, to demonstrate the checkbox
    options. Checkboxes are useful when you are looking for information that must
    be a specific choice; for example, dinner choices—`chicken` or `beef`. Finally,
    I added a text box to allow the user to detail any errors she may have found.
    Once the information is collected, the script will go to work writing a slick
    HTML form.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Two important lines of code are included in the redirection of standard output
    ![](../Images/00004.jpg). `$stdout` is redirected to a new file called *form.html*,
    and it will capture the HTML form. The cgi method `out` is called to prepare the
    file for the creation of HTML code. Then the `pretty` method is used; although
    not necessary, it cleans up the HTML code so it resembles something you can easily
    read, with proper line spacing and indentations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `HTML` method then begins constructing each piece of our form. First comes
    the head, which we specified earlier; next is the body, with each part of the
    form ![](../Images/00005.jpg). Last, and most importantly, is the submission button,
    which I appropriately named Send. To clean up our open file, we close it and exit
    the script. Our shiny new HTML form is ready for use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of this script is in how simple writing HTML code becomes. You can
    explore the cgi library further to incorporate radio buttons, multiple groups,
    and other elements of a form. You can make this script even more flexible by specifying
    how many groups are needed and how many options should be in each group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: RSS Parsing
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RSS Parsing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: rssParser.rb
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Really Simple Syndication (RSS)* is a wonderful technology that has been gaining
    popularity since early 2000\. RSS feeds allow users to stay current on information
    that frequently changes, such as news headlines or product announcements. Many
    websites feature RSS feeds, and a feed reader is needed to extract the important
    data included in the feed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Distribution can extend the functionality and interoperability of information.
    Ruby has a library which allows you to customize the way feeds are retrieved,
    published, aggregated, and manipulated. This script will allow you to retrieve
    information from No Starch's blog at [http://nostarch.com/blog/?feed=rss2/](http://nostarch.com/blog/?feed=rss2/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''rss/1.0''  require ''rss/2.0''  require ''open-uri''  ![](../Images/00002.jpg) source
    = "http://nostarch.com/blog/?feed=rss2" # location of rss feed  content = ""  ![](../Images/00003.jpg) open(source)
    do |info|      content = info.read  end  ![](../Images/00004.jpg) rss = RSS::Parser.parse(content,
    false)   print "Do you want to see feed descriptions (y/n)? "    input = gets.chomp   desc
    = input == ''y'' || input == ''Y''   puts "\n\nTITLE: #{rss.channel.title}"  puts
    "DESCRIPTION: #{rss.channel.description}"  puts "LINK: #{rss.channel.link}"  puts
    "PUBLICATION DATE: #{rss.channel.date} \n\n"  ![](../Images/00005.jpg) rss.items.size.times
    do |i|      puts "#{rss.items[i].date} ... #{rss.items[i].title}"      if desc
             print "#{rss.items[i].description}\n\n\n"      end  end`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby rssParser.rb`**``'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The script will then ask if you would like to see the feed descriptions along
    with the titles. Enter `yes` or `no`. If you input `no`, the script will display
    only the titles from each entry.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the descriptions turned off:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`TITLE: The No Starch Press Blog DESCRIPTION: With more stuff, less fluff LINK:
    http://nostarch.com/blog PUBLICATION DATE: Thu, 07 Aug 2008 13:42:08 -0400  Thu,
    07 Aug 2008 13:42:08 -0400 ... Good eats in Vegas Tue, 29 Jul 2008 22:44:17 -0400
    ... Boolean Operator Thu, 10 Jul 2008 03:18:18 -0400 ... Windows Upgrade Hell
    Sat, 05 Jul 2008 02:47:27 -0400 ... Problems brewing at Google? Thu, 03 Jul 2008
    15:35:30 -0400 ... Nick Hornby on eBooks Tue, 17 Jun 2008 17:37:15 -0400 ... Happy
    Download Day! Tue, 17 Jun 2008 14:22:08 -0400 ... How to Write a Book Mon, 16
    Jun 2008 19:08:22 -0400 ... Monday Afternoon Linkfest Mon, 02 Jun 2008 04:36:47
    -0400 ... Is blogging boring? Wed, 21 May 2008 05:15:18 -0400 ... Giant LEGO Boulder`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'With the descriptions left on:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`TITLE: more stuff, less fluff DESCRIPTION: the only blog with no starch LINK:
    http://nostarch.com/blog PUBLICATION DATE: Thu, 07 Aug 2008 13:42:08 -0400  Thu,
    07 Aug 2008 13:42:08 -0400 ... Good eats in Vegas It''s DEFCON time and that means
    Vegas. And as tempting as the $1.99 buffet might be, maybe you''ve had all the
    cheap steak you want for the day. Check out Bill''s restaurant map for other ideas.
    There''s a wide range represented, from Himalayan cuisine to good ol'' American
    food. If you''ve been to any of [...]  Tue, 29 Jul 2008 22:44:17 -0400 ... Boolean
    Operator The search performed by Monica Goodling while ''vetting'' candidates
    for positions within the Department of Justice: [First name of a candidate]! and
    pre/2 [last name of a candidate] w/7 bush or gore or republican! or democrat!
    or charg! or accus! or criticiz! or blam! or defend! or iran contra or clinton
    or spotted owl or florida [...]  Thu, 10 Jul 2008 03:18:18 -0400 ... Windows Upgrade
    Hell Unfortunately, many of us here still use Windows. (I use Ubuntu almost exclusively
    now, except when I''m fixing Windows.) And, even more unfortunately, when it''s
    time for that inevitable Windows problem, I often end up having to fix it. Tonight
    I chose to upgrade one of our XP machines to XP Pro. You''d figure that would
    [...]  ---[snip]---`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, this script is fairly straightforward. The script starts off identifying
    the source of the RSS feed ![](../Images/00002.jpg). This can be either a live
    website or a local file, but it must be in RSS format. Next, we initialize the
    variable content and proceed to read in all of the information from our source
    file—in this case, the source file is No Starch's blog ![](../Images/00003.jpg).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: After the raw data is saved in the variable content, the RSS parser begins working
    its magic. The parser will parse the RSS feed into its specific format and save
    the resulting data into a variable called `rss` ![](../Images/00004.jpg). The
    variable `rss` has a lot of properties available for manipulation, so feel free
    to dig in and see what other information you can glean from it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Now that the hard part is out of the way, I decide what information will be
    presented to the user. The main information I was interested in looking at was
    dates, titles, and possibly descriptions. This way I can skim a feed for anything
    that might interest me further. The descriptions on some RSS feeds can be lengthy
    and take up a lot of space. I gave myself the option of seeing the descriptions,
    if I really needed to ![](../Images/00005.jpg). As you can see above, the output
    without lengthy descriptions is much easier to process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested in specific topics, you can incorporate a search function
    to look for particular key terms in the title of RSS entries or even in the descriptions
    themselves. Another idea is to use this script to comb several feeds, look for
    similar articles, and aggregate them for easy access. You may recall the date
    property; you can filter the results based on the date the entry was put into
    the feed. For instance, if you are looking for entries within the last week, you
    can write a conditional statement to only display the most recent information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Stock Exchange Grep
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stock Exchange Grep
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: stockGrep.rb
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stocks are awesome! I love investing in companies and watching them as they
    grow and develop into industry leaders. And watching a catastrophic failure is
    pretty interesting, too. The stock market is fascinating and complex, and many
    people spend their entire lives trying to understand it. I don't try to play the
    game or understand it; I just observe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: But, whenever I see a stock that I think has promise, I like to keep an eye
    on it. I could watch the stocks through a web service or turn on the TV, but that's
    not fast enough for me. I like to get my information how, where, and when I want
    it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: This script allows me to retrieve different pieces of information about particular
    stocks and perform actions based on certain events. For instance, this script
    could be made to send a text message when a stock reaches a pre-defined level.
    It can also aggregate several stocks in the same industry for easier comparison.
    There is so much data available in the stock market— to have the ability to extract
    the important information is priceless. This script can be modified in many different
    ways, so read through it and let your imagination run wild.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''open-uri'' ![](../Images/00002.jpg) require ''csv''  ![](../Images/00003.jpg) def
    get_info stock_symbol      puts "#{stock_symbol} Current Ticker Information" ![](../Images/00004.jpg)  
      url = "http://download.finance.yahoo.com/d/  quotes.csv?s=#{stock_symbol}&f=sl1d1t1c1ohgv&e=.csv"
         puts "Connecting to #{url}\n\n\n"  ![](../Images/00005.jpg)      csv = CSV.parse(open(url).read)    
      csv.each do |row|          puts "--------------------------------------------------"
             puts "Information current as of #{row[3]} on #{row[2]}\n\n"         
    puts "#{row[0]}''s last trade was - $#{row[1]}  (increase of #{row[4]})\n\n"   
          puts "\tOpened at $#{row[5]}"          puts "\tRange for the day $#{row[7]}
    - $#{row[6]}"      end      puts "--------------------------------------------------"
     end    print "Enter stock symbol (separate by space if > 1): "  stock_symbols
    = gets.upcase  ![](../Images/00006.jpg) stock_symbols.split.each do |symbol|   
      get_info(symbol)  end`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the script is easy—you give it a ticker symbol, and it pulls the data.
    That''s it. Execute the script by entering the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby stockGrep.rb`**``'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You will then be prompted to enter the ticker symbols you want to look up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script can pull any information from Yahoo! Finance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any information available from Yahoo! Finance will be output at the command
    prompt. *StockGrep.rb* outputs standard stock information in a nice format. In
    this example, I searched for Aruba Networks, Inc., which is a company that delivers
    enterprise wireless solutions. The results were promising:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`ARUN Current Ticker Information Connecting to http://download.finance.yahoo.com/d/quotes.csv?s=ARUN&f=sl1d1t1c1ohgv&e=.csv  --------------------------------------------------  Information
    current as of 4:00pm on 6/1/2007  ARUN''s last trade was - $20.20  (increase of
    +0.85)      Opened at $19.35     Range for the day $19.34 - $20.73 --------------------------------------------------`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script begins by requiring the two libraries needed to provide full functionality
    to the script. We've already mentioned open_uri, which is the first library. For
    a reminder, see script "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055).
    The second library is csv, and it is capable of parsing comma-separated value
    files ![](../Images/00002.jpg). The returned object from Yahoo! will be a CSV
    file, as you will soon see.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Next, I define a short method that will be used to retrieve information from
    multiple ticker symbols ![](../Images/00003.jpg). If I wanted to limit the script
    to one ticker symbol at a time, this section could have been added right into
    the main body of the code. Within the method called `get_info`, the first step
    is to print the ticker symbol for the stock being analyzed. Then a custom URL
    is crafted in order to request the correct data from Yahoo! Finance ![](../Images/00004.jpg).
    Notice the `#{stock_symbol}` embedded within the URL; this is where the customization
    comes into play. When this URL is sent to Yahoo!, a comma-separated value file
    is sent back to the script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The variable `csv` will be used to hold any data parsed by the `CSV.parse()`
    method. Each element in a CSV file will be put into an array ![](../Images/00005.jpg).
    Yahoo!'s stock files contain the same fields, so there is no guesswork involved
    in what the output should be. The six `puts` lines simply display the information
    in a user-friendly manner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The last step of the script, which is actually the first to be executed, is
    to retrieve the stock symbols, then split them apart ![](../Images/00006.jpg).
    For each symbol that is split, the method `get_info` is called, as explained above.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Many websites continually change their products, so if the URL is no longer
    valid, you must find the new one. Updates to this script will be posted at* [http://www.nostarch.com/wcruby.htm/](http://www.nostarch.com/wcruby.htm/).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several modifications can make this script even more powerful. If you are interested
    in trend analysis, you can integrate historical data into this script or even
    have the script retrieve data and write the information to another file for further
    analysis.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth considering other trends you could track using a web scraper.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: IP Address Generation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP Address Generation
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ipAdderGen.rb
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever need to generate a range of IPs? I have found myself in several situations
    that called for just that, and I knew I didn't want to generate the list by hand.
    There isn't any magic involved, but the sheer usefulness of this script makes
    it noteworthy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Working with networks on a day-to-day basis means dealing with IP addresses.
    Sometimes a simple `ping` sweep is used to identify machines on a network. This
    script generates a pre-defined list of IPs in any format I choose.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The IPs can then be fed into other utility scripts that perform tasks with each
    machine. This script can be converted into a reusable library and integrated into
    a variety of situations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` class IP ![](../Images/00002.jpg)     def initialize(ip)          @ip = ip
         end       def to_s          @ip      end       def==(other)          to_s==other.to_s
         end  ![](../Images/00003.jpg)     def succ          return @ip if @ip ==
    "255.255.255.255"          parts = @ip.split(''.'').reverse ![](../Images/00004.jpg)  
          parts.each_with_index do |part,i|              if part.to_i < 255       
              part.succ!                  break ![](../Images/00005.jpg)          
      elsif part == "255"                  part.replace("0") unless i == 3       
          else                  raise ArgumentError, "Invalid number #{part} in IP
    address"              end          end ![](../Images/00006.jpg)         parts.reverse.join(''.'')
         end  ![](../Images/00007.jpg)     def succ!          @ip.replace(succ)   
      end  end  ![](../Images/00008.jpg) print "Input Starting IP Address: "  start_ip
    = gets.strip   print "Input Ending IP Address: "  end_ip = gets.strip  ![](../Images/00009.jpg) i
    = IP.new(start_ip)  ![](../Images/00011.jpg) ofile = File.open("ips.txt", "w")
    ![](../Images/00012.jpg) ofile.puts i.succ! until i == end_ip  ofile.close`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby ipAdderGen.rb`**``'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'It will then prompt you to submit a range of IP addresses:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output will be in a text file with one IP address per line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the script has been executed successfully, look for a text file called
    *ips.txt*. As expected, the output will be:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.1 192.168.0.2 192.168.0.3 192.168.0.4 192.168.0.5 192.168.0.6 192.168.0.7
    192.168.0.8 192.168.0.9 192.168.0.10 192.168.0.11 192.168.0.12 192.168.0.13 192.168.0.14
    192.168.0.15 192.168.0.16 192.168.0.17 192.168.0.18 192.168.0.19 192.168.0.20`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script has no arguments or options. The script asks the user for two IP
    addresses ![](../Images/00008.jpg). One is the start of the IP range, and the
    second is the end of it. Next, a new `IP` object is created using the defined
    `IP` class called `i` ![](../Images/00009.jpg). The final step before generating
    the IPs is to initialize the file the IP addresses will be written to, named `ofile`
    ![](../Images/00011.jpg). Now the fun begins.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: For each item returned, the results will be output to `ofile`. Using the `IP`
    class method `succ!`, an until loop calls the `succ!` method until `i` equals
    `end_ip` ![](../Images/00012.jpg). Once the two values are equal, that means the
    ending IP address has been generated and the output file is closed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The script relies on a custom class called `IP`, which has four methods: `initialize`,
    `to_s`, `succ`, and `succ!`. The `IP` class is important because, once an object
    is created, the IP address is stored as a class variable for easy tracking. The
    first method called, when `i` is declared, is `initialize`. This sets `@ip` to
    `start_ip` ![](../Images/00002.jpg). Next, `succ!` is called to begin creating
    the range of IPs. `succ!` calls `succ` and utilizes the `replace` method to overwrite
    the contents in `@ip` whenever `succ` returns a value ![](../Images/00007.jpg).
    The meat of the `IP` class is located in the method `succ` ![](../Images/00003.jpg).
    If `@ip` ever increments to the highest IP address, the script will return `255.255.255.255`.
    IP addresses can only go up to that value.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Next, the IP address, stored in `@ip`, is split apart in reverse order, using
    the period as a delimiter. The values are stored in an array called `parts`. After
    the IP address is properly separated, a new code block is called on the array
    using the `each_with_index` method to access two pieces of information—the index
    being passed and the value ![](../Images/00004.jpg). Within this block, the value
    in `part` is compared against 255, again to prohibit invalid IP addresses. If
    the value is equal to 255, then it is reset to zero ![](../Images/00005.jpg).
    The one exception to the zero reset is if the value of `i` is equal to 3, since
    that is the first octet of the IP. If `part` is less than 255, the method `succ!`
    is called and the `if/else` statement breaks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: After each part has been run through the code block, the IP address is put back
    together opposite of how it was taken apart. The script puts each piece back together
    using the `join` method, with periods in between the elements, all in reverse
    order ![](../Images/00006.jpg). As mentioned previously, the `succ!` method is
    called until the `end_ip` address is equal to the results of `succ!`. That's all
    there is to perfectly generating an IP address range.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Subnet Calculator
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subnet Calculator
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: subnetCalc.rb
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IP space is not infinite, so network administrators must be cognizant of how
    they allocate IP addresses. One way to segment a network is through the use of
    subnet masks, or *Classless Inter-Domain Routing*. In order to properly calculate
    *subnetworks*, or *subnets*, you need a few pieces of information. If you don't
    already know how to calculate subnets, then hopefully this script will enlighten
    you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You can calculate the subnets by hand, but that can be time consuming, and converting
    from decimal to binary and then back to decimal again gets old after many repetitions.
    This script solves the problems of having to memorize subnet calculations. As
    long as you have the information available to input into the script, sit back
    and relax … your day just became that much easier.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This example is based on IPv4 addressing*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''ipaddr''   begin      print "Enter the
    IP address: " ![](../Images/00003.jpg)     ip = IPAddr.new gets.chomp       print
    "Enter the Subnet mask: " ![](../Images/00004.jpg)     subnet_mask = IPAddr.new
    gets.chomp  ![](../Images/00005.jpg) rescue Exception => e      puts "An error
    occurred: #{e}\n\n"  end  ![](../Images/00006.jpg) subnet = ip.mask(subnet_mask.to_s)   puts
    "Subnet address is: #{subnet}\n\n"`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is completely interactive and will guide you through the process
    of creating subnets. Just use the following command to run it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby subnetCalc.rb`**``'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Enter the IP address: 192.168.1.130 Enter the Subnet mask: 255.255.255.192
    Subnet address is: 192.168.1.128`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin, the script requires the ipaddr library ![](../Images/00002.jpg), which
    is useful when working with Internet Protocol addresses. Not only does it have
    a predefined IP address data structure, but the library also includes methods
    to manipulate IPv4 and IPv6 addresses. The first part of computing a subnet address
    is defining the IP address. The user is prompted for the address, which is saved
    into `ip` ![](../Images/00003.jpg).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Relying on the `IPAddr` data structure, I initialized a `begin/rescue` block,
    in case there are any issues with the IP address, such as an address out of bounds.
    As a side note, I could have used a regular expression to check for IP address
    integrity, but the regular expression is quite lengthy. If an error is detected,
    the `rescue` clause catches it and outputs the specific culprit ![](../Images/00005.jpg).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The second piece needed to calculate a subnet address is the subnet mask ![](../Images/00004.jpg).
    Next, the IP address and subnet mask are converted into decimal numbers so the
    binary arithmetic operation `AND` can be performed on the two addresses. The resulting
    binary address is converted back into decimal and is the final subnet address.
    As you will see in a moment, the `mask` method of the ipaddr library abstracts
    all of the mathematical operations, making subnet address calculations simple.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: If both addresses pass inspection from the ipaddr library, the `mask` method
    is called ![](../Images/00006.jpg). The `mask` method expects a string object
    passed as the subnet mask address, so the `to_s` method is used to convert the
    `IPAddr` object. Finally, `mask` returns the subnet address, which is then displayed
    to the user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个地址都通过了ipaddr库的检查，则会调用`mask`方法 ![mask方法](../Images/00006.jpg)。`mask`方法期望传入一个字符串对象作为子网掩码地址，因此使用了`to_s`方法将`IPAddr`对象转换为字符串。最后，`mask`方法返回子网地址，然后将其显示给用户。
- en: Hacking the Script
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: You could easily convert this script to handle IPv6 addresses as well as IPv4
    addresses. I used the ipaddr library method `mask` to accomplish the binary `AND`
    function, but you could also perform the calculations explicitly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地将此脚本转换为同时处理IPv6地址和IPv4地址。我使用了ipaddr库的`mask`方法来实现二进制的`AND`操作，但您也可以显式地进行计算。
