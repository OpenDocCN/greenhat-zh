- en: Chapter 6. Meterpreter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章。Meterpreter
- en: In this chapter, we’ll dive deeper into this “hacker’s Swiss army knife” that
    can significantly improve your post exploitation experience. Meterpreter is one
    of the flagship products in Metasploit and is leveraged as a payload after a vulnerability
    is exploited. A *payload* is the information returned to us when we trigger an
    exploit. For example, when we exploit a weakness in a Remote Procedure Call (RPC),
    trigger the exploit, and select Meterpreter as the payload, we would be given
    a Meterpreter shell to the system. Meterpreter is an extension of the Metasploit
    Framework that allows us to leverage Metasploit’s functionality and further compromise
    our target. Some of this functionality includes ways to cover your tracks, reside
    purely in memory, dump hashes, access operating systems, pivot, and much more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨这个“黑客瑞士军刀”，它可以显著提高你的后利用体验。Meterpreter 是 Metasploit 的旗舰产品之一，在利用漏洞后作为有效载荷使用。*有效载荷*是我们触发漏洞时返回给我们的信息。例如，当我们利用远程过程调用（RPC）中的弱点，触发漏洞，并选择
    Meterpreter 作为有效载荷时，我们会获得一个 Meterpreter shell 来访问系统。Meterpreter 是 Metasploit 框架的扩展，允许我们利用
    Metasploit 的功能并进一步攻破我们的目标。这些功能包括掩盖你的行踪、纯内存中驻留、转储散列、访问操作系统、跳板等。
- en: In this chapter, we’ll leverage normal attack methods within Metasploit to compromise
    a Windows XP machine. Our payload, Meterpreter, will allow us to perform additional
    attacks after we’ve compromised the system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用 Metasploit 中的常规攻击方法来攻击 Windows XP 机器。我们的有效载荷，Meterpreter，将允许我们在攻破系统后执行额外的攻击。
- en: Compromising a Windows XP Virtual Machine
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻破 Windows XP 虚拟机
- en: Before we dive into the specifics of Meterpreter, we first need to compromise
    a system and get a Meterpreter shell.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 Meterpreter 的具体细节之前，我们首先需要攻破一个系统并获得一个 Meterpreter shell。
- en: Scanning for Ports with Nmap
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nmap 扫描端口
- en: 'We begin by identifying the services and ports running on the target by conducting
    a port scan with *nmap* to find a port to exploit, as shown here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用 *nmap* 进行端口扫描来识别目标上运行的服务和端口，以找到一个可利用的端口，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After conducting our port scan at ![](../images/00002.gif), we see that some
    interesting ports are accessible, including MS SQL at ![](../images/00004.gif),
    a potential attack vector. But perhaps the most interesting thing that *nmap*
    tells us is that this machine is running Windows XP Service Pack 2 at![](../images/00005.gif),
    which is now at the end of life, which means some published vulnerabilities will
    not have been fixed or patched by the installation of SP3.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行我们的端口扫描 ![../images/00002.gif](../images/00002.gif) 后，我们发现一些有趣的端口是可访问的，包括
    MS SQL ![../images/00004.gif](../images/00004.gif)，这是一个潜在的攻击向量。但也许 *nmap* 告诉我们最有趣的事情是，这台机器正在运行
    Windows XP Service Pack 2 ![../images/00005.gif](../images/00005.gif)，目前该系统已到生命终结期，这意味着一些已发布的漏洞可能尚未通过安装
    SP3 得到修复或修补。
- en: Also of note, we see the standard FTP ![](../images/00006.gif) and SMTP ![](../images/00007.gif)
    ports, which might be available to be leveraged for an attack. And we see that
    port 80 ![](../images/00026.gif) is open, which means we have a potential web
    application to attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们还看到了标准的 FTP ![../images/00006.gif](../images/00006.gif) 和 SMTP ![../images/00007.gif](../images/00007.gif)
    端口，这些端口可能可用于攻击。我们还看到端口 80 ![../images/00026.gif](../images/00026.gif) 已开启，这意味着我们有一个潜在的
    Web 应用程序可以攻击。
- en: Attacking MS SQL
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击 MS SQL
- en: In this example, we’ll attack port 1433, MS SQL, because this is often an entry
    point of weakness that can lead to a complete compromise and full administrative-level
    control over the target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将攻击端口 1433，MS SQL，因为这通常是弱点的一个入口点，可能导致完全攻破并对目标拥有完全的行政级控制。
- en: To begin, we identify the MS SQL installation, and then launch a MS SQL Server
    brute force attack to see if we can guess a password. By default, MS SQL is installed
    on TCP port 1433 and UDP port 1434, though newer versions allow for installation
    on a dynamically allocated port, which can be randomized. Luckily, port 1434 UDP
    (for which we did not scan) remains the same and can be queried to identify the
    dynamic port of the SQL server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们识别 MS SQL 安装，然后启动 MS SQL 服务器暴力破解攻击，看看我们是否能猜出密码。默认情况下，MS SQL 安装在 TCP 端口
    1433 和 UDP 端口 1434 上，尽管新版本允许在动态分配的端口上安装，这可以是随机的。幸运的是，端口 1434 UDP（我们未对其进行扫描）保持不变，可以查询以确定
    SQL 服务器的动态端口。
- en: 'Here, we scan the system and see that MS SQL port 1434 UDP is open:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们扫描系统并看到 MS SQL 端口 1434 UDP 已开启：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we scan our host at ![](../images/00002.gif) and see that MS
    SQL UDP port 1434 at ![](../images/00004.gif) is open. ([Chapter 11](part0015.html#fast-track),
    [Chapter 13](part0017.html#building_your_own_module), and [Chapter 17](part0021.html#simulated_penetration_test)
    will cover MS SQL in much more depth.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在![扫描主机](../images/00002.gif)处扫描我们的宿主，并看到MS SQL UDP端口1434在![端口状态](../images/00004.gif)处是开放的。（[第11章](part0015.html#fast-track)，[第13章](part0017.html#building_your_own_module)，和[第17章](part0021.html#simulated_penetration_test)将更深入地介绍MS
    SQL。）
- en: When targeting MS SQL, we can leverage the *mssql_ping* module to brute force
    the MS SQL port and attempt to guess the username and password. When MS SQL is
    first installed, the program will require the user to create an *sa*, or system
    administrator, account. You’ll often be able to guess or brute force the *sa*
    account password, because when administrators install this application they do
    not understand the security ramifications of using either a blank password or
    something too simple.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当针对MS SQL时，我们可以利用*mssql_ping*模块暴力破解MS SQL端口，并尝试猜测用户名和密码。当MS SQL首次安装时，程序将要求用户创建一个*sa*，或系统管理员，账户。你通常会能够猜测或暴力破解*sa*账户密码，因为当管理员安装此应用程序时，他们并不了解使用空密码或过于简单的密码的安全影响。
- en: 'In the next example, we look for the *mssql_ping* module and attempt to brute
    force the *sa* account:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们寻找*mssql_ping*模块并尝试暴力破解*sa*账户：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After calling the *mssql_ping* module with `use scanner/mssql/mssql_ping` and
    setting our options, we see that a SQL Server installation is found at 192.168.33.130
    ![](../images/00002.gif). The name of the server is `IHAZSECURITY` ![](../images/00004.gif).
    Its version number 9.00.1399.06 shown at ![](../images/00005.gif) equates to SQL
    Server 2005 Express, and we know that it’s listening on TCP port 1433 ![](../images/00006.gif).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`use scanner/mssql/mssql_ping`调用*mssql_ping*模块并设置我们的选项后，我们看到在192.168.33.130处找到了一个SQL
    Server安装![扫描结果](../images/00002.gif)。服务器的名称是`IHAZSECURITY`![服务器名称](../images/00004.gif)。其版本号9.00.1399.06，如![版本信息](../images/00005.gif)所示，相当于SQL
    Server 2005 Express，我们知道它在TCP端口1433上监听![端口信息](../images/00006.gif)。
- en: Brute Forcing MS SQL Server
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴力破解MS SQL服务器
- en: 'Next, we brute force the server with the Framework’s *mssql_login* module:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用框架的*mssql_login*模块暴力破解服务器：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We select the *mssql_login* module at ![](../images/00002.gif) and point it
    to the default password word list from Fast-Track at ![](../images/00004.gif).
    (We discuss Fast-Track in more detail in [Chapter 11](part0015.html#fast-track).)
    At ![](../images/00005.gif), we have successfully guessed the *sa* password: *password123*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在![选择模块](../images/00002.gif)处选择*mssql_login*模块，并将其指向Fast-Track的默认密码词表![词表来源](../images/00004.gif)。（我们在[第11章](part0015.html#fast-track)中更详细地讨论了Fast-Track。）在![成功猜测密码](../images/00005.gif)处，我们成功猜出了*sa*密码：*password123*。
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fast-Track is a tool created by one of the authors of this book that leverages
    multiple attacks, exploits, and the Metasploit Framework for payload delivery.
    One of Fast-Track’s features is its ability to use a brute-forcer to attack and
    compromise MS SQL automatically.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Fast-Track是由本书的一位作者创建的一个工具，它利用多种攻击、漏洞和Metasploit框架进行有效载荷交付。Fast-Track的一个特性是它能够使用暴力破解器自动攻击和利用MS
    SQL。
- en: '* * *'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The xp_cmdshell
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xp_cmdshell
- en: By running MS SQL from the *sa* account, we can execute the stored procedure
    `xp_cmdshell`, which lets us interact with the underlying operating system and
    execute commands. The `xp_cmdshell` is a built-in stored procedure that ships
    by default with SQL Server. You can call this stored procedure and have it query
    and execute underlying operating system calls directly with MS SQL. Think of it
    as a kind of superuser command prompt that allows you to run anything you want
    on the operating system. When we gain access to the *sa* account, we find that
    the MS SQL server is generally running with SYSTEM-level permissions, which allows
    us full access as an administrator to both MS SQL and the machine itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从*sa*账户运行MS SQL，我们可以执行存储过程`xp_cmdshell`，它允许我们与底层操作系统交互并执行命令。`xp_cmdshell`是一个默认与SQL
    Server一起提供的内置存储过程。你可以调用这个存储过程，并直接通过MS SQL查询和执行底层操作系统调用。把它想象成一个超级用户命令提示符，允许你在操作系统上运行任何你想要的东西。当我们获得对*sa*账户的访问权限时，我们发现MS
    SQL服务器通常以SYSTEM级别的权限运行，这允许我们作为管理员完全访问MS SQL和机器本身。
- en: 'To get a payload onto the system, we’ll interact with the `xp_cmdshell`, add
    a local administrator, and deliver the payload through an executable. David Kennedy
    and Joshua Drake (*jduck*), have written a module (*mssql_payload*) that can be
    used to deliver any Metasploit payload through `xp_cmdshell`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要将有效载荷放入系统，我们将与`xp_cmdshell`交互，添加本地管理员，并通过可执行文件交付有效载荷。David Kennedy和Joshua Drake（*jduck*）编写了一个模块（*mssql_payload*），可以通过`xp_cmdshell`交付任何Metasploit有效载荷：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After selecting the *mssql_payload* module and setting our payload to `meterpreter`
    at ![](../images/00004.gif), all we need to do is set the standard options before
    starting our Meterpreter session. We’ve succeeded in opening a Meterpreter session
    at ![](../images/00005.gif) on the target machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择*mssql_payload*模块并将我们的有效载荷设置为`meterpreter`在![设置有效载荷](../images/00004.gif)之后，我们只需要在启动Meterpreter会话之前设置标准选项。我们已经成功在目标机器上的![启动会话](../images/00005.gif)上打开了一个Meterpreter会话。
- en: To recap, in the attack described here, we used the *mssql_ping* module to guess
    the MS SQL *sa* password, which we discovered is *password123*. We then leveraged
    the *mssql_payload* module to communicate with MS SQL and upload a Meterpreter
    shell through MS SQL, and the shell was presented to us, thereby completely compromising
    the system. Once the Meterpreter shell is presented, we know that the exploit
    was successful and we can continue with post exploitation on this system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章描述的攻击中，我们使用了*mssql_ping*模块来猜测MS SQL *sa*密码，我们发现密码是*password123*。然后我们利用*mssql_payload*模块通过MS
    SQL与MS SQL进行通信，并通过MS SQL上传Meterpreter外壳，外壳被展示给我们，从而完全控制了系统。一旦Meterpreter外壳被展示，我们就知道利用成功，可以继续在这个系统上进行后利用操作。
- en: Basic Meterpreter Commands
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本Meterpreter命令
- en: Having successfully compromised the target and gained a Meterpreter console
    on the system, we can glean more information with some basic Meterpreter commands.
    Use the `help` command at any point for more information on how to use Meterpreter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功入侵目标并获取系统上的Meterpreter控制台后，我们可以使用一些基本的Meterpreter命令来获取更多信息。在任何时候使用`help`命令获取有关如何使用Meterpreter的更多信息。
- en: Capturing a Screenshot
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获屏幕截图
- en: Meterpreter’s `screenshot` command will export an image of the active user’s
    desktop and save it to the */opt/metasploit3/msf3/* directory, as shown in [Figure 6-1](part0010.html#meterpreter-captured_screenshot).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter的`screenshot`命令将导出活动用户的桌面图像，并将其保存到*/opt/metasploit3/msf3/*目录中，如图[图6-1](part0010.html#meterpreter-captured_screenshot)所示。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Desktop screen captures offer a great way to learn about a target system. For
    example, in [Figure 6-1](part0010.html#meterpreter-captured_screenshot), we can
    see that McAfee antivirus software is installed and running, which means we’ll
    need to be cautious about what we upload to the system. ([Chapter 7](part0011.html#avoiding_detection)
    discusses antivirus evasion in more detail.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面屏幕截图是了解目标系统的一种很好的方法。例如，在[图6-1](part0010.html#meterpreter-captured_screenshot)中，我们可以看到McAfee杀毒软件已安装并运行，这意味着我们需要小心上传到系统中的内容。（[第7章](part0011.html#avoiding_detection)更详细地讨论了杀毒软件规避方法。）
- en: '![Meterpreter-captured screenshot](../images/00030.jpeg)Figure 6-1. Meterpreter-captured
    screenshot'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![Meterpreter捕获的屏幕截图](../images/00030.jpeg)图6-1. Meterpreter捕获的屏幕截图'
- en: sysinfo
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sysinfo
- en: 'Another command we can specify is `sysinfo`, which will tell us the platform
    on which the system is running, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以指定的命令是`sysinfo`，它将告诉我们系统正在运行的平台，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this system is running Windows XP Service Pack 2\. Because SP2
    is end of life, we can assume that we can find a ton of holes on this system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该系统正在运行Windows XP Service Pack 2。由于SP2已停止支持，我们可以假设在这个系统上可以找到大量的漏洞。
- en: Capturing Keystrokes
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获按键
- en: Now we’ll grab the password hash values from this system, which can either be
    cracked or used in an attack. We’ll also start *keystroke logging* (recording
    keystrokes) on the remote system. But first, let’s list the running processes
    on the target system with the `ps` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从该系统中抓取密码散列值，这些值可以破解或用于攻击。我们还将开始在远程系统上启动*按键记录*（记录按键）。但在开始之前，让我们使用`ps`命令列出目标系统上正在运行的过程。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Executing `ps` at ![](../images/00002.gif) provides a list of running processes,
    including *explorer.exe* ![](../images/00004.gif). At ![](../images/00005.gif)
    we issue the `migrate` command to move our session into the *explorer.exe* process
    space. Once that move is complete, we start the *keylog_recorder* module at ![](../images/00006.gif),
    stopping it after some time with ctrl-C, and finally, at ![](../images/00007.gif),
    in another terminal window, we dump the contents of the keystroke logger to see
    what we’ve caught.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](../images/00002.gif)处执行`ps`命令提供了一个运行进程列表，包括*explorer.exe* ![](../images/00004.gif)。在![](../images/00005.gif)处，我们发出`migrate`命令将我们的会话移动到*explorer.exe*进程空间。一旦移动完成，我们在![](../images/00006.gif)处启动*keylog_recorder*模块，使用ctrl-C停止它，最后，在另一个终端窗口中，我们将键盘记录器的内容导出，以查看我们捕获了什么。
- en: Dumping Usernames and Passwords
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出用户名和密码
- en: In the preceding example, we grabbed password hashes by logging what a user
    typed. We can also use Meterpreter to obtain the usernames and password hashes
    on a local file system without the use of keyloggers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过记录用户输入的内容来获取密码哈希值。我们也可以使用Meterpreter在本地文件系统上获取用户名和密码哈希值，而不使用键盘记录器。
- en: Extracting the Password Hashes
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取密码哈希值
- en: In this attack, we’ll leverage the *hashdump* post exploitation module in Meterpreter
    to extract the username and password hashes from the system. Microsoft typically
    stores hashes on LAN Manager (LM), NT LAN Manager (NTLM), and NT LAN Manager v2
    (NTLMv2).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次攻击中，我们将利用Meterpreter中的*hashdump*后利用模块从系统中提取用户名和密码哈希值。微软通常在局域网管理器（LM）、NT局域网管理器（NTLM）和NT局域网管理器v2（NTLMv2）上存储哈希值。
- en: In the case of LM, for example, when a use enters a password for the first time
    or changes a password, the password is assigned a hash value. Depending on the
    hash value length, the password can be split into seven-character hashes. For
    example, if the password is *password123456*, the hash value could be stored as
    *passwor* and *d123456*, so an attacker would simply need to crack a 7-character
    password instead of a 14-character one. In NTLM, regardless of the password size,
    *password123456* would be stored as a hash value of *password123456*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在LM的情况下，当用户第一次输入密码或更改密码时，密码会被分配一个哈希值。根据哈希值的长度，密码可以被分成七个字符的哈希值。例如，如果密码是*password123456*，哈希值可能被存储为*passwor*和*d123456*，因此攻击者只需破解一个7个字符的密码，而不是14个字符的密码。在NTLM中，无论密码大小如何，*password123456*都会被存储为*password123456*的哈希值。
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We’re using a super complex password here that we would not be able to crack
    in a reasonable amount of time. Our password is larger than the 14-character maximum
    that LM supports, so it has automatically converted itself to an NTLM-based hash
    value. Even with rainbow tables or a super powerful cracking machine, it would
    take a significant amount of time to crack these passwords.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个超级复杂的密码，我们无法在合理的时间内破解它。我们的密码长度超过了LM支持的14个字符最大限制，因此它已经自动转换为基于NTLM的哈希值。即使使用彩虹表或超级强大的破解机器，破解这些密码也需要相当长的时间。
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In the following code, we extract a username and password hash for the *Administrator*
    user account with UID 500 (the Windows Administrator system default). The strings
    that follow `Administrator:500` are two hashes of the *Administrator* password.
    This shows an example of a simple extract of a username and password hashes. Shortly,
    we will extract our own username and password hashes from our Windows XP system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们提取了UID为500的*Administrator*用户账户的用户名和密码哈希值（Windows管理员系统默认）。跟随`Administrator:500`的字符串是*Administrator*密码的两个哈希值。这展示了简单提取用户名和密码哈希值的一个例子。简而言之，我们将在Windows
    XP系统中提取我们自己的用户名和密码哈希值。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first hash at ![](../images/00002.gif) is an LM hash, and the second at
    ![](../images/00004.gif) is an NTLM hash.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](../images/00002.gif)处的第一个哈希值是LM哈希，在![](../images/00004.gif)处的第二个是NTLM哈希。
- en: Dumping the Password Hash
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出密码哈希值
- en: On your target machine, change your password to something complex, such as *thisisacrazylongpassword&&!!@@##*
    and use Meterpreter to dump the username and password hashes (shown in the preceding
    code listing) from the target again. We will leverage the `use priv` command,
    which means we are running as a privileged user account.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标机器上，将您的密码更改为复杂的密码，例如*thisisacrazylongpassword&&!!@@##*，并使用Meterpreter从目标再次导出用户名和密码哈希值（如前代码列表所示）。我们将利用`use
    priv`命令，这意味着我们正在以特权用户账户运行。
- en: To dump the Security Account Manager (SAM) database, we need to be running as
    SYSTEM to get around the registry restrictions and dump the protected SAM storage
    that contains our Windows usernames and passwords, as shown next. Try performing
    this scenario on a test virtual machine to see if you can dump the username and
    password hashes. In this listing, we execute the `hashdump` command, which dumps
    all the usernames and password hashes from the system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出安全账户管理器（SAM）数据库，我们需要以SYSTEM身份运行，以绕过注册表限制并导出包含我们的Windows用户名和密码的保护SAM存储，如下所示。尝试在一个测试虚拟机上执行此场景，看看你是否能导出用户名和密码散列。在这个列表中，我们执行了`hashdump`命令，该命令从系统中导出所有用户名和密码散列。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A hash value that starts with *aad3b435* is simply an empty or null hash value
    — a placeholder for an empty string. (Something like *Administrator:500:NOPASSWD:ntlmhash*
    is also null.) Because our password was longer than 14 characters, Windows can
    no longer store an LM hash, and it uses the standard *aad3b435* . . . string,
    which represents a blank password.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以*aad3b435*开头的散列值只是一个空或空散列值——一个空字符串的占位符。（类似于*Administrator:500:NOPASSWD:ntlmhash*也是空。）因为我们的密码长度超过14个字符，Windows不能再存储LM散列，它使用标准的*aad3b435*...字符串，这代表一个空密码。
- en: '* * *'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: The Problem With Lm Hashes
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LM散列的问题
- en: 'Just for fun, try the following: Change your password to something complex
    that is 14 characters or less. Then extract the password hashes from the system
    with `hashdump` and copy the first hash value (such as the portion beginning with
    *aad3b435* in the preceding example), which is the LM hash. Next, search for one
    of the many online password crackers and submit your hash value. Wait a few minutes,
    click the refresh button a couple of times, and your password should be cracked.
    (Be careful not to use one of your real passwords, because the information is
    frequently posted to everyone who visits the site!)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，尝试以下操作：将你的密码改为一个复杂度较高且长度不超过14个字符的密码。然后使用`hashdump`从系统中提取密码散列，并复制第一个散列值（例如，在前面示例中以*aad3b435*开始的那个部分），这是LM散列。接下来，搜索许多在线密码破解器之一，提交你的散列值。等待几分钟，点击刷新按钮几次，你的密码应该被破解。（小心不要使用你的真实密码，因为信息经常被发布给所有访问该网站的人！）
- en: This is a *rainbow table* attack. A *rainbow table* is a precomputed table used
    for reversing cryptographic hash functions, usually for cracking passwords. Rainbow
    tables use every combination of characters including 1–7, a–z, special symbols,
    and spaces. When you submit your hash to an online cracker, the site’s server
    searches through gigabytes of rainbow tables for your specific hash.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*彩虹表*攻击。彩虹表是一个用于反转加密散列函数的预计算表，通常用于破解密码。彩虹表使用包括1–7，a–z，特殊符号和空格在内的所有字符组合。当你将你的散列提交给在线破解器时，网站的服务器会搜索数GB的彩虹表以找到你的特定散列。
- en: '* * *'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: Pass the Hash
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递散列
- en: 'In the preceding example, we ran into a slight complication: We have the administrator’s
    username and password hashes, but we can’t crack the password in a reasonable
    time frame. If we don’t know the password, how can we log into additional machines
    and potentially compromise more systems with this one user account?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遇到了一点小麻烦：我们有了管理员的用户名和密码散列，但我们无法在合理的时间内破解密码。如果我们不知道密码，我们如何登录到额外的机器，并可能使用这个用户账户破坏更多的系统？
- en: 'We can use the *pass-the-hash* technique, which requires that we have only
    the password hash, not the password itself. Metasploit’s *windows/smb/psexec*
    module makes this all possible, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*传递散列*技术，这要求我们只有密码散列，而不是密码本身。Metasploit的*windows/smb/psexec*模块使得这一切成为可能，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we select the *smb/psexec* module at ![](../images/00002.gif) and set
    the options for `LHOST`, `LPORT`, and `RHOST`, we set the `SMBPass` variable,
    and at ![](../images/00004.gif) we input the hash that we dumped earlier. As you
    can see, authentication is successful and we gain our Meterpreter session. We
    didn’t have to crack a password, and no password was needed. We’ve secured *Administrator*
    privileges using the password hash alone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择*smb/psexec*模块并在![](../images/00002.gif)设置`LHOST`、`LPORT`和`RHOST`的选项后，我们设置`SMBPass`变量，并在![](../images/00004.gif)输入我们之前导出的散列。正如你所看到的，认证成功，我们获得了Meterpreter会话。我们不需要破解密码，也不需要密码。我们仅使用密码散列就获得了*管理员*权限。
- en: When we successfully compromise one system on a large network, in most cases
    that system will have the same administrator account on multiple systems. This
    attack would allow us to hop from one system to another without ever needing to
    crack the password itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在大型网络中成功攻陷一个系统时，在大多数情况下，该系统将在多个系统上拥有相同的管理员账户。这种攻击将使我们能够从一个系统跳到另一个系统，而无需破解密码本身。
- en: Privilege Escalation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提权
- en: Now that we have access to the system, we can create a normal user account with
    limited permissions using the `net user` command. We’ll create a new user account
    to demonstrate how to elevate permissions as that user. (You will learn more about
    this in [Chapter 8](part0012.html#exploitation_using_client-side_attacks).)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问系统，我们可以使用`net user`命令创建一个具有有限权限的正常用户账户。我们将创建一个新的用户账户来演示如何以该用户提升权限。（你将在[第8章](part0012.html#exploitation_using_client-side_attacks)中了解更多关于此内容。）
- en: When we compromise a limited user account, we will run into restrictions that
    prevent us from executing commands that require administrative-level permissions.
    By elevating an account’s permissions, we overcome that restriction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们攻陷一个受限用户账户时，我们会遇到限制，阻止我们执行需要管理员级别权限的命令。通过提升账户的权限，我们克服了这种限制。
- en: 'On a Windows XP target machine, we enter the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows XP目标机器上，我们输入以下命令：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we create a Meterpreter-based payload, *payload.exe*, copy it to the target’s
    XP machine, and run it under the user account *bob*. This will be our new limited
    user account. In this example, we will use *msfpayload* to create a Meterpreter-based
    payload as a normal Windows executable. (We’ll discuss *msfpayload* in more detail
    in [Chapter 7](part0011.html#avoiding_detection).)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个基于Meterpreter的有效载荷，命名为*payload.exe*，将其复制到目标XP机器上，并在用户账户*bob*下运行它。这将是我们新的受限用户账户。在这个例子中，我们将使用*msfpayload*来创建一个基于Meterpreter的有效载荷，作为一个普通的Windows可执行文件。（我们将在[第7章](part0011.html#avoiding_detection)中更详细地讨论*msfpayload*。）
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `LHOST` and `LPORT` options tell Metasploit that when it creates our Meterpreter
    payload it should connect back to our attacker machine on port 443\. We then call
    the *msfcli* interface to start a listener handler for us. This listener handler
    will wait for connections, and when one is received, it will spawn a Meterpreter
    shell.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`LHOST`和`LPORT`选项告诉Metasploit，当它创建我们的Meterpreter有效载荷时，应该连接回我们的攻击机器的443端口。然后我们调用*msfcli*接口为我们启动一个监听处理器。这个监听处理器将等待连接，当收到连接时，它将启动一个Meterpreter
    shell。'
- en: On the attacker machine, we create a new Meterpreter stand-alone executable
    at ![](../images/00002.gif), copy the executable to the Windows XP machine, and
    run it under the user account *bob*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击机器上，我们在![](../images/00002.gif)处创建一个新的Meterpreter独立可执行文件，将可执行文件复制到Windows
    XP机器上，并在用户账户*bob*下运行它。
- en: We then set up a listener at ![](../images/00004.gif) to listen for the Meterpreter
    connection. After the target executes the payload on the system (*payload.exe*),
    we see a limited user Meterpreter console ![](../images/00005.gif). We can, for
    example, generate a *payload.exe* on a Back|Track machine, copy the executable
    to a Windows XP machine, and set up a listener to get a Meterpreter session.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在![](../images/00004.gif)处设置一个监听器以监听Meterpreter连接。当目标在系统上执行有效载荷(*payload.exe*)后，我们看到一个受限用户的Meterpreter控制台![](../images/00005.gif)。例如，我们可以在Back|Track机器上生成一个*payload.exe*，将可执行文件复制到Windows
    XP机器上，并设置一个监听器以获取Meterpreter会话。
- en: As shown in the next listing, we drop to a Meterpreter shell at ![](../images/00002.gif)
    and enter **`net user bob`**; we can see that user *bob* is a member of the *Users*
    group, is not an administrator, and has limited rights. We have a limited footprint
    from which to attack this device, and we can’t perform certain attacks, such as
    dumping the SAM database to extract usernames and passwords. (Luckily, Meterpreter
    has us covered, as you’ll see in a moment.) Our query complete, we press ctrl-Z,
    which saves our Meterpreter session and keeps us in the exploited system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，我们在![](../images/00002.gif)处进入Meterpreter shell，输入**`net user bob`**；我们可以看到用户*bob*是*Users*组的成员，不是管理员，并且权限有限。我们从有限的足迹中攻击这个设备，不能执行某些攻击，例如转储SAM数据库以提取用户名和密码。（幸运的是，Meterpreter已经为我们提供了覆盖，你将在下一刻看到。）我们的查询完成后，我们按ctrl-Z，这将保存我们的Meterpreter会话并保持我们在被利用的系统上。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '* * *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here’s another Meterpreter trick: While you’re in the Meterpreter console,
    enter **`background`** to jump back into *msfconsole* and leave the session running.
    Then enter `sessions -l` and `sessions -isessionid` to return to your Meterpreter
    console.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Meterpreter的另一个技巧：当你处于Meterpreter控制台时，输入**`background`**回到*msfconsole*并保持会话运行。然后输入`sessions
    -l`和`sessions -isessionid`返回到你的Meterpreter控制台。
- en: '* * *'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Now let’s get administrative or SYSTEM rights. As shown in the next listing,
    we enter **`use priv`** to load the *priv* extensions, which gets us access to
    the privileged module (which may already be loaded). Next, we enter **`getsystem`**
    in an attempt to elevate our privilege to that of local system, or administrator.
    We then verify that we have admin privileges with the **`getuid`** command. The
    server username returned is *NT AUTHORITY\SYSTEM*, which tells us that we’ve succeeded
    at gaining administrator access.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来获取管理权限或SYSTEM权限。如以下列表所示，我们输入**`use priv`**来加载*priv*扩展，这使我们能够访问特权模块（可能已经加载）。接下来，我们输入**`getsystem`**尝试提升我们的权限到本地系统或管理员权限。然后我们使用**`getuid`**命令来验证我们是否有管理员权限。返回的服务器用户名是*NT
    AUTHORITY\SYSTEM*，这告诉我们我们已经成功获得了管理员访问权限。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To switch back to the previous user account where we initially got our Meterpreter
    shell, we’d use `rev2self`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换回我们最初获取Meterpreter外壳的先前用户账户，我们会使用`rev2self`。
- en: Token Impersonation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令牌模拟
- en: In *token impersonation*, we grab a Kerberos token on the target’s machine and
    then use it in place of authentication to assume the identity of the user that
    originally created that token. Token impersonation is very beneficial for penetration
    tests and can be one of Meterpreter’s most powerful features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在*令牌模拟*中，我们在目标机器上抓取一个Kerberos令牌，然后用它代替认证来假设创建该令牌的原始用户的身份。令牌模拟对于渗透测试非常有用，可能是Meterpreter最强大的功能之一。
- en: 'Consider the following scenario, for example: You’re performing a penetration
    test at your organization, and you successfully compromise the system and establish
    a Meterpreter console. A domain administrator account has logged on within the
    last 13 hours. When this account logs on, a Kerberos token is passed to the server
    (single sign-on) and is valid for a certain period of time. You exploit this system
    via the valid and active Kerberos token, and through Meterpreter you successfully
    assume the role of a domain administrator, without needing the password. Then
    you hack a domain administrator account or go after a domain controller. This
    is probably one of the easiest ways to gain access into a system and just another
    example of why Meterpreter is so useful.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景，例如：你在你的组织进行渗透测试，你成功入侵系统并建立了Meterpreter控制台。在过去的13小时内，有一个域管理员账户已登录。当此账户登录时，一个Kerberos令牌被传递到服务器（单点登录），并在一定时间内有效。你通过有效的和活跃的Kerberos令牌利用这个系统，并通过Meterpreter成功模拟了域管理员的角色，而不需要密码。然后你黑掉域管理员账户或攻击域控制器。这可能是在系统中获得访问权限的最简单方法之一，也是Meterpreter为什么如此有用的另一个例子。
- en: Using ps
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ps
- en: For this example, we’ll use the Meterpreter function `ps` to list the applications
    running and show under which account they are running. We’ll use the domain name
    *SNEAKS.IN* ![](../images/00002.gif) and the user account *ihazdomainadmin* ![](../images/00004.gif).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用Meterpreter函数`ps`来列出正在运行的应用程序以及它们运行的账户。我们将使用域名*SNEAKS.IN* ![图片](../images/00002.gif)和用户账户*ihazdomainadmin*
    ![图片](../images/00004.gif)。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following listing, we leverage `steal_token` and the PID (380
    in this case) to steal the token of that user and assume the role of the domain
    administrator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下列表所示，我们利用`steal_token`和PID（在这个例子中是380）来窃取该用户的令牌并假设域管理员的角色：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have successfully impersonated the domain administrator account and Meterpreter
    is now running under the context of that user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功模拟了域管理员账户，现在Meterpreter正在该用户的上下文中运行。
- en: In some cases, `ps` may not list a running process running as a domain administrator.
    We can leverage `incognito` to list available tokens on the system as well. When
    performing a penetration test, we should check the output of both `ps` and `icognito`
    because the results may vary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`ps`可能不会列出以域管理员身份运行的进程。我们可以利用`incognito`来列出系统上的可用令牌。在进行渗透测试时，我们应该检查`ps`和`incognito`的输出，因为结果可能会有所不同。
- en: We load `incognito` with `use incognito` and then list tokens with `list_tokens
    -u`. Looking through the list of tokens, we see the *SNEAKS.IN\ihazdomainadmin*
    user account at ![](../images/00002.gif). Now we can pretend to be someone else.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`use incognito`加载`incognito`，然后使用`list_tokens -u`列出令牌。在查看令牌列表时，我们看到 ![图片](../images/00002.gif)
    中的 *SNEAKS.IN\ihazdomainadmin* 用户账户。现在我们可以假装成另一个人。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As shown in the next listing, we successfully impersonate the `ihazdomainadmin`
    token at ![](../images/00002.gif) and add a user account at ![](../images/00004.gif),
    which we then give domain administrator rights at ![](../images/00005.gif). (Be
    sure to use two backslashes, `\\`, when entering the `DOMAIN\USERNAME` at ![](../images/00002.gif).)
    Our domain controller is 192.168.33.50.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示列表，我们成功地在 ![图片](../images/00002.gif) 处模仿了`ihazdomainadmin`令牌，并在 ![图片](../images/00004.gif)
    处添加了一个用户账户，然后我们给它赋予了域管理员权限 ![图片](../images/00005.gif)。（在输入`DOMAIN\USERNAME`时，务必使用两个反斜杠
    `\\`，如 ![图片](../images/00002.gif) 所示。）我们的域控制器是192.168.33.50。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When entering the `add_user` and `add_group_user` commands, be sure to specify
    the `-h` flag, which tells Incognito where to add the domain administrator account.
    In this case, that would be the IP address of a domain controller. The implications
    for this attack are devastating: Essentially, the Kerberos token on any system
    that a domain administrator logs into can be assumed and used to access the entire
    domain. This means that every server on your network is your weakest link!'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入`add_user`和`add_group_user`命令时，务必指定`-h`标志，它告诉Incognito在哪里添加域管理员账户。在这种情况下，那将是域控制器的IP地址。这种攻击的影响是灾难性的：基本上，任何域管理员登录的系统上的Kerberos令牌都可以假定并用于访问整个域。这意味着你网络上的每台服务器都是你的薄弱环节！
- en: Pivoting onto Other Systems
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳板到其他系统
- en: '*Pivoting* is a Meterpreter method that allows for the attack of other systems
    on a network through the Meterpreter console. For example, if an attacker were
    to compromise one system, he could use pivoting to compromise other systems on
    the same network or to access systems to which he could not otherwise route traffic,
    for whatever reason.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳板* 是Meterpreter的一种方法，允许通过Meterpreter控制台攻击网络上的其他系统。例如，如果攻击者攻陷了一个系统，他可以使用跳板来攻陷同一网络上的其他系统，或者访问他无法通过其他方式路由流量的系统，无论出于什么原因。'
- en: For example, suppose you’re performing a penetration test from the Internet.
    You compromise a system through a vulnerability and have a Meterpreter console
    to the internal network. You can’t directly access other systems on the network,
    because the system you compromised did not provide you with everything you need
    to do so, but you need to penetrate the network further. Pivoting will allow you
    to attack multiple systems on the internal network through the Internet, using
    the Meterpreter console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在从互联网进行渗透测试。你通过一个漏洞攻陷了一个系统，并拥有一个指向内部网络的Meterpreter控制台。你无法直接访问网络上的其他系统，因为被攻陷的系统没有提供你进行此类操作所需的一切，但你需要进一步渗透网络。跳板攻击将允许你通过Meterpreter控制台，通过互联网攻击内部网络上的多个系统。
- en: In the following example, we’ll attack a system from one subnet and route that
    system to attack another system. First, we’ll exploit the Windows XP machine,
    and then we’ll piggyback the attack from our attacking machine to an Ubuntu system
    on the internal network. We’ll come from a 10.10.1.1/24 address and attack systems
    within the 192.168.33.1/24 network.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将从一个子网攻击一个系统，并将该系统路由到攻击另一个系统。首先，我们将利用Windows XP机器，然后我们将从我们的攻击机器通过跳板攻击内部网络上的Ubuntu系统。我们将从10.10.1.1/24地址开始，攻击192.168.33.1/24网络内的系统。
- en: We’ll assume that we already have access to one server via a compromise and
    will focus on establishing a connection to that network. Next, we introduce external
    scripts written with Meterpreter that can be found in the *scripts/meterpreter/*
    directory. These scripts offer additional functionality that we can use within
    Meterpreter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们已经通过攻陷获得了一个服务器的访问权限，并将重点放在建立与该网络的连接上。接下来，我们将介绍使用Meterpreter编写的外部脚本，这些脚本可以在*scripts/meterpreter/*目录中找到。这些脚本提供了我们可以在Meterpreter中使用的一些附加功能。
- en: We begin by displaying local subnets on the compromised system within a Meterpreter
    session with `run get_local_subnets`, as shown at ![](../images/00002.gif).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Meterpreter会话中使用`run get_local_subnets`显示被攻陷系统上的本地子网，如图所示 ![图片](../images/00002.gif)。
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have successfully compromised our Windows XP machine and have full access
    to it. Next, we background our running session at ![](../images/00004.gif) and
    add a `route` command to the Framework at ![](../images/00005.gif), telling it
    to route the remote network ID over session 1, the background Meterpreter session.
    We then display active routes with `route print` at ![](../images/00006.gif),
    and we can clearly see at ![](../images/00007.gif) that, just as we desired, the
    route is active.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up a second exploit against the targeted Linux system. The specific
    exploit here is a Samba-based heap overflow, which would be vulnerable on our
    Metasploitable machine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compare the `LHOST` ![](../images/00002.gif) and `RHOST` ![](../images/00004.gif)
    variables to the network information displayed by `ifconfig` ![](../images/00005.gif).
    Our `LHOST` option specifies the IP address of our attacking machine. Also notice,
    the `RHOST` option IP address is set to a different network subnet and that we
    are attacking systems by tunneling our traffic through our compromised target
    to additional systems on the target’s network. We are leveraging the pivoting
    attack through Metasploit to pass communications through our exploited machine
    to the target machine that resides on the local subnet. In this case, if the heap
    overflow is successful, we should be presented with a reverse shell from 192.168.33.132,
    simply by leveraging the network communications on the already compromised machine.
    When we run the exploit with `exploit`, we see at ![](../images/00006.gif) that
    a connection is set up as expected on a different machine, not the Windows XP
    machine. Now, to port scan through the pivot, we would use the *scanner/portscan/tcp*
    scanner module, which is built to handle routing through Metasploit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could also use the *scanner/portscan/tcp* scanner to conduct a series of
    port scans through your compromised target on the local subnet itself. We won’t
    go into the details here, but just know that you can perform port scanning on
    a compromised network leveraging this module.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, we used the `route add` command after we had compromised
    the system. Alternatively, to add the routes automatically to Meterpreter upon
    a new session spawn, we could use `load auto_add_route`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using Meterpreter Scripts
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several external Meterpreter scripts can help you to enumerate a system or perform
    predefined tasks inside the Meterpreter shell. We won’t cover every script here,
    but we will mention a few of the most notable ones.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Meterpreter scripts are in the process of being moved to post exploitation
    modules. We’ll cover both scripts and post exploitation modules in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: To run a script from the Meterpreter console, enter **`run`***`scriptname`*.
    The script will either execute or provide additional help on how to run it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you want to use an interactive remote GUI on the system, you can use
    the VNC protocol to tunnel the active desktop communications and interact with
    the GUI desktop on the target machine. But in some cases, the system may be locked
    and you may be unable to access it. Never fear: Metasploit has us covered.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在系统上使用交互式远程GUI，您可以使用VNC协议隧道活动桌面通信，并与目标机器上的GUI桌面进行交互。但在某些情况下，系统可能被锁定，您可能无法访问它。不要担心：Metasploit已经为我们解决了这个问题。
- en: In the following example, we issue the `run vnc` command, which installs a VNC
    session on the remote system. From there, we launch `run screen_unlock` to unlock
    the target machine so that we can view the desktop. As a result, a VNC window
    should appear, showing us the target desktop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们发出`run vnc`命令，该命令在远程系统上安装一个VNC会话。从那里，我们启动`run screen_unlock`来解锁目标机器，以便我们可以查看桌面。结果，应该会出现一个VNC窗口，显示目标桌面。
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will give us a VNC graphical interface to the target machine and allow
    us to interact through a desktop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供目标机器的VNC图形界面，并允许我们通过桌面进行交互。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Migrating a Process
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移进程
- en: Often, when we are attacking a system and exploiting a service such as Internet
    Explorer, if the target user closes the browser, the Meterpreter session is also
    closed and we lose our connection to the target. To avoid this problem, we can
    use the *migrate* post exploitation module, shown next, to attempt to migrate
    the service to a memory space that won’t close when the target closes the browser.
    By migrating to a different, more stable process, we ensure that the process isn’t
    closed and we maintain our connection to the system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们攻击一个系统并利用像Internet Explorer这样的服务时，如果目标用户关闭浏览器，Meterpreter会话也会关闭，我们就会失去与目标的连接。为了避免这个问题，我们可以使用下面的*migrate*后利用模块，尝试将服务迁移到一个在目标关闭浏览器时不会关闭的内存空间。通过迁移到不同的、更稳定的进程，我们确保进程不会被关闭，并保持与系统的连接。
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Killing Antivirus Software
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杀死抗病毒软件
- en: Antivirus software can block certain tasks. During penetration tests, we have
    seen “smarter” antivirus or host-based intrusion prevention products block our
    ability to run certain attack vectors. In such cases, we can run the `killav`
    script to stop the processes preventing our tasks from running.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 抗病毒软件可以阻止某些任务。在渗透测试中，我们见过“更智能”的抗病毒软件或基于主机的入侵预防产品阻止我们运行某些攻击向量。在这种情况下，我们可以运行`killav`脚本来停止阻止我们任务运行的过程。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obtaining System Password Hashes
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取系统密码散列
- en: 'Obtaining a copy of the system’s password hashes allows us to run pass-the-hash
    attacks or to brute force the hash to reveal the plain-text password. We can obtain
    the password hashes with the `run hashdump` command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 获取系统密码散列的副本允许我们运行传递散列攻击或暴力破解散列以揭示明文密码。我们可以使用`run hashdump`命令来获取密码散列：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Viewing All Traffic on a Target Machine
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看目标机器上的所有流量
- en: To see all traffic on a target, we can run a packet recorder. Everything captured
    by `packetrecorder` is saved in the *.pcap* file format to be parsed with a tool
    such as Wireshark.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看目标上的所有流量，我们可以运行数据包记录器。`packetrecorder`捕获的所有内容都保存为*.pcap*文件格式，以便使用Wireshark等工具进行解析。
- en: 'In this listing, we run the `packetrecorder` script with the `-i 1` option,
    which specifies which interface we want to use to perform the packet captures:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我们使用`-i 1`选项运行`packetrecorder`脚本，该选项指定我们想要用于执行数据包捕获的接口：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Scraping a System
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爬取系统
- en: The `scraper` script enumerates just about everything you could ever want from
    a system. It will grab the usernames and passwords, download the entire registry,
    dump password hashes, gather system information, and export the `HKEY_CURRENT_USER`
    (`HKCU`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`scraper`脚本几乎可以获取系统上您可能需要的所有内容。它将抓取用户名和密码，下载整个注册表，转储密码散列，收集系统信息，并导出`HKEY_CURRENT_USER`（`HKCU`）。'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using Persistence
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用持久性
- en: Meterpreter’s `persistence` script allows you to inject a Meterpreter agent
    to ensure that Meterpreter is running even after the target system reboots. If
    this is a reverse connection, you can set intervals for the target to connect
    back to the attacker machine. If it’s a bind, you can have it attempt to bind
    on an interface at a given time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter的`persistence`脚本允许您注入Meterpreter代理，以确保即使在目标系统重启后，Meterpreter仍在运行。如果是反向连接，您可以为目标设置连接回攻击者机器的间隔。如果是绑定连接，您可以指定在给定时间尝试绑定到某个接口。
- en: '* * *'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Warning
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: If you use this functionality, be sure that you remove it after you’re done.
    If you forget to do this, any attacker can also gain access to the system without
    authentication!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此功能，请确保在完成后将其删除。如果您忘记这样做，任何攻击者都可以未经身份验证就访问系统！
- en: '* * *'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In the following listing, we run `persistence` and tell Windows to autostart
    the agent at boot time (`-X`), wait 50 seconds (`-i 50`) before connection retries,
    run on port 443 (`-p 443`), and connect to IP 192.168.33.129\. We then establish
    a listener for the agent at ![](../images/00002.gif) with `use multi/handler`,
    and after setting a couple of options and running `exploit`, we see at ![](../images/00005.gif)
    that the connection comes in as expected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们运行 `persistence` 并告诉 Windows 在启动时自动启动代理（`-X`），在连接重试前等待 50 秒（`-i 50`），在端口
    443 上运行（`-p 443`），并连接到 IP 192.168.33.129。然后我们使用 `use multi/handler` 在 ![图片](../images/00002.gif)
    上为代理建立监听器，并在设置了一些选项并运行 `exploit` 之后，我们在 ![图片](../images/00005.gif) 上看到连接正如预期的那样进入。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As of this writing, the only way to remove the Meterpreter agent is to delete
    the registry entry in *HKLM\Software\Microsoft\Windows\CurrentVersion\Run\* and
    remove the VBScript located in *C:\WINDOWS\TEMP\*. Be sure to document the registry
    keys and locations (such as *HKLM\Software\Microsoft\Windows\CurrentVersion\Run\xEYnaHedooc*
    ![](../images/00004.gif)) to remove them manually. Generally, you can do this
    through Meterpreter or drop to a shell and remove it that way. If you feel more
    comfortable using a GUI, you can use `run vnc` and remove the script with *regedit*.
    (Note that the registry keys will change each time, so make sure that you document
    where Metasploit adds the registry keys.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，删除 Meterpreter 代理的唯一方法是删除注册表项 *HKLM\Software\Microsoft\Windows\CurrentVersion\Run\*
    和删除位于 *C:\WINDOWS\TEMP\* 的 VBScript。请务必记录注册表键和位置（例如 *HKLM\Software\Microsoft\Windows\CurrentVersion\Run\xEYnaHedooc*
    ![图片](../images/00004.gif)) 以手动删除它们。通常，您可以通过 Meterpreter 或切换到 shell 并以这种方式删除它来完成此操作。如果您更习惯使用
    GUI，可以使用 `run vnc` 并使用 *regedit* 删除脚本。（请注意，注册表键会每次更改，因此请确保您记录了 Metasploit 添加注册表键的位置。）
- en: Leveraging Post Exploitation Modules
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用后利用模块
- en: As mentioned earlier, the Meterpreter scripts are slowly being converted to
    post exploitation modules. The move to post exploitation modules will finally
    give a fully consistent standard and format to the Metasploit modules. As you
    read through later chapters, you’ll see the overall structure of auxiliary modules
    and exploits. In the past, Meterpreter scripts used their own format, which was
    very different from the way other modules behaved.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Meterpreter 脚本正在逐渐转换为后利用模块。转向后利用模块最终将为 Metasploit 模块提供一个完全一致的标准和格式。在阅读后面的章节时，您将看到辅助模块和漏洞利用的总体结构。在过去，Meterpreter
    脚本使用自己的格式，这与其他模块的行为方式非常不同。
- en: One added benefit of moving the modules to the same format is the ability to
    perform the same attack on all sessions available. Suppose, for example, that
    you have 10 open Meterpreter shells. In the traditional fashion, you would need
    to run `hashdump` on each or write custom scripts to query through each console.
    In the new format, you would be able to interact with each session and perform
    the `hashdump` on multiple systems if needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块转移到相同格式的另一个好处是能够在所有可用的会话上执行相同的攻击。例如，假设您有 10 个打开的 Meterpreter shell。按照传统方式，您需要在每个上运行
    `hashdump` 或编写自定义脚本来查询每个控制台。在新格式中，您将能够与每个会话交互，并在需要时在多个系统上执行 `hashdump`。
- en: 'The next listing shows an example of how to use the post exploitation modules:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用后利用模块的示例：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To see a list of post exploitation modules, enter the following and then press
    the tab key on your keyboard at the end of the line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看后利用模块的列表，请输入以下内容，然后在行尾按键盘上的制表键：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Upgrading Your Command Shell to Meterpreter
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将您的命令 shell 升级到 Meterpreter
- en: One of the newer features in the Metasploit Framework is its ability to upgrade
    a command shell payload to a Meterpreter payload once the system has been exploited,
    by issuing the `sessions -u` command. This is useful if we use a command shell
    payload as an initial stager and then find that this newly exploited system would
    make the perfect launching pad for further attacks into the network. Let’s look
    at a quick example from start to finish using MS08-067 with a reverse command
    shell as the payload, and upgrade it to a Meterpreter shell.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit框架中较新的功能之一是，一旦系统被利用，可以通过发出`sessions -u`命令将命令shell有效载荷升级到Meterpreter有效载荷。如果我们使用命令shell有效载荷作为初始阶段，然后发现这个新被利用的系统将完美地成为进一步攻击网络的发射台，这将非常有用。让我们通过使用带有反向命令shell作为有效载荷的MS08-067从开始到结束的快速示例，并将其升级到Meterpreter
    shell。
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At ![](../images/00002.gif) we issue the `setg` command for `LHOST` and `LPORT`,
    which is required in order for the `sessions -u 1` to upgrade to Meterpreter at
    ![](../images/00005.gif). (The `setg` command sets the `LPORT` and `LHOST` globally
    in Metasploit, not just for this exploit.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](../images/00002.gif)处，我们发出`setg`命令为`LHOST`和`LPORT`，这是在![](../images/00005.gif)处升级到Meterpreter所必需的。（`setg`命令在Metasploit中全局设置`LPORT`和`LHOST`，而不仅仅是针对此利用。）
- en: Notice at ![](../images/00004.gif) that when we exploit the system we issue
    the `exploit -z` command, which will not interact with the session once the target
    has been exploited. If you had already executed the `exploit` command at this
    point, you could simply press ctrl-Z and run the session in the background.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在![](../images/00004.gif)处，当我们利用系统时，我们发出`exploit -z`命令，一旦目标被利用，它将不会与会话交互。如果你此时已经执行了`exploit`命令，你可以简单地按ctrl-Z并在后台运行会话。
- en: Manipulating Windows APIs with the Railgun Add-On
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Railgun附加组件操作Windows API
- en: You can interface with the Windows native API directly through a Metasploit
    add-on called *Railgun*, which was written by Patrick HVE. By adding Railgun to
    the Metasploit Framework, you can natively call Windows APIs through Meterpreter,
    all through the Windows API. For example, in the following listing, we’ll drop
    into an interactive Ruby shell (`irb`), available through Meterpreter. The `irb`
    shell allows us to interact directly with Meterpreter through Ruby-based syntax.
    We call Railgun in this example and create a simple pop-up box saying “hello world”.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Metasploit的一个名为*Railgun*的附加组件直接与Windows原生API接口，这是由Patrick HVE编写的。通过将Railgun添加到Metasploit框架，你可以通过Meterpreter以原生方式调用Windows
    API，这一切都通过Windows API完成。例如，在下面的列表中，我们将进入一个交互式Ruby shell（`irb`），这是通过Meterpreter可用的。`irb`
    shell允许我们通过基于Ruby的语法直接与Meterpreter交互。在这个例子中，我们调用Railgun并创建一个简单的弹出窗口，显示“hello world”。
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On our target Windows XP machine, you should see a pop-up box with *world* in
    the title bar and *hello* in the message box. In this example, we simply called
    the *user32.dll* and the `MessageBoxA` function, which takes the parameters as
    shown.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目标Windows XP机器上，你应该看到一个标题栏上有*world*、信息框中有*hello*的弹出窗口。在这个例子中，我们只是调用了*user32.dll*和`MessageBoxA`函数，其参数如下所示。
- en: '* * *'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a list of all documented API calls, visit [http://msdn.microsoft.com/](http://msdn.microsoft.com/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有已记录的API调用列表，请访问[http://msdn.microsoft.com/](http://msdn.microsoft.com/).
- en: '* * *'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We won’t cover Railgun in detail (you can find a tutorial within the Framework
    directory under *external/source/meterpreter/source/extensions/stdapi/server/railgun/*,
    but this gives you an idea of its power.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍Railgun（你可以在框架目录下的*external/source/meterpreter/source/extensions/stdapi/server/railgun/*中找到一个教程，但这可以给你一个关于其功能的概念）。
- en: 'The implications are huge: Railgun gives you the same capabilities as a native
    Win32 application with full access to the Windows API.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其影响是巨大的：Railgun为你提供了与原生Win32应用程序相同的性能，并完全访问Windows API。
- en: Wrapping Up
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully, you’re now pretty comfortable with Meterpreter. We haven’t gone through
    every Meterpreter flag and option, because we expect your knowledge of Meterpreter
    to grow as you experiment and use it. Meterpreter is a continuously evolving tool
    with an enormous amount of support for scripts and additions. Once you become
    comfortable with the overall interface, you will be able to master anything new.
    In [Chapter 16](part0020.html#meterpreter_scripting), you will learn how to create
    your own Meterpreter scripts from scratch and how the overall structure of a Meterpreter
    script is designed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在对Meterpreter已经很熟悉了。我们并没有介绍Meterpreter的每一个标志和选项，因为我们预期你在实验和使用过程中对Meterpreter的了解会不断增长。Meterpreter是一个持续发展的工具，它为脚本和附加功能提供了巨大的支持。一旦你对整体界面感到舒适，你将能够掌握任何新的内容。在[第16章](part0020.html#meterpreter_scripting)中，你将学习如何从头开始创建自己的Meterpreter脚本，以及Meterpreter脚本的整体结构是如何设计的。
