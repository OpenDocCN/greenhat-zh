- en: Part VI. VIEW FROM THE TOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The air's getting thinner, but the view's getting better. Several hundred pages
    ago we started our journey at the lowest level, grubbing around the seedy underbelly
    of source code construction. In this last section we complete our journey by climbing
    to the very top of the software development mountain and surveying the territory
    below. I hope you're not afraid of heights.
  prefs: []
  type: TYPE_NORMAL
- en: Here we'll look at how the final parts of the jigsaw fit together.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code cookbook: how we actually write software in our development teams.
    This chapter describes both software development methodologies and software development
    processes. It shows how we manage to produce programs in a predictable, timely
    manner (or, at least, attempt to).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  prefs: []
  type: TYPE_NORMAL
- en: 'A look at the different code-writing disciplines out there: applications programming,
    games programming, distributed programming, and more. Each of these branches of
    programming has its own special problems and important skills. Understanding these
    will equip you to write the most suitable code for each occasion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 24](ch24.html "Chapter 24. WHERE NEXT?")'
  prefs: []
  type: TYPE_NORMAL
- en: The end is in sight. . . . This is the final, tearful farewell. We look at where
    to go next in your continuing study of code craft. This book is just the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 22. RECIPE FOR A PROGRAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Code Development Methodologies and Processes*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: They always say time changes things, but you actually have to change them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: --Andy Warhol
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredients**'
  prefs: []
  type: TYPE_NORMAL
- en: 1 bunch programmers (preferably fresh)
  prefs: []
  type: TYPE_NORMAL
- en: 1-2 tsp language
  prefs: []
  type: TYPE_NORMAL
- en: 1 target platform
  prefs: []
  type: TYPE_NORMAL
- en: 1 project manager
  prefs: []
  type: TYPE_NORMAL
- en: 1 pinch luck
  prefs: []
  type: TYPE_NORMAL
- en: 1 sachet dehydrated training
  prefs: []
  type: TYPE_NORMAL
- en: Various industry buzzwords
  prefs: []
  type: TYPE_NORMAL
- en: '**Instructions**'
  prefs: []
  type: TYPE_NORMAL
- en: Marinade programmers in training. Add language, target platform, and season
    with project manager. Stir briskly until well mixed. Add buzzwords to taste. Sprinkle
    evenly with luck and leave to cook in a hot software oven until deadline. Remove,
    tip onto wire rack, and allow to cool before handing on to customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'I know at least four recipes for sponge cake. They vary depending on whether
    you want a fat-free or an egg-free cake and also on the method you want to prepare
    with. Writing software is like that. There is no one recipe or magic formula;
    the same system could be built in many different ways, with no one necessarily
    better than any other. There are different ingredients that you may choose to
    feed the development process and different methods to follow. Likely as not, they
    will each produce a slightly different cake; different in terms of features, structure,
    stability, extensibility, maintainability, and more. These recipes describe the
    *software life cycle*: the phases of development ranging from the very beginning
    (conceptualizing the software) to its very end (decommissioning it).'
  prefs: []
  type: TYPE_NORMAL
- en: As software engineers, we should be able to predictably (and to some extent
    reproducibly) create software by following a defined procedure. As software craftsmen,
    we should be able to harness a particular development procedure as a tool to help
    fashion the best software possible. In this chapter, we'll investigate some of
    the recipes for creating software; we'll compare, contrast, criticize, and see
    how they affect the way we code.
  prefs: []
  type: TYPE_NORMAL
- en: We programmed a ZX spectrum differently from a modern palmtop PDA, and that
    differently from a mainframe stock control system with a high-capacity web interface.
    We program differently alone than we would working in a pair, and differently
    than we would in a 200-strong worldwide project team. Differences in the target
    platform and development team (and their levels of experience) will shape the
    choice of recipe. The art of programming is much more than just edit, compile,
    link, and run.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Good programmers are aware of* how *they program—the methods and practices
    that shape their work*.'
  prefs: []
  type: TYPE_NORMAL
- en: What are these programming recipes?
  prefs: []
  type: TYPE_NORMAL
- en: Programming Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A programming style describes how a software problem is mapped out and how its
    solution is decomposed and then modeled by the target language. We have to *model*
    a solution, since useful systems can't be entirely held in the mind of a single
    developer. The programming style shapes how we split a project up into manageable
    pieces; it is the design paradigm used to express your code's intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different programming languages support different programming styles. Some
    are tailored to a specific one; some cater for a number of them. The programming
    styles fall into two main camps: *imperative* and *declarative*.'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative (or procedural ) languages allow you to specify the explicit sequence
    of steps to follow to produce the program's output. It's what most programmers
    are used to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative languages describe relationships between variables in terms of inference
    rules (or functions), and the language executor applies some fixed algorithm to
    these rules to produce the result. (This description might turn into understandable
    English once when we take a look at functional and logic programming.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programming language you choose will go some way to determine the style
    you design with. (However, it would be better to select a language that supports
    the style you want to use.) The programming language is not the ultimate determinant,
    though. It is perfectly possible to build structured code in an object-oriented
    language, in the same way that it is possible to write hateful code in any language.
    The next few sections describe the popular programming styles.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This common imperative design method applies *algorithmic decomposition*—a
    process of breaking a system into parts, each of which represents a small step
    in the larger process. Design decisions focus on the flow of control and create
    a hierarchy of functional structure. As Dijkstra observed, "Hierarchical systems
    seem to have a property that something considered as an undivided entity on one
    level is considered as a composite object on the next lowest level of greater
    detail: as a result, the natural grain of space or time that is applicable at
    each level decreases by an order of magnitude when we shift our attention from
    one level to the next lower one. We understand walls in terms of bricks, bricks
    in terms of crystals, crystals in terms of molecules, etc." Indeed, it was Dijkstra''s
    seminal paper "Go To Statement Considered Harmful" that popularized structured
    programming. (Dijkstra 68)'
  prefs: []
  type: TYPE_NORMAL
- en: Structured programming is a control-centered model and follows a top-down design
    technique. You start with the whole program in mind (e.g., `do_shopping`). Then
    you decompose it into sequential sub-blocks (e.g., `get_shopping_list`, `leave_house`,
    `walk_to_shop`, `collect_items`, `pay_at_checkout`, `return_to_house`, `put_shopping_away`).
    In turn, each sub-block is decomposed until it is at a level that can be easily
    implemented in code. The blocks are assembled into a whole, and the design is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implications of a structured approach are:'
  prefs: []
  type: TYPE_NORMAL
- en: Each step of the decomposition should be within the programmer's intellectual
    understanding. (Dijkstra said, "I now suggest that we confine ourselves to the
    design and implementation of intellectually manageable programs.")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control flow should be carefully managed: Avoid the dreaded `goto` statement
    (an unstructured jump in the code to some arbitrary place), and instead prefer
    functions to have a single entry and single exit point (this is known as *SESE
    code*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping constructs and conditional statements are used within functional blocks
    to provide code structure. Short-circuit jumping out of the middle of a loop or
    from within a nested block of code is held in similar disdain to `goto`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common structured programming languages are C, Pascal, BASIC, and more venerable
    languages like Fortran and COBOL. Most other imperative languages can be easily
    used to write structured code, although it's not their design specialism; structured
    programmers often adopt new fashionable languages without adopting new idioms.^([[1](#ftn.CHP-22-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Booch describes OO programming as "A method of implementation in which programs
    are organized as co-operative collections of objects, each of which represents
    an instance of some class, and whose classes are all members of a hierarchy of
    classes united via inheritance relationships." (Booch 94) It is another imperative
    style, but one that allows us to more naturally model the world in our code designs;
    we focus on the interacting entities being modeled rather than on the notion of
    a particular flow of execution.
  prefs: []
  type: TYPE_NORMAL
- en: This is very much a data-centred model (as opposed to structured programming's
    process-centric view). We think about the life of our data and how it moves about,
    rather than the sequence of steps that need to be taken to get the job done. Objects
    (the data) have behavior (they do things) and states (which change when they do
    things). This is implemented at language level by *methods* on *classes* of *objects*.
    We think of OO programs as sets of collaborating software components, rather than
    as monolithic lists of CPU instructions. OO design has allowed us to effectively
    model larger systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-oriented programming exploits the following computer science concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**'
  prefs: []
  type: TYPE_NORMAL
- en: The art of selective ignorance—abstraction allows us to design code so that
    the higher levels of control can ignore gory implementation details below. Who
    cares whether `get_next_item` does a binary search in a list, indexes an array,
    or makes a phone call to Frankfurt? It returns the next item (whatever that is),
    and that's all the calling code has to care about.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's earlier exposition of hierarchy—go back and read it again—revealed
    a form of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encapsulation is the placing of cohesive units of execution into one tightly
    bound package that can only be accessed through a well-defined API: a code capsule.
    Users of that capsule can only call the defined API and cannot tinker directly
    with internal state. This provides a clear separation of concerns, helps us to
    reason about metaphysical questions like *What is an object?* and provides some
    assurance that no evil programmer can tinker with your innards when you''re not
    looking.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: A mechanism to create an object type that is a specialized version of a parent
    object. Consider a parent type called `Shape`, with inherited child types `Square`,
    `Circle`, and `Triangle`. The inherited types provide more detail, specializing
    behavior (for example, knowing the exact number of sides the shape has). Like
    any other programming concept, inheritance can be abused to create unfathomable,
    surprising programs or leveraged to create logically sound, elegant code. Good
    OO programmers know how to create appropriate inheritance hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism**'
  prefs: []
  type: TYPE_NORMAL
- en: This allows the same code to use different underlying data types (what most
    OO programming languages call *classes*) depending on the context in which it
    runs. This technique emphasizes programming to explicitly defined interfaces,
    not to an implicit implementation—polymorphism provides a clear separation of
    concerns as you write code. There are two types of polymorphism, *dynamic* and
    *static*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic polymorphism, as the name suggests, determines the actual operation
    to be performed at run time, based on the type of an operand or target object.
    This often exploits inheritance hierarchies: a client that deals with `Shape`
    types might currently be using a `Square` or a `Triangle` object—which one is
    figured out at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static polymorphism determines the exact code to be run at compile time. Language
    features that provide static polymorphism include: *function overloading* (functions
    with the same name accept different parameter lists—the compiler deduces the correct
    function to invoke from the arguments supplied), *operator overloading* (where
    you can define certain operations on types—including +, !=, <, and &—these functions
    are called when the types of operands match), and *generic programming facilities*
    like C++''s *template specialism* (where you can overload a template based on
    the template parameter type).'
  prefs: []
  type: TYPE_NORMAL
- en: These facilities are all possible to use in non-OO languages, using non-OO practices.
    However, OO languages express them directly and OO designs exploit them to create
    a cohesive system.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming started with Simula around 1970 and has been recently
    popularized by C++ and Java. One of the few pure OO programming languages is Smalltalk.
    These days, OO is en vogue, and there are many OO languages; a number are structured
    languages with fashionable OO bolt-ons.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a declarative programming style based on typed *lambda calculus*, a
    more mathematical model of programming. You work with values, functions, and functional
    forms. Functional programs are generally compact and elegant, although seldom
    compiled. They are therefore reliant on a language executor. The program's performance
    is governed by these executors—they can be quite slow and memory hungry.^([[2](#ftn.CHP-22-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: The structured and OO styles are far more popular in mainstream use than any
    declarative languages, although that doesn't diminish the usefulness of this breed
    of programming. They have different strong points and uses. Functional programs
    require a totally different approach to code design from the procedural methods.
  prefs: []
  type: TYPE_NORMAL
- en: Common functional programming languages are Lisp (although it does contain nonfunctional
    elements), Scheme, ML, and Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Logic Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another declarative style, in which you provide the executor with a
    set of axioms (rules) and a goal statement. A set of built-in inference rules
    (over which the programmer has no control) are applied to determine whether the
    axioms are sufficient to ensure the truth of the goal statement. Program execution
    is essentially the proof of the goal statement.
  prefs: []
  type: TYPE_NORMAL
- en: Interest in artificial intelligence was a huge boost to the development of logic
    programming languages. They are widely used for automatic theorem proving and
    in *expert systems* (which model large problem domains and generate specific answers
    based on the amassed body of knowledge).
  prefs: []
  type: TYPE_NORMAL
- en: The best known logic programming language is Prolog.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-22-FN-1)]) This is not necessarily a Bad Thing, unless the programmer
    believes that he's moved beyond structured coding without changing the way he
    designs code.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-22-FN-2)]) This is not a problem solely encountered by declarative
    languages (for example Java has an executor, the JVM). However, comparatively
    less optimization effort has gone into the declarative breed of language executors—they're
    more often backed by academic institutions than wealthy corporations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recipes: The How and the What'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different aspects we''ll investigate. Software "recipes" employ
    a *development process* and also a *programming style*. The two are separate and
    connected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is the larger picture: It describes the steps taken to construct
    software. This encompasses the *entire* development organization, not just the
    programmers. Most software construction is not a one-person job; the process explains
    how to get a number of people to build a coherent whole. Or at least, it should
    attempt to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The programming style is the smaller picture: It is an underlying approach
    for dissecting, building, and gluing software components together. It will quite
    likely be influenced by the choice of development process, but doesn''t have to
    be.^([[3](#ftn.CHP-22-FN-3)]) It''s more likely to be influenced by a target language
    or the designer''s prior experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll see both of these construction aspects called methodologies, so it's
    easy to get them confused.^([[4](#ftn.CHP-22-FN-4)]) We'll look in turn at styles
    and then development processes. It's important to have a grasp of the different
    development methods out there, to give you a better programming worldview and
    to help you choose a process, should you ever have the opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Our software development efforts are molded by the* styles *and* processes
    *we employ. These have an inevitable effect on the shape and quality of our code*.'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections do not provide a textbook description of these topics;
    they provide a suitably hand-wavy overview to help us compare and contrast. If
    you want or need more detail, you can easily find a hard-core software engineering
    textbook.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-22-FN-3)]) For example, OO styles are often picked in "iterative
    and incremental" processes; this is mostly by convention. (If you don't know what
    this means, *don't panic*! It will all be explained in "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432.)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-22-FN-4)]) If you want to make a distinction, then what I call programming
    styles are often called methodologies (with a lowercase m). Development processes
    are often called Methodologies (with an uppercase M ); a kind of high-church/low-church
    classification. That's far too subtle. In this chapter I'll stick to styles and
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Development Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are as many development processes as there are people who feel like inventing
    them. Many are slight evolutions of one or two basic development models. We'll
    look here at those basic variants. Some of them are closely related, as you will
    see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your choice of development processes determines how projects are planned, how
    work flows between phases, and how the project team interacts. Processes vary
    along a number of axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thick/thin**'
  prefs: []
  type: TYPE_NORMAL
- en: A *thick development process* is heavyweight and bureaucratic. It generates
    a lot of paperwork, regiments developer behavior, and presumes a certain team
    structure. It's characterized by the ISO 9000 organizational model, where every
    work procedure is slavishly written down in great detail, without regard for whether
    the process is flawed or appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the process spectrum, *thin development processes* eschew
    unnecessary bureaucracy, favoring leaner, people-centric principles. Agile processes,
    described in "[Agile Methodologies](ch22s03.html#agile_methodologies "Agile Methodologies")"
    on page 433, are built around thin practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequencing**'
  prefs: []
  type: TYPE_NORMAL
- en: Some development processes sensibly recognize that the world is not a predictable
    place and attempt to model and plan for this by running a number of iterations
    around a process loop. This provides an opportunity for the developers to incorporate
    feedback from one iteration into the work of the next. They can adapt to the natural
    changes that occur as software develops (changing customer requirements, unexpected
    problems encountered, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Other processes are more regimented and linear—predicting a formal progression
    of development from one phase to the next. They involve heavy up-front planning
    efforts and try to foresee the future in great detail. These predictions make
    it hard to change direction late in development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design direction**'
  prefs: []
  type: TYPE_NORMAL
- en: A *top-down design* creates the system from an initial undetailed overview.
    Each top-level package is refined and split into subcomponents. This process iterates
    until the software is specified sufficiently to begin work. Top-down design emphasizes
    planning and a good understanding of the final system, and presumes that few requirements
    change en route.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite, *bottom-up design*, specifies individual parts of the system in
    detail and then determines how best to connect them to form a cohesive whole.
    This helps us to leverage existing software components in a new design. Modern
    processes tend to blend these two polar opposites—some idea of the entire system
    is required to begin initial planning, then the design progresses by identifying
    and coding low-level components and objects.
  prefs: []
  type: TYPE_NORMAL
- en: No one style of development process is better than any other. Extreme religious
    views are held about the correct position on any one of these axes. The correct
    methodology for any project is determined by a number of factors, including the
    development culture of the organization, the type of product being developed,
    and the experience of the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Now please buckle your seat belts for our roller coaster ride through the range
    of software development processes. Hold on tight.
  prefs: []
  type: TYPE_NORMAL
- en: Ad Hoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a starting point, but it's really an anti-process. Here there is no
    process, or else it is undocumented. Everybody works to his or her own agenda,
    no one knows what anyone else is doing, and hopefully something useful will drop
    out at the end. Perhaps your team works like [Figure 22-1](ch22s03.html#engineering_a_release
    "Figure 22-1. Engineering a release")?
  prefs: []
  type: TYPE_NORMAL
- en: If an organization doesn't know how it builds software, then it's in an unforgivable
    state, even if it's a small outfit and it doesn't think it needs a process. In
    this state, there is no guarantee that the software will be delivered on time,
    since there's no accountability. Who can guarantee that all the features will
    be implemented?
  prefs: []
  type: TYPE_NORMAL
- en: A lot of open source software is created using this chaotic method.^([[5](#ftn.CHP-22-FN-5)])
    If you have an infinite number of monkeys and an infinite number of computers,
    you might eventually get a program out—however it isn't feasible to wait the requisite
    infinite amount of time. Even back-of-napkin designs are a step toward a more
    formal, predictable development process.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Without a development process, your team is in a state of anarchy. Your software
    will be produced by luck, not on purpose*.'
  prefs: []
  type: TYPE_NORMAL
- en: This case is development anarchy. Individual programmers may work hard, and
    their heroic efforts might eventually produce something of value. Such an outcome
    cannot be seriously relied upon, though. The team is likely to be very inefficient
    and will probably never deliver anything of value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Engineering a release](tagoreillycom20080909nostarchimages207578.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 22-1. Engineering a release**'
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *waterfall model* is the classic software development life cycle model.
    It has been much criticized for its simplicity (even for being old fashioned).
    However practically every other development process is in some way based on it.
    It has numerous flaws, and yet it is still an instructional starting point in
    process study. It's modeled after a more conventional engineering life cycle and
    was described by W.W. Royce in 1970\. (Royce 70) It's the most predictive of the
    development processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**STAGES OF DEVELOPMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: The waterfall model describes five stages in the life of a software development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Many other processes identify the same phases but order them differently or
    change their relative emphasis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirements analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the requirements for the software project are established. This scopes
    its goals, the services it will provide, and what constraints it needs to work
    within. This step is often preceded by a feasibility study to kick the project
    off, or feasibility is done at the same time. The feasibility study asks questions
    like: *Will this project work? Should we develop this software? What are the alternatives?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design and specification**'
  prefs: []
  type: TYPE_NORMAL
- en: The established requirements flowing from the first stage are converted into
    software or hardware requirements. The software requirements are then transformed
    into a form that can be readily implemented in a computer program, perhaps by
    splitting into separately developed components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the programs are created. Each program or subcomponent is a unit,
    and is unit tested. The unit test ensures that each unit meets its specification
    as defined in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration and testing**'
  prefs: []
  type: TYPE_NORMAL
- en: All units are combined and the whole system is tested. We test that the code
    integrates correctly, that the entire system behaves as it should, and that it
    implements all system requirements. When successfully tested, the software is
    considered complete.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the product is delivered. We should never presume software is finished
    when it ships; it is naïve to do so. The largest phase of the software lifecycle
    is *maintenance* (see "[Maintenance of Existing Code](ch15s05.html#maintenance_of_existing_code
    "Maintenance of Existing Code")" on page 288). There will be bugs to fix, unnoticed
    requirements to accommodate, evolution of the original requirements, and other
    product support work for software deployed in the field.
  prefs: []
  type: TYPE_NORMAL
- en: It is a simple idea; the development process is broken up into a number of stages,
    which run one after the other. This is likened to a waterfall because of the steady,
    irreversible flow from one stage to another. Just as water always flows downward
    toward the river, the development always flows downward through each stage toward
    release.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional waterfall model is shown in [Figure 22-2](ch22s03.html#the_traditional_waterfall_model
    "Figure 22-2. The traditional waterfall model").^([[6](#ftn.CHP-22-FN-6)]) You
    can see the five standard stages; these are described in the "[STAGES OF DEVELOPMENT](ch22s03.html#stages_of_development
    "STAGES OF DEVELOPMENT")" text box. Once a stage is successfully completed, progression
    is made via some *gating process* (usually a review meeting) to the next stage.
    The output of most stages is a document; a requirements specification, a design
    specification, or something similar. If the review finds an error or problem,
    it is fed back upstream, setting that stage back again.
  prefs: []
  type: TYPE_NORMAL
- en: Following this model, you can't easily backtrack to make changes; it's like
    a salmon expending massive amounts of time and energy swimming back upstream.
    While salmon are genetically programmed to do this, programmers aren't. This means
    that the process is not helpful when changes are made late in the development
    process. The requirements must be fixed before system design, and it is difficult
    to accommodate too many alterations after the process is underway. Generally,
    problems at the design stage are not discovered until system testing.
  prefs: []
  type: TYPE_NORMAL
- en: In its defense, though, it is simple to manage—at least conceptually—and is
    the basis for most other development models. The waterfall doesn't scale well
    to very large projects; it works fine for a two-week project. Other development
    models exploit this by running many, smaller, waterfalls over the life of a large
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '![The traditional waterfall model](tagoreillycom20080909nostarchimages207580.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 22-2. The traditional waterfall model**'
  prefs: []
  type: TYPE_NORMAL
- en: SSADM and PRINCE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although *SSADM* sounds like development only partaken by consenting adults,
    it actually stands for *Structured Systems Analysis and Design Methodology*. It
    is a structured and rigorous method following the waterfall approach, perhaps
    the most regimented waterfall variant you'll encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It covers analysis and design, not implementation and testing, and is a well-defined
    open standard, heavily used in UK government organizations. SSADM consists of
    five main steps (each subdivided into many other procedures), which for our purposes
    are self-descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: Feasibility study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical system specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Projects In a Controlled Environment (PRINCE)* and its imaginatively named
    successor, *PRINCE2*, were created in 1989 and 1996 to supercede SSADM. Like SSADM,
    they define a heavyweight, document-centric model. They list regimented steps
    (this time in eight separate phases) that can be followed to produce a product,
    aiming to meet identified requirements and quality standards.'
  prefs: []
  type: TYPE_NORMAL
- en: V Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This process model derives from the classic waterfall and was developed to regulate
    the software development process within German administration and military. It
    shares much in common with the waterfall model (including a propensity to attract
    criticism) but rather than model the processes as a cascade, it is visualized
    as a *V*, as shown in [Figure 22-3](ch22s03.html#the_v_model "Figure 22-3. The
    V model").
  prefs: []
  type: TYPE_NORMAL
- en: '![The V model](tagoreillycom20080909nostarchimages207582.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 22-3. The V model**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left, we see the development phases leading up to software construction:
    the planning, design, and implementation work. The right-hand stream governs testing
    and approval.^([[7](#ftn.CHP-22-FN-7)]) Each level of test work is measured against
    the specification generated from the corresponding left-hand phase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The V model''s difference from the waterfall is more than the orientation of
    a diagram. The testing phases (in the right branch) can begin in parallel to the
    development work (the left branch), and are given an equal importance. This is
    good because:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, testing is squeezed out during the dying stages of a slipping
    project. This is dangerous. Emphasizing testing as a keystone of the development
    process highlights this fact and helps to ensure product quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should always test more than the final software: reviewing and validating
    at *all* stages of development work, from the requirements specification through
    to the completed software. The V model highlights this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Real World, testing and bug fixing often take up more than half of a
    project's total time. The waterfall model doesn't accurately reflect this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This model can shave time from the entire development process, since the test
    plans can be drawn up as soon as each development phase is complete. This streamlined,
    parallelized work will bring forward the project's end date because we don't need
    to wait for the waterfall's implementation phase to end before beginning test
    activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite our many years of research and experience in software development processes,
    the waterfall is still a standard reference model since it has a clear logic to
    it—you obviously can't perform useful implementation before requirements analysis
    or any design work. However, the waterfall makes it hard to evaluate a software
    system until development is complete. It is also hard to demonstrate the software
    to your customer until the integration phase has completed and the system is ready
    to alpha test.
  prefs: []
  type: TYPE_NORMAL
- en: The *prototyping approach* attempts to work around this limitation. It helps
    to explore and evaluate implementation as development progresses and to refine
    unknown or ambiguous requirements (users never know what they *really* want).
  prefs: []
  type: TYPE_NORMAL
- en: The essence of the prototyping process is to create a number of throw-away prototypes
    of the software system. Each prototype is evaluated, shown to the customer, and
    customer feedback is used to shape the next prototype. This continues until enough
    is known to develop and deploy the real product.
  prefs: []
  type: TYPE_NORMAL
- en: We see an analogy with other industries here. If you were developing a new car,
    you'd create many prototypes until you hit on exactly the right design. We aim
    to do the same with our software. However, there is an important difference that
    must be observed. When building a car, the major cost is in the manufacturing,
    not the development. It works the other way around with software. You can make
    multiple copies of the code for free; the development is the costly part. For
    this reason, the prototyping cycle needs to be controlled; it can't be repeated
    an unlimited number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROTOTYPE BLUES**'
  prefs: []
  type: TYPE_NORMAL
- en: Releasing prototypes can cause severe maintenance problems.
  prefs: []
  type: TYPE_NORMAL
- en: I did some work for a company that had a policy of only using one GUI library
    for its Java front ends. But in practice, it had some systems that used the library
    and some that didn't. Whenever a bug cropped up, the maintenance programmers had
    to jump through hoops to work out what the front end code was doing. They didn't
    understand the other GUI libraries, and often their fixes introduced yet more
    problems. The more this happened, the less respected the company's products became.
  prefs: []
  type: TYPE_NORMAL
- en: 'It didn''t take much software archeology to discover the cause of this problem:
    The front ends that didn''t use the correct GUI library had been prototypes that
    "accidentally" became products. A little time spent releasing correct code would
    have saved months of work later on and wouldn''t have destroyed the company''s
    reputation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototypes are developed quickly in very high-level languages. Sometimes
    they are simply drawn: The use of automated tool support^([[8](#ftn.CHP-22-FN-8)])
    can speed prototype production immensely. The prototypes are proofs-of-concept,
    so efficiency, stability, or a complete feature set are not primary concerns.
    For this reason, prototyping works best for systems with an emphasis on the user
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes help us to manage risk. We can use them to ensure that customers
    really do want what they *say* they want. We can also use prototypes to explore
    the use of a new technology or to check that our design decisions will stand up
    to real use.
  prefs: []
  type: TYPE_NORMAL
- en: The danger with prototyping is the temptation to continue developing the inefficient,
    quickly produced, not fully thought-out prototype code into a real release. This
    is especially true when a project is running out of time and the real development
    might not fit the schedule. Without education, customers will confuse the prototype
    with the finished product and be surprised that it takes a lot longer to receive
    their completed software. It needs very careful management to work. The best way
    to avoid this problem is to leave your prototypes deliberately rough around the
    edges, and to never get them near a releasable state. A prototype that has too
    much functionality is not a prototype!
  prefs: []
  type: TYPE_NORMAL
- en: Iterative and Incremental Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the recent advances on the waterfall approach are basically variations on
    a theme. The major improvement is performing development in an *iterative and
    incremental manner*. That is, many trips (iterations) around a small development
    life cycle run back to back (incrementally), with each cycle adding more and more
    functionality to the system until it is complete. Each single run of a mini lifecycle
    tends to follow the waterfall model and may last a number of weeks or months (depending
    on the scale of the project). Each phase of the waterfall therefore gets executed
    more than once. At each iteration end is a software release.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental development is neither a top-down nor a bottom-up approach. A complete
    version of the code is created for each code release, with all requisite high-
    and low-level components. During each iteration, the system grows, and subsequent
    design work can be done based on the existing design and implementation. There
    is a parallel to prototyping here, but we're not so focused on quick demonstrative
    hacks. With this approach each stage is less complex and easier to manage—and
    process progress is more easily monitored; you know how much of the system is
    built and integrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of process works well for projects whose requirements are less understood
    at the start. Let''s face it: That encompasses most projects in the Real World.
    It is more resilient to change, and it saves the lengthy redesign and reimplementation
    of the entire system that you''d encounter in the waterfall approach. Iterative
    and incremental development works well because it fits the fundamental nature
    of software development, it consequently helps us to better control the inherent
    chaos. Because iterative cycles are much shorter, there is greater opportunity
    for feedback and correction; you don''t have to wait until the end of your project
    to find out that it''s failing.'
  prefs: []
  type: TYPE_NORMAL
- en: Spiral Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *spiral model*, proposed by Barry Boehm in 1988 (Boehm 88), is a good example
    of the iterative and incremental approach.^([[9](#ftn.CHP-22-FN-9)]) The development
    process is modeled as a spiral, like [Figure 22-4](ch22s03.html#the_spiral_model
    "Figure 22-4. The spiral model"). It starts in the center and fans outward toward
    the later stages of the process. We start working on a very rough notion of the
    system, becoming more detailed over time, as we enter later stages of the spiral.
    Each 360-degree turn of the spiral sees us go through a single waterfall, and
    each iteration typically lasts six months to two years.
  prefs: []
  type: TYPE_NORMAL
- en: Features are defined and implemented in order of decreasing priority; the most
    important facilities are created as soon as possible. This is a way of managing
    risk; it's safer because as you inch toward the ship date, you can be sure that
    the majority of the system is complete. In fact, it is very pragmatic approach;
    the programmers will not be spending 80 percent of their time on the trifling
    (but fun) 20 percent of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![The spiral model](tagoreillycom20080909nostarchimages207584.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 22-4. The spiral model**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boehm splits the spiral into four quadrants or four distinct phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective setting**'
  prefs: []
  type: TYPE_NORMAL
- en: Specific objectives for this phase are identified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Risk assessment and reduction**'
  prefs: []
  type: TYPE_NORMAL
- en: The key risks are identified and analyzed, and information is sought to reduce
    these risks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development and validation**'
  prefs: []
  type: TYPE_NORMAL
- en: An appropriate model is chosen for next phase of development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Planning**'
  prefs: []
  type: TYPE_NORMAL
- en: The project is reviewed, and plans are drawn up for the next round of the spiral.
  prefs: []
  type: TYPE_NORMAL
- en: Agile Methodologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These were developed as a backlash against the bureaucratic and heavyweight
    methodologies that tried to straitjacket the software development process. Agile
    practitioners observed that software development cannot easily be made a predictable
    process; they claim that it is *very* different from the established engineering
    procedures, like constructing a bridge.^([[10](#ftn.CHP-22-FN-10)]) The old-fashioned,
    monumental methodologies only serve to get in the way of people trying to write
    good software, and so they should be thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: '*Agile methodology* is an umbrella term that describes a number of development
    processes, including the much-hyped Extreme Programming, as well as Crystal Clear
    and Scrum. Agile processes focus on nimbleness and risk reduction rather than
    on long-term planning or forcing (pretending to have) predictability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Agile processes share these central tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize risk by performing many small iterative development cycles. The software
    and all process artifacts are complete, consistent, and of releasable quality
    at the end of each cycle. Although the software seldom *is* released, it can be
    passed on to the customer to review and to comment on. This gives the customer
    reassurance of the team's progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile process iterations tend to be much smaller than iterative and incremental
    process loops (typically lasting a number of weeks, rather than months).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Minimize risk by placing far more emphasis on a suite of automated regression
    tests that are run continually, rather than on a lengthy test cycle at the end
    of development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the documentation that plagues heavyweight processes. Agile processes
    view the code itself as the design and as the implementation documentation. Good
    code stands on its own and doesn't need to be lumbered with bureaucratic documentation
    processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasize people and aim to facilitate communication, preferably face-to-face
    rather than through documents. This keeps the customer (or a customer representative)
    as close to the development team as possible, to take part in implementation and
    prioritization decisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider *working software* as the measure of progress and performance, not
    specification writing or a manager's opinion of the team's position in a fictitious
    development cycle. The developers meet problems and respond to changes by modifying
    the code as development progresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agile approach is not always appropriate. It tends to work best on smaller
    projects, with teams of less than 10 high-quality programmers who are geographically
    co-located. Agile processes excel in domains with a high degree of requirements
    change. They are hard to run in companies with a heavy process culture.
  prefs: []
  type: TYPE_NORMAL
- en: Other Development Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other development processes: variations on these themes, each
    with its own distinct features. There are modified waterfall processes that overlap
    certain phases or contain subprojects, managed as mini-waterfalls. The *evolutionary
    prototyping* approach starts with an initial concept, designs and implements a
    prototype, iteratively refines the prototype until it is acceptable, and then
    releases this, perhaps planning to include some throw away prototypes in the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Staged delivery* follows a sequential process up to architectural design and
    then implements the separate components showing them to the customer as each is
    completed, going back to previous development steps if needed. *Evolutionary delivery*
    is essentially a cross between evolutionary prototyping and staged delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: Rapid Application Development (RAD) emphasizes user involvement and small development
    teams, and it makes heavy use of prototyping and automated tools. In a slight
    twist on other processes, the development time frame is established up front and
    considered immovable. Then as many features as feasible are incorporated into
    the design to accommodate the deadline—some features may be sacrificed.
  prefs: []
  type: TYPE_NORMAL
- en: The *Rational Unified Process (RUP)* is a notable commercial methodology that
    stems from Ivar Jacobson's 1987 *Objectory Process*. It's a heavyweight but flexible
    object-oriented process that leans heavily on UML diagrams, with *use case-driven
    design* (a use case describes a single user activity or interaction with the software
    system). It favors iterative development, continuous testing, and careful change
    management. As a commercial process, it is supported by a suite of commercial
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-22-FN-5)]) And there, perhaps, it doesn't matter so much, since
    there's no paying customer and no formal set of requirements—a lot of open source
    software is developed because the programmer feels like it. However, applying
    some development process to ad hoc open source work will almost certainly yield
    better programs.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-22-FN-6)]) This is a common simplicifcation of Royce's original
    paper. Royce *did* allow feedback up the waterfall, but didn't actively encourage
    it. Zealous managers imagined software development to be a strictly linear process,
    and soon removed these upstream paths; the waterfall was tarnished.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-22-FN-7)]) Note how development flows downward, like the waterfall,
    but testing is seen as an uphill effort—a reasonably accurate model of software
    development!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-22-FN-8)]) For example, *Rapid Application Development (RAD)* tools
    with simple GUI builders.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#CHP-22-FN-9)]) Boehm's process wasn't the first iterative model, but
    he was the first to popularize and emphasize the importance of iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[10](#CHP-22-FN-10)]) This is a religious debate: Many programmers believe
    that it *is* possible to make the software development process a repeatable, predictable
    thing, but the industry is currently not mature or disciplined enough to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Enough, Already!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've read this far and haven't gotten bored yet, then you're doing well.
    Finally, and perhaps more importantly, what are the key points to draw from all
    this? A software craftsman has a good working understanding of development processes
    and programming styles, but anyone can get this from the right books. How do we
    apply this stuff usefully to our work? How can it improve our skill set?
  prefs: []
  type: TYPE_NORMAL
- en: All of these processes share some common threads. The phases described in "[STAGES
    OF DEVELOPMENT](ch22s03.html#stages_of_development "STAGES OF DEVELOPMENT")" on
    page 428 are present in each. The processes really only differ in the length and
    relative positioning of these stages. Each activity is vital to the production
    of good-quality software. The better processes ensure that testing is not left
    as an afterthought, but is carried out continuously—and monitored—throughout the
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: It's hard to compare or evaluate the different processes and programming styles.
    Which is best? Which will ensure that a high-quality product is shipped on time
    and to budget? There is no answer, because those are not the right questions.
    Which process is suitable depends on the nature of the project and the culture
    of your company. If you have 20 programmers who know nothing of object-oriented
    development and only ever use C, then trying to build an OO Java product is clearly
    a stupid idea.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You''ll pick a software recipe for a number of reasons—make sure they''re
    good ones. The motivation for your choice of process says a lot about the maturity
    of your organization*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see two procedural extremes: The anarchy of the ad hoc method contrasts
    with the strict regime of a rigid process. In the latter, any experimentation
    that could yield a more elegant architecture is discouraged. The user''s real
    requirements may never filter down to a developer since it''s lost in a sea of
    bureaucracy; the programmer just codes to a specification that''s passed on to
    him from the previous process phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the *Goldilocks prinicple*, the most flexible approach is somewhere
    in between. You *do* need to know the process you're working to and where it's
    defined. Effective development requires discipline; you need a coherent strategy
    to get something out of the door on time (having a realistic schedule is another
    topic in its own right—see "[The Planning Game](ch21s05.html "The Planning Game")"
    on page 409). Experienced programmers know the value of their development processes,
    as well as the faults. They know how to work with it and when to step outside
    it. Good programmers don't just program. They understand their recipes and how
    to adapt them as appropriate. This is why our science is still a craft.
  prefs: []
  type: TYPE_NORMAL
- en: It's important not to be uptight and legalistic about the process you follow,
    but you must have an agreed framework for producing software. It must be appropriate
    for your development team—not every organization needs a high-ceremony process
    with many hoops and hurdles to navigate and lengthy forms to fill in.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The process you adopt doesn''t have to be high-ceremony and hard to follow.
    In fact, the exact opposite characteristics are generally hallmarks of a good
    process. You must have a defined process, though*.'
  prefs: []
  type: TYPE_NORMAL
- en: New methodologies spring up (or rather evolve) from time to time. They tend
    to arrive with a big fanfare and a spurt of fireworks; they're claimed to be the
    silver bullet, the panacea that will make development better for our children
    and our children's children. Sadly, it's never the case. When it comes down to
    it, no matter which life cycle you follow, the programming team is only as good
    as its programmers. If there is no intuition, no flair, no experience, and no
    motivation present then, regardless of the development process you use, you won't
    reliably produce good code. You might be better able to track how far behind schedule
    you are, though.
  prefs: []
  type: TYPE_NORMAL
- en: Pick a Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many factors contribute to a good choice of development process. However, the
    choice is seldom made on sensible grounds; a development process is used because
    *It's the way we always do it*, *It works well enough*, or *It was the first thing
    we could think of*.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know what development method is appropriate? Ultimately, if the process
    works for your team—if you collaborate well and produce good software on time—then
    you have a good development approach.
  prefs: []
  type: TYPE_NORMAL
- en: A good choice of process is based on the type and size of the project. Small
    modifications to an existing codebase don't need a large iterative development
    cycle; three-year industrial projects starting from scratch probably do. A good
    process choice suits the experience of the existing team members, has the developers
    willing (even eager) to use it, and is something that the project manager really
    understands.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, there are plenty of bad reasons to choose a development process.
    There's no point in moving to a new process just because you feel like a change;
    a new process must be introduced to fix a problem with the current development
    model. There's no point in trying to make a political statement (I know people
    who've tried to foster an open development culture, just to swing the organization
    toward open sourcing their internal codebase). The ultimate bad motivation for
    picking a particular process is fashion. More buzzwords do not necessarily mean
    a more useful process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This *is* important: An inappropriate process really can ruin the quality of
    your code; you''ll spend more time pandering to the demands of a procedural straitjacket
    than delivering software. A good process does not get in your way. Indeed, it
    enables your team to create more software, better and faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Process is vital. Most projects fail for nontechnical reasons. And bad process
    is almost always high on the list of reasons*.'
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building software is like crime: It''s better when it''s organized. Every now
    and again, an undisciplined team will pull off something spectacular and create
    a software masterpiece. However, that *is* the exception. The development process
    needs to be defined and understood and carried out by team members with appropriate
    skills to stand a chance of working well. Otherwise, you''ll end up with software
    that''s criminal.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use proven development processes and established design styles to
    allow us to build software that meets expectations against a backdrop of timescales,
    budgets, and changing requirements. Building software is hard—and we've just looked
    at another way to make it easier.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the programming style and development process they are expected to
    work within
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit their development process to shape interactions with other software
    factory inhabitants; when the process becomes constraining, they'll sidestep it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appreciate the pros and cons of different development recipes and can pick the
    appropriate one for any given situation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore development process issues, and attempt to do things their own way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not know how the process shapes their interaction with other developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid thinking about this kind of stuff—*it's for managers to worry about*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a key phase of the development process. Often the pressures of Real
    World deadlines try to squeeze out room for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Teamwork: the cornerstone of large scale software development.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Specifications are often the gates between phases of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207586.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 553.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do the choices of programming style and development process influence one
    another?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the best programming style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the best development process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does each development process listed in this chapter fall on the classification
    axes we saw in "[Development Processes](ch22s03.html "Development Processes")"
    on page 425?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If development processes and programming styles are recipes, what would a software
    development cookbook look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a suitable process, can software construction become a predictable, repeatable
    task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What development process and programming language style are you currently using?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has it been formally agreed upon by the development team, or do you use it by
    convention?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How was it chosen? Was it chosen specifically for this project, or is it the
    recipe you always use?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it documented anywhere?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the team stick to the process? When problems arise and your back is against
    the wall, do you maintain the process, or is all ivory tower theory ignored in
    a rush to produce something—anything?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are your current processes and styles appropriate? Are they the best way for
    you to develop your software right now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does your organization appreciate that there are other development models that
    might be worth investigating?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 23. THE OUTER LIMITS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Different Programming Disciplines*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything that irritates us about others can lead us to an understanding of
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: --Carl Jung
  prefs: []
  type: TYPE_NORMAL
- en: I like sweeping generalizations and tenuous metaphors. Sue me. I've also been
    doing my research. I found that there are over 40 churches in the city I live
    in. Each one of these is subtly different; different types of people attend, and
    they do different things. They have different concerns and ways of working. They're
    located in different areas. However, they're all doing roughly the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: '*What on earth has this got to do with programming?* I hear you ask. If you
    forgive the tenuous link, software development works in pretty much the same way.
    Okay, we don''t all file into a building every Sunday morning (well, most of us
    don''t). But, to outsiders, we do appear to engage in bizarre rituals and invoke
    arcane rites to get our own way with things that are out of the control of normal
    human beings.'
  prefs: []
  type: TYPE_NORMAL
- en: The real comparison I draw, though, is that there is no single way to program,
    no one methodology that solves every problem. There is no one programming language.
    There are different classes of problems to be solved in many, many different arenas.
    The work in each differs by more than mere technology (i.e., which tools and code
    libraries are available); they differ by technique. Each requires a different
    skill set, a particular mindset, and subtly different ways of working. The differences
    might seem slight, but there is no replacement for specific experience of programming
    a particular type of system—if there was, job advertisements for programmers would
    be a lot more vague. It's important to know your field well and to appreciate
    its unique concerns. In a particular programming arena, the craftsman knows how
    to ply his trade, how to work his medium, and how to best use his tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are various types of programming, in different problem domains. Each
    presents its own unique problems and requires specific skills and experience*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll explore this. We'll take a guided tour of the vast field
    that is computer programming, discover some of the common problem domains we program
    in, see how they differ, and learn the particular problems and challenges of each.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these arenas overlap. That's natural. Nothing is ever quite as clear-cut
    as you'd imagine. The following descriptions are necessarily general, since each
    of these is a big field with lots of variations within. Nonetheless, this should
    give you a taste of what's going on out there.
  prefs: []
  type: TYPE_NORMAL
- en: Applications Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is what most non-techies think of when you mention the word *programming*.^([[1](#ftn.CHP-23-FN-1)])
    It's probably the broadest category we'll consider in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is programming *applications*—self-contained programs—typically for single-user,
    workstation-like computers. This world focuses on end users and how they use their
    desktop machines. For commercial reasons, we usually target the mainstream platforms—currently
    Windows and Mac OS. Although you hear a lot about Linux programming these days,
    that's still not where the applications work is (at least, at the time of writing).
    As portable devices become more powerful and their application development environments
    become richer, mobile applications work has moved from the embedded realm (see
    "[Embedded Programming](ch23s04.html "Embedded Programming")" on page 447) into
    this class of more general-purpose applications programming; the specific embedded
    hurdles have largely been removed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many languages and environments for this kind of work; C and C++ are
    common. We also see common use of Visual Basic and Delphi, Java, and .NET, plus
    a number of libraries and frameworks like MFC and Qt. This choice is made according
    to what is convenient for the developers—something that's well-enough known and
    provides all required features.
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications programming has advanced rapidly since the dawn of personal
    computing. We now have rich development environments to work in with helpful framework
    code that automates a lot of tedious boilerplate stuff. We have threading support,
    libraries of standard user interface components, and facilities for network transparency.
    There is a lot of operating system support provided to make applications programming
    easier, but this also means that there's a lot to learn as you get started. You
    have to know a lot to *really* understand what's going on around you.
  prefs: []
  type: TYPE_NORMAL
- en: All this extra support raises the bar to determine what a good application is.
    What was acceptable application behavior years ago is not today. People expect
    high-quality, robust programs, with a standard interface and look-and-feel, good
    responsiveness, user-friendliness (the ability to cope with the most inept user),
    and a plethora of features (even if the user will only take advantage of a fraction
    of them). The huge professional applications marketed today are the results of
    large development teams with departments specifically focusing on usability issues.
  prefs: []
  type: TYPE_NORMAL
- en: We are seeing a move toward web-based systems, applications that run on browsers,
    over a network. We'll look at them separately; this also cuts into the enterprise
    or distributed programming arenas somewhat (see "[Distributed Programming](ch23s05.html
    "Distributed Programming")" on page 450).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main markets for applications programming: shrink-wrap software
    and custom applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Shrink-Wrap Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shrink-wrap software is developed for the mass market. It''s used by a large
    number of people, or at least that''s what the marketing departments are praying
    for. This is key: The market is speculative, so the software has to appeal to
    the broadest cross-section of consumers possible in order to make money. Since
    no customer commissions or pays for the development of shrink-wrap software, you
    must establish a profitable market before you begin work, or else you''re throwing
    away time and effort. The software needs to differentiate itself from competing
    products in terms of features, performance, or a unique approach to the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Shrink-wrap software might be bought over the counter in a box neatly wrapped
    in cellophane (hence the name), or it could be downloaded from the Internet. It
    could even be a subscription-based web service. The key point is the way you sell
    it and how that forces you to develop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Life is hard for shrink-wrap applications programmers. You can''t control the
    environment the code runs in. It must gracefully handle all versions of the operating
    system, on different machine configurations, with different libraries and other
    apps installed, and it has to cope reliably with them all. That''s a testing nightmare!
    Web applications programmers win half the battle (as we''ll see later)—you have
    control over the server deployment. But you still have the headache of browser
    compatibility to contend with: Your web pages must render correctly on a wide
    range of target platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom applications are made-to-order—developed to a specific brief for a specific
    customer. Therefore, the focus isn't so much on an inviting UI, a never-ending
    feature list, or even to get it perfect and bug free. There's no commercial imperative
    to do this. Get it working. Get it shipped. Get the cash. This is a more certain
    business model.
  prefs: []
  type: TYPE_NORMAL
- en: Since a customer commissions this work, it will use this software or use nothing.
    With no real competition, the software only needs to be good *enough*. Given half
    a chance, programmers will keep tinkering and improving their code until it reaches
    some mythical state of perfection. But in this situation, it doesn't make commercial
    sense to do so. It doesn't really matter if the program works fine, but crashes
    once a week; it costs less to restart it periodically than to engage in a lengthy
    bug hunt (assuming that it doesn't trash any data as it goes down).
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: Application work is fun. Modern PCs are powerful, so you don't have to worry
    too much about code size or performance, and you can concentrate on writing neat,
    elegant code. It's a buzz to know your application is used by tens of thousands
    of people around the world. —Steve (applications programmer for a major company)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: Typical shrink-wrap products are desktop applications like web browsers, spreadsheets,
    and so on. Custom software could be anything—a highly tailored inventory management
    system for a large retailer, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: This tends to be the same kind of machine you are doing the development on (more
    often than not, an x86 Windows PC).
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll normally build code on the same workstation you run the program on.
    Modern *integrated development environments* (*IDEs*) provide comfortable working
    environments, bringing the editor, compiler, debugger, and help systems together
    in a single unified point-and-click interface. Many third-party components are
    available to simplify the development of common tasks. The full gamut of lan-guages
    is employed here: from low-level C/C++, through BASIC and Java, to scripting languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Users expect high-quality programs that conform to standard interface principles.
    More features than any person could remember are the order of the day; this is
    a serious commercial requirement, and usually what differentiates one product
    from the next. New product revisions these days tend to introduce more features
    (and bugs) than any problems they might solve. This is what the market demands.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-23-FN-1)]) Which, of course, you don't. Admitting your job at a
    party can be an instant conversation killer. Well, unless it's a party full of
    nerds, in which case you're probably trying to escape, anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Games Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exciting and glamorous world of games programming is a specific form of
    applications work, usually developing shrink-wrap software. A lot of the battle
    is waged with captivating marketing and a very good initial concept for the game
    play. This is a fine line that differentiates a great, successful game from the
    also-rans.
  prefs: []
  type: TYPE_NORMAL
- en: These games often involve first-person, massive, immersive, 3D environments.
    To provide an absorbing experience, the graphics capability of the hardware is
    fully exploited, and the CPU is maxed out managing maps, enemies, and puzzles,
    while performing serious modeling of the physics of moving objects. This must
    all be coordinated in real time and stresses the hardware to its limits. A significant
    portion of games programming is optimizing the code to the execution platform.
    As faster hardware is released, the problem doesn't lessen; to stand out from
    other games, more optimization is required to squeeze a better experience out
    of the new platforms. This field is very much about staying on the cutting edge
    and using the latest state-of-the-art technology to do the coolest thing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: Professional games development is about fun, but it's a hugely competitive industry
    where developers are expected to keep up with the latest technologies, furious
    deadlines, and nonnegotiable, last-minute change requests. Sweat, blood, and tears
    are required to write the software, only for it to meet the harsh public glare
    of a highly critical specialist press. But it can be hugely rewarding—once finished,
    you've made something that people can see, understand, and enjoy.—Thaddeus (professional
    games programmer)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: First-person, immersive, 3D games, strategy games, online puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Desktop PC, games consoles, mobile devices (PDAs and mobile phones), arcade
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated games platforms (including high-end graphics cards in standard PCs)
    have tailored development environments to help exploit their power. It still takes
    very talented developers to fully capitalize on the platform's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Getting excellent game play; balancing features, user response, aesthetics,
    atmosphere, and difficulty. A good game unfolds very much like a story, and draws
    the player in.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is required to capitalize on the execution platform.
  prefs: []
  type: TYPE_NORMAL
- en: Modern games development teams often have a cast more akin to Hollywood movie
    production than to standard bean-counting software. We see teams including graphics
    artists and level designers and the development of storyboards, concept art, and
    proof-of-concept designs.
  prefs: []
  type: TYPE_NORMAL
- en: The software might target a (suitably souped-up) PC platform or dedicated games
    consoles. These machines have specific hardware to accelerate the many graphics
    operations required per second and special tools to help you harness their power.
    Console manufacturers provide development kits (special versions of the hardware
    and tailored software tools) to help you create products, assisting with code
    loading, testing, and debugging, while helping to avoid security features on production
    hardware that would impede development.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplayer games provide richer game play. This brings network collaboration
    into the mix and requires some skill to get acceptable real-time performance out
    of slow Internet connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quality of the ultimate product is determined by the feel of the game play.
    Everything is tweaked until the game feels right: the level design, the physics
    models, the graphics, the color of your underwear. Nothing is sacred. You might
    write the most beautiful code in the world; the program might never crash; it
    might do everything it was specified to do; it might be highly efficient. But
    if it lacks that special spark that makes it a compelling, addictive game, it
    will not be successful. Tricky stuff.'
  prefs: []
  type: TYPE_NORMAL
- en: Systems Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications sit atop rich system libraries: layers of code for networking,
    graphical interfaces, multitasking, file access, multimedia, peripheral control,
    inter-process communication, and more. If applications programmers receive a lot
    of support from the underlying system, then someone''s got to supply that underlying
    system. This is systems programming.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally for workstation machines too, but it's not aimed at the end
    users. Systems software is aimed at the application developer; the public façade
    is a set of APIs to be used by software layers higher up the food chain. Systems
    software is concerned with the low-level logic that interacts with the computer
    at a very basic level, and also middle-level support frameworks that don't interface
    directly to hardware but provide important services to the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Work in this arena typically includes writing device drivers (controlling devices
    such as printers, storage media, output devices, etc.), writing common shared
    libraries and utilities for managing scarce resources, implementing the actual
    operating systems controlling the computer, and providing components such as filing
    systems and network stacks. Even compilers and installation tool suites can come
    under this heading, as they are support services for application programmers and
    are often intimately entwined with the program run-time environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: I wrote the USB stack for a proprietary operating system. I had to understand
    the OS, USB hardware, and the USB protocol, so there was a lot to take in. I had
    to keep up performance so the system worked well. Acting as the middleman, I was
    abstracting the hardware interfaces and providing a neat API for applications
    to use. I had to make this platform agnostic, which added extra complexity.—Dave
    (systems component writer)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems, device drivers, a window manager, or a graphics subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Since every execution environment needs some form of run-time support, there
    is system-level software in almost every electronic device. Systems software is
    required in the smallest embedded device and the largest mainframe computer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Writing device drivers and operating system components tends to screw with the
    computer and make your system unstable, so it's common to develop on one machine
    and run the code on a second system. C is by far the most common language in this
    arena, although some library-level work is done in other languages (C++ is popular,
    as it aims to be a systems-capable language).
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: The key here is stability, since these are foundational blocks of the entire
    computing environment. While an application might crash and have a chance to save
    work and gracefully recover, a device driver rarely has such a luxury; it is required
    to work correctly the entire time it runs. This could be an awfully long time,
    so even small memory leaks can become major problems.
  prefs: []
  type: TYPE_NORMAL
- en: The code must be efficient (enough), both in terms of space and speed, and will
    need to be appropriately tailored to the particular operating environment.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computer technology shows up everywhere in our daily lives, whether we''re
    aware of it or not. We''re constantly using devices and gizmos, from microwaves
    to watches, radios to thermostats. These consumer electronics products require
    software for control and operation. More often than not, this software is invisible
    to the device''s user. It''s not just consumer electronics appliances that contain
    embedded software: Anything with a microcontroller (e.g., laboratory instruments
    or the machines that issue parking tickets) is software driven. We must write
    programs that are embedded in the hardware devices: embedded software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Embedded developers work under tight constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are usually very scarce resources: restricted CPU power and/or strict
    memory limits. Memory limitations concern both ROM (for the program image) and
    RAM (space for the code to execute and to store information). On platforms without
    much capacity, you have to shoehorn a lot of software into the available device
    space. Sometimes this requires quite creative (and heroic) solutions, like decompressing
    program code or data on the fly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The opportunities for user interface are quite limited: how do you pack all
    user interaction into two buttons and an LED? Indeed, there may be no user interface
    at all; there may be no direct interaction with a user—the software is expected
    to just work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These constraints have a profound impact on the nature of the code you write.
    Sadly, in the embedded environment (more than others), we end up sacrificing the
    purity of our code to get something working. Fast code that fits into the device's
    ROM and works is more important than theologically correct but large and slow
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded systems are designed to do one job and to do it reliably. It should
    appear as if the software is not there; the embedded device should just work,
    all the time. Failure is rarely an option; it might physically break the hardware.
    Contrast this to a desktop computer—it's a general-purpose machine. It has to
    be able to word process, play movies, browse websites, read email, manage your
    accounts, and so on. As users, we've been conditioned to accept the odd crash
    and a bit of instability. We'll sacrifice a little convenience for power and flexibility.
    Embedded work is a totally different ballpark.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example is the modern car industry. We see vehicles manufactured with
    many embedded systems, controlling all sorts of things: engine management, ABS
    brakes, safety features like air bags and seat belt pre-tensioners, climate control,
    the odometer, and so on. However, the users (in this case the driver and/or passengers)
    don''t have to be at all aware that there are any microprocessors whirring away
    under the hood. They expect the car to just work. When an engine management system
    fails, the user becomes acutely aware of the software! Think also about mobile
    phones. They are obviously computer-driven devices, but few consumers think of
    them as a computer. We pack a lot of power into these small packages, but there
    are still strict operational limits that the software must work within.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An embedded system is typically the combination of a small computer, some dedicated
    hardware, and either a real-time operating system or a simple controlling program.
    It will have direct control over the hardware on the device. Embedded systems
    are usually made-to-order: developed for specific hardware, for a specific purpose.
    Simple embedded systems have only one piece of software running on them; no highly
    complex threaded programming environments are used—not even an operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is usually stored in firmware, permanently held in a read-only memory
    chip. It is seldom updatable, so it has to work correctly the first time. There's
    no chance to get it wrong and ship a version 1.1\. One simple mistake can render
    your miracle product a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, memory and CPU power have become a lot cheaper as more and more mass
    market devices are created. Embedded environments have become more powerful and
    the constraints are widening. However, there will always be the need for very
    small devices with little horsepower that achieve just what they need to. Just.
  prefs: []
  type: TYPE_NORMAL
- en: You might consider that programming applications for handheld devices like PDAs
    is embedded-level or applications-level work, depending on where you stand.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: I like working near the metal—it really forces you to think about what's going
    on. You need tight code and a good understanding of what the hardware's doing.
    It can be tricky to debug problems, but these challenges are what makes it interesting.
    —Graham (embedded software developer)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: Control software for washing machines, hi-fis, mobile phones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Small, custom-made devices with very limited resources and meager UIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Since you work with custom-made devices, the toolchain is also often custom
    made. Frequently, it's not very advanced at all, compared to the relative luxury
    of the applications programmer. (As the market broadens, we are seeing improvements
    here.) The code is developed in a cross-compilation environment, where the target
    platform is different from host compilation environment. (Clearly you can't compile
    C on a washing machine . . . yet.)
  prefs: []
  type: TYPE_NORMAL
- en: We write specialized software for each specific device. Embedded programming
    almost universally uses C, apart from really low-level work, which resorts to
    assembly code. C++ is making inroads into this area, and ADA has also been used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: There are all sorts of problems you can encounter, largely depending on whether
    you are working with a commodity, off-the-shelf embedded platform or building
    your own. There are issues of real-time programming (for example, timely handling
    of hardware events and interrupts), direct hardware interfacing, and controlling
    peripheral connections, plus tedious low-level concerns like byte endianness and
    physical memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the system is robust, there must be a great emphasis on product testing.^([[02](#ftn.CHP-23-FN-02)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[02](#CHP-23-FN-02)]) Of course any good software development—not just embedded
    work—needs a great emphasis on testing. In all environments, testing tends to
    suffer as it is squeezed out by overzealous marketing and management departments
    who do not really understand the nature of software. However, desktop applications
    can be more easily updated than the firmware in an embedded device.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed systems are comprised of more than one computer. As we'll see later,
    the World Wide Web is effectively a huge distributed system with information being
    stored on many computers across many continents and with applications delivered
    remotely via your web browser. It's not all about web browsers, though. Multimachine
    architectures are used in many situations. Working with and designing distributed
    systems ushers in a whole new world of problems.
  prefs: []
  type: TYPE_NORMAL
- en: You might need to distribute a software system for a number of reasons. Perhaps
    some types of computers are more suited to particular tasks than others. Perhaps
    the system is in high demand, and you can share the workload among many machines
    on a network to improve performance. Perhaps there are physical location restrictions
    for certain machines that mandate distributing the system. Perhaps you need to
    interoperate a new installation with a legacy system or some old hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to design a system that is composed of a number of programs on different
    machines that all work as a cohesive whole. Tied together by a network connection,
    they might be physically co-located in a corporate server room or scattered across
    the globe, communicating over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disparate parts need to be glued together somehow; each of the programs
    needs to communicate, and it is desirable to call functions on remote machines
    as if they were locally linked to the code. This is known as *remote procedure
    call (RPC)*, and such facilities are provided by a number of available *middleware
    technologies*. These act as brokers for data transfer between machines; they describe
    how you discover and talk to services on other machines and how you publish your
    services for other programs to call. Middleware manages the policies involved
    with interoperability: there are security issues (Who''s allowed to call whom?),
    network latency issues (What happens if a remote function call takes too long
    or a computer goes down?), considerations for balancing synchronous remote function
    calls with asynchronous calls, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Some middleware systems employ object-oriented technologies; some take more
    of a procedural approach. The middleware is simply connectivity software and allows
    some degree of platform neutrality. As long as the middleware runs on a given
    platform, the client code shouldn't care what platform it's calling into—it could
    even be a ZX spectrum—the function calls all look the same. Of course, in the
    design of a distributed system, you will select the appropriate hardware for each
    task. It's doubtful you'll see any ZX spectrums hanging around!
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used middlewares are CORBA, the Java RMI, Microsoft's DCOM, and .NET
    remoting. Using these, we split the system between user interface elements, the
    business logic (real workhorse code), and any storage required (e.g., a database
    and query engine). The user interface client may be a GUI program or a web-based
    front end. This is the classic *tiered architecture approach* (described in "[Client/Server
    Architecture](ch14s03.html#client_foreword_slash_server_architecture "Client/Server
    Architecture")" on page 271). We also see the emergence of *web APIs*—communications
    methods for services that use standard web protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '*Grid computing* and *clustered systems* are specific distribution mechanisms
    that help numerical programming work (more on this later), enabling the creation
    of high performance, distributed computational algorithms. Clusters are tightly
    coupled systems; usually all the machines are in the same room, using the same
    hardware and OSes, linked by a specific cluster middleware. Grids are loosely
    coupled; they could be geographically scattered and run heterogeneous environments.
    They communicate via standard web protocols (e.g., HTTP/XML).'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: The Smallpox project, completed in 2003, was a grid computing project to help
    find a cure for smallpox by screening a huge number of potential drug molecules.
    It was a collaboration between scientists, universities, and businesses that identified
    44 strong candidates for treatment of the disease.
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: An online purchase system, splitting work between front-end applications (web
    interface, in-shop kiosk, and/or phone ordering system), business logic (manages
    stock control, implements ordering system and secure billing) and the shared storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Many different computer systems connect via a middleware, almost always sitting
    on top of standard networking protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Many and varied. This will depend on languages used, the nature of each computer
    in the system, and the type of middleware employed. Remotely callable interfaces
    are often defined in some form of interface definition language (IDL) and compiled
    to an implementation language representation that provides all the calling glue
    and provides hooks for each function implementation to be slotted in to.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the correct split of services between computers and streamlining the
    communications involved. This can severely affect the scalability of a distributed
    system. What works for a few transactions per day may not work efficiently for
    100 transactions per minute. This calls for a real need to design carefully. You
    also have to deal with computer availability and cope gracefully if one of the
    computers in the system becomes unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Web Application Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 1990, Tim Berners-Lee created the first HTML browser and server, and the
    World Wide Web was born. Today it is a pervasive technology, and servers can not
    only deliver static pages of information, but they can dynamically create pages
    based on programs running on the webserver. This is a very specific form of distributed
    computing, where the user interface is hosted on a remote client: the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of this kind of application include:'
  prefs: []
  type: TYPE_NORMAL
- en: Online shopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulletin boards, messaging services, and web-based email packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ticket availability and booking systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet search engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most people now use web applications without thought; it's as natural as a local
    word processor. These programs clearly have different characteristics from ordinary
    (so-called *rich client*) desktop applications. There are different things that
    each can do well. Without heroic JavaScript coding, interaction in a browser-based
    application UI is a lot more limited.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: A web app makes you treat the web browser as your OS. All good web developers
    start by learning client-side browser technologies inside out. Then you learn
    to write good server-side code (i.e., fast, concurrent, transactional, distributed,
    and correct). The best thing about the Web is that it is constantly evolving and
    users' expectations are always rising. The bad thing about the Web is that users'
    expectations are always rising and your code never stands still. —Alan (web applications
    programmer)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interactive services that require up-to-date infomation and feedback: ticket
    booking or shopping systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: The back end is a webserver (commonly Apache or IIS). This choice is under your
    control, since you deploy the web app. The clients are web browsers, and there
    are many variants. Each has its own quirks, and you have no control over what
    is used. You have to produce web pages that are compatible with most of these.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: The environment consists of the specific webserver and the applications programming
    language you write the system in, running on that server. Common languages are
    Perl and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Coping with different browsers; scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The web application operational model is different from vanilla applications
    programming—session state is held on a remote machine, which must manage numerous
    simultaneous client connections, storing their state between HTTP interactions
    and gracefully handling clients that stop connecting. To facilitate this, some
    information is stored on the server (e.g., the items each customer is ordering
    are placed in a database) and some on the local client (using web browser *cookies*—nuggets
    of stored session state—to record the current user/session ID). Frameworks like
    ASP.NET and Java Servlets exist to speed web application development. Numerous
    off-the-shelf systems exist, such as content management systems and shopping cart
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Many open standard protocols and encoding systems are used to represent and
    transfer information. HTTP is the common data transfer mechanism, and XML is often
    used to encode data packets (e.g., SOAP is a web-based communication protocol
    based on an XML schema).
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems faced by web application programmers mainly revolve around interoperability
    with the many types of browsers that might be used, handling their HTML peculiarities
    and their odd JavaScript quirks. It''s not unusual to develop tortuous HTML output
    to cope with all manners of flaws in the popular browsers. Web programmers often
    have to interface with legacy systems (customer databases, existing order management
    systems, etc.) to generate their information; this can get quite messy. Scalability
    is a real concern: A system might work fine when tested by five simultaneous users.
    But when it goes live, it must withstand 500 users accessing it at the same time.
    *Load testing* is important here (see "Load testing" on page 139).'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enterprise* is one of those tedious buzzwords that floats around, more management-speak
    than any programmer dialect. An enterprise is literally a business organization.
    So enterprise programming provides systems for entire companies, gluing all their
    separate systems together to form a unified, cohesive whole. Enterprise programming
    almost always means the development of large distributed systems.'
  prefs: []
  type: TYPE_NORMAL
- en: They'll commonly be deployed on a company intranet (internal network) and link
    the different departments of the business together to improve workflow. The systems
    may or may not be customer facing. Once the organization is running an integrated
    computer system, it's generally not too hard to have automated customer interaction—for
    example, through a web-based shop interface. Perhaps an enterprise system will
    need to interface to other companies' systems too, to track the delivery status
    of goods being shipped, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise programming shares a lot of characteristics with made-to-order applications
    software. The product only really needs to be good *enough*, since it's developed
    under contract for a specific customer, rather than speculatively for a general-market
    release. Quality here is not the measure of success (at least as determined by
    general stability and a larger feature set than any competitor); meeting the customer's
    objectives is.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise systems are written for installation on specific machines in a company's
    server room or on locked-down desktop machines. You have reasonable control over
    the execution environment, so you don't need to worry about making the code work
    on every release of the operating system and under every conceivable hardware
    configuration. This deftly sidesteps a lot of the headaches that applications
    programmers suffer.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: I work in the IT department of a large city bank. We write software to solve
    specific business needs. It's mission critical; what we do makes a real difference
    to the company's profits, so we have to take it seriously. With many thousands
    of dollars going through the system every hour, there's no room for error.—Richard
    (Enterprise programmer)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: Business systems for an entire company, managing its commercial operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: A tailored distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Same as for distributed systems. We'll probably be working with huge data stores,
    perhaps various database technologies from previous internal systems (legacy systems
    in manager-speak). XML is all the rage here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Same as for distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This kind of work involves scientific, highly technical tasks making heavy use
    of mathematics. This is a very specialized area that requires writing applications
    specifically targeted at particular numerical problems. The programs are often
    aimed at supercomputers, the fastest type of computers, capable of massive number-crunching
    operations. Although we're living in times when the fastest computer changes from
    year to year, these are very expensive platforms, employed for specialized applications
    that require immense mathematical calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Weather forecasting, for example, requires a supercomputer (or perhaps a gift
    of prophesy!). We also see supercomputers used for animated graphics, fluid dynamic
    calculations, and other areas that require highly complex mathematical investigation
    and calculation.
  prefs: []
  type: TYPE_NORMAL
- en: A supercomputer is not a mainframe. The latter is a high-performance computer
    designed to concurrently execute as many programs as possible, often used as a
    centralized computing resource in a business setting. A supercomputer channels
    all its power into executing a few programs as fast as possible. There are a number
    of different supercomputer architectures exploiting different technological advances,
    each requiring different algorithmic approaches to fully exploit their power.
    General-purpose machines are now becoming powerful enough for serious numerical
    work—clustered, they can respectably make a poor man's supercomputer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerical work requires high-performance algorithms that execute calculations
    rapidly, to capitalize on the performance of the computing platform. It is common
    to make use of carefully designed, heavily optimized numerical libraries and to
    make explicit use of parallel processing, designing this into the computational
    algorithms and processes. This will involve both task and data parallelism: either
    performing many similar tasks on many CPUs at once or pipelining the algorithm,
    performing different parts of it on different CPUs.'
  prefs: []
  type: TYPE_NORMAL
- en: This branch of programming requires heavy optimization to the characteristics
    of the target platform to achieve acceptable performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE RUNDOWN**'
  prefs: []
  type: TYPE_NORMAL
- en: I work on software systems for an engineering firm. We model large mechanical
    installations to figure out where physical problems might lie now or in the future.
    I have to represent the real world in a mathematical way, figuring out how things
    (should) work. Once I've done this, it's a case of finding the right mathematical
    constructs to represent the systems in an acceptable, accurate way.—Andy (Numerical
    programming expert)
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical products**'
  prefs: []
  type: TYPE_NORMAL
- en: Fields involving highly complex mathematical investigation like nuclear energy
    research or petroleum exploration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Supercomputers or grid-based computing clusters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is work on advancing numerical programming support in C++, and
    some of this work is performed in C, a lot of numerical programming is done in
    Fortran, which has excellent numeric support (that was what it was designed for:
    formula translation).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common problems and challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Crafting efficient algorithms to really exploit the power of the supercomputer.
  prefs: []
  type: TYPE_NORMAL
- en: So What?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Freedom from the desire for an answer is essential to the understanding of a
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: --Jiddu Krishnamurti
  prefs: []
  type: TYPE_NORMAL
- en: 'How do these programming niches affect us? What do they make us do differently?
    To be a good programmer, a true craftsman, you must know:'
  prefs: []
  type: TYPE_NORMAL
- en: What your discipline is—the kind of software you're producing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the discipline affects your architecture. (Is it a tiered enterprise system
    or tightly woven ball of embedded code? See [Chapter 14](ch14.html "Chapter 14. SOFTWARE
    ARCHITECTURE").)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an appropriate code design in this field and what isn't. (For example,
    should you sacrifice clarity and elegance for performance, try to squeeze the
    executable image into the smallest size possible, or perhaps incorporate many
    hooks for future extensibility?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools you use—what's available and what isn't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is the most appropriate choice of programming language and which coding
    idioms you should employ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Know your discipline. Learn its intricacies. Understand how to write excellent
    software that appropriately meets its requirements*.'
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Still round the corner there may wait, A new road or a secret gate.
  prefs: []
  type: TYPE_NORMAL
- en: --J.R.R. Tolkien
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve dipped a toe in the water and sampled the different flavors of programming
    going on out there. Of course, there are other areas than those we''ve seen: some
    well defined, others more ephemeral. For example, *safety-critical software* drives
    high-reliability systems like medical equipment and aircraft control. Here failure
    is not an option, and the code must be *provably* correct; this has a profound
    affect on the way you design and write it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What have we learned? These fields all have one thing in common: their differences.
    Each requires fundamental design decisions to be made to suit software to them.
    Application-level code is not generally suited to an embedded environment. A workstation
    application design may not scale when applied to a distributed system.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that software developers tend to specialize in particular fields
    and learn to think in particular patterns that suit their worlds. Understanding
    the very real concerns of each environment will make you a more flexible and mature
    programmer. Ultimately, you must know your programming church and practice its
    rites and rituals well.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the nature of the problems they face
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailor their code and designs to the problem domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Have a naïvely narrow software worldview; they don't understand the forces that
    drive other types of software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code ill-suited for the problem domain (choosing unsympathetic architectures
    or inappropriate code idioms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  prefs: []
  type: TYPE_NORMAL
- en: Different niches have different qualities and ranges of development tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  prefs: []
  type: TYPE_NORMAL
- en: Different problem domains call for very different software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207588.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 557.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which of the programming niches we've looked at here are particularly similar
    or share common characteristics? Which are particularly different?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these programming disciplines is hardest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it important to be an expert in one particular area or to have a good grounding
    in all of them without a particular specialism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which programming niche should trainee programmers be introduced to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What programming arena are you working in right now? How does it affect the
    code that you're writing? What specific design and implementation decisions has
    it led you to make?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have experience working in more than one programming discipline? How
    easy was it for you to switch mindsets and apply appropriate techniques in a different
    world?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are any of the people you work with unaware of the forces that shape the particular
    kind of code you write? Do you have embedded software being written by programmers
    who only understand applications work? What can you do about this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 24. WHERE NEXT?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*All''s Well That Ends Well*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we call the beginning is often the end. And to make an end is to make a
    beginning. The end is where we start from.
  prefs: []
  type: TYPE_NORMAL
- en: --T.S. Eliot
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You''ve reached the end of this book. Either that, or you''re
    the kind of person who likes to spoil an ending by reading the last page first.
    (If you are: *The butler did it*.) Presuming that you''ve read every chapter,
    by now you should have:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned many practical code-writing techniques that have already improved your
    source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gained an understanding of how to write code in the Real World and the tricks
    that help you to produce useful code in the madness of the software factory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worked out some personal ways to improve your skill set. (You did attempt the
    questions, didn't you? If not, try them now.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovered how to write effective code as part of a team, establishing practical
    steps to improve the way your team currently works together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Found out more about cartoon monkeys than you ever really needed to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But more importantly, you should now appreciate that an exceptional programmer
    is one with the right attitude: one who always seeks to write the best code in
    any situation, who works well with others, and who can make pragmatic decisions
    in the heat of the software factory. The craftsman knows how to manage technical
    debt and seeks to address problems early, before they become software snares.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Becoming a good programmer requires you to adopt effective *attitudes*—the
    angle of approach you take to software construction*.'
  prefs: []
  type: TYPE_NORMAL
- en: But What Now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The important thing is not to stop questioning. Curiosity has its own reason
    for existing. One cannot help but be in awe when he contemplates the mysteries
    of eternity, of life, of the marvelous structure of reality. It is enough if one
    tries merely to comprehend a little of this mystery every day. Never lose a holy
    curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: --Albert Einstein
  prefs: []
  type: TYPE_NORMAL
- en: As a code craftsman, you'll never reach perfection; the best you can ever achieve
    is a continual state of improvement. There's always more to learn. So what should
    you do now? The very fact that you're asking that question is pivotal—one of the
    most important charateristics of a code craftsman is a desire to improve.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to become a skilled soccer player, I might find some books on soccer,
    buy a soccer training video, and then sit down with some popcorn and a few beers
    to learn how to play the game. Great. Ask me how it''s going two months later.
    If I say, "I''ve read loads about it, and I know all the top moves of the premier
    players," then you won''t be at all impressed: How well can I actually *play*?
    It is a geniunely good idea to read about the game and to study it, but couch
    potato soccer skills aren''t any real use.'
  prefs: []
  type: TYPE_NORMAL
- en: I can only learn soccer by doing it—by getting dirty, out on a field, playing
    the game. *Practice makes perfect*. I need to play with people who are skilled
    and who can train me well. I need to expend energy, feel the burn, and perhaps
    make a fool of myself in front of others. Slowly, gradually, painfully, I'll get
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hate to break it to you, but that''s the only way to get good at code craft
    too. Just reading this book won''t cut it. You have to get out there and *do it*.
    Properly. So how can we translate this into practice? Here are a few simple ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Place this book on your bookshelf. Put what you've learned into practice as
    best you can right now. You can always refer to a specific chapter when you run
    into problems later on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a few months of working with this advice, pull out the book once more
    and give it another read. Pay particular attention to the questions in the "[Getting
    Personal](ch23s12.html#getting_personal-id23 "Getting Personal")" sections—work
    out what your next steps must be to improve your code. Each time you go through
    this process, you'll identify new ways to improve your skills.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Maneuver your career into the path of great coders, and glean all you can from
    them. Learn what makes their code good and their attitudes constructive, and how
    you can apply these characteristics to yourself. Seek their advice, criticism,
    review, and opinion. Ask them to mentor you. (Bribe them with popcorn and alcohol
    if you have to!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep programming, and expand your horizions. Write more code. Try out new techniques.
    Tackle new problems, different languages, and unfamiliar technologies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't be afraid of making mistakes; you won't become a perfect programmer overnight.
    As you learn, you will almost certainly make many embarrassing faux pas. Don't
    let these stunt your growth or define you as a programmer. Unless you try out
    new techniques, you'll never learn and won't improve. George Bernard Shaw wrote,
    "A life spent making mistakes is more useful than a life spent doing nothing."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive advice and code review comments with a constructive attitude. Look back
    at what you've done, and see how it can be improved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Develop outside interests that you can use as a frame of reference for technical
    knowledge. If all you ever study is programming, then you will become a very two-dimensional
    person and will not be able to fit code craft into the context of the Real World.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the classic books in your field. (*Code Craft* is obviously one of them!)
    Get a copy of each, and digest it well. Every disicpline and every language has
    its renowned gurus—ensure you know who they are and what they've written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read the classic software tomes, like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*The Mythical Man-Month* (Brooks 95)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Psychology of Computer Programming* (Weinberg 71)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Peopleware: Productive Projects and Teams* (DeMarco 99)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Pragmatic Programmer* (Hunt Davis 99)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code Complete* (McConnell 04)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Practice of Programming* (Kernighan Pike 99)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* (Gamma et
    al. 94)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the Design of Existing Code* (Fowler 99)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask your peers which books they have found valuable. Seek out relevant magazines,
    websites, and conferences.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Teach. Mentor a lesser abled programmer. You'll learn a lot more by passing
    on your wisdom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broaden your skills base by joining a professional organization like the British
    Computer Society (BCS), the Association for Computing Machinery (ACM), or the
    ACCU ([www.accu.org](http://www.accu.org)). Then join in—contribute. The more
    you participate, the more you'll invest in yourself. The ACCU, for example, is
    highly contributory. It runs mentored developer projects and encourages members
    to write for its periodicals. These organizations run programming contests, provide
    forums for social networking, and often have local chapters where you can meet
    like-minded people who care about the craft of programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have fun! Enjoy cutting code to solve tricky problems. Produce software that
    makes you proud. Confucius said, "If you enjoy what you do, you'll never work
    another day in your life."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Take responsibility for improving your skills. Never lose your passion for
    programming or your desire to do it with excellence*.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Answers and Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Principles for the Development of a Complete Mind: Study the science of art.
    Study the art of science. Develop your senses—especially learn how to see. Realize
    that everything connects to everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: --Leonardo DaVinci
  prefs: []
  type: TYPE_NORMAL
- en: This part contains my musings on the questions at the end of each chapter. It's
    not a straight answer set—few of the questions have a definite *yes* or *no* response.
    Compare your answers with these.
  prefs: []
  type: TYPE_NORMAL
- en: The point of these questions is simply to get you thinking, to make you delve
    deeper into each subject, and to spur you to improve your programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: If you're thinking of reading this just to get the "answers" without having
    thought about the questions first, I'd really encourage you not to. Spending even
    a little time mulling things over and getting personal will really pay off. As
    Confucius said, "I hear and I forget. I see and I remember. I do and I understand."
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Can you have** too much **defensive programming?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes—just as too many comments can degrade code readability, so can many defensive
    checks, if they are bad. Redundant checks can be avoided with careful coding;
    for example, by making a good choice of types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should you add an assertion to your code for every bug you find and fix?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fundamentally, it's not a bad practice. But think about where you'd add the
    assertions. Many, many faults are due to incorrect honoring of API contracts.
    If you passed garbage into a function, you would want to put some *precondition*
    checking inside that function, rather than put a test at the call site. If the
    function returned garbage, you would either fix the function so that it won't
    again (and prove it's fixed) or write some *postconditions*.
  prefs: []
  type: TYPE_NORMAL
- en: It would be more beneficial to add a new unit test for every bug you find and
    fix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should assertions conditionally compile away to nothing in production builds?
    If not, which assertions should remain in release builds?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: People hold passionate beliefs on this subject. The answer isn't black and white;
    there are powerful arguments for both sides. There are always some very nit-picky
    assertions that really don't *need* to be left in production builds. But some
    assertion occurrences may still interest you in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you do leave any constraint checks in releases, they *must* change behavior—the
    program shouldn't abort on failure, just log the problem and move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: Genuine run-time error checks should *never* be removed; they should
    never be coded in assertions anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Are exceptions a better form of defensive barrier than C-style assertions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They can be. Exceptions behave differently; while propagating back up the call
    stack, an exception can be caught and ignored—suppressing its effect. This makes
    exceptions more flexible tools. You can't ignore an `assert` that aborts execution;
    assertions are lower-level mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should the defensive checking of pre- and postconditions be put inside each
    function, or around each important function call ?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function, without a doubt. This way, you only need to write tests once.
    The only reason you'd want to move them out is to gain flexibility, to choose
    what happens when a constraint fails. This isn't a compelling gain for such an
    explosion in complexity and potential for failure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are constraints a perfect defensive tool? What are their drawbacks?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, they are nowhere near perfect. Redundant constraints can be pests at best
    and hindrances at worst. For example, you could assert that a function parameter
    `i >= 0`. But it's much better to make `i` an unsigned type that can't contain
    invalid values anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Treat constraints that can be compiled out with a certain degree of suspicion:
    We must carefully check for any side effects (assertions can have subtle indirect
    consequences) and for timing issues in the debug build that alters its behavior
    from a release build. Ensure that assertions are logical constraints and not genuine
    run-time checks that mustn''t be compiled out. It *is* possible to put bugs in
    the bug-defense code!'
  prefs: []
  type: TYPE_NORMAL
- en: But carefully used, constraints are still far better than dancing barefoot over
    the hot coals of chance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you avoid defensive programming?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If you designed a better language, would defensive programming still be necessary?
    How could you do this?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does this show that C and C++ are flawed because they have so many areas
    for problems to manifest?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Some language features certainly could be designed to avoid errors. For example,
    C doesn't check the index of any array lookup you perform. As a result, you can
    crash the program by accessing an invalid memory address. The Java run time, on
    the other hand, checks *every* array index before lookup, so such an catastrophe
    will never arise. (Bad indexes will still cause an error though, just a better
    defined class of failure.)
  prefs: []
  type: TYPE_NORMAL
- en: Despite the long list of "improvements" you could make to the liberal C specification
    (and I urge you to think of as many as you can), you'll never be able to create
    a language that doesn't need defensive programming. Functions will always need
    to validate parameters, and classes will always need invariants to check that
    their data is internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Although C and C++ do provide plenty of opportunity for things to go wrong,
    they also provide a great deal of power and expression. Whether that makes the
    languages flawed depends on your viewpoint—this is a topic ripe for holy war.
  prefs: []
  type: TYPE_NORMAL
- en: '**What sort of code do you not need to worry about writing defensively?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I've worked with people who refused to put any defensive code into an old program
    because it was *so bad* that their defenses would make no difference. I managed
    to resist the urge to whack them with a large mallet.
  prefs: []
  type: TYPE_NORMAL
- en: You might argue that a small, stand-alone, single-file program or a test harness
    doesn't need this sort of careful defensive code or any rigorous constraints.
    But even in these situations, not being careful is just being sloppy. We should
    aim to be defensive all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How carefully do you consider each statement that you type? Do you relentlessly
    check every function return code, even if you''re **sure** a function will not
    return an error?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I bet you don't check everything. It's far too easy to overlook certain function
    return codes, especially since some are deemed more important than others. How
    many C programmers check the return value of `printf`? How many actually *know*
    that it returns anything?
  prefs: []
  type: TYPE_NORMAL
- en: '**When you document a function, do you state the pre- and postconditions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are they always implicit in the description of what the function does?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If there are no pre- or postconditions, do you explicitly document this?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No matter how obvious you think a contract is (from the function name or its
    description), explicitly stating the constraints removes any ambiguity—remember,
    it''s always better to remove areas of assumption. Explicitly writing *Preconditions:
    None* will document a contract explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't want every function to explicitly restate a global precondition.
    It would be laborious and tedious. If an entire API expects that pointer values
    mustn't be null, it's arguably better to document this once, globally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Many companies pay lip service to defensive programming. Does your team recommend
    it? Take a look at the codebase—do they really? How widely are constraints codified
    in assertions? How thorough is the error checking in each function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Very few companies have a culture of excellent code with the right level of
    defense. Code reviews are a good way to bring a team's code up to a reasonable
    standard; many eyes see many more potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are you naturally paranoid enough? Do you look both ways before crossing
    the road? Do you eat your greens? Do you check for every potential error in your
    code, no matter how unlikely?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How easy is it to do this thoroughly? Do you forget to think about errors?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are there any ways to help yourself write more thorough defensive code?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No one finds it naturally easy—thinking the worst of your carefully crafted
    new code is contrary to a programmer's instincts. Instead, expect the worst of
    any people who will be using your code. They're nowhere near as conscientious
    a programmer as you are!
  prefs: []
  type: TYPE_NORMAL
- en: A very helpful technique is to write unit tests for each function or class.
    Some experts strongly advise doing this *before* writing a function, which makes
    a lot of sense. It helps you to think about all the error cases, rather than happily
    trusting that your code will work.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Should you alter the layout of legacy code to conform to your latest code
    style? Is this a valuable use of code reformatting tools?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's usually safest to leave legacy code however you find it, even if it's ugly
    and hard to work with. I'd only entertain reformatting if I was absolutely sure
    that none of the original authors would ever need to return.
  prefs: []
  type: TYPE_NORMAL
- en: By reformatting, you lose the ability to easily compare a particular revision
    of the source with a previous one—you'll be thrown by many, many formatting changes
    which may hide the one important difference you really need to see. You also risk
    introducing program errors in the reformatting.
  prefs: []
  type: TYPE_NORMAL
- en: As far as code reformatting tools go, they're nice curiosities, but I don't
    advocate the use of them. Some companies insist on running source files through
    beautifiers before checking any code into their repository. The advantage is that
    all code is homogenized, pasteurized, and uniformly formatted. The major disadvantage
    is that no tool is perfect; you'll lose some helpful nuances of the author's layout.
    Unless all the programmers on your team are gibbons, don't use a reformatting
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**A common layout convention is to split source lines at a set number of columns.
    What are the pros and cons of this? Is it useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with many presentation concerns, there is no absolute answer; it is a matter
    of personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: I like to split my code up so that it fits on an 80-column display. I've always
    done that, so it's a matter of habit as much as anything else. I don't disagree
    with people who like long lines, but I find long lines hard to work with. I set
    my editor up to wrap continuous lines rather than provide a horizontal scrollbar
    (horizontal scrolling is clumsy). In this environment, long lines tend to ruin
    the effect of any indentation.
  prefs: []
  type: TYPE_NORMAL
- en: As I see it, the main advantage of fixed column widths is not printability,
    as some would claim. It's the ability to have several editor windows open side
    by side on the same display.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, C++ produces very long lines. It's more verbose than C; you end
    up calling member functions on objects referenced by another object through a
    templated container. . . . There are strategies to manage the many, many, long
    lines this may lead to. You can store intermediate references in temporary variables,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**How detailed should a reasonable coding standard be?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How serious are deviations from the style? How many limbs should be amputated
    for not following it?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Can a standard become too detailed and restrictive? What would happen if
    it did?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Six limbs should be amputated for deviations from any coding standard.
  prefs: []
  type: TYPE_NORMAL
- en: The correct answer really depends on the exhaustiveness of the coding standard
    and the coding culture you work in. There are usually much bigger software problems
    to address than a misplaced bracket, but brackets are easier to moan about. I
    have seen many coding standards that are so prescriptive and paralyzing that the
    poor programmers have just plain ignored them. To be useful and to be accepted,
    a coding standard should provide a little room for maneuvering, perhaps with a
    *best practice* approach given as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**When defining a new presentation style, how many items or cases need layout
    rules? What other presentation rules must be provided? List them**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you write out each layout rule individually, there will be an awfully large
    number of cases to consider. Coding style is a delicate interplay of many forces:
    indentation, yes, but also internal spacing, naming, positioning of operators,
    presentation of parentheses, contents of files, use and ordering of header files,
    and more, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The following list of presentation items *is* long, but it's far from complete.
    It's a good starting point for a style checklist. In practice, some items are
    more important to standardize than others. As you read this list, make sure that
    you have considered a personal preference for each item. Also make sure that you
    know the correct convention for your current software project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code margins**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of spaces per indent shapes the left edge of the code. It's common
    to see two- or four-space indents, though some programmers diplomatically choose
    three spaces. Smaller indents mean that you don't run into the right margin as
    quickly, but they look cluttered and make it harder to differentiate among levels.
    Larger indents are more distinct, but you run out of space more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to indent with tabs or spaces is a long-running debate that has driven
    many programmers to therapy. Spaces are more portable; they'll display the same
    width in any editor. When displaying code using a variable width font,^([[1](#ftn.APP-FN-1)])
    tabs can give better alignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page width determines how you format the right-hand code edge. You can limit
    lines to a fixed number of columns or let them grow forever, requiring horizontal
    window navigation. Fixed pages are often 79 or 80 characters wide. This is historic;
    80 characters is a common terminal width, but the last column was not always usable
    for display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are choices for aligning certain constructs. At which level do you put
    `public:`, `private:`, and `protected:` in a class declaration? Where do `case`
    labels go in `switch` statements? How do you format labels for the `goto` statements
    you never use?^([[2](#ftn.APP-FN-2)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spacing and separation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can line up pieces of code with an internal tabular layout; for example,
    aligning operators in the same column across subsequent lines. This provides visual
    emphasis for the function of a block of statements. However, it does require extra
    typing and maintenance effort, and some programmers don''t feel it is justified.
    A tabular horizontal layout would look something like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Whitespace can appear pretty much anywhere, and there are different ways to
    space out individual code statements. It''s a good idea to put spaces around operators,
    like this: `hamster = "cute"`. It''s akin to having spaces between words when
    you write. The alternative, `hamster="ugly"`, looks cramped and dense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, function calls can be spaced in various ways. You might employ one
    of the following formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Many view the latter option as bad—a mathematical equation wouldn't have a space
    after the function name. (The mother-in-law, however, might be a genuinely edible
    commodity.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Should you follow a similar convention for keywords? How does `while(lionIsAsleep)`
    look? Cramped. Keywords aren't functions; they read more like words, so it's most
    common to see spaces around them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If code gets too long for a single line, it must be split, but *where* to split
    is another choice. Naturally, you'd break in the most logical place, but one man's
    logic is another man's folly. Lines are generally broken around an operator, but
    whether before or after it—whether the operator appears on the end of the previous
    or beginning of the next line—is a matter of taste.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic C/C++ contention is where to put the asterisk in a pointer declaration
    (a battle often called Star Wars). You can chose between these three:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first two associate the "pointeryness" with the variable and with the type,
    respectively. The problem with associating with type is it doesn''t work as expected
    for statements like this: `int* weasel, ferret;`. The third version is a reasonable
    fence-sitting alternative, but isn''t as common.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some C/C++ standards mandate that all constant names should be in uppercase
    letters to make them clear. Some argue that only preprocessor macro names should
    be capitalized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines of code**'
  prefs: []
  type: TYPE_NORMAL
- en: Exactly *what* goes on each line is a layout concern; it is often mandated that
    every individual statement goes on its own line, making each one distinct and
    clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leads on to the issue of *side effects* in statements; should you allow
    code like `index[count++] = 2` or permit assignments in `if`s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some presentation styles will place code on the same line as an opening brace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you always include braces, even if there''s only one statement within
    them? You might allow braces to be missed when the code follows on the same line,
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's common to see `else` clauses aligned in the same column as their respective
    `if`, but you'll sometimes see them placed at a subordinate indent level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How important is it to make *special cases* clear? Some coding standards mandate
    that fall-throughs between `switch` statement `case`s should be flagged with comments.
    Similarly, *no-ops* in loops should be flagged to avoid confusion; otherwise,
    this little bodiless loop that finds the end of a C string `str` may confuse the
    unwary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Should C++ inline methods be put inside the class declaration, outside it (directly
    afterward), or in a separate source file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**'
  prefs: []
  type: TYPE_NORMAL
- en: The most basic decision is how to split a project into files and what information
    to put into each one. Is there one file per class or per function? Or can you
    split files into smaller or larger units than this, perhaps per library or section
    of code? What if there are a lot of very small related classes? Do you really
    want lots of very small related files?^([[3](#ftn.APP-FN-3)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventions for splitting a file into sections differ. Some programmers like
    to insert a number of blank lines as a separator, some prefer comment blocks,
    some like reams of ASCII art.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C/C++, the exact order of `#include`d files may be fixed by a presentation
    style. There are different schools of thought here. Some prefer to neatly order
    system includes first, then project includes, then file-specific includes. Others
    feel that the exact opposite is safer; it *can* prevent one header file from accidentally
    relying on headers normally included before itself. Some standards suggest that
    no *header file* should *ever* `#include` another, leaving it to be done long-hand
    in every implementation file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misc**'
  prefs: []
  type: TYPE_NORMAL
- en: There will always be plenty of other issues specific to particular coding situations.
    How do you format embedded SQL commands in code that performs database access?
    Do you require consistent formatting in a project across different languages?
  prefs: []
  type: TYPE_NORMAL
- en: '**Which is more important—good code presentation or good code design? Why?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is really a very artificial question. Both are fundamental for good code,
    and you should never be asked to sacrifice one for the other. If you ever are,
    beware. However, which one you just chose may say a lot about you as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Bad formatting is certainly easier to fix than bad design, especially if you
    use clever tools to homogenize your code's formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an interesting connection between presentation and design: Bad presentation
    often shows that the code was produced by a bad programmer, which probably means
    that it suffers from bad internal design too. Or it may imply that the code has
    been maintained by a series of different programmers, with a subsequent loss of
    the initial code design.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Do you write in a consistent style?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When you work with other people''s code, which layout style do you adopt—theirs
    or your own?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How much of your coding style is dictated by your editor''s auto-formatting?
    Is this an adequate reason for adopting a particular style?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can't alter the way your editor positions the cursor for you, you shouldn't
    be using it (either you're too inept, or your editor is).
  prefs: []
  type: TYPE_NORMAL
- en: If you can't write code in a consistent style, you should have your programmer's
    license revoked. If you can't follow someone else's presentation style, you should
    be forced to maintain BASIC for the rest of your career.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guard your attitude: The typical programmer cares more about his code, personal
    practices, and individual layout fetishes than the overall health of the project.
    Too often, there is an *individual versus team* dilemma. If a programmer rebels
    against an imposed house style or can''t maintain code using its existing presentation
    style, it is a bad sign. This suggests that the programmer can''t see the big
    picture.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tabs: Are they a work of the devil, or the best thing since sliced bread?
    Explain why**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you know if your editor inserts tabs automatically? Do you know what your
    editor''s tab stop is?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Some hugely popular editors indent with a mixture of tabs and spaces. Does
    this make the code any less maintainable?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How many spaces should a tab correspond to?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is such a religious issue, I'll just say *Tabs suck!* and back away
    quickly. Well, actually I'll add that the only thing more evil than indenting
    with tabs is indenting with tabs *and* spaces—a nightmare!
  prefs: []
  type: TYPE_NORMAL
- en: If your editor *is* inserting tabs (and probably spaces) without you noticing,
    try using another editor for a while to appreciate how frustrating it is. Try
    setting your tab stop to a different value, and see what a mess it makes of the
    code. *Everyone uses the same editor, so it doesn't matter* is not a professional
    attitude. Everyone doesn't use the same editor, so it *does* matter.
  prefs: []
  type: TYPE_NORMAL
- en: You'll hear people recommend their choice of tab-stop length and carefully justify
    their opinions. That's all very well; in fact a respected study claims that a
    *three-* or *four-* space tab stop provides optimum readability. (I favor four
    spaces because I don't like odd numbers!) However, a tab should correspond to
    *no* fixed number of spaces. A tab is a tab, which is not a space or any multiple
    thereof. For code laid out using tabs, it shouldn't matter exactly how many spaces
    the tab is displayed as—the code should read well, regardless. Unfortunately,
    I have rarely seen tab-indented code that works this way. All too often, tabs
    and spaces are mixed together to make code line up neatly. This works fine with
    a tab stop set as the author intended. But it makes an unholy mess with any other
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you have a preferred layout style?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Describe it in a series of simple statements. Be complete. Include, for example,
    how you format** `switch` **statements and split up long lines**.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How many statements did it take? Is that what you expected?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does your company have a coding standard?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you know where it is? Is it advertised? Have you read it?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If yes: Is it any good? Perform an honest critique, and feed your comments
    back to the document owners**.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If no: Should it? ( Justify your answer.) Is there a common unwritten code
    style that everyone adopts? Can you drive the adoption of a standard?**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is there more than one standard used, perhaps one per project? If so, how
    is code shared among projects?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you are aware of any style guides (or undocumented conventions) that
    you should work to.
  prefs: []
  type: TYPE_NORMAL
- en: 'This question was partly motivated by personal experience: I was working in
    a large organization with several isolated departments, each following its own
    set of guidelines. As the separate products slowly converged, it made technological
    (and sound financial) sense to combine some parts of the codebases. The result
    was a mess of code with different styles of interface, different presentation,
    even different language use. It looked unorganized and unprofessional and was
    very hard to work with. It was painful.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How many different layout styles have you followed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which did you feel most comfortable with?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which was the most rigorously defined?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is there a link?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few years of programming, it's easy to settle into your own peculiar
    layout style without really thinking about how or why you arrived at it. Undoubtedly,
    it was a result of other code you've read and worked with, mixed with your own
    personal tastes. Take some time to consider this, and ensure that your coding
    style is sound. Perhaps now is the time to modify and improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Changing your style isn't straightforward. There will still be your old legacy
    code to deal with—should you convert it to the new style, or leave it in the previous
    state?
  prefs: []
  type: TYPE_NORMAL
- en: Grab a text editor and type in this bit of code; it calculates the *n* th prime
    number. It's written in one particular coding style. Present it as *you'd* like
    to see it. Don't try to change the implementation at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That is a representative bit of Real World code, so don't dismiss this as a
    stupid and tedious exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I haven't given any suggested answer here. My reformatting is just
    as valid as yours, and indeed as valid as the original format. That's why this
    is a *Getting Personal* question.
  prefs: []
  type: TYPE_NORMAL
- en: If you're reading these answers without chewing over the questions at all, go
    on—give this one a try. The book can wait while you type in a few lines. . . .
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at what you've written.
  prefs: []
  type: TYPE_NORMAL
- en: How different is your version? How many specific changes did you make?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each change, ask yourself: Is it a personal aesthetic preference, or can
    you justify the change with some rationale? Question this rationale—is it truly
    valid? How strongly would you be prepared to defend it?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How comfortable were you with the original format? Did it bother you to read?
    Could you work in that coding style if you encountered code like it? *Should*
    you be able to become comfortable with it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give yourself bonus points if you wanted to reimplement the code to be more
    efficient, and extra bonus points if you resisted the temptation. (Premature optimization
    is a Bad Thing—see "[The Nuts and Bolts](ch11s05.html "The Nuts and Bolts")" on
    page 206.)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#APP-FN-1)]) More common in published code than in a source code editor.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#APP-FN-2)]) Because, of course, no high-quality programmer will use
    `goto`s in these enlightened times—see "[Structured Programming](ch22.html#structured_programming
    "Structured Programming")" on page 421.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#APP-FN-3)]) Java answers this by mandating the physical mapping of classname
    to filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Are these good variable names? Answer with either** yes (explain why, and
    in what context), no (explain why), or can''t tell (explain why).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`int apple_count`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`char foo`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`bool apple_count`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`char *string`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`int loop_counter`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The quality of a name depends on its context, and we can''t honestly tell whether
    any of these are good or bad names. That''s why the question asks for example
    contexts. There are some obvious contexts where the names might be bad: `apple_count`
    wouldn''t be a particularly good name for a grapefruit counter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`foo` is *never* a good name. I''ve yet to see anyone counting *foo*s. `loop_counter`
    is also bad; even if a loop gets too big for a short counter name, you can still
    pick a more descriptive name, one that reflects the actual *use* of the variable
    rather than its role as a loop counter.'
  prefs: []
  type: TYPE_NORMAL
- en: We can't really tell whether `bool apple_count` is a good name, but it looks
    like it isn't—a boolean cannot hold a number. Perhaps it's recording whether a
    separate count of apples is valid, but if this was the case, it ought to be called
    something like `is_apple_count_valid`.
  prefs: []
  type: TYPE_NORMAL
- en: '**When would these be appropriate function names? Which return types or parameters
    might you expect? Which return types would make them nonsensical?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`doIt(...)`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`value(...)`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`sponge(...)`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`isApple(...)`**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What each of these might mean depends on where you find them. A name depends
    on its context for meaning; that context is provided by the enclosing scope of
    the function. Context information can also be given by function parameters or
    return variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should a naming scheme favor the easy reading or easy writing of code? How
    would you make either easy?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How many times do you write a single piece of code? (Think about it.) How
    many times do you read it? Your answers should give some indication as to the
    relative importances**.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What do you do when naming conventions collide? Say you''re working on camelCase
    C++ code and need to do STL (using_underscore) library work. What''s the best
    way to handle this situation?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: I've worked on C++ codebases that used such a collision of naming conventions
    to their advantage. The internal logic used camelCase, whereas libraries and components
    that extended the standard library followed STL naming_conventions. It actually
    worked quite well, neatly marking separate parts of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it doesn't always work that nicely. I've seen plenty of inconsistent
    code where there was no rhyme or reason behind the changing styles.
  prefs: []
  type: TYPE_NORMAL
- en: '**How long should a loop be before you need to give a meaningful loop counter
    name?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This depends on how long your piece of string is. It's clear, though, that a
    100-line loop with a counter called `i` is not best practice.^([[4](#ftn.APP-FN-4)])
    Whenever you insert new code into a loop, check the counter name to see if it
    now needs adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: '**In C, if** `assert` **is a macro, why is its name lowercase? Why should we
    name macros so they stand out?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`assert` isn''t capitalized because `assert` isn''t capitalized. In an ideal
    world it would be, but standards being what they are, we have to live with this
    second-rate macro name. Sigh.'
  prefs: []
  type: TYPE_NORMAL
- en: Fire is useful, but it can also be very dangerous. Macros are the same. Macros
    and `#define`d constant definitions *are* dangerous—adopting the UPPERCASE name
    convention will prevent nasty collisions with ordinary names. It's as sensible
    as wearing safety goggles when a lunatic is walking around with a big pointy stick.
  prefs: []
  type: TYPE_NORMAL
- en: Because macros can be so painful, you should choose names that are very unlikely
    to cause headaches. More importantly, avoid using the preprocessor as much as
    humanly possible.
  prefs: []
  type: TYPE_NORMAL
- en: Long calculations can be made more readable by putting intermediate results
    in temporary variables. Suggest good naming heuristics for these types of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Bad temporary names are `tmp`, `tmp1`, `tmp2`, and so on, or `a`, `b`, `c`,
    and so on. These, unfortunately, are all common intermediate names.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other item, temporary names should be meaningful (like `circle_radius`
    in a trigonometric calculation or `apple_count` in an arboreal analysis routine).
    In fact, in a complex calculation, good names can really serve to document the
    internal logic and show what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: If you find a value that really has no nameable purpose, if it truly is an arbitrary
    intermediate value that's hard to name, then you'll begin to understand why `tmp`
    is so popular. Avoid calling anything `tmp` if possible—try to break the calculation
    in some other way that makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the pros and cons of following your language''s standard library
    naming conventions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Standard libraries are often a source of language best practice, so it can be
    valuable to follow their conventions. Other programmers are used to the naming
    style, so they will have fewer nasty reading surprises and will feel at home with
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the library might not always present best practices, so think
    first! C's horribly named `assert` macro is a good example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you wear out a name? Is it okay to repeat a local variable name in many
    different functions? Is it okay to use local names that override (and hide) global
    names? Why?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is perfectly acceptable to repeat a local variable name in many different
    contexts. Sometimes it''s good practice to: Why use a different loop index counter
    name all the time? It would only serve to make your code harder to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t* hide global names with local variable names; it''s really confusing.
    This is an indicator of brittle code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the mechanics of Hungarian Notation. What are the pros and cons
    of this naming convention? Does it have a place in modern code design?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hungarian Notation is a naming convention that adorns variable and function
    names with cryptic prefixes to denote type. It's seen predominantly in C code.
    There are several subtly different dialects, but the most common Hungarian prefixes
    are shown in [Table A-1](apas03.html#common_hungarian_notation_prefixes "Table A-1. Common
    Hungarian Notation Prefixes").
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-1. Common Hungarian Notation Prefixes**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prefix | Which means . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | pointer to . . . (`lp` means *long pointer*, an old architectural issue—if
    you don''t know, don''t ask) |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | reference of . . . |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | constant . . . |'
  prefs: []
  type: TYPE_TB
- en: '| `rg` | array of . . . |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | boolean (`bool` or some C `typedef`) |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | `char` |'
  prefs: []
  type: TYPE_TB
- en: '| `si` | `short int` |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `li` | `long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `ld` | `long double` |'
  prefs: []
  type: TYPE_TB
- en: '| `sz` | zero-terminated `char` string (Note: *not* `p`) |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | `struct` |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | `class` (You can define your own class abbreviations, too.) |'
  prefs: []
  type: TYPE_TB
- en: Hungarian Notation was relatively unbearable in C (not to mention unnecessary
    once the language became more strongly typed), and is rapidly nauseating in C++,
    since it doesn't really scale up to the many new type definitions you can introduce.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to confuse a maintenance programmer, use Hungarian Notation
    and then, a few months later, change the types of all the variables without correcting
    every single variable name (since it would take far too long to do *that*). This
    is a real weakness with the naming scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid Hungarian Notation like the plague*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some naming conventions have diluted Hungarian leanings. Witness the `foo_ptr`
    and `m_foo` ideas mentioned earlier in the chapter. There are other cute conventions
    with similar intent: Some programmers call their global variables `theFoo` and
    their member variables `myFoo`. Perhaps this shows that *some* Hungarian Notation
    is a good idea in principle; but taken to its logical extreme, it''s a dictatorial
    tyrant of a convention. Be on your guard.'
  prefs: []
  type: TYPE_NORMAL
- en: '**We see many classes containing member functions acting as getters and setters;
    reading and writing the value of certain properties. What are the common naming
    conventions for these functions, and which is the best?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While some argue that the existence of get and set methods shows a weak design,
    we nonetheless see a lot of classes written like this. Some languages actually
    have built-in support for these operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several naming conventions to choose from. If you''re writing in
    C++, using camelCase, and have some property called *foo* of type *Foo*, you might
    pick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: or perhaps
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Your choice may be dictated by a coding standard; otherwise, it's down to your
    sense of aesthetics. This is a case where I'd violate the *Function name should
    always contain a verb* rule and go for the second option, since it reads the most
    naturally in code. Try it and see.
  prefs: []
  type: TYPE_NORMAL
- en: If a "getter" method has to perform a long calculation the first time it's run
    (even if it can cache the answer for future invocations), then I'd be wary. It's
    no longer a simple retrieval function, and these naming schemes don't imply this.
    `Tree::numApples` is a good getter name, unless the operation could block for
    a minute while an image recognition system detects all the apples. In that case,
    I'd like to see the behavior implied by name. `Tree::countApples()` hints at some
    greater activity—it's the verb in the name.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How good are you at naming? How many of these heuristics do you follow already?
    Do you consciously think about your naming and these sorts of rules, or do you
    just** do it **all naturally? In which areas can you improve?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back over the section "[The Nuts and Bolts](ch11s05.html "The Nuts and Bolts")"
    on page 44\. Compare those guidelines with the last piece of code you wrote. How
    does it match up? How much of your naming necessarily follows existing coding
    conventions (as you're exhorted to do on page 50), and how much have you established
    from scratch?
  prefs: []
  type: TYPE_NORMAL
- en: '**Does your coding standard mention naming at all?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does it cover all the cases we''ve looked at here? Is it sufficient? Is it
    useful, or just superficial?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How much naming detail is appropriate in a coding standard?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes a coding standard with comprehensive naming mandates can make it *harder*
    to invent names—you have so many rules to try to satisfy that it's hard to remember
    and reconcile them all. Look with caution at anything more prescriptive than the
    guidelines laid out in [Chapter 3](ch03.html "Chapter 3. WHAT'S IN A NAME?").
  prefs: []
  type: TYPE_NORMAL
- en: Good code craftsmen habitually name well, and don't need coding standards to
    "help" them. The standards-setters often claim that their standards will help
    less-experienced programmers to name well. But more often than not, these standards
    are not that helpful—inexperienced programmers commit more programming sins than
    just bad naming. Code reviews are required to ensure that their work is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the worst name you''ve come across recently? How have names ever
    misled you? How would you have changed them to avoid future confusion?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you spot this in a formal review of someone else's work, or while trying
    to maintain some old, long-forgotten code?^([[5](#ftn.APP-FN-5)]) Finding and
    correcting bad names just after they've been written (when you still know what
    the thing should really be called) is best. And it takes the least effort. Working
    it out months later can sometimes be quite painful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you have to port code between platforms? How has this affected filenames,
    other names, and the overall code structure?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Older filesystems limited the number of characters you could use in a filename.
    This made file naming much messier (and more cryptic). Unless you have to port
    code to such an archaic system, this kind of limitation can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '*File-based polymorphism* is a cunning way to exploit filenames to achieve
    code substitutability at build time. It''s often used to select platform-specific
    implementations in portable code. You can set up header file search paths, allowing
    one `#include` to pull in a different file depending on the current build platform.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#APP-FN-4)]) But generally a 100-line loop itself is not best practice.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#APP-FN-5)]) Obviously, it would never be a problem you found in your
    *own* code!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Grouping related code will make its relationships clear. How can we perform
    this grouping? Which methods document the relationships most strongly?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obvious grouping devices are common name prefixes and suffixes; filesystem location;
    and putting items in the same class or structure, C++/C# namespace, Java package,
    source file, or code library. Can you think of more?
  prefs: []
  type: TYPE_NORMAL
- en: Relationships enforced by the language are the strongest—both obvious to read
    and also automatically checked for you. However, proximity of code layout is a
    more potent association than you'd think. Ordering also implies a lot—you'll think
    that the first item is more important than subsequent items. Exploit these facts
    to document your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**We should avoid using magic numbers in our code. Is zero a magic number?
    What should you call a constant value representing zero?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number zero has magic properties in many different contexts; in C code it
    is used as a *null* pointer value, and the initial value for most loops. What
    *could* you replace 0 with?
  prefs: []
  type: TYPE_NORMAL
- en: A single shared constant called `ZERO` is no better than writing `0`; it's *just
    as* magic. The name doesn't imply what any zero actually means—is it a null pointer
    value, or a loop initialization value? This approach would defeat the purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A different name for each zero constant would get very tedious because you'd
    have to create many similar variations on the theme of `for (int i = SOME_ZERO_START_VALUE;
    i < SOME_END_VALUE; ++i)`. None of these zero constant names gives any new meaningful
    information, anyway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'd have to think carefully about names for zero constants. The obvious choice
    would be something like `NO_BANANAS`, meaning *no bananas counted*. But this `NO_`
    prefix could be confused as an abbreviation for number (like `NUM_`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-documenting code makes good use of context to convey information. Show
    how you do this, and give an example of how a particular name would lead to a
    different interpretation in different functions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many ways to exploit context to your documentation's advantage. Consider
    a `Cat` class. Inside it, member functions don't need to be called `setCatName`,
    `setCatColor`, and so on; the *cat* part is implicit from the class context.
  prefs: []
  type: TYPE_NORMAL
- en: Many English words have a dual meaning. You'd expect the `count` variable in
    a search function to hold different information than one in a vampire database
    schema. More practically, a `name` variable in our `Cat` class clearly holds the
    cat's name, whereas one in an `Employee` class is more likely to hold a human's—with
    first name, last name, and title information. Same variable name, different contents.
    Exploit context information as much as possible, but ensure that the context in
    which you write is truly obvious.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it realistic to expect a newcomer to pick up some self-documenting code
    and understand it totally?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, that's our aim—it *is* realistic. However, the reader will still need overview
    and design documents describing the entire system, what it does, and how it's
    structured. If the code comments try to explain this, then they're in the wrong
    place (or it's a very small system).
  prefs: []
  type: TYPE_NORMAL
- en: With good code documentation, a newcomer should find it perfectly clear what
    a particular *section of code* is doing. Comprehensive API docs show the meaning
    of any function call the newcomer may come across.
  prefs: []
  type: TYPE_NORMAL
- en: '**If code is truly self-documenting, how much other documentation is required?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It depends on the size and scope of the project. You'll require functional specifications
    and design documents. You may still need an implementation overview, and will
    definitely require thorough test specifications.
  prefs: []
  type: TYPE_NORMAL
- en: To document the design of a single piece of code, good literate comments mean
    that you shouldn't need any other documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why must more people than the original author understand any piece of code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a reality of the software factory. Being the only person who understands
    some code is good job security for the unscrupulous programmer. Writing code that's
    worse than a cryptic crossword puzzle will guarantee you a job for life (or until
    the company folds, whichever happens first). The downside is that you'll spend
    your days immersed in your own foul concoctions.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, code is dangerous if it can't be understood by anyone else. If you
    leave the company, move to another department, get promoted, or no longer have
    time to perform maintenance, then someone else must be able to take over. And
    if it doesn't come down to that, sometime down the road, when you've forgotten
    how your code works, a fatal fault will turn up that must be fixed by last Tuesday.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews can help to ensure that code is well understood and adequately
    documented.
  prefs: []
  type: TYPE_NORMAL
- en: '**This simple C bubblesort function could use some improvement. What specific
    things are wrong with it? Write an improved, self-documenting version**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first problem is that a bubblesort algorithm should never be used. There
    are plenty of better sorts. There's also probably a much better, generic language
    library function available; in C you can call `qsort`, for example. I've used
    bubblesort here as a simple code example.
  prefs: []
  type: TYPE_NORMAL
- en: The function's interface isn't clear *at all*. The function name is too cryptic,
    and the parameter names mean nothing. I'd like to see an API documentation comment
    provided too, but I'll leave that out in the rewrite below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, the code is a mess. Its intent would be much clearer if the code
    that transposes array values is split out as a `swap` function. Then the reader
    can see what''s going on. A little more massaging leads to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is adequate C, although there are some more changes you might prefer. Depending
    on your religion, you might want braces around the loops. `swap` could be made
    into a macro for efficiency. This isn't a clever optimization though; you should
    really choose a more efficient sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, I'd consider making `swap` inline, and take its parameters by reference
    (documenting the fact that they will be changed). The best choice would be to
    use the `std::swap` facility available in the language libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with code documentation tools brings up some interesting issues.
    What''s your opinion on these?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When you review the documentation, should you perform a code review, looking
    at the comments in the source files, or a specification review, looking at the
    generated documents?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Where do you put documentation of protocols and other non-API issues?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you document private/internal functions? In C/C++, where do you place
    this documentation—in the header file or implementation file?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In a large system, should you create a single, large API document or several
    smaller documents, one per area? What are the advantages of each approach?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My thoughts on these questions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Review the generated spec; don't get too hung up about the layout of the comments
    in the source file. You're reviewing the content, not the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't be fooled into thinking documentation must be put in a *header file* or
    in an *implementation file*. Even if documentation tools are a Good Thing, it's
    not evil to have some separate "traditional" documents as well. Write about your
    protocol there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document any internal functions that *need* documentation. You don't necessarily
    have to write exhaustive docs on all private parts. These docs should be hived
    off into the implementation file if they're reasonably large, to keep the public
    interface neat and simple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both! Use different invocations of the tool to generate a single, large document
    and documents for each subsystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If you''re working on a codebase that isn''t literately documented, and you
    need to alter or add new methods or functions, is it a good idea to give them
    literate documentation comments, or should you leave them undocumented?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The craftsman *wants to* document and automatically feels the need to write
    comment blocks. Now, if the code has a separate specification document, then your
    documentation should go in there alongside everything else. Otherwise, it's not
    too bad to start adding literate comments. Make sure that the original programmer
    isn't going to take offense, though!
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it possible to write self-documenting assembly code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can give it your best shot, but it's not going to be easy. Assembly code
    isn't particularly expressive; you're not programming at the level of intent,
    more at the level of *do this, you dumb microprocessor*. Your code will be mostly
    comment blocks (probably good practice for assembly, anyway). Except for subroutine
    labels, there's not much else to self-document with.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What do you consider to be the best documented code you''ve come across?
    What made it so?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Did this code have a large number of external specifications? How many of
    them did you read? How can you be sure you knew enough about the code without
    reading them all?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How much of this do you think was due to the author''s programming style,
    and how much was because of any house style or guidelines he or she worked to?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Well-documented code does not necessarily have any separate description documents.
    Internally, it employs good naming, logical modularization, simple techniques,
    clear layout, documented assumptions, and good commenting. House styles help,
    but they are no substitute for astute, sensitive programming. An idiot can follow
    the most stringent guidelines and still produce shabby shreds of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you write in more than one language, how does your documentation strategy
    differ in each?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different languages are more or less expressive, and so what can and can't be
    documented within the language syntax varies. As much as anything else, this will
    affect how many comments you'd write.
  prefs: []
  type: TYPE_NORMAL
- en: You're probably better at writing self-documenting code in your most familiar
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**In the last code you wrote, how did you make the important stuff stand out?
    Did you hide private information away appropriately?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think carefully about this—the natural tendency is to dismissively say, *Yeah,
    I wrote it okay*. Look at your code as if it had been written by some other muppet.
    Criticize it.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you''re working on a team, how often do others come to you to ask you
    how something works? Could you avoid this with better-documented code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A good two-pronged strategy to cope with this is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the question is genuinely about something unclear in your code, after having
    explained it to the curious programmer (and learned what he really *needed* to
    know), capture the information in some appropriate documentation. You can email
    this to him afterward, too, to ensure he took away the right information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the question was about something that was already explained in the documentation,
    point him at it, shout RTFM,^([[6](#ftn.APP-FN-6)]) and give him a poke in the
    eye.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#APP-FN-6)]) *Read The* (ahem . . . ) *Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How might the need for and the content of comments differ in the following
    types of code**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Low-level assembly language (machine code)**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shell scripts**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A single-file test harness**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A large C/C++ project**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assembly language is less expressive, providing fewer opportunities for self-documenting
    code. Therefore, you'd expect more comments in assembly code, and you'd expect
    those comments to be at a much lower level than comments in other languages—assembly
    language comments generally *would* explain how as well as why.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't an enormous a difference between the remaining three. Shell scripts
    can be quite hard to read back; they are proto-Perl in this respect. Careful commenting
    helps. You're more likely to use literate programming techniques on a large C/C++
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '**You can run tools to calculate what percentage of your source code lines
    are comments. How useful are these tools? How accurate a measure is this of comment
    quality?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This kind of metric will give insight into the code, but you shouldn't get too
    concerned about it. It isn't an accurate reflection of code quality. Well-documented
    code might not contain *any* comments. Enormous revision histories or large corporate
    copyright messages can dominate small files, affecting this metric.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you come across some incomprehensible code, which is the better way to
    factor in some intelligibility: adding comments to document what you think is
    going on, or renaming variables/functions/types with more descriptive names? Which
    approach will most likely be easier? Which approach will be safer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should do both, as appropriate. Renaming is arguably the best approach,
    but it's dangerous if you don't know exactly what a function does. You might be
    giving it another equally bad name. When renaming, you must be sure you know the
    nature of the item you're changing.
  prefs: []
  type: TYPE_NORMAL
- en: Use the code's unit tests to ensure that your modifications don't break any
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**When you document a C/C++ API with a code comment block, should it go in
    the public header file that declares the function or the source file containing
    the implementation? What are the pros and cons of each location?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This question was the cause of a big fight at one place I worked. Some argued
    for descriptions to go in the `.c` file. Being close to the function means that
    it's harder to write an incorrect comment and harder to write code that doesn't
    match the documentation. The comment is also more likely to be changed in line
    with any code changes.
  prefs: []
  type: TYPE_NORMAL
- en: However, when placed in a header file, the description is visible alongside
    the public interface—a logical location. Why should someone have to look into
    the implementation to read any public API docs?
  prefs: []
  type: TYPE_NORMAL
- en: A literate programming documentation tool should be able to pull comments out
    of either place, but sometimes it's quicker to just read comments in the source
    instead of using the tool—a bonus of the literate code approach. I favor placing
    the comments in header files.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in Java and C#, there's only one source file anyway; you'd conventionally
    use the Javadoc or C# XML comment format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Look carefully at the source files you''ve recently worked on. Inspect your
    commenting. Is it honestly any good? (I bet as you read through the code you''ll
    find yourself making a few changes!)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you read and review your own code, it's very easy to skip the comments,
    presuming they're correct or at least adequate. It is a good idea to spend some
    time looking at them and assess how well you've written them. Perhaps you could
    ask a trusted colleague to give you his or her (constructive) opinion on your
    commenting style.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you ensure that your comments are genuinely valuable and not just
    personal ramblings that only you can understand?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some considerations for this are: write whole sentences, avoid abbreviations,
    and keep comments neatly formatted and in a common language (both the native language
    and the selection of words used from the problem domain). Avoid inside jokes,
    throw-away statements, or anything that you''re not entirely sure about.'
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews will highlight weaknesses in your comment strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do the people you work with all comment to the same standard, in about the
    same way?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Who''s the best at writing comments? Why do you think that? Who''s the worst?
    How much of a correlation does this bear to these individuals'' general quality
    of coding?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you think any imposed coding standards could raise the quality of the
    comments written by your team?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use code reviews to inspect the comment quality of your peers and to move your
    team toward a consistent quality of commenting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you include history logging information in each source file? If yes:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you do maintain it manually? Why, if your revision control system will
    insert this for you automatically? Is the history kept particularly accurate?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is this really a sensible practice? How often is this information needed?
    Why is it better if placed in the source file than in another, separate mechanism?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It's human nature not to keep a history accurate, even with the best intentions
    in the world. It requires a lot of manual work that gets skipped when time is
    tight. You should use tools to help maintain a history and put the right information
    in the right place (which I don't believe is the source file at all).
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you add your initials to or otherwise mark the comments you make in other
    people''s code? Do you ever date comments? When and why do you do this—is it a
    useful practice? Has it ever been useful to find someone else''s initials and
    timestamping?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For some comments, this is a useful practice. In other places, it's just inconvenient—extra
    comment noise that you have to read past to get to the really interesting stuff.
  prefs: []
  type: TYPE_NORMAL
- en: It's most useful with temporary `FIXME` or `TODO` comments, marking work in
    progress. Released production code probably shouldn't have these; no finished
    code should need a reader to understand the author or date of a particular change.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. TO ERR IS HUMAN")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Are return values and exceptions equivalent error reporting mechanisms? Prove
    it**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return values are equivalent to global *status variables* because the same reason
    code information can be sent back by both mechanisms (although it is easier to
    ignore a status variable). You can write code that works in a similar manner using
    both of these approaches.^([[7](#ftn.APP-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are a very different beast. They involve a new control flow, something
    very different from simple reason codes. They are tightly bound into the language
    and program run time. While you *can* simulate exceptions by hand-crafting code
    that propagates errors, you''d have to carefully consider:'
  prefs: []
  type: TYPE_NORMAL
- en: How to represent errors as arbitrary objects, not just as integer reason codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting exception class hierarchies and providing the ability to catch by
    base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propagating exceptions through *any* function, even those without `try`, `catch`,
    or `throw` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's that final point which shows most clearly why the two are *not* equivalent.
    Implemented at a language level, exceptions are not at all intrusive in your code.
    A hand-crafted facsimile must manage the possibility of failure at every point.
    Every function is forced to return an error code—even if it cannot fail itself—just
    to propagate other error information. This requires serious adaptation of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**What different implementations of tuple return types can you think of? Don''t
    limit yourself to a single programming language. What are the pros and cons of
    using tuples as a return value?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In C you can create a `struct` for every return type, linking it with an error
    reason code. This would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is messy, tedious to write, cumbersome to use, and hard to read. You can
    exploit C++ templates or Java/C# generics to automatically build this scaffolding,
    or you can use C++'s `std::pair` class. Both approaches are seen in production
    C++ code. Both are tedious to use, with the extra declarations and the machinery
    necessary to return these types. Some languages, like Perl, support lists of arbitrary
    types; this is a much easier implementation mechanism. Functional languages also
    provide such a facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve just seen some of the disadvantages of this technique: It''s very intrusive
    in the code and not at all sympathetic to the reader. It is also not an idiomatic
    coding practice. There may be a performance hit when returning more than one argument,
    but this is not a compelling argument, unless you''re working at the machine code
    level. The notable advantage is that a separate reason code doesn''t interfere
    with any return value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How do exception implementations differ between languages?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The four main implementations we''ll consider are: C++, Java, .NET, and Win32
    structured exceptions. Win32 exceptions are bound to the operating platform, the
    others to their languages. Languages *may* be implemented in terms of such underlying
    platform facilities, or they may not be.'
  prefs: []
  type: TYPE_NORMAL
- en: They all follow a similar approach; you can `throw` an exception, which is later
    handled by a `catch` statement placed after code wrapped in a `try` block. They
    all follow the termination model's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Java, .NET, and Win32 also have a `finally` construct. It contains code that
    is run whether execution leaves the `try` block normally or abnormally. This can
    be a good place to put cleanup code to ensure that it always gets called. `finally`
    can be simulated in C++, but it isn't pleasant.
  prefs: []
  type: TYPE_NORMAL
- en: The raw Win32 exceptions (minus any language support provided by compilers)
    don't clean up as they unwind the stack, because the OS has no concept of destructors.
    They must be used with care—they are intended to handle situations more akin to
    signals than code logic errors.
  prefs: []
  type: TYPE_NORMAL
- en: Java exceptions (deriving from `Throwable`) and C# exceptions (deriving from
    `Exception`) automatically provide a diagnostic backtrace—very helpful in later
    debugging. .NET's CLI allows anything to be thrown, but C# does not expose the
    ability to do so (it does expose the ability to catch them, though). Other .NET
    languages can throw whatever they like.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signals are an old-school Unix mechanism. Are they still needed now that
    we have modern techniques like exceptions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, they are still needed. Signals are a part of the ISO C standard, and so
    they aren't easy to remove, anyway. Signals date from (pre) System-V Unix implementations.
    They are an asynchronous mechanism to report system-level problems/events. Exceptions
    solve a different problem, reporting code logic errors that can percolate up to
    a handler. It makes no sense to throw an exception for signal-type events, especially
    using the termination model—it doesn't provide asynchronous handling.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the best code structure for error handling?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is simply no answer to this question. Different code strategies will work
    best in different situations. What's important is to reliably detect and handle
    errors with clear, readable, maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: '**How should you handle errors that occur in your error-handling code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Errors signaled within error handlers should be dealt with as you would any
    other error. It gets nasty fast, though—you end up with error handlers nested
    within error handlers nested within error handlers. Be very careful about this,
    and check for a neater way to structure your code.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to only perform operations that are guaranteed to succeed
    (or that honor the nothrow exception guarantee) in your error handlers. That way,
    your world is a much nicer place to be.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How thorough is the error handling in your current codebase? How does this
    contribute to the stability of the program?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a direct correlation between good error handling and stable code. Either
    your program is not required to be robust, or it *must* systematically detect
    and handle all error conditions. If this isn't deeply rooted in the program's
    philosophy, then you will not have a reliable system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you naturally consider error handling as you write code, or do you find
    it a distraction, preferring to come back to it later?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s natural to dislike error handling; no one wants to focus on the negative
    aspects of program functionality all the time.^([[8](#ftn.APP-FN-8)]) However,
    heed this important advice: Don''t put it off until later. If you do, some potential
    errors will inevitably be missed, one day causing unexpected program behavior.
    Get into the habit of thinking about errors *now*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Go to the last (reasonably sized) function you wrote or worked on, and perform
    a careful review of the code. Find every abnormal occurence and potential error
    situation. How many of these were actually handled in your code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Now get someone else to review it. Don''t be shy! Did they find any more?
    Why? What does this tell you about the code you''re working on?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is a telling insight into how thorough a programmer you really are. Make
    sure that you perform this exercise carefully—and *do* ask someone else. Even
    the most accomplished programmer will miss some error cases.^([[9](#ftn.APP-FN-9)])
    If these are unlikely to manifest as bugs, you'll probably never notice and live
    forever in the shadow of potentially weird behavior.
  prefs: []
  type: TYPE_NORMAL
- en: When using exceptions, you can't easily ignore an error case—exceptions force
    their own way up the call stack, regardless of whether you handle them or not.
    You *can* still write bad code if it isn't exception safe (it may exit in a bad
    state, or with leaked resources) or if it performs over-eager catches (consuming
    errors that can't actually be handled at that level—for this reason, don't write
    `catch(...)` to catch all exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you find it easier to manage and reason about error conditions using return
    values or exceptions? Are you sure you know what is involved in writing exception-safe
    code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To some extent, this depends on what you're used to. Exceptions complement and
    extend return values. An exception user can also understand return values, but
    the opposite doesn't necessarily hold. Return values are more obvious, hence easier
    to use properly.
  prefs: []
  type: TYPE_NORMAL
- en: If you do use exceptions, it's important to know what issues to be aware of.
    Exception safety affects *all* of your code, not just the parts that raise and
    catch errors. Exception safety is a large and involved subject that needs much
    study. Don't underestimate how seriously it affects the way you program.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#APP-FN-7)]) They are not quite the same, though. In C++ you can return
    a *proxy* value type that has behavior in its destructor. This infuses extra magic
    into the return code mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#APP-FN-8)]) If you are inclined that way, you'd probably make a very
    good software tester. But don't change careers just yet—really thorough programmers
    are few and far between.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#APP-FN-9)]) How often does anyone check for errors from C's `printf`,
    for example?
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Is it more important for everyone in a development team to use the same IDE,
    or for each person to pick the one that suits him or her best? What are the implications
    of different people using different tools?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All professional programmers should be responsible and informed enough to select
    the tools that make them most productive. No two programmers are the same, and
    different people will naturally prefer different tools. As long as the choice
    is made based on practical considerations, the team's overall effectiveness will
    be improved. But forcing strong-minded techies to use particular tools rarely
    enthuses them to work well.
  prefs: []
  type: TYPE_NORMAL
- en: If the people on a team *are* all using different development environments,
    then they must work together properly. They must build *identical* code, and each
    editor mustn't fight the others' layout rules every time a source file is edited.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the minimum set of tools that any programmer should have at his or
    her disposal?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can''t get by without at least:'
  prefs: []
  type: TYPE_NORMAL
- en: Some rudimentary form of editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum language support required (either a compiler, an interpreter, or
    both—it depends on the language)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer to run them on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But that minimum set won't make a very productive programmer. You need a toolbox
    of other tools to get any serious work done.
  prefs: []
  type: TYPE_NORMAL
- en: There must be a revision control system, or work is downright dangerous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reasonable set of libraries will prevent reinventing wheels and lower the
    risk of introducing avoidable bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also need a build tool to help construct the software system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a more realistic minimum set. The more fundamental tools you add in,
    the easier it is to develop, and the better the code that will be produced.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which are more powerful: command-line or GUI-based tools?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I should break your arm if you even began to answer this question. Command-line
    and GUI tools are different. End of story.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting philosophical question is: *In this context, how do you define
    "powerful?"* Does it mean having more esoteric features? Does it mean how easy
    the tool is to use? Does it mean how fast it runs? Or does it determine how well
    a tool fits into the rest of the toolchain? Decide on a definition, and then try
    justifying your answer in terms of that. Then I might not break your arm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Are there construction tools that aren''t programs?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already categorized languages and libraries as tools, so the answer is *yes*.
    Other good examples to consider are:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical components (GUI "widgets")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common protocols and formats (like XML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design methodologies (like CRC cards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What''s most important for a tool?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interoperability**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Flexibility**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Customization**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Power**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ease of use and learning**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these is important. The balance probably changes for different types
    of tools and the situations in which you'll use them.
  prefs: []
  type: TYPE_NORMAL
- en: Power is important; your tools must be powerful *enough* for the tasks you set
    them to, or your life will be hell. If this weren't the case, programmers would
    edit their source code using Notepad or vi.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What are the common tools in your toolbox? Which do you use every day? Which
    do you use a few times a week? Which do you only call on occasionally?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How well do you know how to use them?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are you getting the most from every tool?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How did you learn to use them? Did you ever spend any time improving your
    skill with them?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are these the best tools you could be using?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The last question in that list is critical. Honestly appraise whether there
    are any better tools you could be using. It really is worth spending some time
    looking around. If there are better tools, get your hands on them and start experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: '**How up to date are your tools? Does it matter if they''re not the latest
    cutting-edge versions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Out-of-date tools can cause nasty problems, but so can the latest tool versions.
    The nastiest problems occur when one tool version is out of sync with rest of
    the toolchain. There may be a subtle functional mismatch because of the version
    skew, causing the toolchain not to work together properly. The symptom is seldom
    a toolchain failure, but code that behaves in surprising ways.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-date tools may miss important bug fixes. An update might not seem important
    until you've been bitten by the bug it addresses. Hindsight is a wonderful thing.
    If you get out of date, you could end up relying on tools that are no longer supported,
    written by companies that no longer exist. This can become a serious problem in
    a critical project.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can't always download and install a new tool version on a whim.
    It may not be practical to upgrade for a number of reasons. It may cost more than
    you can afford. The upgrade may force you to upgrade your OS or other critical
    parts of your toolchain, when this isn't practical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you favor an integrated tool set (like a visual development environment)
    or a discrete toolchain? What are the advantages of the other approach? How much
    experience do you have with both ways of working?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A careless answer here might cost you your arm (see the answer to question 3
    in the "Mull It Over" section on page 491). Try to come up with a serious list
    of the benefits of the other way of working—to ensure you avoid a narrow-minded
    and opinionated view.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are you a Default Dan or a Tweaker Tom? Do you accept the default settings
    in your editor, or do you customize them to within an inch of their lives? Which
    is the "better" approach?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You learn to use and get the most out of your editor by discovering how to configure
    it. In that case, Tom *might* have the most sensible approach. A pragmatic stance
    is probably somewhere between the two (a good example of the *Goldilocks principle*;
    behavior at the extremes is rarely best). There's no point configuring features
    you'll never touch. Some things really don't matter—I'm not all that worried about
    the color scheme an editor uses. But others things do matter—I don't want to be
    forced to accept a default code layout style if it's grotesque.
  prefs: []
  type: TYPE_NORMAL
- en: It's far better to code to your carefully chosen layout style than have it dictated
    by the editor's default settings. Indeed, your house coding style may *require*
    it. I'd rather configure my editor to automatically format code as I want, rather
    than fight its cursor positioning every time I hit ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of discussion scales beyond editors to any kind of configurable software
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you determine your budget for software tools? How do you know whether
    a tool is worth its cost?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It depends on what kind of organization you're working for and the kind of work
    you're doing. If your project has the tools budget of a small country's GDP, then
    the cost of tools is of no consequence—buy the best tools (which may not necessarily
    be the most expensive ones) and enjoy them. But a lone hacker working at home
    can't justify the same kind of expense for a top-notch toolchain. Often the freely
    available tools are more than adequate for this kind of home use.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the freely available tools are often of a very high quality, which makes
    it hard to draw the line as to when paying for tools is worthwhile. Paying for
    a toolchain usually means that you can *expect* good product support and demand
    future bug fixes or development work. However, this doesn't always pan out—companies
    go out of business and products are discontinued. This is *perhaps* an argument
    for picking the most popular, widely used tools. There's safety in numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If all reasonable criteria fail, the more expensive a tool is, the larger its
    box should be. If it costs a fortune but comes in a small box, don't buy it!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Write a test harness for the** `greatest_common_divisor` **code example earlier
    in this chapter. Make it as exhaustive as you can. How many individual test cases
    have you included?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How many of these passed?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How many failed?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using these tests, identify any faults and repair the code**.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a large number of tests you should run, even though there are very
    few invalid input combinations. Thinking of invalid inputs first: Test for *zero*.
    It may or may not be an invalid value (we''ve seen no spec, so we can''t tell),
    but you''d expect the code to cope reasonably with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, write tests considering combinations of usual inputs (say of 1, 10, and
    100 in all orders). Then try numbers with no common multiple, like 733 and 449\.
    Test for some very large numbers and for some negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you write these test cases? Write a simple unit test function, and then
    place it into an automated test framework. For each test, don''t programatically
    calculate what the correct output value should be;^([[10](#ftn.APP-FN-10)]) just
    check against a known constant value. Keep your test code as simple as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a surprisingly large number of tests for this simple function. You
    could argue that for such a small piece of code, it's easier to inspect, review,
    and prove correctness rather than laborously create a set of tests. This seems
    like a valid argument. But—what if later on, someone makes modifications? Without
    the tests, you'd have to carefully reinspect and revalidate the code, an easy
    task to overlook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you find the mistake in `greatest_common_divisor`? There''s a clue coming
    up. If you don''t want the puzzle spoiled, then look away now. . . . *Try feeding
    it a negative argument*. This is a more robust (and more efficient) version written
    in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**How should the testing of a spreadsheet application and an automatic aircraft
    pilot differ?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In an ideal world, there would be no faults in either. In this utopia, both
    would be exhaustively tested and not released until perfect. Reality is somewhat
    different. Whereas you expect spreadsheets to crash from time to time,^([[11](#ftn.APP-FN-11)])
    you expect an autopilot to contain no errors at all. When human lives hang in
    the balance, software is developed in a very different way—far more formally and
    with much greater care. It is tested rigorously. There are safety standards at
    play here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should you test all of the test code that you write?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you think about this for long enough it will give you a headache. You can't
    keep testing test code—how can you be sure the test code for your test code's
    test code is correct? The trick is to keep tests *as simple as possible*. This
    way, the most likely testing errors will be lack of important test cases, not
    problems with the actual lines of test code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep test code as simple as possible to prevent the introduction of errors*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a programmer''s testing differ from a QA department member''s testing?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testers are more concerned with the black box style of testing and usually only
    perform product testing. It's rare to have testers working at the code level,
    because most products are executable software; there are comparatively few code
    library vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers are more concerned with white box tests, making sure their masterful
    creations work as they planned them to.
  prefs: []
  type: TYPE_NORMAL
- en: The secret aim of any programmer writing tests is to prove that his code works,
    not to find cases where it doesn't! I can easily write a load of tests to show
    how perfect my code is by deliberately avoiding all the bits I know are problematic.
    This is a good argument for getting someone other than the original programmer
    to create test harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it necessary to write a test harness for every single function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't need to be quite so extreme. Some functions are easy enough to verify
    by inspection. Be careful not to get sloppy, though—remember to read the code
    *cynically*. Simple getter and setter functions don't need a slew of individual
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: At what code size do test harnesses become attractive? Generally when the code
    becomes sufficiently complex to require it. When a single glance can't prove the
    code is correct, write some test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test-driven development encourages you to write tests first, before any code.
    What sort of tests should you write?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without having written any code, these can only be black box tests. Either that,
    or test-driven developers need a gift of prophecy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should you write C/C++ tests to check for the handling of** `NULL` **(zero)
    pointer parameters? What''s the value of such a test?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If zero is an expected input value, then of course you must test for it.
  prefs: []
  type: TYPE_NORMAL
- en: But you don't always need to test for null pointers. If you don't specify magic
    behavior for a zero pointer value, then your function is quite within its rights
    to fall over when you pass it a bad pointer. In this case, zero could be as bad
    as a pointer to deallocated or invalid memory. It's rarely possible to test that
    the code will survive all bad pointers.
  prefs: []
  type: TYPE_NORMAL
- en: However, it *can* be valuable to write code that is robust in the face of zero
    pointers, since they tend to fly around a lot. Many allocation routines return
    zero pointers for failure, and undefined pointers are often set to zero. If the
    dog might bite, it's a good idea to put a muzzle on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Your early code tests might not be on the final platform—you may not yet
    have access to it. Is it safest to defer testing until you do have a target test
    platform, or to steam ahead now?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If the code is intended to run in a different environment (perhaps on a high-capacity
    server, or some embedded device), how can you be sure that your tests are representative
    and adequate?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It depends on the nature of the code you're testing—whether it's a simple function
    doing housekeeping work or some hardware access logic. You must understand the
    differences between the development platform and the target environment. Memory
    constraints or processor speed may affect how the code runs. This probably isn't
    a big deal for the majority of the code you write, for which it is perfectly possible
    to create local test harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: If your code exploits particular target platform features (parallel processors
    or particular hardware facilities), then you can't test fully without them. There
    may be simulators to check that the code runs; they are helpful, but not the definitive
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all testing off until you have a target platform is a dangerous practice.
    By then you'll have a large body of code that you will have neither the time nor
    the inclination to test fully. For maximum confidence, test as early as you reasonably
    can.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you know when you''ve finished and can stop testing? How much is enough?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since testing can't prove the absence of faults, you can never really tell when
    you're done. The task is potentially endless, and we're trying to come up with
    a test plan to make it a realistic exercise.
  prefs: []
  type: TYPE_NORMAL
- en: For simple blocks of code under black box testing, successfully running all
    the test cases in "[Choosing Unit Test Cases](ch08s05.html "Choosing Unit Test
    Cases")" on page 142 is sufficient. The larger your code gets, the more work you
    have to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can measure the adequacy and exhaustiveness of your tests by the angle
    of attack you''re taking. There are a few key strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coverage-based testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test plan is specified in terms of *coverage* of the software. For example:
    You may plan to execute every line of code at least once, execute every conditional
    branch both ways, or ensure that all system requirements are exercised at least
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fault-based testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This is based on weeding out a certain percentage of program faults. You start
    with a hypothetical number of faults, generally picked from prior experience.
    You then aim to detect and remove, say, 95 percent of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error-based testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This approach focuses on the common points of error, where the software is likely
    to be brittle. For example, you'd eliminate off-by-one errors by testing all boundary
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, here are some good reasons to stop testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Regression test cases complete with a certain percentage passed (and no major
    *show-stopping* failures remaining).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage of code, functionality, or requirements reaches a specified point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhibited bug rate falls below a certain level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beyond these are some physical barriers, seldom movable, which will have a
    final say in determining an end point:'
  prefs: []
  type: TYPE_NORMAL
- en: Hitting scheduled deadlines (testing deadlines or release deadlines). Development
    work has a nasty habit of overrunning and eating into the scheduled test time;
    this requires very careful management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test budget is depleted (a very sad criteria for stopping).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beta or alpha testing period ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most organizations, the decision to stop testing and ship the product comes
    at a deadline. It's a compromise based on the remaining known faults, their severity,
    and the frequency of their occurrence, pitched against the need to get to market.
    The tests allow an informed judgment to be made about how acceptable the software
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**For what percentage of your code do you write tests? Are you happy with this?
    Are your tests an automated part of the build process? What sort of testing do
    you give the remaining code? Is this adequate? What will you do about it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Don''t feel obliged to write a test harness for every scrap of code. But don''t
    forget to use your brain, either. The implementation of a small function is often
    a no-brainer—so you tend to code it with no brain—and voilà: stupid errors. Since
    a simple function only needs a simple test, it''s probably valuable to write it.
    In my code shop, we have a simple rule: *Every* piece of code has a unit test,
    or it''s not in the codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure that you *are* performing the adequate and appropriate testing for
    which you are responsible, not just skipping an unpleasant task. Ask yourself
    this: How many of the errors that have bitten you recently could have been prevented
    by a good set of tests? Make sure you do something about it.'
  prefs: []
  type: TYPE_NORMAL
- en: If your tests are not a part of the build system, then how do you ensure that
    the tests are ever run and that all the code passes them?
  prefs: []
  type: TYPE_NORMAL
- en: '**How good is your relationship with the people in your QA department? What
    personal reputation do you think you have with them?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is vital to establish good working relationships between the QA department
    and the software developers. Rivalry often brews; the testing department is seen
    as a bunch of people who aim to get in the way of developers and hinder the path
    to release, rather than as a team who is helping to build a stable product. Usually
    the test and development departments sit far, far away from one another, only
    taking orders from their individual tribal chieftains.
  prefs: []
  type: TYPE_NORMAL
- en: Forget that.
  prefs: []
  type: TYPE_NORMAL
- en: Make them coffee. Take them out for lunch. Head down to the bar with them. Anything
    to prevent fostering a *them and us* attitude.
  prefs: []
  type: TYPE_NORMAL
- en: Develop a professional working relationship. Make sure that you provide them
    with good, well-tested code—not just any old hurried junk. Throwing them your
    scraps to mop up will give the impression that you see them as servants working
    *for* you, not colleagues working *with* you.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s your usual response to finding an error in your code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several possible reactions:'
  prefs: []
  type: TYPE_NORMAL
- en: Disgust and disappointment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An urge to blame someone else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Happiness, if not downright *excitement*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretending you didn't find it, ignoring it, and hoping it will go away (as if
    *that's* likely)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of those are so plainly wrong that I'll assume you can rise above them.
    Does it seem a little crazy to suggest that you might be *happy* to find a fault?
    Surely that's the reasonable reaction for a quality-conscious engineer—it's far
    better to find faults during development than for a user to find them in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Your level of excitement will depend on where in the development life cycle
    the fault is found. Discovering a show-stopping bug the day before release won't
    make anyone smile.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you file a fault report for every code problem you uncover?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s not really necessary to do this for every single fault: If no one''s
    seen your code yet and it''s not been integrated into the wider system, then you
    don''t need to broadcast your incompetence! If you don''t report a fault in the
    database, then you must make methodical notes so that you don''t forget about
    it. For this reason, you might find it easier to use the fault-tracking system
    from the outset. You might be forced to raise fault reports if delivery is so
    late that people *need* visibility of the remaining problems.'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as any code is released, you should make all of its faults public; you
    *have* to file fault reports. This shows that you have identified each issue and
    have a plan to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you discover a code fault, you should write a test case that excercises
    it and incorporate it into your suite of automatic tests to be run as a regression
    check. This acts as a form of documentation for the fault and ensures that it
    won't be reintroduced accidentally, later on.
  prefs: []
  type: TYPE_NORMAL
- en: '**How much testing are the project engineers expected to do?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to know what's expected of you and to deliver that level of testing.
    But above this, don't just do what's *expected*—do what *needs* to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Write a unit test for *every* piece of code you create. If you need to modify
    someone else's work, write a test for it first if there isn't one. That way, you
    will know how well it currently works, what needs to be fixed, and how to prove
    that your modifications haven't busted anything.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[10](#APP-FN-10)]) This would open the door to more coding errors—imagine
    the pain of bugs in the test code!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#APP-FN-11)]) It's sad we've been conditioned to accept this.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Is it best for faults to be fixed by the original programmer who wrote the
    code? Or is the programmer who discovered the problem better placed to make a
    fix?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's always helpful to approach any problem with a fresh pair of eyes. When
    debugging, this method avoids the common problem of a programmer reading what
    he *meant* to write, not what the code actually says—too many bugs stay hidden
    that way.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the original programmer *is* probably best placed to make
    the fix. He understands the code inside out (hopefully). He knows what repercussions
    a particular change will have. He'll be the quickest to pinpoint the location
    of a fault.
  prefs: []
  type: TYPE_NORMAL
- en: In Real World organizations, the choice of who makes a fix may be determined
    by individual free time and what other commitments the team has. For bugs that
    have been in the program since time immemorial, the original programmer is probably
    no longer available. He may have left the company, moved projects, or (worst of
    all) been promoted to management.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you tell when to use a debugger and when to use your brain?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously, even the use of a debugger should be with your brain engaged. (Remember
    the golden rule of debugging?)
  prefs: []
  type: TYPE_NORMAL
- en: 'My rule of thumb is: Don''t fire up a debugger until you know exactly what
    information you need to get out of it. The danger lies in using a debugger to
    putter around in the running code, not really knowing what you are looking for.
    You can waste hours doing this, with no real reward.'
  prefs: []
  type: TYPE_NORMAL
- en: '**You should learn unfamiliar code before you start trying to find and fix
    faults in it. But the time pressures of the software factory often dictate that
    you can''t spend any serious time studying and understanding the program you''re
    repairing. What''s the best way forward?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your dreams, you'd slap the people who wrote the schedule and take as long
    as necessary to fix the fault properly. Wake up, Alice. . . .
  prefs: []
  type: TYPE_NORMAL
- en: The best you can do is try to learn the code as you go along. Proceed with extra
    caution when working through it, and don't trust what you *think* is happening—always
    make sure that the code is doing what you expect it to. When you think that you've
    found the cause of the bug, see if anyone on your team knows about the offending
    section of code. Discuss with them what you're going to do. Often when you describe
    the situation, you'll explain *to yourself* the obvious thing you've just missed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe good techniques to avoid memory-leak bugs**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are some good approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a language where you're less likely to be bitten by them, such as Java or
    C#. (You can still be bitten by memory leaks in these languages. Do you know how?)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use "safe" data structures that manage memory for you, so you don't have to
    worry about it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Employ helpful language idioms, such as C++'s `auto_ptr`, to avoid problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be rigorous and methodical in your handling of memory. For every allocation
    point, make sure there is a balancing deallocation point and that it will always
    be called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your code through memory validator tools to ensure no bugs have crept through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When is it justifiable to have a quick stab at finding and fixing a fault,
    rather than adopting a more methodical approach?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You *always* need to think about what you're doing. Even quick fiddling should
    be done with your brain firmly in gear. Don't blindly pepper the code with breakpoints
    to start digging around in the internals; try to think about how the code is designed
    and what it should be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Gut feelings and your instant reactions may find a fault quickly in *very small
    programs* (say, a few tens of lines). But in a program that's many thousands of
    lines long, you really need to know what's going on. There is no substitute for
    insight. There's nothing wrong with tracing the program's execution in a debugger
    to examine what it's doing, but chose the test points methodically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How many debugging techniques/tools do you routinely use? What others have
    you seen that you might find useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously the answer is *none*. You always write perfect code the first time!
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the common problems and pitfalls in your language(s) of choice?
    How do you guard against these kinds of bugs in your own code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to know this kind of thing. It's what sets mediocre programmers
    apart from the experts. If you don't know where the dragons live, then you don't
    know how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are most of the bugs that occur in your code sloppy programming errors, or
    are they more subtle issues?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you get bitten over and over again by little language snafus, it shows that
    you should write code more carefully. Take time with your code. Proofread it,
    and then reread it—you'll save time overall. A classic mistake is fixing one fault,
    not testing that it works, and then being bitten by undesirable side effects of
    your "fix."
  prefs: []
  type: TYPE_NORMAL
- en: There's no shame in having bugs in your code. Everyone gets them. Just make
    sure they're not stupid mistakes that you could have easily prevented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you know how to use a debugger on your platform? How routinely do you
    use it? Describe how to**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Produce a backtrace**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inspect variable values**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inspect value of fields within a structure**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run an arbitrary function**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Swap thread contexts**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use a debugger all the time, then that's *too much*. If you never use
    one, then that's *too little*. Don't be afraid of your debugger, but don't use
    it as a crutch, either. Intelligent use of a debugger will allow you to hone right
    in to the location of a fault in little to no time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Why should people with nice integrated development environments worry about
    using a command-line make utility, when they can just hit a single button to build
    their project?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides learning what's really going on behind the build button, knowing how
    to use make is a route to more powerful, flexible software construction. Rarely
    does a GUI build tool compare to the capabilities and malleability of makefiles.
    Simplification often *is* a good thing, and GUI tools can help developers to create
    software quickly, but this simplicity comes at an expense.
  prefs: []
  type: TYPE_NORMAL
- en: GUI build tools simply do not scale well and are of little use on really large
    projects. Make does have a cryptic syntax, but it lets you do far, far more. For
    example, makefiles allow nesting of directories, creating a build hierarchy. Simplistic
    GUI tools only provide one level of depth, the nesting of projects inside a workspace.
  prefs: []
  type: TYPE_NORMAL
- en: People complain about make's complexity and that you can foul things up using
    it. This is a valid concern, but it is the same as with any power tool—you might
    injure yourself if you don't use it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t mean that you should throw away all GUI build tools and start
    writing a raft of replacement makefiles. On the contrary: Use the right tool for
    the job. Balance simplicity and integration with power and extensibility; choose
    the tool that''s required each time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it important to treat the extraction of source code as a separate
    step from building it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two *are* logically different steps. In a properly crafted build system,
    you should be able to check out *any* version of the software, no matter how old,
    and then issue the same make instruction to build it. Later you should be able
    to clean the tree and rebuild it using the same instruction, without checking
    everything back out again.
  prefs: []
  type: TYPE_NORMAL
- en: It's no loss to have these as two separate steps. You can easily wrap a script
    around them to make a single-step retrieve/build procedure—this will then be useful
    for an overnight build script. For these overnight scripts, it's vital to start
    from a fresh source tree each time (to avoid being caught out by problems carried
    over from the last tree). This is a good test of your source tree; by deleting
    it and performing a complete rebuild, you'll check that no files are missing or
    out of date (you might have forgetten to check something in).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other problems with binding source extraction into the build step include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't want the build system to automatically check files out of the source
    repository as you do a build. You rarely want the whole world changing under your
    feet each time you rebuild. It's important to be in control of the code you're
    working on, not a slave to the build system behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a bootstrapping problem: If extraction is a part of the build process,
    where do you get a source tree from in order to start the build? You''d have to
    check it out manually anyway! Or you''d have to recite more magic incantations
    to partially check out the build portions of the tree in order to perform a real
    checkout and build. Don''t go there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Where should the intermediate files from construction steps (e.g., object
    files) be put?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some build systems dump object files beside the source file that generated
    them. Advanced build systems can create a parallel directory tree and build objects
    into *there*, leaving the source directories intact. This keeps things neat, distinguishing
    source files from the build-generated files. There are downsides, though: It''s
    harder to search around the hierarchy. You might want to force a source file recompilation
    by deleting a `.o` file, but with split trees you have to navigate further from
    the source to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Another neat approach for object file placement is to put intermediate files
    within the source tree, but in their own subdirectory; out of way of the source
    files, but still close to hand. You'd end up with a directory hierarchy looking
    like [Figure A-1](apas10.html#putting_built_object_files_in_a_subdirectory "Figure A-1. Putting
    built object files in a subdirectory").
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good way to support the building of *multiple targets* from one source
    tree—each target has its own build subdirectory. Without this mechanism, you could
    start a debug build, finish it off in release mode, and have a link stage that''s
    a disaster. Adopting this approach leads to a build tree looking [Figure A-2](apas10.html#even_better_colon_putting_object_files_in_a_named
    "Figure A-2. Even better: Putting object files in a named subdirectory").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting built object files in a subdirectory](tagoreillycom20080909nostarchimages207590.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure A-1. Putting built object files in a subdirectory**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Even better: Putting object files in a named subdirectory](tagoreillycom20080909nostarchimages207592.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure A-2. Even better: Putting object files in a *named* subdirectory**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you add an automated test suite to the build system, should it run automatically
    after the software is built, or must you fire a separate command to invoke the
    tests?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can easily provide a separate command (something like a *tests* makefile
    target; you'd type `make tests` after `make all`). However, this extra step would
    be less likely to be performed—there's no requirement to do so. The tests may
    be overlooked. This is quite likely, human nature being what it is. The untested
    code could cause all sorts of problems, making the effort of writing tests fruitless.
    Ensure your unit tests are a part of the main build procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Automated stress tests and load tests probably shouldn't be part of this build
    step, though. They might take too long to execute, only intended to be run on
    the overnight build. In this case, make an automated scaffold to run them, but
    don't trigger it during a normal build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should the overnight build be a debug or release build?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both. It's very important to test the release build configuration as early as
    possible. Debug builds shouldn't be released to the QA department, let alone outside
    the company.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to test that both release and development build processes work—not
    just once when the build system is created, but on an ongoing basis. It's remarkably
    easy to make a minor update that breaks one or other build. If a build isn't tested
    until the last minute, you're going to be very angry when it fails with a deadline
    looming.
  prefs: []
  type: TYPE_NORMAL
- en: There may be serious differences between executables generated by debug and
    release builds. Some compilers exhibit markedly changed behavior in debug and
    release mode. One popular compiler is happy to pad out data buffers in debug builds,
    so memory overruns are harmless and go undetected—hardly a good debugging aid.
    If you only ever tested the debug build, switching to release mode just before
    the product ships means that you are bound to run into problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Write a make rule to automatically generate dependency information from your
    compiler. Show how to use this information in the makefile**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several ways to achieve this, depending in part on how you get dependency
    information from your compiler. Say the hypothetical `compiler` takes an extra
    `-dep` parameter that cajoles it to create a dependency file as well as the object
    file. Let''s say that the format of this generated file is already in make''s
    dependency format.^([[12](#ftn.APP-FN-12)]) Using GNU Make, you can specify a
    compilation rule that has the side effect of generating dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then incorporate all generated dependency files directly into the makefile
    by putting this at the bottom of `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s that easy! Of course, this is the simplest mechanism that will work.
    There are many refinements to clean this up. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: You can direct the dependency files into a separate directory. This prevents
    them from cluttering up the working directory and covering up the important files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can write an include rule to only pull in the *correct* `.d` files. There
    may be other `.d` files lying around that you shouldn''t include, making the wildcard
    `include` line dangerous: The inclusion of random information from invalid files
    will confuse make. This problem can crop up easily: If you remove a source file
    from the makefile but don''t clean the build tree first, the old `.o` and `.d`
    files will hang around in the working directories until you remove them manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the compiler permits, you can write a separate rule to create `.d` files,
    making them first-class citizens of the build system. This has the downside of
    slowing down the build process—the compiler will now be invoked *twice* for each
    source file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive make is a popular method of creating a modular build system spanning
    several directories. However, it is fundamentally flawed. Describe its problems
    and suggest alternatives**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conventional wisdom suggests that all large codebases built with makefiles should
    use the recursive make technique. Yet as powerful as recursive make is, it's fundamentally
    flawed. Don't ignore it, though. It's important to understand how recursive make
    works (or doesn't work) because it's so prevalent (many codebases employ recursive
    make), and you need to you know its problems to understand what makes a better
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'What renders recursive make a liability? It has a number of pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**'
  prefs: []
  type: TYPE_NORMAL
- en: It's so *slooooooow*. If you try to rebuild a source tree that's already up
    to date, a recursive build still has to trawl faithfully through each directory.
    For a reasonably sized project this takes ages, which is nonsensical when no action
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Each directory is built as a *separate* make invocation.^([[13](#ftn.APP-FN-13)])
    This circumvents many potential optimizations; shared include files will be inspected
    over and over and over again. Although filesystems can cache information, this
    is still an unnecessary overhead. A sensible build system would only need to inspect
    each file once.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependencies**'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive make cannot follow dependencies correctly; subdirectory makefiles
    have no way of determining all dependency information. Your module makefile can
    observe that its local `func1.c` source file depends on a `shared.h` header in
    another directory. It will happily rebuild `func1.c` every time `shared.h` is
    changed. But what happens if `shared.h` is automatically generated by a separate
    module, based on some template file `shared.tmpl`? Your module can't know about
    this extra dependency. Even if it could, it doesn't know how to rebuild `shared.h`—that
    isn't its job. So if `shared.tmpl` is changed, `func1.c` will not be rebuilt appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to plaster over this crack is to arrange for `shared.h` to be built
    first, *before* `func1.c`'s module. The programmer must carefully define the *order*
    of recursion to make sure the software rebuilds correctly.^([[14](#ftn.APP-FN-14)])
    The more indirect dependencies that exist, the worse the mess gets.
  prefs: []
  type: TYPE_NORMAL
- en: Faced with this problem, programmers devise nefarious work-arounds, like making
    several build passes over the tree or manually removing certain files to force
    a rebuild every time. These hacks only serve to slow the build down more and unnecessarily
    complicate the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Puts onus back on the developer**'
  prefs: []
  type: TYPE_NORMAL
- en: Make was created to manage the complexity of rebuilding code. Recursive make
    turns this inside out and forces you to get involved in the build process again.
    We've seen how the programmer has to manage the order of recursion, kludging each
    makefile to work around limitations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Subtlety**'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive make's problems are not at all obvious. That's why many people still
    think it's a good idea. When things go wrong, they do so in strange ways. The
    cause of a problem is rarely clear, so it'll be dismissed as "one of those freak
    events."
  prefs: []
  type: TYPE_NORMAL
- en: This adds up to a build system that is dangerously brittle.
  prefs: []
  type: TYPE_NORMAL
- en: These are all problems people wrongly attribute to make itself, arguing that
    it is defective. But in this respect, make is an innocent bystander. It's our
    *use* of make that is at fault. The recursion introduces each of these problems;
    it inhibits make from doing its proper job.
  prefs: []
  type: TYPE_NORMAL
- en: So what's the solution to this mess? Clearly we don't want to throw away the
    nesting in our source trees. We need a build process that supports nesting but
    doesn't split up the build process recursively. This isn't too hard; we'll call
    the technique *nested make*. It simply involves putting all build information
    in one master makefile. There is no longer a need for individual subdirectory
    makefiles. The über-makefile manages all source nesting internally.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Contrary to popular belief, recursive make is a* bad *build technique. Avoid
    it in favor of a more robust* nested make *approach*.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that this is a more complex and less flexible approach.
    How can you manage a large build tree with just a single makefile?
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of practical implementation techniques make it easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Use make's include file mechanism. Put the list of each directory's source files
    in *that* directory—it's far more maintainable and clear that way. Place this
    list in a file called something like `files.mk`, and include that from the master
    `Makefile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can retain recursive make's modularity—entering *any* component subdirectory
    to type `make`—by defining more intermediate targets. These targets construct
    specific parts of the project. Constructing modular builds this way can be more
    meaningful than recursive make's arbitrary directory-based approach, and it ensures
    that each intermediate target is always built properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested make is no more complex than recursive make; in fact it can be *less*
    complex. It produces more reliable, accurate, speedy builds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Do you know how to perform different types of compilation using your build
    system? How can you build a debug or release version of the application from the
    same sources, with the same makefiles?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In an earlier answer, we saw a good solution to this problem: Build objects
    into different subdirectories, created by the build script, based on the type
    of build (one directory for debug files and one for release files).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve this in GNU Make by massaging filenames. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll obviously be doing more with the selected `BUILD_TYPE`, altering the
    compiler flags, for example. Don''t forget that you''ll need a rule to create
    the subdirectories, or your compiler will complain when it tries to generate output.
    Here''s how to do this on Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can type these two commands, one after the other, knowing the build
    system will cope perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You *can* create a simpler system without this subdirectory technique, but it
    will rely on doing a cleanout whenever you change the `BUILD_TYPE`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How good is your current project''s build process? Does it rate well against
    the characteristics in this chapter? How could you improve it? How easy is it
    to**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add a new file to a library?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add a new directory of code?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Move or rename a file of code?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add a different build configuration (say, a demo build)?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build two configurations in one copy of the source tree without doing a clean
    in between?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows both how well you know the build process and how maintainable it
    is. Comparing your build mechanism to other projects' is a good idea—it will show
    where your processes are inadequate and need improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Consider moving and renaming source files. Both are common during refactoring
    and are very easy to overlook. These simple actions *can* cause build systems
    to calculate dependencies incorrectly and build flawed code. I've been bitten
    more than once by such a problem; it takes a while to notice when this goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Often there is "no time" in the programmers' busy schedules to spend on improving
    the build system; they are all far too busy trying to get a product out the door.
    This is a dangerous misconception. The build scripts are a part of the code and
    require as much maintenance and careful extension as any other source file. A
    safe and reliable build system is so important that time spent sorting it out
    is *not* time wasted. It's time invested in the future of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Have you ever created a build system from scratch? What drove you to its
    particular design?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As with any programming task, the shape of your solution is influenced by a
    number of factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Your prior experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you know
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your understanding of the problem *at the moment*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The limitations of the technology available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of time you have to set it up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, a little time and a little usage will tell how good your design
    decisions were. You never appreciate all the requirements at first, and things
    change that no one can anticipate:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements change—if the product becomes really successful, you may need to
    build different internationalized versions or target a new processor architecture.
    The build system must accommodate extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code may need to be moved across to a new build toolchain, when no one ever
    anticipated that this should be a selectable option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easily these modifications can be incorporated is a testament to the quality
    of your design. You'll learn with each change, gaining valuable experience for
    the next build system you craft.
  prefs: []
  type: TYPE_NORMAL
- en: '**Everyone suffers from flaws in a build system from time to time. When programming
    a build script, you''re as likely to introduce bugs as you are when programming
    real code**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What kinds of build errors have you been bitten by, and how could you fix,
    or even prevent, them?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Common build errors include:'
  prefs: []
  type: TYPE_NORMAL
- en: Picking up dependency information incorrectly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not coping gracefully with file system failures, like running out of disk space
    or incorrect file permissions; the build may continue with no indication that
    one of the steps failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source control problems: merges go wrong, or the wrong version of some source
    code is checked out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library configuration errors, often using incompatible or out of date versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers not understanding how to use the build system, and making silly
    mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When something's not going as expected, step back and consider whether or not
    the build system is playing a part in the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#APP-FN-12)]) These are quite reasonable assumptions; many systems work
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#APP-FN-13)]) Just think of the overhead of starting up all those child
    processes!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#APP-FN-14)]) This is a one-up for GUI tools—without recursive make,
    they tend to manage dependencies properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. THE NEED FOR SPEED")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Optimization is a process of making trade-offs—sacrificing one quality of
    code for another desirable quality. Describe the kinds of trade-offs that lead
    to a performance increase**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The kinds of decisions that profoundly influence a program''s performance are:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of features versus size of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program speed versus memory consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage and caching versus computation on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarded approach versus unguarded; optimistic versus pessimistic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approximate calculations versus exact calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline versus function call; monolithic versus modular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing an array versus searching a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a parameter by reference or address versus passing a copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented in hardware versus software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard-coded, direct access versus indirect access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predetermined, fixed value versus variable and configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile-time work versus run-time work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local function call versus remote call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy computation versus eager computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Clever" algorithm versus clear code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Look at each of the optimization alternatives listed in "[Why Not Optimize?](ch11s03.html
    "Why Not Optimize?")" on page 202\. Describe what trade-offs are being made, if
    any**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of these alternatives *could* be considered optimizations, depending on
    how much of the system is under your control. If you specify the hardware platform
    that your program will run on, using a faster machine *is* an optimization. If
    not, it's more of a work-around.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the alternatives have hidden complexity costs. For example, relying
    on a certain host platform configuration (i.e., what services or background programs
    are running) leads to specific environmental dependencies that are hard to capture
    and easy to miss during installation or later maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Explain these terms and their exact relationship**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *efficiency* of code determines its *performance*. *Optimizing* is the act
    of improving the code's efficiency in order to improve performance. Notice that
    none of these terms directly describe *speed of execution*; the quality required
    may not be speed, but rather memory footprint or data throughput.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the likely bottlenecks in a slow program?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s common fallacy to think that everything is contending for the CPU and
    that bad code will be consuming all the processor time. Sometimes the CPU can
    be running almost idle, yet performance is dire. A program may stall for a number
    of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory is being thrashed to and from swap space on the hard disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is waiting on disk access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is waiting on slow database transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is bad locking behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How can you avoid the need to optimize? What methods will prevent you from
    writing inefficient code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've seen how important it is to *design* performance into a software system
    from the very beginning. You can only do this if you already have a firm idea
    of what the required performance characteristics are.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a sound design in place, write your code sensibly. Be aware which
    constructs are most efficient in your language, and avoid using the inefficient
    ones. For example, in C++, pass `const` references rather than expensive temporary
    copies.^([[15](#ftn.APP-FN-15)])
  prefs: []
  type: TYPE_NORMAL
- en: It's useful to have a rough idea of the relative costs of different operations.
    If we scale time so that a processor executes one instruction a second, then a
    function call typically takes a few seconds, a virtual function call takes 10
    to 30 seconds, a disk seek takes a few months, and the time between keystrokes
    of an average typist is several years. Try to work out this kind of measure for
    operations like a memory allocation, claiming a lock, creating a new thread, and
    a simple data structure lookup.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does the presence of multiple threads affect optimization?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Threading can cause as many problems as it's supposed to solve. Naïvely threaded
    designs can introduce extra bottlenecks, particularly when locks are used badly,
    leading to long periods of deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programs are harder to profile, unless the profiler has good thread
    support; you need to interpret the profiler's results based on the relative thread
    priorities. If the threads are supposed to cooperate, you have to work out how
    the overall execution is progressing as several threads of control weave around
    one another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why don''t we write efficient code? What stops us from using high-performance
    algorithms in the first place?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are many perfectly valid reasons for not writing optimized code on the
    first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't know the final pattern of usage. With no Real World test data, how
    can you choose the code design that will work best?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's hard enough to get the program *working*, let alone working *fast*. To
    prove it's feasible, we choose designs that are easy to implement so that prototypes
    get finished quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"High-performance" algorithms can be more complex and daunting to implement.
    Programmers naturally shy away from them, since it''s an area where faults can
    be easily introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers often think that the time taken to run some code is proportional
    to the amount of effort spent writing it.^([[16](#ftn.APP-FN-16)]) You might have
    written some file-parsing code in hours, but it will always takes ages to execute,
    because disks are slow. The complex code you spent half a week getting right may
    only consume a few hundred processor cycles. In fact, neither the efficiency of
    a piece of code nor the amount of time you need to spend optimizing it bears any
    relation to the amount of time you spent writing it.
  prefs: []
  type: TYPE_NORMAL
- en: '**A** `List` **data type is implemented using an array. What is the worst case
    algorithmic complexity of each of the following** `List` **methods?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The constructor**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`append`**—**places a new item on the end of the list**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`insert`—**slides a new item in between two existing list items, at a given
    position**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isEmpty`—**returns** `true` **if the list contains no items**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`contains`—**returns** `true` **if the list contains a specified item**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get`—**returns the item with a given index**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The worst cases are:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor is `O(1)` since it only needs to create an array; the list is
    initially empty. However, it's worth considering that the size of this array will
    affect the complexity of the constructor—most languages create arrays fully populated
    with objects, even if you don't plan to use them yet. If the constructors for
    these objects are nontrivial, then the `List` constructor will take some time
    to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array size might not be fixed—the constructor could take a parameter to
    determine this size (effectively setting the maximum possible list size). The
    method then becomes `O(n)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `append` operation is `O(1)` on average: It simply has to write an array
    entry and update the list size. *But*, if the array is full, it will have to reallocate,
    copy, and deallocate—a worst case complexity of `O(n)`, at least (it depends on
    the performance of your memory manager).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`insert` is `O(n)` on average. You might be asked to insert an element at the
    very beginning of the list. This requires all the elements in the array to be
    shuffled down one place before writing the first element. The more items in the
    `List`, the longer this will take. However, the worst case, again, involves memory
    reallocation and could be much more than `O(n)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless you have a ridiculously bad implementation, `isEmpty` is `O(1)`. The
    list size will be known, so the return value is a single calculation based on
    this number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`contains` is `O(n)`, presuming the list contents are unordered. In the worst
    case, you will be asked to look for an item that doesn''t exist and will have
    to traverse every single list item.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get` is `O(1)`, thanks to the array implementation. Indexing an array is a
    constant time operation. If `List` had been implemented as a *linked list*, then
    this would have been an `O(n)` operation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How important (honestly) is code performance in your current project? What
    is the motivator for this performance requirement?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The performance requirements should not be arbitrarily chosen. They should be
    justified, not just a time limit pulled out of thin air. Every performance requirement
    is important; there are no specifications that don't matter. How much concern
    a particular requirement generates depends on how hard it is to meet. Whether
    it's hard or not, you still have to come up with a design that satisfies it.
  prefs: []
  type: TYPE_NORMAL
- en: '**In your last optimization attempt**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Did you use a profiler?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If yes, how much improvement did you measure?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If no, how did you know whether you made any kind of improvement?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Did you test that the code still worked after optimizing?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If yes, how thoroughly did you test?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If no, why not? How could you be sure the code still worked properly for
    all cases?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only the most dramatic performance improvements can be detected without a profiler
    or some other good timing tests. Human perception is easily fooled—when you've
    just slaved to speed up the program, it will always *appear* faster to you.
  prefs: []
  type: TYPE_NORMAL
- en: Test performance improvements carefully, and discard those that are not worthwhile.
    It's better to have clear code than a minuscule speed increase and unmaintainable
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you''ve not yet attempted to optimize the code you''re currently working
    on, take a guess at which parts are the slowest and which bits consume the most
    memory. Now run it through a profiler—how accurate were you?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll probably be quite surprised at the results. The larger the program you
    profile, the less likely you are to correctly judge these bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: '**How well specified are your program''s performance requirements? Do you have
    a concrete plan to test that you meet these criteria?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without a clear specification, no one can really complain that your program
    isn't fast enough!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#APP-FN-15)]) Conversely, this reference might inhibit other performance
    gains. Copies are guaranteed not to have aliasing issues; some compiler optimizations
    cannot be performed if there are potential variable aliases. As always, you must
    measure and work out what works best.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#APP-FN-16)]) That looks stupid when you see it written down, but it's
    a very easy trap to fall into at the codeface.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What is a "secure" program?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A secure program is able to stand up against attempts to abuse it, to break
    into it, or to use it for a purpose it was not intended for. This is more than
    a robust program; robust code meets its specification and doesn't crash when you
    apply a little pressure. However, a robust program might not have been designed
    with security in mind and could still leak sensitive information under some extreme
    conditions. Sometimes it's preferable to crash when used wrongly, rather than
    provide unintended output. So secure code *might* crash!
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a secure program depends on the security requirements for
    the application. These are defined in part by what you can expect from the supporting
    services (the OS and other applications). Given these, your application''s objectives
    could be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**'
  prefs: []
  type: TYPE_NORMAL
- en: The system will not disclose information to the wrong people. They will get
    an access denied message, or will have no idea that the information exists in
    the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity**'
  prefs: []
  type: TYPE_NORMAL
- en: The system won't allow unauthorized changing of information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability**'
  prefs: []
  type: TYPE_NORMAL
- en: The system works continually—even while being attacked. It's hard to guard against
    *all* possible attacks (what if someone removes the power?), but it's possible
    to resist many attacks by including a level of redundancy in the design, or by
    providing a rapid restart after attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: The system ensures that users are who they say they are, usually with a login
    and password mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '**Audit**'
  prefs: []
  type: TYPE_NORMAL
- en: The system records information about all important operations, to catch or monitor
    the activities of attackers.
  prefs: []
  type: TYPE_NORMAL
- en: '**What input must be validated in a secure program? What sort of validation
    is required?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*All* input must be validated. This includes command-line parameters, environment
    variables, GUI inputs, web form inputs (even those with client-side JavaScript
    checking), CGI-encoded URLs, cookie contents, file contents, and filenames.'
  prefs: []
  type: TYPE_NORMAL
- en: You should check the input's size (if it's not a simple numeric variable), the
    validity of its format, and the actual contents of the data (that numbers are
    in range, and there are no embedded query strings).
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you guard against attacks from the pool of trusted users?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not very easily. They have been given a specific level of privilege because
    they are trusted not to abuse it. Most users will not intentionally abuse your
    software, but a small number will try to subvert programs for their own advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few techniques to manage this:'
  prefs: []
  type: TYPE_NORMAL
- en: Log every operation so you know who made what change and when.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require two users to authenticate all really important operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap each operation in an undoable transaction so it can be unrolled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back up all data stores periodically so you can retrieve lost data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Where can an exploitable buffer overrun occur? What functions are particularly
    prone to buffer overrun?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffer overrun is probably the biggest security vulnerability, and it is a simple
    problem that is easy for an attacker to exploit. It can occur anywhere that a
    multi-location structure is addressed—either by copying data into or out of it
    or by indexing into it to access a specific item. Arrays and strings are the most
    common culprits.
  prefs: []
  type: TYPE_NORMAL
- en: It is most often seen in user input routines, although this is not the only
    habitat—it can exist within any data manipulation code. Exploitable buffers can
    be situated both on the stack (where function-local variables are placed) or on
    the heap (the pool of dynamically allocated memory).
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you avoid buffer overruns altogether?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes—as long as you are diligent in validating each function's input and can
    be sure that the stack of software leading up to each input (possibility implemented
    in the OS input routines or your language's run-time library) is safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key techniques to safeguard your code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a language with no fixed-size buffers—for example, a language that has
    automatically extending strings. It''s not just strings that are dangerous, though:
    Look for bounds-checked arrays and safe hash maps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can't rely on language support, you *must* bounds check all input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C, always use the safer standard library functions `strncpy`, `strncat`,
    `snprintf`, `fgets`, and so on. Don't use stdio routines like `printf`, and `scanf`—you
    can't guarantee their safety.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never use third-party libraries that aren't provably safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your code in a managed execution environment (like Java or C#). Then buffer
    overrun attacks become almost nonexistent—the executive traps most overruns automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How can you secure the memory in use by your application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three times to think about memory security:'
  prefs: []
  type: TYPE_NORMAL
- en: Before you use it. When you claim some memory, it contains arbitrary values.
    Don't write code that accidentally relies on the contents of uninitialized memory.
    A cracker could exploit this to attack your code. To be extra safe, zero all allocated
    memory before you use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During use. Lock memory containing sensitive information so it can't be swapped
    to disk. Obviously you must be using a secure OS—if one application can read any
    other's memory, then you've already lost!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After use. Often forgotten by application programmers is that when you release
    memory, it should be cleaned before you hand it back for the OS to recycle. If
    you don't do this, a rogue process could mine memory for the secret data you leave
    behind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are C and C++ inherently less secure than alternative languages?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C and C++ produce more than their fair share of insecure applications and *allow*
    you to write code containing classic security vulnerabilities. You definitely
    have to keep your brain switched on; even experienced developers must pay attention
    when writing C/C++ code to avoid buffer overruns. These languages don't exactly
    encourage secure programming.
  prefs: []
  type: TYPE_NORMAL
- en: However, other languages don't avoid all security problems either, just the
    ones C and C++ have made famous. A different language will most likely avoid potential
    buffer overruns, but you shouldn't have a false sense of security; many other
    problems that can't be avoided in the language itself remain. You must be aware
    of security issues when using *any* language—you can't pick a "safe" language
    and forget all about security.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, buffer overrun is a vulnerability that can be very easily audited and
    worked around. If you need to program secure applications, then the language you
    use is a small concern among all the other problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Has the experience of C led to C++ being a better, more securely designed
    language?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'C++ has gained an abstract `string` type that manages its own memory internally.
    This goes a long way toward avoiding buffer overruns, although traditional C-style
    `char` arrays remain for those who still want to shoot themselves in the foot.
    The `vector` is another handy device: a memory managing array. However, it is
    possible to overrun both of these structures—do you know how?'
  prefs: []
  type: TYPE_NORMAL
- en: C++ could be considered more dangerous than C, because it stores a lot of function
    pointers on the heap (this is where virtual function tables are stored). If an
    attacker can overwrite one of those pointers, then he can redirect operation to
    his own evil code.
  prefs: []
  type: TYPE_NORMAL
- en: In many ways, C++ is more secure, or rather, it is more easy to use securely.
    However, it was not designed with security solely in mind, and provides its own
    set of security problems that the developer must be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you know when your program has been compromised?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without detection measures, you'll have no idea—and you will just have to keep
    an eye out for unusual system behavior or different patterns of activity. This
    is hardly scientific. A hacked system can remain a secret indefinitely. Even if
    a victim (or his software vendor) *does* spot an attack, he probably doesn't want
    to release detailed information about it to invite more intruders. What company
    would publicize that its product has security flaws? If it is conscientious enough
    to release a security patch, not everyone will upgrade, leaving a well-documented
    security flaw in many operational systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What are the security requirements for your current project? How were these
    requirements established? Who knows about them? Where are they documented?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer this honestly. It's not too hard to make up something that sounds plausible.
    But unless the security requirements are formally documented, security has not
    really been addressed by your project. This should be something that every developer
    is aware of and knows how to fulfill.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the worst security bug in one of your shipped applications?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to know about this, even if it's now ancient history. You have
    to know what you've got wrong in the past to stand any chance of avoiding it in
    the future. If you don't know of any past security vulnerabilities, then you've
    probably not been thorough in security testing—you've not been paying attention,
    or you've been very lucky to have nothing discovered.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many security bulletins have been posted against your application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have these been caused by silly developer mistakes like stupid code errors,
    or do they stem from larger design problems? Most common problems that get documented
    in bulletins are the former.
  prefs: []
  type: TYPE_NORMAL
- en: '**Have you ever run a security audit? What kinds of flaws did it reveal?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless you have a professional security specialist running this test, it will
    surely miss some security vulnerabilities. However, the audit will still uncover
    many glaring problems and is *very* worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: '**What kind of person is most likely to attack your current system? How is
    this influenced by**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Your company**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The type of user**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The type of product**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The popularity of the product**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The competition**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The platform you run on**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The connectedness and public visibility of the system**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everyone is a target to someone: a malicious user, unscrupulous competitors,
    and even terrorist organizations. Who do you trust?'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How does project size affect your software design and the work involved in
    creating it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The larger a project gets, the more architectural design it requires in proportion
    to low-level code design. More time needs to be spent up front ensuring the design
    is right, because bad choices will have more serious consequences.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is a well-documented bad design better than an undocumented good one?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documentation is part of what makes a design good. A well-documented bad design
    provides a route in to the code, even if it's a brightly illuminated dirt track
    to a cesspit. At the very least, it will teach you never to touch the code again.
  prefs: []
  type: TYPE_NORMAL
- en: A sufficiently simple piece of code shouldn't need reams of documentation, but
    any reasonably complex piece of software becomes hard to work with when there
    isn't adequate description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which is better? The undocumented good design is best: If it is a truly high-quality
    design, then it *should* be obvious and self-documenting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you measure the design quality of a piece of code? How can you quantify
    its simplicity, elegance, modularity, and so on?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quality is difficult to quantify; it's largely an aesthetic judgment for design.
    What makes a picture beautiful? The kind of thing you can't hold in your hand
    and count. Hindsight will show how easy the code was to pick up or to modify.
    But that doesn't really help when you first come across some code. If I have two
    designs *A* and *B*, and I think *A* is more elegant, but in practice *B* turns
    out to be more usable and copes with the pressures of reuse much better, then
    it is hard to argue that *A* is the better design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to judge design quality is to *look* at the code. Reading a little
    code generally gives a good impression of overall quality; if one small bit appears
    good, then the rest is likely to be of reasonable quality too. This doesn''t always
    hold, but it''s a handy yardstick. A realistic approach is this: If that little
    bit of code is bad, expect the whole codebase to be terrible. If the little bit
    is any good, then just suspect the codebase of harboring more subtle problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Running code tools that inspect the source, producing diagrams and documentation,
    can also help to gauge design quality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is design a team activity? How important are teamworking skills in creating
    a good design?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Very important. Programming tasks are seldom a lone activity. In the software
    factory, most large-scale design activities involve more than one designer. Even
    if the work is split into separate areas, those areas interface at some point—so
    the designers must interface. If there *is* only one designer, he or she must
    still be able to document and communicate the design effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are different methodologies more suitable to different projects?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, the scope of some projects will render certain design approaches unnecessary.
    If you are writing a set of device drivers, you won't find *much* use in a full-blown
    OO design process.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on a very formal project, perhaps for a government agency,
    you'll need to use a very formal process that documents every stage and provides
    accountability for every design decision made. This may be quite different from
    an exploratory R&D project in a software lab.
  prefs: []
  type: TYPE_NORMAL
- en: '**In what ways can you determine whether a design is highly cohesive or weakly
    coupled?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ultimately you have to look at the code and see how it fits together, but that's
    boring! You can get a good feel for coupling in a C or C++ project by looking
    at the `#include`s at the top of the file. If there are tons of them, the coupling
    is probably disastrous. Alternatively, you can run inspection tools that produce
    pretty pictures of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you''ve solved a similar design problem in the past, how good an indicator
    is it of how difficult this problem will be?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experience teaches you how to design, so learn and then exploit your knowledge.
    But employ wisdom with this knowledge; don't run on autopilot. Different situations
    present different challenges—don't presume that one problem is the same as another
    just because it looks like it on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: If you know how to use a hammer, don't make every problem into a nail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is there a place for experimentation in design?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, any design *is* experimental until it has been implemented and found acceptable.
    Consider the "build one to throw away" approach that Frederick Brooks described.
    (Brooks 95) There's a lot to be said for experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Design is an iterative process; during each iteration you can try out design
    alternatives and decide which is most sensible. The more iterations you go through
    and the smaller in scope you make each one, the less painful any bad design decisions
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Look back and think about how you learned to design code. How could you convey
    the knowledge you''ve gained to a total novice?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much do you honestly think you *could* teach, and how much would have to
    come from the novice's inherent abilities and experience? Could you create a set
    of exercises based on your experience that would help someone else?
  prefs: []
  type: TYPE_NORMAL
- en: You wouldn't give a novice a large system to design at first. You'd start him
    off on a small self-contained project, and then perhaps get him to make extensions
    to existing programs, all the time keeping a mentoring eye on what he's doing.
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers didn't get this kind of help themselves when they were learning
    to design. They learned through a process of trial and error. Do consider teaching
    and mentoring a novice—it really helps you to grow in your own abilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**What experience do you have with using particular design methodologies? Were
    these good or bad experiences? What was the resulting code like? What might have
    worked better?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Was the taste left in your mouth by a methodology influenced by your prior experience
    and preferences? If you don't know how to use a particular methodology, it will
    be hard work and uncomfortable. A hard-core C programmer may dislike any form
    of object-oriented design, and his OO designs will be appalling. But that doesn't
    make OO a flawed approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you find it important to stick rigidly to the methodology you''re using?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The design approach is a tool, a utility, like a programming language—you should
    only use it up to the point it remains *useful*. If it stops being useful, it's
    no longer a utility! A methodology won't work if no one on the team knows how
    to perform it; use something they do know, or teach them first.
  prefs: []
  type: TYPE_NORMAL
- en: '**What was the best designed code you''ve ever seen? What was the worst designed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I bet you'll easily remember the worst designed code. Bad code sticks out like
    a sore thumb, and likewise sticks in your memory. Well-designed code looks simple
    and obvious, so you probably won't step back and say, "What a great design!" You
    probably won't even notice there was much design work involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**A programming language is essentially a tool to implement your design, not
    a religion to argue about. How important is it really to know language idioms?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's very important, or you'll end up with code that doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some architectural decisions may be language independent, but low-level code
    design is *heavily* influenced by the implementation language. An obvious example:
    Don''t create a flat procedural design when you''re coding in Java—it''s just
    plain wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you think programming is an engineering discipline, a craft, or an art?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quite simply, it depends on how you do it. It has elements of all three.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to think of programming as a craft—it requires skill, workmanship,
    discipline, and experience. Its products can be at once functional *and* beautiful.
    There is an element of artistry in it; it's a creative process. Allied with this
    artistry is the mastery of tools and techniques. These are the hallmarks of a
    craft.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Define where** architecture **ends and** software design **begins**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In truth, both terms can be defined to whatever suits you. In their common
    usage, the distinctions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture** is the high-level structural design. It looks at the wide-ranging
    implications of its choices, seeing how it will impact construction and maintenance
    costs, overall system complexity, ability to accommodate future extensions, and
    marketing concerns. The architecture is devised at the start of a project. It
    has serious consequences, at the very least on the further software design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software design** is the next level down, a more refined and focused activity.
    It''s concerned with code details—data structures, function signatures, and the
    exact flow of control through modules. Software design is conducted on a per-module
    basis. Its consequences are nowhere near as significant to the system as a whole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly where the two meet depends in part on the size of the project. Software
    construction is an iterative and incremental process—although architecture is
    created first, design results can feed back up to the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '**In what ways can a bad architecture affect a system? Are there parts that
    wouldn''t be affected by architectural flaws?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bad architecture will undermine any effort to write good software. It is fundamental
    to the quality of your code. If some code isn't affected by the flawed architecture,
    then it's probably either a stand-alone library or it never really belonged in
    the system in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '**How easy is it to repair architectural deficiencies once they become apparent?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the early formative stages of a project, it's relatively easy to massage
    the architecture. But once development is committed to that architecture, with
    sufficient investment (design and code) slotted into its scaffold, it's very,
    *very* hard to change. You might as well try rewriting the entire product from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: This is why it is so important to get the architecture right the first time.
    You can refactor small bits of code, but not an entire structural foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is easier for us to rip up software and start it afresh than it
    is in the physical construction industry, but economics dictate that we can't
    do it. We usually only have one chance to get the architecture right, and if we
    don't, we will have to live with the consequences for the entire lifetime of the
    software system.
  prefs: []
  type: TYPE_NORMAL
- en: '**To what extent does architecture affect the following things?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**System configuration**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Logging**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Error handling**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Security**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The architecture has a profound impact on each of these, or more correctly,
    each of these has a profound impact on the architecture. You need to establish
    requirements for these areas before embarking on serious architectural design.
    It will be hard to graft such features into the code at a later date, let alone
    into the overriding architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture determines *what* should be configurable (a lot or a little)
    and *how* it should be configured. The kind of configuration mechanism is determined
    by several factors: the importance of a shared "configuration manager" component,
    whether or not the system supports remote configuration, and who has rights to
    perform configuration (is it just the developers; should the software be tweaked
    by installers, maintainers, or users?). All of these concerns are fundamental
    architectural issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The separate components may log information using some shared facility, or they
    might use their own custom mechanisms. The architecture will define which approach
    is acceptable, how you access the logs, and also the sort of logging information
    that's important. This needs to address the requirements of the software developers
    as well as the software users. Should development logging information be produced
    by release versions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Architectural error management concerns include whether or not there is a central
    error-logging service and the error-reporting scheme (how does an error propagate
    from the seedy back-end components to the user''s sanitized GUI interface?). It
    also defines what kind of error mechanisms are used: perhaps a centralized table
    of error codes shared across all components or a common exception hierarchy. It
    will address how errors from third-party code are incorporated into the system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security issues will depend on the kind of software under development. A distributed
    Internet-based shop-front system has different security requirements from a small
    piece of code that will only ever be deployed on a stand-alone computer. Security
    is an important topic and can't be grafted in at the last minute; it must be addressed
    in the early architectural designs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What experience or qualifications are required to be called a software architect?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can decide to *call* yourself an architect, but you can't gain insight and
    experience overnight or magically conjure up the wisdom to make good design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Good architectural design requires a wealth of prior experience—learning from,
    devising, and refining real software systems. This can only be learned by actually
    doing it, not by watching someone else. Be wary of people who call themselves
    architects after working on just one release of software.
  prefs: []
  type: TYPE_NORMAL
- en: You can work on software architecture and not be called an architect; the use
    of this moniker often depends on company structure and culture. No formal qualifications
    are required before you claim the title—however in some countries, it is illegal
    to call yourself any kind of architect without professional accreditation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should sales strategy influence architecture? If so, how? If not, why?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, commercial concerns will inevitably affect the technical architecture.
    Otherwise, you'll build a system that is not a viable product; you'll rapidly
    find yourself out of a job and your company in receivership.
  prefs: []
  type: TYPE_NORMAL
- en: We *must* address the commercial implications of our designs—for example, considering
    the consequences of failure modes and the cost associated with return-to-base
    or on-site system support. The architecture must minimize these events if they
    are problems (you can provide remote access and rich diagnostics to avoid such
    intense product support).
  prefs: []
  type: TYPE_NORMAL
- en: 'Commercial concerns also affect these architectural areas: customer support
    facilities (including how easy the system is to administer), the installation
    approach (performed by trained personnel or by an automated CD installer), and
    maintenance support and fee structures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How would you architect for** extensibility? **How would you architect for**
    performance? **How do these design goals affect the system, and how do they complement
    one another?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a number of architectural decisions that follow from these two requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility** can be supported through architectural devices such as plug-ins,
    programmatic access to code (reflection), more language bindings, scripting capabilities,
    and extra levels of indirection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance** is achieved by streamlining the architecture, keeping it mean
    and lean. You must remove all unnecessary components and ensure the connections
    provided are timely and adequate. Perhaps caching layers must be incorporated
    to boost data throughput.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these two have little in common; every hook for extensibility
    will consume some, no matter how little, performance. Extra indirection has a
    cost—the indirection. If your goal is extensibility, this is an appropriate price
    to pay. A good architecture makes the correct high-level compromises to suit the
    perceived requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How diverse is the range of architectural styles to which you are accustomed?
    What do you have the most experience with—how does it affect the software you
    write?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Architecture affects us in many ways. Different architectural styles lead to
    different design and coding techniques. We are creatures of habit, and these techniques
    will shape how we think and code, even when working within a different architecture
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: It is healthy to be exposed to a number of different architectures and to be
    able to work with them. In practice, you will focus on one particular style. Make
    sure you understand how your code is shaped by this architecture, and check that
    you're writing sympathetic code when you do change architectures.
  prefs: []
  type: TYPE_NORMAL
- en: '**What personal experience do you have of architectures that succeeded or failed?
    What made them winning solutions or a hindrances?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we must define what architectural *success* means. Is it an architecture
    with technical merit? Is it a system that achieves commercial profitability? Is
    it a bit of both? Place your answer here.
  prefs: []
  type: TYPE_NORMAL
- en: Software that buckles under the weight of inappropriate architecture usually
    suffers because the architecture was not suitably extensible. Important features
    cannot be accommodated. This inevitably means the product loses market share to
    the more nimble competitors. History is strewn with software products that have
    fallen by the wayside like this.
  prefs: []
  type: TYPE_NORMAL
- en: Another danger is legacy; a huge investment in architectural baggage is a great
    hindrance. It requires real insight and a fair bit of courage to throw away an
    old system or architecture and start from scratch. A rework must always learn
    lessons from the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: An over-engineered architecture is just as dangerous as an insufficient one.
    If the architecture supports too much, it will make the product overly complex,
    cumbersome, and unacceptably slow. It usually means that even the simplest change
    requires modifying many components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Get every developer on your current project to draw a picture of the system
    architecture—individually (without talking to anyone) and without any reference
    to system documentation or the code. Compare the pictures. See what strikes you
    about each developer''s efforts—aside from the relative artistic merit!**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be fearful if the pictures bear no resemblance to one another. Don't worry if
    there are minor variations; different people will miss different small components,
    and each may be focused on different parts of the system. But if the diagrams
    contain wildly different components or the communication paths are not similar,
    then the team does not have the same mental model of the code. This will almost
    certainly lead to disaster. Pull the developers together and make sure they know
    what the system really looks like.
  prefs: []
  type: TYPE_NORMAL
- en: If all the diagrams *do* look similar, then give yourselves a pat on the back.
    You get bonus points if the components are positioned similarly on each sheet
    of paper. This is a hint that there is a central architecture specification and,
    more importantly, that everyone understands it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you have an architectural description that''s commonly available for your
    current project? How up to date is it? Which kinds of view are you using? If you
    needed to explain the system to a newcomer or a potential customer, what would
    you really need to have documented?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note how far your ideal documentation is from reality. What opportunities do
    you have to improve this situation? In a busy commercial environment, you'll rarely
    be able to schedule specific time to document the entire architecture, but you
    can plan to capture parts during the design and specification of new modules.
    In this way, you can construct a good architectural overview, piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does your system''s architecture compare to the architecture of your
    competitors in the marketplace? How has your architecture been defined to determine
    your project''s success?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to understand how your architecture is designed to meet all your
    requirements and to ensure your success. (If it has not been designed with this
    in mind, then you're in trouble.) We've seen how architecture has the most fundamental
    affect on the shape and quality of a software system—it therefore really does
    have a large influence on your product's success or failure. You'll rarely see
    software products thriving *despite* their bad architecture. If you do know of
    a successful one, it probably won't be around for very much longer.
  prefs: []
  type: TYPE_NORMAL
- en: An architecture must be able to support at least the same core functionality
    as competing systems and provide good support for the unique features that will
    cause someone to choose your product over anyone else's. The simple features that
    don't require architectural support are rarely as compelling as core functionality
    embedded deeply in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What is the best metaphor for software growth?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is none. In the immortal words of Forrest Gump, "Software is as software
    does." (Groom 94) Code construction has many correlations, yet no metaphor fully
    conveys its subtleties, just as you could never fully describe the beauty of a
    sunrise in words.
  prefs: []
  type: TYPE_NORMAL
- en: Analogies can be misleading; software is a very different substance from any
    physical item, and building it is accordingly different. There are fewer physical
    constraints, and you can manipulate it in many more ways.
  prefs: []
  type: TYPE_NORMAL
- en: There is a glimpse of truth in each metaphor. Learn what you can from them,
    but don't be tunneled into an incorrect view of software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Looking at a program''s development through the colorful lifetime metaphor
    I talked about in the introduction, what Real World events correspond to a program''s**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Conception**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Birth**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Growth**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coming of age**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sending out into the Big Wide World**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle age**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Growing tired**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retirement**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Death**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we've seen that metaphors are imperfect, investigating this one does
    teach us a lot about the lifetime of a software system. It's certainly not practical
    to try to place one developmental stage before the preceding steps—you can't release
    software until it has come of age. Well, you can, but the consequences are dire.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conception**'
  prefs: []
  type: TYPE_NORMAL
- en: The company observes an opening for a new product. The market requirements are
    established. The decision is made to build it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Birth**'
  prefs: []
  type: TYPE_NORMAL
- en: A project is initiated to build the software. Designers and programmers are
    drafted in. An architecture is established. The code is started.
  prefs: []
  type: TYPE_NORMAL
- en: '**Growth**'
  prefs: []
  type: TYPE_NORMAL
- en: The code develops, and the program matures. It becomes more and more functionally
    complete. Deadlines loom.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coming of age**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code is complete. It passes all tests to QA's satisfaction. It's
    considered a job well done, and hopefully it wasn't too far behind schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending out**'
  prefs: []
  type: TYPE_NORMAL
- en: The program is released as version 1.0\. It successfully meets the market's
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Middle age**'
  prefs: []
  type: TYPE_NORMAL
- en: The program is heavily used by clients and has been deployed for some time.
    Now, several revisions later, it has accumulated extra functionality and a degree
    of bloating.
  prefs: []
  type: TYPE_NORMAL
- en: '**Growing tired**'
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, more nimble competition overtakes the program, with a greater feature
    set and better performance. No new customers choose our program, but existing
    customers clamor for upgrades. The software has become hard (even uneconomical)
    to extend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retirement**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the company decides to give up on development and cease support. It
    announces support is ending in *x* months: a formal *end-of-life* statement. Development
    stops, although some maintenance work continues.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Death**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We reach the inevitable: All development and maintenance stops. There is no
    longer anything offered by way of support. The world has moved on; soon, no one
    will remember what the program was called, let alone how to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is there a limit to software life—how long can you keep developing and working
    on a program before you have to start afresh?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This depends more on the market for the program than the quality of the software
    itself. Code can last indefinitely if it's well maintained and extended carefully.
    However, technologies go out of date rapidly, and trends change. Operating systems
    evolve quickly, hardware platforms become obsolete, and something that began as
    state-of-the-art, market-leading functionality will be given away for free a few
    years later. You must work hard to maintain the program's competitive advantage.
    Perhaps you'll have to continually add new functions, or port the software to
    new platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Open source software is not immune to these competitive and market-related issues;
    in some cases the problem is worse. There may be little or no money involved,
    but there is a still a real market with advancing technology, lower barriers to
    entry, and greater chances to switch products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does the size of a codebase correspond to the maturity of the project?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. On many occasions, I have vastly improved a system by *removing* code from
    it. Duplication can lead to massive code growth with little functional gain. The
    use of external libraries provides a lot of functionality without any discernible
    increase in project code size.
  prefs: []
  type: TYPE_NORMAL
- en: Many people quote *lines of code* as a good measurement of development progress.
    Such metrics are useless unless interpreted correctly. This is merely a view of
    the *amount of code written*, not of its quality or the purity of its design.
    It is certainly not a measure of its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**How important is** backward compatibility **when maintaining code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This depends on the individual project and how it has been deployed. More often
    than not, it is very important to retain backward compatibility when you change
    code—especially with regard to file formats, data structures, and communication
    protocols. Few applications can justifiably break this rule—only systems with
    small deployments and no need to store, retrieve, or communicate legacy data.
  prefs: []
  type: TYPE_NORMAL
- en: You should also consider *forward compatibility*. That is, designing code for
    extension and ensuring that future events will not render it inoperable. The Y2K
    bug is a good example of this rule being ignored, with expensive and potentially
    disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is code likely to rot more quickly if you alter it or if you leave it alone?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code rots quickest when you attempt to alter it. It's true that leaving a program
    to slowly stagnate will ensure your competitors gain an advantage, eventually
    rendering your code worthless. Your *product* will hear its death knell, but the
    *code* itself is as beautiful as it ever was.
  prefs: []
  type: TYPE_NORMAL
- en: Careless maintenance and sloppy extension will really cripple code. New faults
    are introduced all too easily as other problems are cleaned up. The pressure for
    rapid turnaround leads to modifications that degrade code clarity and structure.
    Maintaining code often renders it unmaintainable.
  prefs: []
  type: TYPE_NORMAL
- en: It takes good programmers and informed project management to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Is the majority of the code you write brand new or a modification of existing
    source?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If it''s brand-new code, do you create entirely new systems or new extensions
    to existing systems?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does this affect** how **you write? In what ways?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Different forces come into play in these different scenarios. When extending
    existing code or fitting new software into an old framework, you have to do a
    *lot* of investigation up front to understand how all the existing stuff works.
    If you don't, you'll end up writing bad code that doesn't fit in properly, causing
    headaches in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Brand-new code must be created with a view to future modification. It must be
    clear, extensible, and malleable to prevent such problems from cropping up later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you have experience of working with preexisting codebases? If so**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How has it shaped your current skill set? What lessons did you learn?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Was it predominantly good or bad code? What did you have to judge it against?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A few years experience helps you to judge what's good software and what's bad.
    The telltale signs become clear, and you're able to quickly detect code that must
    be handled with care.
  prefs: []
  type: TYPE_NORMAL
- en: Although vaguely masochistic, it can be good experience to work with someone
    else's trashy code—it teaches you what *not* to do, how one programmer's shortsightedness
    can make other programmer's lives painful later on. It helps you to appreciate
    the importance of taking responsibility for the code you write.
  prefs: []
  type: TYPE_NORMAL
- en: '**Have you ever made changes that degraded the quality of code? Why?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Common reasons (or excuses) are:'
  prefs: []
  type: TYPE_NORMAL
- en: I didn't know any better at the time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I was pressed for time and had to ship the code quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was too much work to do any other way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I could only modify code that was under *our* control—the problem was in another
    team's code or in third-party library code that we only had binaries for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these reasons are satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: For bonus points, come up with counter arguments against each of those excuses
    and find ways to avoid each situation. For example, if you're pressured to ship
    a code release quickly, you can make a simple hacky change now, and revise the
    work once the software is released to create a more engineered solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many revisions has your current project gone through?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How much changed functionally between revisions? How did the code change?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Has it grown by** luck, **by** design, **or something between the two? How
    is this evident now?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here are some important things to consider.
  prefs: []
  type: TYPE_NORMAL
- en: The two are not necessarily connected. Even some very simple functional changes
    may require fundamental code rewrites. I've seen many projects where this was
    the case, where the system architecture didn't support future requirements and
    had to be radically altered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And I''ve also seen the opposite: releases that were functionally identical
    to their predecessor, but where almost everything had changed under the covers.
    There is no point in performing a complete project rewrite if the system is spiraling
    toward its death, but when it has a viable commercial future and the current code
    cannot accommodate future requirements, such action may be justified.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It might be commercial suicide to release a new version with no new features—customers
    will refuse to upgrade unless it's worth their while. Therefore, a few minor features
    tend to be thrown in as bait, or the revision is released with a certain amount
    of spin (i.e., *This revision includes significant bug fixes*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must know the history of your codebase to understand how it grew to this
    current shape and to be able to make informed modifications and appropriate tidy-ups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How does your team safeguard code so that it can''t be changed by more than
    one programmer at once?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Employ a *revision control system* to manage code changes. Blocking file checkouts
    prevent more than one person from modifying a file at once. However, this is not
    enough. One change can be checked in with a contradictory change immediately following.
    You need to *manage* the development carefully, so that each developer with access
    to the source code understands what his or her peers are doing and who is responsible
    for making which changes. Code reviews help to detect and correct when this kind
    of problem has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: A good suite of regression tests will ensure that any modification you make
    does not break functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 16](ch16.html "Chapter 16. CODE MONKEYS")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How many programmers** does **it take to change a light bulb?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The question's wrong. It's a hardware problem, not a software one. Get the hardware
    engineers to fix it. Of course, the hardware engineers will want to work around
    the problem in software. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it better to be enthusiastic and less skilled (not incompetent) or to
    be incredibly talented and unmotivated?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Who will write the better code?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Who is the better programmer? (Not the same thing.)**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which does more to shape the code you write: your technical competence or
    your attitude?**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are various types of software systems, and the creation of each requires
    a different set of skills. That''s how programmers can carve out niches in embedded
    programming, web services, financial systems, and so on. The coding task also
    differs with the heritage of the code. You might write:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple "toy" programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New systems from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions of existing systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance work on old codebases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each task requires a different level of skill and discipline, and a very different
    development approach. We'll see this in the next question. Not every programmer
    who can write a personal "toy" can create a brand-new, industrial-strength system.
  prefs: []
  type: TYPE_NORMAL
- en: For all of these, the quality of the resulting code is determined as much by
    your technical competence as your *attitude* regarding the task—indeed, the two
    must complement one another. If you lack some technical skills, then you must
    have an attitude that acknowledges this and compensates for it.
  prefs: []
  type: TYPE_NORMAL
- en: Your attitude can do more to shape the code you write than your current skill
    set can. If you're less skilled but desire to do a good job, then you're more
    likely to work well. You're also more likely to learn and to improve your skills.
  prefs: []
  type: TYPE_NORMAL
- en: '**There are various different types of programs we write, differentiated by
    code "heritage." How does writing the following types of code differ?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A "toy" program**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A brand-new system**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extensions to an existing system**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maintenance work on an old codebase**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It might not look like there's a great different between these code scenarios,
    but they require surprisingly different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**A toy program**'
  prefs: []
  type: TYPE_NORMAL
- en: This might be a small fun hack for your own use or a little utility to help
    develop a larger system. This program doesn't need to be bulletproof, have in-depth
    design, or have exhaustive features. It just needs to do enough to solve the immediate
    problem. Then it's thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: Speed and ease of development is probably more important than design elegance
    or the theological purity of the construction process.
  prefs: []
  type: TYPE_NORMAL
- en: '**A new system**'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a brand-new professional system from scratch requires serious design
    and careful planning. You must take into account future use and extensions, and
    ensure that the whole system is adequately documented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensions**'
  prefs: []
  type: TYPE_NORMAL
- en: Few projects create a new system from the ground up. More often, we extend existing
    code, adding new features to an old codebase. The new work must knit correctly
    into the existing system. This can't be done properly without a thorough understanding
    of the original code and the ability to make changes that sit well alongside existing
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common software activity is the maintenance of existing code, fixing
    any remaining faults, and ensuring that it remains operational as the world around
    it changes. This needs a careful methodical approach. It probably requires a lot
    of exploratory work; it will stretch your deductive powers since few systems are
    ever documented well enough to easily maintain, especially as they grow old and
    near obsolescence.
  prefs: []
  type: TYPE_NORMAL
- en: '**If programming is an art, what is the correct balance of consideration and
    planning versus intuition and gut instinct? Do you program by gut or by plan?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we've seen, effective programmers use both approaches. Intuition and the
    artist's aesthetic sensibilities will help craft elegant code. Thoughtful planning
    works alongside to ensure the code is sound, pragmatic, and delivered on time.
  prefs: []
  type: TYPE_NORMAL
- en: We can't formulate an exact ratio or formula for the optimum balance. Effective
    programmers have both and know how to moderate the use of each.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Why write software in teams? What are the real advantages over writing a
    system on your own?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software development might be easier on your own; you don't have to work with
    other weird programmers, you don't need to coordinate work or suffer ineffective
    management. However, it isn't hard to see the many benefits of software development
    in teams.
  prefs: []
  type: TYPE_NORMAL
- en: In a team you can solve larger problems by decomposing them between individual
    members. And you can create code faster too. Groups of developers combine talents
    to make something greater than the sum of their parts. In cases where there is
    no well-established design or prior art, the wider skill set and knowledge of
    the group has a distinct advantage; a collaborative approach will filter ideas
    and generate better solutions. Peer reviews ensure that work is sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a personal motivation: Techies like working on cool projects.
    You can work on systems well beyond your own ability when developing in a team.
    This might be software that is much larger than an individual could tackle, which
    requires specialized skills, or that provides the chance to work alongside more
    experienced programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: In a Real World organization, even a lone developer is part of a larger team.
    If you're not working with other software developers, you are still part of a
    corporate team, working to create a final polished product. Without those other
    people, your software would never be released.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describe the telltale signs of good and bad teamwork. What are the prerequisites
    for good teamwork, and what characterizes bad teamwork?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For effective teamwork, all of these factors must be in place:'
  prefs: []
  type: TYPE_NORMAL
- en: The correct spread of people, with a range of appropriate technical skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team members with a range of experience, who are each able to learn from others.
    A whole team of trainees will clearly be very unlikely to succeed. (However, they'd
    be much easier to mold and manage than a bunch of Demigurus who are far more set
    in their ways.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team member personality types must be complementary. To succeed, the team needs
    encouragers and motivators, not people who will drag morale down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clear and realistic goal (even better if it's an exciting project that the
    team members really want to see completed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivation (whether financial or emotional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable specifications provided as soon as possible, so all members understand
    what they are building and to ensure that the individual pieces of work fit together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As small a team as realistically possible, but no smaller. Adding more people
    makes teamwork harder: There are more lines of communication, more people to coordinate,
    and more points of failure. We should try not to make things unnecessarily difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clear and universally understood software engineering process for the team
    to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing from the company, not hindrances and unnecessary bureaucracy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In contrast, these are sure indicators of a team that is not able to work effectively.
    Note that this list includes a mix of internal and external factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Unrealistic schedules with deadlines established before the team has scoped
    their work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unclear project objectives and a lack of project requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad or unqualified team leaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Badly defined individual roles and responsibilities—who's responsible for doing
    what?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual bad attitudes and personal agendas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incompetent team members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management not valuing individual engineers, and treating them like minions
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual appraisals based on criteria that don't match the team objectives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapid turnover of team members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No change in management procedure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of training or mentoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare software teamwork with the construction metaphor (see "[DO WE REALLY
    BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question "DO WE REALLY
    BUILD SOFTWARE?")" on page 177). Does it reveal insights into our teamwork?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a number of different metaphors that can be used to describe our work
    (for example, DeMarco's *sports team* or *choral society* and the *factory* we
    joke about here). (DeMarco 99) The problem with any metaphor is that it can only
    tell a partial truth. Software engineering has its own problems and challenges.
    Chemical engineering is different from civil engineering, which is different from
    making a movie, which is different from writing software.
  prefs: []
  type: TYPE_NORMAL
- en: 'While not perfect, *building construction* is a useful metaphor. After all,
    we construct software according to a plan, from different components (some of
    which we build ourselves, others which we buy or bring in). These are the useful
    parallels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need a team: You can''t single-handedly build a skyscraper or an enterprise-level
    highly complex software superstructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The team has a goal: It works to finish the construction on time and on budget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Someone commissions the work, for a purpose: There is an end-purpose for the
    work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each team member does something different: Different roles help to get the
    job done. There are architects, builders, carpenters, plumbers, electricians,
    foremen, office staff, security guards, and more. Each makes a valuable contribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are team members with responsibility: The foreman is the people manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But of course, buildings are very different from programs. Buildings can't be
    developed in an iterative and incremental manner. Any change to a building's specification
    will result in costly demolition prior to rebuilding. In our world of pure thought
    stuff, we can tear down and rebuild with very little material cost (but with the
    costs of time and labor). In software, we are better able to build abstract interfaces
    between blocks. The engineering discipline is different, but that doesn't mean
    we can't learn from the parallels with other professions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Will external or internal factors do the most to ruin the effectiveness of
    a software development team?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They''ll both conspire to destroy your development work. Internal factors like:'
  prefs: []
  type: TYPE_NORMAL
- en: Ineffective team members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conflict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show-stopping bugs late in development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inaccurate plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mix with external factors like:'
  prefs: []
  type: TYPE_NORMAL
- en: Unclear or shifting requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unrealistic deadlines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corporate bureaucracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes the life of a software developer incredibly difficult. Internal and
    external pressures are equally likely to destroy your teamwork, although it's
    widely recognized that most projects fail for nontechnical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing is certain: There are far more detrimental influences on team performance
    than there are success factors. For this reason, you must guard your team''s work
    closely, attempting to insulate yourself from both internal and external attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a team''s size affect the team dynamics?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With more people, the team members suffer increased
  prefs: []
  type: TYPE_NORMAL
- en: Coordination effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication effort (more people introduce more separate paths of communication;
    this grows exponentially)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cooperation effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency on others (direct and indirect)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these *can* make your work harder. However, it's clear that a team of
    programmers can produce greater software than a single coder. This means that
    there must be an appropriate balance of team size versus size of task; this will
    change depending on the kind of system being developed.
  prefs: []
  type: TYPE_NORMAL
- en: As a team gets bigger, there is more likelihood that individual programmers
    will slacken the effort they put in, since they can be carried by the rest of
    the team. Brooks's *The Mythical Man-Month* shows that adding people to a project
    does not necessarily make it complete sooner. (Brooks 95)
  prefs: []
  type: TYPE_NORMAL
- en: With a larger project, there is more chance that management talent will differentiate
    success from failure and more scope for management to provoke catastrophic failure.
  prefs: []
  type: TYPE_NORMAL
- en: In general, smaller development teams are better; but they must still be large
    enough to accomplish the task.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you insulate a team from problems caused by inexperienced members?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will always be inexperienced programmers. This is the same in any field
    of endeavor. In many professions, new recruits undergo some form of apprenticeship
    period and must complete a stage of academic study. This ensures that their skills
    are already honed to a reasonable level. Although ripe with academic programming
    courses (of varying quality), our software profession doesn't recognize any formal
    form of apprenticeship. Mentoring new programmers is a fantastic way to quickly
    bring fresh recruits to a reasonable standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few techniques contribute to making inexperienced coders'' work less risky:'
  prefs: []
  type: TYPE_NORMAL
- en: Have realistic expectations; don't expect miracles from them. Allot trainees
    appropriate tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor their progress, and ensure they aren't afraid to raise questions and
    problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t require too much prior experience: Use popular languages and tools that
    will require less time to get up-to-speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use bleeding edge technologies and techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize tools across teams so trainees only need to learn a toolset once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Train them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review their code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mentor them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair program with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What kind of team are you working in right now? Which of the stereotypes
    on pages 322 through 332 is it most like?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is it like this by design?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is it a healthy team?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does it need to be changed?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What factors have you encountered that prevent good teamwork?**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**If you haven''t done so already, fill out the earlier action sheet carefully
    (see "[Action Sheet](ch17s10.html "Action Sheet")" on page 347). Make sure you
    work out how to improve your team and start to make the changes**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Work out how you will carry out any required changes. Set goals and review the
    team's health in a few months' time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common team problems include:'
  prefs: []
  type: TYPE_NORMAL
- en: Unbalanced team composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ineffective team members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unrealistic deadlines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Are you a good team player? How could you work better with your teammates
    and build better software?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look again at the personal characteristics in "[Personal Skills and Characteristics
    for Good Teamwork](ch17s05.html "Personal Skills and Characteristics for Good
    Teamwork")" on page 333\. Determine how closely you model each of these and how
    you can improve.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the exact responsibility of a software engineer on your current team?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much responsibility and authority does a software developer have? Are there
    several ranks of programmer job titles—if so, how do these roles differ? Does
    a development role involve any of the following activities?
  prefs: []
  type: TYPE_NORMAL
- en: Forming the project scope and objectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating timescales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a mentor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating and implementing performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing (to what level?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with the customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning enhancements or the next software revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This detail will differ from company to company and from project to project.
    Are there clear lines of accountability in your team? Are there technical and
    pastoral managers to whom developers are assigned?
  prefs: []
  type: TYPE_NORMAL
- en: Do you have a job description? Do you have a set of personal objectives? If
    so, are you fulfilling them right now, or are they actually incorrect?
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How can you reliably release your source code to other people?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest option for proprietary source code is *not* to release it—then you'll
    avoid all sorts of problems. If you must ship code, don't forget to sort out licensing
    and get NDAs in place first. Know the size and extent of your audience and, if
    it's important to you, take measures to ensure that the code doesn't leak further
    afield.
  prefs: []
  type: TYPE_NORMAL
- en: For open source projects, this is not such a big concern; by their nature, they
    ship as source.
  prefs: []
  type: TYPE_NORMAL
- en: Before release, make sure that there are clear copyright and license notices
    in every source code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several mechanisms for a source code release, with differing abilities
    to guard against your code getting into the wrong hands:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the external viewer to have access to your source control system. You
    can lock this down through an account that is granted read-only access, possibly
    using a shared *anonymous* account if your code is publicly available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, to see your VCS server, users must have some level of privilege and
    network access to your development environment, so this must be closely managed—both
    so that they don't do anything untoward and so that crackers can't get in to look
    at your code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Tarball* the source tree (create a compressed archive of files—this term is
    named after Unix''s `tar` command). This tarball can be emailed, FTPed, or sent
    on a CD. Ensure that your method of dispatch is appropriately secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a set of release notes with your code, and clearly display the source
    tree revision information (usually a source control version or build number) for
    later reference. Mark the released code in your source control repository with
    a label so that you can retrieve it at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: '**Of the two models for repository file editing (locking file checkouts or
    concurrent modification), which is best?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Neither model of operation is better or worse than its counterpart. Each hides
    different file editing problems and forces users to work differently when modifications
    might collide.
  prefs: []
  type: TYPE_NORMAL
- en: The locking model requires you to check out a file to reserve it before making
    any modifications. You can be sure that no other developer's change will interfere
    with your work and that you have sole access to that file until you check it back
    in or release the file unchanged. The downside is that a reserved file is blocked
    until the owner has relinquished control. You have no immediate way of knowing
    how long this will take.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the owner sits at the desk next to you, then it's annoying but not hard to
    work out. However, if the owner is on another continent, works different hours,
    or accidentally leaves the file checked out while on vacation, then you're stuck.
    The best you can do is subvert the checkout by fiddling with the owner's computer
    to release the file. This will undoubtedly cause hassle and confusion later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The concurrent model avoids this problem and ensures that you can continue coding
    unhindered at all times. The hidden danger is the possibility of conflicting file
    modifications. If Fred alters lines 10 through 20 of `foo.c`, while George alters
    lines 15 through 25, a race is on! The first developer to check in the file won't
    have any problems, so if Fred wins, his work on lines 10 through 20 will be put
    into the repository. But when George tries to check in, the SCMS will tell him
    that his source tree is out of date—he has to merge Fred's change into his copy
    of `foo.c` first. The five conflicting lines will need to be merged manually;
    George must do extra work to understand Fred's change and integrate it with his
    own. Only then can he check his work in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This isn't ideal, but it happens very rarely in reality, and most conflicts
    are not at all contentious. The more common case is when Fred modifies lines 10
    through 20 and George modifies lines 40 through 50; the two modifications don't
    conflict and the SCMS can merge the changes automatically. If you do encounter
    conflicting concurrent modifications, it's often a sign that the code needs some
    refactoring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Neither mode of operation is perfect; but each works fine. Which you choose
    depends on the operation of your source control tool and the development process
    and culture you work in.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do the requirements for version control systems differ between a distributed
    and a single-site development team?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a SCMS can accommodate remote sites, it will definitely be able to cope
    with a single-site development team, so we''re mostly considering a set of *extra*
    requirements for multisite operation. These extra requirements include:'
  prefs: []
  type: TYPE_NORMAL
- en: There must be a scaleable client/server architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool must work effectively over low-bandwidth network links (which are common
    for satelite sites), *or* your deployment must include a really high-quality intersite
    connection. Low-bandwidth links require intelligent data compression and sensible
    communications protocols (for example, the tools should send small file differences,
    rather than entire files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be a centralized method to administer user accounts so that collaboration
    is seamless across sites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two main designs: wide area network communication and remote repository
    replication. The first performs all client communication with a central server
    hosted at the parent location. This requires a sufficiently fast and reliable
    communication channel between sites. The latter method reduces communication overhead
    by replicating the repository onto a remote server at low-load times. However,
    this adds a lot complication to the development process; you need to understand
    that the two repositories are not costantly synchronized, and you must work out
    sensible branching strategies to avoid conflicting lines of development work.'
  prefs: []
  type: TYPE_NORMAL
- en: When evaluating source control systems, don't ignore these requirements, even
    if you only have one development site. In the future, you may need to add a secondary
    site or support for telecommuters. Bear this in mind as you scope your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a sound rationale for selecting a source code management system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Good criteria for selecting a SCMS include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**'
  prefs: []
  type: TYPE_NORMAL
- en: Check that it is proven technology and won't suddenly lose your source files.
    The server must be robust and not prone to crashing every few days.
  prefs: []
  type: TYPE_NORMAL
- en: '**Capacity**'
  prefs: []
  type: TYPE_NORMAL
- en: The tool must scale up well, handling large teams and large projects as well
    as small ones. In more demanding situations, does it consume a lot of disk space,
    soak up all network bandwidth, or take an excruciating time to run? Perhaps you
    require multisite repository synchronization, or does it work well enough on a
    low-bandwidth link?
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**'
  prefs: []
  type: TYPE_NORMAL
- en: Does it provide all the operations and reports that you need? Does it handle
    all the filetypes that you want to control? Can it manage binary files? Does it
    support Unicode? Does it version directories, allowing the renaming and moving
    of files? Does it manage atomic change sets, or is each file individually versioned?
  prefs: []
  type: TYPE_NORMAL
- en: '**Branching**'
  prefs: []
  type: TYPE_NORMAL
- en: To support more than one release, product variants, concurrent feature work,
    or to help with logical development, the tool *must* support branching. Does it
    support sub-branches? Is merging easy, or is it prohibitively difficult?
  prefs: []
  type: TYPE_NORMAL
- en: '**Platforms**'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that it works on all the platforms, hardware configurations, and operating
    systems that you work with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Costs and licensing**'
  prefs: []
  type: TYPE_NORMAL
- en: The SCMS must meet your budget constraints (remember, there are some *very*
    free source systems). Consider whether there are extra license costs per client.
    Sometimes these are hidden extra costs; as your team grows, you must pay an SCMS
    tax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Audit**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository must record who makes each change: Don''t force everyone into
    one SCMS user account. The system must support your access policies, allowing
    you to restrict modification rights as required. Do you want it to provide automatic
    notification of changes?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**'
  prefs: []
  type: TYPE_NORMAL
- en: The tool must be easy to use, configure, and deploy. This is especially important
    if you don't have a full-time designated SCMS administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you separate bleeding-edge code under active development from stable
    code during team development?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need a strategy to separate the two in the source control repository. Your
    choices are:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't separate them. Everyone has bleeding-edge code and must learn to cope
    with it. Don't check in anything that is obviously broken or nonfunctional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employ branches. Perform each line of development work on a separate branch,
    and merge the branches down at appropriate stable points. With this scheme, integration
    problems are only discovered on a merge; this places the burden of maintenance
    on the branch merger (which might be the developer working on the branch or a
    separate system integrator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a *stable* label, applied to the entire source tree as a *baseline*. Developers
    check out this labeled baseline and then move the components they are developing
    to the latest version. They can then work and commit changes without affecting
    anyone else's stable source tree. When new development work is deemed stable (fit
    for public consumption) the label is moved. This change is picked up by other
    developers when they next synchronize to the baseline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which you chose depends on the facilities of your SCMS and your development
    culture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Does your development team make effective use of source control?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ultimately, does your SCMS help you to develop software easily, and does it
    facilitate collaboration better than any alternative? Consider tool setup issues
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Are you using the right tool with the right feature set?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have an SCMS administrator, or is it managed on an ad hoc basis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does everyone know how to use it? Is there an appropriate training scheme?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the repository integrated with your defect management or fault-tracking tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider asset management issues like:'
  prefs: []
  type: TYPE_NORMAL
- en: Is there agreement over the contents of check-in messages and the use of other
    revision metadata?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have a consistent labeling scheme to mark important source tree revisions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have a defined (and documented) branching strategy, with provably correct
    merging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you automatically create release notes from the source repository?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you able to re-create old builds? Have you addressed when the build toolchain
    altered, affecting code compatibility?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you build a product entirely from the contents of the repository, or do
    you need to supply any extra files?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How important are each of these issues to your development team?
  prefs: []
  type: TYPE_NORMAL
- en: '**Is your current work backed up? How important are backups to your development
    team? When are backups made?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you can be bothered to write some code, it must be important, and so it
    must be backed up. There are several levels at which backups can be employed:'
  prefs: []
  type: TYPE_NORMAL
- en: Personal workstation backups. These will ensure that no work is lost from your
    local hard drive or from your source tree sandbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server holding the source control repository. This ensures that you won't
    lose the central source tree files and their revision histories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter is the most important: It''s criminally insane not to back up a
    source repository. If your workstation only contains sandbox development areas,
    then it''s not as critical to back it up; there should be little work at any time
    that isn''t checked in (remember to perform *little and often* check-ins), so
    a loss of a local disk is not critical.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider also how you back up documents and any other non—source tree items
    you produce. Either check them in to the repository somewhere or make sure that
    they are stored in logical places on a shared fileserver, somewhere that is backed
    up. Without revision control, you will have to perform manual document versioning—it's
    as important to keep historical versions of specifications as it is to version
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: In a multiuser environment, the systems administrator will determine when backups
    are made. This is usually during the night when there is less computer activity
    and less information changing on the filesystems being backed up. (But what about
    multi-continent projects with massive time zone delays?)
  prefs: []
  type: TYPE_NORMAL
- en: '**On which computers is your source code held?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously, it is held on the development servers and workstations within the
    company network. These sit safely in the office behind a corporate firewall. But
    also consider whether your code is held on laptops or on the home machines of
    telecommuters. How sensitive is the work? How should these machines be digitally
    and physically protected?
  prefs: []
  type: TYPE_NORMAL
- en: 'Chatper 19: Being Specific'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Is a poor specification better than no specification at all?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A factually incorrect or painfully out-of-date specification is definitely worse.
    It will send readers down a blind alley and waste a lot of their time. The false
    information it contains could easily lead to broken code that will cost a lot
    of time, energy, and money to fix later on.
  prefs: []
  type: TYPE_NORMAL
- en: If a specification is ambiguous or misses important information, then you're
    hoping that the readers are experienced enough to recognize the problem and interpret
    the information carefully. Hopefully they'll all make the same set of assumptions
    about the missing information. A specification should really stand on its own
    and not require the intuition of its readership.
  prefs: []
  type: TYPE_NORMAL
- en: If a specification is too verbose and hides information, then it is probably
    better (in the long run) to rewrite it.
  prefs: []
  type: TYPE_NORMAL
- en: The number of factual inaccuracies in your company's specifications will probably
    frighten you! In my experience, very few companies have a set of consistently
    good specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '**How detailed does a good specification have to be?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The answer is: *appropriately detailed*, where the value of "appropriate" depends
    on the project, the team, the contents, the quality of related documents, and
    the lunar phase. Too much detail can definitely be counterproductive: Clearly,
    if a design specification was too detailed it would *be* the code itself. However,
    ambiguity in key areas is a road to disaster.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it important that all the documents in a company/project have a common
    presentation style?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is about as important as a uniform code style. That is, there are plenty
    of more important things to worry about, even if this is the most immediately
    visible problem with a specification. The importance of visual consistency depends
    (in part) on whether the documents are released outside the company or not. It
    looks more professional to ship consistent documents, all written in a similar
    style with the same template.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the content of your documents is far more important than their appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '**How should you store documents? Should you provide an index of them (by type
    or by project), for example?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must be able to quickly locate and retrieve a document that has been written.
    The actual storage scheme is unimportant, provided that it's well known and universally
    followed.
  prefs: []
  type: TYPE_NORMAL
- en: It usually makes sense to store all documents on a single central filestore,
    and group them by work package (this could be by project, by customer, by component,
    or by feature). It's helpful to maintain a central list of all stored documents
    to aid retrieval. However, this adds management overhead, and if not maintained,
    it will quickly fall out of use.
  prefs: []
  type: TYPE_NORMAL
- en: Large companies employ people to deal with the storage and retrieval of documents.
    Though experts at this task, their presence adds more steps to the working procedure
    and more links in the development process chain.
  prefs: []
  type: TYPE_NORMAL
- en: It's essential to keep documents under some form of revision control and to
    monitor which versions of the documents apply to which versions of the code. This
    is part of a *configuration management* strategy (see "[Configuration Management](ch18s03.html
    "Configuration Management")" on page 356).
  prefs: []
  type: TYPE_NORMAL
- en: '**How should you conduct a specification review?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Document reviews work similarly to code reviews. They generally take place
    in a meeting, in which case there are some important prerequisites: the correct
    set of reviewers must be selected, and the material for review should be distributed
    with enough time for reviewers to adequately prepare.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the review can be run virtually by soliciting email feedback
    or by giving a printed copy to each reviewer and receiving his or her marked-up
    copies for inspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The review will address a number of things; the importance of each should be
    agreed upon up front:'
  prefs: []
  type: TYPE_NORMAL
- en: The quality of the contents. (Is it complete, correct, and so on? This is paramount.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of the presentation style. (Does the document conform to project
    guidelines?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of the writing style. (Does the author write like Shakespeare or
    a five year old? For software specifications, both are bad!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a meeting context, it''s best to discuss general comments about the material
    and the overall approach first. (But be careful here: It''s very easy to get waylaid
    by more specific technical issues at this stage.) Then the specifics of the material
    can be discussed. Since all the reviewers have looked at the material beforehand
    and have already amassed their comments, stepping through, section by section,
    is usually appropriate. Long sections might be traversed paragraph by paragraph
    if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Does self-documenting code render all specifications useless? Specific ones?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Not entirely. Self-documenting code can avoid the need for design specifications
    or other maintenance documents. Literate API documentation placed in code comments
    can even replace functional specifications in *some* cases, if the docs are really
    thorough. Be careful, though: If you try to write a lot of documentation in literate
    comments, you''d probably find it easier to type the same information into a word
    processor. Literate code documentation can never replace a requirements specification
    or a test specification.'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive set of automated test cases *could* replace a software component's
    test specification, if the test were sufficiently clear and maintainable. However,
    they are seldom sufficient to replace final product validation tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can a document be collaborated on by more than one author?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With difficulty—few documentation systems provide the same collaborative facilities
    as a source code control tool. Look at wiki-webs for shared text editing, if you
    can cope with your documents being in an HTML-derivative form.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you have to split the document into sections and give one section
    to each person. Each section will have an inevitable difference in writing style,
    quality of content, and will be based on a different set of assumptions; check
    for this as the work is stitched back together. You might find it easier to split
    the sections into their own documents and put an umbrella document over the top
    of them. A leader must be appointed to coordinate the work of several people—to
    guide the writing process, collate the parts, and encourage people to complete
    their sections on time.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to give one person overall writing responsibility,
    but with a strong element of peer review. The document's content and structure
    is agreed upon in meetings beforehand, then the writer retires to craft the document
    alone, before offering it for group review.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with any of these approaches, as writing by committee can produce
    laborious documents and can take a very long time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Who decides on the contents of your documents?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is defined by a company's development process, by a document template,
    or by convention. But just because there is a convention doesn't mean that it's
    actually good practice. Check that the types of documents you write, as well as
    their contents, are genuinely valuable to your software development process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consider your current project. Do you have:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A requirements specification?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**An architecture specification?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A design specification?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A functional specification?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Any other specification?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Are they up to date? Are they complete? Do you know how to get the latest
    versions? Can you access historical revisions?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you don't have some of these or they're substandard, why? How can you remedy
    the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Whose job is it to keep the documents up to date? Document versioning is an
    important aspect of specification generation—make sure that you have a clear plan
    for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you revision control your documents? If so, how?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Several techniques for managing document revisions are seen in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: Store them in an SCMS alongside the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a document (or even a workflow) management system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the filesystem: Encode the document revision in its filename (possibly
    archiving old versions in a separate old directory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store old revisions in an email attachment sent to a "magic" user (grotesque,
    but—yes—I *have* seen a company do this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whichever scheme you use, it must address these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Ease of use and document accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to prevent two people from editing the same document at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating the latest release version from the copy currently under development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid accidental deletion or overwriting the wrong document version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to maintain the document history with each change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ease of referencing a specific document revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Does the required number of reviewers depend on the size of the code being
    reviewed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not really. If your code is particularly important, then you might consider
    inviting a few more reviewers, or you might make a particular effort to select
    reviewers with the most experience.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the code is too large, you don't need more reviewers—you need a
    rewrite!
  prefs: []
  type: TYPE_NORMAL
- en: '**Which tools are useful aids for code reviewing?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Common sense, a keen pair of eyes, and an alert brain!
  prefs: []
  type: TYPE_NORMAL
- en: A number of software tools are also useful. Many different tools can inspect
    your code and help you to gauge its quality and relative risk to the entire codebase.
    They can trace the flow of execution, work out which code is executed most often,
    and calculate a value for each function's code complexity. This last metric is
    very useful when identifying which pieces of code need to be reviewed as soon
    as possible. A visual design program may help you to understand the code structure
    and its dependencies (particularly useful for reviewing class hierarchies in object-oriented
    languages).
  prefs: []
  type: TYPE_NORMAL
- en: '**Should you perform a code review before or after running it through source
    code checking tools?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After. Reviewers should probably use these tools themselves during review preparation,
    but authors must perform all possible checking on their own code before releasing
    it for review. They'd be foolish not to. It makes no sense to waste reviewers'
    time on code that could have been easily improved. Reserve review time to find
    more interesting problems.
  prefs: []
  type: TYPE_NORMAL
- en: If an issue is detected during a review, thought should be given to whether
    the same issue can be automatically detected in the future using a tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**What preparation is required for a code review meeting?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The author has completed the code satisfactorily (otherwise he or she is wasting
    the reviewers'' precious time). The chairman has arranged the meeting properly
    so that it will run smoothly. More interestingly, before the meeting, each reviewer
    must have already:'
  prefs: []
  type: TYPE_NORMAL
- en: Read (and understood) the specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Become familiar with the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawn up a list of issues and questions (this step enforces discipline; if you
    don't force yourself to do this, it's easy to superficially skim the code and
    not really know it well enough to review thoroughly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will always be things you'll find during methodical inspection in a review
    meeting that you missed beforehand. Even so, this prior preparation is essential
    to prevent the meeting from wasting a lot of people's time.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you differentiate review comments to be acted upon immediately from
    those to chalk up for experience on the next project?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You must make a decision based on:'
  prefs: []
  type: TYPE_NORMAL
- en: How important the identified problem is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it's a matter of personal aesthetics or it breaks an agreed best practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much work is involved in the fix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How serious the effect of the change is on the rest of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How wrong (or misleading) the code is without the fix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fragile or dangerous the change work is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the project is in the development cycle—you only want to make *essential*
    changes near a release deadlin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no easy rule. If there is any ambiguity in a review meeting, then the
    chairman makes the ultimate choice. Sometimes problems are rated between *must
    fix and nice to have*—the author implements as many high priority fixes as feasible
    in the available time. Other issues may be deferred to the next iteration of the
    component's development.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you run a virtual review meeting?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual reviews are commonly run by email. The review is organized by a chairman,
    who is usually the hub of communications. Certainly, the author must *not* be
    the hub of communications; it would be too easy for him to select which comments
    are important and to ignore all the things he doesn't like. This is obviously
    a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important question with this approach: Do the reviewers get to
    see each other''s comments? In a virtual review, debate is much harder to facilitate,
    especially if emails are directed only to the chairman. However, a 1,000-email
    conversation broadcast to all reviewers quickly becomes irritating and diverting.
    As an alternative, you could meet in a virtual chat room, use an instant messenger,
    a dedicated newsgroup, or a mailing list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative virtual review mechanism is to distribute printouts of the code
    in question. The reviewers scribble comments on their copies and return them to
    the author. You can run a similar scheme using a wiki: Post your code on the wiki
    and let reviewers add comments to the page. The format of how you conduct a review
    is less important than simply doing it somehow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How useful are informal code reviews?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Informal reviews are much better than no review at all, but since they are less
    thorough, they'll inevitably find fewer faults (for the same quality of code reviewer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although terms are not officially defined, McConnell describes two types of
    informal review: (McConnell 96)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Walkthroughs**'
  prefs: []
  type: TYPE_NORMAL
- en: These are very informal gatherings where programmers look over the code together.
    This could be in front of an editor, with changes made on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reading**'
  prefs: []
  type: TYPE_NORMAL
- en: The author distributes copies of the code to a set of reviewers, who make comments
    on it and send them back to the author.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Does your project perform code reviews? Does it perform** *enough* **code
    reviews?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if it makes a vaguely regular event of code reviews, there probably still
    isn't enough reviewing going on. Too little value is put on this practice; if
    the code seems to work, then people think that there's no point wasting valuable
    time reviewing it.
  prefs: []
  type: TYPE_NORMAL
- en: This attitude is careless. The time taken to track lingering code faults is
    often far greater than the effort of review. Code reviews are a sensible and pragmatic
    way to take control of your development process and ensure that your software
    is of high quality.
  prefs: []
  type: TYPE_NORMAL
- en: What can you do to improve on this in your current project?
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you work with any programmers whose code is considered to be above review?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A respected Guru programmer (see "[The Guru](ch16.html#the_guru "The Guru")"
    on page 299) is often held in awe, and no one ever suggests that his work should
    be reviewed. No one probably dares. This reverence is misguided and dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my experience, Gurus write some of the most review-worthy code you''ll ever
    see: full of deep, incomprehensible, unmaintainable magic. The fact that they
    never put their code forward for review illustrates their incorrect attitude toward
    the task and the team. No one''s code is above review; all code should be carefully
    scrutinized.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What percentage of your code has ever been subject to code review?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless you're a very unusual beast, this amount is undoubtedly small. How formal
    have the reviews been? How useful was each review, and how much did it contribute
    to the final quality of the code?
  prefs: []
  type: TYPE_NORMAL
- en: How much of your unreviewed code was pair programmed? How much *should* have
    been reviewed? How much unreviewed code was critically important commercial code?
    How many bugs slipped through into production software, and how many of those
    bugs caused later problems?
  prefs: []
  type: TYPE_NORMAL
- en: Even if it's not a part of your project culture to run code reviews, make a
    point of inviting formal review for your work. Don't worry if no one else does
    it—your code will be exceptional by comparison!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 21](ch21.html "Chapter 21. HOW LONG IS A PIECE OF STRING?")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How can you rescue a slipping project and bring it back on track?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One technique to protect yourself from a failing project is to run, fast, like
    a rat from a sinking ship. It's not very professional, though!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a project is behind schedule, there''s rarely anything you can do to bring
    it back on track—that is, unless there was a monster amount of contingency allocated.
    You might instead consider these strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Reschedule the project; see if you can agree a later delivery date with the
    customer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: De-scope the first release, possibly agreeing to a later release with the missing
    functionality. It's better to commit to doing less stuff, but doing it better
    and within the allotted time, than to implement loads of unnecessary functionality
    and slip badly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't blindly throw more developers at the project to speed things up. Brooks
    lucidly described how bad this idea is, especially when a project is failing.
    (Brooks 95) It would take the existing developers time to get the new guys up
    to speed, and there would then be extra overhead in managing the larger team.
    Any benefit would almost certainly be outweighed by the costs of new personnel.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the correct response to having a deadline imposed on you before feasibility
    or planning work commences?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tact! The fixed delivery deadline might be a valid business requirement: You''ll
    make money if you ship software on time; you''ll make nothing if you don''t. You
    can''t always do the theologically correct thing and move a deadline or adjust
    the scope of the work.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it helps your design effort to have early visibility of the anticipated
    project deadline. This information shows you how pure and well-thought-out your
    design can be, and it will help you to scope out the amount of code required and
    whether future flexibility can be considered. Ultimately, it will show you whether
    or not you need to hack out a quick-fix solution or the elegantly engineered code
    you always want to write. It might help you to make buy versus build decisions
    and to set the final quality expectations for the delivered software.
  prefs: []
  type: TYPE_NORMAL
- en: Make it clear that this is not an ideal way to develop software. *Hopefully*
    someone will listen, and the managers will learn to stop promising such risky
    deadlines—it's a careless form of gambling with the success of a project and the
    future of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you ensure that a development plan is genuinely useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'High-quality development plans are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accurate**'
  prefs: []
  type: TYPE_NORMAL
- en: They include all the tasks required to build the software and are based on sound
    timescale estimates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fine-grained**'
  prefs: []
  type: TYPE_NORMAL
- en: There aren't a few large tasks with rough estimates, but many small tasks carefully
    sequenced. Our confidence in the accuracy of a small task's timescale is higher,
    so the quality of the overall plan will be higher.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that a task comprises several parts (e.g., it is dependent on a
    third party and splits into the third-party release milestone, followed by a period
    of integration and bug fixing) then make this explicit on the plan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agreed**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone buys into the plan: Management is happy with the level of inherent
    risk, while programmers agree that the timescales are accurate, no tasks are missing,
    and all the dependencies are correctly mapped out.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visible**'
  prefs: []
  type: TYPE_NORMAL
- en: They are used to make important decisions by individual developers and by managers.
    Timescale changes are communicated through the plan. The plan is versioned, and
    progress against the plan is recorded clearly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitored**'
  prefs: []
  type: TYPE_NORMAL
- en: If the schedule is poorly monitored, the timescale estimates become a worthless
    statistic. Progress must be checked against the plan. The course of the development
    effort is steered by this measurement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do different programmers work at different rates? How can you reflect
    this on the plan?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Programmers differ in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They have different technical abilities and reason about problems in different
    ways. This affects the quality of work produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different levels of experience lead to different design choices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'People have different levels of commitment: responsibility for old projects,
    levels of enthusiasm for the company or project, respect for the craft of software
    construction, and external commitments (family pressures, socializing, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some people are highly motivated and prepared to put in hours of overtime to
    get a project finished. Others want to work their minimum hours and then go party.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not just the duration of a work package that differs between programmers.
    The quality of their code, the soundness of their design, and the bug count of
    their programs will differ too. It will even differ when the same programmer attempts
    the same task multiple times—with more experience, a programmer will work better
    the second time.
  prefs: []
  type: TYPE_NORMAL
- en: To reflect this on a project plan, check which developer each task is allocated
    to. If the task is not within his or her core competency, then increase the timescale
    estimate, or add in a block of contingency to the end. Consider putting in an
    extra up-front task to get the developer up to speed with the work, and make sure
    that you include any training that might be required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What percentage of the projects that you''ve worked on have run to schedule?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For those that did: What contributed to the success of the planning effort?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For those that failed: What were the main problems?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It's easier to characterize failure than success; you'll identify the single
    reason that something went wrong far more easily than a delicate balance of things
    working together well. When everything on a project is healthy, the whole thing
    appears to just work.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative and incremental development helps to accommodate problems and de-risk
    the plan. Well-understood work packages, a fine-grained plan, and a good initial
    design are also key. High-quality testing performed early and often makes development
    much safer. Talented developers are also very useful!
  prefs: []
  type: TYPE_NORMAL
- en: '**How accurate are your timescale estimates? How far off target are you normally?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a skill that you can continually improve. Experience is a great teacher.
    Hopefully, your later estimates have been more accurate than your earlier ones.
    Is this the case?
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't yet been asked to make timescale estimates, start practicing
    now! Make a mini-plan for your current development task. Estimate timescales for
    the small parts of this mini-plan and see how accurate you are. This has the added
    benefit of making you think carefully about what you're doing, putting a good
    initial design into place. It will also force you to leave enough time for testing,
    debugging, and documentation—all good things.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How do the choices of programming style and development process influence
    one another?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They don't need to have any bearing on one another, but hopefully they're the
    kinds of things you think about together as you begin a project.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative processes are easier to implement with programming methodologies that
    support componentization—the object-oriented paradigm. Linear processes are suitable
    for all types of programming styles, but are not necessarily the best match.
  prefs: []
  type: TYPE_NORMAL
- en: The developers' prior experiences and their personal preferences for programming
    style will have the greatest affect on these choices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which is the best programming style?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trick question! If you actually gave an answer, put down this book and give
    yourself 30 lashes with a wet noodle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which is the best development process?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't possibly have fallen for this too? Electric shock therapy with a 9-volt
    battery is your only option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where does each development process listed in this chapter fall on the classification
    axes we saw in "[Development Processes](ch22s03.html "Development Processes")"
    on page 425?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, a quick recap: The thick/thin classification relates to the bureaucracy
    and paperwork involved in a process, *sequencing* describes how linear and predictive
    the process is, and the *design direction* determines whether design starts from
    the minuscule implementation details or from the grand overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ad hoc**'
  prefs: []
  type: TYPE_NORMAL
- en: Who knows how to classify this mess? An ad hoc process could be anywhere on
    any axis, even constantly moving. Ad hoc developers are typically low on bureaucracy,
    but with no discipline at all, things fall through the cracks or are repeated
    time and time again. There's no sequencing whatsoever, so this anti-process rates
    off the scale, and if there *is* any design, then it probably has nothing to do
    with what is actually being built, anyway!
  prefs: []
  type: TYPE_NORMAL
- en: '**Waterfall model**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a reasonably thick, very linear process. It generally leads to a top-down
    design, although it doesn't enforce this.
  prefs: []
  type: TYPE_NORMAL
- en: '**SSADM**'
  prefs: []
  type: TYPE_NORMAL
- en: This scores full marks on the thick scale—there's paperwork and heavily documented
    steps aplenty here. The sequencing axis is full throttle toward linear.
  prefs: []
  type: TYPE_NORMAL
- en: '**V model**'
  prefs: []
  type: TYPE_NORMAL
- en: Another thick, linear process (although some parts of this process are explicitly
    parallelized for efficiency). As with other waterfall variants, it leans toward
    top-down design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototyping**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An explicitly cyclical process (although by fixing the number of prototypes
    anticipated, we can enforce some level of linearity on the development process).
    This tends to edge toward the thin camp, sometimes too much so: Prototypes by
    themselves are not sufficient to capture user requirements or design decisions,
    so when prototyping, it''s dangerously easy to avoid capturing decisions in specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative and incremental**'
  prefs: []
  type: TYPE_NORMAL
- en: Again nonlinear by design, this process can be as bureaucratic as you like,
    but some variants (especially as seen in the agile movement) can be quite thin.
    Iterative and incremental processes tend to stick in the middle of the design
    direction axis—at each iteration, we perform high-level design right through to
    low-level design. These design decisions are revised in the next cycle, and additional
    work repeat the top-level and bottom-level design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spiral model**'
  prefs: []
  type: TYPE_NORMAL
- en: A thick version of an iterative and incremental process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agile methodologies**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Agile processes are thin and nonlinear. They do not fix a design direction;
    you are constantly redirecting the design. Compare design to driving to Paris:
    In a traditional process, you would point your car at Paris and drive; in an agile
    process, you''d start driving and make constant streering tweaks. You *might*
    even map out sections of the middle of the journey before determining the best
    route out of your hometown.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that an organization's implementation of a specific process model will
    be inevitably tailored to its particular ways of working. (This is perfectly healthy.)
    These tweaks can make a significant difference. For example, you might base your
    development around the V model but aim to make the interphase handoff procedure
    as lightweight as possible, to reduce unnecessary bureaucracy.
  prefs: []
  type: TYPE_NORMAL
- en: '**If development processes and programming styles are recipes, what would a
    software development cookbook look like?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It would probably look dangerously like a software engineering textbook. There
    probably wouldn't be that many mouth-watering pictures! Just as the Naked Chef
    's^([[17](#ftn.APP-FN-17)]) recipes differ from Rachael Ray's, you could imagine
    a number of different approaches to a mythical software development cookbook.
  prefs: []
  type: TYPE_NORMAL
- en: You don't really see that many software development cookbooks because people
    don't shop around for new recipes that often. These things only tend to spring
    up when a marketing machine can gather sufficient momentum behind the next big
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: '**With a suitable process, can software construction become a predictable,
    repeatable task?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're still not in a position where the software industry is able to make this
    claim. No matter how hard we try to homogenize the development process, the quality
    of code produced is ultimately determined by the quality (e.g., experience, ability,
    intuition, and flair) and the particular mood (e.g., ability to concentrate, being
    in the zone or constantly interrupted, see page 414) of the programmers doing
    the work. A master craftsman will produce more elegant, robust, and well-fashioned
    designs than a fresh apprentice.
  prefs: []
  type: TYPE_NORMAL
- en: With such variance, it's hard to reproducibly create software, even with the
    most prescriptive process. Using the same programmers, the same process, and trying
    to produce the same piece of software, you'll never get the exact same result.
    On different days, the team will make different choices, which will lead to radically
    different software with different inherent faults and strengths. (This point is
    hypothetical anyway; the same team would learn from its mistakes the first time
    around and create a different—probably better—piece of software on its second
    attempt.)
  prefs: []
  type: TYPE_NORMAL
- en: Agile methods exploit this, and celebrate the unpredictability of software construction.
    They attempt to address uncertainty by choosing pragmatic approaches that minimize
    the inherent risk of an unpredictable task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What development process and programming language style are you currently
    using?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Has it been formally agreed upon by the development team, or do you use it
    by convention?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How was it chosen? Was it chosen specifically for this project, or is it
    the recipe you always use?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is it documented anywhere?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Does the team stick to the process? When problems arise and your back is
    against the wall, do you maintain the process, or is all ivory tower theory ignored
    in a rush to produce something—anything?**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This question is probing how organized your development team is—and whether
    you develop software on purpose or by accident. Do you really *know* how you produce
    software, or do you still rely on the heroic efforts of a few key team members
    to get your work done?
  prefs: []
  type: TYPE_NORMAL
- en: Can you point to a specific reference for your way of working? Is it documented?
    Is it understood? Is it understood by *all* the developers, by *all* the process
    managers, and by *all* those who play some part in the construction process?
  prefs: []
  type: TYPE_NORMAL
- en: '**Are your current processes and styles appropriate? Are they the best way
    for you to develop your software right now?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't know how you're producing software, or if you're not using the
    best approach, what would be better, and why?
  prefs: []
  type: TYPE_NORMAL
- en: Watch for the danger of ad hoc methods. I've seen numerous organizations where
    there is no agreed method; one person produces wholly OO designs while another
    avoids OO and performs structural design. The code produced is ugly and inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does your organization appreciate that there are other development models
    that might be worth investigating?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Understand who makes decisions about this kind of thing—is it the developers,
    the software team leader, or the managers? Are these people sufficiently informed
    about software development processes? Understand why they''ve chosen to work in
    the current way: what problems have they already solved? Often the reason for
    an odd development procedure is historical—organizations evolve a set of working
    practices, they don''t fashion them consciously.'
  prefs: []
  type: TYPE_NORMAL
- en: What would it take to persuade your organization to adopt another process model?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#APP-FN-17)]) If you think that sounds rude, see [www.jamieoliver.com](http://www.jamieoliver.com).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Which of the programming niches we''ve looked at here are particularly similar
    or share common characteristics? Which are particularly different?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is more in common than you might think. Crossovers include:'
  prefs: []
  type: TYPE_NORMAL
- en: Games and web applications could both be considered specific forms of applications
    programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web programming is a form of distributed programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some enterprise work can take the form of web applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some systems implementation is for embedded platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical work is sometimes optimized by parallelizing and distributing the
    computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which of these programming disciplines is hardest?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each type of programming presents a different set problems, and every individual
    program is complex in its own way. Otherwise, programming would take very little
    skill and any idiot could do it. (The fact that many idiots *do* program doesn't
    bear discussion here!)
  prefs: []
  type: TYPE_NORMAL
- en: The "harder" programming worlds could be considered to be the ones that demand
    more formal processes to ensure adequate quality is met. For example, the world
    of safety-critical software (mentioned in "[In a Nutshell](ch23s10.html "In a
    Nutshell")" on page 456) is particularly fraught. Watertight specifications, very
    formal development and testing models, and certification to regulated standards
    are essential in this world, along with the inclusion of reliable failsafes.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical work, in particular, would be hard for someone who doesn't have a
    head for math and designing complex algorithms. It requires extra statistical
    or scientific skills.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it important to be an expert in one particular area or to have a good
    grounding in all of them without a particular specialism?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An understanding of each area is helpful. However, to truly excel in a given
    area requires specific skills and expertise that can only be gained from experience
    in the trenches. To get this good experience, you'll probably have to focus on
    one particular work area. Vincent van Gogh remarked, "If one is the master of
    one thing and understands one thing well, one has at the same time insight into
    and understanding of many things." Learn the particular intricacies that set your
    discipline apart from the others.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which programming niche should trainee programmers be introduced to?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is seldom thought about by the writers of programming courses. It's a sad
    oversight; many courses are not tailored to programming in the Real World—more
    to some theoretical, androgynous branch of programming. Of course, this makes
    teaching programming much easier, and there are fewer issues to confuse the trainee
    with. But it is important to understand how to make appropriate coding choices
    when you're in the thick of the software factory, and someone has to teach this.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the other programming areas, applications programming is relatively
    unencumbered by specific rituals and practices, so this is presumably the easiest
    area to introduce programmers to. Because trainees rarely appreciate the wider
    world of software development, this is probably what they'd expect to learn anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What programming arena are you working in right now? How does it affect the
    code that you''re writing? What specific design and implementation decisions has
    it led you to make?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to understand the type of code you write so you can make the
    correct programming decisions. If you can't explain how your code has been shaped
    by the demands of the problem domain, then you may not have been thinking hard
    enough about what you're doing. Software has to survive in—and must therefore
    be shaped by—its environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you have experience working in more than one programming discipline? How
    easy was it for you to switch mindsets and apply appropriate techniques in a different
    world?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be careful of the temptation to dismiss these differences and hop thoughtlessly
    from one domain to another. It can lead you to write bad code. You probably won't
    realize that your code isn't appropriate until the end of the game, when you're
    working on tedious bugs or trying to optimize your system to get it to meet the
    original requirements (e.g., code size or scalability). If that's when you realize
    your work isn't molded to its environment, then you're in a sticky position.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are any of the people you work with unaware of the forces that shape the
    particular kind of code you write? Do you have embedded software being written
    by programmers who only understand applications work? What can you do about this?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programmers who don't tailor their work to the requirements of the problem domain
    endanger your project. If they don't understand the inherent constraints (scalability,
    performance, code size, interoperability, and so on), their code will not match
    the specifications, and they will be weak links in the development chain.
  prefs: []
  type: TYPE_NORMAL
- en: Code and design review will help to catch this, as would pair programming.
  prefs: []
  type: TYPE_NORMAL
- en: BIBLIOGRAPHY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (Alexander 79) AlexanderChristopher. The Timeless Way of Building. Oxford University
    Press, 1979. 0195024028.
  prefs: []
  type: TYPE_NORMAL
- en: (Aristotle) Aristotle (384-322 bc). Rhetoric. Book 1, Chapter 11, Section 20\.
    350 bc.
  prefs: []
  type: TYPE_NORMAL
- en: (Beck 99) BeckKent. Extreme Programming Explained. Addison-Wesley, 1999. 0201616416.
  prefs: []
  type: TYPE_NORMAL
- en: '(Belbin 81) BelbinMeredith. Management Teams: Why They Succeed or Fail. Butterworth
    Heinemann, 1981. 0750659106.'
  prefs: []
  type: TYPE_NORMAL
- en: (Bentley 82) BentleyJon Louis. Writing Efficient Programs. Prentice Hall Professional,
    1982. 013970244X.
  prefs: []
  type: TYPE_NORMAL
- en: '(Bersoff et al. 80) BersoffEdwardVilas HendersonStanley Siegel. Software Configuration
    Management: An Investment in Product Integrity. Longman Higher Education, 1980.
    0138217696.'
  prefs: []
  type: TYPE_NORMAL
- en: (Boehm 76) BoehmBarry. "Software Engineering." IEE Transactions on Computers.
    C-25, 12, 1,226-1,241. 1976. http://www.computer.org/tc.
  prefs: []
  type: TYPE_NORMAL
- en: (Boehm 81) BoehmBarry. Software Engineering Economics. Prentice Hall, 1981.
    0138221227.
  prefs: []
  type: TYPE_NORMAL
- en: (Boehm 87) BoehmBarry. "Improving Software Productivity." IEEE computer, 20,
    9. 1987.
  prefs: []
  type: TYPE_NORMAL
- en: (Boehm 88) BoehmBarry. "A Spiral Model of Software Development and Enhancement."
    IEEE computer, 21. May 5, 1988.
  prefs: []
  type: TYPE_NORMAL
- en: (Booch 97) BoochGrady. Object Oriented Analysis and Design With Applications.
    Benjamin/Cummings, 1994. Second Edition. 0805353402.
  prefs: []
  type: TYPE_NORMAL
- en: '(Briggs 80) Briggs MyersIsabel. Gifts Differing: Understanding Personality
    Type. Consulting Psychologist''s Press, 1980. 0891060111.'
  prefs: []
  type: TYPE_NORMAL
- en: (Brooks 95) BrooksFrederick P. Jr. The Mythical Man Month. Addison-Wesley, 1995.
    Anniversary Edition. 0201835959.
  prefs: []
  type: TYPE_NORMAL
- en: '(DeMarco 99) DeMarcoTomTimothy Lister. Peopleware: Productive Projects and
    Teams. Dorset House, 1999. Second Edition. 0932633439.'
  prefs: []
  type: TYPE_NORMAL
- en: (Dijkstra 68) DijkstraEdsger W. "Go To Statement Considered Harmful." Communications
    of the ACM, 11, 3, 147-148. 1968.
  prefs: []
  type: TYPE_NORMAL
- en: (Doxygen) van HeeschDimitri. Doxygen. http://www.doxygen.org.
  prefs: []
  type: TYPE_NORMAL
- en: (Economist 01) "Agility counts." The Economist. September 20, 2001.
  prefs: []
  type: TYPE_NORMAL
- en: (Fagan 76) FaganMichael. "Design and code inspections to reduce errors in program
    development." IBM Systems Journal, 15, 3. 1976.
  prefs: []
  type: TYPE_NORMAL
- en: (Feldman 78) FeldmanStuart. "Make—A Program for Maintaining Computer Programs."
    Bell Laboratories Computering Science Technical Report 57. 1978.
  prefs: []
  type: TYPE_NORMAL
- en: '(Fowler 99) FowlerMartin. Refactoring: Improving the Design of Existing Code.
    Addison-Wesley, 1999. 0201485672.'
  prefs: []
  type: TYPE_NORMAL
- en: '(Gamma et al. 94) GammaErichRichard HelmRalph JohnsonJohn Vlissides. Design
    Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
    0201633612.'
  prefs: []
  type: TYPE_NORMAL
- en: (Gosling et al. 94) GoslingJamesBill JoyGuy SteeleGilad Bracha. The Java Language
    Specification. Addison-Wesley, 2000. Second Edition. 0201310082\. http://java.sun.com.
  prefs: []
  type: TYPE_NORMAL
- en: (Gould 75) GouldJohn. "Some Psychological Evidence on How People Debug Computer
    Programs." International Journal of Man-Machine Studies. 1975.
  prefs: []
  type: TYPE_NORMAL
- en: (Groom 94) GroomWinston. Forrest Gump. Black Swan, 1994. 0552996092.
  prefs: []
  type: TYPE_NORMAL
- en: (Hoare 81) HoareCharles. "The Emperor's Old Clothes." Communications of the
    ACM, 24, 2. ACM, 1981.
  prefs: []
  type: TYPE_NORMAL
- en: (Humphrey 97) HumphreyWatts S. Introduction to the Personal Software Process.
    Addison-Wesley, 1997. 0201548097.
  prefs: []
  type: TYPE_NORMAL
- en: (Humphrey 98) HumphreyWatts S. "The Software Quality Profile." Software Quality
    Professional. December 1998. http://www.sei.cmu.edu/publications/articles/quality-profile/.
  prefs: []
  type: TYPE_NORMAL
- en: (Hunt Davis 99) HuntAndrewDavid Thomas. The Pragmatic Programmer. Addison-Wesley,
    1999. 020161622X.
  prefs: []
  type: TYPE_NORMAL
- en: (IEEE 84) IEEE Standard Glossary of Software Engineering Terminology. ANSI/IEEE,
    1984. ANSI/IEEE Standard 729.
  prefs: []
  type: TYPE_NORMAL
- en: (ISO 84) ISO7498:1984(E) Information Processing Systems—Open Systems Interconnection—Basic
    Reference Model. International Standard for Information Systems, 1984. ISO Standard
    ISO 7498:1984(E).
  prefs: []
  type: TYPE_NORMAL
- en: (ISO 98) ISO/IEC 14882:1998, Programming Languages—C++. International Standard
    for Information Systems, 1998. ISO Standard ISO/IEC 14882:1998.
  prefs: []
  type: TYPE_NORMAL
- en: (ISO 99) ISO/IEC 9899:1999, Programming Languages—C. International Standard
    for Information Systems, 1999. ISO Standard ISO/IEC 9899:1999.
  prefs: []
  type: TYPE_NORMAL
- en: (ISO 05) ISO/IEC 23270:2003, Information technology—C# Language Specification.
    International Standard for Information Systems, 2005. ISO Standard ISO/IEC 23270:2003.
  prefs: []
  type: TYPE_NORMAL
- en: (Jackson 75) JacksonM.A. Principles of Program Design. Academic Press, 1975.
    0123790506.
  prefs: []
  type: TYPE_NORMAL
- en: (Javadoc) Javadoc. Sun Microsystems, Inc. http://java.sun.com/products/jdk/javadoc".
  prefs: []
  type: TYPE_NORMAL
- en: (Kernighan Pike 99) KernighanBrian W.Rob Pike. The Practice of Programming.
    Addison-Wesley, 1999. 020161586X.
  prefs: []
  type: TYPE_NORMAL
- en: (Kernighan Plaugher 76) KernighanBrian W.P.J. Plaugher. Software Tools. Addison-Wesley,
    1976. 020103669X.
  prefs: []
  type: TYPE_NORMAL
- en: (Kernighan Plaugher 78) KernighanBrian W.P.J. Plaugher. The Elements of Programming
    Style. McGraw-Hill, 1978. 0070341990.
  prefs: []
  type: TYPE_NORMAL
- en: (Kernighan Ritchie 88) KernighanBrian W.Dennis M.Ritchie. The C Programming
    Language. Prentice Hall, 1988. Second Edition. 0131103628.
  prefs: []
  type: TYPE_NORMAL
- en: (Knuth 92) KnuthDonald. Literate Programming. CSLI Publications, 1992. 0937073806.
  prefs: []
  type: TYPE_NORMAL
- en: (Kurlansky 99) KurlanskyMark. The Basque History of the World. Jonathan Cope,
    1999. 0224060554.
  prefs: []
  type: TYPE_NORMAL
- en: (McConnell 96) McConnellSteve. Rapid Development. Microsoft Press, 1996. 1556159005.
  prefs: []
  type: TYPE_NORMAL
- en: '(McConnell 04) McConnellSteve. Code Complete: A Practical Handbook of Software
    Construction. Microsoft Press, 2004. Second Edition. 0735619670.'
  prefs: []
  type: TYPE_NORMAL
- en: '(Meyers 97) MeyersScott. Effective C++. Addison-Wesley, 1997. Item 34: Minimize
    complication dependencies between files. 0201924889.'
  prefs: []
  type: TYPE_NORMAL
- en: '(Miller 56) MillerGeorge A. "The Magical Number Seven, Plus or Minus Two: Some
    Limits on our Capacity for Processing Information." First published in Psychological
    Review, 63, 81-97. 1956.'
  prefs: []
  type: TYPE_NORMAL
- en: (Myers 86) MyersWare. "Can software for the Strategic Defense Initiative ever
    be error-free?" IEEE computer. 19, 10, 61-67. 1986.
  prefs: []
  type: TYPE_NORMAL
- en: (Page Jones 96) Page-JonesMeilir. What Every Programmer Should Know About Object-oriented
    Design. Dorset House Publishing Co., 1996. 0932633315.
  prefs: []
  type: TYPE_NORMAL
- en: (Royce 70) RoyceW.W. "Managing the Development of Large Software Systems." Proceedings
    of IEEE WESCON, August 1970.
  prefs: []
  type: TYPE_NORMAL
- en: (Simpsons 91) Simpsons, The. "Do the Bart Man." Geffen, 1991. GEF87CD.
  prefs: []
  type: TYPE_NORMAL
- en: (Stroustrup 97) StroustrupBjarne. The C++ Programming Language. Addison-Wesley,
    1997. Third Edition. 0-201-88954-4.
  prefs: []
  type: TYPE_NORMAL
- en: (UML) Unified Modeling Language. Object Management Group. http://www.uml.org.
  prefs: []
  type: TYPE_NORMAL
- en: (Vitruvius) Vitruvius PollioMarcus (c. 70-25 bc). De Architectura. Book 1, Chapter
    3, Section 2.
  prefs: []
  type: TYPE_NORMAL
- en: (Weinberg 71) WeinbergGerald. The Psychology Of Computer Programming. Van Nostrand
    Reinhold, 1971. 0932633420.
  prefs: []
  type: TYPE_NORMAL
- en: (Wulf 72) WulfWilliam A. "A Case Against the GOTO." Proceedings of the twenty-fifth
    National ACM Conference, 1972.
  prefs: []
  type: TYPE_NORMAL
