<html><head></head><body><div class="appendix" title="Appendix&#xA0;A.&#xA0;Hints for Hunting"><div class="titlepage"><div><div><h1 class="title"><a id="hints_for_hunting"/>Appendix A. Hints for Hunting</h1></div></div></div><p>This appendix describes, in more depth than in the text, some vulnerability classes, exploitation techniques, and common issues that can lead to bugs.</p><div class="sect1" title="A.1 Stack Buffer Overflows"><div class="titlepage"><div><div><h1 class="title"><a id="a.1_stack_buffer_overflows"/>A.1 Stack Buffer Overflows</h1></div></div></div><p>Buffer overflows are memory corruption vulnerabilities that can be categorized by <span class="emphasis"><em>type</em></span> (also known as <span class="emphasis"><em>generation</em></span>). Today the most relevant ones are <span class="emphasis"><em>stack buffer overflows</em></span> and <span class="emphasis"><em>heap buffer overflows</em></span>. A buffer overflow happens if more data is copied into a buffer or array than the buffer or array can handle. It’s that simple. As the name implies, stack buffer overflows are happening in the stack area of a process memory. The stack is a special memory area of a process that holds both data and metadata associated with procedure invocation. If more data is stuffed in a buffer declared on the stack than that buffer can handle, adjacent stack memory may be overwritten. If the user can control the data and the amount of data, it is possible to manipulate the stack data or metadata to gain control of the execution flow of the process.<a id="IDX-APP-A-0030" class="indexterm"/><a id="IDX-APP-A-0031" class="indexterm"/><a id="IDX-APP-A-0032" class="indexterm"/><a id="IDX-APP-A-0033" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The following descriptions of stack buffer overflows are related to the 32-bit Intel platform (IA-32)</em></span>.<a id="IDX-APP-A-0034" class="indexterm"/></p></div><p>Every function of a process that is executed is represented on the stack. The organization of this information is called a <span class="emphasis"><em>stack frame</em></span>. A stack frame includes the data and metadata of the function, as well as a <span class="emphasis"><em>return address</em></span> used to find the caller of the function. When a function returns to its caller, the return address is popped from the stack and into the instruction pointer (program counter) register. If you can overflow a stack buffer and then overwrite the return address with a value of your choosing, you get control over the instruction pointer when the function returns.<a id="IDX-APP-A-0035" class="indexterm"/><a id="IDX-APP-A-0036" class="indexterm"/><a id="IDX-APP-A-0037" class="indexterm"/><a id="IDX-APP-A-0038" class="indexterm"/><a id="IDX-APP-A-0039" class="indexterm"/><a id="IDX-APP-A-0040" class="indexterm"/></p><p>There are a lot of other possible ways to take advantage of a stack buffer overflow for example, by manipulating function pointers, function arguments, or other important data and metadata on the stack.</p><p>Let’s look at an example program:</p><div class="example"><a id="example_program_stackoverflow.c"/><p class="title">Example A-1. Example program <span class="emphasis"><em>stackoverflow.c</em></span></p><div class="example-contents"><pre class="programlisting">01    #include &lt;string.h&gt;
02
03    void
04    overflow (char *arg)
05    {
06        char  buf[12];
07
08        strcpy (buf, arg);
09    }
10
11    int
12    main (int argc, char *argv[])
13    {
14        if (argc &gt; 1)
15            overflow (argv[1]);
16
17        return 0;
18    }</pre></div></div><p>The example program in <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> contains a simple stack buffer overflow. The first command-line argument (line 15) is used as a parameter for the function called <code class="literal">overflow()</code>. In <code class="literal">overflow()</code>, the user-derived data is copied into a stack buffer with a fixed size of 12 bytes (see lines 6 and 8). If we supply more data than the buffer can hold (more than 12 bytes), the stack buffer will overflow, and the adjacent stack data will be overwritten with our input data.</p><p><a class="xref" href="apa.html#stack_frame_illustrating_a_buffer_overfl" title="Figure A-1. Stack frame illustrating a buffer overflow">Figure A-1</a> illustrates the stack layout right before and after the buffer overflow. The stack grows downward (toward lower memory addresses), and the <span class="emphasis"><em>return address (RET)</em></span> is followed by another piece of metadata called the <span class="emphasis"><em>saved frame pointer (SFP)</em></span>. Below that is the buffer that is declared in the <code class="literal">overflow()</code> function. In contrast to the stack, which grows downward, the data that is filled into a stack buffer grows toward higher memory addresses. If we supply a sufficient amount of data for the first command-line argument, then our data will overwrite the buffer, the SFP, the RET, and adjacent stack memory. If the function then returns, we control the value of RET, which gives us control over the instruction pointer (<code class="literal">EIP</code> register).<a id="IDX-APP-A-0041" class="indexterm"/></p><div class="figure"><a id="stack_frame_illustrating_a_buffer_overfl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9857"/><img src="httpatomoreillycomsourcenostarchimages939337.png.jpg" alt="Stack frame illustrating a buffer overflow"/></div></div><p class="title">Figure A-1. Stack frame illustrating a buffer overflow</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Linux"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow_unde"/>Example: Stack Buffer Overflow Under Linux</h2></div></div></div><p>To test the program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> under Linux (Ubuntu 9.04), I compiled it without stack canary support (see Section C.1):<a id="IDX-APP-A-0042" class="indexterm"/><a id="IDX-APP-A-0043" class="indexterm"/></p><a id="I_programlisting_d1e9877"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -fno-stack-protector -o stackoverflow stackoverflow.c</code></strong></pre><p>Then, I started the program in the debugger (see Section B.4 for more information about gdb) while supplying 20 bytes of user input as a command-line argument (12 bytes to fill the stack buffer plus 4 bytes for the SFP plus 4 bytes for the RET):</p><a id="I_programlisting_d1e9883"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./stackoverflow</code></strong>

(gdb) <strong class="userinput"><code>run $(perl -e 'print "A"x12 . "B"x4 . "C"x4')</code></strong>
Starting program: /home/tk/BHD/stackoverflow $(perl -e 'print "A"x12 . "B"x4 . "C"x4')

Program received signal SIGSEGV, Segmentation fault.
<strong class="userinput"><code>0x43434343 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xbfab9fac     −1079271508
ecx            0xbfab9fab     −1079271509
edx            0x15           21
ebx            0xb8088ff4     −1207398412
esp            0xbfab9fc0     0xbfab9fc0
ebp            0x42424242     0x42424242
esi            0x8048430      134513712
edi            0x8048310      134513424
<strong class="userinput"><code>eip            0x43434343     0x43434343</code></strong>
eflags         0x10246   [ PF ZF IF RF ]
cs             0x73      115
ss             0x7b      123
ds             0x7b      123
es             0x7b      123
fs             0x0       0
gs             0x33      51</pre><p>I gained control over the instruction pointer (see the <code class="literal">EIP</code> register), as the return address was successfully overwritten with the four <code class="literal">C</code>s supplied from the user input (hexadecimal value of the four <code class="literal">C</code>s: <code class="literal">0x43434343</code>).</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Windows"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow"/>Example: Stack Buffer Overflow Under Windows</h2></div></div></div><p>I compiled the vulnerable program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> without security cookie (<code class="literal">/GS</code>) support under Windows Vista SP2 (see Section C.1):<a id="IDX-APP-A-0044" class="indexterm"/><a id="IDX-APP-A-0045" class="indexterm"/><a id="IDX-APP-A-0046" class="indexterm"/></p><a id="I_programlisting_d1e9934"/><pre class="programlisting">C:\Users\tk\BHD&gt;<strong class="userinput"><code>cl /nologo /GS- stackoverflow.c</code></strong>
stackoverflow.c</pre><p>Then, I started the program in the debugger (see Section B.2 for more information about WinDbg) while supplying the same input data as in the Linux example above.</p><p>As <a class="xref" href="apa.html#stack_buffer_overflow_under_windows_open" title="Figure A-2. Stack buffer overflow under Windows (WinDbg output)">Figure A-2</a> shows, I got the same result as under Linux: control over the instruction pointer (see the <code class="literal">EIP</code> register).</p><div class="figure"><a id="stack_buffer_overflow_under_windows_open"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9951"/><img src="httpatomoreillycomsourcenostarchimages939339.png.jpg" alt="Stack buffer overflow under Windows (WinDbg output)"/></div></div><p class="title">Figure A-2. Stack buffer overflow under Windows (WinDbg output)</p></div><p>This was only a short introduction to the world of buffer overflows. Numerous books and white papers are available on this topic. If you want to learn more, I recommend Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>buffer overflows</em></span> into Google and browse the enormous amount of material available online.</p></div></div></div>
<div class="sect1" title="A.2 NULL Pointer Dereferences"><div class="titlepage"><div><div><h1 class="title"><a id="a.2_null_pointer_dereferences"/>A.2 NULL Pointer Dereferences</h1></div></div></div><p>Memory is divided into pages. Typically, a process, a thread, or the kernel cannot read from or write to a memory location on the zero page. <a class="xref" href="apas02.html#using_unowned_memoryman_example" title="Example A-2. Using unowned memory—an example NULL pointer dereference">Example A-2</a> shows a simple example of what happens if the zero page gets referenced due to a programming error.<a id="IDX-APP-A-0047" class="indexterm"/></p><div class="example"><a id="using_unowned_memoryman_example"/><p class="title">Example A-2. Using unowned memory—an example NULL pointer dereference</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    typedef struct pkt {
04        char *  value;
05    } pkt_t;
06
07    int
08    main (void)
09    {
10        pkt_t *  packet  = NULL;
11
12        printf ("%s", packet-&gt;value);
13
14        return 0;
15    }</pre></div></div><p>In line 10 of <a class="xref" href="apas02.html#using_unowned_memoryman_example" title="Example A-2. Using unowned memory—an example NULL pointer dereference">Example A-2</a> the data structure <code class="literal">packet</code> is initialized with <code class="literal">NULL</code>, and in line 12 a structure member gets referenced. Since <code class="literal">packet</code> points to <code class="literal">NULL</code>, this reference can be represented as <code class="literal">NULL-&gt;value</code>. This leads to a classic <span class="emphasis"><em>NULL pointer dereference</em></span> when the program tries to read a value from memory page zero. If you compile this program under Microsoft Windows and start it in the Windows Debugger WinDbg (see Section B.2), you get the following result:<a id="IDX-APP-A-0048" class="indexterm"/></p><a id="I_programlisting_d1e10005"/><pre class="programlisting">[..]
(1334.12dc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
<strong class="userinput"><code>eax=00000000</code></strong> ebx=7713b68f ecx=00000001 edx=77c55e74 esi=00000002 edi=00001772
eip=0040100e esp=0012ff34 ebp=0012ff38 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
*** WARNING: Unable to verify checksum for image00400000
*** ERROR: Module load completed but symbols could not be loaded for image00400000
image00400000+0x100e:
<strong class="userinput"><code>0040100e 8b08            mov     ecx,dword ptr [eax]  ds:0023:00000000=????????</code></strong>
[..]</pre><p>The access violation is caused when the value of <code class="literal">EAX</code>, which is <code class="literal">0x00000000</code>, gets referenced. You can get more information on the cause of the crash by using the debugger command <code class="literal">!analyze -v</code>:</p><a id="I_programlisting_d1e10024"/><pre class="programlisting">0:000&gt; <strong class="userinput"><code>!analyze -v</code></strong>
[..]
FAULTING_IP:
image00400000+100e
0040100e 8b08            mov     ecx,dword ptr [eax]

EXCEPTION_RECORD:  ffffffff -- (.exr 0xffffffffffffffff)
ExceptionAddress: 0040100e (image00400000+0x0000100e)
   <strong class="userinput"><code>ExceptionCode: c0000005 (Access violation)</code></strong>
  ExceptionFlags: 00000000
NumberParameters: 2
   Parameter[0]: 00000000
   Parameter[1]: 00000000
<strong class="userinput"><code>Attempt to read from address 00000000</code></strong>
[..]</pre><p>NULL pointer dereferences usually lead to a crash of the vulnerable component (denial of service). Depending on the particular programming error, NULL pointer dereferences can also lead to arbitrary code execution.</p></div>
<div class="sect1" title="A.3 Type Conversions in C"><div class="titlepage"><div><div><h1 class="title"><a id="a.3_type_conversions_in_c"/>A.3 Type Conversions in C</h1></div></div></div><p>The C programming language is quite flexible in handling different data types. For example, in C it’s easy to convert a character array into a signed integer. There are two types of conversion: <span class="emphasis"><em>implicit</em></span> and <span class="emphasis"><em>explicit</em></span>. In programming languages like C, implicit type conversion occurs when the compiler automatically converts a variable to a different type. This usually happens when the initial variable type is incompatible with the operation you are trying to perform. Implicit type conversions are also referred to as <span class="emphasis"><em>coercion</em></span>.<a id="IDX-APP-A-0049" class="indexterm"/></p><p>Explicit type conversion, also known as <span class="emphasis"><em>casting</em></span>, occurs when the programmer explicitly codes the details of the conversion. This is usually done with the cast operator.</p><p>Here is an example of an implicit type conversion (coercion):</p><a id="I_programlisting_d1e10061"/><pre class="programlisting">[..]
unsigned int user_input = 0x80000000;
signed int   length     = user_input;
[..]</pre><p>In this example, an implicit conversion occurs between unsigned int and signed int.</p><p>And here is an example of an explicit type conversion (casting):<a id="IDX-APP-A-0050" class="indexterm"/></p><a id="I_programlisting_d1e10070"/><pre class="programlisting">[..]
char       cbuf[] = "AAAA";
signed int si     = *(int *)cbuf;
[..]</pre><p>In this example, an explicit conversion occurs between char and signed int.</p><p>Type conversions can be very subtle and cause a lot of security bugs. Many of the vulnerabilities related to type conversion are the result of conversions between unsigned and signed integers. Below is an example:</p><div class="example"><a id="a_signed_solidus_unsigned_conversion"/><p class="title">Example A-3. A signed/unsigned conversion that leads to a vulnerability (<span class="emphasis"><em>implicit.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    unsigned int
04    get_user_length (void)
05    {
06        return (0xffffffff);
07    }
08
09    int
10    main (void)
11    {
12        signed int length = 0;
13
14        length = get_user_length ();
15
16        printf ("length: %d %u (0x%x)\n", length, length, length);
17
18        if (length &lt; 12)
19            printf ("argument length ok\n");
20        else
21            printf ("Error: argument length too long\n");
22
23        return 0;
24    }</pre></div></div><p>The source code in <a class="xref" href="apas03.html#a_signed_solidus_unsigned_conversion" title="Example A-3. A signed/unsigned conversion that leads to a vulnerability (implicit.c)">Example A-3</a> contains a signed/unsigned conversion vulnerability that is quite similar to the one I found in FFmpeg (see <a class="xref" href="ch04.html" title="Chapter 4. NULL Pointer FTW">Chapter 4</a>). Can you spot the bug?</p><p>In line 14, a length value is read in from user input and stored in the signed int variable <code class="literal">length</code>. The <code class="literal">get_user_length()</code> function is a dummy that always returns the “user input value” <code class="literal">0xffffffff</code>. Let’s assume this is the value that was read from the network or from a data file. In line 18, the program checks whether the user-supplied value is less than 12. If it is, the string “<code class="literal">argument length ok</code>” will be printed on the screen. Since <code class="literal">length</code> gets assigned the value <code class="literal">0xffffffff</code> and this value is much bigger than 12, it may seem obvious that the string will not be printed. However, let’s see what happens if we compile and run the program under Windows Vista SP2:<a id="IDX-APP-A-0051" class="indexterm"/><a id="IDX-APP-A-0052" class="indexterm"/></p><a id="I_programlisting_d1e10118"/><pre class="programlisting">C:\Users\tk\BHD&gt;<strong class="userinput"><code>cl /nologo implicit.c</code></strong>
implicit.c

C:\Users\tk\BHD&gt;<strong class="userinput"><code>implicit.exe</code></strong>
length: −1 4294967295 (0xffffffff)
argument length ok</pre><p>As you can see from the output, line 19 was reached and executed. How did this happen?</p><p>On a 32-bit machine, an unsigned int has a range of 0 to 4294967295 and a signed int has a range of –2147483648 to 2147483647. The unsigned int value <code class="literal">0xffffffff</code> (4294967295) is represented in binary as <code class="literal">1111 1111 1111 1111 1111 1111 1111 1111</code> (see <a class="xref" href="apas03.html#the_role_of_the_most_significant_bit_ope" title="Figure A-3. The role of the Most Significant Bit (MSB)">Figure A-3</a>). If you interpret the same bit pattern as a signed int, there is a change in sign that results in a signed int value of −1. The sign of a number is indicated by the <span class="emphasis"><em>sign bit</em></span>, which is usually represented by the <span class="emphasis"><em>Most Significant Bit (MSB)</em></span>. If the MSB is 0, the number is positive, and if it is set to 1, the number is negative.<a id="IDX-APP-A-0053" class="indexterm"/><a id="IDX-APP-A-0054" class="indexterm"/></p><div class="figure"><a id="the_role_of_the_most_significant_bit_ope"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e10154"/><img src="httpatomoreillycomsourcenostarchimages939341.png.jpg" alt="The role of the Most Significant Bit (MSB)"/></div></div><p class="title">Figure A-3. The role of the Most Significant Bit (MSB)</p></div><p>To summarize: If an unsigned int is converted to a signed int value, the bit pattern isn’t changed, but the value is interpreted in the context of the new type. If the unsigned int value is in the range <code class="literal">0x80000000</code> to <code class="literal">0xffffffff</code>, the resulting signed int will become negative (see <a class="xref" href="apas03.html#integer_type_conversion_colon_unsigned_i" title="Figure A-4. Integer type conversion: unsigned int to signed int">Figure A-4</a>).</p><p>This was only a brief introduction to implicit and explicit type conversions in C/C++. For a complete description of type conversions in C/C++ and associated security problems, see Mark Dowd, John McDonald, and Justin Schuh’s <span class="emphasis"><em>The Art of Software Security Assessment: Identifying and Avoiding Software Vulnerabilities</em></span> (Addison-Wesley, 2007).<a id="IDX-APP-A-0055" class="indexterm"/><a id="IDX-APP-A-0056" class="indexterm"/></p><div class="figure"><a id="integer_type_conversion_colon_unsigned_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e10183"/><img src="httpatomoreillycomsourcenostarchimages939343.png.jpg" alt="Integer type conversion: unsigned int to signed int"/></div></div><p class="title">Figure A-4. Integer type conversion: unsigned int to signed int</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used Debian Linux 6.0 (32-bit) as a platform for all the following steps</em></span>.<a id="IDX-APP-A-0057" class="indexterm"/><a id="IDX-APP-A-0058" class="indexterm"/></p></div></div>
<div class="sect1" title="A.4 GOT Overwrites"><div class="titlepage"><div><div><h1 class="title"><a id="a.4_got_overwrites"/>A.4 GOT Overwrites</h1></div></div></div><p>Once you have found a memory corruption vulnerability, you can use a variety of techniques to gain control over the instruction pointer register of the vulnerable process. One of these techniques, called <span class="emphasis"><em>GOT overwrite</em></span>, works by manipulating an entry in the so-called <span class="emphasis"><em>Global Offset Table (GOT)</em></span> of an <span class="emphasis"><em>Executable and Linkable Format (ELF)</em></span><sup>[<a href="apas04.html#ftn.APP-A-FN-1" class="footnoteref">90</a>]</sup> object to gain control over the instruction pointer. Since this technique relies on the ELF file format, it works only on platforms supporting this format (such as Linux, Solaris, or BSD).<a id="IDX-APP-A-0059" class="indexterm"/><a id="IDX-APP-A-0060" class="indexterm"/><a id="IDX-APP-A-0061" class="indexterm"/><a id="IDX-APP-A-0062" class="indexterm"/></p><p>The GOT is located in an ELF-internal data section called <code class="literal">.got</code>. Its purpose is to redirect position-independent address calculations to an absolute location, so it stores the absolute location of function-call symbols used in dynamically linked code. When a program calls a library function for the first time, the <span class="emphasis"><em>runtime link editor</em></span> (<code class="literal">rtld</code>) locates the appropriate symbol and relocates it to the GOT. Every new call to that function passes the control directly to that location, so <code class="literal">rtld</code> isn’t called for that function anymore. <a class="xref" href="apas04.html#example_code_used_to_demonstrate_the" title="Example A-4. Example code used to demonstrate the function of the Global Offset Table (got.c)">Example A-4</a> illustrates this process.</p><div class="example"><a id="example_code_used_to_demonstrate_the"/><p class="title">Example A-4. Example code used to demonstrate the function of the Global Offset Table (<span class="emphasis"><em>got.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    int
04    main (void)
05    {
06        int  i = 16;
07
08        printf ("%d\n", i);
09        printf ("%x\n", i);
10
11        return 0;
12    }</pre></div></div><p>The program in <a class="xref" href="apas04.html#example_code_used_to_demonstrate_the" title="Example A-4. Example code used to demonstrate the function of the Global Offset Table (got.c)">Example A-4</a> calls the <code class="literal">printf()</code> library function two times. I compiled the program with debugging symbols and started it in the debugger (see Section B.4 for a description of the following debugger commands):<a id="IDX-APP-A-0063" class="indexterm"/></p><a id="I_programlisting_d1e10263"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -g -o got got.c</code></strong>

linux$ <strong class="userinput"><code>gdb -q ./got</code></strong>

(gdb) <strong class="userinput"><code>set disassembly-flavor intel</code></strong>

(gdb) <strong class="userinput"><code>disassemble main</code></strong>
Dump of assembler code for function main:
0x080483c4 &lt;main+0&gt;:    push   ebp
0x080483c5 &lt;main+1&gt;:    mov    ebp,esp
0x080483c7 &lt;main+3&gt;:    and    esp,0xfffffff0
0x080483ca &lt;main+6&gt;:    sub    esp,0x20
0x080483cd &lt;main+9&gt;:    mov    DWORD PTR [esp+0x1c],0x10
0x080483d5 &lt;main+17&gt;:   mov    eax,0x80484d0
0x080483da &lt;main+22&gt;:   mov    edx,DWORD PTR [esp+0x1c]
0x080483de &lt;main+26&gt;:   mov    DWORD PTR [esp+0x4],edx
0x080483e2 &lt;main+30&gt;:   mov    DWORD PTR [esp],eax
<strong class="userinput"><code>0x080483e5 &lt;main+33&gt;:   call   0x80482fc &lt;printf@plt&gt;</code></strong>
0x080483ea &lt;main+38&gt;:   mov    eax,0x80484d4
0x080483ef &lt;main+43&gt;:   mov    edx,DWORD PTR [esp+0x1c]
0x080483f3 &lt;main+47&gt;:   mov    DWORD PTR [esp+0x4],edx
0x080483f7 &lt;main+51&gt;:   mov    DWORD PTR [esp],eax
<strong class="userinput"><code>0x080483fa &lt;main+54&gt;:   call   0x80482fc &lt;printf@plt&gt;</code></strong>
0x080483ff &lt;main+59&gt;:   mov    eax,0x0
0x08048404 &lt;main+64&gt;:   leave
0x08048405 &lt;main+65&gt;:   ret
End of assembler dump.</pre><p>The disassembly of the <code class="literal">main()</code> function shows the address of <code class="literal">printf()</code> in the <span class="emphasis"><em>Procedure Linkage Table (PLT)</em></span>. Much as the GOT redirects position-independent address calculations to absolute locations, the PLT redirects position-independent function calls to absolute locations.<a id="IDX-APP-A-0064" class="indexterm"/></p><a id="I_programlisting_d1e10298"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i 0x80482fc</code></strong>
0x80482fc &lt;printf@plt&gt;: jmp    DWORD PTR ds:<strong class="userinput"><code>0x80495d8</code></strong></pre><p>The PLT entry jumps immediately into the GOT:</p><a id="I_programlisting_d1e10307"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1x 0x80495d8</code></strong>
0x80495d8 &lt;_GLOBAL_OFFSET_TABLE_+20&gt;:   <strong class="userinput"><code>0x08048302</code></strong></pre><p>If the library function wasn’t called before, the GOT entry points back into the PLT. In the PLT, a relocation offset gets pushed onto the stack, and execution is redirected to the <code class="literal">_init()</code> function. This is where <code class="literal">rtld</code> gets called to locate the referenced <code class="literal">printf()</code> symbol.<a id="IDX-APP-A-0065" class="indexterm"/></p><a id="I_programlisting_d1e10329"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/2i 0x08048302</code></strong>
0x8048302 &lt;printf@plt+6&gt;:       push   0x10
0x8048307 &lt;printf@plt+11&gt;:      jmp    0x80482cc</pre><p>Now let’s see what happens if <code class="literal">printf()</code> gets called a second time. First, I defined a breakpoint just before the second call to <code class="literal">printf()</code>:</p><a id="I_programlisting_d1e10342"/><pre class="programlisting">(gdb) <strong class="userinput"><code>list 0</code></strong>
1    #include &lt;stdio.h&gt;
2
3    int
4    main (void)
5    {
6        int    i    = 16;
7
8        printf ("%d\n", i);
<strong class="userinput"><code>9        printf ("%x\n", i);</code></strong>
10

(gdb) <strong class="userinput"><code>break 9</code></strong>
Breakpoint 1 at 0x80483ea: file got.c, line 9.</pre><p>I then started the program:</p><a id="I_programlisting_d1e10355"/><pre class="programlisting">(gdb) <strong class="userinput"><code>run</code></strong>
Starting program: /home/tk/BHD/got
16

Breakpoint 1, main () at got.c:9
9        printf ("%x\n", i);</pre><p>After the breakpoint triggered, I disassembled the <code class="literal">main</code> function again to see if the same PLT address was called:</p><a id="I_programlisting_d1e10365"/><pre class="programlisting">(gdb) <strong class="userinput"><code>disassemble main</code></strong>
Dump of assembler code for function main:
0x080483c4 &lt;main+0&gt;:    push   ebp
0x080483c5 &lt;main+1&gt;:    mov    ebp,esp
0x080483c7 &lt;main+3&gt;:    and    esp,0xfffffff0
0x080483ca &lt;main+6&gt;:    sub    esp,0x20
0x080483cd &lt;main+9&gt;:    mov    DWORD PTR [esp+0x1c],0x10
0x080483d5 &lt;main+17&gt;:   mov    eax,0x80484d0
0x080483da &lt;main+22&gt;:   mov    edx,DWORD PTR [esp+0x1c]
0x080483de &lt;main+26&gt;:   mov    DWORD PTR [esp+0x4],edx
0x080483e2 &lt;main+30&gt;:   mov    DWORD PTR [esp],eax
<strong class="userinput"><code>0x080483e5 &lt;main+33&gt;:   call   0x80482fc &lt;printf@plt&gt;</code></strong>
0x080483ea &lt;main+38&gt;:   mov    eax,0x80484d4
0x080483ef &lt;main+43&gt;:   mov    edx,DWORD PTR [esp+0x1c]
0x080483f3 &lt;main+47&gt;:   mov    DWORD PTR [esp+0x4],edx
0x080483f7 &lt;main+51&gt;:   mov    DWORD PTR [esp],eax
<strong class="userinput"><code>0x080483fa &lt;main+54&gt;:   call   0x80482fc &lt;printf@plt&gt;</code></strong>
0x080483ff &lt;main+59&gt;:   mov    eax,0x0
0x08048404 &lt;main+64&gt;:   leave
0x08048405 &lt;main+65&gt;:   ret
End of assembler dump.</pre><p>The same address in the PLT was indeed called:</p><a id="I_programlisting_d1e10378"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i 0x80482fc</code></strong>
0x80482fc &lt;printf@plt&gt;: jmp    DWORD PTR ds:<strong class="userinput"><code>0x80495d8</code></strong></pre><p>The called PLT entry jumps immediately into the GOT again:</p><a id="I_programlisting_d1e10387"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1x 0x80495d8</code></strong>
0x80495d8 &lt;_GLOBAL_OFFSET_TABLE_+20&gt;:   <strong class="userinput"><code>0xb7ed21c0</code></strong></pre><p>But this time, the GOT entry of <code class="literal">printf()</code> has changed: It now points directly to the <code class="literal">printf()</code> library function in <code class="literal">libc</code>.</p><a id="I_programlisting_d1e10406"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/10i 0xb7ed21c0</code></strong>
0xb7ed21c0 &lt;printf&gt;:    push   ebp
0xb7ed21c1 &lt;printf+1&gt;:  mov    ebp,esp
0xb7ed21c3 &lt;printf+3&gt;:  push   ebx
0xb7ed21c4 &lt;printf+4&gt;:  call   0xb7ea1aaf
0xb7ed21c9 &lt;printf+9&gt;:  add    ebx,0xfae2b
0xb7ed21cf &lt;printf+15&gt;: sub    esp,0xc
0xb7ed21d2 &lt;printf+18&gt;: lea    eax,[ebp+0xc]
0xb7ed21d5 &lt;printf+21&gt;: mov    DWORD PTR [esp+0x8],eax
0xb7ed21d9 &lt;printf+25&gt;: mov    eax,DWORD PTR [ebp+0x8]
0xb7ed21dc &lt;printf+28&gt;: mov    DWORD PTR [esp+0x4],eax</pre><p>Now if we change the value of the GOT entry for <code class="literal">printf()</code>, it’s possible to control the execution flow of the program when <code class="literal">printf()</code> is called:</p><a id="I_programlisting_d1e10419"/><pre class="programlisting">(gdb) <strong class="userinput"><code>set variable *(0x80495d8)=0x41414141</code></strong>

(gdb) <strong class="userinput"><code>x/1x 0x80495d8</code></strong>
0x80495d8 &lt;_GLOBAL_OFFSET_TABLE_+20&gt;:   <strong class="userinput"><code>0x41414141</code></strong>

(gdb) <strong class="userinput"><code>continue</code></strong>
Continuing.

Program received signal SIGSEGV, Segmentation fault.
<strong class="userinput"><code>0x41414141 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers eip</code></strong>
eip            <strong class="userinput"><code>0x41414141</code></strong>    0x41414141</pre><p>We have achieved <code class="literal">EIP</code> control. For a real-life example of this exploitation technique, see <a class="xref" href="ch04.html" title="Chapter 4. NULL Pointer FTW">Chapter 4</a>.</p><p>To determine the GOT address of a library function, you can either use the debugger, as in the previous example, or you can use the <code class="literal">objdump</code> or <code class="literal">readelf</code> command:<a id="IDX-APP-A-0066" class="indexterm"/><a id="IDX-APP-A-0067" class="indexterm"/></p><a id="I_programlisting_d1e10464"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R got</code></strong>

got:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080495c0 R_386_GLOB_DAT    __gmon_start__
080495d0 R_386_JUMP_SLOT   __gmon_start__
080495d4 R_386_JUMP_SLOT   __libc_start_main
<strong class="userinput"><code>080495d8 R_386_JUMP_SLOT   printf</code></strong>

linux$ <strong class="userinput"><code>readelf -r got</code></strong>

Relocation section '.rel.dyn' at offset 0x27c contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
080495c0  00000106 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x284 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
080495d0  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__
080495d4  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main
<strong class="userinput"><code>080495d8  00000307 R_386_JUMP_SLOT   00000000   printf</code></strong></pre><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes-id8"/>Notes</h2></div></div></div><p><sup>[<a id="APP-A-FN-1" href="#ftn.APP-A-FN-1" class="footnote">90</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.APP-A-FN-1" href="#APP-A-FN-1" class="para">90</a>] </sup>For a description of ELF, see TIS Committee, <span class="emphasis"><em>Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification</em></span>, Version 1.2, 1995, at <a class="ulink" href="http://refspecs.freestandards.org/elf/elf.pdf">http://refspecs.freestandards.org/elf/elf.pdf</a>.</p></div></div></div></body></html>