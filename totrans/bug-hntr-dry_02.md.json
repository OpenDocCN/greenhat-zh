["```\n[..]\n`41    struct demux_t`\n42    {\n43       VLC_COMMON_MEMBERS\n44\n45       /* Module properties */\n46       module_t    *p_module;\n47\n48       /* eg informative but needed (we can have access+demux) */\n49       char        *psz_access;\n50       char        *psz_demux;\n51       char        *psz_path;\n52\n`53       /* input stream */`\n`54       stream_t    *s;     /* NULL in case of a access+demux in one */`\n[..]\n```", "```\n[..]\n1623    static void parse_master(`demux_t *p_demux`)\n1624    {\n1625        demux_sys_t *p_sys = p_demux->p_sys;\n`1626        uint8_t mst_buf[32];`\n`1627        int i, i_map_size;`\n1628        int64_t i_save_pos = stream_Tell(p_demux->s);\n1629        int64_t i_pts_secs;\n1630\n1631        /* Note that the entries in the SEQ table in the stream may have\n1632           different sizes depending on the bits per entry.  We store them\n1633           all in the same size structure, so we have to parse them out one\n1634           by one.  If we had a dynamic structure, we could simply read the\n1635           entire table directly from the stream into memory in place. */\n1636\n1637        /* clear the SEQ table */\n1638        free(p_sys->seq_table);\n1639\n1640        /* parse header info */\n`1641        stream_Read(p_demux->s, mst_buf, 32);`\n`1642        i_map_size = U32_AT(&mst_buf[20]);  /* size of bitmask, in bytes */`\n1643        p_sys->i_bits_per_seq_entry = i_map_size * 8;\n1644        i = U32_AT(&mst_buf[28]);   /* size of SEQ table, in bytes */\n1645        p_sys->i_seq_table_size = i / (8 + i_map_size);\n1646\n1647        /* parse all the entries */\n1648        p_sys->seq_table = malloc(p_sys->i_\nseq_table_size * sizeof(ty_seq_table_t));\n1649        for (i=0; i<p_sys->i_seq_table_size; i++) {\n`1650             stream_Read(p_demux->s, mst_buf, 8 + i_map_size);`\n[..]\n```", "```\n`$ wget http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b`\n--2008-10-12 21:12:25--  http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b\nResolving samples.mplayerhq.hu... 213.144.138.186\nConnecting to samples.mplayerhq.hu|213.144.138.186|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 5242880 (5.0M) [text/plain]\nSaving to: `test-dtivo-junkskip.ty+'\n\n100%[=========================>] 5,242,880    240K/s   in 22s\n\n2008-10-12 21:12:48 (232 KB/s) - `test-dtivo-junkskip.ty+' saved [5242880/5242880]\n```", "```\n[..]\n`386    static int Demux( demux_t *p_demux )`\n387    {\n388        demux_sys_t  *p_sys = p_demux->p_sys;\n389        ty_rec_hdr_t *p_rec;\n390        block_t      *p_block_in = NULL;\n391\n392        /*msg_Dbg(p_demux, \"ty demux processing\" );*/\n393\n394        /* did we hit EOF earlier? */\n395        if( p_sys->eof )\n396            return 0;\n397\n398        /*\n399         * what we do (1 record now.. maybe more later):\n400         * - use stream_Read() to read the chunk header & record headers\n401         * - discard entire chunk if it is a PART header chunk\n402         * - parse all the headers into record header array\n403         * - keep a pointer of which record we're on\n404         * - use stream_Block() to fetch each record\n405         * - parse out PTS from PES headers\n406         * - set PTS for data packets\n407         * - pass the data on to the proper codec via es_out_Send()\n408\n409         * if this is the first time or\n410         * if we're at the end of this chunk, start a new one\n411         */\n412        /* parse the next chunk's record headers */\n413        if( p_sys->b_first_chunk || p_sys->i_cur_rec >= p_sys->i_num_recs )\n414        {\n`415               if( get_chunk_header(p_demux) == 0 )`\n[..]\n```", "```\n[..]\n `112    #define TIVO_PES_FILEID   ( 0xf5467abd )`\n[..]\n1839    static int get_chunk_header(demux_t *p_demux)\n1840    {\n1841        int i_readSize, i_num_recs;\n1842        uint8_t *p_hdr_buf;\n1843        const uint8_t *p_peek;\n1844        demux_sys_t *p_sys = p_demux->p_sys;\n1845        int i_payload_size;                /* sum of all records' sizes */\n1846\n1847        msg_Dbg(p_demux, \"parsing ty chunk #%d\", p_sys->i_cur_chunk );\n1848\n1849        /* if we have left-over filler space from the last chunk, get that */\n1850        if (p_sys->i_stuff_cnt > 0) {\n1851            stream_Read( p_demux->s, NULL, p_sys->i_stuff_cnt);\n1852            p_sys->i_stuff_cnt = 0;\n1853        }\n1854\n1855        /* read the TY packet header */\n`1856        i_readSize = stream_Peek( p_demux->s, &p_peek, 4 );`\n1857        p_sys->i_cur_chunk++;\n1858\n1859        if ( (i_readSize < 4) || ( U32_AT(&p_peek[ 0 ] ) == 0 ))\n1860        {\n1861            /* EOF */\n1862            p_sys->eof = 1;\n1863            return 0;\n1864        }\n1865\n1866        /* check if it's a PART Header */\n`1867        if( U32_AT( &p_peek[ 0 ] ) == TIVO_PES_FILEID )`\n1868        {\n1869            /* parse master chunk */\n`1870            parse_master(p_demux);`\n1871            return get_chunk_header(p_demux);\n1872        }\n[..]\n```", "```\n[..]\n1641     stream_Read(p_demux->s, mst_buf, 32);\n1642     i_map_size = U32_AT(&mst_buf[`20`]);  /* size of bitmask, in bytes */\n[..]\n```", "```\n--- a/modules/demux/ty.c\n+++ b/modules/demux/ty.c\n@@ −1639,12 +1639,14 @@ static void parse_master(demux_t *p_demux)\n     /* parse all the entries */\n     p_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));\n     for (i=0; i<p_sys->i_seq_table_size; i++) {\n`-        stream_Read(p_demux->s, mst_buf, 8 + i_map_size);`\n`+        stream_Read(p_demux->s, mst_buf, 8);`\n         p_sys->seq_table[i].l_timestamp = U64_AT(&mst_buf[0]);\n         if (i_map_size > 8) {\n             msg_Err(p_demux, \"Unsupported SEQ bitmap size in master chunk\");\n`+            stream_Read(p_demux->s, NULL, i_map_size);`\n             memset(p_sys->seq_table[i].chunk_bitmask, i_map_size, 0);\n         } else {\n`+            stream_Read(p_demux->s, mst_buf + 8, i_map_size);`\n             memcpy(p_sys->seq_table[i].chunk_bitmask, &mst_buf[8], i_map_size);\n         }\n     }\n```", "```\n[..]\n@@ −1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)\n\n {\n     demux_sys_t *p_sys = p_demux->p_sys;\n     uint8_t mst_buf[32];\n`-    int i, i_map_size;`\n`+    uint32_t i, i_map_size;`\n     int64_t i_save_pos = stream_Tell(p_demux->s);\n     int64_t i_pts_secs;\n[..]\n```", "```\nC:\\Windows\\system32>`bcdedit /enum | findstr nx`\nnx                      OptIn\n```", "```\n[..]\nBuilding VLC from the source code\n=================================\n[..]\n- natively on Windows, using cygwin (www.cygwin.com) with or\n without the POSIX emulation layer. This is the preferred way to compile\n vlc if you want to do it on Windows.\n[..]\nUNSUPPORTED METHODS\n-------------------\n[..]\n- natively on Windows, using Microsoft Visual Studio. This will not work.\n[..]\n```"]