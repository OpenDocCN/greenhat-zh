- en: 'That’s right, too. We could go another iteration, but instead, let’s look at
    the last iteration, a place where bugs frequently arise in loops. So, let’s add
    a conditional breakpoint, as follows:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，还可以再迭代一次，但相反，让我们看看最后一次迭代，这是循环中经常出现错误的地方。所以，让我们添加一个条件断点，如下所示：
- en: findruns <- function(x,k) {
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: findruns <- function(x,k) {
- en: n <- length(x)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: runs <- NULL
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- NULL
- en: for (i in 1:(n-k)) {
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n-k)) {
- en: if (all(x[i:(i+k-1)]==1)) runs <- c(runs,i)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: if (all(x[i:(i+k-1)]==1)) runs <- c(runs,i)
- en: 'if (i == n-k) browser() # break in last iteration of loop'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (i == n-k) browser() # 在循环的最后一次迭代中中断'
- en: '}'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(runs)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: return(runs)
- en: '}'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: And now run it again.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行它。
- en: source("findruns.R")
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("findruns.R")
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: 'Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
- en: Browse[1]> i
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 7'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 7'
- en: 'This shows the last iteration was for i = 7\. But the vector is nine elements
    long, and k = 2, so our last iteration should be i = 8\. Some thought then reveals
    that the range in the loop should have been written as follows: for (i in 1:(n-k+1))
    {'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明最后一次迭代是 i = 7。但向量有九个元素长，k = 2，所以我们的最后一次迭代应该是 i = 8。经过一些思考后，我们发现循环中的范围应该写成如下：for
    (i in 1:(n-k+1)) {
- en: By the way, note that the breakpoint that we set using setBreakpoint() is no
    longer valid, now that we’ve replaced the old version of the object findruns.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，请注意，我们现在已经替换了旧的 findruns 对象版本，因此我们使用 setBreakpoint() 设置的断点不再有效。
- en: Subsequent testing (not shown here) indicates the code now works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后续测试（此处未显示）表明代码现在可以正常工作。
- en: Let’s move on to a more complex example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到一个更复杂的例子。
- en: '**13.3.6.2 Debugging Finding City Pairs**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.6.2 调试寻找城市对**'
- en: 'Recall our code in Section 3.4.2, which found the pair of cities with the closest
    distance between them. Here is a buggy version of that code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 3.4.2 节中的代码，该代码找到了距离最近的城市对。以下是该代码的一个有问题的版本：
- en: '1'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: returns the minimum value of d[i,j], i != j, and the row/col attaining 2
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 d[i,j] 的最小值，i != j，以及达到 2 的行/列
- en: that minimum, for square symmetric matrix d; no special policy on
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平方对称矩阵 d 的最小值，没有特殊策略
- en: '3'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: ties;
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ties;
- en: '4'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: motivated by distance matrices
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由距离矩阵激发
- en: Debugging
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**295**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**295**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '5'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mind <- function(d) {
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: mind <- function(d) {
- en: '6'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: n <- nrow(d)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(d)
- en: '7'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: add a column to identify row number for apply()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为 apply() 添加一个列以标识行号
- en: '8'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: dd <- cbind(d,1:n)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: dd <- cbind(d,1:n)
- en: '9'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: wmins <- apply(dd[-n,],1,imin)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n,],1,imin)
- en: '10'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: wmins will be 2xn, 1st row being indices and 2nd being values
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: wmins 将是 2xn，第一行是索引，第二行是值
- en: '11'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: i <- which.min(wmins[1,])
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[1,])
- en: '12'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: j <- wmins[2,i]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[2,i]
- en: '13'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: return(c(d[i,j],i,j))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(d[i,j],i,j))
- en: '14'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '15'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: finds the location, value of the minimum in a row x
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 x 中找到最小值的定位和值
- en: '17'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: imin <- function(x) {
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: imin <- function(x) {
- en: '18'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: n <- length(x)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: '19'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: i <- x[n]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: i <- x[n]
- en: '20'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: j <- which.min(x[(i+1):(n-1)])
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i+1):(n-1)])
- en: '21'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: return(c(j,x[j]))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(j,x[j]))
- en: '22'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s use R’s debugging tools to find and fix the problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 R 的调试工具来查找和修复问题。
- en: 'We’ll run it first on a small test case:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在一个小测试用例上运行它：
- en: source("cities.R")
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("cities.R")
- en: m <- rbind(c(0,12,5),c(12,0,8),c(5,8,0))
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- rbind(c(0,12,5),c(12,0,8),c(5,8,0))
- en: m
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2] [,3]'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '0'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '12'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '5'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[2,]'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '0'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '[3,]'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '5'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '0'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: mind(m)
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: 'Not an auspicious start! Unfortunately, the error message doesn’t tell us where
    the code blew up. But the debugger will give us that information:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是一个吉祥的开始！不幸的是，错误信息没有告诉我们代码在哪里崩溃。但调试器会给我们这个信息：
- en: options(error=recover)
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=recover)
- en: mind(m)
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: Enter a frame number, or 0 to exit
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个帧号，或 0 退出
- en: '1: mind(m)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '1: mind(m)'
- en: 'Selection: 1'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Selection: 1'
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'Called from: eval(expr, envir, enclos)'
- en: Browse[1]> where
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> where
- en: '**296**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**296**'
- en: Chapter 13
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'where 1: eval(expr, envir, enclos)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 1: eval(expr, envir, enclos)'
- en: 'where 2: eval(quote(browser()), envir = sys.frame(which))'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'where 2: eval(quote(browser()), envir = sys.frame(which))'
- en: 'where 3 at cities.R#13: function ()'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'where 3 at cities.R#13: function ()'
- en: '{'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (.isMethodsDispatchOn()) {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: if (.isMethodsDispatchOn()) {
- en: tState <- tracingState(FALSE)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: tState <- tracingState(FALSE)
- en: '...'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Okay, so the problem occurred in mind() rather than imin() and in particular
    at line 13\. It still could be the fault of imin(), but for now, let’s deal with
    the former.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，问题发生在 mind() 而不是 imin() 中，特别是在第 13 行。这仍然可能是 imin() 的错误，但暂时我们先处理前者。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is another way we could have determined that the blowup occurred on
    line 13\.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还有另一种方法可以确定崩溃发生在第13行。*'
- en: '*We would enter the debugger as before but probe the local variables. We could
    reason* *that if the subscript bounds error had occurred at line 9, then the variable
    wmins would* *not have been set, so querying it would give us an error message
    like* Error: object'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们像以前一样进入调试器，但检查局部变量。我们可以推理* *如果下标界限错误发生在第9行，那么变量wmins就不会被设置，所以查询它将给我们一个像这样的错误消息*
    错误：对象'
- en: '''wmins'' not found. *On the other hand, if the blowup occurred on line 13,
    even j* *would have been set.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '''wmins'' not found. *另一方面，如果崩溃发生在第13行，即使j* *也会被设置。*'
- en: 'Since the error occurred with d[i,j], let’s look at those variables: Browse[1]>
    d'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误发生在d[i,j]，让我们看看这些变量：Browse[1]> d
- en: '[,1] [,2] [,3]'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '0'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '12'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '5'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[2,]'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '0'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '[3,]'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '5'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '0'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Browse[1]> i
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 2'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Browse[1]> j
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> j
- en: '[1] 12'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 12'
- en: This is indeed a problem—d only has three columns, yet j, a column
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个问题——d只有三列，而j是一个列
- en: subscript, is 12\.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下标，是12。
- en: 'Let’s look at the variable from which we gleaned j, wmins:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们从中获得j的变量wmins：
- en: Browse[1]> wmins
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> wmins
- en: '[,1] [,2]'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '2'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[2,]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '12'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 'If you recall how the code was designed, column k of wmins is supposed to contain
    information about the minimum value in row k of d. So here wmins is saying that
    in the first row (k = 1) of d,(0,12,5), the minimum value is 12, occurring at
    index 2\. But it should be 5 at index 3\. So, something went wrong with this line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得代码是如何设计的，wmins的列k应该包含关于d的第k行最小值的信息。所以在这里，wmins表示在d的第一行（k = 1）中，(0,12,5)的最小值是12，发生在索引2。但应该是索引3的5。所以，这一行出了问题：
- en: wmins <- apply(dd[-n, ], 1, imin)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n, ], 1, imin)
- en: Debugging
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Debugging
- en: '**297**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**297**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: There are several possibilities here. But since ultimately imin() is called,
    we can check them all from within that function. So, let’s set the debug status
    of imin(), quit the debugger, and rerun the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个可能性。但由于最终imin()被调用，我们可以在该函数内部检查它们。所以，让我们设置imin()的调试状态，退出调试器，并重新运行代码。
- en: Browse[1]> Q
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> Q
- en: debug(imin)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: debug(imin)
- en: mind(m)
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'debugging in: FUN(newX[, i], ...)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在：FUN(newX[, i], ...)
- en: 'debug at cities.R#17: {'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.R#17: {'
- en: n <- length(x)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: i <- x[n]
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: i <- x[n]
- en: j <- which.min(x[(i + 1):(n - 1)])
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i + 1):(n - 1)])
- en: return(c(j, x[j]))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(j, x[j]))
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: So, we’re in imin(). Let’s see if it properly received the first row of dd,
    which should be (0,12,5,1).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在imin()中。让我们看看它是否正确接收了dd的第一行，它应该是(0,12,5,1)。
- en: Browse[4]> x
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[4]> x
- en: '[1] 0 12 5 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 12 5 1'
- en: It’s confirmed. This seems to indicate that the first two arguments to apply()
    were correct and that the problem is instead within imin(), though that remains
    to be seen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 已确认。这似乎表明apply()的第一个两个参数是正确的，问题实际上出在imin()中，尽管这一点还需要进一步确认。
- en: 'Let’s single-step through, occasionally typing confirmational queries: Browse[2]>
    n'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们单步执行，偶尔输入确认查询：Browse[2]> n
- en: 'debug at cities.r#17: n <- length(x)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#17: n <- length(x)'
- en: Browse[2]> n
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#18: i <- x[n]'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#18: i <- x[n]'
- en: Browse[2]> n
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#19: j <- which.min(x[(i + 1):(n - 1)])'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#19: j <- which.min(x[(i + 1):(n - 1)])'
- en: Browse[2]> n
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#20: return(c(j, x[j]))'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#20: return(c(j, x[j]))'
- en: Browse[2]> print(n)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> print(n)
- en: '[1] 4'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4'
- en: Browse[2]> i
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> i
- en: '[1] 1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[2]> j
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> j
- en: '[1] 2'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Recall that we designed our call which.min(x[(i + 1):(n - 1)] to look only at
    the above-diagonal portion of this row. This is because the matrix is symmetric
    and because we don’t want to consider the distance between a city and itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们设计调用which.min(x[(i + 1):(n - 1)])时只查看这一行的上三角部分。这是因为矩阵是对称的，而且我们不希望考虑一个城市与自身的距离。
- en: '**298**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**298**'
- en: Chapter 13
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'But the value j = 2 does not confirm. The minimum value in (0,12,5) is 5, which
    occurs at index 3 of that vector, not index 2\. Thus, the problem is in this line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但j = 2的值没有得到确认。在(0,12,5)中的最小值是5，发生在该向量的索引3，而不是索引2。因此，问题就在这一行：
- en: j <- which.min(x[(i + 1):(n - 1)])
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i + 1):(n - 1)])
- en: What could be wrong?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出了什么问题？
- en: After taking a break, we realize that although the minimum value of (0,12,5)
    occurs at index 3 of that vector, that is *not* what we asked which.min() to find
    for us. Instead, that i + 1 term means we asked for the index of the minimum in
    (12,5), which is 2\.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下后，我们意识到，尽管(0,12,5)的最小值出现在该向量的索引3处，但这**并不是**我们要求which.min()为我们找到的内容。相反，那个i
    + 1项意味着我们要求的是(12,5)中的最小值的索引，即2。
- en: 'We did ask which.min() for the correct information, but we failed to use it
    correctly, because we do want the index of the minimum in (0,12,5). We need to
    adjust the output of which.min() accordingly, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实要求which.min()提供正确的信息，但我们未能正确使用它，因为我们确实想要(0,12,5)中最小值的索引。我们需要相应地调整which.min()的输出，如下所示：
- en: j <- which.min(x[(i+1):(n-1)])
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i+1):(n-1)])
- en: k <- i + j
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: k <- i + j
- en: return(c(k,x[k]))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(k,x[k]))
- en: We make the fix and try again.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行修复并再次尝试。
- en: mind(m)
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: Enter a frame number, or 0 to exit
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个帧号，或0退出
- en: '1: mind(m)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '1: mind(m)'
- en: 'Selection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 选择：
- en: Oh no, *another* bounds error! To see where the blowup occurred this time, we
    issue the where command as before, and we find it was at line 13
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不，**另一个**越界错误！为了看到这次爆炸发生的位置，我们像以前一样发出where命令，我们发现它是在第13行。
- en: again. What about i and j now?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次。现在i和j是什么？
- en: Browse[1]> i
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[1]> j
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> j
- en: '[1] 5'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5'
- en: The value of j is still wrong; it cannot be larger than 3, as we have only three
    columns in this matrix. On the other hand, i is correct. The overall minimum value
    in dd is 5, occurring in row 1, column 3\.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: j的值仍然不正确；它不能大于3，因为在这个矩阵中我们只有三列。另一方面，i是正确的。在dd中的整体最小值是5，出现在第1行第3列。
- en: 'So, let’s check the source of j again, the matrix wmins:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们再次检查j的来源，即矩阵wmins：
- en: Browse[1]> wmins
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> wmins
- en: '[,1] [,2]'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '3'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '3'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '[2,]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '5'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: Debugging
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**299**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**299**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Well, there are the 3 and 5 in column 1, just as should be the case.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，列1中的3和5正如预期的那样。
- en: Remember, column 1 here contains the information for row 1 in d, so wmins is
    saying that the minimum value in row 1 is 5, occurring at index 3 of that row,
    which is correct.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里的列1包含d中第1行的信息，所以wmins表示第1行的最小值是5，出现在该行的索引3处，这是正确的。
- en: After taking another break, though, we realize that while wmins is correct,
    our *use* of it isn’t. We have the rows and columns of that matrix mixed up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，休息一下后，我们意识到，虽然wmins是正确的，但我们的**使用**是不正确的。我们混淆了那个矩阵的行和列。
- en: 'This code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码：
- en: i <- which.min(wmins[1,])
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[1,])
- en: j <- wmins[2,i]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[2,i]
- en: 'should be like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是这样的：
- en: i <- which.min(wmins[2,])
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[2,])
- en: j <- wmins[1,i]
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[1,i]
- en: After making that change and resourcing our file, we try it out.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改并重新加载文件后，我们再次尝试。
- en: mind(m)
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: '[1] 5 1 3'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5 1 3'
- en: This is correct, and subsequent tests with larger matrices worked, too.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的，并且后续对更大矩阵的测试也成功了。
- en: '**13.4 Moving Up in the World: More Convenient Debugging**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.4 在世界上攀升：更方便的调试**'
- en: '**Tools**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具**'
- en: 'As just seen, R’s debugging tools are effective. However, they’re not very
    convenient. Fortunately, there are various tools that make the process easier.
    In approximate chronological order of development, they are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，R的调试工具是有效的。然而，它们并不非常方便。幸运的是，有一些工具可以使这个过程更容易。按照开发的大致时间顺序，它们如下所示：
- en: •
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The debug package by Mark Bravington
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 马克·布拉文顿的debug包
- en: •
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: My edtdbg package, which works with the Vim and Emacs text editors
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我的edtdbg包，它与Vim和Emacs文本编辑器一起工作
- en: •
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Vitalie Spinu’s ess-tracebug, which runs under Emacs (with the same goals as
    edtdbg but with more Emacs-specific features)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 维塔利·斯皮努的ess-tracebug，它在Emacs下运行（与edtdbg有相同的目标，但具有更多Emacs特定功能）
- en: •
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: REvolution Analytics’ Integrated Development Environment (IDE)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: REvolution Analytics的集成开发环境（IDE）
- en: '**NOTE**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of this writing (July 2011), work is in progress by the teams that develop
    the* *StatET and RStudio IDEs to add debugging tools.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至本文撰写时（2011年7月），开发StatET和RStudio IDE的团队正在进行添加调试工具的工作。*'
- en: All of these tools are cross-platform, working on Linux, Windows, and Mac systems,
    with the exception of the REvolution Analytics product. That IDE is available
    only on Windows systems with Microsoft Visual Studio. All of the tools are open
    source or free, again with the exception of the REvolution Analytics product.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都是跨平台的，可以在Linux、Windows和Mac系统上运行，但REvolution Analytics产品除外。该IDE仅适用于带有Microsoft
    Visual Studio的Windows系统。所有这些工具都是开源的或免费的，但REvolution Analytics产品除外。
- en: So, what do these packages have to offer? To me, one of the biggest problems
    with R’s built-in debugging tools is the lack of a window that shows the big picture—a
    window displaying your R code with a cursor that moves **300**
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些包有什么可以提供的呢？对我来说，R内置调试工具的最大问题之一是缺少一个显示整体情况的窗口——一个显示您的R代码并带有移动光标的窗口——**300**
- en: Chapter 13
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 39](index-327_1.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image 39](index-327_1.png)'
- en: '![Image 40](index-327_2.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Image 40](index-327_2.png)'
- en: 'through the code as you single-step through it. For example, consider this
    excerpt from our previous browser output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单步执行代码时，代码会显示出来。例如，考虑以下我们之前浏览器输出的摘录：
- en: Browse[2]> n
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2] > n
- en: 'debug at cities.r#17: n <- length(x)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '在cities.r#17: n <- length(x)'
- en: Browse[2]> n
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2] > n
- en: 'debug at cities.r#18: i <- x[n]'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '在cities.r#18: i <- x[n]'
- en: This is nice, but where are these lines in our code? Most GUI debuggers for
    other languages feature a window showing the user’s source code, with a symbol
    indicating the next line to be executed. All of the R tools listed at the start
    of this section remedy this lack in core R. The Bravington debug package creates
    a separate window for exactly this purpose. The other tools have your text editor
    double as that window, thus saving space on your screen compared to using debug.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但这些行在我们的代码中的位置在哪里？其他语言的多数GUI调试器都有一个显示用户源代码的窗口，其中有一个符号指示下一个要执行的行。本节开头列出的所有R工具都弥补了R核心中的这一不足。Bravington调试包创建了一个专门用于此目的的单独窗口。其他工具让您的文本编辑器充当那个窗口，从而与使用debug相比节省了屏幕空间。
- en: 'In addition, these tools allow you to set breakpoints and handle other debugging
    operations without moving your screen’s cursor from the editor window to your
    R execution window. This is convenient and saves typing as well, greatly enhancing
    your ability to concentrate on the real task at hand: finding your bugs.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些工具还允许您设置断点并处理其他调试操作，而无需将屏幕光标从编辑器窗口移到R执行窗口。这既方便又节省了输入，大大提高了您专注于手头真正任务的效率：找到您的错误。
- en: Let’s consider the cities example again. I opened the GVim text editor on my
    source file in conjunction with edtdbg, did some startup for edtdbg, and then
    hit the [ (left bracket) key twice to single-step twice through the code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑城市示例。我在GVim文本编辑器中打开了我的源文件，并配合edtdbg使用，为edtdbg进行了一些启动操作，然后按了两次[（左括号）键来单步通过代码。
- en: The resulting GVim window is shown in Figure 13-1\.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的GVim窗口如图13-1所示。
- en: '*Figure 13-1: Source window in edtdbg*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：edtdbg中的源代码窗口*'
- en: Debugging
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**301**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**301**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Operation of edtdbg for Emacs is the same as shown here, just with different
    keystrokes* *used for the commands. For instance, F8 is used for single-stepping
    instead of [.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*edtdbg在Emacs中的操作与这里显示的相同，只是用于命令的快捷键不同。例如，F8用于单步执行而不是[。*'
- en: 'First, note that the editor’s cursor is now on this line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意编辑器的光标现在在这一行：
- en: wmins <- apply(dd[-n, ], 1, imin)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n, ], 1, imin)
- en: This shows the line to be executed next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了下一个要执行的行。
- en: Whenever I want to single-step a line, I simply hit the [ key while I’m in the
    editor window. The editor then tells the browser to execute its n command, without
    my needing to move the mouse to the R execution window, and then the editor moves
    its cursor to the next line. I can also hit ] for the browser’s c command. Each
    time I execute a line or lines in this manner, the editor’s cursor moves right
    along.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我想要单步执行一行时，我只需在编辑器窗口中按[键。然后编辑器会告诉浏览器执行其n命令，而无需我将鼠标移到R执行窗口，然后编辑器将光标移到下一行。我也可以按]来执行浏览器的c命令。每次我以这种方式执行一行或几行，编辑器的光标就会相应移动。
- en: Whenever I make a change to my source code, typing ,src (the comma
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我对我的源代码进行更改时，输入,src（逗号
- en: is part of the command) into my GVim window will tell R to call source() on
    it. Each time I want to rerun my code, I hit ,dt. I rarely, if ever, need to move
    my mouse away from the editor window to the R window and back.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: （这是命令的一部分）输入到GVim窗口中会告诉R调用source()。每次我想重新运行我的代码时，我都会按,dt。我很少，如果有的话，需要将鼠标从编辑器窗口移到R窗口然后再回来。
- en: In essence, the editor has become my debugger in addition to providing its editing
    operations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，编辑器已经成为了我的调试器，除了提供其编辑操作外。
- en: '**13.5 Ensuring Consistency in Debugging Simulation Code**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.5 确保调试模拟代码的一致性**'
- en: If you’re doing anything with random numbers, you’ll need to be able to reproduce
    the same stream of numbers each time you run your program during the debugging
    session. Without this, your bugs may not be reproducible, making them even harder
    to fix.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The set.seed() function controls this by reinitializing the random number sequence
    to a given value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.8811480 0.2853269 0.5864738'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.4155105 0.4852900 0.6591892'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set.seed(8888)
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: runif(3)
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: set.seed(8888)
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: runif(3)
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The call runif(3) generates three random numbers from the uniform
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: distribution on the interval (0,1). Each time we make that call, we will get
    a different set of three numbers. But with set.seed(), we can start over and get
    the same sequence of numbers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**302**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6 Syntax and Runtime Errors**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The most common syntax errors will be lack of matching parentheses, brackets,
    braces, or quotation marks. When you encounter a syntax
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: error, this is the first thing you should check and double-check. I highly recommend
    that you use a text editor that does parentheses matching and syntax coloring
    for R, such as Vim or Emacs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that often when you get a message saying there is a syntax error on
    a certain line, the error may actually be in a much earlier line.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: This can occur with any language, but R seems especially prone to it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'If it just isn’t obvious to you where your syntax error is, I recommend selectively
    commenting out some of your code, better enabling you to pinpoint the location
    of the syntax problem. Generally, it helps to follow a binary search approach:
    Comment out half of your code (being careful to maintain syntax integrity) and
    see if the same error arises. If it does, it’s in the remaining half; otherwise,
    it’s in the half you deleted. Then cut that half in half, and so on.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'You may sometimes get messages like the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: There were 50 or more warnings (use warnings() to see the first 50) These should
    be heeded—run warnings() as suggested. The problem
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'could range from nonconvergence of an algorithm to misspecification of a matrix
    argument to a function. In many cases, the program output may be invalid, though
    it may well be fine, too, say with this message:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Fitted probabilities numerically 0 or 1 occurred in: glm...'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you may find it useful to issue this command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=2)
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This instructs R to turn warnings into actual errors and makes the locations
    of the warnings easier to find.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**13.7 Running GDB on R Itself**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: This section may be of interest to you even if you are not trying to fix a bug
    in R. For example, you may have written some C code to interface to R (covered
    in Chapter 15) and found it to be buggy. In order to run GDB on that C function,
    you must first run R itself through GDB.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Or, you may be interested in the internals of R, say to determine how you can
    write efficient R code, and wish to explore the internals by stepping through
    the R source code with a debugging tool such as GDB.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**303**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can invoke R through GDB from a shell command line (see Section
    15.1.4), for our purposes here, I suggest using separate windows for R and GDB.
    Here’s the procedure:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Start R in one window, as usual.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: In another window, determine the ID number of your R process. In
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: UNIX family systems, for instance, this is obtained by something like ps -a.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In that second window, submit GDB’s attach command with the R pro-
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: cess number.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Submit the continue command to GDB.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: You can set breakpoints in the R source code either before continuing or by
    interrupting GDB later with CTRL-C. See Section 15.1.4 for details for debugging
    C code called from R. If, on the other hand, you wish to use GDB
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: to explore the R source code, note the following.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The R source code is dominated by S expression pointers (SEXPs),
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: which are pointers to C structs that contain an R variable’s value, type, and
    so on. You can use the R internal function Rf_PrintValue(s) to inspect SEXP
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'values. For example, if the SEXP is named s, then in GDB, type this: call Rf_PrintValue(s)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: This prints the value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**304**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](index-331_1.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: '**14**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**PERFORMANCE ENHANCEMENT:**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEED AND MEMORY**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: In computer science curricula, a common
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: theme is the trade-off between time and
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: space. In order to have a fast-running pro-
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: gram, you may need to use more memory space.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in order to conserve memory space,
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: you might need to settle for slower code. In the R lan-
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: guage, this trade-off is of particular interest for the fol-
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'lowing reasons:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: R is an interpreted language. Many of the commands are written in C
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: and thus do run in fast machine code. But other commands, and your
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: own R code, are pure R and thus interpreted. So, there is a risk that your R
    application may run more slowly than you would like.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: All objects in an R session are stored in memory. More precisely, all objects
    are stored in R’s memory address space. R places a limit of 231 *−* 1 bytes on
    the size of any object, even on 64-bit machines and even if you have a lot of
    RAM. Yet some applications do encounter
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: larger objects.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will suggest ways that you can enhance the performance of your
    R code, taking into account the time/space trade-off.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1 Writing Fast R Code**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'What can be done to make R code faster? Here are the main tools available to
    you:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Optimize your R code through vectorization, use of byte-code compilation, and
    other approaches.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Write the key, CPU-intensive parts of your code in a compiled language such
    as C/C++.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Write your code in some form of parallel R.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The first approach will be covered in this chapter, and the other approaches
    are covered in Chapters 15 and 16\.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: To optimize your R code, you need to understand R’s functional pro-
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: gramming nature and the way R uses memory.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2 The Dreaded for Loop**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The r-help discussion listserv for R often has questions about how to accomplish
    various tasks without for loops. There seems to be a feeling that programmers
    should avoid these loops at all costs.1 Those who pose the queries usually have
    the goal of speeding up their code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that simply rewriting code to avoid loops will
    not necessarily make the code faster. However, in some cases, dramatic speedup
    may be attained, usually through vectorization.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '***14.2.1 Vectorization for Speedup***'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you can use vectorization instead of looping. For example, if x
    and y are vectors of equal lengths, you can write this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: z <- x + y
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not only more compact, but even more important, it is faster than using
    this loop:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a quick timing comparison:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: x <- runif(1000000)
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- runif(1000000)
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1 By contrast, while loops pose much more of a challenge, because they are difficult
    to vectorize effectively.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '**306**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: z <- vector(length=1000000)
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z <- x + y)
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '0.052'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '0.016'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '0.068'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: system.time(for (i in 1:length(x)) z[i] <- x[i] + y[i])
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '8.088'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '0.044'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '8.175'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: What a difference! The version without a loop was more than 120 times faster
    in elapsed time. While timings may vary from one run to another (a second run
    of the loop version had elapsed time of 22.958), in some cases,
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: “delooping” R code can really pay off.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth discussing some of the sources of slowdown in the loop version.
    What may not be obvious to programmers coming to R from other languages is that
    numerous function calls are involved in the loop version of the previous code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Though syntactically the loop looks innocuous, for() is, in fact, a function.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon : looks even more innocuous, but it’s a function too. For instance,
    1:10 is actually the : function called on the arguments 1'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'and 10:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '":"(1,10)'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 3 4 5 6 7 8 9 10'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Each vector subscript operation represents a function call, with calls to [
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: for the two reads and to [<- in the case of the write.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Function calls can be time-consuming, as they involve setting up stack frames
    and the like. Suffering that time penalty at every iteration of the loop adds
    up to a big slowdown.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, if we were to write this in C, there would be no function calls.
    Indeed, that is essentially what happens in our first code snippet. There are
    function calls there as well, namely a call to + and one to - *>* , but each is
    called only once, not 1,000,000 times, as in the loop version. Thus, the first
    version of the code is much faster.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'One type of vectorization is *vector filtering* For instance, let’s rewrite
    our function oddcount() from Section 1.3:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化的一种类型是*向量过滤*。例如，让我们重写第1.3节中的oddcount()函数：
- en: oddcount <- function(x) return(sum(x%%2==1))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: oddcount <- function(x) return(sum(x%%2==1))
- en: There is no explicit loop here, and even though R will internally loop through
    the array, this will be done in native machine code. Again, the anticipated speedup
    does occur.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显式循环，尽管R会内部遍历数组，但这将在本地机器码中完成。再次强调，预期的加速确实发生了。
- en: x <- sample(1:1000000,100000,replace=T)
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- sample(1:1000000,100000,replace=T)
- en: system.time(oddcount(x))
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(oddcount(x))
- en: user system elapsed
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**307**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**307**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '0.012'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '0.012'
- en: '0.000'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.015'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '0.015'
- en: system.time(
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(
- en: +
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: +
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: c <- 0
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c <- 0
- en: +
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: for (i in 1:length(x))
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(x))
- en: +
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: if (x[i] %% 2 == 1) c <- c+1
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: if (x[i] %% 2 == 1) c <- c+1
- en: +
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: return(c)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: return(c)
- en: +
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '}'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: + )
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: + )
- en: user system elapsed
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.308'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '0.308'
- en: '0.000'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.310'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '0.310'
- en: You might wonder whether it matters in this case, since even the loop version
    of the code took less than a second to run. But if this code had been part of
    an enclosing loop, with many iterations, the difference could be important indeed.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在这种情况下这是否有关系，因为即使循环版本的代码运行时间也少于1秒。但如果这段代码是包含在嵌套循环中的，并且有很多迭代，那么差异确实可能很重要。
- en: Examples of other vectorized functions that may speed up your code
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 可能加快你代码速度的其他向量化函数示例
- en: are ifelse(), which(), where(), any(), all(), cumsum(), and cumprod(). In the
    matrix case, you can use rowSums(), colSums(), and so on. In “all possible combinations”
    types of settings, combin(), outer(), lower.tri(), upper.tri(), or expand.grid()
    may be just what you need.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是ifelse(), which(), where(), any(), all(), cumsum(), 和 cumprod()。在矩阵情况下，你可以使用rowSums(),
    colSums()等等。在“所有可能的组合”类型的设置中，combin(), outer(), lower.tri(), upper.tri(), 或 expand.grid()可能正是你所需要的。
- en: Though apply() eliminates an explicit loop, it is actually implemented in R
    rather than C and thus will usually not speed up your code. However, the other
    apply functions, such as lapply(), can be very helpful in speeding up your code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然apply()消除了显式循环，但实际上它在R中而不是在C中实现，因此通常不会加快你的代码速度。然而，其他apply函数，如lapply()，可以在加快你的代码速度方面非常有帮助。
- en: '***14.2.2 Extended Example: Achieving Better Speed in a Monte Carlo***'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.2.2 扩展示例：在蒙特卡洛中实现更好的速度***'
- en: '***Simulation***'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '***模拟***'
- en: In some applications, simulation code can run for hours, days, or even months,
    so speedup methods are of high interest. Here, we’ll look at two simulation examples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，模拟代码可能需要运行数小时、数天，甚至数月，因此加速方法是高度感兴趣的。在这里，我们将查看两个模拟示例。
- en: 'To begin, let’s consider the following code from Section 8.6:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑第8.6节中的以下代码：
- en: sum <- 0
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- 0
- en: nreps <- 100000
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: nreps <- 100000
- en: for (i in 1:nreps) {
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nreps) {
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 'xy <- rnorm(2) # 生成2个N(0,1)的随机数'
- en: sum <- sum + max(xy)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- sum + max(xy)
- en: '}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: print(sum/nreps)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: print(sum/nreps)
- en: 'Here’s a revision (hopefully faster):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个修订版（希望更快）：
- en: nreps <- 100000
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: nreps <- 100000
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: xymat <- matrix(rnorm(2*nreps),ncol=2)
- en: '**308**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**308**'
- en: Chapter 14
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: maxs <- pmax(xymat[,1],xymat[,2])
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: maxs <- pmax(xymat[,1],xymat[,2])
- en: print(mean(maxs))
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: print(mean(maxs))
- en: 'In this code, we generate all the random variates at once, storing them in
    a matrix xymat, with one (X,Y) pair per row:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们一次性生成所有随机变量，并将它们存储在矩阵xymat中，每行一个(X,Y)对：
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: xymat <- matrix(rnorm(2*nreps),ncol=2)
- en: Next, we find all the max(X,Y) values, storing those values in maxs, and then
    simply call mean().
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们找到所有max(X,Y)的值，将这些值存储在maxs中，然后简单地调用mean()。
- en: It’s easier to program, and we believe it will be faster. Let’s check that.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易编程，我们相信它将更快。让我们检查一下。
- en: I had the original code in the file *MaxNorm.R* and the improved version in
    *MaxNorm2.R*.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我在文件*MaxNorm.R*中有原始代码，在*MaxNorm2.R*中有改进版本。
- en: system.time(source("MaxNorm.R"))
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(source("MaxNorm.R"))
- en: '[1] 0.5667599'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5667599'
- en: user system elapsed
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '1.700'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '1.700'
- en: '0.004'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '1.722'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '1.722'
- en: system.time(source("MaxNorm2.R"))
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(source("MaxNorm2.R"))
- en: '[1] 0.5649281'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5649281'
- en: user system elapsed
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.132'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '0.132'
- en: '0.008'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '0.008'
- en: '0.143'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '0.143'
- en: The speedup is dramatic, once again.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 速度提升再次非常显著。
- en: '**NOTE**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We achieved an increase in speed, at the expense of using more memory, by
    keeping our* *random numbers in an array instead of generating and discarding
    them one pair at a* *time. As mentioned earlier, the time/space trade-off is a
    common one in the computing* *world and in the R world in particular.*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们通过将随机数保存在数组中而不是一次生成和丢弃它们来提高速度，但代价是使用更多的内存。如前所述，时间/空间权衡在计算领域以及 R 世界的特定领域是常见的。*'
- en: We attained an excellent speedup in this example, but it was misleadingly easy.
    Let’s look at a slightly more complicated example.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取得了非常好的加速效果，但这是误导性的简单。让我们看看一个稍微复杂一点的例子。
- en: Our next example is a classic exercise from elementary probability
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的例子是初等概率中的一个经典练习
- en: courses. Urn 1 contains ten blue marbles and eight yellow ones. In urn 2, the
    mixture is six blue and six yellow. We draw a marble at random from urn 1, transfer
    it to urn 2, and then draw a marble at random from urn 2\.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉 1 中有十个蓝色弹珠和八个黄色弹珠。在抽屉 2 中，混合物是六个蓝色和六个黄色。我们随机从抽屉 1 中抽取一个弹珠，将其转移到抽屉 2，然后从抽屉
    2 中随机抽取一个弹珠。
- en: 'What is the probability that that second marble is blue? This is easy to find
    analytically, but we’ll use simulation. Here is the straightforward way: 1'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个弹珠是蓝色的概率是多少？这可以通过解析方法轻松找到，但我们将使用模拟。以下是直接的方法：1
- en: perform nreps repetitions of the marble experiment, to estimate
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行 nreps 次弹珠实验，以估计
- en: '2'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: P(pick blue from Urn 2)
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P(从抽屉 2 中抽取蓝色)
- en: '3'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: sim1 <- function(nreps) {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: sim1 <- function(nreps) {
- en: '4'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'nb1 <- 10 # 10 blue marbles in Urn 1'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'nb1 <- 10 # 抽屉 1 中有 10 个蓝色弹珠'
- en: '5'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'n1 <- 18 # number of marbles in Urn 1 at 1st pick'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'n1 <- 18 # 第一次抽取时抽屉 1 中的弹珠数量'
- en: '6'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'n2 <- 13 # number of marbles in Urn 2 at 2nd pick'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'n2 <- 13 # 第二次抽取时抽屉 2 中的弹珠数量'
- en: '7'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: 'count <- 0 # number of repetitions in which get blue from Urn 2'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 'count <- 0 # 从抽屉 2 中获得蓝色的重复次数'
- en: '8'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: for (i in 1:nreps) {
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nreps) {
- en: '9'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'nb2 <- 6 # 6 blue marbles orig. in Urn 2'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'nb2 <- 6 # 抽屉 2 中原本有 6 个蓝色弹珠'
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**309**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**309**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '10'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: pick from Urn 1 and put in Urn 2; is it blue?
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 1 中抽取并放入抽屉 2；它是蓝色的吗？
- en: '11'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: if (runif(1) < nb1/n1) nb2 <- nb2 + 1
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: if (runif(1) < nb1/n1) nb2 <- nb2 + 1
- en: '12'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: pick from Urn 2; is it blue?
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 2 中抽取；它是蓝色的吗？
- en: '13'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: if (runif(1) < nb2/n2) count <- count + 1
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: if (runif(1) < nb2/n2) count <- count + 1
- en: '14'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '15'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: 'return(count/nreps) # est. P(pick blue from Urn 2)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'return(count/nreps) # 估计 P(从抽屉 2 中抽取蓝色)'
- en: '16'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Here is how we can do it without loops, using apply():'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在不使用循环的情况下使用 apply() 来完成它的：
- en: '1'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sim2 <- function(nreps) {
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: sim2 <- function(nreps) {
- en: '2'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: nb1 <- 10
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: nb1 <- 10
- en: '3'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nb2 <- 6
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: nb2 <- 6
- en: '4'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n1 <- 18
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: n1 <- 18
- en: '5'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: n2 <- 13
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: n2 <- 13
- en: '6'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: pre-generate all our random numbers, one row per repetition
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预先生成所有随机数，每重复一次一行
- en: '7'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
- en: '8'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: define simfun for use in apply(); simulates one repetition
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 apply() 定义 simfun；模拟一次重复
- en: '9'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: simfun <- function(rw) {
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: simfun <- function(rw) {
- en: '10'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: rw ("row") is a pair of random numbers
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rw ("行") 是一对随机数
- en: '11'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: choose from Urn 1
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 1 中选择
- en: '12'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: if (rw[1] < nb1/n1) nb2 <- nb2 + 1
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: if (rw[1] < nb1/n1) nb2 <- nb2 + 1
- en: '13'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: choose from Urn 2, and return boolean on choosing blue
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 2 中选择，并返回选择蓝色时的布尔值
- en: '14'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: return (rw[2] < nb2/n2)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: return (rw[2] < nb2/n2)
- en: '15'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '}'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '16'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: z <- apply(u,1,simfun)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: z <- apply(u,1,simfun)
- en: '17'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: z is a vector of booleans but they can be treated as 1s, 0s
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: z 是一个布尔向量，但它们可以被视为 1s 和 0s
- en: '18'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: return(mean(z))
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(z))
- en: '19'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here, we set up a matrix u with two columns of U(0,1) random variates.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置一个矩阵 u，包含两列 U(0,1) 随机变量。
- en: The first column is used for our simulation of drawing from urn 1, and the second
    for drawing from urn 2\. This way, we generate all our random numbers at once,
    which might save a bit of time, but the main point is to set up for using apply().
    Toward that goal, our function simfun() works on one repetition of the experiment—that
    is, one row of u. We set up the call to apply() to go through all of the nreps
    repetitions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列用于我们对抽屉 1 的模拟，第二列用于从抽屉 2 中抽取。这样，我们一次生成所有随机数，这可能节省一点时间，但主要目的是为使用 apply() 准备。为了达到这个目标，我们的
    simfun() 函数在一个实验重复中工作——即 u 的一行。我们设置 apply() 的调用以遍历所有的 nreps 重复。
- en: Note that since the function simfun() is declared within sim2(), the locals
    of sim2()—n1, n2, nb1, and nb2—are available as globals of simfun(). Also, since
    a Boolean vector will automatically be changed by R to 1s and 0s, we can find
    the fraction of TRUE values in the vector by simply calling mean().
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于simfun()函数是在sim2()内部声明的，所以sim2()的局部变量n1、n2、nb1和nb2可以作为simfun()的全局变量使用。此外，由于布尔向量将被R自动转换为1s和0s，我们可以通过简单地调用mean()来找到向量中TRUE值的比例。
- en: Now, let’s compare performance.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较性能。
- en: system.time(print(sim1(100000)))
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim1(100000)))
- en: '[1] 0.5086'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5086'
- en: user system elapsed
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '2.465'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '2.465'
- en: '0.028'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '0.028'
- en: '2.586'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '2.586'
- en: system.time(print(sim2(10000)))
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim2(10000)))
- en: '**310**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**310**'
- en: Chapter 14
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[1] 0.5031'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5031'
- en: user system elapsed
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '2.936'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '2.936'
- en: '0.004'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '3.027'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '3.027'
- en: In spite of the many benefits of functional programming, this approach using
    apply() didn’t help. Instead, things got worse. Since this could be simply due
    to random sampling variation, I ran the code several times again, with similar
    results.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数式编程有许多好处，但使用apply()的方法并没有帮助。相反，情况变得更糟。这可能是由于随机抽样变异的简单原因，所以我再次运行了代码，结果相似。
- en: So, let’s look at vectorizing this simulation.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何将这个模拟向量化。
- en: '1'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sim3 <- function(nreps) {
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: sim3 <- function(nreps) {
- en: '2'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: nb1 <- 10
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: nb1 <- 10
- en: '3'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nb2 <- 6
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: nb2 <- 6
- en: '4'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n1 <- 18
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: n1 <- 18
- en: '5'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: n2 <- 13
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: n2 <- 13
- en: '6'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
- en: '7'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: set up the condition vector
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置条件向量
- en: '8'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
- en: '9'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: u[,1] > nb1/n1 & u[,2] <= nb2/n2
- en: '10'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: return(mean(cndtn))
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 返回cndtn的平均值
- en: '11'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The main work is done in this statement:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作在这条语句中完成：
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: u[,1] > nb1/n1 & u[,2] <= nb2/n2
- en: To get that, we reasoned out which conditions would lead to choosing a blue
    marble on the second pick, coded them, and then assigned them to cndtn.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个结果，我们推理出哪些条件会导致在第二次选择时选择蓝色弹珠，将它们编码，然后将它们分配给cndtn。
- en: 'Remember that *<* = and & are functions; in fact, they are vector functions,
    so they should be fast. Sure enough, this brings quite an improvement:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*<* = 和 & 是函数；实际上，它们是向量函数，所以它们应该很快。确实，这带来了相当大的改进：
- en: system.time(print(sim3(10000)))
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim3(10000)))
- en: '[1] 0.4987'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.4987'
- en: user system elapsed
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.060'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '0.060'
- en: '0.016'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '0.076'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '0.076'
- en: In principle, the approach we took to speed up the code here could be applied
    to many other Monte Carlo simulations. However, it’s clear that the analog of
    the statement that computes cndtn would quickly become quite complex, even for
    seemingly simple applications.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，我们用来加速代码的方法可以应用于许多其他蒙特卡洛模拟。然而，很明显，计算cndtn的语句的类似物会迅速变得相当复杂，即使对于看似简单的应用也是如此。
- en: Moreover, the approach would not work in “infinite-stage” situations, meaning
    an unlimited number of time steps. Here, we are considering the marble example
    as being two-stage, with two columns to the matrix u.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法在“无限阶段”情况下不会起作用，这意味着无限的时间步数。在这里，我们将弹珠示例视为两阶段，矩阵u有两列。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**311**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**311**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***14.2.3 Extended Example: Generating a Powers Matrix***'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.2.3 扩展示例：生成幂矩阵***'
- en: 'Recall in Section 9.1.7, we needed to generate a matrix of powers of our predictor
    variable. We used the following code:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第9.1.7节，我们需要生成预测变量的幂矩阵。我们使用了以下代码：
- en: '1'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过度dg形成向量x的幂矩阵
- en: '2'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: powers1 <- function(x,dg) {
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: powers1 <- function(x,dg) {
- en: '3'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(x,nrow=length(x))
- en: '4'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'prod <- x # current product'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 'prod <- x # 当前乘积'
- en: '5'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: for (i in 2:dg) {
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '6'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: prod <- prod * x
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '7'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: pw <- cbind(pw,prod)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- cbind(pw,prod)
- en: '8'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '}'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '9'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: return(pw)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: return(pw)
- en: '10'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: One glaring problem is that cbind() is used to build up the output matrix, column
    by column. This is very costly in terms of memory-allocation time. It’s much better
    to allocate the full matrix at the beginning, even though it will be empty, as
    this will mean incurring the cost of only one memory-allocation operation.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是，cbind()被用来按列构建输出矩阵。这在内存分配时间上代价很高。最好一开始就分配整个矩阵，即使它是空的，因为这将意味着只需承担一次内存分配操作的代价。
- en: '1'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过度dg形成向量x的幂矩阵
- en: '2'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: powers2 <- function(x,dg) {
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: powers2 <- function(x,dg) {
- en: '3'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pw <- matrix(nrow=length(x),ncol=dg)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(nrow=length(x),ncol=dg)
- en: '4'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'prod <- x # current product'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 'prod <- x # 当前乘积'
- en: '5'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: pw[,1] <- prod
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: pw[,1] <- prod
- en: '6'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: for (i in 2:dg) {
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '7'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: prod <- prod * x
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '8'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: pw[,i] <- prod
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: pw[,i] <- prod
- en: '9'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '}'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '10'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: return(pw)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: return(pw)
- en: '11'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: And indeed, powers2() is a lot faster.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，powers2() 要快得多。
- en: x <- runif(1000000)
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- runif(1000000)
- en: system.time(powers1(x,8))
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers1(x,8))
- en: user system elapsed
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.776'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '0.776'
- en: '0.356'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '0.356'
- en: '1.334'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '1.334'
- en: system.time(powers2(x,8))
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers2(x,8))
- en: user system elapsed
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.388'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '0.388'
- en: '0.204'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '0.204'
- en: '0.593'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '0.593'
- en: '**312**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**312**'
- en: Chapter 14
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: And yet, powers2() still contains a loop. Can we do better? It would seem that
    this setting is perfect for outer(), whose call form is
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，powers2() 仍然包含一个循环。我们能做得更好吗？这似乎是 outer() 的调用形式完美的设置，其调用形式为
- en: outer(X,Y,FUN)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: outer(X,Y,FUN)
- en: This call applies the function FUN() to all possible pairs of elements of X
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将函数 FUN() 应用到 X 的所有可能元素对上
- en: and elements of Y. The default value of FUN is multiplication.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 Y 的元素。FUN 的默认值是乘法。
- en: 'Here, we can write the following:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以写出以下内容：
- en: powers3 <- function(x,dg) return(outer(x,1:dg,"^"))
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: powers3 <- function(x,dg) return(outer(x,1:dg,"^"))
- en: For each combination of element of x and element of 1:dg (resulting in length(x)
    *×* dg combinations in all), outer() calls the exponentiation function
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 x 的每个元素和 1:dg 的每个元素的组合（总共产生 length(x) *×* dg 个组合），outer() 调用指数函数
- en: ^ on that combination, placing the results in a length(x) *×* dg matrix. This
    is exactly what we need, and as a bonus, the code is quite compact. But is the
    code faster?
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: ^ 在那个组合上，将结果放入一个 length(x) *×* dg 矩阵中。这正是我们需要的，而且作为额外的好处，代码相当紧凑。但代码更快吗？
- en: system.time(powers3(x,8))
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers3(x,8))
- en: user system elapsed
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '1.336'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '1.336'
- en: '0.204'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '0.204'
- en: '1.747'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '1.747'
- en: What a disappointment! Here, we’re using a fancy R function, with very compact
    code, but getting the worst performance of the three functions.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 多么令人失望啊！在这里，我们使用了一个花哨的 R 函数，代码非常紧凑，但三个函数中性能最差。
- en: 'And it gets even worse. Here’s what happens if we try to make use of cumprod():'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 而且情况变得更糟。如果我们尝试使用 cumprod()，会发生什么：
- en: powers4
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: powers4
- en: function(x,dg) {
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: function(x,dg) {
- en: repx <- matrix(rep(x,dg),nrow=length(x))
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: repx <- matrix(rep(x,dg),nrow=length(x))
- en: return(t(apply(repx,1,cumprod)))
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: return(t(apply(repx,1,cumprod)))
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: system.time(powers4(x,8))
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers4(x,8))
- en: user system elapsed
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '28.106'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '28.106'
- en: 1.120 83.255
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 1.120 83.255
- en: In this example, we made multiple copies of x, since the powers of a number
    n are simply cumprod(c(1,n,n,n...)). But in spite of dutifully using two C-level
    R functions, the performance was disastrous.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了多个 x 的副本，因为一个数字 n 的幂仅仅是 cumprod(c(1,n,n,n...)) 的累积乘积。但尽管我们尽职尽责地使用了两个
    C 级别的 R 函数，性能仍然非常糟糕。
- en: The moral of the story is that performance issues can be unpredictable.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义在于性能问题可能是不可预测的。
- en: All you can do is be armed with an understanding of the basic issues, vectorization,
    and the memory aspects explained next and then try various approaches.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的就是掌握基本问题、向量化以及接下来解释的内存方面的理解，然后尝试各种方法。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**313**'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**313**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**14.3 Functional Programming and Memory Issues**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.3 函数式编程和内存问题**'
- en: Most R objects are *immutable*, or unchangeable. Thus, R operations are implemented
    as functions that reassign to the given object, a trait that can have performance
    implications.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 R 对象都是 *不可变的*，或者说不可更改的。因此，R 操作是通过将给定对象重新赋值的函数实现的，这种特性可能会对性能产生影响。
- en: '***14.3.1 Vector Assignment Issues***'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.1 向量赋值问题***'
- en: 'As an example of some of the issues that can arise, consider this simple-looking
    statement:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可能出现的一些问题的例子，考虑这个看起来简单的声明：
- en: z[3] <- 8
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: z[3] <- 8
- en: 'As noted in Chapter 7, this assignment is more complex than it seems. It is
    actually implemented via the replacement function "[<-" through this call and
    assignment:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 7 章所述，这个赋值比看起来要复杂。实际上，它是通过这个调用和赋值通过替换函数 "[<-" 实现的：
- en: z <- "[<-"(z,3,value=8)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: z <- "[<-"(z,3,value=8)
- en: An internal copy of z is made, element 3 of the copy is changed to 8, and then
    the resulting vector is reassigned to z. And recall that the latter simply means
    that z is pointed to the copy.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 对 z 的一个内部副本进行了操作，将副本中的第 3 个元素更改为 8，然后将得到的向量重新赋值给 z。记住，后者仅仅意味着 z 指向了副本。
- en: In other words, even though we are ostensibly changing just one element of the
    vector, the semantics say that *the entire vector is recomputed*. For a long vector,
    this would slow down the program considerably. The same would be true for a shorter
    vector if it were assigned from within a loop of our code.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，即使我们表面上只改变向量的一个元素，语义上讲，*整个向量都会被重新计算*。对于长向量，这会显著减慢程序的运行速度。如果是在我们的代码循环中赋值给短向量，情况也会相同。
- en: In some situations, R does take some measures to mitigate this impact, but it
    is a key point to consider when aiming for fast code. You should be mindful of
    this when working with vectors (including arrays). If your code seems to be running
    unexpectedly slowly, assignment of vectors should be a prime area of suspicion.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，R确实采取了一些措施来减轻这种影响，但在追求快速代码时，这是一个需要考虑的关键点。当与向量（包括数组）一起工作时，你应该注意这一点。如果你的代码似乎运行得异常缓慢，向量的赋值应该是一个首要的怀疑对象。
- en: '***14.3.2 Copy-on-Change Issues***'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.2 更改时复制问题***'
- en: 'A related issue is that R (usually) follows a *copy-on-change* policy. For
    instance, if we execute the following in the previous setting:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是，R（通常）遵循*更改时复制*策略。例如，如果我们执行以下操作：
- en: y <- z
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- z
- en: then initially y shares the same memory area with z. But if either of them changes,
    then a copy is made in a different area of memory, and the changed variable will
    occupy the new area of memory. However, only the *first* change is affected, as
    the relocating of the moved variable means there are no longer any sharing issues.
    The function tracemem() will report such memory relocations.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，y与z共享相同的内存区域。但如果有任何一个发生变化，那么就会在内存的不同区域创建一个副本，并且变化后的变量将占用新的内存区域。然而，只有*第一次*变化受到影响，因为移动变量的重新定位意味着不再有任何共享问题。tracemem()函数将报告此类内存重新定位。
- en: '**314**'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**314**'
- en: Chapter 14
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Though R usually adheres to copy-on-change semantics, there are excep-tions.
    For example, R doesn’t exhibit the location-change behavior in the following setting:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管R通常遵循更改时复制的语义，但也有一些例外。例如，R在以下设置中不会显示位置变化的行为：
- en: z <- runif(10)
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- runif(10)
- en: tracemem(z)
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: tracemem(z)
- en: '[1] "<0x88c3258>"'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "<0x88c3258>"'
- en: z[3] <- 8
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z[3] <- 8
- en: tracemem(z)
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: tracemem(z)
- en: '[1] "<0x88c3258>"'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "<0x88c3258>"'
- en: The location of z didn’t change; it was at memory address 0x88c3258
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: z的位置没有变化；它在内存地址0x88c3258
- en: both before and after the assignment to z[3] was executed. Thus, although you
    should be vigilant about location change, you also can’t assume it.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行对z[3]的赋值操作之前和之后。因此，尽管你应该警惕位置变化，但你也不能假设它会发生变化。
- en: Let’s look at the times involved.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涉及的时间。
- en: z <- 1:10000000
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- 1:10000000
- en: system.time(z[3] <- 8)
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z[3] <- 8)
- en: user system elapsed
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.180'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '0.180'
- en: '0.084'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '0.084'
- en: '0.265'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '0.265'
- en: system.time(z[33] <- 88)
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z[33] <- 88)
- en: user system elapsed
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: In any event, if copying is done, the vehicle is R’s internal function duplicate().
    (The function is called duplicate1() in recent versions of R.) If you’re familiar
    with the GDB debugging tool and your R build includes debugging information, you
    can explore the circumstances under which a copy is performed.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果进行了复制，那么工具是R的内部函数duplicate()。（在R的较新版本中，该函数被称为duplicate1()。）如果你熟悉GDB调试工具，并且你的R构建包含调试信息，你可以探索执行复制的环境。
- en: 'Following the guide in Section 15.1.4, start up R with GDB, step through R
    through GDB, and place a breakpoint at duplicate1(). Each time you break at that
    function, submit this GDB command:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第15.1.4节中的指南，使用GDB启动R，通过GDB逐步执行R，并在duplicate1()函数处设置断点。每次在该函数处中断时，提交以下GDB命令：
- en: call Rf_PrintValue(s)
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: call Rf_PrintValue(s)
- en: This will print the value of s (or whatever variable is of interest).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印s（或任何感兴趣的变量）的值。
- en: '***14.3.3 Extended Example: Avoiding Memory Copy***'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.3 扩展示例：避免内存复制***'
- en: This example, though artificial, will demonstrate the memory-copy issues discussed
    in the previous section.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子，尽管是人为的，将演示上一节中讨论的内存复制问题。
- en: Suppose we have a large number of unrelated vectors and, among other things,
    we wish to set the third element of each to 8\. We could store the vectors in
    a matrix, one vector per row. But since they are unrelated, maybe even of different
    lengths, we may consider storing them in a list.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有许多无关的向量，并且我们希望将每个向量的第三个元素设置为8。我们可以将向量存储在一个矩阵中，每行一个向量。但由于它们是无关的，甚至可能长度不同，我们可能考虑将它们存储在一个列表中。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**315**'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '**315**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: But things can get very subtle when it comes to R performance issues, so let’s
    try it out.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: m <- 5000
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n <- 1000
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z <- list()
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(for (i in 1:m) z[[i]][3] <- 8)
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '0.288'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '0.024'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '0.321'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: z <- matrix(sample(1:10,m*n,replace=T),nrow=m)
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z[,3] <- 8)
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '0.008'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '0.044'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '0.052'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Except for system time (again), the matrix formulation did better.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons is that in the list version, we encounter the memory-copy
    problem in each iteration of the loop. But in the matrix version, we encounter
    it only once. And, of course, the matrix version is vectorized.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: But what about using lapply() on the list version?
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: set3 <- function(lv) {
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: lv[3] <- 8
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: return(lv)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: + }
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: z <- list()
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(lapply(z,set3))
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '0.100'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '0.012'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '0.112'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to beat vectorized code.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '**14.4 Using Rprof() to Find Slow Spots in Your Code**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: If you think your R code is running unnecessarily slowly, a handy tool for finding
    the culprit is Rprof(), which gives you a report of (approximately) how much time
    your code is spending in each of the functions it calls. This is important, as
    it may not be wise to optimize *every* section of your program.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: Optimization may come at the expense of coding time and code clarity, so it’s
    of value to know where optimization would really help.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '***14.4.1 Monitoring with Rprof()***'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate using Rprof() with our three versions of code to find a powers
    matrix from the previous extended example. We’ll call Rprof() to get the monitor
    started, run our code, and then call Rprof() with a NULL
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '**316**'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: argument to stop the monitoring. Finally, we’ll call summaryRprof() to see the
    results.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: x <- runif(1000000)
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof()
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers1(x,8))
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '"cbind"'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '"powers1"'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '0.86'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '"powers1"'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '0.86'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '"cbind"'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.86'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: We see immediately that the runtime of our code is dominated by calls to cbind(),
    which as we noted in the extended example is indeed slowing things down.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the call to invisible() in this example is used to suppress output.
    We certainly don’t want to see the 1,000,000-row matrix returned by powers1()
    here!
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: Profiling powers2() does not show any obvious bottlenecks.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Rprof()
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers2(x,8))
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '"powers2"'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '0.38'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '67.9'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '0.56'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '"powers2"'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '0.56'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '0.38'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '67.9'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '**317**'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.56'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: What about powers3(), the promising approach that didn’t pan out?
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Rprof()
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers3(x,8))
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '"outer"'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '0.72'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '43.4'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '"powers3"'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '"outer"'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '0.72'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '43.4'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '"powers3"'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.66'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: The function logging the largest amount of time was FUN(), which as noted in
    our extended example is simply multiplication. For each pair of elements of x
    here, one of the elements is multiplied by the other; that is, a product of two
    scalars is found. In other words, no vectorization! No wonder it was slow.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '***14.4.2 How Rprof() Works***'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore in a bit more detail what Rprof() does. Every 0.02 seconds (the
    default value), R inspects the call stack to determine which function calls are
    in effect at that time. It writes the result of each inspection to a file, by
    default *Rprof.out*. Here is an excerpt of that file from our run of powers3():'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '**318**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: So, Rprof() often found that at inspection time, powers3() had called outer(),
    which in turn had called FUN(), the latter being the currently executing function.
    The function summaryRprof() conveniently summarizes all those lines in the file,
    but you may find that looking at the file itself reveals more insights in some
    cases.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, too, that Rprof() is no panacea. If the code you’re profiling produces
    many function calls (including indirect calls, triggered when your code calls
    some function that then calls another within R), the profiling output may be hard
    to decipher. This is arguably the case for the output from powers4():'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: $by.self
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '"apply"'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '19.46'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '67.5'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '27.56'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '95.6'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '"lapply"'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '4.02'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '13.9'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '5.68'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '19.7'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '"as.vector"'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '"t.default"'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '"unlist"'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: '0.40'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '1.4'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '6.08'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '21.1'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: '"!"'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '"is.null"'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '"aperm"'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '0.5'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '2.6'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: '"!="'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '"powers4"'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '28.84'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: '"t"'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '28.10'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: '97.4'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '"array"'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '"powers4"'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '28.84'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '"t"'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '28.10'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '97.4'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '"apply"'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '27.56'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '95.6'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '19.46'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '67.5'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '"unlist"'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '6.08'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '21.1'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '0.40'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '1.4'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '"lapply"'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '5.68'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '19.7'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '4.02'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '13.9'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '"as.vector"'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '2.6'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '0.5'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '"t.default"'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '"!"'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '"is.null"'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '"aperm"'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '"array"'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '"!="'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 28.84'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '**319**'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**14.5 Byte Code Compilation**'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.5 字节码编译**'
- en: Starting with version 2.13, R has included a *byte code compiler*, which you
    can use to try to speed up your code. Consider our example from Section 14.2.1\.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.13开始，R已经包含了一个*字节码编译器*，你可以用它来尝试加速你的代码。考虑我们第14.2.1节中的例子。
- en: As a trivial example, we showed that
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，我们展示了
- en: z <- x + y
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: z <- x + y
- en: was much faster than
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 比以下代码快得多
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(x)) z[i] <- x[i] + y[i]
- en: 'Again, that was obvious, but just to get an idea of how byte code compilation
    works, let’s give it a try:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是显而易见的，但为了了解字节码编译是如何工作的，让我们试一试：
- en: library(compiler)
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(compiler)
- en: f <- function() for (i in 1:length(x)) z[i] <<- x[i] + y[i]
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f <- function() for (i in 1:length(x)) z[i] <<- x[i] + y[i]
- en: cf <- cmpfun(f)
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf <- cmpfun(f)
- en: system.time(cf())
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(cf())
- en: user system elapsed
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户系统耗时
- en: '0.845'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '0.845'
- en: '0.003'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '0.003'
- en: '0.848'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '0.848'
- en: We created a new function, cf(), from the original f(). The new code’s run time
    was 0.848 seconds, much faster than the 8.175 seconds the non-compiled version
    took. Granted, it still wasn’t as fast as the straightforward vectorized code,
    but it is clear that byte code compilation has potential. You should try it whenever
    you need faster code.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从原始的f()函数创建了一个新的函数cf()。新代码的运行时间为0.848秒，比非编译版本的8.175秒快得多。诚然，它仍然没有像直接向量化的代码那样快，但很明显，字节码编译有潜力。当你需要更快的代码时，你应该尝试它。
- en: '**14.6 Oh No, the Data Doesn’t Fit into Memory!**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.6 哎呀，数据放不进内存！**'
- en: As mentioned earlier, all objects in an R session are stored in memory. R
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，R会话中的所有对象都存储在内存中。R
- en: places a limit of 231 *−* 1 bytes on the size of any object, regardless of word
    size (32-bit versus 64-bit) and the amount of RAM in your machine. However, you
    really should not consider this an obstacle. With a little extra care, applications
    that have large memory requirements can indeed be handled well in R. Some common
    approaches are chunking and using R packages for memory management.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何对象的大小设置限制为231 *−* 1字节，无论字长（32位与64位）以及机器中的RAM量。然而，你真的不应该把它看作是一个障碍。只要稍微多加小心，具有大量内存需求的应用程序确实可以在R中得到很好的处理。一些常见的方法是分块和使用R包进行内存管理。
- en: '***14.6.1 Chunking***'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.6.1 分块***'
- en: One option involving no extra R packages at all is to read in your data from
    a disk file one chunk at a time. For example, suppose that our goal is to find
    means or proportions of some variables. We can use the skip argument in read.table().
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不涉及任何额外R包的选项是从磁盘文件一次读取一个数据块。例如，假设我们的目标是找到一些变量的均值或比例。我们可以使用read.table()中的skip参数。
- en: Say our data set has 1,000,000 records and we divide them into 10
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据集有1,000,000条记录，我们将它们分成10
- en: chunks (or more—whatever is needed to cut the data down to a size so it fits
    in memory). Then we set skip = 0 on our first read, set skip = 100000
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 块（或更多—— whatever is needed to cut the data down to a size so it fits in memory）。然后我们在第一次读取时设置skip
    = 0，第二次设置skip = 100000
- en: the second time, and so on. Each time we read in a chunk, we calculate **320**
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次读取时，以此类推。每次读取一个块时，我们计算**320**
- en: Chapter 14
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: the counts or totals for that chunk and record them. After reading all the chunks,
    we add up all the counts or totals in order to calculate our grand means or proportions.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 记录该块的数量或总和，并将它们记录下来。在读取所有块之后，我们将所有数量或总和加起来，以便计算我们的总体均值或比例。
- en: As another example, suppose we are performing a statistical operation, say calculating
    principle components, in which we have a huge number of rows—that is, a huge number
    of observations—but the number of variables is manageable. Again, chunking could
    be the solution. We apply the statistical operation to each chunk and then average
    the results over all the chunks. My mathematical research shows that the resulting
    estimators are statistically efficient in a wide class of statistical methods.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，假设我们正在进行一个统计操作，比如计算主成分，其中我们有一大批行——也就是说，有大量观测值——但变量的数量是可管理的。再次强调，分块可能是解决方案。我们将统计操作应用于每个块，然后对所有块的结果进行平均。我的数学研究显示，这些结果估计量在广泛的统计方法中在统计上是有效的。
- en: '***14.6.2 Using R Packages for Memory Management***'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.6.2 使用R包进行内存管理***'
- en: Again looking at a bit more sophistication, there are alternatives for accommodating
    large memory requirements in the form of some specialized R
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑更复杂的例子，有一些替代方案可以用来适应大内存需求，形式是一些专门的R
- en: packages.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: packages.
- en: One such package is RMySQL, an R interface to SQL databases. Using it requires
    some database expertise, but this package provides a much more efficient and convenient
    way to handle large data sets. The idea is to have SQL do its variable/case selection
    operations for you back at the database end and then read the resulting selected
    data as it is produced by SQL.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个包是RMySQL，它是SQL数据库的R接口。使用它需要一些数据库专业知识，但这个包提供了处理大型数据集的更高效和更方便的方法。想法是在数据库端让SQL为你执行变量/情况选择操作，然后读取由SQL产生的所选数据。
- en: Since the latter will typically be much smaller than the overall data set, you
    will likely be able to circumvent R’s memory restriction.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后者通常比整体数据集小得多，你可能会绕过R的内存限制。
- en: 'Another useful package is biglm, which does regression and generalized linear-model
    analysis on very large data sets. It also uses chunking but in a different manner:
    Each chunk is used to update the running totals of sums needed for the regression
    analysis and then discarded.'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的包是biglm，它对非常大的数据集进行回归和广义线性模型分析。它也使用分块，但方式不同：每个块用于更新回归分析所需的运行总和，然后被丢弃。
- en: Finally, some packages do their own storage management indepen-
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些包自己进行存储管理独立于
- en: dently of R and thus can deal with very large data sets. The two most commonly
    used today are ff and bigmemory. The former sidesteps memory constraints by storing
    data on disk instead of memory, essentially transparently to the programmer. The
    highly versatile bigmemory package does the same, but it can store data not only
    on disk but also in the machine’s main memory, which is ideal for multicore machines.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于R，因此可以处理非常大的数据集。目前最常用的两个是ff和bigmemory。前者通过在磁盘上而不是内存中存储数据来规避内存限制，对程序员来说几乎是透明的。功能极其丰富的bigmemory包做同样的事情，但它不仅可以存储在磁盘上，还可以存储在机器的主内存中，这对于多核机器来说非常理想。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**321**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**321**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 42](index-349_1.png)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![图像42](index-349_1.png)'
- en: '**15**'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**INTERFACING R TO OTHER**'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '**将R连接到其他**'
- en: '**LANGUAGES**'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言**'
- en: R is a great language, but it can’t do every-
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: R是一种伟大的语言，但它不能做每一件事
- en: thing well. Thus, it is sometimes desirable
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 事情处理得很好。因此，有时是可取的
- en: to call code written in other languages from
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他语言中调用代码
- en: R. Conversely, when working in other great lan-
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: R。相反，当在其他伟大的语言中工作时
- en: guages, you may encounter tasks that could be better
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 语言，你可能会遇到一些任务，这些任务可能更适合
- en: done in R.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中完成。
- en: R interfaces have been developed for a number of other languages,
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为许多其他语言开发了R接口，
- en: 'from ubiquitous languages like C to esoteric ones like the Yacas computer algebra
    system. This chapter will cover two interfaces: one for calling C/C++ from R and
    the other for calling R from Python.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 从无处不在的语言如C到晦涩难懂的语言如Yacas计算机代数系统。本章将介绍两个接口：一个是从R调用C/C++的接口，另一个是从Python调用R的接口。
- en: '**15.1 Writing C/C++ Functions to Be Called from R**'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.1 编写从R调用的C/C++函数**'
- en: You may wish to write your own C/C++ functions to be called from R. Typically,
    the goal is performance enhancement, since C/C++ code may run much faster than
    R, even if you use vectorization and other R optimization techniques to speed
    things up.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望编写自己的C/C++函数，以便从R中调用。通常，目标是性能提升，因为C/C++代码可能比R运行得更快，即使你使用向量化和其他R优化技术来加速。
- en: Another possible goal in dropping down to the C/C++ level is specialized I/O.
    For example, R uses the TCP protocol in layer 3 of the standard Internet communication
    system, but UDP can be faster in some settings.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 降低到C/C++级别的另一个可能目标是专门的I/O。例如，R在标准互联网通信系统的第3层使用TCP协议，但在某些设置中UDP可能更快。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: To work in UDP, you need C/C++, which requires an interface to R for those languages.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用UDP时，你需要C/C++，这些语言需要与R的接口。
- en: R actually offers two C/C++ interfaces via the functions .C() and
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: R实际上通过函数 .C() 和
- en: .Call(). The latter is more versatile but requires some knowledge of R’s internal
    structures, so we’ll stick with .C() here.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: .Call(). 后者更灵活，但需要了解R的内部结构，所以我们在这里坚持使用 .C()。
- en: '***15.1.1 Some R-to-C/C++ Preliminaries***'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.1 一些R到C/C++的初步知识***'
- en: In C, two-dimensional arrays are stored in row-major order, in contrast to R’s
    column-major order. For instance, if you have a 3-by-4 array, the element in the
    second row and second column is element number 5 of the array when viewed linearly,
    since there are three elements in the first column and this is the second element
    in the second column. Also keep in mind that C subscripts begin at 0, rather than
    at 1, as with R.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，二维数组以行主序存储，这与 R 的列主序相反。例如，如果您有一个 3x4 的数组，当线性查看时，第二行第二列的元素是数组的第 5 个元素，因为第一列有三个元素，这是第二列的第二元素。还要记住，C
    的索引从 0 开始，而不是像 R 那样从 1 开始。
- en: All the arguments passed from R to C are received by C as pointers.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从 R 传递到 C 的参数都以指针的形式接收。
- en: Note that the C function itself must return void. Values that you would ordinarily
    return must be communicated through the function’s arguments, such as result in
    the following example.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C 函数本身必须返回 void。您通常返回的值必须通过函数的参数传递，例如以下示例中的 result。
- en: '***15.1.2 Example: Extracting Subdiagonals from a Square Matrix***'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.2 示例：从方阵中提取子对角线***'
- en: Here, we will write C code to extract subdiagonals from a square matrix.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写 C 代码以从方阵中提取子对角线。
- en: '(Thanks to my former graduate assistant, Min-Yu Huang, who wrote an earlier
    version of this function.) Here’s the code for the file *sd.c*:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: (感谢我的前研究生助理，黄敏宇，他编写了这个函数的早期版本。) 这是文件 *sd.c* 的代码：
- en: '#include <R.h> // required'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h> // 必需'
- en: '// arguments:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: // 参数：
- en: //
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'm: a square matrix'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 'm: 一个方阵'
- en: //
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'n: number of rows/columns of m'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 'n: m 的行/列数'
- en: //
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'k: the subdiagonal index--0 for main diagonal, 1 for first'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 'k: 子对角线索引--主对角线为 0，第一个子对角线为 1'
- en: //
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: subdiagonal, 2 for the second, etc.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 子对角线，第二个子对角线为 2，等等。
- en: //
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'result: space for the requested subdiagonal, returned here'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'result: 请求的子对角线空间，此处返回'
- en: void subdiag(double *m, int *n, int *k, double *result)
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: void subdiag(double *m, int *n, int *k, double *result)
- en: '{'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int nval = *n, kval = *k;
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: int nval = *n, kval = *k;
- en: int stride = nval + 1;
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: int stride = nval + 1;
- en: for (int i = 0, j = kval; i < nval-kval; ++i, j+= stride)
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0, j = kval; i < nval-kval; ++i, j+= stride)
- en: result[i] = m[j];
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: result[i] = m[j];
- en: '}'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The variable stride alludes to a concept from the parallel-processing community.
    Say we have a matrix in 1,000 columns and our C code is looping through all the
    elements in a given column, from top to bottom. Again, since C uses row-major
    order, consecutive elements in the column are 1,000
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 stride 暗示了并行处理社区中的一个概念。比如说我们有一个 1,000 列的矩阵，我们的 C 代码正在遍历给定列中的所有元素，从上到下。再次强调，由于
    C 使用行主序，如果将矩阵视为一个长向量，则连续元素之间相隔 1,000 个元素。
- en: elements apart from each other if the matrix is viewed as one long vector.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: elements apart from each other if the matrix is viewed as one long vector.
- en: '**324**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**324**'
- en: Chapter 15
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Here, we would say that we are traversing that long vector with a stride of
    1,000—that is, accessing every thousandth element.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们会说我们以 1,000 的步长遍历这个长向量--也就是说，访问每千个元素。
- en: '***15.1.3 Compiling and Running Code***'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.3 编译和运行代码***'
- en: 'You compile your code using R. For example, in a Linux terminal window, we
    could compile our file like this:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 R 编译您的代码。例如，在 Linux 终端窗口中，我们可以像这样编译我们的文件：
- en: '% R CMD SHLIB sd.c'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '% R CMD SHLIB sd.c'
- en: gcc -std=gnu99 -I/usr/share/R/include
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -I/usr/share/R/include
- en: -fpic -g -O2 -c sd.c -o sd.o
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: -fpic -g -O2 -c sd.c -o sd.o
- en: gcc -std=gnu99 -shared -o sd.so sd.o
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -shared -o sd.so sd.o
- en: -L/usr/lib/R/lib -lR
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: -L/usr/lib/R/lib -lR
- en: This would produce the dynamic shared library file *sd.so*.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成动态共享库文件 *sd.so*。
- en: Note that R has reported how it invoked GCC in the output of the example. You
    can also run these commands by hand if you have special requirements, such as
    special libraries to be linked in. Also note that the locations of the *include*
    and *lib* directories may be system-dependent.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 R 在示例输出中报告了如何调用 GCC。如果您有特殊要求，例如需要链接的特殊库，您也可以手动运行这些命令。另外，请注意 *include* 和
    *lib* 目录的位置可能取决于系统。
- en: '**NOTE**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*GCC is easily downloadable for Linux systems. For Windows, it is included
    in* *Cygwin, an open source package available from* http://www.cygwin.com/ *.*'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCC 对于 Linux 系统很容易下载。对于 Windows，它包含在 *Cygwin* 中，这是一个可以从 *http://www.cygwin.com/*
    获取的开源软件包。*'
- en: 'We can then load our library into R and call our C function like this:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的库加载到 R 中，并像这样调用我们的 C 函数：
- en: dyn.load("sd.so")
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("sd.so")
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
- en: k <- 2
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k <- 2
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))
- en: '[[1]]'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 6 11 16 21 2 7 12 17 22 3 8 13 18 23 4 9 14 19 24 5 10 15 20 25'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '[[2]]'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[[3]]'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: $result
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 11 17 23'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: For convenience here, we’ve given the name result to both the formal argument
    (in the C code) and the actual argument (in the R code). Note that we needed to
    allocate space for result in our R code.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the example, the return value takes on the form of a list
    consisting of the arguments in the R call. In this case, the call had four arguments
    (in addition to the function name), so the returned list has four components.
    Typically, some of the arguments will be changed during execution of the C code,
    as was the case here with result.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '**325**'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.4 Debugging R/C Code***'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13 discussed a number of tools and methods for debugging R code.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: However, the R/C interface presents an extra challenge. The problem in using
    a debugging tool such as GDB here is that you must first apply it to R
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: itself.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: The following is a walk-through of the R/C debugging steps using GDB
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: on our previous *sd.c* code as the example.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: $ R -d gdb
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: GNU gdb 6.8-debian
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) run
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting program: /usr/lib/R/bin/exec/R'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("sd.so")
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: hit ctrl-c here
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Program received signal SIGINT, Interrupt.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: 0xb7ffa430 in __kernel_vsyscall ()
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) b subdiag
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: 'Breakpoint 1 at 0xb77683f3: file sd.c, line 3\.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) continue
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: Continuing.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoint 1, subdiag (m=0x92b9480, n=0x9482328, k=0x9482348, result=0x9817148)
    at sd.c:3
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: int nval = *n, kval = *k;
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: (gdb)
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened in this debugging session?
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: We launched the debugger, GDB, with R loaded into it, from a com-
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: 'mand line in a terminal window:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: R -d gdb
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: 'We told GDB to run R:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) run
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: 'We loaded our compiled C code into R as usual:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("sd.so")
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: We hit the CTRL-C interrupt key pair to pause R and put us back at the GDB prompt.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a breakpoint at the entry to subdiag():'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) b subdiag
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '**326**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: 'We told GDB to resume executing R (we needed to hit the ENTER key a second
    time in order to get the R prompt):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) continue
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: 'We then executed our C code:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k <- 2
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k),
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: + result=double(dim(m)[1]-k))
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoint 1, subdiag (m=0x942f270, n=0x96c3328, k=0x96c3348, result=0x9a58148)
    at subdiag.c:46
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 46 if (*n < 1) error("n < 1\n");
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can use GDB to debug as usual. If you’re not familiar with
    GDB, you may want to try one of the many quick tutorials on the Web.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1 lists some of the most useful commands.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common GDB Commands'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: l
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: List code lines
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: b
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: Set breakpoint
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: r
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: Run/rerun
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: n
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: Step to next statement
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: s
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: Step into function call
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: p
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: Print variable or expression
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: c
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: Continue
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: h
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Help
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: q
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: Quit
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.5 Extended Example: Prediction of Discrete-Valued Time Series***'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our example in Section 2.5.2 where we observed 0- and 1-valued data,
    one per time period, and attempted to predict the value in any period from the
    previous k values, using majority rule. We developed two competing functions for
    the job, preda() and predb(), as follows:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们在 2.5.2 节中的例子，我们观察了 0 和 1 值的数据，每个时间周期一个值，并尝试使用多数规则从之前的 k 个值中预测任何周期的值。我们为此开发了两个竞争性的函数，preda()
    和 predb()，如下所示：
- en: prediction in discrete time series; 0s and 1s; use k consecutive
  id: totrans-1292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prediction in discrete time series; 0s and 1s; use k consecutive
- en: observations to predict the next, using majority rule; calculate the
  id: totrans-1293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: observations to predict the next, using majority rule; calculate the
- en: error rate
  id: totrans-1294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: error rate
- en: preda <- function(x,k) {
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: preda <- function(x,k) {
- en: n <- length(x)
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: k2 <- k/2
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: the vector pred will contain our predicted values
  id: totrans-1298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: the vector pred will contain our predicted values
- en: pred <- vector(length=n-k)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- vector(length=n-k)
- en: Interfacing R to Other Languages
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: Interfacing R to Other Languages
- en: '**327**'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**327**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: for (i in 1:(n-k)) {
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n-k)) {
- en: if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
- en: '}'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: predb <- function(x,k) {
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: predb <- function(x,k) {
- en: n <- length(x)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: k2 <- k/2
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: pred <- vector(length=n-k)
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- vector(length=n-k)
- en: sm <- sum(x[1:k])
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: sm <- sum(x[1:k])
- en: if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
- en: if (n-k >= 2) {
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: if (n-k >= 2) {
- en: for (i in 2:(n-k)) {
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:(n-k)) {
- en: sm <- sm + x[i+k-1] - x[i-1]
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: sm <- sm + x[i+k-1] - x[i-1]
- en: if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
- en: '}'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Since the latter avoids duplicate computation, we speculated it would be faster.
    Now is the time to check that.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后者避免了重复计算，我们推测它可能会更快。现在是检查这个的时候了。
- en: y <- sample(0:1,100000,replace=T)
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- sample(0:1,100000,replace=T)
- en: system.time(preda(y,1000))
  id: totrans-1324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(preda(y,1000))
- en: user system elapsed
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '3.816'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '3.816'
- en: '0.016'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '3.873'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '3.873'
- en: system.time(predb(y,1000))
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(predb(y,1000))
- en: user system elapsed
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '1.392'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '1.392'
- en: '0.008'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '0.008'
- en: '1.427'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '1.427'
- en: Hey, not bad! That’s quite an improvement.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，不错！这相当是一个改进。
- en: 'However, you should always ask whether R already has a fine-tuned function
    that will suit your needs. Since we’re basically computing a moving average, we
    might try the filter() function, with a constant coefficient vector, as follows:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该始终询问 R 是否已经有一个经过微调的函数可以满足你的需求。因为我们基本上是在计算移动平均，我们可能会尝试使用 filter() 函数，使用一个常数系数向量，如下所示：
- en: predc <- function(x,k) {
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: predc <- function(x,k) {
- en: n <- length(x)
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: f <- filter(x,rep(1,k),sides=1)[k:(n-1)]
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: f <- filter(x,rep(1,k),sides=1)[k:(n-1)]
- en: k2 <- k/2
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: pred <- as.integer(f >= k2)
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- as.integer(f >= k2)
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**328**'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '**328**'
- en: Chapter 15
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 15
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: That’s even more compact than our first version. But it’s a lot harder to read,
    and for reasons we will explore soon, it may not be so fast. Let’s check.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比我们的第一个版本更加紧凑。但它很难阅读，并且由于我们将很快探讨的原因，它可能不会那么快。让我们检查一下。
- en: system.time(predc(y,1000))
  id: totrans-1347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(predc(y,1000))
- en: user system elapsed
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '3.872'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '3.872'
- en: '0.016'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '3.945'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '3.945'
- en: 'Well, our second version remains the champion so far. This actually should
    be expected, as a look at the source code shows. Typing the following shows the
    source for that function:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们的第二个版本至今仍然是冠军。这实际上是可以预料的，因为查看源代码就可以看到。输入以下内容显示了该函数的源代码：
- en: filter
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: filter
- en: This reveals (not shown here) that filter1() is called. The latter is written
    in C, which should give us some speedup, but it still suffers from the duplicate
    computation problem—hence the slowness.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了（此处未显示）filter1() 被调用的信息。后者是用 C 编写的，这应该会给我们带来一些速度提升，但它仍然存在重复计算的问题——因此速度较慢。
- en: So, let’s write our own C code.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写自己的 C 代码。
- en: '#include <R.h>'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h>'
- en: void predd(int *x, int *n, int *k, double *errrate)
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: void predd(int *x, int *n, int *k, double *errrate)
- en: '{'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int nval = *n, kval = *k, nk = nval - kval, i;
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: int nval = *n, kval = *k, nk = nval - kval, i;
- en: int sm = 0; // moving sum
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: int sm = 0; // 移动总和
- en: int errs = 0; // error count
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: int errs = 0; // 错误计数
- en: int pred; // predicted value
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: int pred; // 预测值
- en: double k2 = kval/2.0;
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: double k2 = kval/2.0;
- en: // initialize by computing the initial window
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过计算初始窗口进行初始化
- en: for (i = 0; i < kval; i++) sm += x[i];
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = 0; i < kval; i++) sm += x[i];
- en: if (sm >= k2) pred = 1; else pred = 0;
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred = 1; else pred = 0;
- en: errs = abs(pred-x[kval]);
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: errs = abs(pred-x[kval]);
- en: for (i = 1; i < nk; i++) {
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = 1; i < nk; i++) {
- en: sm = sm + x[i+kval-1] - x[i-1];
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: sm = sm + x[i+kval-1] - x[i-1];
- en: if (sm >= k2) pred = 1; else pred = 0;
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred = 1; else pred = 0;
- en: errs += abs(pred-x[i+kval]);
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: errs += abs(pred-x[i+kval]);
- en: '}'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*errrate = (double) errs / nk;'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '*errrate = (double) errs / nk;'
- en: '}'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This is basically predb() from before, “hand translated” into C. Let’s see if
    it will outdo predb().
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是将之前的 predb() “手动翻译”成 C 语言。让我们看看它是否能超越 predb()。
- en: system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000),
  id: totrans-1376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000),
- en: +
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: errrate=double(1)))
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: errrate=double(1)))
- en: user system elapsed
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.004'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '0.000'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.003'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '0.003'
- en: Interfacing R to Other Languages
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: R 与其他语言的接口
- en: '**329**'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**329**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The speedup is breathtaking.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 加速效果令人惊叹。
- en: You can see that writing certain functions in C can be worth the effort.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，用 C 语言编写某些函数是值得努力的。
- en: This is especially true for functions that involve iteration, as R’s own iteration
    constructs, such as for(), are slow.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于涉及迭代的函数尤其如此，因为 R 的迭代构造，如 for()，速度较慢。
- en: '**15.2 Using R from Python**'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.2 从 Python 使用 R**'
- en: Python is an elegant and powerful language, but it lacks built-in facilities
    for statistical and data manipulation, two areas in which R excels. This section
    demonstrates how to call R from Python, using RPy, one of the most popular interfaces
    between the two languages.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种优雅且强大的语言，但它缺乏内置的统计和数据操作功能，这两个领域是 R 的强项。本节演示了如何使用 RPy（两种语言之间最受欢迎的接口之一）从
    Python 调用 R。
- en: '***15.2.1 Installing RPy***'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.2.1 安装 RPy***'
- en: RPy is a Python module that allows access to R from Python. For extra efficiency,
    it can be used in conjunction with NumPy.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: RPy 是一个 Python 模块，允许从 Python 访问 R。为了提高效率，它可以与 NumPy 一起使用。
- en: You can build the module from the source, available from *http://rpy*
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *http://rpy* 获取源代码构建模块。
- en: '*.sourceforge.net*, or download a prebuilt version. If you are running Ubuntu,
    simply type this:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '*.sourceforge.net*，或者下载一个预构建版本。如果你正在运行 Ubuntu，只需输入以下命令：'
- en: sudo apt-get install python-rpy
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get install python-rpy
- en: 'To load RPy from Python (whether in Python interactive mode or from code),
    execute the following:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Python 加载 RPy（无论是 Python 交互模式还是从代码中），请执行以下命令：
- en: from rpy import *
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: from rpy import *
- en: This will load a variable r, which is a Python class instance.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一个变量 r，它是一个 Python 类实例。
- en: '***15.2.2 RPy Syntax***'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.2.2 RPy 语法***'
- en: 'Running R from Python is in principle quite simple. Here is an example of a
    command you might run from the *>>>* Python prompt:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 运行 R 在原则上非常简单。以下是从 *>>>* Python 提示符可能运行的命令示例：
- en: '>>> r.hist(r.rnorm(100))'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.hist(r.rnorm(100))'
- en: This will call the R function rnorm() to produce 100 standard normal variates
    and then input those values into R’s histogram function, hist().
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 R 函数 rnorm() 来生成 100 个标准正态变量，然后将这些值输入到 R 的直方图函数 hist() 中。
- en: As you can see, R names are prefixed by r., reflecting the fact that Python
    wrappers for R functions are members of the class instance r.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，R 名称以 r. 为前缀，反映了 R 函数的 Python 包装器是 r 类实例的成员。
- en: The preceding code will, if not refined, produce ugly output, with your (possibly
    voluminous!) data appearing as the graph title and the *x*-axis label.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行优化，前面的代码将产生丑陋的输出，你的（可能大量的！）数据将出现在图表标题和 *x* 轴标签中。
- en: 'You can avoid this by supplying a title and label, as in this example:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供标题和标签来避免这种情况，如下例所示：
- en: '>>> r.hist(r.rnorm(100),main='''',xlab='''')'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.hist(r.rnorm(100),main='''',xlab='''')'
- en: RPy syntax is sometimes less simple than these examples would lead you to believe.
    The problem is that R and Python syntax may clash. For instance, **330**
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: RPy 语法有时比这些示例所表明的要复杂。问题是 R 和 Python 语法可能冲突。例如，**330**
- en: Chapter 15
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: consider a call to the R linear model function lm(). In our example, we will
    predict b from a.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑调用 R 线性模型函数 lm()。在我们的例子中，我们将从 a 预测 b。
- en: '>>> a = [5,12,13]'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [5,12,13]'
- en: '>>> b = [10,28,30]'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [10,28,30]'
- en: '>>> lmout = r.lm(''v2 ~ v1'',data=r.data_frame(v1=a,v2=b))'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lmout = r.lm(''v2 ~ v1'',data=r.data_frame(v1=a,v2=b))'
- en: This is somewhat more complex than it would have been if done directly in R.
    What are the issues here?
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 这比直接在 R 中做要复杂一些。这里有什么问题？
- en: First, since Python syntax does not include the tilde character, we needed to
    specify the model formula via a string. Since this is done in R anyway, this is
    not a major departure.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于 Python 语法不包含波浪线字符，我们需要通过字符串指定模型公式。由于这已经在 R 中完成，因此这不是一个重大的改变。
- en: Second, we needed a data frame to contain our data. We created one
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一个数据框来包含我们的数据。我们创建了一个
- en: using R’s data.frame() function. In order to form a period in an R function
    name, we need to use an underscore on the Python end. Thus we called r.data_frame().
    Note that in this call, we named the columns of our data frame v1 and v2 and then
    used these in our model formula.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: 'The output object is a Python dictionary (analog of R’s list type), as you
    can see here (in part):'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: '{''qr'': {''pivot'': [1, 2], ''qr'': array([[ -1.73205081, -17.32050808],'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0.57735027, -6.164414 ],'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0.57735027,'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '0.78355007]]), ''qraux'':'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: 'You should recognize the various attributes of lm() objects here. For example,
    the coefficients of the fitted regression line, which would be contained in lmout$coefficients
    if this were done in R, are here in Python as lmout[''coefficients'']. So, you
    can access those coefficients accordingly, for example like this:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout[''coefficients'']'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '{''v1'': 2.5263157894736841, ''(Intercept)'': -2.5964912280701729}'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout[''coefficients''][''v1'']'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: '2.5263157894736841'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: You can also submit R commands to work on variables in R’s namespace, using
    the function r(). This is convenient if there are many syntax clashes.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we could run the wireframe() example in Section 12.4 in RPy:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.library(''lattice'')'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.assign(''a'',a)'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.assign(''b'',b)'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''g <- expand.grid(a,b)'')'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''g$Var3 <- g$Var1^2 + g$Var1 * g$Var2'')'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''wireframe(Var3 ~ Var1+Var2,g)'')'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''plot(wireframe(Var3 ~ Var1+Var2,g))'')'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '**331**'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: First, we used r.assign() to copy a variable from Python’s namespace to R’s.
    We then ran expand.grid() (with a period in the name instead of an underscore,
    since we are running in R’s namespace), assigning the result to g. Again, the
    latter is in R’s namespace. Note that the call to wireframe() did not automatically
    display the plot, so we needed to call plot().
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for RPy is at *http://rpy.sourceforge.net/rpy/doc/*
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '*rpy.pdf*. Also, you can find a useful presentation, “RPy—R from Python,” at
    *http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html*.'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: '**332**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](index-359_1.png)'
  id: totrans-1447
  prefs: []
  type: TYPE_IMG
- en: '**16**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: '**PARALLEL R**'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: Since many R users have very large compu-
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: tational needs, various tools for some kind
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: of parallel operation of R have been devised.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to parallel R.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: Many a novice in parallel processing has, with great anticipation, written parallel
    code for some application only to find that the parallel version actually ran
    more slowly than the serial one. For reasons to be discussed in this chapter,
    this problem is especially acute with R.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, understanding the nature of parallel-processing hardware and software
    is crucial to success in the parallel world. These issues will be discussed here
    in the context of common platforms for parallel R.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a few code examples and then move to general performance issues.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '**16.1 The Mutual Outlinks Problem**'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: Consider a network graph of some kind, such as web links or links in a social
    network. Let A be the *adjacency matrix* of the graph, meaning that, say, A[3,8]
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑某种类型的网络图，例如网页链接或社交网络中的链接。设A为图的**邻接矩阵**，这意味着，例如，A[3,8]
- en: is 1 or 0, depending on whether there is a link from node 3 to node 8\.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 的值为1或0，取决于是否存在从节点3到节点8的链接。
- en: For any two vertices, say any two websites, we might be interested in mutual
    outlinks—that is, outbound links that are common to two sites. Suppose that we
    want to find the mean number of mutual outlinks, averaged
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何两个顶点，例如任何两个网站，我们可能对互链感兴趣——即两个网站共有的出链。假设我们想找到互链的平均数量，平均
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'over all pairs of websites in our data set. This mean can be found using the
    following outline, for an *n*-by- *n* matrix:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中所有网站对之间。这个平均值可以使用以下概述找到，对于一个 *n* 行 *n* 列的矩阵：
- en: '1'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sum = 0
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: sum = 0
- en: '2'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: for i = 0...n-1
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: for i = 0...n-1
- en: '3'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: for j = i+1...n-1
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: for j = i+1...n-1
- en: '4'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
- en: '5'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mean = sum / (n*(n-1)/2)
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: mean = sum / (n*(n-1)/2)
- en: Given that our graph could contain thousands—even millions—of web-
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的图可能包含成千上万的——甚至数百万个——网页-
- en: sites, our task could entail quite large amounts of computation. A common approach
    to dealing with this problem is to divide the computation into smaller chunks
    and then process each of the chunks simultaneously, say on separate computers.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 网站，我们的任务可能涉及相当大的计算量。处理此问题的常见方法是将计算分成更小的块，然后同时处理每个块，例如在单独的计算机上。
- en: Let’s say that we have two computers at our disposal. We might have one computer
    handle all the odd values of i in the for i loop in line 2 and have the second
    computer handle the even values. Or, since dual-core computers are fairly standard
    these days, we could take this same approach on a single computer. This may sound
    simple, but a number of major issues can arise, as you’ll learn in this chapter.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两台可用的计算机。我们可能让一台计算机处理第2行for i循环中的所有奇数i值，而让第二台计算机处理偶数值。或者，由于双核计算机现在相当普遍，我们可以在单台计算机上采取相同的方法。这听起来可能很简单，但正如你将在本章中学到的那样，可能会出现许多重大问题。
- en: '**16.2 Introducing the snow Package**'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2 介绍snow包**'
- en: Luke Tierney’s snow (Simple Network of Workstations) package, available from
    the CRAN R code repository, is arguably the simplest, easiest-to-use form of parallel
    R and one of the most popular.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: Luke Tierney的snow（简单工作站网络）包，可以从CRAN R代码仓库获得，可以说是最简单、最容易使用的并行R包之一，也是最受欢迎的。
- en: '**NOTE**'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The CRAN Task View page on parallel R,* http://cran.r-project.org/web/views/'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行R的CRAN任务视图页面，* http://cran.r-project.org/web/views/'
- en: HighPerformanceComputing.html *, has a fairly up-to-date list of available parallel
    R packages.*
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能计算.html *，列出了可用的并行R包的最新列表。*
- en: To see how snow works, here’s code for the mutual outlinks problem
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解snow是如何工作的，以下是对互链问题的代码示例
- en: 'described in the previous section:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中描述的：
- en: '1'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: snow version of mutual links problem
  id: totrans-1484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: snow版本的互链问题
- en: '2'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: mtl <- function(ichunk,m) {
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: mtl <- function(ichunk,m) {
- en: '4'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n <- ncol(m)
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: n <- ncol(m)
- en: '5'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: matches <- 0
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: matches <- 0
- en: '6'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: for (i in ichunk) {
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in ichunk) {
- en: '7'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: if (i < n) {
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: if (i < n) {
- en: '8'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: rowi <- m[i,]
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: rowi <- m[i,]
- en: '9'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: matches <- matches +
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: matches <- matches +
- en: '10'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: sum(m[(i+1):n,] %*% rowi)
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: sum(m[(i+1):n,] %*% rowi)
- en: '11'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '12'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '}'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '13'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: matches
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: matches
- en: '14'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**334**'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: '**334**'
- en: Chapter 16
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '15'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: mutlinks <- function(cls,m) {
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: mutlinks <- function(cls,m) {
- en: '17'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: n <- nrow(m)
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(m)
- en: '18'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: nc <- length(cls)
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: nc <- length(cls)
- en: '19'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: determine which worker gets which chunk of i
  id: totrans-1521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定哪个工作器获得哪个i块的块
- en: '20'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: options(warn=-1)
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=-1)
- en: '21'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: ichunks <- split(1:n,1:nc)
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: ichunks <- split(1:n,1:nc)
- en: '22'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: options(warn=0)
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=0)
- en: '23'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: counts <- clusterApply(cls,ichunks,mtl,m)
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: counts <- clusterApply(cls,ichunks,mtl,m)
- en: '24'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: do.call(sum,counts) / (n*(n-1)/2)
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: do.call(sum,counts) / (n*(n-1)/2)
- en: '25'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: '}'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Suppose we have this code in the file *SnowMutLinks.R*. Let’s first discuss
    how to run it.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在这段代码文件 *SnowMutLinks.R* 中。让我们首先讨论如何运行它。
- en: '***16.2.1 Running snow Code***'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2.1 运行snow代码***'
- en: 'Running the above snow code involves the following steps:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述snow代码涉及以下步骤：
- en: 1\.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: Load the code.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 加载代码。
- en: 2\.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Load the snow library.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 加载snow库。
- en: 3\.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Form a snow cluster.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 形成snow集群。
- en: 4\.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: Set up the adjacency matrix of interest.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 设置感兴趣的邻接矩阵。
- en: 5\.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Run your code on that matrix on the cluster you formed.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 在你形成的集群上运行你的代码。
- en: 'Assuming we are running on a dual-core machine, we issue the following commands
    to R:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在双核机器上运行，我们向R发出以下命令：
- en: source("SnowMutLinks.R")
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: library(snow)
  id: totrans-1549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cl <- makeCluster(type="SOCK",c("localhost","localhost"))
  id: totrans-1550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testm <- matrix(sample(0:1,16,replace=T),nrow=4)
  id: totrans-1551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mutlinks(cl,testm)
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.6666667'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are instructing snow to start two new R processes on our
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: machine (localhost is a standard network name for the local machine), which
    I will refer to here as *workers*. I’ll refer to the original R process—the one
    in which we type the preceding commands—as the *manager*. So, at this point, three
    instances of R will be running on the machine (visible by running the ps command
    if you are in a Linux environment, for example).
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: The workers form a *cluster* in snow parlance, which we have named cl.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: 'The snow package uses what is known in the parallel-processing world as a *scatter/gather*
    paradigm, which works as follows:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: The manager partitions the data into chunks and parcels them out to the workers
    (scatter phase).
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: '**335**'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: The workers process their chunks.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: The manager collects the results from the workers (gather phase) and combines
    them as appropriate to the application.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: We have specified that communication between the manager and work-
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: ers will be via network sockets (covered in Chapter 10).
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test matrix to check the code:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: testm
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3] [,4]'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '[4,]'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: Row 1 has zero outlinks in common with row 2, two in common with
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: row 3, and one in common with row 4\. Row 2 has zero outlinks in common with
    the rest, but row 3 has one in common with row 4\. That is a total of four mutual
    outlinks out of 4 *×* 3 */* 2 = 6 pairs—hence, the mean value of 4/6 = 0.6666667,
    as you saw earlier.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: You can make clusters of any size, as long as you have the machines.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: 'In my department, for instance, I have machines whose network names are pc28,
    pc29, and pc30\. Each machine is dual core, so I could create a six-worker cluster
    as follows:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: cl6 <- makeCluster(type="SOCK",c("pc28","pc28","pc29","pc29","pc30","pc30"))
  id: totrans-1596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***16.2.2 Analyzing the snow Code***'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how the mutlinks() function works. First, we sense how many rows
    the matrix m has, in line 17, and the number of workers in our cluster, in line
    18\.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to determine which worker will handle which values of i in the
    for i loop in our outline code shown earlier in Section 16.1\. R’s split() function
    is well suited for this. For instance, in the case of a 4-row matrix and a 2-worker
    cluster, that call produces the following:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: split(1:4,1:2)
  id: totrans-1600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $`1`
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 3'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: $`2`
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2 4'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: An R list is returned whose first element is the vector (1,3) and the second
    is (2,4). This will set up having one R process work on the odd values of i and
    the other work on the even values, as we discussed earlier. We ward off the **336**
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: warnings that split() would give us (“data length is not a multiple of split
    variable”) by calling options().
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: The real work is done in line 23, where we call the snow function
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作是在第23行完成的，在那里我们调用snow函数
- en: 'clusterApply(). This function initiates a call to the same specified function
    (mtl() here), with some arguments specific to each worker and some optional arguments
    common to all. So, here’s what the call in line 23 does: 1\.'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: clusterApply(). 这个函数初始化对相同指定函数（这里的mtl()）的调用，其中包含一些针对每个工作者的特定参数和一些对所有工作者都可选的参数。所以，这里第23行的调用是这样的：1.
- en: Worker 1 will be directed to call the function mtl() with the arguments ichunks[[1]]
    and m.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者1将被指示使用ichunks[[1]]和m作为参数调用函数mtl()。
- en: 2\.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Worker 2 will call mtl() with the arguments ichunks[[2]] and m, and so on for
    all workers.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者2将使用ichunks[[2]]和m调用mtl()，对所有工作者也是如此。
- en: 3\.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Each worker will perform its assigned task and then return the result to the
    manager.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作者将执行其分配的任务，然后将结果返回给管理者。
- en: 4\.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The manager will collect all such results into an R list, which we have assigned
    here to counts.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者将收集所有这些结果到一个R列表中，我们在这里将其分配给counts。
- en: At this point, we merely need to sum all the elements of counts. Well, I shouldn’t
    say “merely,” because there is a little wrinkle to iron out in line 24\.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需要对counts中的所有元素进行求和。好吧，我不应该说“仅仅”，因为在第24行有一些小问题需要解决。
- en: 'R’s sum() function is capable of acting on several vector arguments, like this:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: R的sum()函数可以对多个向量参数进行操作，如下所示：
- en: sum(1:2,c(4,10))
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sum(1:2,c(4,10))
- en: '[1] 17'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 17'
- en: But here, counts is an R list, not a (numeric) vector. So we rely on do.call()
    to extract the vectors from counts, and then we call sum() on them.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，counts是一个R列表，而不是（数值）向量。因此，我们依赖于do.call()从counts中提取向量，然后对它们调用sum()。
- en: Note lines 9 and 10\. As you know, in R, we try to vectorize our computation
    wherever possible for better performance. By casting things in matrix-times-vector
    terms, we replace the for j and for k loops in the outline in Section 16.1 by
    a single vector-based expression.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第9行和第10行。正如你所知，在R中，我们尽可能地尝试将计算向量化以提高性能。通过将事物表示为矩阵-向量乘积的形式，我们将第16.1节概述中的for
    j和for k循环替换为一个基于向量的单一表达式。
- en: '***16.2.3 How Much Speedup Can Be Attained?***'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2.3 可以获得多少加速？**'
- en: I tried this code on a 1000-by-1000 matrix m1000\. I first ran it on a 4-worker
    cluster and then on a 12-worker cluster. In principle, I should have had speedups
    of 4 and 12, respectively. But the actual elapsed times were 6.2 seconds and 5.0
    seconds. Compare these figures to the 16.9 seconds runtime in nonparallel form.
    (The latter consisted of the call mtl(1:1000,m1000).) So, I attained a speedup
    of about 2.7 instead of a theoretical 4.0 for a 4-worker cluster and 3.4 rather
    than 12.0 on the 12-node system. (Note that some timing variation occurs from
    run to run.) What went wrong?
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个1000x1000的矩阵m1000上尝试了这段代码。我首先在一个4个工作者的集群上运行它，然后在一个12个工作者的集群上运行。原则上，我应该有4和12的加速比。但实际上，经过的时间是6.2秒和5.0秒。将这些数字与16.9秒的非并行运行时间进行比较。（后者是mtl(1:1000,m1000)的调用。）因此，我获得了大约2.7的加速比，而不是4.0的理论值，对于4个工作者的集群，以及在12节点系统上的3.4而不是12.0。请注意，运行之间的时间会有所变化。）出了什么问题？
- en: In almost any parallel-processing application, you encounter *overhead*, or
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎任何并行处理应用程序中，你都会遇到*开销*，或者
- en: “wasted” time spent on noncomputational activity. In our example, there is overhead
    in the form of the time needed to send our matrix from the manager to the workers.
    We also encountered a bit of overhead in sending the function mtl() itself to
    the workers. And when the workers finish their tasks, returning their results
    to the manager causes some overhead, too. We’ll Parallel R
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: “浪费”在非计算活动上的时间。在我们的例子中，存在从管理者到工作者的矩阵传输所需的时间开销。我们还在将函数mtl()本身发送到工作者时遇到了一点开销。当工作者完成他们的任务后，将结果返回给管理者也会造成一些开销。我们将在第16.4.1节中详细讨论这一点。
- en: '**337**'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '**337**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: discuss this in detail when we talk about general performance considerations
    in in Section 16.4.1\.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论一般性能考虑时。
- en: '***16.2.4 Extended Example: K-Means Clustering***'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2.4 扩展示例：K-Means聚类**'
- en: To learn more about the capabilities of snow, we’ll look at another example,
    this one involving k-means clustering (KMC).
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于snow功能的能力，我们将查看另一个示例，这个示例涉及k-means聚类（KMC）。
- en: KMC is a technique for exporatory data analysis. In looking at scatter plots
    of your data, you may have the perception that the observations tend to cluster
    into groups, and KMC is a method for finding such groups. The output consists
    of the centroids of the groups.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an outline of the algorithm:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: for iter = 1,2,...,niters
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: set vector and count totals to 0
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: for i = 1,...,nrow(m)
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: set j = index of the closest group center to m[i,]
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: add m[i,] to the vector total for group j, v[j]
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: add 1 to the count total for group j, c[j]
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: for j = 1,...,ngrps
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: set new center of group j = v[j] / c[j]
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: Here, we specify niters iterations, with initcenters as our initial guesses
    for the centers of the groups. Our data is in the matrix m, and there are ngrps
    groups.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the snow code to compute KMC in parallel:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: snow version of k-means clustering problem
  id: totrans-1654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: library(snow)
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: returns distances from x to each vector in y;
  id: totrans-1660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: here x is a single vector and y is a bunch of them;
  id: totrans-1662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: define distance between 2 points to be the sum of the absolute values 8
  id: totrans-1664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of their componentwise differences; e.g., distance between (5,4.2) and 9
  id: totrans-1665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (3,5.6) is 2 + 1.4 = 3.4
  id: totrans-1666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: dst <- function(x,y) {
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 'tmpmat <- matrix(abs(x-y),byrow=T,ncol=length(x)) # note recycling 12'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: rowSums(tmpmat)
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: will check this worker's mchunk matrix against currctrs, the current 16
  id: totrans-1676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: centers of the groups, returning a matrix; row j of the matrix will 17
  id: totrans-1677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: consist of the vector sum of the points in mchunk closest to jth
  id: totrans-1678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '18'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: current center, and the count of such points
  id: totrans-1680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: findnewgrps <- function(currctrs) {
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: ngrps <- nrow(currctrs)
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: 'spacedim <- ncol(currctrs) # what dimension space are we in?'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '**338**'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: set up the return matrix
  id: totrans-1691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts <- matrix(rep(0,ngrps*(spacedim+1)),nrow=ngrps)
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nrow(mchunk)) {
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: dsts <- dst(mchunk[i,],t(currctrs))
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(dsts)
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts[j,] <- sumcounts[j,] + c(mchunk[i,],1)
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: parkm <- function(cls,m,niters,initcenters) {
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(m)
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: 'spacedim <- ncol(m) # what dimension space are we in?'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: determine which worker gets which chunk of rows of m
  id: totrans-1716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '36'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=-1)
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: ichunks <- split(1:n,1:length(cls))
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=0)
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: form row chunks
  id: totrans-1724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '40'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: mchunks <- lapply(ichunks,function(ichunk) m[ichunk,])
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: mcf <- function(mchunk) mchunk <<- mchunk
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: send row chunks to workers; each chunk will be a global variable at 43
  id: totrans-1730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: the worker, named mchunk
  id: totrans-1731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '44'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: invisible(clusterApply(cls,mchunks,mcf))
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: send dst() to workers
  id: totrans-1735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '46'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: clusterExport(cls,"dst")
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: start iterations
  id: totrans-1739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '48'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: centers <- initcenters
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:niters) {
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts <- clusterCall(cls,findnewgrps,centers)
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: tmp <- Reduce("+",sumcounts)
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: centers <- tmp[,1:spacedim] / tmp[,spacedim+1]
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: if a group is empty, let's set its center to 0s
  id: totrans-1751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '54'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: centers[is.nan(centers)] <- 0
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: centers
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: The code here is largely similar to our earlier mutual outlinks example.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a couple of new snow calls and a different kind of usage
    of an old call.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有几个新的 snow 调用和一个旧调用的不同用法。
- en: Let’s start with lines 39 through 44\. Since our matrix m does not change from
    one iteration to the next, we definitely do not want to resend it to the workers
    repeatedly, exacerbating the overhead problem. Thus, first we need to send each
    worker its assigned chunk of m, just once. This is done in line 44
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第 39 行到第 44 行开始。由于我们的矩阵 m 在每次迭代中都不会改变，我们绝对不希望反复将其发送到工作者，这会加剧开销问题。因此，首先我们需要将
    m 的分配块发送给每个工作者，只发送一次。这是在第 44 行完成的。
- en: via snow’s clusterApply() function, which we used earlier but need to get creative
    with here. In line 41, we define the function mcf(), which will, running Parallel
    R
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们之前使用但现在需要发挥创造性的 snow 的 clusterApply() 函数，我们在第 41 行定义了函数 mcf()，该函数将在并行 R
    中运行。
- en: '**339**'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '**339**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: on a worker, accept the worker’s chunk from the manager and then keep it as
    a global variable mchunk on the worker.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作者上，接受管理者的数据块并将其作为全局变量 mchunk 保留在工作者上。
- en: 'Line 46 makes use of a new snow function, clusterExport(), whose job it is
    to make copies of the manager’s global variables at the workers. The variable
    in question here is actually a function, dst(). Here is why we need to send it
    separately: The call in line 50 will send the function findnewgrps() to the workers,
    but although that function calls dst(), snow will not know to send the latter
    as well. Therefore we send it ourselves.'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 第 46 行使用了新的 snow 函数，clusterExport()，其任务是复制管理员的全局变量到工作者。这里的变量实际上是一个函数，dst()。我们需要单独发送它的原因如下：第
    50 行的调用会将函数 findnewgrps() 发送到工作者，尽管该函数调用了 dst()，但 snow 不会知道也要发送后者。因此，我们自行发送。
- en: Line 50 itself uses another new snow call, clusterCall(). This instructs each
    worker to call findnewgrps(), with centers as argument.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 第 50 行本身使用了另一个新的 snow 调用，clusterCall()。这指示每个工作者调用 findnewgrps()，其中 centers 作为参数。
- en: Recall that each worker has a different matrix chunk, so this call will work
    on different data for each worker. This once again brings up the controversy regarding
    the use of global variables, discussed in Section 7.8.4\.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个工作者都有一个不同的矩阵块，因此这个调用将针对每个工作者的不同数据进行操作。这再次引发了关于全局变量使用的争议，这在第 7.8.4 节中讨论过。
- en: Some software developers may be troubled by the use of a hidden argument in
    findnewgrps(). On the other hand, as mentioned earlier, using mchunk as an argument
    would mean sending it to the workers repeatedly, compromising performance.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件开发者可能会对 findnewgrps() 中使用隐藏参数感到困扰。另一方面，如前所述，使用 mchunk 作为参数意味着需要反复将其发送到工作者，这会损害性能。
- en: Finally, take a look at line 51\. The snow function clusterApply() always returns
    an R list. In this case, the return value is in sumcounts, each element of which
    is a matrix. We need to sum the matrices, producing a totals matrix.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看第 51 行。snow 函数 clusterApply() 总是返回一个 R 列表。在这种情况下，返回值在 sumcounts 中，每个元素都是一个矩阵。我们需要对矩阵进行求和，生成一个总计矩阵。
- en: Using R’s sum() function wouldn’t work, as it would total all the elements of
    the matrices into a single number. Matrix addition is what we need.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 的 sum() 函数是不行的，因为它会将矩阵的所有元素加起来变成一个单一的数字。我们需要的是矩阵加法。
- en: Calling R’s Reduce() function will do the matrix addition. Recall that any arithmetic
    operation in R is implemented as a function; in this case, it is implemented as
    the function "+". The recall to Reduce() then successively applies "+" to the
    elements of the list sumcounts. Of course, we could just write a loop to do this,
    but using Reduce() may give us a small performance boost.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 R 的 Reduce() 函数可以进行矩阵加法。回想一下，R 中的任何算术运算都是以函数的形式实现的；在这种情况下，它是以 "+" 函数的形式实现的。然后对
    Reduce() 的调用会依次将 "+" 应用到 sumcounts 列表的元素上。当然，我们也可以直接写一个循环来完成这个操作，但使用 Reduce()
    可能会给我们带来一点性能提升。
- en: '**16.3 Resorting to C**'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3 转向 C**'
- en: As you’ve seen, using parallel R may greatly speed up your R code. This allows
    you to retain the convenience and expressive power of R, while still ameliorating
    large runtimes in big applications. If the parallelized R gives you sufficiently
    good performance, then all is well.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用并行 R 可以大大加快你的 R 代码的执行速度。这允许你保留 R 的便利性和表达力，同时仍然可以改善大型应用程序中的长时间运行。如果并行化的
    R 给你足够好的性能，那么一切就都很好了。
- en: Nevertheless, parallel R is still R and thus still subject to the performance
    issues covered in Chapter 14\. Recall that one solution offered in that chapter
    was to write a performance-critical portion of your code in C and then call that
    code from your main R program. (The references to C here mean C or C++.) We will
    explore this from a parallel-processing viewpoint. Here, instead of writing parallel
    R, we write ordinary R code that calls parallel C. (I assume a knowledge of C.)
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并行 R 仍然是 R，因此仍然受到第 14 章中讨论的性能问题的影响。回想一下，在第 14 章中提供的一个解决方案是将代码的关键部分用 C 语言编写，然后从主
    R 程序中调用该代码。（这里的 C 指的是 C 或 C++。）我们将从并行处理的角度来探讨这个问题。在这里，我们不是编写并行 R 代码，而是编写调用并行 C
    的普通 R 代码。（我假设您了解 C 语言。）
- en: '***16.3.1 Using Multicore Machines***'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.1 使用多核机器***'
- en: The C code covered here runs only on multicore systems, so we must discuss the
    nature of such systems.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的 C 代码仅在多核系统上运行，因此我们必须讨论这类系统的本质。
- en: '**340**'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '**340**'
- en: Chapter 16
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: You are probably familiar with dual-core machines. Any computer includes a CPU,
    which is the part that actually runs your program. In essence, a dual-core machine
    has two CPUs, a quad-core system has four, and so on.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉双核机器。任何计算机都包含一个 CPU，这是实际运行您程序的部分。本质上，双核机器有两个 CPU，四核系统有四个，依此类推。
- en: With multiple cores, you can do parallel computation!
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 多核处理器允许进行并行计算！
- en: This parallel computation is done with *threads*, which are analogous to snow’s
    workers. In computationally intensive applications, you generally set up as many
    threads as there are cores, for example two threads in a dual-core machine. Ideally,
    these threads run simultaneously, though overhead issues do arise, as will be
    explained when we look at general performance issues in Section 16.4.1\.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 这种并行计算是通过 *线程* 来实现的，它们类似于雪的工人。在计算密集型应用中，通常设置的线程数与核心数相同，例如在双核机器上设置两个线程。理想情况下，这些线程可以同时运行，尽管会出现开销问题，这将在我们查看第
    16.4.1 节中的通用性能问题时进行解释。
- en: If your machine has multiple cores, it is structured as a *shared-memory* system.
    All cores access the same RAM. The shared nature of the memory makes communication
    between the cores easy to program. If a thread writes to a memory location, the
    change is visible to the other threads, without the programmer needing to insert
    code to make that happen.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器具有多个核心，它将结构化为一个 *共享内存* 系统。所有核心都访问相同的 RAM。内存的共享特性使得核心之间的通信易于编程。如果一个线程写入内存位置，该变化对其他线程可见，而无需程序员插入代码来实现这一点。
- en: '***16.3.2 Extended Example: Mutual Outlinks Problem in OpenMP***'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.2 扩展示例：OpenMP 中的互链问题***'
- en: OpenMP is a very popular package for programming on multicore machines.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 是一个在多核机器上编程的非常流行的包。
- en: 'To see how it works, here is the mutual outlinks example again, this time in
    R-callable OpenMP code:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，这里再次展示互链示例，这次是在可由 R 调用的 OpenMP 代码中：
- en: '1'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#include <omp.h>'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <omp.h>'
- en: '2'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '#include <R.h>'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h>'
- en: '3'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: int tot; // grand total of matches, over all threads
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: int tot; // 所有线程的匹配总计数
- en: '5'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: // processes row pairs (i,i+1), (i,i+2), ...
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: // 处理行对 (i,i+1)，(i,i+2)，...
- en: '7'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: int procpairs(int i, int *m, int n)
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: int procpairs(int i, int *m, int n)
- en: '8'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '{ int j,k,sum=0;'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int j,k,sum=0;'
- en: '9'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: for (j = i+1; j < n; j++) {
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: for (j = i+1; j < n; j++) {
- en: '10'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: for (k = 0; k < n; k++)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: for (k = 0; k < n; k++)
- en: '11'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: // find m[i][k]*m[j][k] but remember R uses col-major order
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: // find m[i][k]*m[j][k] but remember R uses col-major order
- en: '12'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: sum += m[n*k+i] * m[n*k+j];
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: sum += m[n*k+i] * m[n*k+j];
- en: '13'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '}'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '14'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: return sum;
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: return sum;
- en: '15'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '}'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '16'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: void mutlinks(int *m, int *n, double *mlmean)
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: void mutlinks(int *m, int *n, double *mlmean)
- en: '18'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '{ int nval = *n;'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int nval = *n;'
- en: '19'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: tot = 0;
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: tot = 0;
- en: '20'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '#pragma omp parallel'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp parallel'
- en: '21'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '{ int i,mysum=0,'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int i,mysum=0,'
- en: '22'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: me = omp_get_thread_num(),
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: me = omp_get_thread_num(),
- en: '23'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: nth = omp_get_num_threads();
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: nth = omp_get_num_threads();
- en: '24'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: // in checking all (i,j) pairs, partition the work according to i;
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: // 在检查所有 (i,j) 对时，根据 i 分配工作；
- en: '25'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: // this thread me will handle all i that equal me mod nth
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: // 此线程 me 将处理所有等于 me mod nth 的 i
- en: '26'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: for (i = me; i < nval; i += nth) {
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = me; i < nval; i += nth) {
- en: Parallel R
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R
- en: '**341**'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: '**341**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '27'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: mysum += procpairs(i,m,nval);
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(i,m,nval);
- en: '28'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '}'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '29'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: '#pragma omp atomic'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp atomic'
- en: '30'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: tot += mysum;
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: tot += mysum;
- en: '31'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '}'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '32'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: int divisor = nval * (nval-1) / 2;
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: int divisor = nval * (nval-1) / 2;
- en: '33'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '*mlmean = ((float) tot)/divisor;'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: '*mlmean = ((float) tot)/divisor;'
- en: '34'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '}'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '***16.3.3 Running the OpenMP Code***'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.3 运行 OpenMP 代码***'
- en: 'Again, compilation follows the recipe in Chapter 15\. We do need to link in
    the OpenMP library, though, by using the -fopenmp and -lgomp options. Suppose
    our source file is *romp.c*. Then we use the following commands to run the code:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，编译遵循第15章中的配方。不过，我们确实需要通过使用-fopenmp和-lgomp选项来链接OpenMP库。假设我们的源文件是*romp.c*。然后我们使用以下命令来运行代码：
- en: 'gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o
    gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp Here’s an
    R test:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o
    gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp 这里是一个R测试：
- en: dyn.load("romp.so")
  id: totrans-1860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("romp.so")
- en: Sys.setenv(OMP_NUM_THREADS=4)
  id: totrans-1861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Sys.setenv(OMP_NUM_THREADS=4)
- en: n <- 1000
  id: totrans-1862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n <- 1000
- en: m <- matrix(sample(0:1,n^2,replace=T),nrow=n)
  id: totrans-1863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- matrix(sample(0:1,n^2,replace=T),nrow=n)
- en: system.time(z <- .C("mutlinks",as.integer(m),as.integer(n),result=double(1)))
    user system elapsed
  id: totrans-1864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z <- .C("mutlinks",as.integer(m),as.integer(n),result=double(1)))
    user system elapsed
- en: '0.830'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '0.830'
- en: '0.000'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.218'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: '0.218'
- en: z$result
  id: totrans-1868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z$result
- en: '[1] 249.9471'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 249.9471'
- en: The typical way to specify the number of threads in OpenMP is through an operating
    system environment variable, OMP_NUM_THREADS. R is capable of setting operating
    system environment variables with the Sys.setenv() function. Here, I set the number
    of threads to 4, because I was running on a quad-core machine.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenMP中指定线程数量的典型方式是通过操作系统环境变量，OMP_NUM_THREADS。R能够通过Sys.setenv()函数设置操作系统环境变量。在这里，我将线程数设置为4，因为我正在一个四核机器上运行。
- en: Note the runtime—only 0.2 seconds! This compares to the 5.0-second
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运行时间——只有0.2秒！这比之前5.0秒的
- en: time we saw earlier for a 12-node snow system. This might be surprising to some
    readers, as our code in the snow version was vectorized to a fair degree, as mentioned
    earlier. Vectorizing is good, but again, R has many hidden sources of overhead,
    so C might do even better.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的12节点雪系统的时间。这可能会让一些读者感到惊讶，因为我们的代码在雪版本中已经相当程度地进行了向量化，如前所述。向量化是好的，但同样，R有很多隐藏的开销来源，所以C可能做得更好。
- en: '**NOTE**'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I tried R’s new byte-compilation function cmpfun(), but mtl() actually became
    slower.*'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '*我尝试了R的新字节编译函数cmpfun()，但mtl()实际上变慢了*。'
- en: Thus, if you are willing to write part of your code in parallel C, dramatic
    speedups may be possible.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你愿意用并行C编写你代码的一部分，可能会实现显著的加速。
- en: '**342**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '**342**'
- en: Chapter 16
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.3.4 OpenMP Code Analysis***'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.4 OpenMP代码分析***'
- en: OpenMP code is C, with the addition of *pragmas* that instruct the compiler
    to insert some library code to perform OpenMP operations. Look at line 20, for
    instance. When execution reaches this point, the threads will be activated. Each
    thread then executes the block that follows—lines 21 through 31—in parallel.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP代码是C，增加了*pragmas*，这些pragma指示编译器插入一些库代码以执行OpenMP操作。例如，看看第20行。当执行到达这个点时，线程将被激活。然后每个线程将并行执行随后的块——第21行到第31行。
- en: A key point is variable scope. All the variables within the block starting on
    line 21 are local to their specific threads. For example, we’ve named the total
    variable in line 21 mysum because each thread will maintain its own sum.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点是变量作用域。从第21行开始的块内的所有变量都是它们特定线程的局部变量。例如，我们之所以在第21行将总变量命名为mysum，是因为每个线程将维护自己的总和。
- en: By contrast, the global variable tot on line 4 is held in common by all the
    threads. Each thread makes its contribution to that grand total on line 30\.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第4行的全局变量tot被所有线程共享。每个线程在第30行对那个总和做出贡献。
- en: But even the variable nval on line 18 is held in common with all the threads
    (during the execution of mutlinks()), as it is declared outside the block beginning
    on line 21\. So, even though it is a local variable in terms of C scope, it is
    global to all the threads. Indeed, we could have declared tot on that line, too.
    It needs to be shared by all the threads, but since it’s not used outside mutlinks(),
    it could have been declared on line 18\.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使在第18行的变量nval也是与所有线程共享的（在mutlinks()执行期间），因为它是在第21行开始的块外部声明的。所以，尽管它从C的作用域角度来看是一个局部变量，但对于所有线程来说它是全局的。实际上，我们也可以在第21行声明tot。它需要被所有线程共享，但由于它不在mutlinks()外部使用，它可以在第18行声明。
- en: Line 29 contains another pragma, atomic. This one applies only to the single
    line following it—line 30, in this case—rather than to a whole block.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 第29行包含另一个pragma，atomic。这个pragma只适用于它后面的单行——在这个例子中是第30行——而不是整个块。
- en: The purpose of the atomic pragma is to avoid what is called a *race condition*
    in parallel-processing circles. This term describes a situation in which two threads
    are updating a variable at the same time, which may produce incorrect results.
    The atomic pragma ensures that line 30 will be executed by only one thread at
    a time. Note that this implies that in this section of the code, our parallel
    program becomes temporarily serial, which is a potential source of slowdown.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 原子预处理语句的目的是避免并行处理领域所说的“竞争条件”。这个术语描述了两个线程同时更新一个变量的情况，这可能会导致错误的结果。原子预处理语句确保一次只有一个线程执行第
    30 行。注意，这暗示了在这个代码段中，我们的并行程序暂时变成了串行，这可能是减慢速度的一个潜在原因。
- en: Where is the manager’s role in all of this? Actually, the manager is the original
    thread, and it executes lines 18 and 19, as well as .C(), the R function that
    makes the call to mutlinks(). When the worker threads are activated in line 21,
    the manager goes dormant. The worker threads become dormant once they finish line
    31\. At that point, the manager resumes execution. Due to the dormancy of the
    manager while the workers are executing, we do want to have as many workers as
    our machine has cores.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，管理者的角色在哪里？实际上，管理者是原始线程，它执行第 18 和 19 行，以及 .C()，这是调用 mutlinks() 的 R 函数。当工作线程在第
    21 行被激活时，管理者进入休眠状态。工作线程一旦完成第 31 行，就会进入休眠状态。在那个时刻，管理者恢复执行。由于管理者在工作线程执行期间处于休眠状态，我们希望有尽可能多的工作线程，就像机器的核数一样。
- en: 'The function procpairs() is straightforward, but note the manner in which the
    matrix m is being accessed. Recall from the discussion in Chapter 15 on interfacing
    R to C that the two languages store matrices differently: column by column in
    R and row-wise in C. We need to be aware of that difference here. In addition,
    we have treated the matrix m as a one-dimensional array, as is common in parallel
    C code. In other words, if n is, say, 4, then we treat m as a vector of 16 elements.
    Due to the column-major nature of R'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 procpairs() 很简单，但请注意访问矩阵 m 的方式。回想一下第 15 章关于 R 与 C 接口讨论中的内容，两种语言存储矩阵的方式不同：R
    中是按列存储，C 中是按行存储。我们需要注意这个差异。此外，我们将矩阵 m 作为一维数组处理，这在并行 C 代码中很常见。换句话说，如果 n 是，比如说，4，那么我们将
    m 视为一个包含 16 个元素的向量。由于 R 的列主序特性
- en: matrix storage, the vector will consist first of the four elements of column
    1, then the four of column 2, and so on. To further complicate matters, we must
    keep in mind that array indices in C start at 0, instead of starting at 1 as in
    R.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵存储，向量将首先包含第 1 列的四个元素，然后是第 2 列的四个元素，依此类推。为了进一步复杂化问题，我们必须记住，C 中的数组索引从 0 开始，而不是像
    R 中的那样从 1 开始。
- en: Putting all of this together yields the multiplication in line 12\. The factors
    here are the (k,i) and (k,j) elements of the version of m in the C code, which
    are the (i+1,k+1) and (j+1,k+1) elements back in the R code.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，就得到了第 12 行的乘法。这里的因子是 C 代码中 m 版本的 (k,i) 和 (k,j) 元素，在 R 代码中对应的是 (i+1,k+1)
    和 (j+1,k+1) 元素。
- en: Parallel R
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R
- en: '**343**'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '**343**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.3.5 Other OpenMP Pragmas***'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.5 其他 OpenMP 预处理器***'
- en: OpenMP includes a wide variety of possible operations—far too many to list here.
    This section provides an overview of some OpenMP pragmas that I consider especially
    useful.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 包含了各种各样的可能操作——多得无法在此一一列举。本节提供了我对一些特别有用的 OpenMP 预处理器的概述。
- en: '**16.3.5.1 The omp barrier Pragma**'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.1 omp barrier 预处理语句**'
- en: 'The parallel-processing term *barrier* refers to a line of code at which the
    threads rendezvous. The syntax for the omp barrier pragma is simple:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理术语 *屏障* 指的是线程会合的代码行。omp barrier 预处理语句的语法很简单：
- en: '#pragma omp barrier'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma omp barrier`'
- en: When a thread reaches a barrier, its execution is suspended until all other
    threads have reached that line. This is very useful for iterative algorithms;
    threads wait at a barrier at the end of every iteration.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程达到屏障时，它的执行会暂停，直到所有其他线程都到达那条线。这对于迭代算法非常有用；线程在每个迭代的末尾都在屏障处等待。
- en: Note that in addition to this explicit barrier invocation, some other pragmas
    place an implicit barrier following their blocks. These include single and parallel.
    There is an implied barrier immediately following line 31 in the previous listing,
    for example, which is why the manager stays dormant until all worker threads finish.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了这个显式的屏障调用之外，一些其他的预处理语句在其块之后放置了一个隐式的屏障。这些包括单线程和并行。例如，在前面的列表中，第 31 行之后立即有一个隐式的屏障，这就是为什么管理器保持休眠状态直到所有工作线程完成。
- en: '**16.3.5.2 The omp critical Pragma**'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.2 omp critical Pragma**'
- en: The block that follows this pragma is a *critical section*, meaning one in which
    only one thread is allowed to execute at a time. The omp critical pragma essentially
    serves the same purpose as the atomic pragma discussed earlier, except that the
    latter is limited to a single statement.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma之后的部分是一个*临界区*，意味着一次只允许一个线程执行。omp critical pragma基本上与前面讨论的atomic pragma具有相同的目的，只不过后者仅限于单个语句。
- en: '**NOTE**'
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The OpenMP designers defined a special pragma for this single-statement situation
    in* *the hope that the compiler can translate this to an especially fast machine
    instruction.*'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenMP的设计者定义了一个特殊的pragma来处理这种单语句情况，希望编译器可以将它转换为一个特别快速的机器指令。*'
- en: 'Here is the omp critical syntax:'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 这是omp critical语法的示例：
- en: '1'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#pragma omp critical'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp critical'
- en: '2'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: // place one or more statements here
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: // 在此处放置一个或多个语句
- en: '4'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '}'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**16.3.5.3 The omp single Pragma**'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.3 omp single Pragma**'
- en: 'The block that follows this pragma is to be executed by only one of the threads.
    Here is the syntax for the omp single pragma:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma之后的部分将由只有一个线程执行。以下是omp single pragma的语法：
- en: '1'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#pragma omp single'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp single'
- en: '2'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: // place one or more statements here
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: // 在此处放置一个或多个语句
- en: '4'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '}'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**344**'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: '**344**'
- en: Chapter 16
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This is useful for initializing sum variables that are shared by the threads,
    for instance. As noted earlier, an automatic barrier is placed after the block.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于初始化由线程共享的求和变量很有用。如前所述，在块之后放置了一个自动屏障。
- en: This should make sense to you. If one thread is initializing a sum, you wouldn’t
    want other threads that make use of this variable to continue execution until
    the sum has been properly set.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对你来说是有意义的。如果一个线程正在初始化求和，你不会希望使用这个变量的其他线程在求和被正确设置之前继续执行。
- en: You can learn more about OpenMP in my open source textbook on par-
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的开源教科书上了解更多关于OpenMP的信息，关于并行编程的——
- en: allel processing at *http://heather.cs.ucdavis.edu/parprocbook*.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: allel处理在*http://heather.cs.ucdavis.edu/parprocbook*。
- en: '***16.3.6 GPU Programming***'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.6 GPU编程***'
- en: Another type of shared-memory parallel hardware consists of graphics processing
    units (GPUs). If you have a sophisticated graphics card in your machine, say for
    playing games, you may not realize that it is also a very powerful computational
    device—so powerful that the slogan “A supercomputer on your desk!” is often used
    to refer to PCs equipped with high-end GPUs.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种共享内存并行硬件类型是图形处理单元（GPU）。如果你机器中有用于游戏的复杂显卡，你可能不会意识到它也是一个非常强大的计算设备——强大到经常用“桌面上的超级计算机！”这个口号来指代配备了高端GPU的PC。
- en: As with OpenMP, the idea here is that instead of writing parallel R, you write
    R code interfaced to parallel C. (Similar to the OpenMP case, *C*
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenMP一样，这里的想法是，你不需要编写并行R代码，而是编写与并行C接口的R代码。（与OpenMP的情况类似，*C*
- en: here means a slightly augmented version of the C language.) The technical details
    become rather complex, so I won’t show any code examples, but an overview of the
    platform is worthwhile.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 这里指的是C语言的略微增强版本。）技术细节变得相当复杂，所以我不展示任何代码示例，但对该平台的概述是值得的。
- en: As mentioned, GPUs do follow the shared-memory/threads model,
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GPU遵循共享内存/线程模型，
- en: but on a much larger scale. They have dozens, or even hundreds, of
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 但规模要大得多。它们有数十个，甚至数百个
- en: cores (depending on how you define *core*). One major difference is that several
    threads can be run together in a block, which can produce certain efficiencies.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 核心（取决于你如何定义*核心*）。一个主要区别是，可以在一个块中同时运行多个线程，这可以产生一定的效率。
- en: Programs that access GPUs begin their run on your machine’s CPU,
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GPU的程序从你机器的CPU开始运行，
- en: referred to as the *host*. They then start code running on the GPU, or *device*.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*主机*。然后它们在GPU上启动代码，或*设备*。
- en: This means that your data must be transferred from the host to the device, and
    after the device finishes its computation, the results must be transferred back
    to the host.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的数据必须从主机传输到设备，设备完成计算后，结果必须传输回主机。
- en: As of this writing, GPU has not yet become common among R users.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，GPU尚未在R用户中变得普遍。
- en: The most common usage is probably through the CRAN package gputools, which consists
    of some matrix algebra and statistical routines callable from R. For instance,
    consider matrix inversion. R provides the function solve() for this, but a parallel
    alternative is available in gputools with the name gpuSolve().
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的使用方式可能是通过CRAN包gputools，它包含一些可以从R调用的矩阵代数和统计例程。例如，考虑矩阵求逆。R提供了solve()函数来完成这个任务，但在gputools中有一个名为gpuSolve()的并行替代方案。
- en: For more about GPU programming, again see my book on parallel pro-
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GPU编程的更多信息，请再次参阅我关于并行编程的书籍。
- en: cessing at *http://heather.cs.ucdavis.edu/parprocbook*.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *http://heather.cs.ucdavis.edu/parprocbook* 处处理。
- en: '**16.4 General Performance Considerations**'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4 一般性能考虑**'
- en: This section discusses some issues that you may find generally useful in parallelizing
    R applications. I’ll present some material on the main sources of overhead and
    then discuss a couple of algorithmic issues.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了一些在并行化R应用时可能普遍有用的问题。我将介绍关于主要负载来源的一些材料，然后讨论几个算法问题。
- en: Parallel R
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R
- en: '**345**'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: '**345**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.4.1 Sources of Overhead***'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.1 负载来源***'
- en: Having at least a rough idea of the physical causes of overhead is essential
    to successful parallel programming. Let’s take a look at these in the contexts
    of the two main platforms, shared-memory and networked computers.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 了解开销的物理原因对于成功的并行编程至关重要。让我们从共享内存和网络计算机这两个主要平台的角度来看看这些问题。
- en: '**16.4.1.1 Shared-Memory Machines**'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.1.1 共享内存机器**'
- en: As noted earlier, the memory sharing in multicore machines makes for easier
    programming. However, the sharing also produces overhead, since the two cores
    will bump into each other if they both try to access memory at the same time.
    This means that one of them will need to wait, causing overhead. That overhead
    is typically in the range of hundreds of nanoseconds (billionths of seconds).
    This sounds really small, but keep in mind that the CPU is working at a subnanosecond
    speed, so memory access often becomes a bottleneck.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多核机器中的内存共享使得编程更容易。然而，共享也会产生开销，因为如果两个核心同时尝试访问内存，它们会相互冲突。这意味着其中一个需要等待，从而产生开销。这种开销通常在数百纳秒（秒的十亿分之一）的范围内。这听起来真的很小，但请记住，CPU以亚纳秒的速度工作，所以内存访问经常成为瓶颈。
- en: Each core may also have a *cache*, in which it keeps a local copy of some of
    the shared memory. It’s intended to reduce contention for memory among the cores,
    but it produces its own overhead, involving time spent in keeping the caches consistent
    with each other.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 每个核心也可能有一个*缓存*，其中它保留了一些共享内存的本地副本。它的目的是减少核心之间的内存竞争，但它会产生自己的开销，包括保持缓存之间一致性的时间开销。
- en: Recall that GPUs are special types of multicore machines. As such, they suffer
    from the problems I’ve described, and more. First, the *latency*, which is the
    time delay before the first bit arrives at the GPU from its memory after a memory
    read request, is quite long in GPUs.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，GPU是特殊的多核机器。因此，它们会遭受我描述的问题，以及更多。首先，*延迟*，即从内存读取请求后，第一个比特到达GPU的时间延迟，在GPU中相当长。
- en: There is also the overhead incurred in transferring data between the host and
    the device. The latency here is on the order of microseconds (millionths of seconds),
    an eternity compared to the nanosecond scale of the CPU and GPU.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机和设备之间传输数据时，也会产生开销。这里的延迟在微秒（百万分之一秒）的量级，与CPU和GPU的纳秒尺度相比，这是一个永恒的时间。
- en: GPUs have great performance potential for certain classes of applications, but
    overhead can be a major issue. The authors of gputools note that their matrix
    operations start achieving a speedup only at matrix sizes of 1000
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: GPU对于某些类别的应用具有巨大的性能潜力，但开销可能是一个主要问题。gputools的作者指出，他们的矩阵运算只有在矩阵大小达到1000时才开始实现加速。
- en: by 1000\. I wrote a GPU version of our mutual outlinks application, which turned
    out to have a runtime of 3.0 seconds—about half of the snow version but still
    far slower than the OpenMP implementation.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 通过1000个例子。我编写了我们共同链接应用的GPU版本，其运行时间为3.0秒——大约是雪版的一半，但仍然比OpenMP实现慢得多。
- en: Again, there are ways of ameliorating these problems, but they require very
    careful, creative programming and a sophisticated knowledge of the physical GPU
    structure.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有方法可以缓解这些问题，但它们需要非常仔细、有创造性的编程和深入了解物理GPU结构。
- en: '**16.4.1.2 Networked Systems of Computers**'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.1.2 计算机网络系统**'
- en: As you saw earlier, another way to achieve parallel computation is through networked
    systems of computers. You still have multiple CPUs, but in this case, they are
    in entirely separate computers, each with its own memory.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，实现并行计算的另一种方式是通过计算机网络系统。您仍然有多个CPU，但在这个案例中，它们位于完全独立的计算机中，每个计算机都有自己的内存。
- en: As pointed out earlier, network data transfer causes overhead. Its latency is
    again on the order of microseconds. Thus, even accessing a small amount of data
    across the network incurs a major delay.
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网络数据传输会产生开销。其延迟再次在微秒级别。因此，即使通过网络访问少量数据也会产生很大的延迟。
- en: Also note that snow has additional overhead, as it changes numeric
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，雪有额外的开销，因为它会改变数值
- en: objects such as vectors and matrices to character form before sending them,
    say from the manager to the workers. Not only does this entail time for the conversion
    (both in changing from numeric to character form and **346**
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送之前将对象如向量和矩阵转换为字符形式，比如说从管理者到工作者。这不仅涉及到转换的时间（无论是从数值形式转换为字符形式还是**346**）
- en: Chapter 16
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: in charging back to numeric at the receiver), but the character form tends to
    make for much longer messages, thus longer network transfer time.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端重新计算数值时)，但字符形式往往会导致消息更长，从而增加网络传输时间。
- en: Shared-memory systems can be networked together, which, in fact, we did in the
    previous example. We had a hybrid situation in which we formed snow clusters from
    several networked dual-core computers.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存系统可以联网，实际上，我们在前面的例子中就是这样做的。我们有一个混合情况，即从几个联网的双核计算机中形成了雪簇。
- en: '***16.4.2 Embarrassingly Parallel Applications and Those That Aren’t***'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.2 令人尴尬的并行应用和那些不是的应用***'
- en: It’s no shame to be poor, but it’s no great honor either.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 贫穷并不丢人，但也不算是什么荣耀。
- en: —Tevye, *Fiddler on the Roof*
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: ——Tevye，《屋顶上的提琴手》
- en: Man is the only animal that blushes, or needs to.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是唯一会脸红，或者需要脸红的动物。
- en: —Mark Twain
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: ——马克·吐温
- en: The term *embarrassingly parallel* is heard often in talk about parallel R
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于并行R的讨论中，经常听到“令人尴尬的并行”这个术语。
- en: (and in the parallel processing field in general). The word *embarrassing* alludes
    to the fact that the problems are so easy to parallelize that there is no intellectual
    challenge involved; they are embarrassingly easy.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: （以及在并行处理领域）。单词“尴尬”暗示了这样一个事实，即问题如此容易并行化，以至于其中不涉及任何智力挑战；它们是尴尬地容易。
- en: Both of the example applications we’ve looked at here would be con-
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里查看的两个示例应用都会是
- en: sidered embarrassingly parallel. Parallelizing the for i loop for the mutual
    outlinks problem in Section 16.1 was pretty obvious. Partitioning the work in
    the KMC example in Section 16.2.4 was also natural and easy.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是令人尴尬的并行。在16.1节中，对互连出链问题的for i循环进行并行化是非常明显的。在16.2.4节中，KMC示例中的工作划分也是自然且容易的。
- en: By contrast, most parallel sorting algorithms require a great deal of interaction.
    For instance, consider merge sort, a common method of sorting numbers. It breaks
    the vector to be sorted into two (or more) independent parts, say the left half
    and right half, which are then sorted in parallel by two processes. So far, this
    is embarrassingly parallel, at least after the vector is divided in half. But
    then the two sorted halves must be merged to produce the sorted version of the
    original vector, and that process is *not* embarrassingly parallel. It can be
    parallelized but in a more complex manner.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，大多数并行排序算法需要大量的交互。例如，考虑归并排序，这是一种常见的排序数字的方法。它将待排序的向量分成两个（或更多）独立的部分，比如左半部分和右半部分，然后由两个进程并行排序。到目前为止，这是令人尴尬的并行，至少在向量被分成一半之后。但是，然后必须将两个已排序的半部分合并以产生原始向量的排序版本，而这个过程**不是**令人尴尬的并行。它可以并行化，但方式更为复杂。
- en: Of course, to paraphrase Tevye, it’s no shame to have an embarrassingly parallel
    problem! It may not exactly be an honor, but it is a cause for cele-bration, as
    it is easy to program. More important, embarrassingly parallel problems tend to
    have low communication overhead, which is crucial to performance, as discussed
    earlier. In fact, when most people refer to embarrassingly parallel applications,
    they have this low overhead in mind.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用Tevye的话来说，有一个令人尴尬的并行问题并不丢人！这也许并不完全是一种荣誉，但它是值得庆祝的，因为它容易编程。更重要的是，令人尴尬的并行问题通常具有低通信开销，正如前面讨论的那样，这对于性能至关重要。事实上，当大多数人提到令人尴尬的并行应用时，他们心中想的正是这种低开销。
- en: 'But what about nonembarrassingly parallel applications? Unfortunately, parallel
    R code is simply not suitable for many of them for a very basic reason: the functional
    programming nature of R. As discussed in Section 14.3, a statement like this:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于非令人尴尬的并行应用呢？不幸的是，由于R的函数式编程特性，并行R代码对于许多这样的应用来说并不适合，这是一个非常基本的原因：如第14.3节所述，一个像这样的语句：
- en: x[3] <- 8
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: x[3] <- 8
- en: is deceptively simple, because it can cause the entire vector x to be rewritten.
    This really compounds communication traffic problems. Accordingly, if your application
    is not embarrassingly parallel, your best strategy is probably to write the computationally
    intensive parts of the code in C, say using OpenMP or GPU programming.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 是表面上很简单，因为它可能导致整个向量x被重写。这实际上加剧了通信流量问题。因此，如果你的应用不是令人尴尬的并行，你的最佳策略可能是将代码的计算密集部分用C编写，例如使用OpenMP或GPU编程。
- en: Parallel R
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R
- en: '**347**'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: '**347**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Also, note carefully that even being embarrassingly parallel does not make an
    algorithm efficient. Some such algorithms can still have significant communication
    traffic, thus compromising performance.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，即使是令人尴尬的并行化也不一定使算法高效。某些这样的算法仍然可能存在大量的通信流量，从而影响性能。
- en: Consider the KMC problem, run under snow. Suppose we were to set
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在雪地中运行的KMC问题。假设我们要设置
- en: up a large enough number of workers so that each worker had relatively little
    work to do. In that case, the communication with the manager after each iteration
    would become a signficant portion of run time. In this situation, we would say
    that the *granularity* is too fine, and then probably switch to using fewer workers.
    We would then have larger tasks for each worker, thus a *coarser* granularity.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 增加足够多的工人，以便每个工人有相对较少的工作要做。在这种情况下，每次迭代后与经理的通信将变成运行时间的一个很大部分。在这种情况下，我们会说粒度太细，然后可能切换到使用更少的工人。这样，每个工人的任务就会更大，因此粒度会更**粗**。
- en: '***16.4.3 Static Versus Dynamic Task Assignment***'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.3 静态与动态任务分配***'
- en: Look again at the loop beginning on line 26 of our OpenMP example,
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的OpenMP示例的第26行开始的循环，
- en: 'reproduced here for convenience:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容为方便查阅而复制：
- en: for (i = me; i < nval; i += nth) {
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = me; i < nval; i += nth) {
- en: mysum += procpairs(i,m,nval);
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(i,m,nval);
- en: '}'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The variable me here was the thread number, so the effect of this code was that
    the various threads would work on nonoverlapping sets of values of i. We do want
    the values to be nonoverlapping, to avoid duplicate work and an incorrect count
    of total number of links, so the code was fine. But the point now is that we were,
    in effect, preassigning the tasks that each thread would handle. This is called
    *static* assignment.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变量me是线程号，因此这段代码的效果是各个线程将工作在i的值的非重叠集合上。我们确实希望这些值是非重叠的，以避免重复工作和总链接数的错误计数，所以代码是好的。但现在的问题是，我们实际上是在预先分配每个线程要处理的任务。这被称为**静态**分配。
- en: 'An alternative approach is to revise the for loop to look something like this:'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是修改for循环，使其看起来像这样：
- en: int nexti = 0; // global variable
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: int nexti = 0; // 全局变量
- en: '...'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: for ( ; myi < n; ) { // revised "for" loop
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: for ( ; myi < n; ) { // 修改后的"for"循环
- en: '#pragma omp critical'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp critical'
- en: '{'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: nexti += 1;
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: nexti += 1;
- en: myi = nexti;
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: myi = nexti;
- en: '}'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (myi < n) {
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: if (myi < n) {
- en: mysum += procpairs(myi,m,nval);
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(myi,m,nval);
- en: '...'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: This is *dynamic* task assignment, in which it is not determined ahead of time
    which threads handle which values of i. Task assignment is done during execution.
    At first glance, dynamic assignment seems to have the potential for better performance.
    Suppose, for instance, that in a static assignment **348**
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种**动态**的任务分配，其中在执行之前并没有确定哪些线程处理哪些i的值。任务分配是在执行过程中完成的。乍一看，动态分配似乎有更好的性能潜力。例如，假设在静态分配中**348**
- en: Chapter 16
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: setting, one thread finishes its last value of i early, while another thread
    still has two values of i left to do. This would mean our program would finish
    somewhat later than it could. In parallel-processing parlance, we would have a
    *load balance* problem. With dynamic assignment, the thread that finished when
    there were two values of i left to handle could have taken up one of those values
    itself. We would have better balance and theoretically less overall runtime.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 设置时，一个线程提前完成了其最后一个i的值，而另一个线程还有两个i的值未完成。这意味着我们的程序可能会比预期晚一些完成。在并行处理术语中，我们会遇到一个*负载平衡*问题。使用动态分配，当还剩下两个i的值要处理时，完成工作的线程可以自己承担其中一个值。这样我们会获得更好的平衡，并且理论上整体运行时间会更短。
- en: But don’t jump to conclusions. As always, we have the overhead issue to reckon
    with. Recall that a critical pragma, used in the dynamic version of the code above,
    has the effect of temporarily rendering the program serial rather than parallel,
    thus causing a slowdown. In addition, for reasons too technical to discuss here,
    these pragmas may cause considerable cache activity overhead. So in the end, the
    dynamic code could actually be substantially slower than the static version.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要急于下结论。像往常一样，我们还有开销问题要考虑。回想一下，上面代码的动态版本中使用的临界pragma会暂时将程序变为串行而不是并行，从而造成速度减慢。此外，由于这里讨论的技术原因过于复杂，这些pragma可能会引起相当大的缓存活动开销。因此，最终，动态代码实际上可能比静态版本慢得多。
- en: Various solutions to this problem have been developed, such as an
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发出各种解决这个问题的方法，例如一个
- en: OpenMP construct named guided. But rather than present these, the point I wish
    to make is that they are unnecessary. In most situations, static assignment is
    just fine. Why is this the case?
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP中名为guided的构造。但我不想介绍这些，我想说的是，它们是不必要的。在大多数情况下，静态分配就足够好了。为什么是这样呢？
- en: 'You may recall that the standard deviation of the sum of independent, identically
    distributed random variables, divided by the mean of that sum, goes to zero as
    the number of terms goes to infinity. In other words, sums are approximately constant.
    This has a direct implication for our load-balancing concerns: Since the total
    work time for a thread in static assignment is the sum of its individual task
    times, that total work time will be approximately constant; there will be very
    little variation from thread to thread. Thus, they will all finish at pretty close
    to the same time, and we do not need to worry about load imbalance. Dynamic scheduling
    will not be necessary.'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，独立同分布随机变量的总和的标准差，除以该总和的均值，当项数趋于无穷大时趋近于零。换句话说，总和是近似恒定的。这对我们的负载平衡问题有直接影响：由于静态分配中线程的总工作时间是其各个任务时间的总和，因此总工作时间将近似恒定；线程之间的差异将非常小。因此，它们将几乎同时完成，我们不需要担心负载不平衡。动态调度将不是必要的。
- en: 'This reasoning does depend on a statistical assumption, but in practice, the
    assumption will typically be met sufficiently well for the outcome: Static scheduling
    does as well as dynamic in terms of uniformity of total work times across threads.
    And since static scheduling doesn’t have the overhead problems of the dynamic
    kind, in most cases the static approach will give better performance.'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理依赖于一个统计假设，但在实践中，这个假设通常能够很好地满足结果：在总工作时间的均匀性方面，静态调度与动态调度相当。而且由于静态调度没有动态调度那样的开销问题，在大多数情况下，静态方法将提供更好的性能。
- en: 'There is one more aspect of this to discuss. To illustrate the issue, consider
    again the mutual outlinks example. Let’s review the outline of the algorithm:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于这个问题的更多方面需要讨论。为了说明问题，再次考虑互链示例。让我们回顾一下算法的大纲：
- en: '1'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sum = 0
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: sum = 0
- en: '2'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: for i = 0...n-1
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: for i = 0...n-1
- en: '3'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: for j = i+1...n-1
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: for j = i+1...n-1
- en: '4'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
- en: '5'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mean = sum / (n*(n-1)/2)
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: mean = sum / (n*(n-1)/2)
- en: Say n is 10000 and we have four threads, and consider ways to partition the
    for i loop. Naively, we might at first decide to have thread 0 handle the i values
    0 through 2499, thread 1 handle 2500 through 4999, and so on.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 假设n是10000，我们有四个线程，考虑如何划分for i循环。一开始，我们可能决定让线程0处理i值0到2499，线程1处理2500到4999，依此类推。
- en: However, this would produce a severe load imbalance, since the thread that Parallel
    R
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致严重的负载不平衡，因为并行R
- en: '**349**'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: '**349**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'handles a given value of i does an amount of work proportional to n-i. That,
    in fact, is why we staggered the values of i in our actual code: Thread 0 handled
    the i values 0, 4, 8 ..., thread 1 worked on 1, 5, 9, ..., and so on, yielding
    good load balance.'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: The point then is that static assignment might require a bit more plan-ning.
    One general approach to this is to randomly assign tasks (i values, in our case
    here) to threads (still doing so at the outset, before work begins).
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: With a bit of forethought such as this, static assignment should work well in
    most applications.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: '***16.4.4 Software Alchemy: Turning General Problems into Embarrassingly***'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: '***Parallel Ones***'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, it’s difficult to attain good performance from nonembarrassingly
    parallel algorithms. Fortunately, for statistical applications, there is a way
    to turn nonembarrassingly parallel problems into embarrassingly parallel ones.
    The key is to exploit some statistical properties.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the method, let’s once again turn to our mutual out-
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: 'links problem. The method, applied with w workers on a links matrix m, consists
    of the following:'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: Break the rows of m into w chunks.
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: Have each worker find the mean number of mutual outlinks for pairs of vertices
    in its chunk.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: Average the results returned by the workers.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: It can be shown mathematically that for large problems (the only ones you would
    need parallel computing for anyway), this chunked approach gives the estimators
    of the same statistical accuracy as in the nonchunked method. But meanwhile, we’ve
    turned a nonparallel problem into not just a parallel one but an embarrassingly
    parallel one! The workers in the preceding outline compute entirely independently
    of each other.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
- en: This method should not be confused with the usual chunk-based
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: approaches in parallel processing. In those, such as the merge-sort example
    discussed on page 347, the chunking is embarrassingly parallel, but the combining
    of results is not. By contrast, here the combining of results consists of simple
    averaging, thanks to the mathematical theory.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: I tried this approach on the mutual outlinks problem in a 4-worker snow cluster.
    This reduced the runtime to 1.5 seconds. This is far better than the serial time
    of about 16 seconds, double the speedup obtained by the GPU
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
- en: and approaching comparability to the OpenMP time. And the theory showing that
    the two methods give the same statistical accuracy was confirmed as well. The
    chunked method found the mean number of mutual outlinks to be 249.2881, compared
    to 249.2993 for the original estimator.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: '**350**'
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5 Debugging Parallel R Code**'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R packages such as Rmpi, snow, foreach, and so on do not set up a terminal
    window for each process, thus making it impossible to use R’s debugger on the
    workers. (My Rdsm package, which adds a threads capability to R, is an exception
    to this.)
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: What then can you do to debug apps for those packages? Let’s consider snow for
    a concrete example.
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
- en: First, you should debug the underlying single-worker function, such as mtl()
    in Section 16.2\. Here, we would set up some artificial values of the arguments
    and then use R’s ordinary debugging facilities.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the underlying function may be sufficient. However, the bug may be
    in the arguments themselves or in the way we set them up. Then things get more
    difficult.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: It’s even hard to print out trace information, such as values of variables,
    since print() won’t work in the worker processes. The message() function may work
    for some of these packages; if not, you may need to resort to using cat() to write
    to a file.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: '**351**'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](index-379_1.png)'
  id: totrans-2066
  prefs: []
  type: TYPE_IMG
- en: '**A**'
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
- en: '**INSTALLING R**'
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: This appendix covers the methods for
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
- en: installing R on your system. You can eas-
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: ily download and install the precompiled
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
- en: binaries, use your package manager on a UNIX-
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
- en: based system, or even install from source if you prefer.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: '**A.1 Downloading R from CRAN**'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
- en: R, in both its base form and user-written packages, is available on the Comprehensive
    R Archive Network (CRAN) at the R home page, *http://www*
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: '*.r-project.org/*. Click CRAN and choose a site near you to download the appropriate
    base package for your operating system (OS).'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: For most users, installing R is quite simple, regardless of the platform.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: You can find precompiled binaries for Windows, Linux, and Mac OS X on CRAN.
    You should be able to simply download the appropriate file and install R.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: '**A.2 Installing from a Linux Package Manager**'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using the precompiled binaries, if you’re running a Linux distribution
    with a centralized package repository, such as Fedora or Ubuntu, you
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: 'can install R using your OS’s package manager. For example, if you’re running
    Fedora, you can install R by typing the following at the command line: $ yum install
    R'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: For a Debian-based system, such as Ubuntu, the command looks
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install r-base
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: Check your distribution’s documentation for more details on installing and removing
    packages.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: '**A.3 Installing from Source**'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux or other UNIX-based machines (probably including Mac OS X), you can
    also compile R’s source code yourself. Simply unpack the source archive and follow
    the classic three-command installation procedure: $ configure'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
- en: $ make
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: $ make install
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may need to run make install as root, depending on your write
    permissions and the location to which you’re installing R. If you want to install
    to a nonstandard directory, say */a/b/c*, you can run configure with the --prefix
    parameter, like this:'
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
- en: $ configure --prefix=/a/b/c
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: This might be helpful if you’re working on a shared machine and don’t have write
    permissions to the standard installation directories like */usr*.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '**354**'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 45](index-381_1.png)'
  id: totrans-2097
  prefs: []
  type: TYPE_IMG
  zh: '![Image 45](index-381_1.png)'
- en: '**B**'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**'
- en: '**INSTALLING AND USING PACKAGES**'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装和使用包**'
- en: One of the major strengths of R is that
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: R的一个主要优势是
- en: thousands of user-written packages are
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 数千个用户编写的包
- en: available on the Comprehensive R Archive
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 在综合R存档
- en: Network (CRAN) at the R home page, *http://*
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 网络（CRAN）在R主页上，*http://*
- en: '*www.r-project.org/*. Package installation is easy in most'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.r-project.org/*. R包的安装在大多数情况下都很简单'
- en: cases, but there are nuances to be aware of for some of
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 的情况下，但需要注意一些细微差别
- en: the specialty packages.
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些专业包。
- en: This appendix starts with some package basics and then explains how to load
    R packages from your hard drive and from the Web.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录首先介绍一些包的基本知识，然后解释如何从你的硬盘驱动器和网络加载R包。
- en: '**B.1 Package Basics**'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.1 包的基本知识**'
- en: R uses packages to store groups of related pieces of software. The packages
    that are included with the R distribution are visible as subdirectories of your
    *library* directory in your R installation tree, as in */usr/lib/R/library*.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: R使用包来存储相关软件的组。包含在R发行版中的包作为你的R安装树中 *library* 目录的子目录可见，例如 */usr/lib/R/library*。
- en: '**NOTE**'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the R community, the term* library *is often used in place of* package
    *.*'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: '*在R社区中，术语* library *通常用来代替* package *.*'
- en: Some packages are loaded automatically when you start R, such as the *base*
    subdirectory. However, in order to save memory and time, R does not load all available
    packages automatically.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包在启动R时会自动加载，例如 *base* 子目录。然而，为了节省内存和时间，R不会自动加载所有可用的包。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can check which packages are currently loaded by typing this:'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容来检查当前加载了哪些包：
- en: .path.package()
  id: totrans-2115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .path.package()
- en: '**B.2 Loading a Package from Your Hard Drive**'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.2 从你的硬盘驱动器加载包**'
- en: 'If you need a package that is in your R installation but not loaded into memory
    yet, you can load it using the library() function. For instance, suppose you wish
    to generate multivariate normal random vectors. The function mvrnorm() in the
    package MASS does this. So, load the package as follows:'
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个在R安装中但尚未加载到内存中的包，你可以使用 library() 函数来加载它。例如，假设你希望生成多元正态随机向量。MASS包中的 mvrnorm()
    函数可以做到这一点。所以，按照以下方式加载包：
- en: library(MASS)
  id: totrans-2118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(MASS)
- en: The mvrnorm() function will now be ready to use. And so will its documentation
    (before you loaded MASS, entering help(mvrnorm) would have generated an error
    message).
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: mvrnorm() 函数现在可以使用了。它的文档也可以使用（在你加载MASS之前，输入 help(mvrnorm) 会生成一个错误信息）。
- en: '**B.3 Downloading a Package from the Web**'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.3 从网络下载包**'
- en: The package you want may not be in your R installation. One of the big advantages
    of open source software is that people love to share. People all over the world
    have written their own special-purpose R packages, placing them in the CRAN repository
    and elsewhere.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的包可能不在你的R安装中。开源软件的一个主要优势是人们喜欢分享。世界各地的人们都编写了自己的专用R包，并将它们放置在CRAN仓库和其他地方。
- en: '**NOTE**'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*User contributions to CRAN go through a vetting process and are generally
    of high* *quality. They are, however, not tested as throughly as R itself.*'
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户对CRAN的贡献会经过审查过程，通常质量很高。然而，它们并没有像R本身那样经过彻底的测试。*'
- en: '***B.3.1 Installing Packages Automatically***'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3.1 自动安装包***'
- en: One way to install a package is to use the install_packages() function. For
    example, suppose you wish to use the mvtnorm package, which computes multivariate
    normal cumulative distribution functions and other quantities.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包的一种方法是使用 install_packages() 函数。例如，假设你希望使用 mvtnorm 包，该包计算多元正态累积分布函数和其他量。
- en: 'First, choose a directory in which you wish to install the package (and maybe
    others in the future), say */a/b/c*. Then at the R prompt, type this:'
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一个你希望安装包（以及未来可能的其他包）的目录，比如 */a/b/c*。然后在R提示符下，输入以下内容：
- en: install.packages("mvtnorm","/a/b/c/")
  id: totrans-2127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: install.packages("mvtnorm","/a/b/c/")
- en: 'This will cause R to automatically go to CRAN, download the package, compile
    it, and load it into a new directory: */a/b/c/mvtnorm*.'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致R自动前往CRAN，下载包，编译它，并将其加载到新的目录中：*/a/b/c/mvtnorm*。
- en: 'You do need to tell R where to find that package once it’s installed, which
    you can do via the .libPaths() function:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉R在哪里可以找到已安装的包，这可以通过 .libPaths() 函数来完成：
- en: .libPaths("/a/b/c/")
  id: totrans-2130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .libPaths("/a/b/c/")
- en: This will add that new directory to the ones R was already using. If you use
    that directory often enough, you may wish to add that call to .libPaths() in your
    *.Rprofile* startup file in your home directory.
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将新目录添加到 R 已经使用的目录中。如果你经常使用该目录，你可能希望将此调用添加到你的家目录中的 *.Rprofile* 启动文件中。
- en: '**356**'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: '**356**'
- en: Appendix B
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: A call to .libPaths() without an argument will show you a list of all the places
    R will currently look for loading a package when requested.
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数的 .libPaths() 调用将显示 R 在请求加载包时当前会查找的所有位置。
- en: '***B.3.2 Installing Packages Manually***'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3.2 手动安装包***'
- en: Sometimes you need to install “by hand” to make modifications required to make
    a particular R package work on your system. The following example demonstrates
    how I did so in one particular instance, and it will serve as a case study on
    handling situations in which ordinary methods don’t work.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要手动安装以进行必要的修改，使特定的 R 包能在你的系统上运行。以下示例展示了我在一个特定情况下是如何做到这一点的，这将成为一个关于处理常规方法不起作用的情形的案例研究。
- en: '**NOTE**'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Situations in which you need to install packages by hand typically are operating
    system* *dependent and require more computer expertise than is generally assumed
    in this book.*'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: '*需要手动安装包的情况通常与操作系统相关，并且需要比本书中通常假设的更多计算机专业知识。*'
- en: '*For help in very specific cases, the* r-help *mailing list is invaluable.
    To access it, go to* *the R home page (* http://www.r-project.org/ *), click the
    FAQs link and then the R*'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于非常具体的情况的帮助，r-help 邮件列表非常有价值。要访问它，请访问 R 主页 (* http://www.r-project.org/ *)，点击
    FAQs 链接，然后点击 R*'
- en: '*FAQ link, and scroll down to Section 2.9, “What mailing lists exist for R?”*'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: '*FAQ 链接，并滚动到第 2.9 节，“存在哪些 R 的邮件列表？”*'
- en: I wanted to install the Rmpi package on our department’s instructional machines
    in the directory */home/matloff/R*. I tried using install.packages() first but
    found that the automated process could not find the MPI library on our machines.
    The problem was that R was looking for those files in
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在我们的系的教学机器上目录 */home/matloff/R* 中安装 Rmpi 包。我首先尝试使用 install.packages()，但发现自动过程无法在我们的机器上找到
    MPI 库。问题在于 R 正在寻找这些文件的位置
- en: '*/usr/local/lam*, whereas I knew they were in */usr/local/LAM*. Since these
    were public machines, not my own, I did not have the authority to change the name.
    So, I downloaded the Rmpi files in the packed form *Rmpi_0.5-3*'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/local/lam*，而我知道它们在 */usr/local/LAM* 中。由于这些是公共机器，不是我的，我没有权限更改名称。因此，我下载了打包形式的
    Rmpi 文件 *Rmpi_0.5-3*'
- en: '*.tar.gz*. I unpacked that file in my directory *~/tmp*, producing a directory
    named *~/tmp/Rmpi*.'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: '*.tar.gz*. 我在我的目录 *~/tmp* 中解压了该文件，生成了一个名为 *~/tmp/Rmpi* 的目录。'
- en: 'If I had not experienced this problem, at this point, I could have just typed
    the following in a terminal window from within the *~/tmp* directory: R CMD INSTALL
    -l /home/matloff/R Rmpi'
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有遇到这个问题，在这个时候，我只需在 *~/tmp* 目录下的终端窗口中键入以下命令即可：R CMD INSTALL -l /home/matloff/R
    Rmpi
- en: That command would install the package contained in *~/tmp/Rmpi*, placing it
    in */home/matloff/R*. This would have been an alternative to calling install.packages().
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装 *~/tmp/Rmpi* 中包含的包，并将其放置在 */home/matloff/R* 中。这将是一个调用 install.packages()
    的替代方案。
- en: 'But as noted, I had to deal with a problem. Within the *~/tmp/Rmpi* directory,
    there was a *configure* file, so I ran this command on my Linux command line:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如所注，我必须处理一个问题。在 *~/tmp/Rmpi* 目录中，有一个 *configure* 文件，因此我在 Linux 命令行上运行了这个命令：
- en: configure --help
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: configure --help
- en: 'It told me that I could specify the location of my MPI files to configure,
    as follows:'
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我我可以指定配置时 MPI 文件的位置，如下所示：
- en: configure --with-mpi=/usr/local/LAM
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: configure --with-mpi=/usr/local/LAM
- en: 'This applies if you run configure directly, but I ran it via R:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于你直接运行 configure 的情况，但我通过 R 运行的：
- en: R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM
- en: Installing and Using Packages
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和使用包
- en: '**357**'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: '**357**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Well, that seemed to work, in the sense that R did install the package, but
    R also noted that it had a problem with the threads library on our machines. Sure
    enough, when I tried to load Rmpi, I got a runtime error, saying that a certain
    threads function wasn’t there.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这似乎是可行的，从 R 安装了包这个意义上来说，但 R 也指出，它在我们的机器上的线程库存在问题。确实如此，当我尝试加载 Rmpi 时，我得到了一个运行时错误，说某个线程函数不存在。
- en: 'I knew that our threads library was fine, so I went into the configure file
    and commented out two lines:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
- en: if test $ac_cv_lib_pthread_main = yes; then
  id: totrans-2158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPI_LIBS="$MPI_LIBS -lpthread"
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
- en: fi
  id: totrans-2160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other words, I forced it to use what I knew (or was fairly sure) would work.
    I then reran R CMD INSTALL, and the package loaded without any problems.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
- en: '**B.4 Listing the Functions in a Package**'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a list of functions in a package by calling library() with the
    help argument. For instance, for help on the mvtnorm package, type one of the
    following:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: library(help=mvtnorm)
  id: totrans-2165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: •
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: help(package=mvtnorm)
  id: totrans-2167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**358**'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
- en: '**I N D E X**'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: '**Special Characters**'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: lines with abline() function, 263–264
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
- en: list elements, 88–90
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: ': (colon operator), 32–33'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 73–78
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: == operator, 54–55
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: points to graphs with points() func-
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: operator, 40
  id: totrans-2179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tion, 269–270
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: .libpaths() function, 356–357
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: text to graphs with text() function,
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rdata* file, 20'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: 270–271
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rhistory* file, 20'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
- en: addmargins() function, 131
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rprofile* file, 19'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
- en: adjacency matrix, 333
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: <<- (superassignment operator), 9
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
- en: aggregate() function, 136
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 174
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: all() function, 35–39
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with, 161–162
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: analogous operations, resizing
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
- en: + operator, 31
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 74
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
- en: '"%mut%"() function, 218'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: anonymous functions, 99, 187–188
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: antibugging, 287
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
- en: any() function, 35–39
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: application-specific functions, 165
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: abalone data set
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: apply() function
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: recoding, 51–54
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to matrix rows
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() function, 99
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
- en: and columns, 70–72
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: abline() graphics function, 150
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 107
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: abs() math function, 189
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: obtaining variable marginal
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: accessing
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: values, 131
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 102–104
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: arguments. *See also specific argument*
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: files on remote machines via
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
- en: '*by name*'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: URLs, 243
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: actual, 9
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: Internet, 246–250
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: default, 9–10
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R exam-
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: default values for, 146–147
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
- en: ple, 248–250
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: formal, 9
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic operations, 30–31, 145–146
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: array() function, 134
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: keyboard and monitor, 232–235
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: arrays
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: higher-dimensional arrays, 82–83
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: as vectors, 28
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
- en: as.matrix() function, 81
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: list components and values, 93–95
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
- en: aspell() function, 211
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: actual argument, 9
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
- en: assign() function
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: adding
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: variables, 109
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
- en: legends to graphs with legend()
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: writing nonlocals with, 163
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: function, 270
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
- en: atomic pragma, 343
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: character strings, 251–259
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
- en: atomic vectors, 85–86
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: defined, 11
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: attr() function, 212
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
- en: regular expressions, 254–257
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: forming filenames example,
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: 256–257
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: testing filename for given suffix
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 1
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: example, 255–256
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
- en: help feature, 24
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions,
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: running R in, 3
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: 251–254
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: Bernoulli sequence, 204
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr(), 254
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
- en: biglm package, 321
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: grep(), 252
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: bigmemory package, 321
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: nchar(), 252
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: binary files, 237
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: paste(), 252–253
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree, 177–182
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: regexpr(), 253–254
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: body() function, 149, 151
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(), 253
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators, 145–146
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: strsplit(), 253
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: braces, 144
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: substr(), 253
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: brackets, 87–88
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: use of string utilities in edtdbg debug-
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
- en: Bravington, Mark, 300
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: ging tool, 257–259
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: breakpoints, setting, 289–290
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
- en: child nodes, binary search tree, 177
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: calling browser() function directly,
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: Chinese dialects, aids for learning,
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: 289–290
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: 115–120
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: using setbreakpoint() function, 290
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: chi-square distribution, 193–194
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
- en: breaks component, hist() function, 14
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: chol() linear algebra function, 197
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
- en: break statement, 141
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: choose() set operation, 202
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
- en: browser commands, 289
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: chunking memory, 320–321
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: browser() function
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
- en: class() function, 212
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: cleaner code, 172
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
- en: single-stepping through code, 288
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: client/server model, 247
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: by() function, 126–127
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: closures, 151, 174–175
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: byrow argument, matrix() function,
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: cloud() function, 282–283
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: 61, 236
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: cluster, snow package, 335
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: clusterApply() function, snow package,
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: 72, 337, 339–340
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: code files, 3
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: code safety, 41
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
- en: c %in% y set operation, 202
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
- en: col() function, 69–70
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: cache, 346
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
- en: calculus, 192–193
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: color images, 63
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
- en: categorical variables, 121
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: column-major order, matrix storage,
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
- en: cbind() function, 12, 74–75, 106–107
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: 59, 61
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
- en: c browser command, 289
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: combinatorial simulation, 205–206
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: cdf (cumulative distribution
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
- en: combn() function, 203
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: function), 193
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
- en: comdat$countabsamecomm component, 206
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
- en: ceiling() math function, 190
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: comdat$numabchosen component, 206
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
- en: cell counts, changing to
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: comdat$whosleft component, 206
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
- en: proportions, 130
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: comma-separated value (CSV) files, 103
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: cex option, changing graph character
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: comments, 3
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
- en: sizes with, 272–273
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: complete.cases() function, 105–106
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: c() function, 56–57
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive R Archive Network
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
- en: Chambers, John, 226
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: (CRAN), 24, 193, 353
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
- en: '**360**'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: computed mean, saving in variable, 5
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: applying logistic regression
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
- en: concatenating, vectors, 4
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: models example, 113–115
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() and sapply() on
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: constructors, 217
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 112–113
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: contingency tables, 128, 229
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 104–109
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 139–144
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 107
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: if-else function, 143–144
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdata frames,
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 143
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: 104–105
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: loops, 140–142
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: NA values, 105–106
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change policy, 314–315
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: rbind() and cbind() functions,
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
- en: cos() math function, 190
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: 106–107
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: counter() function, 175
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
- en: salary study example, 108–109
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: counts component
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: merging, 109–112
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: hist() function, 14
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
- en: employee database example,
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 116
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
- en: 111–112
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: covariance matrix, generating, 69–70
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
- en: reading from files, 236
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
- en: CRAN (Comprehensive R Archive Net-
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: regression analysis of exam grades
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: work), 24, 193, 353
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: example, 103–104
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: critical section, OpenMP, 344
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: data structures, 10–16
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: crossprod() function, 196
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
- en: character strings, 11
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: cross-validation, 219, 222
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: classes, 15–16
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
- en: C-style looping, 140
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 14–15
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: CSV (comma-separated value) files, 103
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
- en: lists, 12–14
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
- en: ct.dat file, 128
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 11–12
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: cumprod() math function, 190, 191
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 10
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
- en: cumsum() math function, 39, 190–191
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: debug() function, 288
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
- en: cumulative distribution function
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
- en: debugger() function, performing checks
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: (cdf), 193
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
- en: after crash with, 291–292
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: cumulative sums and products, 191
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 285–304
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: curve() function, 277–278
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: ensuring consistency in debugging
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
- en: customizing graphs, 272–280
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
- en: simulation code, 302
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: adding polygons with polygon() func-
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
- en: facilities, 288–300
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: tion, 275–276
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
- en: browser commands, 289
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: changing character sizes with cex
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
- en: debug() and browser()
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
- en: option, 272–273
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
- en: functions, 288
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: changing ranges of axes with xlim
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: debugging sessions, 292–300
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
- en: and ylim options, 273–275
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
- en: graphing explicit functions, 276–277
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: traceback() and debugger()
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: functions, 291–292
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
- en: example, 277–280
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
- en: trace() function, 291
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
- en: smoothing points with lowess() and
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
- en: global variables and, 173
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
- en: loess() functions, 276
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 351
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
- en: cut() function, 136–137
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: principles of, 285–287
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
- en: antibugging, 287
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: confirmation, 285–286
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
- en: modular, top-down manner, 286
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: data argument, array() function, 134
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
- en: starting small, 286
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 14–15, 101–102
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
- en: running GDB on R, 303–304
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: accessing, 102–104
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
- en: syntax and runtime errors, 303
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to, 112–120
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
- en: tools, 287–288, 300–302
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
- en: aids for learning Chinese dialects
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
- en: debug package, 300–301
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
- en: example, 115–120
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: declarations, 28–29
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: '**361**'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: default arguments, 9–10
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: employee database example, 111–112
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
- en: deleting
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation, 207
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: list elements, 88–90
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: end of file (EOF), 238
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 73–78
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
- en: envir argument
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: a node from binary search tree, 181
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
- en: get() function, 159
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: density estimates, same graph, 264–266
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
- en: DES (discrete-event simulation),
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope, 151–159
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: writing, 164–171
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: functions have (almost) no side
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
- en: det() linear algebra function, 197
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: effects, 156–157
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: dev.off() function, 3
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
- en: function to display contents of call
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: df parameter, mapsound() function, 116
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: frame example, 157–159
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: dgbsendeditcmd() function, 257–258
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155–156
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: diag() linear algebra function, 197–198
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
- en: diff() function, 50–51
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
- en: dim argument, array() function, 134
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: EOF (end of file), 238
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: dim attribute, matrix class, 79
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
- en: ess-tracebug package, 300
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: dimcode argument, apply() function, 70
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
- en: event list, DES, 164
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: dimension reduction, avoiding, 80–81
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: event-oriented paradigm, 164
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: dim() function, 79
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
- en: example() function, 21–22
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: dimnames argument, array() function, 134
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: exists() function, 230
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
- en: dimnames() function, 131
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: expandut() function, 218
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
- en: dir() function, 245
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: explicit functions, graphing, 276–277
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation (DES),
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: exp() math function, 189
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
- en: writing, 164–171
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: extracting
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
- en: discrete-valued time series, predicting,
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
- en: subdata frames, 104–105
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: 37–39
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: subtables, 131–134
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: do.call() function, 133
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
- en: dosim() function, 165
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: double brackets, 87–88
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: drop argument, 68, 81
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
- en: factorial() math function, 190
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
- en: dtdbg debugging tool, use of string utili-
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
- en: factors, 121
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
- en: ties in, 257–259
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
- en: functions, 123, 136
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
- en: dual-core machines, 341
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
- en: aggregate(), 136
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: duplicate() function, 315
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
- en: by(), 126–127
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: dynamic task assignment, 348–350
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: cut(), 136–137
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
- en: split(), 124–126
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
- en: tapply(), 123–124
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: levels and, 121–122
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: each argument, rep() function, 34
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
- en: fangyan, 115
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 150, 186–187
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
- en: fargs argument, apply() function, 70
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: edtdbg package, 300–302
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
- en: f argument, apply() function, 70
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
- en: eigen() function, 197, 201
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
- en: Fedora, installing R on, 353–354
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
- en: eigenvalues, 201
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: file.exists() function, 245
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
- en: eigenvectors, 201
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: file.info() function, 245, 246
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
- en: elements
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
- en: filetype criterion, Google, 24
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
- en: list, adding and deleting, 88–90
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: filter() function, 328
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: vectors
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 45–48
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting, 26
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
- en: naming, 56
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
- en: generating filtering indices, 45–47
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: embarrassingly parallel applications
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 66–69
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: defined, 347–348
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
- en: with subset() function, 47
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
- en: turning general problems into, 350
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
- en: with which() selection function, 47–48
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
- en: '**362**'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
- en: findud() function, 50
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: findwords() function, 90–91
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
- en: first-class objects, 149
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: GCC, 325
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
- en: floor() math function, 190
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: GDB (GNU debugger), 288, 327
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: general-purpose editors, 186
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in Monte
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
- en: generating
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
- en: covariance matrices, 69–70
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
- en: filtering indices, 45–47
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix example,
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: powers matrices, 312–313
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
- en: 312–313
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, xxi
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup, 306–308
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
- en: classes, 15
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
- en: formal parameters
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: implementing on S4 classes, 225–226
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 116
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: getAnywhere() function, 211
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: oddcount() function, 9
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
- en: get() function, 159
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: formals() function, 149, 151
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 142
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
- en: forming filenames, 256–257
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
- en: getnextevnt() function, 165
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: four-element vector, adding
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
- en: getwd() function, 245
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
- en: element to, 26
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: global variables, 9, 171–174
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: fromcol parameter, mapsound()
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: GNU debugger (GDB), 288, 327
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
- en: GNU S language, xix
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, xxi–xxii,
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
- en: GPU programming, 171, 345
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
- en: 314–316
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: GPUs (graphics processing units), 345
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
- en: gputools package, 345–346
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
- en: granularity, 348
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
- en: graphical user interfaces (GUIs), xx
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
- en: graphics processing units (GPUs), 345
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
- en: functions, 7–10\. *See also* math functions;
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
- en: graphs, 261–283
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
- en: customizing, 272–280
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
- en: anonymous, 187–188
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
- en: adding legends with legend()
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
- en: applying to data frames, 112–120
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: function, 270
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
- en: aids for learning Chinese dialects
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
- en: adding lines with abline()
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: example, 115–120
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
- en: function, 263–264
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
- en: applying logistic regression
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
- en: adding points with points()
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: models example, 113–115
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
- en: function, 269–270
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() and sapply()
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
- en: adding polygons with polygon()
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
- en: functions, 112–113
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: function, 275–276
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
- en: applying to lists, 95–99
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: adding text with text() function,
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
- en: abalone data example, 99
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
- en: 270–271
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
- en: lapply() and sapply() functions, 95
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
- en: changing character sizes with cex
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 95–98
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
- en: option, 272–273
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: applying to matrix rows and columns,
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
- en: changing ranges of axes with xlim
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
- en: 70–73
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: and ylim options, 273–275
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 70–72
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
- en: graphing explicit functions,
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: finding outliers example, 72–73
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
- en: 276–277
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
- en: default arguments, 9–10
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: listing in packages, 358
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
- en: example, 277–280
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: as objects, 149–151
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
- en: smoothing points with lowess()
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
- en: replacement, 182–186
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: and loess() functions, 276
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
- en: for statistical distributions, 193–194
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
- en: pinpointing locations with locator()
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
- en: transcendental, 40
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: function, 271–272
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
- en: variable scope, 9
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
- en: plot() function, 262
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: vector, 35–39, 311
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
- en: '**363**'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
- en: graphs ( *continued*)
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 62–63
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
- en: plots
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
- en: vector, 31–32
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: restoring, 272
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: indices, filtering, 45–47
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional, 282–283
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
- en: inheritance
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
- en: polynomial regression example,
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: defined, 207
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
- en: 266–269
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 214
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: saving to files, 280–281
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: initglbls() function, 165
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
- en: starting new graph while keeping
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
- en: input/output (I/O). *See* I/O
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
- en: old, 264
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
- en: installing packages. *See* packages
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
- en: two density estimates on same graph
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
- en: installing R, 353–354
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
- en: example, 264–266
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
- en: downloading base package from
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
- en: grayscale images, 63
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: CRAN, 353
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr() function, 254
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
- en: from Linux package manager,
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
- en: grep() function, 109, 252
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
- en: 353–354
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: GUIs (graphical user interfaces), xx
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
- en: from source, 354
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: install_packages() function, 356
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
- en: integrated development environments
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: (IDEs), xx, 186
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
- en: hard drive, loading packages from, 356
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: intensity, pixel, 63–64
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
- en: help feature, 20–24
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: interactive mode, 2–3
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
- en: additional topics, 23–24
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
- en: interfacing R to other languages, 323–332
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 24
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
- en: using R from Python, 330–332
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: example() function, 21–22
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
- en: writing C/C++ functions to be called
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20–21
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
- en: from R, 323–330
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 22–23
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: compiling and running code, 325
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
- en: online, 24
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: debugging R/C code, 326–327
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20–21
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdiagonals from
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 22–23
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
- en: square matrix example, 324–325
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: higher-dimensional arrays, 82–83
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: prediction of discrete-valued time
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
- en: hist() function, 3, 13–14
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: series example, 327–330
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
- en: hosts, 345
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
- en: internal data sets, 5
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: Huang, Min-Yu, 324
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
- en: internal storage, matrix, 59, 61
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: Internet, accessing, 246–250
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R example,
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
- en: 248–250
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
- en: identical() function, 55
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: IDEs (integrated development environ-
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: ments), xx, 186
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: Internet Protocol (IP) address, 247
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
- en: ifelse() function, 48–49
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: intersect() set operation, 202
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
- en: intextract() function, 243
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
- en: variables example, 49–51
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
- en: I/O (input/output), 231–250
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 143–144
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
- en: accessing Internet, 246–250
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: recoding abalone data set example,
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R example,
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: 51–54
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
- en: 248–250
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
- en: if statements, nested, 141–142
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: sockets in R, 247–248
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation, 63–66
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: images component, mapsound()
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
- en: accessing keyboard and monitor,
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
- en: 232–235
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
- en: immutable objects, 314
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
- en: indexing
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: list, 87–88
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
- en: '**364**'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
- en: reading files, 235
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
- en: lines() function, 264
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
- en: accessing files on remote
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
- en: Linux package manager, installing R
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
- en: machines via URLs, 243
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
- en: from, 353–354
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: lists, 12–14, 85–100
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: reading data frame or matrix from
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
- en: accessing components and values,
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: files, 236
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: 93–95
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
- en: reading PUMS census files
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to, 95–99
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
- en: example, 239–243
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: abalone data example, 99
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
- en: reading text files, 237
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
- en: lapply() and sapply() functions, 95
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: writing files
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 95–98
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: getting files and directory
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
- en: general operations, 87–93
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: information, 245
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting list elements,
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
- en: sum contents of many files
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
- en: 88–90
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
- en: example, 245–246
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: getting size of list, 90
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
- en: writing to files, 243–245
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: list indexing, 87–88
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: IP (Internet Protocol) address, 247
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 90–93
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
- en: recursive lists, 99–100
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: lm()function, 15, 208–210
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
- en: load balance, 349–350
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: join operation, 109
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
- en: locator() function
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
- en: determining relevant rows and col-
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: '**K**'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: umns, 64–65
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
- en: pinpointing locations with, 271–272
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
- en: keyboard, accessing, 232–235
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: loess() function, 276
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: printing to screen, 234–235
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
- en: log10() math function, 189
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
- en: logical operations, 30–31
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
- en: logistic regression models, applying,
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: KMC (k-means clustering), 338–340
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
- en: 113–115
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
- en: log() math function, 189
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
- en: long-run state distribution, Markov
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
- en: modeling, 200
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
- en: lag operations, vector, 50–51
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
- en: loops, control statements, 140–142
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
- en: lapply() function
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
- en: lowess() function, 276
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to lists, 95
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: ls() function
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
- en: lists, 50
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope, 155–156
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 142
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: listing objects with, 226–227
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
- en: using on data frames, 112–113
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: latency, 346
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
- en: lazy evaluation principle, 52, 147
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
- en: leaving-one-out method, 219, 222
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve, 277–280
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
- en: legend() function, 270
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
- en: makerow() function, 241–242
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
- en: length() function
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
- en: managers, snow package, 335
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
- en: obtaining length of vector, 27
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
- en: managing objects, 226–230
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 32
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
- en: determining object structure,
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
- en: levels, factors and, 121–122
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
- en: 228–230
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
- en: .libPaths() function, 356–357
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
- en: exists() function, 230
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
- en: library functions, 165
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
- en: listing objects with ls() function,
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, on vectors
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
- en: 226–227
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
- en: and matrices, 61, 196–201
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: removing specific objects with rm()
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
- en: finding stationary distributions of
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
- en: function, 227–228
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains example, 199–201
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: saving collection of objects with
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
- en: vector cross product example, 198–199
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
- en: save() function, 228
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
- en: '**365**'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 115–116
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
- en: memory
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
- en: marginal values, variable, 131
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
- en: chunking, 320–321
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
- en: m argument, apply() function, 70
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, 314–316
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains, 199–201
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
- en: MASS package, 23, 356
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: math functions, 189–193
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
- en: calculating probability example,
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
- en: 190–191
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
- en: using R packages for memory
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
- en: calculus, 192–193
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
- en: cumulative sums and products, 191
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
- en: merge() function, 109–110
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
- en: minima and maxima, 191–192
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
- en: merge sort method, numerical
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 11–12, 59–83
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
- en: sorting, 347
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting rows and col-
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
- en: merging data frames, 109–112
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
- en: umns, 73–78
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
- en: employee database example,
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
- en: finding closest pair of vertices in
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
- en: 111–112
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
- en: graph example, 75–78
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
- en: metacharacters, 254
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrix, 73–75
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
- en: methods() function, 210
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to rows and col-
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
- en: microdata, 239
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
- en: umns, 70–73
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
- en: minima function, 191–192
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 70–72
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
- en: min() math function, 190, 191
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
- en: finding outliers example, 72–73
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
- en: M/M/1 queue, 165, 168
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
- en: avoiding unintended dimension
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
- en: modes
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
- en: reduction, 80–81
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
- en: batch, 1, 3, 24
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations on, 196–201
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
- en: defined, 26
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
- en: naming rows and columns, 81–82
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
- en: interactive, 2–3
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
- en: operations, 61–70
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
- en: modulo operator, 44
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 66–69
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
- en: monitor, accessing, 232–235
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
- en: generating covariance matrix
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
- en: example, 69–70
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation example,
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
- en: 63–66
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo simulation, achieving bet-
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, 61
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
- en: ter speed in, 308–311
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
- en: matrix indexing, 62–63
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
- en: multicore machines, 340–341
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
- en: reading from files, 236
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
- en: mutlinks() function, 336
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
- en: vector/matrix distinction, 78–79
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 333–334, 341–342
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
- en: as vectors, 28
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
- en: mvrnorm() function, MASS package, 23, 356
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like operations, 130–131
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
- en: matrix class, 79
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
- en: matrix() function, 60
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
- en: matrix-inverse update method, 222
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
- en: named arguments, 146–147
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 104–109
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
- en: names() function, 56
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 107
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
- en: naming
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdata frames, 104–105
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 81–82
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
- en: NA values, 105–106
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
- en: vector elements, 56
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
- en: rbind() and cbind() functions,
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: NA values
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
- en: 106–107
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 105–106
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
- en: salary study example, 108–109
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 43
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: matrix-multiplication operator, 12
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
- en: n browser command, 289
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
- en: maxima function, 191–192
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
- en: nchar() function, 252
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
- en: max() math function, 190, 192
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
- en: ncol() function, 79
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
- en: mean() function, 38
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
- en: '**366**'
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
- en: negative subscripts, 32, 63
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: matrix, 61–70
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
- en: network, defined, 247
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 66–69
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: Newton-Raphson method, 192
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
- en: generating covariance matrix
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
- en: next statement, 141
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
- en: example, 69–70
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
- en: Nile data set, 5
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation example,
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
- en: noise, adding to image, 65–66
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
- en: 63–66
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
- en: nominal variables, 121
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: indexing, 62–63
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
- en: nonlocals
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, 61
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
- en: writing to with superassignment
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like, 130–131
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
- en: operator, 161–162
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
- en: vector, 30–34
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
- en: writing with assign() function, 163
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and logical operations,
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
- en: nonvector sets, looping control state-
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
- en: 30–31
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
- en: ments over, 143
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
- en: nonvisible functions, 211
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
- en: generating vector sequences with
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
- en: nreps values, 205
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 33–34
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
- en: nrow() function, 79
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
- en: repeating vector constants with
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
- en: NULL values, 44
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, 34
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
- en: vector in, matrix out, 42–43
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
- en: vector in, vector out, 40–42
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 31–32
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented programming. *See* OOP
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
- en: operator precedence, 33
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
- en: objects. *See also* managing objects
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
- en: order() function, 97, 194–195
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
- en: first-class, 149
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
- en: outliers, 49
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
- en: immutable, 314
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
- en: oddcount() function, 7, 140
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
- en: omp barrier pragma, OpenMP, 344
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
- en: omp critical pragma, OpenMP, 344
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
- en: packages, 355–358
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
- en: omp single pragma, OpenMP, 344–345
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
- en: installing
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
- en: OOP (object-oriented programming),
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
- en: automatically, 356–357
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
- en: xxi, 207–230
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
- en: manually, 357–358
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
- en: managing objects. *See* managing
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
- en: listing functions in, 358
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
- en: objects
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: loading from hard drive, 356
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes. *See* S3 classes
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 333–351
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 222–226
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 351
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
- en: implementing generic function
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
- en: embarrassingly parallel applica-
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
- en: on, 225–226
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
- en: tions, 347–348
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
- en: vs. S3 classes, 226
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
- en: turning general problems into, 350
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
- en: writing, 223–225
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
- en: implementing, 248–250
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP, 344–345
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 333–334
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
- en: code analysis, 343
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
- en: resorting to C, 340–345
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
- en: omp barrier pragma, 344
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
- en: GPU programming, 345
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
- en: omp critical pragma, 344
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
- en: multicore machines, 340–341
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
- en: omp single pragma, 344–345
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 341–342
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
- en: operations
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP code analysis, 343
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
- en: list, 87–93
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP pragmas, 344–345
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting list elements,
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
- en: running OpenMP code, 342
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
- en: 88–90
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
- en: snow package, 334–340
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
- en: getting size of list, 90
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
- en: analyzing snow code, 336–337
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
- en: list indexing, 87–88
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering (KMC), 338–340
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 90–93
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
- en: running snow code, 335–336
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: speedup, 337–338
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
- en: '**367**'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
- en: snow package ( *continued*)
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
- en: polynomial regression, 219–222, 266–269
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
- en: sources of overhead, 346–347
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
- en: port number, 247
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
- en: networked systems of computers,
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
- en: powers matrix, generating, 312–313
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
- en: 346–347
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
- en: pragmas, OpenMP, 343–345
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory machines, 346
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
- en: preda() function, 38
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
- en: static vs. dynamic task assignment,
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
- en: principle of confirmation, debugging,
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
- en: 348–350
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
- en: 285–286
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
- en: parent.frame() function, 156
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
- en: print() function, 18, 234–235
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
- en: paste() function, 252–253, 257, 269
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
- en: print.ut() function, 218
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
- en: PDF devices, saving displayed
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
- en: prntrslts() function, 165
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
- en: graphs, 281
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
- en: probability, calculating, 190–191
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
- en: pdf() function, 3
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
- en: probability mass function (pmf), 193
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
- en: Pearson product-moment
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
- en: procpairs() function, 343
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
- en: correlation, 49
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
- en: prod() math function, 190
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
- en: performance enhancement, 305–321
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
- en: programming structures. *See* R program-
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
- en: ming structures
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
- en: chunking, 320–321
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
- en: Public Use Microdata Samples (PUMS)
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, 314–316
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
- en: census files, reading, 239
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
- en: Python, using R from, 330–332
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
- en: Q browser command, 289
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in a Monte
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
- en: qr() linear algebra function, 197
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation, 176–177
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix exam-
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
- en: ple, 312–313
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup, 306–308
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
- en: race condition, 343
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
- en: using R packages for memory
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
- en: random variate generators, 204–205
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
- en: rank()
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
- en: function, 195–196
  id: totrans-3123
  prefs: []
  type: TYPE_NORMAL
- en: rbind()
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
- en: using Rprof() function to find slow
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
- en: function, 12, 106–107
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
- en: spots in code, 316–319
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
- en: ordering events, 171
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
- en: writing fast R code, 306
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrices, 74–75
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
- en: rbinom()
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
- en: Perron-Frobenius theorem, 201
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
- en: function, 204
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
- en: persp() function, 22, 282
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
- en: R console, 2
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
- en: pixel intensity, 63–64
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rdata* file, 20'
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
- en: plot()
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
- en: Rdsm
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
- en: function, xxi, 16, 262
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
- en: package, implementing
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
- en: plots
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 249
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
- en: reactevnt()
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
- en: restoring, 272
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
- en: function, 165
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
- en: readBin()
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional, 282–283
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
- en: function, 248
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
- en: plyr
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
- en: read.csv()
  id: totrans-3151
  prefs: []
  type: TYPE_NORMAL
- en: package, 136
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
- en: function, 108
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
- en: pmax() math function, 190, 192
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
- en: reading files, 235
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
- en: pmf (probability mass function), 193
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
- en: accessing files on remote machines
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
- en: pmin() math function, 190, 191
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
- en: via URLs, 243
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
- en: pointers, 159–161
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
- en: points() function, 269–270
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
- en: reading data frames or matrices from
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
- en: polygon() function, 275–276
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
- en: files, 236
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
- en: reading PUMS census files example,
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
- en: defined, xxi, 207
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
- en: 239–243
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, 208
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
- en: reading text files, 237
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
- en: '**368**'
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
- en: readline() function, 234
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
- en: R programming structures, 139
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
- en: readLines() function, 248
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
- en: anonymous functions, 187–188
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
- en: reassigning matrices, 73–74
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and Boolean operators
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
- en: recursion, 176–182
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
- en: and values, 145–146
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree example, 177–182
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 139–144
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation, 176–177
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
- en: if-else function, 143–144
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
- en: recursive argument, concatenate
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 143
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
- en: function, 100
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
- en: loops, 140–142
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
- en: recursive vectors, 86
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
- en: default values for arguments, 146–147
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
- en: recycling
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope issues,
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
- en: 151–159
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 29–30
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
- en: function to display contents of call
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
- en: reference classes, 160
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
- en: frame example, 157–159
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
- en: regexpr() function, 253–254
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155–156
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
- en: regression analysis of exam grades,
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
- en: 16–19, 103–104
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
- en: side effects, 156–157
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
- en: regular expressions, character string
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
- en: manipulation, 254–257
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
- en: functions as objects, 149–151
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
- en: remote machines, accessing files
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
- en: pointers, lack of, 159–161
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
- en: on, 243
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
- en: recursion, 176–182
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
- en: repeat loop, 241–242
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree example,
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
- en: repeat statement, 141
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
- en: 177–182
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, repeating vector con-
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation,
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
- en: stants with, 34
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
- en: 176–177
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
- en: replacement functions, 182–186
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
- en: replacement functions, 182–186
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
- en: defined, 183–184
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
- en: return values, 147–149
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
- en: self-bookkeeping vector class
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
- en: deciding whether to explicitly call
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
- en: example, 184–186
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
- en: return() function, 148
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
- en: reshape package, 136
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
- en: returning complex objects,
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrices, 73–75
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
- en: 148–149
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
- en: return statement, 8
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
- en: tools for composing function code,
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
- en: return values, 147–149
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
- en: 186–187
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
- en: deciding whether to explicitly call
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 186–187
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
- en: return() function, 148
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
- en: text editors and IDEs, 186
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
- en: returning complex objects, 148–149
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
- en: writing, 161–175
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
- en: REvolution Analytics, 300
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
- en: binary operations, 187
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
- en: rexp() function, 204
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
- en: closures, 174–175
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
- en: Rf_PrintValue(s) function, 304
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation (DES) in
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
- en: rgamma() function, 204
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
- en: R example, 164–171
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rhistory* file, 20'
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
- en: when to use global variables,
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
- en: rm() function, 227–228
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
- en: 171–174
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
- en: rnorm() function, 3, 204
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with assign()
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
- en: round() function, 40–41, 190
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
- en: function, 163
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
- en: routers, 247
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with the super-
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
- en: row() function, 69–70
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
- en: assignment operator, 161–162
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
- en: rownames() function, 82
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
- en: RPy module
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
- en: R packages, for memory
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
- en: installing, 330
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
- en: syntax, 330–332
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
- en: rpois() function, 204
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
- en: runif() function, 204
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
- en: Rprof() function, 316–319
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
- en: running
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rprofile* file, 19'
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
- en: GDB on R, 303–304
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP code, 342
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
- en: '**369**'
  id: totrans-3279
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
- en: running ( *continued*)
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
- en: setdiff() set operation, 202
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
- en: R, 1–2
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
- en: setequal() set operation, 202
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 3
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
- en: setMethod() function, 225
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
- en: first session, 4–7
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
- en: set operations, 202–203
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
- en: interactive mode, 2–3
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
- en: set.seed() function, 302
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
- en: snow code, 335–336
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
- en: runs of consecutive ones, finding, 35–37
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
- en: calling browser() function directly,
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
- en: runtime errors, 303
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
- en: 289–290
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
- en: using setbreakpoint() function, 290
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
- en: setwd() function, 245
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
- en: S expression pointers (SEXPs), 304
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
- en: S (programming language), xix
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory systems, 341, 346–347
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 208–222
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory/threads model,
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
- en: class for storing upper-triangular
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
- en: GPUs, 345
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
- en: matrices example, 214–219
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
- en: Sherman-Morrison-Woodbury
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
- en: finding implementations of generic
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
- en: formula, 222
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
- en: methods, 210–212
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
- en: shortcuts
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, 208
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
- en: OOP in lm() function example,
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 23
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
- en: 208–210
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
- en: showframe() function, 158
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
- en: procedure for polynomial regression
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
- en: sim global variable, 172–173
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
- en: example, 219–222
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 172
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
- en: vs. S4 classes, 226
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
- en: simulation programming in R, 204–206
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
- en: using inheritance, 214
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
- en: built-in random variate generators,
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
- en: writing, 212–213
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
- en: 204–205
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 222–226
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
- en: combinatorial simulation, 205–206
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
- en: implementing generic function on,
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
- en: obtaining same random stream in
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
- en: 225–226
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
- en: repeated runs, 205
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
- en: vs. S3 classes, 226
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
- en: single brackets, 87–88
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
- en: writing, 223–225
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
- en: single-server queuing system, 168
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
- en: salary study, 108–109
  id: totrans-3339
  prefs: []
  type: TYPE_NORMAL
- en: sink() function, 258
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
- en: Salzman, Pete, 285
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
- en: sin() math function, 190
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
- en: sapply() function, 42
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
- en: slots, S4 class, 224
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to lists, 95
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
- en: snow package, 334–335
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
- en: using on data frames, 112–113
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R, 248–249
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
- en: save() function, saving collection of
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering (KMC), 338–340
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
- en: objects with, 228
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
- en: snow code
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
- en: saving graphs to files, 280–281
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
- en: analyzing, 336–337
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
- en: scalars, 10
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
- en: running, 335–336
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators, 145
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
- en: speedup, 337–338
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 26
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
- en: socketConnection() function, 248
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
- en: scan() function, 142, 232–234
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
- en: scatter/gather paradigm, 335–336
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
- en: socketSelect() function, 248
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
- en: schedevnt() function, 165, 171
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
- en: solve() function, 197
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155\. *See also* envi-
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
- en: sorting, numerical, 194–196
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
- en: ronment and scope
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
- en: sos package, 24
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
- en: sepsoundtone() function, 119
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
- en: source, installing R from, 354
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 21, 33–34
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
- en: sourceval parameter, mapsound()
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
- en: serialize() function, 248
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
- en: setbreakpoint() function, 290
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
- en: Spearman rank correlation, 49
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
- en: setClass() function, 223
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
- en: '**370**'
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
- en: speed
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
- en: summary() function, 15, 18
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
- en: summaryRprof() function, 319
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
- en: finding slow spots in code, 316–319
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
- en: summing contents of many files, 245–246
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
- en: superassignment operator (<<-), 9
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in Monte
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 174
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with, 161–162
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
- en: sweep() linear algebra function, 197–198
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
- en: symmetric matrix, 77
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
- en: example, 312–313
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
- en: syntax errors, 303
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup,
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
- en: 306–308
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
- en: writing fast R code, 306
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
- en: Spinu, Vitalie, 300
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
- en: tabdom() function, 134
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
- en: split() function, 124–126, 336
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
- en: tables, 127–130
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
- en: S-Plus (programming language), xix
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
- en: extracting subtable example,
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
- en: sprintf() function, 253
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
- en: 131–134
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
- en: sqrt() function, 42, 189
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
- en: finding largest cells in, 134
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
- en: stack trace, 289
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
- en: functions, 136–137
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
- en: startup and shutdown, 19–20
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
- en: aggregate(), 136
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
- en: static task assignment, 348–350
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
- en: cut(), 136–137
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
- en: stationary distributions, Markov chains,
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like operations,
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
- en: 199–201
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
- en: 130–131
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
- en: statistical distributions, functions for,
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
- en: tags, 86
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
- en: 193–194
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
- en: tapply() function
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
- en: str() function, 14
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
- en: vs. by() function, 126–127
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions, 11,
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
- en: factors, 123–124
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
- en: 251–254
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
- en: vs. split() function, 124
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr(), 254
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
- en: tbl argument, subtable() function, 132
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
- en: grep(), 252
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
- en: tblarray array, 133
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
- en: nchar(), 252
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
- en: paste(), 252–253
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
- en: termination condition, 177
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
- en: regexpr(), 253–254
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
- en: testing vector equality, 54–55
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(), 253
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
- en: text, adding to graphs with text() func-
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
- en: strsplit(), 253
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
- en: tion, 270–271
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
- en: substr(), 253
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
- en: text concordance, 90–93, 95–98
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
- en: stringsAsFactors argument, data.frame()
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
- en: text editors, 186
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
- en: function, 102
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
- en: text files, reading, 237
  id: totrans-3454
  prefs: []
  type: TYPE_NORMAL
- en: string utilities, in edtdbg debugging tool,
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
- en: text() function, adding text to graphs
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
- en: 257–259
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
- en: with, 270–271
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
- en: strsplit() function, 253
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
- en: t() function, 71, 119, 197
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
- en: subdeterminants, 199
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
- en: threaded code, 171
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
- en: submatrices, assigning values to, 62–63
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
- en: threads, 341
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
- en: subnames argument, subtable()
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional tables, 129–130
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
- en: function, 132
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
- en: Tierney, Luke, 334
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
- en: subscripting operations, 183
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
- en: tocol parameter, mapsound()
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
- en: subset() function, 47, 105
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
- en: subsetting, vector, 4–5
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
- en: tools
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
- en: substr() function, 253
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
- en: for composing function code,
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
- en: subtable() function, 132
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
- en: 186–187
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
- en: suffix, testing filename for given, 255–256
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 186–187
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
- en: sum() function, 190, 337
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
- en: text editors and IDEs, 186
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 287–288, 300–302
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
- en: '**371**'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 10, 25–57
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
- en: traceback() function, 291–292
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
- en: all() and any() functions, 35–39
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
- en: trace() function, 291
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
- en: finding runs of consecutive ones
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
- en: tracemem() function, 314–315
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
- en: example, 35–37
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
- en: training set, 37
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
- en: predicting discrete-valued time
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
- en: transcendental functions, 40
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
- en: series example, 37–39
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
- en: transition probability, 200
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
- en: c() function, 56–57
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
- en: treelike data structures, 177
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
- en: common operations, 30–34
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and logical operations,
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
- en: 30–31
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu, installing R on, 353–354
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
- en: generating vector sequences with
  id: totrans-3508
  prefs: []
  type: TYPE_NORMAL
- en: unclass() function, 229
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 33–34
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
- en: union() set operation, 202
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
- en: repeating vector constants with
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
- en: unlist() function, 93
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, 34
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
- en: unname() function, 94
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 31–32
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
- en: unserialize() function, 248
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
- en: computing inner product of two, 196
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
- en: upn argument, showframe() function, 158
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
- en: declarations, 28–29
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
- en: upper-triangular matrices, class for stor-
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
- en: defined, 4
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
- en: ing, 214–219
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
- en: elements
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
- en: URLs, accessing files on remote
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting, 26
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
- en: machines via, 243
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
- en: naming, 56
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
- en: u variable, 162
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 45–48
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
- en: generating indices for, 45–47
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
- en: with subset() function, 47
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
- en: with which() function, 47–48
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
- en: values
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
- en: ifelse() function, 48–54
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
- en: assigning to submatrices, 62–63
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, 145–146
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
- en: variables example, 49–51
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
- en: list, accessing, 93–95
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
- en: recoding abalone data set
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
- en: NA, 43, 105–106
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
- en: example, 51–54
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
- en: NULL, 44
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations on,
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
- en: return, 147–149
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
- en: 196–201
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
- en: vanilla option, startup/shutdown, 20
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
- en: matrices and arrays as, 28
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
- en: variables
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
- en: NA value, 43
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two,
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
- en: NULL value, 44
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
- en: 49–51
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
- en: obtaining length of, 27
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
- en: categorical, 121
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
- en: recycling, 29–30
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
- en: global, 9, 171–174
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
- en: scalars, 26
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
- en: nominal, 121
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
- en: testing vector equality, 54–55
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
- en: variable scope, 9
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
- en: vectorized operations, 39–43
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
- en: vector in, matrix out, 42–43
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
- en: vector cross product, 198–199
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
- en: vector in, vector out, 40–42
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
- en: vector filtering, 307
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
- en: vertices, graph, finding, 75–78
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
- en: vector-filtering capability, 176
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
- en: vector functions, 311
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
- en: Web, downloading packages from,
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
- en: for speedup, 306–308
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
- en: 356–358
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
- en: vectorized operations, 40
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
- en: installing automatically, 356–357
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
- en: vector/matrix distinction, 78–79
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
- en: installing manually, 357–358
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
- en: '**372**'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3584
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
- en: where browser command, 289
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
- en: which.max() function, 73, 190
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
- en: which.min() function, 190
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
- en: which() function, 47–48
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
- en: whitespace, 233
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
- en: Wickham, Hadley, 136
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
- en: wireframe() function, 282–283
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
- en: wmins matrix, 77
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
- en: workers, snow package, 335
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
- en: working directory, 19–20
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
- en: writeBin() function, 248
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
- en: writeLines() function, 248
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
- en: write.table() function, 244
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
- en: writing, 161
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
- en: binary operations, 187
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ functions to be called from R,
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
- en: 323–324
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
- en: compiling and running code, 325
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
- en: debugging R/C code, 326–327
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdiagonals from
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
- en: square matrix example, 324–325
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
- en: prediction of discrete-valued time
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
- en: series example, 327–330
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
- en: closures, 174–175
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation in R
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
- en: example, 164–171
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
- en: getting files and directory
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
- en: information, 245
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
- en: to nonlocals
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
- en: with assign() function, 163
  id: totrans-3615
  prefs: []
  type: TYPE_NORMAL
- en: with superassignment operator,
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
- en: 161–162
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 212–213
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 223–225
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
- en: summing contents of many files
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
- en: example, 245–246
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
- en: when to use global variables, 171–174
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
- en: '**X**'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
- en: xlim option, 273–275
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
- en: x variable, 162
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
- en: '**Y**'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
- en: ylim option, 273–275
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**'
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
- en: z variable, 162
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
- en: '**373**'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
- en: The Electronic Frontier Foundation (EFF) is the leading organization defending
    civil liberties in the digital world. We defend free speech on the Internet, fight
    illegal surveillance, promote the rights of innovators to develop new digital
    technologies, and work to ensure that the rights and freedoms we enjoy are enhanced
    —
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
- en: rather than eroded — as our use of technology grows.
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
- en: PRIVACY EFF has sued telecom giant AT&T for giving the NSA unfettered access
    to the private communications of millions of their customers. eff.org/nsa
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
- en: FREE SPEECH EFF’s Coders’ Rights Project is defending the rights of programmers
    and security researchers to publish their findings without fear of legal challenges.
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
- en: eff.org/freespeech
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
- en: INNOVATION EFF's Patent Busting Project challenges overbroad patents that threaten
    technological innovation. eff.org/patent
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
- en: FAIR USE EFF is fighting prohibitive standards that would take away your right
    to receive and use over-the-air television broadcasts any way you choose. eff.org/IP/fairuse
    TRANSPARENCY EFF has developed the Switzerland Network Testing Tool to give individuals
    the tools to test for covert traffic filtering. eff.org/transparency
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
- en: INTERNATIONAL EFF is working to ensure that international treaties do not restrict
    our free speech, privacy or digital consumer rights. eff.org/global
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
- en: EFF is a member-supported organization. Join Now! www.eff.org/support
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 46](index-401_1.jpg)'
  id: totrans-3643
  prefs: []
  type: TYPE_IMG
- en: '![Image 47](index-401_2.jpg)'
  id: totrans-3644
  prefs: []
  type: TYPE_IMG
- en: '![Image 48](index-401_3.jpg)'
  id: totrans-3645
  prefs: []
  type: TYPE_IMG
- en: '![Image 49](index-401_4.jpg)'
  id: totrans-3646
  prefs: []
  type: TYPE_IMG
- en: '![Image 50](index-401_5.jpg)'
  id: totrans-3647
  prefs: []
  type: TYPE_IMG
- en: '![Image 51](index-401_6.jpg)'
  id: totrans-3648
  prefs: []
  type: TYPE_IMG
- en: UPDATES
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
- en: Visit *http://www.nostarch.com/artofr.htm* for updates, errata, and more.
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
- en: '*More no-nonsense books from*'
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
- en: NO STARCH PRESS
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
- en: MAP SCRIPTING 101
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
- en: LEARN YOU A HASKELL
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
- en: ELOQUENT JAVASCRIPT
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
- en: An Example-Driven Guide to Building
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
- en: FOR GREAT GOOD
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
- en: A Modern Introduction to Programming
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Maps with Bing, Yahoo!,
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
- en: A Beginner’s Guide
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MARIJN HAVERBEKE'
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
- en: and Google Maps
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
- en: JANUARY 2011, 224 PP., $29.95
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MIRAN LIPOVAýA'
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-282-1
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
- en: '*by* ADAM DUVANDER'
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
- en: APRIL 2011, 400 PP., $44.95
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
- en: AUGUST 2010, 376 PP., $34.95
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-283-8
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-271-5
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
- en: THE TCP/IP GUIDE
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
- en: THE MANGA GUIDE™ TO
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
- en: THE LINUX PROGRAMMING
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
- en: A Comprehensive, Illustrated Internet
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
- en: STATISTICS
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
- en: INTERFACE
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
- en: Protocols Reference
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
- en: '*by* SHIN TAKAHASHI *and* TREND-PRO'
  id: totrans-3678
  prefs: []
  type: TYPE_NORMAL
- en: A Linux and UNIX® System
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
- en: '*by* CHARLES M. KOZIEROK'
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
- en: CO., LTD
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
- en: Programming Handbook
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
- en: OCTOBER 2005, 1616 PP., $99.95, *hardcover*
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
- en: NOVEMBER 2008, 232 PP., $19.95
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MICHAEL KERRISK'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-047-6
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-189-3
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
- en: OCTOBER 2010, 1552 PP., $99.95, *hardcover*
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-220-3
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
- en: '**PHONE:**'
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
- en: '**EMAIL:**'
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
- en: 800.420.7240 OR
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
- en: SALES@NOSTARCH.COM
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
- en: 415.863.9900
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
- en: '**WEB:**'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
- en: MONDAY THROUGH FRIDAY,
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
- en: 9 A.M. TO 5 P.M. (PST)
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
- en: WWW.NOSTARCH.COM
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
- en: The fonts used in *The Art of R Programming* are New Baskerville, Futura, The
    Sans Mono Condensed and Dogma. The book was typeset with LATEX 2 *ε*
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
- en: package nostarch by Boris Veytsman *(2008/06/06 v1.3 Typesetting books for No*
    *Starch Press).*
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
- en: This book was printed and bound at Malloy Incorporated in Ann Arbor, Michigan.
    The paper is Glatfelter Spring Forge 60# Smooth, which is certi-fied by the Sustainable
    Forestry Initiative (SFI). The book uses a RepKover binding, which allows it to
    lie flat when open.
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](index-404_1.png)'
  id: totrans-3705
  prefs: []
  type: TYPE_IMG
- en: '**T A M E Y O U R D A T A**'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
- en: '**T H E**'
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
- en: '**HE A**'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
- en: '**A R T O F R**'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
- en: R is the world’s most popular language for developing
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
- en: • Interface R with C/C++ and Python for increased
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
- en: 'statistical software: Archaeologists use it to track the'
  id: totrans-3714
  prefs: []
  type: TYPE_NORMAL
- en: speed or functionality
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
- en: '**T O**'
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
- en: '**PROGR A MMING**'
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
- en: spread of ancient civilizations, drug companies use it
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
- en: • Find new packages for text analysis, image manipula-
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
- en: to discover which medications are safe and effective,
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
- en: tion, and thousands more
  id: totrans-3721
  prefs: []
  type: TYPE_NORMAL
- en: and actuaries use it to assess financial risks and keep
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
- en: '**A T O U R O F S T A T I S T I C A L S O F T W A R E D E S I G N**'
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
- en: '**F R P**'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
- en: markets running smoothly.
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
- en: • Squash annoying bugs with advanced debugging
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
- en: techniques
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of R Programming* takes you on a guided tour'
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
- en: of software development with R, from basic types
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re designing aircraft, forecasting the
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
- en: and data structures to advanced topics like closures,
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
- en: weather, or you just need to tame your data, *The Art of*
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
- en: '**N O R M A N M A T L O F F**'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
- en: recursion, and anonymous functions. No statistical
  id: totrans-3734
  prefs: []
  type: TYPE_NORMAL
- en: '*R Programming* is your guide to harnessing the power'
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3736
  prefs: []
  type: TYPE_NORMAL
- en: knowledge is required, and your programming skil s
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
- en: of statistical computing.
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
- en: can range from hobbyist to pro.
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
- en: '**A B O U T T H E A U T H O R**'
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, you’ll learn about functional and object-
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
- en: Norman Matloff is a professor of computer science
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming, running mathematical simulations,
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
- en: (and a former professor of statistics) at the University
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
- en: and rearranging complex data into simpler, more useful
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
- en: of California, Davis. His research interests include
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
- en: 'formats. You’ll also learn to:'
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
- en: paral el processing and statistical regression, and
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
- en: • Create artful graphs to visualize complex data sets
  id: totrans-3753
  prefs: []
  type: TYPE_NORMAL
- en: he is the author of several widely used web tutorials
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  id: totrans-3755
  prefs: []
  type: TYPE_NORMAL
- en: and functions
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
- en: on software development. He has written articles for
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
- en: the *New York Times*, the *Washington Post*, *Forbes* **M**
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
- en: • Write more efficient code using paral el R and
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
- en: '*Magazine*, and the *Los Angeles Times*, and he is the'
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
- en: co-author of *The Art of Debugging* (No Starch Press).
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
- en: '**NG**'
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
- en: '***TH E FI N EST I N G E E K E NTE RTAI N M E NT™***'
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
- en: www.nostarch.com
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
- en: '**MAT**'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
- en: '***“I LI E FLAT.”***'
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
- en: '**$39.95 *($41.95 CDN)***'
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
- en: '**S C S**'
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
- en: '*This book uses RepKover —a durable binding that won’t snap shut.*'
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
- en: '**T O H**'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
- en: '**M E**'
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
- en: '**LV**'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
- en: '**I P**'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
- en: '**ST U E**'
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
- en: '**I T I**'
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
- en: '**C E N**'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
- en: '**A R :**'
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
- en: '**L S**'
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
- en: '**SO /M**'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
- en: '**F A**'
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
- en: '**T T**'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
- en: '**W H**'
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
- en: '**A EM**'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
- en: '**RE ATICAL &**'
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  id: totrans-3794
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Copyright](index_split_000.html#p6)'
  id: totrans-3795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Brief Contents](index_split_000.html#p7)'
  id: totrans-3796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contents in Detail](index_split_000.html#p9)'
  id: totrans-3797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p19)'
  id: totrans-3798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p21)'
  id: totrans-3799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why Use R for Your Statistical Work?](index_split_000.html#p21)'
  id: totrans-3800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Whom Is This Book For?](index_split_000.html#p24)'
  id: totrans-3801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[My Own Background](index_split_000.html#p25)'
  id: totrans-3802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1: Getting Started](index_split_000.html#p27)'
  id: totrans-3803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.1 How to Run R](index_split_000.html#p27)'
  id: totrans-3804
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.2 A First R Session](index_split_000.html#p30)'
  id: totrans-3805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.3 Introduction to Functions](index_split_000.html#p33)'
  id: totrans-3806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.4 Preview of Some Important R Data Structures](index_split_000.html#p36)'
  id: totrans-3807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.5 Extended Example: Regression Analysis of Exam Grades](index_split_000.html#p42)'
  id: totrans-3808
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.5 扩展示例：考试成绩回归分析](index_split_000.html#p42)'
- en: '[1.6 Startup and Shutdown](index_split_000.html#p45)'
  id: totrans-3809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.6 启动和关闭](index_split_000.html#p45)'
- en: '[1.7 Getting Help](index_split_000.html#p46)'
  id: totrans-3810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.7 获取帮助](index_split_000.html#p46)'
- en: '[2: Vectors](index_split_000.html#p51)'
  id: totrans-3811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2: 向量](index_split_000.html#p51)'
- en: '[2.1 Scalars, Vectors, Arrays, and Matrices](index_split_000.html#p52)'
  id: totrans-3812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1 标量、向量、数组和矩阵](index_split_000.html#p52)'
- en: '[2.2 Declarations](index_split_000.html#p54)'
  id: totrans-3813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2 声明](index_split_000.html#p54)'
- en: '[2.3 Recycling](index_split_000.html#p55)'
  id: totrans-3814
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3 回收](index_split_000.html#p55)'
- en: '[2.4 Common Vector Operations](index_split_000.html#p56)'
  id: totrans-3815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.4 常见向量操作](index_split_000.html#p56)'
- en: '[2.5 Using all() and any()](index_split_001.html#p61)'
  id: totrans-3816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.5 使用all()和any()](index_split_001.html#p61)'
- en: '[2.6 Vectorized Operations](index_split_001.html#p65)'
  id: totrans-3817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.6 向量化操作](index_split_001.html#p65)'
- en: '[2.7 NA and NULL Values](index_split_001.html#p69)'
  id: totrans-3818
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.7 NA和NULL值](index_split_001.html#p69)'
- en: '[2.8 Filtering](index_split_001.html#p71)'
  id: totrans-3819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.8 过滤](index_split_001.html#p71)'
- en: '[2.9 A Vectorized if-then-else: The ifelse() Function](index_split_001.html#p74)'
  id: totrans-3820
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.9 向量化if-then-else：ifelse()函数](index_split_001.html#p74)'
- en: '[2.10 Testing Vector Equality](index_split_001.html#p80)'
  id: totrans-3821
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.10 测试向量等价性](index_split_001.html#p80)'
- en: '[2.11 Vector Element Names](index_split_001.html#p82)'
  id: totrans-3822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.11 向量元素名称](index_split_001.html#p82)'
- en: '[2.12 More on c()](index_split_001.html#p82)'
  id: totrans-3823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.12 关于c()的更多内容](index_split_001.html#p82)'
- en: '[3: Matrices and Arrays](index_split_001.html#p85)'
  id: totrans-3824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3: 矩阵和数组](index_split_001.html#p85)'
- en: '[3.1 Creating Matrices](index_split_001.html#p85)'
  id: totrans-3825
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.1 创建矩阵](index_split_001.html#p85)'
- en: '[3.2 General Matrix Operations](index_split_001.html#p87)'
  id: totrans-3826
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2 矩阵通用操作](index_split_001.html#p87)'
- en: '[3.3 Applying Functions to Matrix Rows and Columns](index_split_001.html#p96)'
  id: totrans-3827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.3 将函数应用于矩阵行和列](index_split_001.html#p96)'
- en: '[3.4 Adding and Deleting Matrix Rows and Columns](index_split_001.html#p99)'
  id: totrans-3828
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.4 添加和删除矩阵行和列](index_split_001.html#p99)'
- en: '[3.5 More on the Vector/Matrix Distinction](index_split_001.html#p104)'
  id: totrans-3829
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.5 关于向量/矩阵区别的更多内容](index_split_001.html#p104)'
- en: '[3.6 Avoiding Unintended Dimension Reduction](index_split_001.html#p106)'
  id: totrans-3830
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.6 避免意外的维度缩减](index_split_001.html#p106)'
- en: '[3.7 Naming Matrix Rows and Columns](index_split_001.html#p107)'
  id: totrans-3831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.7 命名矩阵行和列](index_split_001.html#p107)'
- en: '[3.8 Higher-Dimensional Arrays](index_split_001.html#p108)'
  id: totrans-3832
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.8 高维数组](index_split_001.html#p108)'
- en: '[4: Lists](index_split_001.html#p111)'
  id: totrans-3833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4: 列表](index_split_001.html#p111)'
- en: '[4.1 Creating Lists](index_split_001.html#p111)'
  id: totrans-3834
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.1 创建列表](index_split_001.html#p111)'
- en: '[4.2 General List Operations](index_split_001.html#p113)'
  id: totrans-3835
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2 列表通用操作](index_split_001.html#p113)'
- en: '[4.3 Accessing List Components and Values](index_split_002.html#p119)'
  id: totrans-3836
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3 访问列表组件和值](index_split_002.html#p119)'
- en: '[4.4 Applying Functions to Lists](index_split_002.html#p121)'
  id: totrans-3837
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.4 将函数应用于列表](index_split_002.html#p121)'
- en: '[4.5 Recursive Lists](index_split_002.html#p125)'
  id: totrans-3838
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.5 递归列表](index_split_002.html#p125)'
- en: '[5: Data Frames](index_split_002.html#p127)'
  id: totrans-3839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5: 数据框](index_split_002.html#p127)'
- en: '[5.1 Creating Data Frames](index_split_002.html#p128)'
  id: totrans-3840
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.1 创建数据框](index_split_002.html#p128)'
- en: '[5.2 Other Matrix-Like Operations](index_split_002.html#p130)'
  id: totrans-3841
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.2 其他矩阵类操作](index_split_002.html#p130)'
- en: '[5.3 Merging Data Frames](index_split_002.html#p135)'
  id: totrans-3842
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.3 合并数据框](index_split_002.html#p135)'
- en: '[5.4 Applying Functions to Data Frames](index_split_002.html#p138)'
  id: totrans-3843
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.4 将函数应用于数据框](index_split_002.html#p138)'
- en: '[6: Factors and Tables](index_split_002.html#p147)'
  id: totrans-3844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6: 因子和表格](index_split_002.html#p147)'
- en: '[6.1 Factors and Levels](index_split_002.html#p147)'
  id: totrans-3845
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.1 因子和水平](index_split_002.html#p147)'
- en: '[6.2 Common Functions Used with Factors](index_split_002.html#p149)'
  id: totrans-3846
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.2 因子常用函数](index_split_002.html#p149)'
- en: '[6.3 Working with Tables](index_split_002.html#p153)'
  id: totrans-3847
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.3 与表格一起工作](index_split_002.html#p153)'
- en: '[6.4 Other Factor- and Table-Related Functions](index_split_002.html#p162)'
  id: totrans-3848
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.4 其他因子和表格相关函数](index_split_002.html#p162)'
- en: '[7: R Programming Structures](index_split_003.html#p165)'
  id: totrans-3849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7: R编程结构](index_split_003.html#p165)'
- en: '[7.1 Control Statements](index_split_003.html#p165)'
  id: totrans-3850
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.1 控制语句](index_split_003.html#p165)'
- en: '[7.2 Arithmetic and Boolean Operators and Values](index_split_003.html#p171)'
  id: totrans-3851
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2 算术和布尔运算符及值](index_split_003.html#p171)'
- en: '[7.3 Default Values for Arguments](index_split_003.html#p172)'
  id: totrans-3852
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.3 参数的默认值](index_split_003.html#p172)'
- en: '[7.4 Return Values](index_split_003.html#p173)'
  id: totrans-3853
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.4 返回值](index_split_003.html#p173)'
- en: '[7.5 Functions Are Objects](index_split_003.html#p175)'
  id: totrans-3854
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.5 函数是对象](index_split_003.html#p175)'
- en: '[7.6 Environment and Scope Issues](index_split_003.html#p177)'
  id: totrans-3855
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.6 环境和作用域问题](index_split_003.html#p177)'
- en: '[7.7 No Pointers in R](index_split_003.html#p185)'
  id: totrans-3856
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.7 R中没有指针](index_split_003.html#p185)'
- en: '[7.8 Writing Upstairs](index_split_003.html#p187)'
  id: totrans-3857
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.8 向上写入](index_split_003.html#p187)'
- en: '[7.9 Recursion](index_split_003.html#p202)'
  id: totrans-3858
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.9 递归](index_split_003.html#p202)'
- en: '[7.10 Replacement Functions](index_split_003.html#p208)'
  id: totrans-3859
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.10 替换函数](index_split_003.html#p208)'
- en: '[7.11 Tools for Composing Function Code](index_split_004.html#p212)'
  id: totrans-3860
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.11 编写函数代码的工具](index_split_004.html#p212)'
- en: '[7.12 Writing Your Own Binary Operations](index_split_004.html#p213)'
  id: totrans-3861
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.12 编写自己的二进制操作](index_split_004.html#p213)'
- en: '[7.13 Anonymous Functions](index_split_004.html#p213)'
  id: totrans-3862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.13 匿名函数](index_split_004.html#p213)'
- en: '[8: Doing Math and Simulations in R](index_split_004.html#p215)'
  id: totrans-3863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8: 在 R 中进行数学和模拟](index_split_004.html#p215)'
- en: '[8.1 Math Functions](index_split_004.html#p215)'
  id: totrans-3864
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.1 数学函数](index_split_004.html#p215)'
- en: '[8.2 Functions for Statistical Distributions](index_split_004.html#p219)'
  id: totrans-3865
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.2 统计分布函数](index_split_004.html#p219)'
- en: '[8.3 Sorting](index_split_004.html#p220)'
  id: totrans-3866
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.3 排序](index_split_004.html#p220)'
- en: '[8.4 Linear Algebra Operations on Vectors and Matrices](index_split_004.html#p222)'
  id: totrans-3867
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.4 向量和矩阵的线性代数运算](index_split_004.html#p222)'
- en: '[8.5 Set Operations](index_split_004.html#p228)'
  id: totrans-3868
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.5 集合运算](index_split_004.html#p228)'
- en: '[8.6 Simulation Programming in R](index_split_004.html#p230)'
  id: totrans-3869
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.6 R 中的模拟编程](index_split_004.html#p230)'
- en: '[9: Object-Oriented Programming](index_split_004.html#p233)'
  id: totrans-3870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9: 面向对象编程](index_split_004.html#p233)'
- en: '[9.1 S3 Classes](index_split_004.html#p234)'
  id: totrans-3871
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.1 S3 类](index_split_004.html#p234)'
- en: '[9.2 S4 Classes](index_split_004.html#p248)'
  id: totrans-3872
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2 S4 类](index_split_004.html#p248)'
- en: '[9.3 S3 Versus S4](index_split_004.html#p252)'
  id: totrans-3873
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3 S3 与 S4 的比较](index_split_004.html#p252)'
- en: '[9.4 Managing Your Objects](index_split_004.html#p252)'
  id: totrans-3874
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.4 管理你的对象](index_split_004.html#p252)'
- en: '[10: Input/Output](index_split_004.html#p257)'
  id: totrans-3875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10: 输入/输出](index_split_004.html#p257)'
- en: '[10.1 Accessing the Keyboard and Monitor](index_split_004.html#p258)'
  id: totrans-3876
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.1 访问键盘和监视器](index_split_004.html#p258)'
- en: '[10.2 Reading and Writing Files](index_split_005.html#p261)'
  id: totrans-3877
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.2 读取和写入文件](index_split_005.html#p261)'
- en: '[10.3 Accessing the Internet](index_split_005.html#p272)'
  id: totrans-3878
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.3 访问互联网](index_split_005.html#p272)'
- en: '[11: String Manipulation](index_split_005.html#p277)'
  id: totrans-3879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11: 字符串操作](index_split_005.html#p277)'
- en: '[11.1 An Overview of String-Manipulation Functions](index_split_005.html#p277)'
  id: totrans-3880
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.1 字符串操作函数概述](index_split_005.html#p277)'
- en: '[11.2 Regular Expressions](index_split_005.html#p280)'
  id: totrans-3881
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.2 正则表达式](index_split_005.html#p280)'
- en: '[11.3 Use of String Utilities in the edtdbg Debugging Tool](index_split_005.html#p283)'
  id: totrans-3882
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.3 edtdbg 调试工具中的字符串实用工具的使用](index_split_005.html#p283)'
- en: '[12: Graphics](index_split_005.html#p287)'
  id: totrans-3883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12: 图形](index_split_005.html#p287)'
- en: '[12.1 Creating Graphs](index_split_005.html#p287)'
  id: totrans-3884
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.1 创建图表](index_split_005.html#p287)'
- en: '[12.2 Customizing Graphs](index_split_005.html#p298)'
  id: totrans-3885
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.2 自定义图表](index_split_005.html#p298)'
- en: '[12.3 Saving Graphs to Files](index_split_005.html#p306)'
  id: totrans-3886
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.3 将图表保存到文件](index_split_005.html#p306)'
- en: '[12.4 Creating Three-Dimensional Plots](index_split_005.html#p308)'
  id: totrans-3887
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.4 创建三维图表](index_split_005.html#p308)'
- en: '[13: Debugging](index_split_005.html#p311)'
  id: totrans-3888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13: 调试](index_split_005.html#p311)'
- en: '[13.1 Fundamental Principles of Debugging](index_split_005.html#p311)'
  id: totrans-3889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.1 调试的基本原则](index_split_005.html#p311)'
- en: '[13.2 Why Use a Debugging Tool?](index_split_005.html#p313)'
  id: totrans-3890
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.2 为什么使用调试工具？](index_split_005.html#p313)'
- en: '[13.3 Using R Debugging Facilities](index_split_005.html#p314)'
  id: totrans-3891
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.3 使用 R 调试设施](index_split_005.html#p314)'
- en: '[13.4 Moving Up in the World: More Convenient DebuggingTools](index_split_006.html#p326)'
  id: totrans-3892
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.4 向上走：更方便的调试工具](index_split_006.html#p326)'
- en: '[13.5 Ensuring Consistency in Debugging Simulation Code](index_split_006.html#p328)'
  id: totrans-3893
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.5 确保调试模拟代码的一致性](index_split_006.html#p328)'
- en: '[13.6 Syntax and Runtime Errors](index_split_006.html#p329)'
  id: totrans-3894
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.6 语法和运行时错误](index_split_006.html#p329)'
- en: '[13.7 Running GDB on R Itself](index_split_006.html#p329)'
  id: totrans-3895
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.7 在 R 本身上运行 GDB](index_split_006.html#p329)'
- en: '[14: Performance Enhancement: Speed and Memory](index_split_006.html#p331)'
  id: totrans-3896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14: 性能提升：速度和内存](index_split_006.html#p331)'
- en: '[14.1 Writing Fast R Code](index_split_006.html#p332)'
  id: totrans-3897
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.1 编写快速的 R 代码](index_split_006.html#p332)'
- en: '[14.2 The Dreaded for Loop](index_split_006.html#p332)'
  id: totrans-3898
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.2 可怕的 for 循环](index_split_006.html#p332)'
- en: '[14.3 Functional Programming and Memory Issues](index_split_006.html#p340)'
  id: totrans-3899
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3 函数式编程与内存问题](index_split_006.html#p340)'
- en: '[14.4 Using Rprof() to Find Slow Spots in Your Code](index_split_006.html#p342)'
  id: totrans-3900
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.4 使用 Rprof() 查找代码中的慢点](index_split_006.html#p342)'
- en: '[14.5 Byte Code Compilation](index_split_006.html#p346)'
  id: totrans-3901
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.5 字节码编译](index_split_006.html#p346)'
- en: '[14.6 Oh No, the Data Doesn’t Fit into Memory!](index_split_006.html#p346)'
  id: totrans-3902
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.6 哎呀，数据放不进内存！](index_split_006.html#p346)'
- en: '[15: Interfacing R to Other Languages](index_split_006.html#p349)'
  id: totrans-3903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15: 将 R 与其他语言接口](index_split_006.html#p349)'
- en: '[15.1 Writing C/C++ Functions to Be Called from R](index_split_006.html#p349)'
  id: totrans-3904
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15.1 将 C/C++ 函数编写为 R 可调用的函数](index_split_006.html#p349)'
- en: '[15.2 Using R from Python](index_split_006.html#p356)'
  id: totrans-3905
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15.2 从 Python 使用 R](index_split_006.html#p356)'
- en: '[16: Parallel R](index_split_006.html#p359)'
  id: totrans-3906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16: 并行 R](index_split_006.html#p359)'
- en: '[16.1 The Mutual Outlinks Problem](index_split_006.html#p359)'
  id: totrans-3907
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.1 互链问题](index_split_006.html#p359)'
- en: '[16.2 Introducing the snow Package](index_split_006.html#p360)'
  id: totrans-3908
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.2 介绍 snow 包](index_split_006.html#p360)'
- en: '[16.3 Resorting to C](index_split_006.html#p366)'
  id: totrans-3909
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.3 转向 C 语言](index_split_006.html#p366)'
- en: '[16.4 General Performance Considerations](index_split_006.html#p371)'
  id: totrans-3910
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.4 一般性能考虑](index_split_006.html#p371)'
- en: '[16.5 Debugging Parallel R Code](index_split_006.html#p377)'
  id: totrans-3911
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.5 调试并行 R 代码](index_split_006.html#p377)'
- en: '[Appendix A: Installing R](index_split_006.html#p379)'
  id: totrans-3912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录 A：安装 R](index_split_006.html#p379)'
- en: '[A.1 Downloading R from CRAN](index_split_006.html#p379)'
  id: totrans-3913
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.1 从 CRAN 下载 R](index_split_006.html#p379)'
- en: '[A.2 Installing from a Linux Package Manager](index_split_006.html#p379)'
  id: totrans-3914
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从 Linux 软件包管理器安装](index_split_006.html#p379)'
- en: '[A.3 Installing from Source](index_split_006.html#p380)'
  id: totrans-3915
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.3 从源代码安装](index_split_006.html#p380)'
- en: '[Appendix B: Installing and Using Packages](index_split_006.html#p381)'
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录 B：安装和使用软件包](index_split_006.html#p381)'
- en: '[B.1 Package Basics](index_split_006.html#p381)'
  id: totrans-3917
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.1 软件包基础](index_split_006.html#p381)'
- en: '[B.2 Loading a Package from Your Hard Drive](index_split_006.html#p382)'
  id: totrans-3918
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.2 从您的硬盘加载软件包](index_split_006.html#p382)'
- en: '[B.3 Downloading a Package from the Web](index_split_006.html#p382)'
  id: totrans-3919
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从 Web 下载软件包](index_split_006.html#p382)'
- en: '[B.4 Listing the Functions in a Package](index_split_006.html#p384)'
  id: totrans-3920
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.4 列出软件包中的函数](index_split_006.html#p384)'
- en: '[Index](index_split_006.html#p385)'
  id: totrans-3921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引](index_split_006.html#p385)'
- en: '[UPDATES](index_split_006.html#p401)'
  id: totrans-3922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更新](index_split_006.html#p401)'
