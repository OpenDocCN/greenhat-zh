- en: 'That’s right, too. We could go another iteration, but instead, let’s look at
    the last iteration, a place where bugs frequently arise in loops. So, let’s add
    a conditional breakpoint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: findruns <- function(x,k) {
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: runs <- NULL
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n-k)) {
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:(i+k-1)]==1)) runs <- c(runs,i)
  prefs: []
  type: TYPE_NORMAL
- en: 'if (i == n-k) browser() # break in last iteration of loop'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return(runs)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: And now run it again.
  prefs: []
  type: TYPE_NORMAL
- en: source("findruns.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows the last iteration was for i = 7\. But the vector is nine elements
    long, and k = 2, so our last iteration should be i = 8\. Some thought then reveals
    that the range in the loop should have been written as follows: for (i in 1:(n-k+1))
    {'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, note that the breakpoint that we set using setBreakpoint() is no
    longer valid, now that we’ve replaced the old version of the object findruns.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent testing (not shown here) indicates the code now works.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a more complex example.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.6.2 Debugging Finding City Pairs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our code in Section 3.4.2, which found the pair of cities with the closest
    distance between them. Here is a buggy version of that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: returns the minimum value of d[i,j], i != j, and the row/col attaining 2
  prefs: []
  type: TYPE_NORMAL
- en: that minimum, for square symmetric matrix d; no special policy on
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: ties;
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: motivated by distance matrices
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**295**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: mind <- function(d) {
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(d)
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: add a column to identify row number for apply()
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: dd <- cbind(d,1:n)
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: wmins <- apply(dd[-n,],1,imin)
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: wmins will be 2xn, 1st row being indices and 2nd being values
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: i <- which.min(wmins[1,])
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: j <- wmins[2,i]
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: return(c(d[i,j],i,j))
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: finds the location, value of the minimum in a row x
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: imin <- function(x) {
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: i <- x[n]
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(x[(i+1):(n-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: return(c(j,x[j]))
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use R’s debugging tools to find and fix the problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll run it first on a small test case:'
  prefs: []
  type: TYPE_NORMAL
- en: source("cities.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m <- rbind(c(0,12,5),c(12,0,8),c(5,8,0))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: mind(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in mind(m) : subscript out of bounds'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not an auspicious start! Unfortunately, the error message doesn’t tell us where
    the code blew up. But the debugger will give us that information:'
  prefs: []
  type: TYPE_NORMAL
- en: options(error=recover)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mind(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in mind(m) : subscript out of bounds'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a frame number, or 0 to exit
  prefs: []
  type: TYPE_NORMAL
- en: '1: mind(m)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selection: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Called from: eval(expr, envir, enclos)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> where
  prefs: []
  type: TYPE_NORMAL
- en: '**296**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'where 1: eval(expr, envir, enclos)'
  prefs: []
  type: TYPE_NORMAL
- en: 'where 2: eval(quote(browser()), envir = sys.frame(which))'
  prefs: []
  type: TYPE_NORMAL
- en: 'where 3 at cities.R#13: function ()'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (.isMethodsDispatchOn()) {
  prefs: []
  type: TYPE_NORMAL
- en: tState <- tracingState(FALSE)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so the problem occurred in mind() rather than imin() and in particular
    at line 13\. It still could be the fault of imin(), but for now, let’s deal with
    the former.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is another way we could have determined that the blowup occurred on
    line 13\.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We would enter the debugger as before but probe the local variables. We could
    reason* *that if the subscript bounds error had occurred at line 9, then the variable
    wmins would* *not have been set, so querying it would give us an error message
    like* Error: object'
  prefs: []
  type: TYPE_NORMAL
- en: '''wmins'' not found. *On the other hand, if the blowup occurred on line 13,
    even j* *would have been set.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the error occurred with d[i,j], let’s look at those variables: Browse[1]>
    d'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> j
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 12'
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed a problem—d only has three columns, yet j, a column
  prefs: []
  type: TYPE_NORMAL
- en: subscript, is 12\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the variable from which we gleaned j, wmins:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> wmins
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall how the code was designed, column k of wmins is supposed to contain
    information about the minimum value in row k of d. So here wmins is saying that
    in the first row (k = 1) of d,(0,12,5), the minimum value is 12, occurring at
    index 2\. But it should be 5 at index 3\. So, something went wrong with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: wmins <- apply(dd[-n, ], 1, imin)
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**297**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: There are several possibilities here. But since ultimately imin() is called,
    we can check them all from within that function. So, let’s set the debug status
    of imin(), quit the debugger, and rerun the code.
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> Q
  prefs: []
  type: TYPE_NORMAL
- en: debug(imin)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mind(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'debugging in: FUN(newX[, i], ...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.R#17: {'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: i <- x[n]
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(x[(i + 1):(n - 1)])
  prefs: []
  type: TYPE_NORMAL
- en: return(c(j, x[j]))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: So, we’re in imin(). Let’s see if it properly received the first row of dd,
    which should be (0,12,5,1).
  prefs: []
  type: TYPE_NORMAL
- en: Browse[4]> x
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 12 5 1'
  prefs: []
  type: TYPE_NORMAL
- en: It’s confirmed. This seems to indicate that the first two arguments to apply()
    were correct and that the problem is instead within imin(), though that remains
    to be seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s single-step through, occasionally typing confirmational queries: Browse[2]>
    n'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#17: n <- length(x)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#18: i <- x[n]'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#19: j <- which.min(x[(i + 1):(n - 1)])'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#20: return(c(j, x[j]))'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> print(n)
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 4'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> j
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we designed our call which.min(x[(i + 1):(n - 1)] to look only at
    the above-diagonal portion of this row. This is because the matrix is symmetric
    and because we don’t want to consider the distance between a city and itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**298**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the value j = 2 does not confirm. The minimum value in (0,12,5) is 5, which
    occurs at index 3 of that vector, not index 2\. Thus, the problem is in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(x[(i + 1):(n - 1)])
  prefs: []
  type: TYPE_NORMAL
- en: What could be wrong?
  prefs: []
  type: TYPE_NORMAL
- en: After taking a break, we realize that although the minimum value of (0,12,5)
    occurs at index 3 of that vector, that is *not* what we asked which.min() to find
    for us. Instead, that i + 1 term means we asked for the index of the minimum in
    (12,5), which is 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We did ask which.min() for the correct information, but we failed to use it
    correctly, because we do want the index of the minimum in (0,12,5). We need to
    adjust the output of which.min() accordingly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(x[(i+1):(n-1)])
  prefs: []
  type: TYPE_NORMAL
- en: k <- i + j
  prefs: []
  type: TYPE_NORMAL
- en: return(c(k,x[k]))
  prefs: []
  type: TYPE_NORMAL
- en: We make the fix and try again.
  prefs: []
  type: TYPE_NORMAL
- en: mind(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in mind(m) : subscript out of bounds'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a frame number, or 0 to exit
  prefs: []
  type: TYPE_NORMAL
- en: '1: mind(m)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selection:'
  prefs: []
  type: TYPE_NORMAL
- en: Oh no, *another* bounds error! To see where the blowup occurred this time, we
    issue the where command as before, and we find it was at line 13
  prefs: []
  type: TYPE_NORMAL
- en: again. What about i and j now?
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> j
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5'
  prefs: []
  type: TYPE_NORMAL
- en: The value of j is still wrong; it cannot be larger than 3, as we have only three
    columns in this matrix. On the other hand, i is correct. The overall minimum value
    in dd is 5, occurring in row 1, column 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s check the source of j again, the matrix wmins:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> wmins
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**299**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Well, there are the 3 and 5 in column 1, just as should be the case.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, column 1 here contains the information for row 1 in d, so wmins is
    saying that the minimum value in row 1 is 5, occurring at index 3 of that row,
    which is correct.
  prefs: []
  type: TYPE_NORMAL
- en: After taking another break, though, we realize that while wmins is correct,
    our *use* of it isn’t. We have the rows and columns of that matrix mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code:'
  prefs: []
  type: TYPE_NORMAL
- en: i <- which.min(wmins[1,])
  prefs: []
  type: TYPE_NORMAL
- en: j <- wmins[2,i]
  prefs: []
  type: TYPE_NORMAL
- en: 'should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: i <- which.min(wmins[2,])
  prefs: []
  type: TYPE_NORMAL
- en: j <- wmins[1,i]
  prefs: []
  type: TYPE_NORMAL
- en: After making that change and resourcing our file, we try it out.
  prefs: []
  type: TYPE_NORMAL
- en: mind(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5 1 3'
  prefs: []
  type: TYPE_NORMAL
- en: This is correct, and subsequent tests with larger matrices worked, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4 Moving Up in the World: More Convenient Debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tools**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As just seen, R’s debugging tools are effective. However, they’re not very
    convenient. Fortunately, there are various tools that make the process easier.
    In approximate chronological order of development, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The debug package by Mark Bravington
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: My edtdbg package, which works with the Vim and Emacs text editors
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Vitalie Spinu’s ess-tracebug, which runs under Emacs (with the same goals as
    edtdbg but with more Emacs-specific features)
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: REvolution Analytics’ Integrated Development Environment (IDE)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As of this writing (July 2011), work is in progress by the teams that develop
    the* *StatET and RStudio IDEs to add debugging tools.*'
  prefs: []
  type: TYPE_NORMAL
- en: All of these tools are cross-platform, working on Linux, Windows, and Mac systems,
    with the exception of the REvolution Analytics product. That IDE is available
    only on Windows systems with Microsoft Visual Studio. All of the tools are open
    source or free, again with the exception of the REvolution Analytics product.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do these packages have to offer? To me, one of the biggest problems
    with R’s built-in debugging tools is the lack of a window that shows the big picture—a
    window displaying your R code with a cursor that moves **300**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 39](index-327_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 40](index-327_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'through the code as you single-step through it. For example, consider this
    excerpt from our previous browser output:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#17: n <- length(x)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at cities.r#18: i <- x[n]'
  prefs: []
  type: TYPE_NORMAL
- en: This is nice, but where are these lines in our code? Most GUI debuggers for
    other languages feature a window showing the user’s source code, with a symbol
    indicating the next line to be executed. All of the R tools listed at the start
    of this section remedy this lack in core R. The Bravington debug package creates
    a separate window for exactly this purpose. The other tools have your text editor
    double as that window, thus saving space on your screen compared to using debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, these tools allow you to set breakpoints and handle other debugging
    operations without moving your screen’s cursor from the editor window to your
    R execution window. This is convenient and saves typing as well, greatly enhancing
    your ability to concentrate on the real task at hand: finding your bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the cities example again. I opened the GVim text editor on my
    source file in conjunction with edtdbg, did some startup for edtdbg, and then
    hit the [ (left bracket) key twice to single-step twice through the code.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting GVim window is shown in Figure 13-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-1: Source window in edtdbg*'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**301**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Operation of edtdbg for Emacs is the same as shown here, just with different
    keystrokes* *used for the commands. For instance, F8 is used for single-stepping
    instead of [.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the editor’s cursor is now on this line:'
  prefs: []
  type: TYPE_NORMAL
- en: wmins <- apply(dd[-n, ], 1, imin)
  prefs: []
  type: TYPE_NORMAL
- en: This shows the line to be executed next.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I want to single-step a line, I simply hit the [ key while I’m in the
    editor window. The editor then tells the browser to execute its n command, without
    my needing to move the mouse to the R execution window, and then the editor moves
    its cursor to the next line. I can also hit ] for the browser’s c command. Each
    time I execute a line or lines in this manner, the editor’s cursor moves right
    along.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I make a change to my source code, typing ,src (the comma
  prefs: []
  type: TYPE_NORMAL
- en: is part of the command) into my GVim window will tell R to call source() on
    it. Each time I want to rerun my code, I hit ,dt. I rarely, if ever, need to move
    my mouse away from the editor window to the R window and back.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the editor has become my debugger in addition to providing its editing
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5 Ensuring Consistency in Debugging Simulation Code**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re doing anything with random numbers, you’ll need to be able to reproduce
    the same stream of numbers each time you run your program during the debugging
    session. Without this, your bugs may not be reproducible, making them even harder
    to fix.
  prefs: []
  type: TYPE_NORMAL
- en: The set.seed() function controls this by reinitializing the random number sequence
    to a given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.8811480 0.2853269 0.5864738'
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.4155105 0.4852900 0.6591892'
  prefs: []
  type: TYPE_NORMAL
- en: runif(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set.seed(8888)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: runif(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  prefs: []
  type: TYPE_NORMAL
- en: set.seed(8888)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: runif(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5775979 0.4588383 0.8354707'
  prefs: []
  type: TYPE_NORMAL
- en: The call runif(3) generates three random numbers from the uniform
  prefs: []
  type: TYPE_NORMAL
- en: distribution on the interval (0,1). Each time we make that call, we will get
    a different set of three numbers. But with set.seed(), we can start over and get
    the same sequence of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**302**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6 Syntax and Runtime Errors**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common syntax errors will be lack of matching parentheses, brackets,
    braces, or quotation marks. When you encounter a syntax
  prefs: []
  type: TYPE_NORMAL
- en: error, this is the first thing you should check and double-check. I highly recommend
    that you use a text editor that does parentheses matching and syntax coloring
    for R, such as Vim or Emacs.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that often when you get a message saying there is a syntax error on
    a certain line, the error may actually be in a much earlier line.
  prefs: []
  type: TYPE_NORMAL
- en: This can occur with any language, but R seems especially prone to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it just isn’t obvious to you where your syntax error is, I recommend selectively
    commenting out some of your code, better enabling you to pinpoint the location
    of the syntax problem. Generally, it helps to follow a binary search approach:
    Comment out half of your code (being careful to maintain syntax integrity) and
    see if the same error arises. If it does, it’s in the remaining half; otherwise,
    it’s in the half you deleted. Then cut that half in half, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may sometimes get messages like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There were 50 or more warnings (use warnings() to see the first 50) These should
    be heeded—run warnings() as suggested. The problem
  prefs: []
  type: TYPE_NORMAL
- en: 'could range from nonconvergence of an algorithm to misspecification of a matrix
    argument to a function. In many cases, the program output may be invalid, though
    it may well be fine, too, say with this message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fitted probabilities numerically 0 or 1 occurred in: glm...'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you may find it useful to issue this command:'
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This instructs R to turn warnings into actual errors and makes the locations
    of the warnings easier to find.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.7 Running GDB on R Itself**'
  prefs: []
  type: TYPE_NORMAL
- en: This section may be of interest to you even if you are not trying to fix a bug
    in R. For example, you may have written some C code to interface to R (covered
    in Chapter 15) and found it to be buggy. In order to run GDB on that C function,
    you must first run R itself through GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Or, you may be interested in the internals of R, say to determine how you can
    write efficient R code, and wish to explore the internals by stepping through
    the R source code with a debugging tool such as GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**303**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can invoke R through GDB from a shell command line (see Section
    15.1.4), for our purposes here, I suggest using separate windows for R and GDB.
    Here’s the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Start R in one window, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: In another window, determine the ID number of your R process. In
  prefs: []
  type: TYPE_NORMAL
- en: UNIX family systems, for instance, this is obtained by something like ps -a.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: In that second window, submit GDB’s attach command with the R pro-
  prefs: []
  type: TYPE_NORMAL
- en: cess number.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Submit the continue command to GDB.
  prefs: []
  type: TYPE_NORMAL
- en: You can set breakpoints in the R source code either before continuing or by
    interrupting GDB later with CTRL-C. See Section 15.1.4 for details for debugging
    C code called from R. If, on the other hand, you wish to use GDB
  prefs: []
  type: TYPE_NORMAL
- en: to explore the R source code, note the following.
  prefs: []
  type: TYPE_NORMAL
- en: The R source code is dominated by S expression pointers (SEXPs),
  prefs: []
  type: TYPE_NORMAL
- en: which are pointers to C structs that contain an R variable’s value, type, and
    so on. You can use the R internal function Rf_PrintValue(s) to inspect SEXP
  prefs: []
  type: TYPE_NORMAL
- en: 'values. For example, if the SEXP is named s, then in GDB, type this: call Rf_PrintValue(s)'
  prefs: []
  type: TYPE_NORMAL
- en: This prints the value.
  prefs: []
  type: TYPE_NORMAL
- en: '**304**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](index-331_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**14**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PERFORMANCE ENHANCEMENT:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SPEED AND MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science curricula, a common
  prefs: []
  type: TYPE_NORMAL
- en: theme is the trade-off between time and
  prefs: []
  type: TYPE_NORMAL
- en: space. In order to have a fast-running pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram, you may need to use more memory space.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in order to conserve memory space,
  prefs: []
  type: TYPE_NORMAL
- en: you might need to settle for slower code. In the R lan-
  prefs: []
  type: TYPE_NORMAL
- en: guage, this trade-off is of particular interest for the fol-
  prefs: []
  type: TYPE_NORMAL
- en: 'lowing reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: R is an interpreted language. Many of the commands are written in C
  prefs: []
  type: TYPE_NORMAL
- en: and thus do run in fast machine code. But other commands, and your
  prefs: []
  type: TYPE_NORMAL
- en: own R code, are pure R and thus interpreted. So, there is a risk that your R
    application may run more slowly than you would like.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: All objects in an R session are stored in memory. More precisely, all objects
    are stored in R’s memory address space. R places a limit of 231 *−* 1 bytes on
    the size of any object, even on 64-bit machines and even if you have a lot of
    RAM. Yet some applications do encounter
  prefs: []
  type: TYPE_NORMAL
- en: larger objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will suggest ways that you can enhance the performance of your
    R code, taking into account the time/space trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.1 Writing Fast R Code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What can be done to make R code faster? Here are the main tools available to
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Optimize your R code through vectorization, use of byte-code compilation, and
    other approaches.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Write the key, CPU-intensive parts of your code in a compiled language such
    as C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Write your code in some form of parallel R.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach will be covered in this chapter, and the other approaches
    are covered in Chapters 15 and 16\.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize your R code, you need to understand R’s functional pro-
  prefs: []
  type: TYPE_NORMAL
- en: gramming nature and the way R uses memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.2 The Dreaded for Loop**'
  prefs: []
  type: TYPE_NORMAL
- en: The r-help discussion listserv for R often has questions about how to accomplish
    various tasks without for loops. There seems to be a feeling that programmers
    should avoid these loops at all costs.1 Those who pose the queries usually have
    the goal of speeding up their code.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that simply rewriting code to avoid loops will
    not necessarily make the code faster. However, in some cases, dramatic speedup
    may be attained, usually through vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.2.1 Vectorization for Speedup***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you can use vectorization instead of looping. For example, if x
    and y are vectors of equal lengths, you can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: z <- x + y
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not only more compact, but even more important, it is faster than using
    this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a quick timing comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- runif(1000000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- runif(1000000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1 By contrast, while loops pose much more of a challenge, because they are difficult
    to vectorize effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**306**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: z <- vector(length=1000000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z <- x + y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.052'
  prefs: []
  type: TYPE_NORMAL
- en: '0.016'
  prefs: []
  type: TYPE_NORMAL
- en: '0.068'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(for (i in 1:length(x)) z[i] <- x[i] + y[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '8.088'
  prefs: []
  type: TYPE_NORMAL
- en: '0.044'
  prefs: []
  type: TYPE_NORMAL
- en: '8.175'
  prefs: []
  type: TYPE_NORMAL
- en: What a difference! The version without a loop was more than 120 times faster
    in elapsed time. While timings may vary from one run to another (a second run
    of the loop version had elapsed time of 22.958), in some cases,
  prefs: []
  type: TYPE_NORMAL
- en: “delooping” R code can really pay off.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth discussing some of the sources of slowdown in the loop version.
    What may not be obvious to programmers coming to R from other languages is that
    numerous function calls are involved in the loop version of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Though syntactically the loop looks innocuous, for() is, in fact, a function.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon : looks even more innocuous, but it’s a function too. For instance,
    1:10 is actually the : function called on the arguments 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '":"(1,10)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 3 4 5 6 7 8 9 10'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Each vector subscript operation represents a function call, with calls to [
  prefs: []
  type: TYPE_NORMAL
- en: for the two reads and to [<- in the case of the write.
  prefs: []
  type: TYPE_NORMAL
- en: Function calls can be time-consuming, as they involve setting up stack frames
    and the like. Suffering that time penalty at every iteration of the loop adds
    up to a big slowdown.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, if we were to write this in C, there would be no function calls.
    Indeed, that is essentially what happens in our first code snippet. There are
    function calls there as well, namely a call to + and one to - *>* , but each is
    called only once, not 1,000,000 times, as in the loop version. Thus, the first
    version of the code is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'One type of vectorization is *vector filtering* For instance, let’s rewrite
    our function oddcount() from Section 1.3:'
  prefs: []
  type: TYPE_NORMAL
- en: oddcount <- function(x) return(sum(x%%2==1))
  prefs: []
  type: TYPE_NORMAL
- en: There is no explicit loop here, and even though R will internally loop through
    the array, this will be done in native machine code. Again, the anticipated speedup
    does occur.
  prefs: []
  type: TYPE_NORMAL
- en: x <- sample(1:1000000,100000,replace=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(oddcount(x))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**307**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '0.012'
  prefs: []
  type: TYPE_NORMAL
- en: '0.000'
  prefs: []
  type: TYPE_NORMAL
- en: '0.015'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: c <- 0
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(x))
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: if (x[i] %% 2 == 1) c <- c+1
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: return(c)
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: + )
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.308'
  prefs: []
  type: TYPE_NORMAL
- en: '0.000'
  prefs: []
  type: TYPE_NORMAL
- en: '0.310'
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder whether it matters in this case, since even the loop version
    of the code took less than a second to run. But if this code had been part of
    an enclosing loop, with many iterations, the difference could be important indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of other vectorized functions that may speed up your code
  prefs: []
  type: TYPE_NORMAL
- en: are ifelse(), which(), where(), any(), all(), cumsum(), and cumprod(). In the
    matrix case, you can use rowSums(), colSums(), and so on. In “all possible combinations”
    types of settings, combin(), outer(), lower.tri(), upper.tri(), or expand.grid()
    may be just what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Though apply() eliminates an explicit loop, it is actually implemented in R
    rather than C and thus will usually not speed up your code. However, the other
    apply functions, such as lapply(), can be very helpful in speeding up your code.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.2.2 Extended Example: Achieving Better Speed in a Monte Carlo***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Simulation***'
  prefs: []
  type: TYPE_NORMAL
- en: In some applications, simulation code can run for hours, days, or even months,
    so speedup methods are of high interest. Here, we’ll look at two simulation examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s consider the following code from Section 8.6:'
  prefs: []
  type: TYPE_NORMAL
- en: sum <- 0
  prefs: []
  type: TYPE_NORMAL
- en: nreps <- 100000
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  prefs: []
  type: TYPE_NORMAL
- en: sum <- sum + max(xy)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: print(sum/nreps)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a revision (hopefully faster):'
  prefs: []
  type: TYPE_NORMAL
- en: nreps <- 100000
  prefs: []
  type: TYPE_NORMAL
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  prefs: []
  type: TYPE_NORMAL
- en: '**308**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: maxs <- pmax(xymat[,1],xymat[,2])
  prefs: []
  type: TYPE_NORMAL
- en: print(mean(maxs))
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we generate all the random variates at once, storing them in
    a matrix xymat, with one (X,Y) pair per row:'
  prefs: []
  type: TYPE_NORMAL
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we find all the max(X,Y) values, storing those values in maxs, and then
    simply call mean().
  prefs: []
  type: TYPE_NORMAL
- en: It’s easier to program, and we believe it will be faster. Let’s check that.
  prefs: []
  type: TYPE_NORMAL
- en: I had the original code in the file *MaxNorm.R* and the improved version in
    *MaxNorm2.R*.
  prefs: []
  type: TYPE_NORMAL
- en: system.time(source("MaxNorm.R"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5667599'
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '1.700'
  prefs: []
  type: TYPE_NORMAL
- en: '0.004'
  prefs: []
  type: TYPE_NORMAL
- en: '1.722'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(source("MaxNorm2.R"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5649281'
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.132'
  prefs: []
  type: TYPE_NORMAL
- en: '0.008'
  prefs: []
  type: TYPE_NORMAL
- en: '0.143'
  prefs: []
  type: TYPE_NORMAL
- en: The speedup is dramatic, once again.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We achieved an increase in speed, at the expense of using more memory, by
    keeping our* *random numbers in an array instead of generating and discarding
    them one pair at a* *time. As mentioned earlier, the time/space trade-off is a
    common one in the computing* *world and in the R world in particular.*'
  prefs: []
  type: TYPE_NORMAL
- en: We attained an excellent speedup in this example, but it was misleadingly easy.
    Let’s look at a slightly more complicated example.
  prefs: []
  type: TYPE_NORMAL
- en: Our next example is a classic exercise from elementary probability
  prefs: []
  type: TYPE_NORMAL
- en: courses. Urn 1 contains ten blue marbles and eight yellow ones. In urn 2, the
    mixture is six blue and six yellow. We draw a marble at random from urn 1, transfer
    it to urn 2, and then draw a marble at random from urn 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the probability that that second marble is blue? This is easy to find
    analytically, but we’ll use simulation. Here is the straightforward way: 1'
  prefs: []
  type: TYPE_NORMAL
- en: perform nreps repetitions of the marble experiment, to estimate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: P(pick blue from Urn 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: sim1 <- function(nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'nb1 <- 10 # 10 blue marbles in Urn 1'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: 'n1 <- 18 # number of marbles in Urn 1 at 1st pick'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'n2 <- 13 # number of marbles in Urn 2 at 2nd pick'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: 'count <- 0 # number of repetitions in which get blue from Urn 2'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: 'nb2 <- 6 # 6 blue marbles orig. in Urn 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**309**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: pick from Urn 1 and put in Urn 2; is it blue?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: if (runif(1) < nb1/n1) nb2 <- nb2 + 1
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: pick from Urn 2; is it blue?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: if (runif(1) < nb2/n2) count <- count + 1
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: 'return(count/nreps) # est. P(pick blue from Urn 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can do it without loops, using apply():'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: sim2 <- function(nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: nb1 <- 10
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: nb2 <- 6
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: n1 <- 18
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: n2 <- 13
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: pre-generate all our random numbers, one row per repetition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: define simfun for use in apply(); simulates one repetition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: simfun <- function(rw) {
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: rw ("row") is a pair of random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: choose from Urn 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: if (rw[1] < nb1/n1) nb2 <- nb2 + 1
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: choose from Urn 2, and return boolean on choosing blue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: return (rw[2] < nb2/n2)
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: z <- apply(u,1,simfun)
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: z is a vector of booleans but they can be treated as 1s, 0s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(z))
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we set up a matrix u with two columns of U(0,1) random variates.
  prefs: []
  type: TYPE_NORMAL
- en: The first column is used for our simulation of drawing from urn 1, and the second
    for drawing from urn 2\. This way, we generate all our random numbers at once,
    which might save a bit of time, but the main point is to set up for using apply().
    Toward that goal, our function simfun() works on one repetition of the experiment—that
    is, one row of u. We set up the call to apply() to go through all of the nreps
    repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since the function simfun() is declared within sim2(), the locals
    of sim2()—n1, n2, nb1, and nb2—are available as globals of simfun(). Also, since
    a Boolean vector will automatically be changed by R to 1s and 0s, we can find
    the fraction of TRUE values in the vector by simply calling mean().
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s compare performance.
  prefs: []
  type: TYPE_NORMAL
- en: system.time(print(sim1(100000)))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.5086'
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '2.465'
  prefs: []
  type: TYPE_NORMAL
- en: '0.028'
  prefs: []
  type: TYPE_NORMAL
- en: '2.586'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(print(sim2(10000)))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**310**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.5031'
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '2.936'
  prefs: []
  type: TYPE_NORMAL
- en: '0.004'
  prefs: []
  type: TYPE_NORMAL
- en: '3.027'
  prefs: []
  type: TYPE_NORMAL
- en: In spite of the many benefits of functional programming, this approach using
    apply() didn’t help. Instead, things got worse. Since this could be simply due
    to random sampling variation, I ran the code several times again, with similar
    results.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s look at vectorizing this simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: sim3 <- function(nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: nb1 <- 10
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: nb2 <- 6
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: n1 <- 18
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: n2 <- 13
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: set up the condition vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(cndtn))
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main work is done in this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  prefs: []
  type: TYPE_NORMAL
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  prefs: []
  type: TYPE_NORMAL
- en: To get that, we reasoned out which conditions would lead to choosing a blue
    marble on the second pick, coded them, and then assigned them to cndtn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that *<* = and & are functions; in fact, they are vector functions,
    so they should be fast. Sure enough, this brings quite an improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(print(sim3(10000)))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.4987'
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.060'
  prefs: []
  type: TYPE_NORMAL
- en: '0.016'
  prefs: []
  type: TYPE_NORMAL
- en: '0.076'
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the approach we took to speed up the code here could be applied
    to many other Monte Carlo simulations. However, it’s clear that the analog of
    the statement that computes cndtn would quickly become quite complex, even for
    seemingly simple applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the approach would not work in “infinite-stage” situations, meaning
    an unlimited number of time steps. Here, we are considering the marble example
    as being two-stage, with two columns to the matrix u.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**311**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***14.2.3 Extended Example: Generating a Powers Matrix***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall in Section 9.1.7, we needed to generate a matrix of powers of our predictor
    variable. We used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: powers1 <- function(x,dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(x,nrow=length(x))
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'prod <- x # current product'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: One glaring problem is that cbind() is used to build up the output matrix, column
    by column. This is very costly in terms of memory-allocation time. It’s much better
    to allocate the full matrix at the beginning, even though it will be empty, as
    this will mean incurring the cost of only one memory-allocation operation.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: powers2 <- function(x,dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(nrow=length(x),ncol=dg)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'prod <- x # current product'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: pw[,1] <- prod
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: pw[,i] <- prod
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: And indeed, powers2() is a lot faster.
  prefs: []
  type: TYPE_NORMAL
- en: x <- runif(1000000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(powers1(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.776'
  prefs: []
  type: TYPE_NORMAL
- en: '0.356'
  prefs: []
  type: TYPE_NORMAL
- en: '1.334'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(powers2(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.388'
  prefs: []
  type: TYPE_NORMAL
- en: '0.204'
  prefs: []
  type: TYPE_NORMAL
- en: '0.593'
  prefs: []
  type: TYPE_NORMAL
- en: '**312**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: And yet, powers2() still contains a loop. Can we do better? It would seem that
    this setting is perfect for outer(), whose call form is
  prefs: []
  type: TYPE_NORMAL
- en: outer(X,Y,FUN)
  prefs: []
  type: TYPE_NORMAL
- en: This call applies the function FUN() to all possible pairs of elements of X
  prefs: []
  type: TYPE_NORMAL
- en: and elements of Y. The default value of FUN is multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: powers3 <- function(x,dg) return(outer(x,1:dg,"^"))
  prefs: []
  type: TYPE_NORMAL
- en: For each combination of element of x and element of 1:dg (resulting in length(x)
    *×* dg combinations in all), outer() calls the exponentiation function
  prefs: []
  type: TYPE_NORMAL
- en: ^ on that combination, placing the results in a length(x) *×* dg matrix. This
    is exactly what we need, and as a bonus, the code is quite compact. But is the
    code faster?
  prefs: []
  type: TYPE_NORMAL
- en: system.time(powers3(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '1.336'
  prefs: []
  type: TYPE_NORMAL
- en: '0.204'
  prefs: []
  type: TYPE_NORMAL
- en: '1.747'
  prefs: []
  type: TYPE_NORMAL
- en: What a disappointment! Here, we’re using a fancy R function, with very compact
    code, but getting the worst performance of the three functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'And it gets even worse. Here’s what happens if we try to make use of cumprod():'
  prefs: []
  type: TYPE_NORMAL
- en: powers4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(x,dg) {
  prefs: []
  type: TYPE_NORMAL
- en: repx <- matrix(rep(x,dg),nrow=length(x))
  prefs: []
  type: TYPE_NORMAL
- en: return(t(apply(repx,1,cumprod)))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(powers4(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '28.106'
  prefs: []
  type: TYPE_NORMAL
- en: 1.120 83.255
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we made multiple copies of x, since the powers of a number
    n are simply cumprod(c(1,n,n,n...)). But in spite of dutifully using two C-level
    R functions, the performance was disastrous.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is that performance issues can be unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: All you can do is be armed with an understanding of the basic issues, vectorization,
    and the memory aspects explained next and then try various approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**313**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3 Functional Programming and Memory Issues**'
  prefs: []
  type: TYPE_NORMAL
- en: Most R objects are *immutable*, or unchangeable. Thus, R operations are implemented
    as functions that reassign to the given object, a trait that can have performance
    implications.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.3.1 Vector Assignment Issues***'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of some of the issues that can arise, consider this simple-looking
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: z[3] <- 8
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in Chapter 7, this assignment is more complex than it seems. It is
    actually implemented via the replacement function "[<-" through this call and
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: z <- "[<-"(z,3,value=8)
  prefs: []
  type: TYPE_NORMAL
- en: An internal copy of z is made, element 3 of the copy is changed to 8, and then
    the resulting vector is reassigned to z. And recall that the latter simply means
    that z is pointed to the copy.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, even though we are ostensibly changing just one element of the
    vector, the semantics say that *the entire vector is recomputed*. For a long vector,
    this would slow down the program considerably. The same would be true for a shorter
    vector if it were assigned from within a loop of our code.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, R does take some measures to mitigate this impact, but it
    is a key point to consider when aiming for fast code. You should be mindful of
    this when working with vectors (including arrays). If your code seems to be running
    unexpectedly slowly, assignment of vectors should be a prime area of suspicion.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.3.2 Copy-on-Change Issues***'
  prefs: []
  type: TYPE_NORMAL
- en: 'A related issue is that R (usually) follows a *copy-on-change* policy. For
    instance, if we execute the following in the previous setting:'
  prefs: []
  type: TYPE_NORMAL
- en: y <- z
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: then initially y shares the same memory area with z. But if either of them changes,
    then a copy is made in a different area of memory, and the changed variable will
    occupy the new area of memory. However, only the *first* change is affected, as
    the relocating of the moved variable means there are no longer any sharing issues.
    The function tracemem() will report such memory relocations.
  prefs: []
  type: TYPE_NORMAL
- en: '**314**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though R usually adheres to copy-on-change semantics, there are excep-tions.
    For example, R doesn’t exhibit the location-change behavior in the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: z <- runif(10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tracemem(z)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "<0x88c3258>"'
  prefs: []
  type: TYPE_NORMAL
- en: z[3] <- 8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tracemem(z)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "<0x88c3258>"'
  prefs: []
  type: TYPE_NORMAL
- en: The location of z didn’t change; it was at memory address 0x88c3258
  prefs: []
  type: TYPE_NORMAL
- en: both before and after the assignment to z[3] was executed. Thus, although you
    should be vigilant about location change, you also can’t assume it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the times involved.
  prefs: []
  type: TYPE_NORMAL
- en: z <- 1:10000000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z[3] <- 8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.180'
  prefs: []
  type: TYPE_NORMAL
- en: '0.084'
  prefs: []
  type: TYPE_NORMAL
- en: '0.265'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(z[33] <- 88)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: In any event, if copying is done, the vehicle is R’s internal function duplicate().
    (The function is called duplicate1() in recent versions of R.) If you’re familiar
    with the GDB debugging tool and your R build includes debugging information, you
    can explore the circumstances under which a copy is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the guide in Section 15.1.4, start up R with GDB, step through R
    through GDB, and place a breakpoint at duplicate1(). Each time you break at that
    function, submit this GDB command:'
  prefs: []
  type: TYPE_NORMAL
- en: call Rf_PrintValue(s)
  prefs: []
  type: TYPE_NORMAL
- en: This will print the value of s (or whatever variable is of interest).
  prefs: []
  type: TYPE_NORMAL
- en: '***14.3.3 Extended Example: Avoiding Memory Copy***'
  prefs: []
  type: TYPE_NORMAL
- en: This example, though artificial, will demonstrate the memory-copy issues discussed
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a large number of unrelated vectors and, among other things,
    we wish to set the third element of each to 8\. We could store the vectors in
    a matrix, one vector per row. But since they are unrelated, maybe even of different
    lengths, we may consider storing them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**315**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: But things can get very subtle when it comes to R performance issues, so let’s
    try it out.
  prefs: []
  type: TYPE_NORMAL
- en: m <- 5000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n <- 1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z <- list()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(for (i in 1:m) z[[i]][3] <- 8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.288'
  prefs: []
  type: TYPE_NORMAL
- en: '0.024'
  prefs: []
  type: TYPE_NORMAL
- en: '0.321'
  prefs: []
  type: TYPE_NORMAL
- en: z <- matrix(sample(1:10,m*n,replace=T),nrow=m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z[,3] <- 8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.008'
  prefs: []
  type: TYPE_NORMAL
- en: '0.044'
  prefs: []
  type: TYPE_NORMAL
- en: '0.052'
  prefs: []
  type: TYPE_NORMAL
- en: Except for system time (again), the matrix formulation did better.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons is that in the list version, we encounter the memory-copy
    problem in each iteration of the loop. But in the matrix version, we encounter
    it only once. And, of course, the matrix version is vectorized.
  prefs: []
  type: TYPE_NORMAL
- en: But what about using lapply() on the list version?
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: set3 <- function(lv) {
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: lv[3] <- 8
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: return(lv)
  prefs: []
  type: TYPE_NORMAL
- en: + }
  prefs: []
  type: TYPE_NORMAL
- en: z <- list()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(lapply(z,set3))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.100'
  prefs: []
  type: TYPE_NORMAL
- en: '0.012'
  prefs: []
  type: TYPE_NORMAL
- en: '0.112'
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to beat vectorized code.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.4 Using Rprof() to Find Slow Spots in Your Code**'
  prefs: []
  type: TYPE_NORMAL
- en: If you think your R code is running unnecessarily slowly, a handy tool for finding
    the culprit is Rprof(), which gives you a report of (approximately) how much time
    your code is spending in each of the functions it calls. This is important, as
    it may not be wise to optimize *every* section of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization may come at the expense of coding time and code clarity, so it’s
    of value to know where optimization would really help.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.4.1 Monitoring with Rprof()***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate using Rprof() with our three versions of code to find a powers
    matrix from the previous extended example. We’ll call Rprof() to get the monitor
    started, run our code, and then call Rprof() with a NULL
  prefs: []
  type: TYPE_NORMAL
- en: '**316**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: argument to stop the monitoring. Finally, we’ll call summaryRprof() to see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: x <- runif(1000000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers1(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"cbind"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  prefs: []
  type: TYPE_NORMAL
- en: '"powers1"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.86'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"powers1"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.86'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"cbind"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '86.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  prefs: []
  type: TYPE_NORMAL
- en: '0.10'
  prefs: []
  type: TYPE_NORMAL
- en: '11.6'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '2.3'
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.86'
  prefs: []
  type: TYPE_NORMAL
- en: We see immediately that the runtime of our code is dominated by calls to cbind(),
    which as we noted in the extended example is indeed slowing things down.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the call to invisible() in this example is used to suppress output.
    We certainly don’t want to see the 1,000,000-row matrix returned by powers1()
    here!
  prefs: []
  type: TYPE_NORMAL
- en: Profiling powers2() does not show any obvious bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Rprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers2(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"powers2"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.38'
  prefs: []
  type: TYPE_NORMAL
- en: '67.9'
  prefs: []
  type: TYPE_NORMAL
- en: '0.56'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"powers2"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.56'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.38'
  prefs: []
  type: TYPE_NORMAL
- en: '67.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '25.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"*"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.04'
  prefs: []
  type: TYPE_NORMAL
- en: '7.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**317**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.56'
  prefs: []
  type: TYPE_NORMAL
- en: What about powers3(), the promising approach that didn’t pan out?
  prefs: []
  type: TYPE_NORMAL
- en: Rprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: invisible(powers3(x,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rprof(NULL)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: summaryRprof()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $by.self
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  prefs: []
  type: TYPE_NORMAL
- en: '"outer"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.72'
  prefs: []
  type: TYPE_NORMAL
- en: '43.4'
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"outer"'
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.72'
  prefs: []
  type: TYPE_NORMAL
- en: '43.4'
  prefs: []
  type: TYPE_NORMAL
- en: '"powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '1.66'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  prefs: []
  type: TYPE_NORMAL
- en: '0.94'
  prefs: []
  type: TYPE_NORMAL
- en: '56.6'
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.66'
  prefs: []
  type: TYPE_NORMAL
- en: The function logging the largest amount of time was FUN(), which as noted in
    our extended example is simply multiplication. For each pair of elements of x
    here, one of the elements is multiplied by the other; that is, a product of two
    scalars is found. In other words, no vectorization! No wonder it was slow.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.4.2 How Rprof() Works***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore in a bit more detail what Rprof() does. Every 0.02 seconds (the
    default value), R inspects the call stack to determine which function calls are
    in effect at that time. It writes the result of each inspection to a file, by
    default *Rprof.out*. Here is an excerpt of that file from our run of powers3():'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN" "outer" "powers3"'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**318**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: So, Rprof() often found that at inspection time, powers3() had called outer(),
    which in turn had called FUN(), the latter being the currently executing function.
    The function summaryRprof() conveniently summarizes all those lines in the file,
    but you may find that looking at the file itself reveals more insights in some
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, too, that Rprof() is no panacea. If the code you’re profiling produces
    many function calls (including indirect calls, triggered when your code calls
    some function that then calls another within R), the profiling output may be hard
    to decipher. This is arguably the case for the output from powers4():'
  prefs: []
  type: TYPE_NORMAL
- en: $by.self
  prefs: []
  type: TYPE_NORMAL
- en: self.time self.pct total.time total.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"apply"'
  prefs: []
  type: TYPE_NORMAL
- en: '19.46'
  prefs: []
  type: TYPE_NORMAL
- en: '67.5'
  prefs: []
  type: TYPE_NORMAL
- en: '27.56'
  prefs: []
  type: TYPE_NORMAL
- en: '95.6'
  prefs: []
  type: TYPE_NORMAL
- en: '"lapply"'
  prefs: []
  type: TYPE_NORMAL
- en: '4.02'
  prefs: []
  type: TYPE_NORMAL
- en: '13.9'
  prefs: []
  type: TYPE_NORMAL
- en: '5.68'
  prefs: []
  type: TYPE_NORMAL
- en: '19.7'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"as.vector"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  prefs: []
  type: TYPE_NORMAL
- en: '"t.default"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"unlist"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.40'
  prefs: []
  type: TYPE_NORMAL
- en: '1.4'
  prefs: []
  type: TYPE_NORMAL
- en: '6.08'
  prefs: []
  type: TYPE_NORMAL
- en: '21.1'
  prefs: []
  type: TYPE_NORMAL
- en: '"!"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  prefs: []
  type: TYPE_NORMAL
- en: '"is.null"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '"aperm"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '0.5'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '2.6'
  prefs: []
  type: TYPE_NORMAL
- en: '"!="'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  prefs: []
  type: TYPE_NORMAL
- en: '"powers4"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '28.84'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"t"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '28.10'
  prefs: []
  type: TYPE_NORMAL
- en: '97.4'
  prefs: []
  type: TYPE_NORMAL
- en: '"array"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: $by.total
  prefs: []
  type: TYPE_NORMAL
- en: total.time total.pct self.time self.pct
  prefs: []
  type: TYPE_NORMAL
- en: '"powers4"'
  prefs: []
  type: TYPE_NORMAL
- en: '28.84'
  prefs: []
  type: TYPE_NORMAL
- en: '100.0'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"t"'
  prefs: []
  type: TYPE_NORMAL
- en: '28.10'
  prefs: []
  type: TYPE_NORMAL
- en: '97.4'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"apply"'
  prefs: []
  type: TYPE_NORMAL
- en: '27.56'
  prefs: []
  type: TYPE_NORMAL
- en: '95.6'
  prefs: []
  type: TYPE_NORMAL
- en: '19.46'
  prefs: []
  type: TYPE_NORMAL
- en: '67.5'
  prefs: []
  type: TYPE_NORMAL
- en: '"unlist"'
  prefs: []
  type: TYPE_NORMAL
- en: '6.08'
  prefs: []
  type: TYPE_NORMAL
- en: '21.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.40'
  prefs: []
  type: TYPE_NORMAL
- en: '1.4'
  prefs: []
  type: TYPE_NORMAL
- en: '"lapply"'
  prefs: []
  type: TYPE_NORMAL
- en: '5.68'
  prefs: []
  type: TYPE_NORMAL
- en: '19.7'
  prefs: []
  type: TYPE_NORMAL
- en: '4.02'
  prefs: []
  type: TYPE_NORMAL
- en: '13.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"FUN"'
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  prefs: []
  type: TYPE_NORMAL
- en: '2.56'
  prefs: []
  type: TYPE_NORMAL
- en: '8.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"as.vector"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  prefs: []
  type: TYPE_NORMAL
- en: '0.82'
  prefs: []
  type: TYPE_NORMAL
- en: '2.8'
  prefs: []
  type: TYPE_NORMAL
- en: '"matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.74'
  prefs: []
  type: TYPE_NORMAL
- en: '2.6'
  prefs: []
  type: TYPE_NORMAL
- en: '0.14'
  prefs: []
  type: TYPE_NORMAL
- en: '0.5'
  prefs: []
  type: TYPE_NORMAL
- en: '"t.default"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  prefs: []
  type: TYPE_NORMAL
- en: '0.54'
  prefs: []
  type: TYPE_NORMAL
- en: '1.9'
  prefs: []
  type: TYPE_NORMAL
- en: '"!"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  prefs: []
  type: TYPE_NORMAL
- en: '0.34'
  prefs: []
  type: TYPE_NORMAL
- en: '1.2'
  prefs: []
  type: TYPE_NORMAL
- en: '"is.null"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.32'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '"aperm"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: '"array"'
  prefs: []
  type: TYPE_NORMAL
- en: '0.22'
  prefs: []
  type: TYPE_NORMAL
- en: '0.8'
  prefs: []
  type: TYPE_NORMAL
- en: '0.00'
  prefs: []
  type: TYPE_NORMAL
- en: '0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '"!="'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  prefs: []
  type: TYPE_NORMAL
- en: '0.02'
  prefs: []
  type: TYPE_NORMAL
- en: '0.1'
  prefs: []
  type: TYPE_NORMAL
- en: $sampling.time
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 28.84'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**319**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.5 Byte Code Compilation**'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 2.13, R has included a *byte code compiler*, which you
    can use to try to speed up your code. Consider our example from Section 14.2.1\.
  prefs: []
  type: TYPE_NORMAL
- en: As a trivial example, we showed that
  prefs: []
  type: TYPE_NORMAL
- en: z <- x + y
  prefs: []
  type: TYPE_NORMAL
- en: was much faster than
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, that was obvious, but just to get an idea of how byte code compilation
    works, let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: library(compiler)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: f <- function() for (i in 1:length(x)) z[i] <<- x[i] + y[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cf <- cmpfun(f)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(cf())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.845'
  prefs: []
  type: TYPE_NORMAL
- en: '0.003'
  prefs: []
  type: TYPE_NORMAL
- en: '0.848'
  prefs: []
  type: TYPE_NORMAL
- en: We created a new function, cf(), from the original f(). The new code’s run time
    was 0.848 seconds, much faster than the 8.175 seconds the non-compiled version
    took. Granted, it still wasn’t as fast as the straightforward vectorized code,
    but it is clear that byte code compilation has potential. You should try it whenever
    you need faster code.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.6 Oh No, the Data Doesn’t Fit into Memory!**'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, all objects in an R session are stored in memory. R
  prefs: []
  type: TYPE_NORMAL
- en: places a limit of 231 *−* 1 bytes on the size of any object, regardless of word
    size (32-bit versus 64-bit) and the amount of RAM in your machine. However, you
    really should not consider this an obstacle. With a little extra care, applications
    that have large memory requirements can indeed be handled well in R. Some common
    approaches are chunking and using R packages for memory management.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.6.1 Chunking***'
  prefs: []
  type: TYPE_NORMAL
- en: One option involving no extra R packages at all is to read in your data from
    a disk file one chunk at a time. For example, suppose that our goal is to find
    means or proportions of some variables. We can use the skip argument in read.table().
  prefs: []
  type: TYPE_NORMAL
- en: Say our data set has 1,000,000 records and we divide them into 10
  prefs: []
  type: TYPE_NORMAL
- en: chunks (or more—whatever is needed to cut the data down to a size so it fits
    in memory). Then we set skip = 0 on our first read, set skip = 100000
  prefs: []
  type: TYPE_NORMAL
- en: the second time, and so on. Each time we read in a chunk, we calculate **320**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: the counts or totals for that chunk and record them. After reading all the chunks,
    we add up all the counts or totals in order to calculate our grand means or proportions.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, suppose we are performing a statistical operation, say calculating
    principle components, in which we have a huge number of rows—that is, a huge number
    of observations—but the number of variables is manageable. Again, chunking could
    be the solution. We apply the statistical operation to each chunk and then average
    the results over all the chunks. My mathematical research shows that the resulting
    estimators are statistically efficient in a wide class of statistical methods.
  prefs: []
  type: TYPE_NORMAL
- en: '***14.6.2 Using R Packages for Memory Management***'
  prefs: []
  type: TYPE_NORMAL
- en: Again looking at a bit more sophistication, there are alternatives for accommodating
    large memory requirements in the form of some specialized R
  prefs: []
  type: TYPE_NORMAL
- en: packages.
  prefs: []
  type: TYPE_NORMAL
- en: One such package is RMySQL, an R interface to SQL databases. Using it requires
    some database expertise, but this package provides a much more efficient and convenient
    way to handle large data sets. The idea is to have SQL do its variable/case selection
    operations for you back at the database end and then read the resulting selected
    data as it is produced by SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Since the latter will typically be much smaller than the overall data set, you
    will likely be able to circumvent R’s memory restriction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful package is biglm, which does regression and generalized linear-model
    analysis on very large data sets. It also uses chunking but in a different manner:
    Each chunk is used to update the running totals of sums needed for the regression
    analysis and then discarded.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some packages do their own storage management indepen-
  prefs: []
  type: TYPE_NORMAL
- en: dently of R and thus can deal with very large data sets. The two most commonly
    used today are ff and bigmemory. The former sidesteps memory constraints by storing
    data on disk instead of memory, essentially transparently to the programmer. The
    highly versatile bigmemory package does the same, but it can store data not only
    on disk but also in the machine’s main memory, which is ideal for multicore machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Enhancement: Speed and Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '**321**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 42](index-349_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**15**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTERFACING R TO OTHER**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LANGUAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: R is a great language, but it can’t do every-
  prefs: []
  type: TYPE_NORMAL
- en: thing well. Thus, it is sometimes desirable
  prefs: []
  type: TYPE_NORMAL
- en: to call code written in other languages from
  prefs: []
  type: TYPE_NORMAL
- en: R. Conversely, when working in other great lan-
  prefs: []
  type: TYPE_NORMAL
- en: guages, you may encounter tasks that could be better
  prefs: []
  type: TYPE_NORMAL
- en: done in R.
  prefs: []
  type: TYPE_NORMAL
- en: R interfaces have been developed for a number of other languages,
  prefs: []
  type: TYPE_NORMAL
- en: 'from ubiquitous languages like C to esoteric ones like the Yacas computer algebra
    system. This chapter will cover two interfaces: one for calling C/C++ from R and
    the other for calling R from Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '**15.1 Writing C/C++ Functions to Be Called from R**'
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to write your own C/C++ functions to be called from R. Typically,
    the goal is performance enhancement, since C/C++ code may run much faster than
    R, even if you use vectorization and other R optimization techniques to speed
    things up.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible goal in dropping down to the C/C++ level is specialized I/O.
    For example, R uses the TCP protocol in layer 3 of the standard Internet communication
    system, but UDP can be faster in some settings.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: To work in UDP, you need C/C++, which requires an interface to R for those languages.
  prefs: []
  type: TYPE_NORMAL
- en: R actually offers two C/C++ interfaces via the functions .C() and
  prefs: []
  type: TYPE_NORMAL
- en: .Call(). The latter is more versatile but requires some knowledge of R’s internal
    structures, so we’ll stick with .C() here.
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.1 Some R-to-C/C++ Preliminaries***'
  prefs: []
  type: TYPE_NORMAL
- en: In C, two-dimensional arrays are stored in row-major order, in contrast to R’s
    column-major order. For instance, if you have a 3-by-4 array, the element in the
    second row and second column is element number 5 of the array when viewed linearly,
    since there are three elements in the first column and this is the second element
    in the second column. Also keep in mind that C subscripts begin at 0, rather than
    at 1, as with R.
  prefs: []
  type: TYPE_NORMAL
- en: All the arguments passed from R to C are received by C as pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the C function itself must return void. Values that you would ordinarily
    return must be communicated through the function’s arguments, such as result in
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.2 Example: Extracting Subdiagonals from a Square Matrix***'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will write C code to extract subdiagonals from a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '(Thanks to my former graduate assistant, Min-Yu Huang, who wrote an earlier
    version of this function.) Here’s the code for the file *sd.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <R.h> // required'
  prefs: []
  type: TYPE_NORMAL
- en: '// arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: 'm: a square matrix'
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: 'n: number of rows/columns of m'
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: 'k: the subdiagonal index--0 for main diagonal, 1 for first'
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: subdiagonal, 2 for the second, etc.
  prefs: []
  type: TYPE_NORMAL
- en: //
  prefs: []
  type: TYPE_NORMAL
- en: 'result: space for the requested subdiagonal, returned here'
  prefs: []
  type: TYPE_NORMAL
- en: void subdiag(double *m, int *n, int *k, double *result)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int nval = *n, kval = *k;
  prefs: []
  type: TYPE_NORMAL
- en: int stride = nval + 1;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0, j = kval; i < nval-kval; ++i, j+= stride)
  prefs: []
  type: TYPE_NORMAL
- en: result[i] = m[j];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The variable stride alludes to a concept from the parallel-processing community.
    Say we have a matrix in 1,000 columns and our C code is looping through all the
    elements in a given column, from top to bottom. Again, since C uses row-major
    order, consecutive elements in the column are 1,000
  prefs: []
  type: TYPE_NORMAL
- en: elements apart from each other if the matrix is viewed as one long vector.
  prefs: []
  type: TYPE_NORMAL
- en: '**324**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we would say that we are traversing that long vector with a stride of
    1,000—that is, accessing every thousandth element.
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.3 Compiling and Running Code***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You compile your code using R. For example, in a Linux terminal window, we
    could compile our file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '% R CMD SHLIB sd.c'
  prefs: []
  type: TYPE_NORMAL
- en: gcc -std=gnu99 -I/usr/share/R/include
  prefs: []
  type: TYPE_NORMAL
- en: -fpic -g -O2 -c sd.c -o sd.o
  prefs: []
  type: TYPE_NORMAL
- en: gcc -std=gnu99 -shared -o sd.so sd.o
  prefs: []
  type: TYPE_NORMAL
- en: -L/usr/lib/R/lib -lR
  prefs: []
  type: TYPE_NORMAL
- en: This would produce the dynamic shared library file *sd.so*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that R has reported how it invoked GCC in the output of the example. You
    can also run these commands by hand if you have special requirements, such as
    special libraries to be linked in. Also note that the locations of the *include*
    and *lib* directories may be system-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*GCC is easily downloadable for Linux systems. For Windows, it is included
    in* *Cygwin, an open source package available from* http://www.cygwin.com/ *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then load our library into R and call our C function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("sd.so")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k <- 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[1]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 6 11 16 21 2 7 12 17 22 3 8 13 18 23 4 9 14 19 24 5 10 15 20 25'
  prefs: []
  type: TYPE_NORMAL
- en: '[[2]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[[3]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: $result
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 11 17 23'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience here, we’ve given the name result to both the formal argument
    (in the C code) and the actual argument (in the R code). Note that we needed to
    allocate space for result in our R code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the example, the return value takes on the form of a list
    consisting of the arguments in the R call. In this case, the call had four arguments
    (in addition to the function name), so the returned list has four components.
    Typically, some of the arguments will be changed during execution of the C code,
    as was the case here with result.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  prefs: []
  type: TYPE_NORMAL
- en: '**325**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.4 Debugging R/C Code***'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13 discussed a number of tools and methods for debugging R code.
  prefs: []
  type: TYPE_NORMAL
- en: However, the R/C interface presents an extra challenge. The problem in using
    a debugging tool such as GDB here is that you must first apply it to R
  prefs: []
  type: TYPE_NORMAL
- en: itself.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a walk-through of the R/C debugging steps using GDB
  prefs: []
  type: TYPE_NORMAL
- en: on our previous *sd.c* code as the example.
  prefs: []
  type: TYPE_NORMAL
- en: $ R -d gdb
  prefs: []
  type: TYPE_NORMAL
- en: GNU gdb 6.8-debian
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) run
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting program: /usr/lib/R/bin/exec/R'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("sd.so")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: hit ctrl-c here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Program received signal SIGINT, Interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 0xb7ffa430 in __kernel_vsyscall ()
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) b subdiag
  prefs: []
  type: TYPE_NORMAL
- en: 'Breakpoint 1 at 0xb77683f3: file sd.c, line 3\.'
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) continue
  prefs: []
  type: TYPE_NORMAL
- en: Continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoint 1, subdiag (m=0x92b9480, n=0x9482328, k=0x9482348, result=0x9817148)
    at sd.c:3
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: int nval = *n, kval = *k;
  prefs: []
  type: TYPE_NORMAL
- en: (gdb)
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened in this debugging session?
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: We launched the debugger, GDB, with R loaded into it, from a com-
  prefs: []
  type: TYPE_NORMAL
- en: 'mand line in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: R -d gdb
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We told GDB to run R:'
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) run
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We loaded our compiled C code into R as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("sd.so")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: We hit the CTRL-C interrupt key pair to pause R and put us back at the GDB prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a breakpoint at the entry to subdiag():'
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) b subdiag
  prefs: []
  type: TYPE_NORMAL
- en: '**326**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We told GDB to resume executing R (we needed to hit the ENTER key a second
    time in order to get the R prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: (gdb) continue
  prefs: []
  type: TYPE_NORMAL
- en: 'We then executed our C code:'
  prefs: []
  type: TYPE_NORMAL
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k <- 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k),
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: + result=double(dim(m)[1]-k))
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoint 1, subdiag (m=0x942f270, n=0x96c3328, k=0x96c3348, result=0x9a58148)
    at subdiag.c:46
  prefs: []
  type: TYPE_NORMAL
- en: 46 if (*n < 1) error("n < 1\n");
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can use GDB to debug as usual. If you’re not familiar with
    GDB, you may want to try one of the many quick tutorials on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1 lists some of the most useful commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common GDB Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: l
  prefs: []
  type: TYPE_NORMAL
- en: List code lines
  prefs: []
  type: TYPE_NORMAL
- en: b
  prefs: []
  type: TYPE_NORMAL
- en: Set breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: r
  prefs: []
  type: TYPE_NORMAL
- en: Run/rerun
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: Step to next statement
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: Step into function call
  prefs: []
  type: TYPE_NORMAL
- en: p
  prefs: []
  type: TYPE_NORMAL
- en: Print variable or expression
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: Continue
  prefs: []
  type: TYPE_NORMAL
- en: h
  prefs: []
  type: TYPE_NORMAL
- en: Help
  prefs: []
  type: TYPE_NORMAL
- en: q
  prefs: []
  type: TYPE_NORMAL
- en: Quit
  prefs: []
  type: TYPE_NORMAL
- en: '***15.1.5 Extended Example: Prediction of Discrete-Valued Time Series***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our example in Section 2.5.2 where we observed 0- and 1-valued data,
    one per time period, and attempted to predict the value in any period from the
    previous k values, using majority rule. We developed two competing functions for
    the job, preda() and predb(), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: prediction in discrete time series; 0s and 1s; use k consecutive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: observations to predict the next, using majority rule; calculate the
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: error rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: preda <- function(x,k) {
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: k2 <- k/2
  prefs: []
  type: TYPE_NORMAL
- en: the vector pred will contain our predicted values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pred <- vector(length=n-k)
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  prefs: []
  type: TYPE_NORMAL
- en: '**327**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n-k)) {
  prefs: []
  type: TYPE_NORMAL
- en: if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(abs(pred-x[(k+1):n])))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: predb <- function(x,k) {
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: k2 <- k/2
  prefs: []
  type: TYPE_NORMAL
- en: pred <- vector(length=n-k)
  prefs: []
  type: TYPE_NORMAL
- en: sm <- sum(x[1:k])
  prefs: []
  type: TYPE_NORMAL
- en: if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
  prefs: []
  type: TYPE_NORMAL
- en: if (n-k >= 2) {
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:(n-k)) {
  prefs: []
  type: TYPE_NORMAL
- en: sm <- sm + x[i+k-1] - x[i-1]
  prefs: []
  type: TYPE_NORMAL
- en: if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(abs(pred-x[(k+1):n])))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Since the latter avoids duplicate computation, we speculated it would be faster.
    Now is the time to check that.
  prefs: []
  type: TYPE_NORMAL
- en: y <- sample(0:1,100000,replace=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(preda(y,1000))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '3.816'
  prefs: []
  type: TYPE_NORMAL
- en: '0.016'
  prefs: []
  type: TYPE_NORMAL
- en: '3.873'
  prefs: []
  type: TYPE_NORMAL
- en: system.time(predb(y,1000))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '1.392'
  prefs: []
  type: TYPE_NORMAL
- en: '0.008'
  prefs: []
  type: TYPE_NORMAL
- en: '1.427'
  prefs: []
  type: TYPE_NORMAL
- en: Hey, not bad! That’s quite an improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should always ask whether R already has a fine-tuned function
    that will suit your needs. Since we’re basically computing a moving average, we
    might try the filter() function, with a constant coefficient vector, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: predc <- function(x,k) {
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: f <- filter(x,rep(1,k),sides=1)[k:(n-1)]
  prefs: []
  type: TYPE_NORMAL
- en: k2 <- k/2
  prefs: []
  type: TYPE_NORMAL
- en: pred <- as.integer(f >= k2)
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(abs(pred-x[(k+1):n])))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**328**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: That’s even more compact than our first version. But it’s a lot harder to read,
    and for reasons we will explore soon, it may not be so fast. Let’s check.
  prefs: []
  type: TYPE_NORMAL
- en: system.time(predc(y,1000))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '3.872'
  prefs: []
  type: TYPE_NORMAL
- en: '0.016'
  prefs: []
  type: TYPE_NORMAL
- en: '3.945'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, our second version remains the champion so far. This actually should
    be expected, as a look at the source code shows. Typing the following shows the
    source for that function:'
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This reveals (not shown here) that filter1() is called. The latter is written
    in C, which should give us some speedup, but it still suffers from the duplicate
    computation problem—hence the slowness.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s write our own C code.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <R.h>'
  prefs: []
  type: TYPE_NORMAL
- en: void predd(int *x, int *n, int *k, double *errrate)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int nval = *n, kval = *k, nk = nval - kval, i;
  prefs: []
  type: TYPE_NORMAL
- en: int sm = 0; // moving sum
  prefs: []
  type: TYPE_NORMAL
- en: int errs = 0; // error count
  prefs: []
  type: TYPE_NORMAL
- en: int pred; // predicted value
  prefs: []
  type: TYPE_NORMAL
- en: double k2 = kval/2.0;
  prefs: []
  type: TYPE_NORMAL
- en: // initialize by computing the initial window
  prefs: []
  type: TYPE_NORMAL
- en: for (i = 0; i < kval; i++) sm += x[i];
  prefs: []
  type: TYPE_NORMAL
- en: if (sm >= k2) pred = 1; else pred = 0;
  prefs: []
  type: TYPE_NORMAL
- en: errs = abs(pred-x[kval]);
  prefs: []
  type: TYPE_NORMAL
- en: for (i = 1; i < nk; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: sm = sm + x[i+kval-1] - x[i-1];
  prefs: []
  type: TYPE_NORMAL
- en: if (sm >= k2) pred = 1; else pred = 0;
  prefs: []
  type: TYPE_NORMAL
- en: errs += abs(pred-x[i+kval]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*errrate = (double) errs / nk;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: This is basically predb() from before, “hand translated” into C. Let’s see if
    it will outdo predb().
  prefs: []
  type: TYPE_NORMAL
- en: system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000),
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: errrate=double(1)))
  prefs: []
  type: TYPE_NORMAL
- en: user system elapsed
  prefs: []
  type: TYPE_NORMAL
- en: '0.004'
  prefs: []
  type: TYPE_NORMAL
- en: '0.000'
  prefs: []
  type: TYPE_NORMAL
- en: '0.003'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  prefs: []
  type: TYPE_NORMAL
- en: '**329**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The speedup is breathtaking.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that writing certain functions in C can be worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially true for functions that involve iteration, as R’s own iteration
    constructs, such as for(), are slow.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.2 Using R from Python**'
  prefs: []
  type: TYPE_NORMAL
- en: Python is an elegant and powerful language, but it lacks built-in facilities
    for statistical and data manipulation, two areas in which R excels. This section
    demonstrates how to call R from Python, using RPy, one of the most popular interfaces
    between the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: '***15.2.1 Installing RPy***'
  prefs: []
  type: TYPE_NORMAL
- en: RPy is a Python module that allows access to R from Python. For extra efficiency,
    it can be used in conjunction with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: You can build the module from the source, available from *http://rpy*
  prefs: []
  type: TYPE_NORMAL
- en: '*.sourceforge.net*, or download a prebuilt version. If you are running Ubuntu,
    simply type this:'
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get install python-rpy
  prefs: []
  type: TYPE_NORMAL
- en: 'To load RPy from Python (whether in Python interactive mode or from code),
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: from rpy import *
  prefs: []
  type: TYPE_NORMAL
- en: This will load a variable r, which is a Python class instance.
  prefs: []
  type: TYPE_NORMAL
- en: '***15.2.2 RPy Syntax***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running R from Python is in principle quite simple. Here is an example of a
    command you might run from the *>>>* Python prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.hist(r.rnorm(100))'
  prefs: []
  type: TYPE_NORMAL
- en: This will call the R function rnorm() to produce 100 standard normal variates
    and then input those values into R’s histogram function, hist().
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, R names are prefixed by r., reflecting the fact that Python
    wrappers for R functions are members of the class instance r.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code will, if not refined, produce ugly output, with your (possibly
    voluminous!) data appearing as the graph title and the *x*-axis label.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can avoid this by supplying a title and label, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.hist(r.rnorm(100),main='''',xlab='''')'
  prefs: []
  type: TYPE_NORMAL
- en: RPy syntax is sometimes less simple than these examples would lead you to believe.
    The problem is that R and Python syntax may clash. For instance, **330**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: consider a call to the R linear model function lm(). In our example, we will
    predict b from a.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = [5,12,13]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = [10,28,30]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout = r.lm(''v2 ~ v1'',data=r.data_frame(v1=a,v2=b))'
  prefs: []
  type: TYPE_NORMAL
- en: This is somewhat more complex than it would have been if done directly in R.
    What are the issues here?
  prefs: []
  type: TYPE_NORMAL
- en: First, since Python syntax does not include the tilde character, we needed to
    specify the model formula via a string. Since this is done in R anyway, this is
    not a major departure.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we needed a data frame to contain our data. We created one
  prefs: []
  type: TYPE_NORMAL
- en: using R’s data.frame() function. In order to form a period in an R function
    name, we need to use an underscore on the Python end. Thus we called r.data_frame().
    Note that in this call, we named the columns of our data frame v1 and v2 and then
    used these in our model formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output object is a Python dictionary (analog of R’s list type), as you
    can see here (in part):'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout'
  prefs: []
  type: TYPE_NORMAL
- en: '{''qr'': {''pivot'': [1, 2], ''qr'': array([[ -1.73205081, -17.32050808],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0.57735027, -6.164414 ],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0.57735027,'
  prefs: []
  type: TYPE_NORMAL
- en: '0.78355007]]), ''qraux'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should recognize the various attributes of lm() objects here. For example,
    the coefficients of the fitted regression line, which would be contained in lmout$coefficients
    if this were done in R, are here in Python as lmout[''coefficients'']. So, you
    can access those coefficients accordingly, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout[''coefficients'']'
  prefs: []
  type: TYPE_NORMAL
- en: '{''v1'': 2.5263157894736841, ''(Intercept)'': -2.5964912280701729}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lmout[''coefficients''][''v1'']'
  prefs: []
  type: TYPE_NORMAL
- en: '2.5263157894736841'
  prefs: []
  type: TYPE_NORMAL
- en: You can also submit R commands to work on variables in R’s namespace, using
    the function r(). This is convenient if there are many syntax clashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we could run the wireframe() example in Section 12.4 in RPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.library(''lattice'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.assign(''a'',a)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r.assign(''b'',b)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''g <- expand.grid(a,b)'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''g$Var3 <- g$Var1^2 + g$Var1 * g$Var2'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''wireframe(Var3 ~ Var1+Var2,g)'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r(''plot(wireframe(Var3 ~ Var1+Var2,g))'')'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing R to Other Languages
  prefs: []
  type: TYPE_NORMAL
- en: '**331**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used r.assign() to copy a variable from Python’s namespace to R’s.
    We then ran expand.grid() (with a period in the name instead of an underscore,
    since we are running in R’s namespace), assigning the result to g. Again, the
    latter is in R’s namespace. Note that the call to wireframe() did not automatically
    display the plot, so we needed to call plot().
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for RPy is at *http://rpy.sourceforge.net/rpy/doc/*
  prefs: []
  type: TYPE_NORMAL
- en: '*rpy.pdf*. Also, you can find a useful presentation, “RPy—R from Python,” at
    *http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**332**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](index-359_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**16**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PARALLEL R**'
  prefs: []
  type: TYPE_NORMAL
- en: Since many R users have very large compu-
  prefs: []
  type: TYPE_NORMAL
- en: tational needs, various tools for some kind
  prefs: []
  type: TYPE_NORMAL
- en: of parallel operation of R have been devised.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to parallel R.
  prefs: []
  type: TYPE_NORMAL
- en: Many a novice in parallel processing has, with great anticipation, written parallel
    code for some application only to find that the parallel version actually ran
    more slowly than the serial one. For reasons to be discussed in this chapter,
    this problem is especially acute with R.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, understanding the nature of parallel-processing hardware and software
    is crucial to success in the parallel world. These issues will be discussed here
    in the context of common platforms for parallel R.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a few code examples and then move to general performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.1 The Mutual Outlinks Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a network graph of some kind, such as web links or links in a social
    network. Let A be the *adjacency matrix* of the graph, meaning that, say, A[3,8]
  prefs: []
  type: TYPE_NORMAL
- en: is 1 or 0, depending on whether there is a link from node 3 to node 8\.
  prefs: []
  type: TYPE_NORMAL
- en: For any two vertices, say any two websites, we might be interested in mutual
    outlinks—that is, outbound links that are common to two sites. Suppose that we
    want to find the mean number of mutual outlinks, averaged
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'over all pairs of websites in our data set. This mean can be found using the
    following outline, for an *n*-by- *n* matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: sum = 0
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: for i = 0...n-1
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: for j = i+1...n-1
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: mean = sum / (n*(n-1)/2)
  prefs: []
  type: TYPE_NORMAL
- en: Given that our graph could contain thousands—even millions—of web-
  prefs: []
  type: TYPE_NORMAL
- en: sites, our task could entail quite large amounts of computation. A common approach
    to dealing with this problem is to divide the computation into smaller chunks
    and then process each of the chunks simultaneously, say on separate computers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that we have two computers at our disposal. We might have one computer
    handle all the odd values of i in the for i loop in line 2 and have the second
    computer handle the even values. Or, since dual-core computers are fairly standard
    these days, we could take this same approach on a single computer. This may sound
    simple, but a number of major issues can arise, as you’ll learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.2 Introducing the snow Package**'
  prefs: []
  type: TYPE_NORMAL
- en: Luke Tierney’s snow (Simple Network of Workstations) package, available from
    the CRAN R code repository, is arguably the simplest, easiest-to-use form of parallel
    R and one of the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The CRAN Task View page on parallel R,* http://cran.r-project.org/web/views/'
  prefs: []
  type: TYPE_NORMAL
- en: HighPerformanceComputing.html *, has a fairly up-to-date list of available parallel
    R packages.*
  prefs: []
  type: TYPE_NORMAL
- en: To see how snow works, here’s code for the mutual outlinks problem
  prefs: []
  type: TYPE_NORMAL
- en: 'described in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: snow version of mutual links problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: mtl <- function(ichunk,m) {
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: n <- ncol(m)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: matches <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in ichunk) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: if (i < n) {
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: rowi <- m[i,]
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: matches <- matches +
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: sum(m[(i+1):n,] %*% rowi)
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: matches
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**334**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: mutlinks <- function(cls,m) {
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(m)
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: nc <- length(cls)
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: determine which worker gets which chunk of i
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=-1)
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: ichunks <- split(1:n,1:nc)
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=0)
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: counts <- clusterApply(cls,ichunks,mtl,m)
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: do.call(sum,counts) / (n*(n-1)/2)
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have this code in the file *SnowMutLinks.R*. Let’s first discuss
    how to run it.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.2.1 Running snow Code***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the above snow code involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Load the code.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Load the snow library.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Form a snow cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the adjacency matrix of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Run your code on that matrix on the cluster you formed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we are running on a dual-core machine, we issue the following commands
    to R:'
  prefs: []
  type: TYPE_NORMAL
- en: source("SnowMutLinks.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: library(snow)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cl <- makeCluster(type="SOCK",c("localhost","localhost"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testm <- matrix(sample(0:1,16,replace=T),nrow=4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mutlinks(cl,testm)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.6666667'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are instructing snow to start two new R processes on our
  prefs: []
  type: TYPE_NORMAL
- en: machine (localhost is a standard network name for the local machine), which
    I will refer to here as *workers*. I’ll refer to the original R process—the one
    in which we type the preceding commands—as the *manager*. So, at this point, three
    instances of R will be running on the machine (visible by running the ps command
    if you are in a Linux environment, for example).
  prefs: []
  type: TYPE_NORMAL
- en: The workers form a *cluster* in snow parlance, which we have named cl.
  prefs: []
  type: TYPE_NORMAL
- en: 'The snow package uses what is known in the parallel-processing world as a *scatter/gather*
    paradigm, which works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The manager partitions the data into chunks and parcels them out to the workers
    (scatter phase).
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**335**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The workers process their chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The manager collects the results from the workers (gather phase) and combines
    them as appropriate to the application.
  prefs: []
  type: TYPE_NORMAL
- en: We have specified that communication between the manager and work-
  prefs: []
  type: TYPE_NORMAL
- en: ers will be via network sockets (covered in Chapter 10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test matrix to check the code:'
  prefs: []
  type: TYPE_NORMAL
- en: testm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3] [,4]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '[4,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: Row 1 has zero outlinks in common with row 2, two in common with
  prefs: []
  type: TYPE_NORMAL
- en: row 3, and one in common with row 4\. Row 2 has zero outlinks in common with
    the rest, but row 3 has one in common with row 4\. That is a total of four mutual
    outlinks out of 4 *×* 3 */* 2 = 6 pairs—hence, the mean value of 4/6 = 0.6666667,
    as you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: You can make clusters of any size, as long as you have the machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my department, for instance, I have machines whose network names are pc28,
    pc29, and pc30\. Each machine is dual core, so I could create a six-worker cluster
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: cl6 <- makeCluster(type="SOCK",c("pc28","pc28","pc29","pc29","pc30","pc30"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***16.2.2 Analyzing the snow Code***'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how the mutlinks() function works. First, we sense how many rows
    the matrix m has, in line 17, and the number of workers in our cluster, in line
    18\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to determine which worker will handle which values of i in the
    for i loop in our outline code shown earlier in Section 16.1\. R’s split() function
    is well suited for this. For instance, in the case of a 4-row matrix and a 2-worker
    cluster, that call produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: split(1:4,1:2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $`1`
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 3'
  prefs: []
  type: TYPE_NORMAL
- en: $`2`
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2 4'
  prefs: []
  type: TYPE_NORMAL
- en: An R list is returned whose first element is the vector (1,3) and the second
    is (2,4). This will set up having one R process work on the odd values of i and
    the other work on the even values, as we discussed earlier. We ward off the **336**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: warnings that split() would give us (“data length is not a multiple of split
    variable”) by calling options().
  prefs: []
  type: TYPE_NORMAL
- en: The real work is done in line 23, where we call the snow function
  prefs: []
  type: TYPE_NORMAL
- en: 'clusterApply(). This function initiates a call to the same specified function
    (mtl() here), with some arguments specific to each worker and some optional arguments
    common to all. So, here’s what the call in line 23 does: 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: Worker 1 will be directed to call the function mtl() with the arguments ichunks[[1]]
    and m.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Worker 2 will call mtl() with the arguments ichunks[[2]] and m, and so on for
    all workers.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Each worker will perform its assigned task and then return the result to the
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The manager will collect all such results into an R list, which we have assigned
    here to counts.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we merely need to sum all the elements of counts. Well, I shouldn’t
    say “merely,” because there is a little wrinkle to iron out in line 24\.
  prefs: []
  type: TYPE_NORMAL
- en: 'R’s sum() function is capable of acting on several vector arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: sum(1:2,c(4,10))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 17'
  prefs: []
  type: TYPE_NORMAL
- en: But here, counts is an R list, not a (numeric) vector. So we rely on do.call()
    to extract the vectors from counts, and then we call sum() on them.
  prefs: []
  type: TYPE_NORMAL
- en: Note lines 9 and 10\. As you know, in R, we try to vectorize our computation
    wherever possible for better performance. By casting things in matrix-times-vector
    terms, we replace the for j and for k loops in the outline in Section 16.1 by
    a single vector-based expression.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.2.3 How Much Speedup Can Be Attained?***'
  prefs: []
  type: TYPE_NORMAL
- en: I tried this code on a 1000-by-1000 matrix m1000\. I first ran it on a 4-worker
    cluster and then on a 12-worker cluster. In principle, I should have had speedups
    of 4 and 12, respectively. But the actual elapsed times were 6.2 seconds and 5.0
    seconds. Compare these figures to the 16.9 seconds runtime in nonparallel form.
    (The latter consisted of the call mtl(1:1000,m1000).) So, I attained a speedup
    of about 2.7 instead of a theoretical 4.0 for a 4-worker cluster and 3.4 rather
    than 12.0 on the 12-node system. (Note that some timing variation occurs from
    run to run.) What went wrong?
  prefs: []
  type: TYPE_NORMAL
- en: In almost any parallel-processing application, you encounter *overhead*, or
  prefs: []
  type: TYPE_NORMAL
- en: “wasted” time spent on noncomputational activity. In our example, there is overhead
    in the form of the time needed to send our matrix from the manager to the workers.
    We also encountered a bit of overhead in sending the function mtl() itself to
    the workers. And when the workers finish their tasks, returning their results
    to the manager causes some overhead, too. We’ll Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**337**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: discuss this in detail when we talk about general performance considerations
    in in Section 16.4.1\.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.2.4 Extended Example: K-Means Clustering***'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the capabilities of snow, we’ll look at another example,
    this one involving k-means clustering (KMC).
  prefs: []
  type: TYPE_NORMAL
- en: KMC is a technique for exporatory data analysis. In looking at scatter plots
    of your data, you may have the perception that the observations tend to cluster
    into groups, and KMC is a method for finding such groups. The output consists
    of the centroids of the groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an outline of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: for iter = 1,2,...,niters
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: set vector and count totals to 0
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: for i = 1,...,nrow(m)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: set j = index of the closest group center to m[i,]
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: add m[i,] to the vector total for group j, v[j]
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: add 1 to the count total for group j, c[j]
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: for j = 1,...,ngrps
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: set new center of group j = v[j] / c[j]
  prefs: []
  type: TYPE_NORMAL
- en: Here, we specify niters iterations, with initcenters as our initial guesses
    for the centers of the groups. Our data is in the matrix m, and there are ngrps
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the snow code to compute KMC in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: snow version of k-means clustering problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: library(snow)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: returns distances from x to each vector in y;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: here x is a single vector and y is a bunch of them;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: define distance between 2 points to be the sum of the absolute values 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of their componentwise differences; e.g., distance between (5,4.2) and 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (3,5.6) is 2 + 1.4 = 3.4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: dst <- function(x,y) {
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: 'tmpmat <- matrix(abs(x-y),byrow=T,ncol=length(x)) # note recycling 12'
  prefs: []
  type: TYPE_NORMAL
- en: rowSums(tmpmat)
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: will check this worker's mchunk matrix against currctrs, the current 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: centers of the groups, returning a matrix; row j of the matrix will 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: consist of the vector sum of the points in mchunk closest to jth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: current center, and the count of such points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: findnewgrps <- function(currctrs) {
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: ngrps <- nrow(currctrs)
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: 'spacedim <- ncol(currctrs) # what dimension space are we in?'
  prefs: []
  type: TYPE_NORMAL
- en: '**338**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: set up the return matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts <- matrix(rep(0,ngrps*(spacedim+1)),nrow=ngrps)
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nrow(mchunk)) {
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: dsts <- dst(mchunk[i,],t(currctrs))
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: j <- which.min(dsts)
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts[j,] <- sumcounts[j,] + c(mchunk[i,],1)
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: parkm <- function(cls,m,niters,initcenters) {
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(m)
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: 'spacedim <- ncol(m) # what dimension space are we in?'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: determine which worker gets which chunk of rows of m
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=-1)
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: ichunks <- split(1:n,1:length(cls))
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: options(warn=0)
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: form row chunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: mchunks <- lapply(ichunks,function(ichunk) m[ichunk,])
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: mcf <- function(mchunk) mchunk <<- mchunk
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: send row chunks to workers; each chunk will be a global variable at 43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: the worker, named mchunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: invisible(clusterApply(cls,mchunks,mcf))
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: send dst() to workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: clusterExport(cls,"dst")
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: start iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: centers <- initcenters
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:niters) {
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: sumcounts <- clusterCall(cls,findnewgrps,centers)
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: tmp <- Reduce("+",sumcounts)
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: centers <- tmp[,1:spacedim] / tmp[,spacedim+1]
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: if a group is empty, let's set its center to 0s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: centers[is.nan(centers)] <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: centers
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The code here is largely similar to our earlier mutual outlinks example.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a couple of new snow calls and a different kind of usage
    of an old call.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with lines 39 through 44\. Since our matrix m does not change from
    one iteration to the next, we definitely do not want to resend it to the workers
    repeatedly, exacerbating the overhead problem. Thus, first we need to send each
    worker its assigned chunk of m, just once. This is done in line 44
  prefs: []
  type: TYPE_NORMAL
- en: via snow’s clusterApply() function, which we used earlier but need to get creative
    with here. In line 41, we define the function mcf(), which will, running Parallel
    R
  prefs: []
  type: TYPE_NORMAL
- en: '**339**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: on a worker, accept the worker’s chunk from the manager and then keep it as
    a global variable mchunk on the worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 46 makes use of a new snow function, clusterExport(), whose job it is
    to make copies of the manager’s global variables at the workers. The variable
    in question here is actually a function, dst(). Here is why we need to send it
    separately: The call in line 50 will send the function findnewgrps() to the workers,
    but although that function calls dst(), snow will not know to send the latter
    as well. Therefore we send it ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Line 50 itself uses another new snow call, clusterCall(). This instructs each
    worker to call findnewgrps(), with centers as argument.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each worker has a different matrix chunk, so this call will work
    on different data for each worker. This once again brings up the controversy regarding
    the use of global variables, discussed in Section 7.8.4\.
  prefs: []
  type: TYPE_NORMAL
- en: Some software developers may be troubled by the use of a hidden argument in
    findnewgrps(). On the other hand, as mentioned earlier, using mchunk as an argument
    would mean sending it to the workers repeatedly, compromising performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, take a look at line 51\. The snow function clusterApply() always returns
    an R list. In this case, the return value is in sumcounts, each element of which
    is a matrix. We need to sum the matrices, producing a totals matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Using R’s sum() function wouldn’t work, as it would total all the elements of
    the matrices into a single number. Matrix addition is what we need.
  prefs: []
  type: TYPE_NORMAL
- en: Calling R’s Reduce() function will do the matrix addition. Recall that any arithmetic
    operation in R is implemented as a function; in this case, it is implemented as
    the function "+". The recall to Reduce() then successively applies "+" to the
    elements of the list sumcounts. Of course, we could just write a loop to do this,
    but using Reduce() may give us a small performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3 Resorting to C**'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, using parallel R may greatly speed up your R code. This allows
    you to retain the convenience and expressive power of R, while still ameliorating
    large runtimes in big applications. If the parallelized R gives you sufficiently
    good performance, then all is well.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, parallel R is still R and thus still subject to the performance
    issues covered in Chapter 14\. Recall that one solution offered in that chapter
    was to write a performance-critical portion of your code in C and then call that
    code from your main R program. (The references to C here mean C or C++.) We will
    explore this from a parallel-processing viewpoint. Here, instead of writing parallel
    R, we write ordinary R code that calls parallel C. (I assume a knowledge of C.)
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.1 Using Multicore Machines***'
  prefs: []
  type: TYPE_NORMAL
- en: The C code covered here runs only on multicore systems, so we must discuss the
    nature of such systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**340**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with dual-core machines. Any computer includes a CPU,
    which is the part that actually runs your program. In essence, a dual-core machine
    has two CPUs, a quad-core system has four, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple cores, you can do parallel computation!
  prefs: []
  type: TYPE_NORMAL
- en: This parallel computation is done with *threads*, which are analogous to snow’s
    workers. In computationally intensive applications, you generally set up as many
    threads as there are cores, for example two threads in a dual-core machine. Ideally,
    these threads run simultaneously, though overhead issues do arise, as will be
    explained when we look at general performance issues in Section 16.4.1\.
  prefs: []
  type: TYPE_NORMAL
- en: If your machine has multiple cores, it is structured as a *shared-memory* system.
    All cores access the same RAM. The shared nature of the memory makes communication
    between the cores easy to program. If a thread writes to a memory location, the
    change is visible to the other threads, without the programmer needing to insert
    code to make that happen.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.2 Extended Example: Mutual Outlinks Problem in OpenMP***'
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP is a very popular package for programming on multicore machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, here is the mutual outlinks example again, this time in
    R-callable OpenMP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <omp.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <R.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: int tot; // grand total of matches, over all threads
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: // processes row pairs (i,i+1), (i,i+2), ...
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: int procpairs(int i, int *m, int n)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '{ int j,k,sum=0;'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: for (j = i+1; j < n; j++) {
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: for (k = 0; k < n; k++)
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: // find m[i][k]*m[j][k] but remember R uses col-major order
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: sum += m[n*k+i] * m[n*k+j];
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: return sum;
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: void mutlinks(int *m, int *n, double *mlmean)
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '{ int nval = *n;'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: tot = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp parallel'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '{ int i,mysum=0,'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: me = omp_get_thread_num(),
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: nth = omp_get_num_threads();
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: // in checking all (i,j) pairs, partition the work according to i;
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: // this thread me will handle all i that equal me mod nth
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: for (i = me; i < nval; i += nth) {
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**341**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: mysum += procpairs(i,m,nval);
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp atomic'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: tot += mysum;
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: int divisor = nval * (nval-1) / 2;
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '*mlmean = ((float) tot)/divisor;'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.3 Running the OpenMP Code***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, compilation follows the recipe in Chapter 15\. We do need to link in
    the OpenMP library, though, by using the -fopenmp and -lgomp options. Suppose
    our source file is *romp.c*. Then we use the following commands to run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o
    gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp Here’s an
    R test:'
  prefs: []
  type: TYPE_NORMAL
- en: dyn.load("romp.so")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sys.setenv(OMP_NUM_THREADS=4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n <- 1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m <- matrix(sample(0:1,n^2,replace=T),nrow=n)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: system.time(z <- .C("mutlinks",as.integer(m),as.integer(n),result=double(1)))
    user system elapsed
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '0.830'
  prefs: []
  type: TYPE_NORMAL
- en: '0.000'
  prefs: []
  type: TYPE_NORMAL
- en: '0.218'
  prefs: []
  type: TYPE_NORMAL
- en: z$result
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 249.9471'
  prefs: []
  type: TYPE_NORMAL
- en: The typical way to specify the number of threads in OpenMP is through an operating
    system environment variable, OMP_NUM_THREADS. R is capable of setting operating
    system environment variables with the Sys.setenv() function. Here, I set the number
    of threads to 4, because I was running on a quad-core machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note the runtime—only 0.2 seconds! This compares to the 5.0-second
  prefs: []
  type: TYPE_NORMAL
- en: time we saw earlier for a 12-node snow system. This might be surprising to some
    readers, as our code in the snow version was vectorized to a fair degree, as mentioned
    earlier. Vectorizing is good, but again, R has many hidden sources of overhead,
    so C might do even better.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I tried R’s new byte-compilation function cmpfun(), but mtl() actually became
    slower.*'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if you are willing to write part of your code in parallel C, dramatic
    speedups may be possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**342**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.4 OpenMP Code Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP code is C, with the addition of *pragmas* that instruct the compiler
    to insert some library code to perform OpenMP operations. Look at line 20, for
    instance. When execution reaches this point, the threads will be activated. Each
    thread then executes the block that follows—lines 21 through 31—in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: A key point is variable scope. All the variables within the block starting on
    line 21 are local to their specific threads. For example, we’ve named the total
    variable in line 21 mysum because each thread will maintain its own sum.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the global variable tot on line 4 is held in common by all the
    threads. Each thread makes its contribution to that grand total on line 30\.
  prefs: []
  type: TYPE_NORMAL
- en: But even the variable nval on line 18 is held in common with all the threads
    (during the execution of mutlinks()), as it is declared outside the block beginning
    on line 21\. So, even though it is a local variable in terms of C scope, it is
    global to all the threads. Indeed, we could have declared tot on that line, too.
    It needs to be shared by all the threads, but since it’s not used outside mutlinks(),
    it could have been declared on line 18\.
  prefs: []
  type: TYPE_NORMAL
- en: Line 29 contains another pragma, atomic. This one applies only to the single
    line following it—line 30, in this case—rather than to a whole block.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the atomic pragma is to avoid what is called a *race condition*
    in parallel-processing circles. This term describes a situation in which two threads
    are updating a variable at the same time, which may produce incorrect results.
    The atomic pragma ensures that line 30 will be executed by only one thread at
    a time. Note that this implies that in this section of the code, our parallel
    program becomes temporarily serial, which is a potential source of slowdown.
  prefs: []
  type: TYPE_NORMAL
- en: Where is the manager’s role in all of this? Actually, the manager is the original
    thread, and it executes lines 18 and 19, as well as .C(), the R function that
    makes the call to mutlinks(). When the worker threads are activated in line 21,
    the manager goes dormant. The worker threads become dormant once they finish line
    31\. At that point, the manager resumes execution. Due to the dormancy of the
    manager while the workers are executing, we do want to have as many workers as
    our machine has cores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function procpairs() is straightforward, but note the manner in which the
    matrix m is being accessed. Recall from the discussion in Chapter 15 on interfacing
    R to C that the two languages store matrices differently: column by column in
    R and row-wise in C. We need to be aware of that difference here. In addition,
    we have treated the matrix m as a one-dimensional array, as is common in parallel
    C code. In other words, if n is, say, 4, then we treat m as a vector of 16 elements.
    Due to the column-major nature of R'
  prefs: []
  type: TYPE_NORMAL
- en: matrix storage, the vector will consist first of the four elements of column
    1, then the four of column 2, and so on. To further complicate matters, we must
    keep in mind that array indices in C start at 0, instead of starting at 1 as in
    R.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all of this together yields the multiplication in line 12\. The factors
    here are the (k,i) and (k,j) elements of the version of m in the C code, which
    are the (i+1,k+1) and (j+1,k+1) elements back in the R code.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**343**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.5 Other OpenMP Pragmas***'
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP includes a wide variety of possible operations—far too many to list here.
    This section provides an overview of some OpenMP pragmas that I consider especially
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3.5.1 The omp barrier Pragma**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parallel-processing term *barrier* refers to a line of code at which the
    threads rendezvous. The syntax for the omp barrier pragma is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp barrier'
  prefs: []
  type: TYPE_NORMAL
- en: When a thread reaches a barrier, its execution is suspended until all other
    threads have reached that line. This is very useful for iterative algorithms;
    threads wait at a barrier at the end of every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in addition to this explicit barrier invocation, some other pragmas
    place an implicit barrier following their blocks. These include single and parallel.
    There is an implied barrier immediately following line 31 in the previous listing,
    for example, which is why the manager stays dormant until all worker threads finish.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3.5.2 The omp critical Pragma**'
  prefs: []
  type: TYPE_NORMAL
- en: The block that follows this pragma is a *critical section*, meaning one in which
    only one thread is allowed to execute at a time. The omp critical pragma essentially
    serves the same purpose as the atomic pragma discussed earlier, except that the
    latter is limited to a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The OpenMP designers defined a special pragma for this single-statement situation
    in* *the hope that the compiler can translate this to an especially fast machine
    instruction.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the omp critical syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp critical'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: // place one or more statements here
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3.5.3 The omp single Pragma**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The block that follows this pragma is to be executed by only one of the threads.
    Here is the syntax for the omp single pragma:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp single'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: // place one or more statements here
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**344**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for initializing sum variables that are shared by the threads,
    for instance. As noted earlier, an automatic barrier is placed after the block.
  prefs: []
  type: TYPE_NORMAL
- en: This should make sense to you. If one thread is initializing a sum, you wouldn’t
    want other threads that make use of this variable to continue execution until
    the sum has been properly set.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about OpenMP in my open source textbook on par-
  prefs: []
  type: TYPE_NORMAL
- en: allel processing at *http://heather.cs.ucdavis.edu/parprocbook*.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.3.6 GPU Programming***'
  prefs: []
  type: TYPE_NORMAL
- en: Another type of shared-memory parallel hardware consists of graphics processing
    units (GPUs). If you have a sophisticated graphics card in your machine, say for
    playing games, you may not realize that it is also a very powerful computational
    device—so powerful that the slogan “A supercomputer on your desk!” is often used
    to refer to PCs equipped with high-end GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: As with OpenMP, the idea here is that instead of writing parallel R, you write
    R code interfaced to parallel C. (Similar to the OpenMP case, *C*
  prefs: []
  type: TYPE_NORMAL
- en: here means a slightly augmented version of the C language.) The technical details
    become rather complex, so I won’t show any code examples, but an overview of the
    platform is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, GPUs do follow the shared-memory/threads model,
  prefs: []
  type: TYPE_NORMAL
- en: but on a much larger scale. They have dozens, or even hundreds, of
  prefs: []
  type: TYPE_NORMAL
- en: cores (depending on how you define *core*). One major difference is that several
    threads can be run together in a block, which can produce certain efficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: Programs that access GPUs begin their run on your machine’s CPU,
  prefs: []
  type: TYPE_NORMAL
- en: referred to as the *host*. They then start code running on the GPU, or *device*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that your data must be transferred from the host to the device, and
    after the device finishes its computation, the results must be transferred back
    to the host.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, GPU has not yet become common among R users.
  prefs: []
  type: TYPE_NORMAL
- en: The most common usage is probably through the CRAN package gputools, which consists
    of some matrix algebra and statistical routines callable from R. For instance,
    consider matrix inversion. R provides the function solve() for this, but a parallel
    alternative is available in gputools with the name gpuSolve().
  prefs: []
  type: TYPE_NORMAL
- en: For more about GPU programming, again see my book on parallel pro-
  prefs: []
  type: TYPE_NORMAL
- en: cessing at *http://heather.cs.ucdavis.edu/parprocbook*.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4 General Performance Considerations**'
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses some issues that you may find generally useful in parallelizing
    R applications. I’ll present some material on the main sources of overhead and
    then discuss a couple of algorithmic issues.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**345**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***16.4.1 Sources of Overhead***'
  prefs: []
  type: TYPE_NORMAL
- en: Having at least a rough idea of the physical causes of overhead is essential
    to successful parallel programming. Let’s take a look at these in the contexts
    of the two main platforms, shared-memory and networked computers.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4.1.1 Shared-Memory Machines**'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the memory sharing in multicore machines makes for easier
    programming. However, the sharing also produces overhead, since the two cores
    will bump into each other if they both try to access memory at the same time.
    This means that one of them will need to wait, causing overhead. That overhead
    is typically in the range of hundreds of nanoseconds (billionths of seconds).
    This sounds really small, but keep in mind that the CPU is working at a subnanosecond
    speed, so memory access often becomes a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Each core may also have a *cache*, in which it keeps a local copy of some of
    the shared memory. It’s intended to reduce contention for memory among the cores,
    but it produces its own overhead, involving time spent in keeping the caches consistent
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that GPUs are special types of multicore machines. As such, they suffer
    from the problems I’ve described, and more. First, the *latency*, which is the
    time delay before the first bit arrives at the GPU from its memory after a memory
    read request, is quite long in GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the overhead incurred in transferring data between the host and
    the device. The latency here is on the order of microseconds (millionths of seconds),
    an eternity compared to the nanosecond scale of the CPU and GPU.
  prefs: []
  type: TYPE_NORMAL
- en: GPUs have great performance potential for certain classes of applications, but
    overhead can be a major issue. The authors of gputools note that their matrix
    operations start achieving a speedup only at matrix sizes of 1000
  prefs: []
  type: TYPE_NORMAL
- en: by 1000\. I wrote a GPU version of our mutual outlinks application, which turned
    out to have a runtime of 3.0 seconds—about half of the snow version but still
    far slower than the OpenMP implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are ways of ameliorating these problems, but they require very
    careful, creative programming and a sophisticated knowledge of the physical GPU
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4.1.2 Networked Systems of Computers**'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier, another way to achieve parallel computation is through networked
    systems of computers. You still have multiple CPUs, but in this case, they are
    in entirely separate computers, each with its own memory.
  prefs: []
  type: TYPE_NORMAL
- en: As pointed out earlier, network data transfer causes overhead. Its latency is
    again on the order of microseconds. Thus, even accessing a small amount of data
    across the network incurs a major delay.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that snow has additional overhead, as it changes numeric
  prefs: []
  type: TYPE_NORMAL
- en: objects such as vectors and matrices to character form before sending them,
    say from the manager to the workers. Not only does this entail time for the conversion
    (both in changing from numeric to character form and **346**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: in charging back to numeric at the receiver), but the character form tends to
    make for much longer messages, thus longer network transfer time.
  prefs: []
  type: TYPE_NORMAL
- en: Shared-memory systems can be networked together, which, in fact, we did in the
    previous example. We had a hybrid situation in which we formed snow clusters from
    several networked dual-core computers.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.4.2 Embarrassingly Parallel Applications and Those That Aren’t***'
  prefs: []
  type: TYPE_NORMAL
- en: It’s no shame to be poor, but it’s no great honor either.
  prefs: []
  type: TYPE_NORMAL
- en: —Tevye, *Fiddler on the Roof*
  prefs: []
  type: TYPE_NORMAL
- en: Man is the only animal that blushes, or needs to.
  prefs: []
  type: TYPE_NORMAL
- en: —Mark Twain
  prefs: []
  type: TYPE_NORMAL
- en: The term *embarrassingly parallel* is heard often in talk about parallel R
  prefs: []
  type: TYPE_NORMAL
- en: (and in the parallel processing field in general). The word *embarrassing* alludes
    to the fact that the problems are so easy to parallelize that there is no intellectual
    challenge involved; they are embarrassingly easy.
  prefs: []
  type: TYPE_NORMAL
- en: Both of the example applications we’ve looked at here would be con-
  prefs: []
  type: TYPE_NORMAL
- en: sidered embarrassingly parallel. Parallelizing the for i loop for the mutual
    outlinks problem in Section 16.1 was pretty obvious. Partitioning the work in
    the KMC example in Section 16.2.4 was also natural and easy.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, most parallel sorting algorithms require a great deal of interaction.
    For instance, consider merge sort, a common method of sorting numbers. It breaks
    the vector to be sorted into two (or more) independent parts, say the left half
    and right half, which are then sorted in parallel by two processes. So far, this
    is embarrassingly parallel, at least after the vector is divided in half. But
    then the two sorted halves must be merged to produce the sorted version of the
    original vector, and that process is *not* embarrassingly parallel. It can be
    parallelized but in a more complex manner.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to paraphrase Tevye, it’s no shame to have an embarrassingly parallel
    problem! It may not exactly be an honor, but it is a cause for cele-bration, as
    it is easy to program. More important, embarrassingly parallel problems tend to
    have low communication overhead, which is crucial to performance, as discussed
    earlier. In fact, when most people refer to embarrassingly parallel applications,
    they have this low overhead in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about nonembarrassingly parallel applications? Unfortunately, parallel
    R code is simply not suitable for many of them for a very basic reason: the functional
    programming nature of R. As discussed in Section 14.3, a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: x[3] <- 8
  prefs: []
  type: TYPE_NORMAL
- en: is deceptively simple, because it can cause the entire vector x to be rewritten.
    This really compounds communication traffic problems. Accordingly, if your application
    is not embarrassingly parallel, your best strategy is probably to write the computationally
    intensive parts of the code in C, say using OpenMP or GPU programming.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**347**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Also, note carefully that even being embarrassingly parallel does not make an
    algorithm efficient. Some such algorithms can still have significant communication
    traffic, thus compromising performance.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the KMC problem, run under snow. Suppose we were to set
  prefs: []
  type: TYPE_NORMAL
- en: up a large enough number of workers so that each worker had relatively little
    work to do. In that case, the communication with the manager after each iteration
    would become a signficant portion of run time. In this situation, we would say
    that the *granularity* is too fine, and then probably switch to using fewer workers.
    We would then have larger tasks for each worker, thus a *coarser* granularity.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.4.3 Static Versus Dynamic Task Assignment***'
  prefs: []
  type: TYPE_NORMAL
- en: Look again at the loop beginning on line 26 of our OpenMP example,
  prefs: []
  type: TYPE_NORMAL
- en: 'reproduced here for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: for (i = me; i < nval; i += nth) {
  prefs: []
  type: TYPE_NORMAL
- en: mysum += procpairs(i,m,nval);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The variable me here was the thread number, so the effect of this code was that
    the various threads would work on nonoverlapping sets of values of i. We do want
    the values to be nonoverlapping, to avoid duplicate work and an incorrect count
    of total number of links, so the code was fine. But the point now is that we were,
    in effect, preassigning the tasks that each thread would handle. This is called
    *static* assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to revise the for loop to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: int nexti = 0; // global variable
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: for ( ; myi < n; ) { // revised "for" loop
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp critical'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: nexti += 1;
  prefs: []
  type: TYPE_NORMAL
- en: myi = nexti;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (myi < n) {
  prefs: []
  type: TYPE_NORMAL
- en: mysum += procpairs(myi,m,nval);
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: This is *dynamic* task assignment, in which it is not determined ahead of time
    which threads handle which values of i. Task assignment is done during execution.
    At first glance, dynamic assignment seems to have the potential for better performance.
    Suppose, for instance, that in a static assignment **348**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: setting, one thread finishes its last value of i early, while another thread
    still has two values of i left to do. This would mean our program would finish
    somewhat later than it could. In parallel-processing parlance, we would have a
    *load balance* problem. With dynamic assignment, the thread that finished when
    there were two values of i left to handle could have taken up one of those values
    itself. We would have better balance and theoretically less overall runtime.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t jump to conclusions. As always, we have the overhead issue to reckon
    with. Recall that a critical pragma, used in the dynamic version of the code above,
    has the effect of temporarily rendering the program serial rather than parallel,
    thus causing a slowdown. In addition, for reasons too technical to discuss here,
    these pragmas may cause considerable cache activity overhead. So in the end, the
    dynamic code could actually be substantially slower than the static version.
  prefs: []
  type: TYPE_NORMAL
- en: Various solutions to this problem have been developed, such as an
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP construct named guided. But rather than present these, the point I wish
    to make is that they are unnecessary. In most situations, static assignment is
    just fine. Why is this the case?
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that the standard deviation of the sum of independent, identically
    distributed random variables, divided by the mean of that sum, goes to zero as
    the number of terms goes to infinity. In other words, sums are approximately constant.
    This has a direct implication for our load-balancing concerns: Since the total
    work time for a thread in static assignment is the sum of its individual task
    times, that total work time will be approximately constant; there will be very
    little variation from thread to thread. Thus, they will all finish at pretty close
    to the same time, and we do not need to worry about load imbalance. Dynamic scheduling
    will not be necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This reasoning does depend on a statistical assumption, but in practice, the
    assumption will typically be met sufficiently well for the outcome: Static scheduling
    does as well as dynamic in terms of uniformity of total work times across threads.
    And since static scheduling doesn’t have the overhead problems of the dynamic
    kind, in most cases the static approach will give better performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more aspect of this to discuss. To illustrate the issue, consider
    again the mutual outlinks example. Let’s review the outline of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: sum = 0
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: for i = 0...n-1
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: for j = i+1...n-1
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: mean = sum / (n*(n-1)/2)
  prefs: []
  type: TYPE_NORMAL
- en: Say n is 10000 and we have four threads, and consider ways to partition the
    for i loop. Naively, we might at first decide to have thread 0 handle the i values
    0 through 2499, thread 1 handle 2500 through 4999, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, this would produce a severe load imbalance, since the thread that Parallel
    R
  prefs: []
  type: TYPE_NORMAL
- en: '**349**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'handles a given value of i does an amount of work proportional to n-i. That,
    in fact, is why we staggered the values of i in our actual code: Thread 0 handled
    the i values 0, 4, 8 ..., thread 1 worked on 1, 5, 9, ..., and so on, yielding
    good load balance.'
  prefs: []
  type: TYPE_NORMAL
- en: The point then is that static assignment might require a bit more plan-ning.
    One general approach to this is to randomly assign tasks (i values, in our case
    here) to threads (still doing so at the outset, before work begins).
  prefs: []
  type: TYPE_NORMAL
- en: With a bit of forethought such as this, static assignment should work well in
    most applications.
  prefs: []
  type: TYPE_NORMAL
- en: '***16.4.4 Software Alchemy: Turning General Problems into Embarrassingly***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Parallel Ones***'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, it’s difficult to attain good performance from nonembarrassingly
    parallel algorithms. Fortunately, for statistical applications, there is a way
    to turn nonembarrassingly parallel problems into embarrassingly parallel ones.
    The key is to exploit some statistical properties.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the method, let’s once again turn to our mutual out-
  prefs: []
  type: TYPE_NORMAL
- en: 'links problem. The method, applied with w workers on a links matrix m, consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Break the rows of m into w chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Have each worker find the mean number of mutual outlinks for pairs of vertices
    in its chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Average the results returned by the workers.
  prefs: []
  type: TYPE_NORMAL
- en: It can be shown mathematically that for large problems (the only ones you would
    need parallel computing for anyway), this chunked approach gives the estimators
    of the same statistical accuracy as in the nonchunked method. But meanwhile, we’ve
    turned a nonparallel problem into not just a parallel one but an embarrassingly
    parallel one! The workers in the preceding outline compute entirely independently
    of each other.
  prefs: []
  type: TYPE_NORMAL
- en: This method should not be confused with the usual chunk-based
  prefs: []
  type: TYPE_NORMAL
- en: approaches in parallel processing. In those, such as the merge-sort example
    discussed on page 347, the chunking is embarrassingly parallel, but the combining
    of results is not. By contrast, here the combining of results consists of simple
    averaging, thanks to the mathematical theory.
  prefs: []
  type: TYPE_NORMAL
- en: I tried this approach on the mutual outlinks problem in a 4-worker snow cluster.
    This reduced the runtime to 1.5 seconds. This is far better than the serial time
    of about 16 seconds, double the speedup obtained by the GPU
  prefs: []
  type: TYPE_NORMAL
- en: and approaching comparability to the OpenMP time. And the theory showing that
    the two methods give the same statistical accuracy was confirmed as well. The
    chunked method found the mean number of mutual outlinks to be 249.2881, compared
    to 249.2993 for the original estimator.
  prefs: []
  type: TYPE_NORMAL
- en: '**350**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5 Debugging Parallel R Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R packages such as Rmpi, snow, foreach, and so on do not set up a terminal
    window for each process, thus making it impossible to use R’s debugger on the
    workers. (My Rdsm package, which adds a threads capability to R, is an exception
    to this.)
  prefs: []
  type: TYPE_NORMAL
- en: What then can you do to debug apps for those packages? Let’s consider snow for
    a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: First, you should debug the underlying single-worker function, such as mtl()
    in Section 16.2\. Here, we would set up some artificial values of the arguments
    and then use R’s ordinary debugging facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the underlying function may be sufficient. However, the bug may be
    in the arguments themselves or in the way we set them up. Then things get more
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: It’s even hard to print out trace information, such as values of variables,
    since print() won’t work in the worker processes. The message() function may work
    for some of these packages; if not, you may need to resort to using cat() to write
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel R
  prefs: []
  type: TYPE_NORMAL
- en: '**351**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](index-379_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INSTALLING R**'
  prefs: []
  type: TYPE_NORMAL
- en: This appendix covers the methods for
  prefs: []
  type: TYPE_NORMAL
- en: installing R on your system. You can eas-
  prefs: []
  type: TYPE_NORMAL
- en: ily download and install the precompiled
  prefs: []
  type: TYPE_NORMAL
- en: binaries, use your package manager on a UNIX-
  prefs: []
  type: TYPE_NORMAL
- en: based system, or even install from source if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '**A.1 Downloading R from CRAN**'
  prefs: []
  type: TYPE_NORMAL
- en: R, in both its base form and user-written packages, is available on the Comprehensive
    R Archive Network (CRAN) at the R home page, *http://www*
  prefs: []
  type: TYPE_NORMAL
- en: '*.r-project.org/*. Click CRAN and choose a site near you to download the appropriate
    base package for your operating system (OS).'
  prefs: []
  type: TYPE_NORMAL
- en: For most users, installing R is quite simple, regardless of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: You can find precompiled binaries for Windows, Linux, and Mac OS X on CRAN.
    You should be able to simply download the appropriate file and install R.
  prefs: []
  type: TYPE_NORMAL
- en: '**A.2 Installing from a Linux Package Manager**'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using the precompiled binaries, if you’re running a Linux distribution
    with a centralized package repository, such as Fedora or Ubuntu, you
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'can install R using your OS’s package manager. For example, if you’re running
    Fedora, you can install R by typing the following at the command line: $ yum install
    R'
  prefs: []
  type: TYPE_NORMAL
- en: For a Debian-based system, such as Ubuntu, the command looks
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install r-base
  prefs: []
  type: TYPE_NORMAL
- en: Check your distribution’s documentation for more details on installing and removing
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: '**A.3 Installing from Source**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux or other UNIX-based machines (probably including Mac OS X), you can
    also compile R’s source code yourself. Simply unpack the source archive and follow
    the classic three-command installation procedure: $ configure'
  prefs: []
  type: TYPE_NORMAL
- en: $ make
  prefs: []
  type: TYPE_NORMAL
- en: $ make install
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may need to run make install as root, depending on your write
    permissions and the location to which you’re installing R. If you want to install
    to a nonstandard directory, say */a/b/c*, you can run configure with the --prefix
    parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: $ configure --prefix=/a/b/c
  prefs: []
  type: TYPE_NORMAL
- en: This might be helpful if you’re working on a shared machine and don’t have write
    permissions to the standard installation directories like */usr*.
  prefs: []
  type: TYPE_NORMAL
- en: '**354**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 45](index-381_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INSTALLING AND USING PACKAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the major strengths of R is that
  prefs: []
  type: TYPE_NORMAL
- en: thousands of user-written packages are
  prefs: []
  type: TYPE_NORMAL
- en: available on the Comprehensive R Archive
  prefs: []
  type: TYPE_NORMAL
- en: Network (CRAN) at the R home page, *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.r-project.org/*. Package installation is easy in most'
  prefs: []
  type: TYPE_NORMAL
- en: cases, but there are nuances to be aware of for some of
  prefs: []
  type: TYPE_NORMAL
- en: the specialty packages.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix starts with some package basics and then explains how to load
    R packages from your hard drive and from the Web.
  prefs: []
  type: TYPE_NORMAL
- en: '**B.1 Package Basics**'
  prefs: []
  type: TYPE_NORMAL
- en: R uses packages to store groups of related pieces of software. The packages
    that are included with the R distribution are visible as subdirectories of your
    *library* directory in your R installation tree, as in */usr/lib/R/library*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the R community, the term* library *is often used in place of* package
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: Some packages are loaded automatically when you start R, such as the *base*
    subdirectory. However, in order to save memory and time, R does not load all available
    packages automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check which packages are currently loaded by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: .path.package()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**B.2 Loading a Package from Your Hard Drive**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a package that is in your R installation but not loaded into memory
    yet, you can load it using the library() function. For instance, suppose you wish
    to generate multivariate normal random vectors. The function mvrnorm() in the
    package MASS does this. So, load the package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: library(MASS)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The mvrnorm() function will now be ready to use. And so will its documentation
    (before you loaded MASS, entering help(mvrnorm) would have generated an error
    message).
  prefs: []
  type: TYPE_NORMAL
- en: '**B.3 Downloading a Package from the Web**'
  prefs: []
  type: TYPE_NORMAL
- en: The package you want may not be in your R installation. One of the big advantages
    of open source software is that people love to share. People all over the world
    have written their own special-purpose R packages, placing them in the CRAN repository
    and elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*User contributions to CRAN go through a vetting process and are generally
    of high* *quality. They are, however, not tested as throughly as R itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***B.3.1 Installing Packages Automatically***'
  prefs: []
  type: TYPE_NORMAL
- en: One way to install a package is to use the install_packages() function. For
    example, suppose you wish to use the mvtnorm package, which computes multivariate
    normal cumulative distribution functions and other quantities.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, choose a directory in which you wish to install the package (and maybe
    others in the future), say */a/b/c*. Then at the R prompt, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: install.packages("mvtnorm","/a/b/c/")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This will cause R to automatically go to CRAN, download the package, compile
    it, and load it into a new directory: */a/b/c/mvtnorm*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You do need to tell R where to find that package once it’s installed, which
    you can do via the .libPaths() function:'
  prefs: []
  type: TYPE_NORMAL
- en: .libPaths("/a/b/c/")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This will add that new directory to the ones R was already using. If you use
    that directory often enough, you may wish to add that call to .libPaths() in your
    *.Rprofile* startup file in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**356**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: A call to .libPaths() without an argument will show you a list of all the places
    R will currently look for loading a package when requested.
  prefs: []
  type: TYPE_NORMAL
- en: '***B.3.2 Installing Packages Manually***'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you need to install “by hand” to make modifications required to make
    a particular R package work on your system. The following example demonstrates
    how I did so in one particular instance, and it will serve as a case study on
    handling situations in which ordinary methods don’t work.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Situations in which you need to install packages by hand typically are operating
    system* *dependent and require more computer expertise than is generally assumed
    in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*For help in very specific cases, the* r-help *mailing list is invaluable.
    To access it, go to* *the R home page (* http://www.r-project.org/ *), click the
    FAQs link and then the R*'
  prefs: []
  type: TYPE_NORMAL
- en: '*FAQ link, and scroll down to Section 2.9, “What mailing lists exist for R?”*'
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to install the Rmpi package on our department’s instructional machines
    in the directory */home/matloff/R*. I tried using install.packages() first but
    found that the automated process could not find the MPI library on our machines.
    The problem was that R was looking for those files in
  prefs: []
  type: TYPE_NORMAL
- en: '*/usr/local/lam*, whereas I knew they were in */usr/local/LAM*. Since these
    were public machines, not my own, I did not have the authority to change the name.
    So, I downloaded the Rmpi files in the packed form *Rmpi_0.5-3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*.tar.gz*. I unpacked that file in my directory *~/tmp*, producing a directory
    named *~/tmp/Rmpi*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I had not experienced this problem, at this point, I could have just typed
    the following in a terminal window from within the *~/tmp* directory: R CMD INSTALL
    -l /home/matloff/R Rmpi'
  prefs: []
  type: TYPE_NORMAL
- en: That command would install the package contained in *~/tmp/Rmpi*, placing it
    in */home/matloff/R*. This would have been an alternative to calling install.packages().
  prefs: []
  type: TYPE_NORMAL
- en: 'But as noted, I had to deal with a problem. Within the *~/tmp/Rmpi* directory,
    there was a *configure* file, so I ran this command on my Linux command line:'
  prefs: []
  type: TYPE_NORMAL
- en: configure --help
  prefs: []
  type: TYPE_NORMAL
- en: 'It told me that I could specify the location of my MPI files to configure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: configure --with-mpi=/usr/local/LAM
  prefs: []
  type: TYPE_NORMAL
- en: 'This applies if you run configure directly, but I ran it via R:'
  prefs: []
  type: TYPE_NORMAL
- en: R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Using Packages
  prefs: []
  type: TYPE_NORMAL
- en: '**357**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Well, that seemed to work, in the sense that R did install the package, but
    R also noted that it had a problem with the threads library on our machines. Sure
    enough, when I tried to load Rmpi, I got a runtime error, saying that a certain
    threads function wasn’t there.
  prefs: []
  type: TYPE_NORMAL
- en: 'I knew that our threads library was fine, so I went into the configure file
    and commented out two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: if test $ac_cv_lib_pthread_main = yes; then
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPI_LIBS="$MPI_LIBS -lpthread"
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other words, I forced it to use what I knew (or was fairly sure) would work.
    I then reran R CMD INSTALL, and the package loaded without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**B.4 Listing the Functions in a Package**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a list of functions in a package by calling library() with the
    help argument. For instance, for help on the mvtnorm package, type one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: library(help=mvtnorm)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: help(package=mvtnorm)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**358**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**I N D E X**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Special Characters**'
  prefs: []
  type: TYPE_NORMAL
- en: lines with abline() function, 263–264
  prefs: []
  type: TYPE_NORMAL
- en: list elements, 88–90
  prefs: []
  type: TYPE_NORMAL
- en: ': (colon operator), 32–33'
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 73–78
  prefs: []
  type: TYPE_NORMAL
- en: == operator, 54–55
  prefs: []
  type: TYPE_NORMAL
- en: points to graphs with points() func-
  prefs: []
  type: TYPE_NORMAL
- en: operator, 40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tion, 269–270
  prefs: []
  type: TYPE_NORMAL
- en: .libpaths() function, 356–357
  prefs: []
  type: TYPE_NORMAL
- en: text to graphs with text() function,
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rdata* file, 20'
  prefs: []
  type: TYPE_NORMAL
- en: 270–271
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rhistory* file, 20'
  prefs: []
  type: TYPE_NORMAL
- en: addmargins() function, 131
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rprofile* file, 19'
  prefs: []
  type: TYPE_NORMAL
- en: adjacency matrix, 333
  prefs: []
  type: TYPE_NORMAL
- en: <<- (superassignment operator), 9
  prefs: []
  type: TYPE_NORMAL
- en: aggregate() function, 136
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 174
  prefs: []
  type: TYPE_NORMAL
- en: all() function, 35–39
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with, 161–162
  prefs: []
  type: TYPE_NORMAL
- en: analogous operations, resizing
  prefs: []
  type: TYPE_NORMAL
- en: + operator, 31
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 74
  prefs: []
  type: TYPE_NORMAL
- en: '"%mut%"() function, 218'
  prefs: []
  type: TYPE_NORMAL
- en: anonymous functions, 99, 187–188
  prefs: []
  type: TYPE_NORMAL
- en: antibugging, 287
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: any() function, 35–39
  prefs: []
  type: TYPE_NORMAL
- en: application-specific functions, 165
  prefs: []
  type: TYPE_NORMAL
- en: abalone data set
  prefs: []
  type: TYPE_NORMAL
- en: apply() function
  prefs: []
  type: TYPE_NORMAL
- en: recoding, 51–54
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to matrix rows
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() function, 99
  prefs: []
  type: TYPE_NORMAL
- en: and columns, 70–72
  prefs: []
  type: TYPE_NORMAL
- en: abline() graphics function, 150
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 107
  prefs: []
  type: TYPE_NORMAL
- en: abs() math function, 189
  prefs: []
  type: TYPE_NORMAL
- en: obtaining variable marginal
  prefs: []
  type: TYPE_NORMAL
- en: accessing
  prefs: []
  type: TYPE_NORMAL
- en: values, 131
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 102–104
  prefs: []
  type: TYPE_NORMAL
- en: arguments. *See also specific argument*
  prefs: []
  type: TYPE_NORMAL
- en: files on remote machines via
  prefs: []
  type: TYPE_NORMAL
- en: '*by name*'
  prefs: []
  type: TYPE_NORMAL
- en: URLs, 243
  prefs: []
  type: TYPE_NORMAL
- en: actual, 9
  prefs: []
  type: TYPE_NORMAL
- en: Internet, 246–250
  prefs: []
  type: TYPE_NORMAL
- en: default, 9–10
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R exam-
  prefs: []
  type: TYPE_NORMAL
- en: default values for, 146–147
  prefs: []
  type: TYPE_NORMAL
- en: ple, 248–250
  prefs: []
  type: TYPE_NORMAL
- en: formal, 9
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic operations, 30–31, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  prefs: []
  type: TYPE_NORMAL
- en: array() function, 134
  prefs: []
  type: TYPE_NORMAL
- en: keyboard and monitor, 232–235
  prefs: []
  type: TYPE_NORMAL
- en: arrays
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  prefs: []
  type: TYPE_NORMAL
- en: higher-dimensional arrays, 82–83
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  prefs: []
  type: TYPE_NORMAL
- en: as vectors, 28
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  prefs: []
  type: TYPE_NORMAL
- en: as.matrix() function, 81
  prefs: []
  type: TYPE_NORMAL
- en: list components and values, 93–95
  prefs: []
  type: TYPE_NORMAL
- en: aspell() function, 211
  prefs: []
  type: TYPE_NORMAL
- en: actual argument, 9
  prefs: []
  type: TYPE_NORMAL
- en: assign() function
  prefs: []
  type: TYPE_NORMAL
- en: adding
  prefs: []
  type: TYPE_NORMAL
- en: variables, 109
  prefs: []
  type: TYPE_NORMAL
- en: legends to graphs with legend()
  prefs: []
  type: TYPE_NORMAL
- en: writing nonlocals with, 163
  prefs: []
  type: TYPE_NORMAL
- en: function, 270
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: atomic pragma, 343
  prefs: []
  type: TYPE_NORMAL
- en: character strings, 251–259
  prefs: []
  type: TYPE_NORMAL
- en: atomic vectors, 85–86
  prefs: []
  type: TYPE_NORMAL
- en: defined, 11
  prefs: []
  type: TYPE_NORMAL
- en: attr() function, 212
  prefs: []
  type: TYPE_NORMAL
- en: regular expressions, 254–257
  prefs: []
  type: TYPE_NORMAL
- en: forming filenames example,
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: 256–257
  prefs: []
  type: TYPE_NORMAL
- en: testing filename for given suffix
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 1
  prefs: []
  type: TYPE_NORMAL
- en: example, 255–256
  prefs: []
  type: TYPE_NORMAL
- en: help feature, 24
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions,
  prefs: []
  type: TYPE_NORMAL
- en: running R in, 3
  prefs: []
  type: TYPE_NORMAL
- en: 251–254
  prefs: []
  type: TYPE_NORMAL
- en: Bernoulli sequence, 204
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr(), 254
  prefs: []
  type: TYPE_NORMAL
- en: biglm package, 321
  prefs: []
  type: TYPE_NORMAL
- en: grep(), 252
  prefs: []
  type: TYPE_NORMAL
- en: bigmemory package, 321
  prefs: []
  type: TYPE_NORMAL
- en: nchar(), 252
  prefs: []
  type: TYPE_NORMAL
- en: binary files, 237
  prefs: []
  type: TYPE_NORMAL
- en: paste(), 252–253
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree, 177–182
  prefs: []
  type: TYPE_NORMAL
- en: regexpr(), 253–254
  prefs: []
  type: TYPE_NORMAL
- en: body() function, 149, 151
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(), 253
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: strsplit(), 253
  prefs: []
  type: TYPE_NORMAL
- en: braces, 144
  prefs: []
  type: TYPE_NORMAL
- en: substr(), 253
  prefs: []
  type: TYPE_NORMAL
- en: brackets, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: use of string utilities in edtdbg debug-
  prefs: []
  type: TYPE_NORMAL
- en: Bravington, Mark, 300
  prefs: []
  type: TYPE_NORMAL
- en: ging tool, 257–259
  prefs: []
  type: TYPE_NORMAL
- en: breakpoints, setting, 289–290
  prefs: []
  type: TYPE_NORMAL
- en: child nodes, binary search tree, 177
  prefs: []
  type: TYPE_NORMAL
- en: calling browser() function directly,
  prefs: []
  type: TYPE_NORMAL
- en: Chinese dialects, aids for learning,
  prefs: []
  type: TYPE_NORMAL
- en: 289–290
  prefs: []
  type: TYPE_NORMAL
- en: 115–120
  prefs: []
  type: TYPE_NORMAL
- en: using setbreakpoint() function, 290
  prefs: []
  type: TYPE_NORMAL
- en: chi-square distribution, 193–194
  prefs: []
  type: TYPE_NORMAL
- en: breaks component, hist() function, 14
  prefs: []
  type: TYPE_NORMAL
- en: chol() linear algebra function, 197
  prefs: []
  type: TYPE_NORMAL
- en: break statement, 141
  prefs: []
  type: TYPE_NORMAL
- en: choose() set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: browser commands, 289
  prefs: []
  type: TYPE_NORMAL
- en: chunking memory, 320–321
  prefs: []
  type: TYPE_NORMAL
- en: browser() function
  prefs: []
  type: TYPE_NORMAL
- en: class() function, 212
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  prefs: []
  type: TYPE_NORMAL
- en: cleaner code, 172
  prefs: []
  type: TYPE_NORMAL
- en: single-stepping through code, 288
  prefs: []
  type: TYPE_NORMAL
- en: client/server model, 247
  prefs: []
  type: TYPE_NORMAL
- en: by() function, 126–127
  prefs: []
  type: TYPE_NORMAL
- en: closures, 151, 174–175
  prefs: []
  type: TYPE_NORMAL
- en: byrow argument, matrix() function,
  prefs: []
  type: TYPE_NORMAL
- en: cloud() function, 282–283
  prefs: []
  type: TYPE_NORMAL
- en: 61, 236
  prefs: []
  type: TYPE_NORMAL
- en: cluster, snow package, 335
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  prefs: []
  type: TYPE_NORMAL
- en: clusterApply() function, snow package,
  prefs: []
  type: TYPE_NORMAL
- en: 72, 337, 339–340
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  prefs: []
  type: TYPE_NORMAL
- en: code files, 3
  prefs: []
  type: TYPE_NORMAL
- en: code safety, 41
  prefs: []
  type: TYPE_NORMAL
- en: c %in% y set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: col() function, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: cache, 346
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  prefs: []
  type: TYPE_NORMAL
- en: calculus, 192–193
  prefs: []
  type: TYPE_NORMAL
- en: color images, 63
  prefs: []
  type: TYPE_NORMAL
- en: categorical variables, 121
  prefs: []
  type: TYPE_NORMAL
- en: column-major order, matrix storage,
  prefs: []
  type: TYPE_NORMAL
- en: cbind() function, 12, 74–75, 106–107
  prefs: []
  type: TYPE_NORMAL
- en: 59, 61
  prefs: []
  type: TYPE_NORMAL
- en: c browser command, 289
  prefs: []
  type: TYPE_NORMAL
- en: combinatorial simulation, 205–206
  prefs: []
  type: TYPE_NORMAL
- en: cdf (cumulative distribution
  prefs: []
  type: TYPE_NORMAL
- en: combn() function, 203
  prefs: []
  type: TYPE_NORMAL
- en: function), 193
  prefs: []
  type: TYPE_NORMAL
- en: comdat$countabsamecomm component, 206
  prefs: []
  type: TYPE_NORMAL
- en: ceiling() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: comdat$numabchosen component, 206
  prefs: []
  type: TYPE_NORMAL
- en: cell counts, changing to
  prefs: []
  type: TYPE_NORMAL
- en: comdat$whosleft component, 206
  prefs: []
  type: TYPE_NORMAL
- en: proportions, 130
  prefs: []
  type: TYPE_NORMAL
- en: comma-separated value (CSV) files, 103
  prefs: []
  type: TYPE_NORMAL
- en: cex option, changing graph character
  prefs: []
  type: TYPE_NORMAL
- en: comments, 3
  prefs: []
  type: TYPE_NORMAL
- en: sizes with, 272–273
  prefs: []
  type: TYPE_NORMAL
- en: complete.cases() function, 105–106
  prefs: []
  type: TYPE_NORMAL
- en: c() function, 56–57
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive R Archive Network
  prefs: []
  type: TYPE_NORMAL
- en: Chambers, John, 226
  prefs: []
  type: TYPE_NORMAL
- en: (CRAN), 24, 193, 353
  prefs: []
  type: TYPE_NORMAL
- en: '**360**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: computed mean, saving in variable, 5
  prefs: []
  type: TYPE_NORMAL
- en: applying logistic regression
  prefs: []
  type: TYPE_NORMAL
- en: concatenating, vectors, 4
  prefs: []
  type: TYPE_NORMAL
- en: models example, 113–115
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() and sapply() on
  prefs: []
  type: TYPE_NORMAL
- en: constructors, 217
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 112–113
  prefs: []
  type: TYPE_NORMAL
- en: contingency tables, 128, 229
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 104–109
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 139–144
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 107
  prefs: []
  type: TYPE_NORMAL
- en: if-else function, 143–144
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdata frames,
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 143
  prefs: []
  type: TYPE_NORMAL
- en: 104–105
  prefs: []
  type: TYPE_NORMAL
- en: loops, 140–142
  prefs: []
  type: TYPE_NORMAL
- en: NA values, 105–106
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change policy, 314–315
  prefs: []
  type: TYPE_NORMAL
- en: rbind() and cbind() functions,
  prefs: []
  type: TYPE_NORMAL
- en: cos() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: 106–107
  prefs: []
  type: TYPE_NORMAL
- en: counter() function, 175
  prefs: []
  type: TYPE_NORMAL
- en: salary study example, 108–109
  prefs: []
  type: TYPE_NORMAL
- en: counts component
  prefs: []
  type: TYPE_NORMAL
- en: merging, 109–112
  prefs: []
  type: TYPE_NORMAL
- en: hist() function, 14
  prefs: []
  type: TYPE_NORMAL
- en: employee database example,
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 116
  prefs: []
  type: TYPE_NORMAL
- en: 111–112
  prefs: []
  type: TYPE_NORMAL
- en: covariance matrix, generating, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: reading from files, 236
  prefs: []
  type: TYPE_NORMAL
- en: CRAN (Comprehensive R Archive Net-
  prefs: []
  type: TYPE_NORMAL
- en: regression analysis of exam grades
  prefs: []
  type: TYPE_NORMAL
- en: work), 24, 193, 353
  prefs: []
  type: TYPE_NORMAL
- en: example, 103–104
  prefs: []
  type: TYPE_NORMAL
- en: critical section, OpenMP, 344
  prefs: []
  type: TYPE_NORMAL
- en: data structures, 10–16
  prefs: []
  type: TYPE_NORMAL
- en: crossprod() function, 196
  prefs: []
  type: TYPE_NORMAL
- en: character strings, 11
  prefs: []
  type: TYPE_NORMAL
- en: cross-validation, 219, 222
  prefs: []
  type: TYPE_NORMAL
- en: classes, 15–16
  prefs: []
  type: TYPE_NORMAL
- en: C-style looping, 140
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 14–15
  prefs: []
  type: TYPE_NORMAL
- en: CSV (comma-separated value) files, 103
  prefs: []
  type: TYPE_NORMAL
- en: lists, 12–14
  prefs: []
  type: TYPE_NORMAL
- en: ct.dat file, 128
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 11–12
  prefs: []
  type: TYPE_NORMAL
- en: cumprod() math function, 190, 191
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 10
  prefs: []
  type: TYPE_NORMAL
- en: cumsum() math function, 39, 190–191
  prefs: []
  type: TYPE_NORMAL
- en: debug() function, 288
  prefs: []
  type: TYPE_NORMAL
- en: cumulative distribution function
  prefs: []
  type: TYPE_NORMAL
- en: debugger() function, performing checks
  prefs: []
  type: TYPE_NORMAL
- en: (cdf), 193
  prefs: []
  type: TYPE_NORMAL
- en: after crash with, 291–292
  prefs: []
  type: TYPE_NORMAL
- en: cumulative sums and products, 191
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 285–304
  prefs: []
  type: TYPE_NORMAL
- en: curve() function, 277–278
  prefs: []
  type: TYPE_NORMAL
- en: ensuring consistency in debugging
  prefs: []
  type: TYPE_NORMAL
- en: customizing graphs, 272–280
  prefs: []
  type: TYPE_NORMAL
- en: simulation code, 302
  prefs: []
  type: TYPE_NORMAL
- en: adding polygons with polygon() func-
  prefs: []
  type: TYPE_NORMAL
- en: facilities, 288–300
  prefs: []
  type: TYPE_NORMAL
- en: tion, 275–276
  prefs: []
  type: TYPE_NORMAL
- en: browser commands, 289
  prefs: []
  type: TYPE_NORMAL
- en: changing character sizes with cex
  prefs: []
  type: TYPE_NORMAL
- en: debug() and browser()
  prefs: []
  type: TYPE_NORMAL
- en: option, 272–273
  prefs: []
  type: TYPE_NORMAL
- en: functions, 288
  prefs: []
  type: TYPE_NORMAL
- en: changing ranges of axes with xlim
  prefs: []
  type: TYPE_NORMAL
- en: debugging sessions, 292–300
  prefs: []
  type: TYPE_NORMAL
- en: and ylim options, 273–275
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  prefs: []
  type: TYPE_NORMAL
- en: graphing explicit functions, 276–277
  prefs: []
  type: TYPE_NORMAL
- en: traceback() and debugger()
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve
  prefs: []
  type: TYPE_NORMAL
- en: functions, 291–292
  prefs: []
  type: TYPE_NORMAL
- en: example, 277–280
  prefs: []
  type: TYPE_NORMAL
- en: trace() function, 291
  prefs: []
  type: TYPE_NORMAL
- en: smoothing points with lowess() and
  prefs: []
  type: TYPE_NORMAL
- en: global variables and, 173
  prefs: []
  type: TYPE_NORMAL
- en: loess() functions, 276
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 351
  prefs: []
  type: TYPE_NORMAL
- en: cut() function, 136–137
  prefs: []
  type: TYPE_NORMAL
- en: principles of, 285–287
  prefs: []
  type: TYPE_NORMAL
- en: antibugging, 287
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  prefs: []
  type: TYPE_NORMAL
- en: confirmation, 285–286
  prefs: []
  type: TYPE_NORMAL
- en: modular, top-down manner, 286
  prefs: []
  type: TYPE_NORMAL
- en: data argument, array() function, 134
  prefs: []
  type: TYPE_NORMAL
- en: starting small, 286
  prefs: []
  type: TYPE_NORMAL
- en: data frames, 14–15, 101–102
  prefs: []
  type: TYPE_NORMAL
- en: running GDB on R, 303–304
  prefs: []
  type: TYPE_NORMAL
- en: accessing, 102–104
  prefs: []
  type: TYPE_NORMAL
- en: syntax and runtime errors, 303
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to, 112–120
  prefs: []
  type: TYPE_NORMAL
- en: tools, 287–288, 300–302
  prefs: []
  type: TYPE_NORMAL
- en: aids for learning Chinese dialects
  prefs: []
  type: TYPE_NORMAL
- en: debug package, 300–301
  prefs: []
  type: TYPE_NORMAL
- en: example, 115–120
  prefs: []
  type: TYPE_NORMAL
- en: declarations, 28–29
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**361**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: default arguments, 9–10
  prefs: []
  type: TYPE_NORMAL
- en: employee database example, 111–112
  prefs: []
  type: TYPE_NORMAL
- en: deleting
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation, 207
  prefs: []
  type: TYPE_NORMAL
- en: list elements, 88–90
  prefs: []
  type: TYPE_NORMAL
- en: end of file (EOF), 238
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 73–78
  prefs: []
  type: TYPE_NORMAL
- en: envir argument
  prefs: []
  type: TYPE_NORMAL
- en: a node from binary search tree, 181
  prefs: []
  type: TYPE_NORMAL
- en: get() function, 159
  prefs: []
  type: TYPE_NORMAL
- en: density estimates, same graph, 264–266
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155
  prefs: []
  type: TYPE_NORMAL
- en: DES (discrete-event simulation),
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope, 151–159
  prefs: []
  type: TYPE_NORMAL
- en: writing, 164–171
  prefs: []
  type: TYPE_NORMAL
- en: functions have (almost) no side
  prefs: []
  type: TYPE_NORMAL
- en: det() linear algebra function, 197
  prefs: []
  type: TYPE_NORMAL
- en: effects, 156–157
  prefs: []
  type: TYPE_NORMAL
- en: dev.off() function, 3
  prefs: []
  type: TYPE_NORMAL
- en: function to display contents of call
  prefs: []
  type: TYPE_NORMAL
- en: df parameter, mapsound() function, 116
  prefs: []
  type: TYPE_NORMAL
- en: frame example, 157–159
  prefs: []
  type: TYPE_NORMAL
- en: dgbsendeditcmd() function, 257–258
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155–156
  prefs: []
  type: TYPE_NORMAL
- en: diag() linear algebra function, 197–198
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155
  prefs: []
  type: TYPE_NORMAL
- en: diff() function, 50–51
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  prefs: []
  type: TYPE_NORMAL
- en: dim argument, array() function, 134
  prefs: []
  type: TYPE_NORMAL
- en: EOF (end of file), 238
  prefs: []
  type: TYPE_NORMAL
- en: dim attribute, matrix class, 79
  prefs: []
  type: TYPE_NORMAL
- en: ess-tracebug package, 300
  prefs: []
  type: TYPE_NORMAL
- en: dimcode argument, apply() function, 70
  prefs: []
  type: TYPE_NORMAL
- en: event list, DES, 164
  prefs: []
  type: TYPE_NORMAL
- en: dimension reduction, avoiding, 80–81
  prefs: []
  type: TYPE_NORMAL
- en: event-oriented paradigm, 164
  prefs: []
  type: TYPE_NORMAL
- en: dim() function, 79
  prefs: []
  type: TYPE_NORMAL
- en: example() function, 21–22
  prefs: []
  type: TYPE_NORMAL
- en: dimnames argument, array() function, 134
  prefs: []
  type: TYPE_NORMAL
- en: exists() function, 230
  prefs: []
  type: TYPE_NORMAL
- en: dimnames() function, 131
  prefs: []
  type: TYPE_NORMAL
- en: expandut() function, 218
  prefs: []
  type: TYPE_NORMAL
- en: dir() function, 245
  prefs: []
  type: TYPE_NORMAL
- en: explicit functions, graphing, 276–277
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation (DES),
  prefs: []
  type: TYPE_NORMAL
- en: exp() math function, 189
  prefs: []
  type: TYPE_NORMAL
- en: writing, 164–171
  prefs: []
  type: TYPE_NORMAL
- en: extracting
  prefs: []
  type: TYPE_NORMAL
- en: discrete-valued time series, predicting,
  prefs: []
  type: TYPE_NORMAL
- en: subdata frames, 104–105
  prefs: []
  type: TYPE_NORMAL
- en: 37–39
  prefs: []
  type: TYPE_NORMAL
- en: subtables, 131–134
  prefs: []
  type: TYPE_NORMAL
- en: do.call() function, 133
  prefs: []
  type: TYPE_NORMAL
- en: dosim() function, 165
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: double brackets, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: drop argument, 68, 81
  prefs: []
  type: TYPE_NORMAL
- en: factorial() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: dtdbg debugging tool, use of string utili-
  prefs: []
  type: TYPE_NORMAL
- en: factors, 121
  prefs: []
  type: TYPE_NORMAL
- en: ties in, 257–259
  prefs: []
  type: TYPE_NORMAL
- en: functions, 123, 136
  prefs: []
  type: TYPE_NORMAL
- en: dual-core machines, 341
  prefs: []
  type: TYPE_NORMAL
- en: aggregate(), 136
  prefs: []
  type: TYPE_NORMAL
- en: duplicate() function, 315
  prefs: []
  type: TYPE_NORMAL
- en: by(), 126–127
  prefs: []
  type: TYPE_NORMAL
- en: dynamic task assignment, 348–350
  prefs: []
  type: TYPE_NORMAL
- en: cut(), 136–137
  prefs: []
  type: TYPE_NORMAL
- en: split(), 124–126
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  prefs: []
  type: TYPE_NORMAL
- en: tapply(), 123–124
  prefs: []
  type: TYPE_NORMAL
- en: levels and, 121–122
  prefs: []
  type: TYPE_NORMAL
- en: each argument, rep() function, 34
  prefs: []
  type: TYPE_NORMAL
- en: fangyan, 115
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 150, 186–187
  prefs: []
  type: TYPE_NORMAL
- en: fargs argument, apply() function, 70
  prefs: []
  type: TYPE_NORMAL
- en: edtdbg package, 300–302
  prefs: []
  type: TYPE_NORMAL
- en: f argument, apply() function, 70
  prefs: []
  type: TYPE_NORMAL
- en: eigen() function, 197, 201
  prefs: []
  type: TYPE_NORMAL
- en: Fedora, installing R on, 353–354
  prefs: []
  type: TYPE_NORMAL
- en: eigenvalues, 201
  prefs: []
  type: TYPE_NORMAL
- en: file.exists() function, 245
  prefs: []
  type: TYPE_NORMAL
- en: eigenvectors, 201
  prefs: []
  type: TYPE_NORMAL
- en: file.info() function, 245, 246
  prefs: []
  type: TYPE_NORMAL
- en: elements
  prefs: []
  type: TYPE_NORMAL
- en: filetype criterion, Google, 24
  prefs: []
  type: TYPE_NORMAL
- en: list, adding and deleting, 88–90
  prefs: []
  type: TYPE_NORMAL
- en: filter() function, 328
  prefs: []
  type: TYPE_NORMAL
- en: vectors
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 45–48
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting, 26
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  prefs: []
  type: TYPE_NORMAL
- en: naming, 56
  prefs: []
  type: TYPE_NORMAL
- en: generating filtering indices, 45–47
  prefs: []
  type: TYPE_NORMAL
- en: embarrassingly parallel applications
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 66–69
  prefs: []
  type: TYPE_NORMAL
- en: defined, 347–348
  prefs: []
  type: TYPE_NORMAL
- en: with subset() function, 47
  prefs: []
  type: TYPE_NORMAL
- en: turning general problems into, 350
  prefs: []
  type: TYPE_NORMAL
- en: with which() selection function, 47–48
  prefs: []
  type: TYPE_NORMAL
- en: '**362**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: findud() function, 50
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: findwords() function, 90–91
  prefs: []
  type: TYPE_NORMAL
- en: first-class objects, 149
  prefs: []
  type: TYPE_NORMAL
- en: GCC, 325
  prefs: []
  type: TYPE_NORMAL
- en: floor() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: GDB (GNU debugger), 288, 327
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  prefs: []
  type: TYPE_NORMAL
- en: general-purpose editors, 186
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in Monte
  prefs: []
  type: TYPE_NORMAL
- en: generating
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  prefs: []
  type: TYPE_NORMAL
- en: covariance matrices, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  prefs: []
  type: TYPE_NORMAL
- en: filtering indices, 45–47
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix example,
  prefs: []
  type: TYPE_NORMAL
- en: powers matrices, 312–313
  prefs: []
  type: TYPE_NORMAL
- en: 312–313
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, xxi
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup, 306–308
  prefs: []
  type: TYPE_NORMAL
- en: classes, 15
  prefs: []
  type: TYPE_NORMAL
- en: formal parameters
  prefs: []
  type: TYPE_NORMAL
- en: implementing on S4 classes, 225–226
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 116
  prefs: []
  type: TYPE_NORMAL
- en: getAnywhere() function, 211
  prefs: []
  type: TYPE_NORMAL
- en: oddcount() function, 9
  prefs: []
  type: TYPE_NORMAL
- en: get() function, 159
  prefs: []
  type: TYPE_NORMAL
- en: formals() function, 149, 151
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 142
  prefs: []
  type: TYPE_NORMAL
- en: forming filenames, 256–257
  prefs: []
  type: TYPE_NORMAL
- en: getnextevnt() function, 165
  prefs: []
  type: TYPE_NORMAL
- en: four-element vector, adding
  prefs: []
  type: TYPE_NORMAL
- en: getwd() function, 245
  prefs: []
  type: TYPE_NORMAL
- en: element to, 26
  prefs: []
  type: TYPE_NORMAL
- en: global variables, 9, 171–174
  prefs: []
  type: TYPE_NORMAL
- en: fromcol parameter, mapsound()
  prefs: []
  type: TYPE_NORMAL
- en: GNU debugger (GDB), 288, 327
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  prefs: []
  type: TYPE_NORMAL
- en: GNU S language, xix
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, xxi–xxii,
  prefs: []
  type: TYPE_NORMAL
- en: GPU programming, 171, 345
  prefs: []
  type: TYPE_NORMAL
- en: 314–316
  prefs: []
  type: TYPE_NORMAL
- en: GPUs (graphics processing units), 345
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  prefs: []
  type: TYPE_NORMAL
- en: gputools package, 345–346
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  prefs: []
  type: TYPE_NORMAL
- en: granularity, 348
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  prefs: []
  type: TYPE_NORMAL
- en: graphical user interfaces (GUIs), xx
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  prefs: []
  type: TYPE_NORMAL
- en: graphics processing units (GPUs), 345
  prefs: []
  type: TYPE_NORMAL
- en: functions, 7–10\. *See also* math functions;
  prefs: []
  type: TYPE_NORMAL
- en: graphs, 261–283
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions
  prefs: []
  type: TYPE_NORMAL
- en: customizing, 272–280
  prefs: []
  type: TYPE_NORMAL
- en: anonymous, 187–188
  prefs: []
  type: TYPE_NORMAL
- en: adding legends with legend()
  prefs: []
  type: TYPE_NORMAL
- en: applying to data frames, 112–120
  prefs: []
  type: TYPE_NORMAL
- en: function, 270
  prefs: []
  type: TYPE_NORMAL
- en: aids for learning Chinese dialects
  prefs: []
  type: TYPE_NORMAL
- en: adding lines with abline()
  prefs: []
  type: TYPE_NORMAL
- en: example, 115–120
  prefs: []
  type: TYPE_NORMAL
- en: function, 263–264
  prefs: []
  type: TYPE_NORMAL
- en: applying logistic regression
  prefs: []
  type: TYPE_NORMAL
- en: adding points with points()
  prefs: []
  type: TYPE_NORMAL
- en: models example, 113–115
  prefs: []
  type: TYPE_NORMAL
- en: function, 269–270
  prefs: []
  type: TYPE_NORMAL
- en: using lapply() and sapply()
  prefs: []
  type: TYPE_NORMAL
- en: adding polygons with polygon()
  prefs: []
  type: TYPE_NORMAL
- en: functions, 112–113
  prefs: []
  type: TYPE_NORMAL
- en: function, 275–276
  prefs: []
  type: TYPE_NORMAL
- en: applying to lists, 95–99
  prefs: []
  type: TYPE_NORMAL
- en: adding text with text() function,
  prefs: []
  type: TYPE_NORMAL
- en: abalone data example, 99
  prefs: []
  type: TYPE_NORMAL
- en: 270–271
  prefs: []
  type: TYPE_NORMAL
- en: lapply() and sapply() functions, 95
  prefs: []
  type: TYPE_NORMAL
- en: changing character sizes with cex
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 95–98
  prefs: []
  type: TYPE_NORMAL
- en: option, 272–273
  prefs: []
  type: TYPE_NORMAL
- en: applying to matrix rows and columns,
  prefs: []
  type: TYPE_NORMAL
- en: changing ranges of axes with xlim
  prefs: []
  type: TYPE_NORMAL
- en: 70–73
  prefs: []
  type: TYPE_NORMAL
- en: and ylim options, 273–275
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 70–72
  prefs: []
  type: TYPE_NORMAL
- en: graphing explicit functions,
  prefs: []
  type: TYPE_NORMAL
- en: finding outliers example, 72–73
  prefs: []
  type: TYPE_NORMAL
- en: 276–277
  prefs: []
  type: TYPE_NORMAL
- en: default arguments, 9–10
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve
  prefs: []
  type: TYPE_NORMAL
- en: listing in packages, 358
  prefs: []
  type: TYPE_NORMAL
- en: example, 277–280
  prefs: []
  type: TYPE_NORMAL
- en: as objects, 149–151
  prefs: []
  type: TYPE_NORMAL
- en: smoothing points with lowess()
  prefs: []
  type: TYPE_NORMAL
- en: replacement, 182–186
  prefs: []
  type: TYPE_NORMAL
- en: and loess() functions, 276
  prefs: []
  type: TYPE_NORMAL
- en: for statistical distributions, 193–194
  prefs: []
  type: TYPE_NORMAL
- en: pinpointing locations with locator()
  prefs: []
  type: TYPE_NORMAL
- en: transcendental, 40
  prefs: []
  type: TYPE_NORMAL
- en: function, 271–272
  prefs: []
  type: TYPE_NORMAL
- en: variable scope, 9
  prefs: []
  type: TYPE_NORMAL
- en: plot() function, 262
  prefs: []
  type: TYPE_NORMAL
- en: vector, 35–39, 311
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**363**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: graphs ( *continued*)
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 62–63
  prefs: []
  type: TYPE_NORMAL
- en: plots
  prefs: []
  type: TYPE_NORMAL
- en: vector, 31–32
  prefs: []
  type: TYPE_NORMAL
- en: restoring, 272
  prefs: []
  type: TYPE_NORMAL
- en: indices, filtering, 45–47
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional, 282–283
  prefs: []
  type: TYPE_NORMAL
- en: inheritance
  prefs: []
  type: TYPE_NORMAL
- en: polynomial regression example,
  prefs: []
  type: TYPE_NORMAL
- en: defined, 207
  prefs: []
  type: TYPE_NORMAL
- en: 266–269
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 214
  prefs: []
  type: TYPE_NORMAL
- en: saving to files, 280–281
  prefs: []
  type: TYPE_NORMAL
- en: initglbls() function, 165
  prefs: []
  type: TYPE_NORMAL
- en: starting new graph while keeping
  prefs: []
  type: TYPE_NORMAL
- en: input/output (I/O). *See* I/O
  prefs: []
  type: TYPE_NORMAL
- en: old, 264
  prefs: []
  type: TYPE_NORMAL
- en: installing packages. *See* packages
  prefs: []
  type: TYPE_NORMAL
- en: two density estimates on same graph
  prefs: []
  type: TYPE_NORMAL
- en: installing R, 353–354
  prefs: []
  type: TYPE_NORMAL
- en: example, 264–266
  prefs: []
  type: TYPE_NORMAL
- en: downloading base package from
  prefs: []
  type: TYPE_NORMAL
- en: grayscale images, 63
  prefs: []
  type: TYPE_NORMAL
- en: CRAN, 353
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr() function, 254
  prefs: []
  type: TYPE_NORMAL
- en: from Linux package manager,
  prefs: []
  type: TYPE_NORMAL
- en: grep() function, 109, 252
  prefs: []
  type: TYPE_NORMAL
- en: 353–354
  prefs: []
  type: TYPE_NORMAL
- en: GUIs (graphical user interfaces), xx
  prefs: []
  type: TYPE_NORMAL
- en: from source, 354
  prefs: []
  type: TYPE_NORMAL
- en: install_packages() function, 356
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  prefs: []
  type: TYPE_NORMAL
- en: integrated development environments
  prefs: []
  type: TYPE_NORMAL
- en: (IDEs), xx, 186
  prefs: []
  type: TYPE_NORMAL
- en: hard drive, loading packages from, 356
  prefs: []
  type: TYPE_NORMAL
- en: intensity, pixel, 63–64
  prefs: []
  type: TYPE_NORMAL
- en: help feature, 20–24
  prefs: []
  type: TYPE_NORMAL
- en: interactive mode, 2–3
  prefs: []
  type: TYPE_NORMAL
- en: additional topics, 23–24
  prefs: []
  type: TYPE_NORMAL
- en: interfacing R to other languages, 323–332
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 24
  prefs: []
  type: TYPE_NORMAL
- en: using R from Python, 330–332
  prefs: []
  type: TYPE_NORMAL
- en: example() function, 21–22
  prefs: []
  type: TYPE_NORMAL
- en: writing C/C++ functions to be called
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20–21
  prefs: []
  type: TYPE_NORMAL
- en: from R, 323–330
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 22–23
  prefs: []
  type: TYPE_NORMAL
- en: compiling and running code, 325
  prefs: []
  type: TYPE_NORMAL
- en: online, 24
  prefs: []
  type: TYPE_NORMAL
- en: debugging R/C code, 326–327
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20–21
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdiagonals from
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 22–23
  prefs: []
  type: TYPE_NORMAL
- en: square matrix example, 324–325
  prefs: []
  type: TYPE_NORMAL
- en: higher-dimensional arrays, 82–83
  prefs: []
  type: TYPE_NORMAL
- en: prediction of discrete-valued time
  prefs: []
  type: TYPE_NORMAL
- en: hist() function, 3, 13–14
  prefs: []
  type: TYPE_NORMAL
- en: series example, 327–330
  prefs: []
  type: TYPE_NORMAL
- en: hosts, 345
  prefs: []
  type: TYPE_NORMAL
- en: internal data sets, 5
  prefs: []
  type: TYPE_NORMAL
- en: Huang, Min-Yu, 324
  prefs: []
  type: TYPE_NORMAL
- en: internal storage, matrix, 59, 61
  prefs: []
  type: TYPE_NORMAL
- en: Internet, accessing, 246–250
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R example,
  prefs: []
  type: TYPE_NORMAL
- en: 248–250
  prefs: []
  type: TYPE_NORMAL
- en: identical() function, 55
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  prefs: []
  type: TYPE_NORMAL
- en: IDEs (integrated development environ-
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  prefs: []
  type: TYPE_NORMAL
- en: ments), xx, 186
  prefs: []
  type: TYPE_NORMAL
- en: Internet Protocol (IP) address, 247
  prefs: []
  type: TYPE_NORMAL
- en: ifelse() function, 48–49
  prefs: []
  type: TYPE_NORMAL
- en: intersect() set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two
  prefs: []
  type: TYPE_NORMAL
- en: intextract() function, 243
  prefs: []
  type: TYPE_NORMAL
- en: variables example, 49–51
  prefs: []
  type: TYPE_NORMAL
- en: I/O (input/output), 231–250
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 143–144
  prefs: []
  type: TYPE_NORMAL
- en: accessing Internet, 246–250
  prefs: []
  type: TYPE_NORMAL
- en: recoding abalone data set example,
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R example,
  prefs: []
  type: TYPE_NORMAL
- en: 51–54
  prefs: []
  type: TYPE_NORMAL
- en: 248–250
  prefs: []
  type: TYPE_NORMAL
- en: if statements, nested, 141–142
  prefs: []
  type: TYPE_NORMAL
- en: sockets in R, 247–248
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation, 63–66
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  prefs: []
  type: TYPE_NORMAL
- en: images component, mapsound()
  prefs: []
  type: TYPE_NORMAL
- en: accessing keyboard and monitor,
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  prefs: []
  type: TYPE_NORMAL
- en: 232–235
  prefs: []
  type: TYPE_NORMAL
- en: immutable objects, 314
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  prefs: []
  type: TYPE_NORMAL
- en: indexing
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  prefs: []
  type: TYPE_NORMAL
- en: list, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  prefs: []
  type: TYPE_NORMAL
- en: '**364**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: reading files, 235
  prefs: []
  type: TYPE_NORMAL
- en: lines() function, 264
  prefs: []
  type: TYPE_NORMAL
- en: accessing files on remote
  prefs: []
  type: TYPE_NORMAL
- en: Linux package manager, installing R
  prefs: []
  type: TYPE_NORMAL
- en: machines via URLs, 243
  prefs: []
  type: TYPE_NORMAL
- en: from, 353–354
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  prefs: []
  type: TYPE_NORMAL
- en: lists, 12–14, 85–100
  prefs: []
  type: TYPE_NORMAL
- en: reading data frame or matrix from
  prefs: []
  type: TYPE_NORMAL
- en: accessing components and values,
  prefs: []
  type: TYPE_NORMAL
- en: files, 236
  prefs: []
  type: TYPE_NORMAL
- en: 93–95
  prefs: []
  type: TYPE_NORMAL
- en: reading PUMS census files
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to, 95–99
  prefs: []
  type: TYPE_NORMAL
- en: example, 239–243
  prefs: []
  type: TYPE_NORMAL
- en: abalone data example, 99
  prefs: []
  type: TYPE_NORMAL
- en: reading text files, 237
  prefs: []
  type: TYPE_NORMAL
- en: lapply() and sapply() functions, 95
  prefs: []
  type: TYPE_NORMAL
- en: writing files
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 95–98
  prefs: []
  type: TYPE_NORMAL
- en: getting files and directory
  prefs: []
  type: TYPE_NORMAL
- en: general operations, 87–93
  prefs: []
  type: TYPE_NORMAL
- en: information, 245
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting list elements,
  prefs: []
  type: TYPE_NORMAL
- en: sum contents of many files
  prefs: []
  type: TYPE_NORMAL
- en: 88–90
  prefs: []
  type: TYPE_NORMAL
- en: example, 245–246
  prefs: []
  type: TYPE_NORMAL
- en: getting size of list, 90
  prefs: []
  type: TYPE_NORMAL
- en: writing to files, 243–245
  prefs: []
  type: TYPE_NORMAL
- en: list indexing, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: IP (Internet Protocol) address, 247
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 90–93
  prefs: []
  type: TYPE_NORMAL
- en: recursive lists, 99–100
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  prefs: []
  type: TYPE_NORMAL
- en: lm()function, 15, 208–210
  prefs: []
  type: TYPE_NORMAL
- en: load balance, 349–350
  prefs: []
  type: TYPE_NORMAL
- en: join operation, 109
  prefs: []
  type: TYPE_NORMAL
- en: locator() function
  prefs: []
  type: TYPE_NORMAL
- en: determining relevant rows and col-
  prefs: []
  type: TYPE_NORMAL
- en: '**K**'
  prefs: []
  type: TYPE_NORMAL
- en: umns, 64–65
  prefs: []
  type: TYPE_NORMAL
- en: pinpointing locations with, 271–272
  prefs: []
  type: TYPE_NORMAL
- en: keyboard, accessing, 232–235
  prefs: []
  type: TYPE_NORMAL
- en: loess() function, 276
  prefs: []
  type: TYPE_NORMAL
- en: printing to screen, 234–235
  prefs: []
  type: TYPE_NORMAL
- en: log10() math function, 189
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  prefs: []
  type: TYPE_NORMAL
- en: logical operations, 30–31
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  prefs: []
  type: TYPE_NORMAL
- en: logistic regression models, applying,
  prefs: []
  type: TYPE_NORMAL
- en: KMC (k-means clustering), 338–340
  prefs: []
  type: TYPE_NORMAL
- en: 113–115
  prefs: []
  type: TYPE_NORMAL
- en: log() math function, 189
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: long-run state distribution, Markov
  prefs: []
  type: TYPE_NORMAL
- en: modeling, 200
  prefs: []
  type: TYPE_NORMAL
- en: lag operations, vector, 50–51
  prefs: []
  type: TYPE_NORMAL
- en: loops, control statements, 140–142
  prefs: []
  type: TYPE_NORMAL
- en: lapply() function
  prefs: []
  type: TYPE_NORMAL
- en: lowess() function, 276
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to lists, 95
  prefs: []
  type: TYPE_NORMAL
- en: ls() function
  prefs: []
  type: TYPE_NORMAL
- en: lists, 50
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope, 155–156
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 142
  prefs: []
  type: TYPE_NORMAL
- en: listing objects with, 226–227
  prefs: []
  type: TYPE_NORMAL
- en: using on data frames, 112–113
  prefs: []
  type: TYPE_NORMAL
- en: latency, 346
  prefs: []
  type: TYPE_NORMAL
- en: lazy evaluation principle, 52, 147
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: leaving-one-out method, 219, 222
  prefs: []
  type: TYPE_NORMAL
- en: magnifying portions of curve, 277–280
  prefs: []
  type: TYPE_NORMAL
- en: legend() function, 270
  prefs: []
  type: TYPE_NORMAL
- en: makerow() function, 241–242
  prefs: []
  type: TYPE_NORMAL
- en: length() function
  prefs: []
  type: TYPE_NORMAL
- en: managers, snow package, 335
  prefs: []
  type: TYPE_NORMAL
- en: obtaining length of vector, 27
  prefs: []
  type: TYPE_NORMAL
- en: managing objects, 226–230
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 32
  prefs: []
  type: TYPE_NORMAL
- en: determining object structure,
  prefs: []
  type: TYPE_NORMAL
- en: levels, factors and, 121–122
  prefs: []
  type: TYPE_NORMAL
- en: 228–230
  prefs: []
  type: TYPE_NORMAL
- en: .libPaths() function, 356–357
  prefs: []
  type: TYPE_NORMAL
- en: exists() function, 230
  prefs: []
  type: TYPE_NORMAL
- en: library functions, 165
  prefs: []
  type: TYPE_NORMAL
- en: listing objects with ls() function,
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, on vectors
  prefs: []
  type: TYPE_NORMAL
- en: 226–227
  prefs: []
  type: TYPE_NORMAL
- en: and matrices, 61, 196–201
  prefs: []
  type: TYPE_NORMAL
- en: removing specific objects with rm()
  prefs: []
  type: TYPE_NORMAL
- en: finding stationary distributions of
  prefs: []
  type: TYPE_NORMAL
- en: function, 227–228
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains example, 199–201
  prefs: []
  type: TYPE_NORMAL
- en: saving collection of objects with
  prefs: []
  type: TYPE_NORMAL
- en: vector cross product example, 198–199
  prefs: []
  type: TYPE_NORMAL
- en: save() function, 228
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**365**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: mapsound() function, 115–116
  prefs: []
  type: TYPE_NORMAL
- en: memory
  prefs: []
  type: TYPE_NORMAL
- en: marginal values, variable, 131
  prefs: []
  type: TYPE_NORMAL
- en: chunking, 320–321
  prefs: []
  type: TYPE_NORMAL
- en: m argument, apply() function, 70
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, 314–316
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains, 199–201
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  prefs: []
  type: TYPE_NORMAL
- en: MASS package, 23, 356
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  prefs: []
  type: TYPE_NORMAL
- en: math functions, 189–193
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  prefs: []
  type: TYPE_NORMAL
- en: calculating probability example,
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  prefs: []
  type: TYPE_NORMAL
- en: 190–191
  prefs: []
  type: TYPE_NORMAL
- en: using R packages for memory
  prefs: []
  type: TYPE_NORMAL
- en: calculus, 192–193
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  prefs: []
  type: TYPE_NORMAL
- en: cumulative sums and products, 191
  prefs: []
  type: TYPE_NORMAL
- en: merge() function, 109–110
  prefs: []
  type: TYPE_NORMAL
- en: minima and maxima, 191–192
  prefs: []
  type: TYPE_NORMAL
- en: merge sort method, numerical
  prefs: []
  type: TYPE_NORMAL
- en: matrices, 11–12, 59–83
  prefs: []
  type: TYPE_NORMAL
- en: sorting, 347
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting rows and col-
  prefs: []
  type: TYPE_NORMAL
- en: merging data frames, 109–112
  prefs: []
  type: TYPE_NORMAL
- en: umns, 73–78
  prefs: []
  type: TYPE_NORMAL
- en: employee database example,
  prefs: []
  type: TYPE_NORMAL
- en: finding closest pair of vertices in
  prefs: []
  type: TYPE_NORMAL
- en: 111–112
  prefs: []
  type: TYPE_NORMAL
- en: graph example, 75–78
  prefs: []
  type: TYPE_NORMAL
- en: metacharacters, 254
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrix, 73–75
  prefs: []
  type: TYPE_NORMAL
- en: methods() function, 210
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to rows and col-
  prefs: []
  type: TYPE_NORMAL
- en: microdata, 239
  prefs: []
  type: TYPE_NORMAL
- en: umns, 70–73
  prefs: []
  type: TYPE_NORMAL
- en: minima function, 191–192
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 70–72
  prefs: []
  type: TYPE_NORMAL
- en: min() math function, 190, 191
  prefs: []
  type: TYPE_NORMAL
- en: finding outliers example, 72–73
  prefs: []
  type: TYPE_NORMAL
- en: M/M/1 queue, 165, 168
  prefs: []
  type: TYPE_NORMAL
- en: avoiding unintended dimension
  prefs: []
  type: TYPE_NORMAL
- en: modes
  prefs: []
  type: TYPE_NORMAL
- en: reduction, 80–81
  prefs: []
  type: TYPE_NORMAL
- en: batch, 1, 3, 24
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations on, 196–201
  prefs: []
  type: TYPE_NORMAL
- en: defined, 26
  prefs: []
  type: TYPE_NORMAL
- en: naming rows and columns, 81–82
  prefs: []
  type: TYPE_NORMAL
- en: interactive, 2–3
  prefs: []
  type: TYPE_NORMAL
- en: operations, 61–70
  prefs: []
  type: TYPE_NORMAL
- en: modulo operator, 44
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 66–69
  prefs: []
  type: TYPE_NORMAL
- en: monitor, accessing, 232–235
  prefs: []
  type: TYPE_NORMAL
- en: generating covariance matrix
  prefs: []
  type: TYPE_NORMAL
- en: using print() function, 234–235
  prefs: []
  type: TYPE_NORMAL
- en: example, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: using readline() function, 234
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation example,
  prefs: []
  type: TYPE_NORMAL
- en: using scan() function, 232–234
  prefs: []
  type: TYPE_NORMAL
- en: 63–66
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo simulation, achieving bet-
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, 61
  prefs: []
  type: TYPE_NORMAL
- en: ter speed in, 308–311
  prefs: []
  type: TYPE_NORMAL
- en: matrix indexing, 62–63
  prefs: []
  type: TYPE_NORMAL
- en: multicore machines, 340–341
  prefs: []
  type: TYPE_NORMAL
- en: reading from files, 236
  prefs: []
  type: TYPE_NORMAL
- en: mutlinks() function, 336
  prefs: []
  type: TYPE_NORMAL
- en: vector/matrix distinction, 78–79
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 333–334, 341–342
  prefs: []
  type: TYPE_NORMAL
- en: as vectors, 28
  prefs: []
  type: TYPE_NORMAL
- en: mvrnorm() function, MASS package, 23, 356
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like operations, 130–131
  prefs: []
  type: TYPE_NORMAL
- en: matrix class, 79
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  prefs: []
  type: TYPE_NORMAL
- en: matrix() function, 60
  prefs: []
  type: TYPE_NORMAL
- en: matrix-inverse update method, 222
  prefs: []
  type: TYPE_NORMAL
- en: named arguments, 146–147
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 104–109
  prefs: []
  type: TYPE_NORMAL
- en: names() function, 56
  prefs: []
  type: TYPE_NORMAL
- en: apply() function, 107
  prefs: []
  type: TYPE_NORMAL
- en: naming
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdata frames, 104–105
  prefs: []
  type: TYPE_NORMAL
- en: matrix rows and columns, 81–82
  prefs: []
  type: TYPE_NORMAL
- en: NA values, 105–106
  prefs: []
  type: TYPE_NORMAL
- en: vector elements, 56
  prefs: []
  type: TYPE_NORMAL
- en: rbind() and cbind() functions,
  prefs: []
  type: TYPE_NORMAL
- en: NA values
  prefs: []
  type: TYPE_NORMAL
- en: 106–107
  prefs: []
  type: TYPE_NORMAL
- en: matrix-like operations, 105–106
  prefs: []
  type: TYPE_NORMAL
- en: salary study example, 108–109
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 43
  prefs: []
  type: TYPE_NORMAL
- en: matrix-multiplication operator, 12
  prefs: []
  type: TYPE_NORMAL
- en: n browser command, 289
  prefs: []
  type: TYPE_NORMAL
- en: maxima function, 191–192
  prefs: []
  type: TYPE_NORMAL
- en: nchar() function, 252
  prefs: []
  type: TYPE_NORMAL
- en: max() math function, 190, 192
  prefs: []
  type: TYPE_NORMAL
- en: ncol() function, 79
  prefs: []
  type: TYPE_NORMAL
- en: mean() function, 38
  prefs: []
  type: TYPE_NORMAL
- en: '**366**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: negative subscripts, 32, 63
  prefs: []
  type: TYPE_NORMAL
- en: matrix, 61–70
  prefs: []
  type: TYPE_NORMAL
- en: network, defined, 247
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 66–69
  prefs: []
  type: TYPE_NORMAL
- en: Newton-Raphson method, 192
  prefs: []
  type: TYPE_NORMAL
- en: generating covariance matrix
  prefs: []
  type: TYPE_NORMAL
- en: next statement, 141
  prefs: []
  type: TYPE_NORMAL
- en: example, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: Nile data set, 5
  prefs: []
  type: TYPE_NORMAL
- en: image manipulation example,
  prefs: []
  type: TYPE_NORMAL
- en: noise, adding to image, 65–66
  prefs: []
  type: TYPE_NORMAL
- en: 63–66
  prefs: []
  type: TYPE_NORMAL
- en: nominal variables, 121
  prefs: []
  type: TYPE_NORMAL
- en: indexing, 62–63
  prefs: []
  type: TYPE_NORMAL
- en: nonlocals
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations, 61
  prefs: []
  type: TYPE_NORMAL
- en: writing to with superassignment
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like, 130–131
  prefs: []
  type: TYPE_NORMAL
- en: operator, 161–162
  prefs: []
  type: TYPE_NORMAL
- en: vector, 30–34
  prefs: []
  type: TYPE_NORMAL
- en: writing with assign() function, 163
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and logical operations,
  prefs: []
  type: TYPE_NORMAL
- en: nonvector sets, looping control state-
  prefs: []
  type: TYPE_NORMAL
- en: 30–31
  prefs: []
  type: TYPE_NORMAL
- en: ments over, 143
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  prefs: []
  type: TYPE_NORMAL
- en: nonvisible functions, 211
  prefs: []
  type: TYPE_NORMAL
- en: generating vector sequences with
  prefs: []
  type: TYPE_NORMAL
- en: nreps values, 205
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 33–34
  prefs: []
  type: TYPE_NORMAL
- en: nrow() function, 79
  prefs: []
  type: TYPE_NORMAL
- en: repeating vector constants with
  prefs: []
  type: TYPE_NORMAL
- en: NULL values, 44
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, 34
  prefs: []
  type: TYPE_NORMAL
- en: vector in, matrix out, 42–43
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: vector in, vector out, 40–42
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 31–32
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented programming. *See* OOP
  prefs: []
  type: TYPE_NORMAL
- en: operator precedence, 33
  prefs: []
  type: TYPE_NORMAL
- en: objects. *See also* managing objects
  prefs: []
  type: TYPE_NORMAL
- en: order() function, 97, 194–195
  prefs: []
  type: TYPE_NORMAL
- en: first-class, 149
  prefs: []
  type: TYPE_NORMAL
- en: outliers, 49
  prefs: []
  type: TYPE_NORMAL
- en: immutable, 314
  prefs: []
  type: TYPE_NORMAL
- en: oddcount() function, 7, 140
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: omp barrier pragma, OpenMP, 344
  prefs: []
  type: TYPE_NORMAL
- en: omp critical pragma, OpenMP, 344
  prefs: []
  type: TYPE_NORMAL
- en: packages, 355–358
  prefs: []
  type: TYPE_NORMAL
- en: omp single pragma, OpenMP, 344–345
  prefs: []
  type: TYPE_NORMAL
- en: installing
  prefs: []
  type: TYPE_NORMAL
- en: OOP (object-oriented programming),
  prefs: []
  type: TYPE_NORMAL
- en: automatically, 356–357
  prefs: []
  type: TYPE_NORMAL
- en: xxi, 207–230
  prefs: []
  type: TYPE_NORMAL
- en: manually, 357–358
  prefs: []
  type: TYPE_NORMAL
- en: managing objects. *See* managing
  prefs: []
  type: TYPE_NORMAL
- en: listing functions in, 358
  prefs: []
  type: TYPE_NORMAL
- en: objects
  prefs: []
  type: TYPE_NORMAL
- en: loading from hard drive, 356
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes. *See* S3 classes
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 333–351
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 222–226
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 351
  prefs: []
  type: TYPE_NORMAL
- en: implementing generic function
  prefs: []
  type: TYPE_NORMAL
- en: embarrassingly parallel applica-
  prefs: []
  type: TYPE_NORMAL
- en: on, 225–226
  prefs: []
  type: TYPE_NORMAL
- en: tions, 347–348
  prefs: []
  type: TYPE_NORMAL
- en: vs. S3 classes, 226
  prefs: []
  type: TYPE_NORMAL
- en: turning general problems into, 350
  prefs: []
  type: TYPE_NORMAL
- en: writing, 223–225
  prefs: []
  type: TYPE_NORMAL
- en: implementing, 248–250
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP, 344–345
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 333–334
  prefs: []
  type: TYPE_NORMAL
- en: code analysis, 343
  prefs: []
  type: TYPE_NORMAL
- en: resorting to C, 340–345
  prefs: []
  type: TYPE_NORMAL
- en: omp barrier pragma, 344
  prefs: []
  type: TYPE_NORMAL
- en: GPU programming, 345
  prefs: []
  type: TYPE_NORMAL
- en: omp critical pragma, 344
  prefs: []
  type: TYPE_NORMAL
- en: multicore machines, 340–341
  prefs: []
  type: TYPE_NORMAL
- en: omp single pragma, 344–345
  prefs: []
  type: TYPE_NORMAL
- en: mutual outlinks, 341–342
  prefs: []
  type: TYPE_NORMAL
- en: operations
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP code analysis, 343
  prefs: []
  type: TYPE_NORMAL
- en: list, 87–93
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP pragmas, 344–345
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting list elements,
  prefs: []
  type: TYPE_NORMAL
- en: running OpenMP code, 342
  prefs: []
  type: TYPE_NORMAL
- en: 88–90
  prefs: []
  type: TYPE_NORMAL
- en: snow package, 334–340
  prefs: []
  type: TYPE_NORMAL
- en: getting size of list, 90
  prefs: []
  type: TYPE_NORMAL
- en: analyzing snow code, 336–337
  prefs: []
  type: TYPE_NORMAL
- en: list indexing, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering (KMC), 338–340
  prefs: []
  type: TYPE_NORMAL
- en: text concordance example, 90–93
  prefs: []
  type: TYPE_NORMAL
- en: running snow code, 335–336
  prefs: []
  type: TYPE_NORMAL
- en: speedup, 337–338
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**367**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: snow package ( *continued*)
  prefs: []
  type: TYPE_NORMAL
- en: polynomial regression, 219–222, 266–269
  prefs: []
  type: TYPE_NORMAL
- en: sources of overhead, 346–347
  prefs: []
  type: TYPE_NORMAL
- en: port number, 247
  prefs: []
  type: TYPE_NORMAL
- en: networked systems of computers,
  prefs: []
  type: TYPE_NORMAL
- en: powers matrix, generating, 312–313
  prefs: []
  type: TYPE_NORMAL
- en: 346–347
  prefs: []
  type: TYPE_NORMAL
- en: pragmas, OpenMP, 343–345
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory machines, 346
  prefs: []
  type: TYPE_NORMAL
- en: preda() function, 38
  prefs: []
  type: TYPE_NORMAL
- en: static vs. dynamic task assignment,
  prefs: []
  type: TYPE_NORMAL
- en: principle of confirmation, debugging,
  prefs: []
  type: TYPE_NORMAL
- en: 348–350
  prefs: []
  type: TYPE_NORMAL
- en: 285–286
  prefs: []
  type: TYPE_NORMAL
- en: parent.frame() function, 156
  prefs: []
  type: TYPE_NORMAL
- en: print() function, 18, 234–235
  prefs: []
  type: TYPE_NORMAL
- en: paste() function, 252–253, 257, 269
  prefs: []
  type: TYPE_NORMAL
- en: print.ut() function, 218
  prefs: []
  type: TYPE_NORMAL
- en: PDF devices, saving displayed
  prefs: []
  type: TYPE_NORMAL
- en: prntrslts() function, 165
  prefs: []
  type: TYPE_NORMAL
- en: graphs, 281
  prefs: []
  type: TYPE_NORMAL
- en: probability, calculating, 190–191
  prefs: []
  type: TYPE_NORMAL
- en: pdf() function, 3
  prefs: []
  type: TYPE_NORMAL
- en: probability mass function (pmf), 193
  prefs: []
  type: TYPE_NORMAL
- en: Pearson product-moment
  prefs: []
  type: TYPE_NORMAL
- en: procpairs() function, 343
  prefs: []
  type: TYPE_NORMAL
- en: correlation, 49
  prefs: []
  type: TYPE_NORMAL
- en: prod() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: performance enhancement, 305–321
  prefs: []
  type: TYPE_NORMAL
- en: programming structures. *See* R program-
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  prefs: []
  type: TYPE_NORMAL
- en: ming structures
  prefs: []
  type: TYPE_NORMAL
- en: chunking, 320–321
  prefs: []
  type: TYPE_NORMAL
- en: Public Use Microdata Samples (PUMS)
  prefs: []
  type: TYPE_NORMAL
- en: functional programming, 314–316
  prefs: []
  type: TYPE_NORMAL
- en: census files, reading, 239
  prefs: []
  type: TYPE_NORMAL
- en: avoiding memory copy example,
  prefs: []
  type: TYPE_NORMAL
- en: Python, using R from, 330–332
  prefs: []
  type: TYPE_NORMAL
- en: 315–316
  prefs: []
  type: TYPE_NORMAL
- en: copy-on-change issues, 314–315
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**'
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  prefs: []
  type: TYPE_NORMAL
- en: Q browser command, 289
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in a Monte
  prefs: []
  type: TYPE_NORMAL
- en: qr() linear algebra function, 197
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation, 176–177
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix exam-
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: ple, 312–313
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup, 306–308
  prefs: []
  type: TYPE_NORMAL
- en: race condition, 343
  prefs: []
  type: TYPE_NORMAL
- en: using R packages for memory
  prefs: []
  type: TYPE_NORMAL
- en: random variate generators, 204–205
  prefs: []
  type: TYPE_NORMAL
- en: rank()
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  prefs: []
  type: TYPE_NORMAL
- en: function, 195–196
  prefs: []
  type: TYPE_NORMAL
- en: rbind()
  prefs: []
  type: TYPE_NORMAL
- en: using Rprof() function to find slow
  prefs: []
  type: TYPE_NORMAL
- en: function, 12, 106–107
  prefs: []
  type: TYPE_NORMAL
- en: spots in code, 316–319
  prefs: []
  type: TYPE_NORMAL
- en: ordering events, 171
  prefs: []
  type: TYPE_NORMAL
- en: writing fast R code, 306
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrices, 74–75
  prefs: []
  type: TYPE_NORMAL
- en: rbinom()
  prefs: []
  type: TYPE_NORMAL
- en: Perron-Frobenius theorem, 201
  prefs: []
  type: TYPE_NORMAL
- en: function, 204
  prefs: []
  type: TYPE_NORMAL
- en: persp() function, 22, 282
  prefs: []
  type: TYPE_NORMAL
- en: R console, 2
  prefs: []
  type: TYPE_NORMAL
- en: pixel intensity, 63–64
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rdata* file, 20'
  prefs: []
  type: TYPE_NORMAL
- en: plot()
  prefs: []
  type: TYPE_NORMAL
- en: Rdsm
  prefs: []
  type: TYPE_NORMAL
- en: function, xxi, 16, 262
  prefs: []
  type: TYPE_NORMAL
- en: package, implementing
  prefs: []
  type: TYPE_NORMAL
- en: plots
  prefs: []
  type: TYPE_NORMAL
- en: parallel R, 249
  prefs: []
  type: TYPE_NORMAL
- en: reactevnt()
  prefs: []
  type: TYPE_NORMAL
- en: restoring, 272
  prefs: []
  type: TYPE_NORMAL
- en: function, 165
  prefs: []
  type: TYPE_NORMAL
- en: readBin()
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional, 282–283
  prefs: []
  type: TYPE_NORMAL
- en: function, 248
  prefs: []
  type: TYPE_NORMAL
- en: plyr
  prefs: []
  type: TYPE_NORMAL
- en: read.csv()
  prefs: []
  type: TYPE_NORMAL
- en: package, 136
  prefs: []
  type: TYPE_NORMAL
- en: function, 108
  prefs: []
  type: TYPE_NORMAL
- en: pmax() math function, 190, 192
  prefs: []
  type: TYPE_NORMAL
- en: reading files, 235
  prefs: []
  type: TYPE_NORMAL
- en: pmf (probability mass function), 193
  prefs: []
  type: TYPE_NORMAL
- en: accessing files on remote machines
  prefs: []
  type: TYPE_NORMAL
- en: pmin() math function, 190, 191
  prefs: []
  type: TYPE_NORMAL
- en: via URLs, 243
  prefs: []
  type: TYPE_NORMAL
- en: pointers, 159–161
  prefs: []
  type: TYPE_NORMAL
- en: connections, 237–238
  prefs: []
  type: TYPE_NORMAL
- en: points() function, 269–270
  prefs: []
  type: TYPE_NORMAL
- en: reading data frames or matrices from
  prefs: []
  type: TYPE_NORMAL
- en: polygon() function, 275–276
  prefs: []
  type: TYPE_NORMAL
- en: files, 236
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism
  prefs: []
  type: TYPE_NORMAL
- en: reading PUMS census files example,
  prefs: []
  type: TYPE_NORMAL
- en: defined, xxi, 207
  prefs: []
  type: TYPE_NORMAL
- en: 239–243
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, 208
  prefs: []
  type: TYPE_NORMAL
- en: reading text files, 237
  prefs: []
  type: TYPE_NORMAL
- en: '**368**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: readline() function, 234
  prefs: []
  type: TYPE_NORMAL
- en: R programming structures, 139
  prefs: []
  type: TYPE_NORMAL
- en: readLines() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: anonymous functions, 187–188
  prefs: []
  type: TYPE_NORMAL
- en: reassigning matrices, 73–74
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and Boolean operators
  prefs: []
  type: TYPE_NORMAL
- en: recursion, 176–182
  prefs: []
  type: TYPE_NORMAL
- en: and values, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree example, 177–182
  prefs: []
  type: TYPE_NORMAL
- en: control statements, 139–144
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation, 176–177
  prefs: []
  type: TYPE_NORMAL
- en: if-else function, 143–144
  prefs: []
  type: TYPE_NORMAL
- en: recursive argument, concatenate
  prefs: []
  type: TYPE_NORMAL
- en: looping over nonvector sets, 143
  prefs: []
  type: TYPE_NORMAL
- en: function, 100
  prefs: []
  type: TYPE_NORMAL
- en: loops, 140–142
  prefs: []
  type: TYPE_NORMAL
- en: recursive vectors, 86
  prefs: []
  type: TYPE_NORMAL
- en: default values for arguments, 146–147
  prefs: []
  type: TYPE_NORMAL
- en: recycling
  prefs: []
  type: TYPE_NORMAL
- en: environment and scope issues,
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  prefs: []
  type: TYPE_NORMAL
- en: 151–159
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 29–30
  prefs: []
  type: TYPE_NORMAL
- en: function to display contents of call
  prefs: []
  type: TYPE_NORMAL
- en: reference classes, 160
  prefs: []
  type: TYPE_NORMAL
- en: frame example, 157–159
  prefs: []
  type: TYPE_NORMAL
- en: regexpr() function, 253–254
  prefs: []
  type: TYPE_NORMAL
- en: ls() function, 155–156
  prefs: []
  type: TYPE_NORMAL
- en: regression analysis of exam grades,
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155
  prefs: []
  type: TYPE_NORMAL
- en: 16–19, 103–104
  prefs: []
  type: TYPE_NORMAL
- en: side effects, 156–157
  prefs: []
  type: TYPE_NORMAL
- en: regular expressions, character string
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  prefs: []
  type: TYPE_NORMAL
- en: manipulation, 254–257
  prefs: []
  type: TYPE_NORMAL
- en: functions as objects, 149–151
  prefs: []
  type: TYPE_NORMAL
- en: remote machines, accessing files
  prefs: []
  type: TYPE_NORMAL
- en: pointers, lack of, 159–161
  prefs: []
  type: TYPE_NORMAL
- en: on, 243
  prefs: []
  type: TYPE_NORMAL
- en: recursion, 176–182
  prefs: []
  type: TYPE_NORMAL
- en: repeat loop, 241–242
  prefs: []
  type: TYPE_NORMAL
- en: binary search tree example,
  prefs: []
  type: TYPE_NORMAL
- en: repeat statement, 141
  prefs: []
  type: TYPE_NORMAL
- en: 177–182
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, repeating vector con-
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort implementation,
  prefs: []
  type: TYPE_NORMAL
- en: stants with, 34
  prefs: []
  type: TYPE_NORMAL
- en: 176–177
  prefs: []
  type: TYPE_NORMAL
- en: replacement functions, 182–186
  prefs: []
  type: TYPE_NORMAL
- en: replacement functions, 182–186
  prefs: []
  type: TYPE_NORMAL
- en: defined, 183–184
  prefs: []
  type: TYPE_NORMAL
- en: return values, 147–149
  prefs: []
  type: TYPE_NORMAL
- en: self-bookkeeping vector class
  prefs: []
  type: TYPE_NORMAL
- en: deciding whether to explicitly call
  prefs: []
  type: TYPE_NORMAL
- en: example, 184–186
  prefs: []
  type: TYPE_NORMAL
- en: return() function, 148
  prefs: []
  type: TYPE_NORMAL
- en: reshape package, 136
  prefs: []
  type: TYPE_NORMAL
- en: returning complex objects,
  prefs: []
  type: TYPE_NORMAL
- en: resizing matrices, 73–75
  prefs: []
  type: TYPE_NORMAL
- en: 148–149
  prefs: []
  type: TYPE_NORMAL
- en: return statement, 8
  prefs: []
  type: TYPE_NORMAL
- en: tools for composing function code,
  prefs: []
  type: TYPE_NORMAL
- en: return values, 147–149
  prefs: []
  type: TYPE_NORMAL
- en: 186–187
  prefs: []
  type: TYPE_NORMAL
- en: deciding whether to explicitly call
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 186–187
  prefs: []
  type: TYPE_NORMAL
- en: return() function, 148
  prefs: []
  type: TYPE_NORMAL
- en: text editors and IDEs, 186
  prefs: []
  type: TYPE_NORMAL
- en: returning complex objects, 148–149
  prefs: []
  type: TYPE_NORMAL
- en: writing, 161–175
  prefs: []
  type: TYPE_NORMAL
- en: REvolution Analytics, 300
  prefs: []
  type: TYPE_NORMAL
- en: binary operations, 187
  prefs: []
  type: TYPE_NORMAL
- en: rexp() function, 204
  prefs: []
  type: TYPE_NORMAL
- en: closures, 174–175
  prefs: []
  type: TYPE_NORMAL
- en: Rf_PrintValue(s) function, 304
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation (DES) in
  prefs: []
  type: TYPE_NORMAL
- en: rgamma() function, 204
  prefs: []
  type: TYPE_NORMAL
- en: R example, 164–171
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rhistory* file, 20'
  prefs: []
  type: TYPE_NORMAL
- en: when to use global variables,
  prefs: []
  type: TYPE_NORMAL
- en: rm() function, 227–228
  prefs: []
  type: TYPE_NORMAL
- en: 171–174
  prefs: []
  type: TYPE_NORMAL
- en: rnorm() function, 3, 204
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with assign()
  prefs: []
  type: TYPE_NORMAL
- en: round() function, 40–41, 190
  prefs: []
  type: TYPE_NORMAL
- en: function, 163
  prefs: []
  type: TYPE_NORMAL
- en: routers, 247
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with the super-
  prefs: []
  type: TYPE_NORMAL
- en: row() function, 69–70
  prefs: []
  type: TYPE_NORMAL
- en: assignment operator, 161–162
  prefs: []
  type: TYPE_NORMAL
- en: rownames() function, 82
  prefs: []
  type: TYPE_NORMAL
- en: RPy module
  prefs: []
  type: TYPE_NORMAL
- en: R packages, for memory
  prefs: []
  type: TYPE_NORMAL
- en: installing, 330
  prefs: []
  type: TYPE_NORMAL
- en: management, 321
  prefs: []
  type: TYPE_NORMAL
- en: syntax, 330–332
  prefs: []
  type: TYPE_NORMAL
- en: rpois() function, 204
  prefs: []
  type: TYPE_NORMAL
- en: runif() function, 204
  prefs: []
  type: TYPE_NORMAL
- en: Rprof() function, 316–319
  prefs: []
  type: TYPE_NORMAL
- en: running
  prefs: []
  type: TYPE_NORMAL
- en: '*.Rprofile* file, 19'
  prefs: []
  type: TYPE_NORMAL
- en: GDB on R, 303–304
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP code, 342
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**369**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: running ( *continued*)
  prefs: []
  type: TYPE_NORMAL
- en: setdiff() set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: R, 1–2
  prefs: []
  type: TYPE_NORMAL
- en: setequal() set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: batch mode, 3
  prefs: []
  type: TYPE_NORMAL
- en: setMethod() function, 225
  prefs: []
  type: TYPE_NORMAL
- en: first session, 4–7
  prefs: []
  type: TYPE_NORMAL
- en: set operations, 202–203
  prefs: []
  type: TYPE_NORMAL
- en: interactive mode, 2–3
  prefs: []
  type: TYPE_NORMAL
- en: set.seed() function, 302
  prefs: []
  type: TYPE_NORMAL
- en: snow code, 335–336
  prefs: []
  type: TYPE_NORMAL
- en: setting breakpoints, 289–290
  prefs: []
  type: TYPE_NORMAL
- en: runs of consecutive ones, finding, 35–37
  prefs: []
  type: TYPE_NORMAL
- en: calling browser() function directly,
  prefs: []
  type: TYPE_NORMAL
- en: runtime errors, 303
  prefs: []
  type: TYPE_NORMAL
- en: 289–290
  prefs: []
  type: TYPE_NORMAL
- en: using setbreakpoint() function, 290
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  prefs: []
  type: TYPE_NORMAL
- en: setwd() function, 245
  prefs: []
  type: TYPE_NORMAL
- en: S expression pointers (SEXPs), 304
  prefs: []
  type: TYPE_NORMAL
- en: S (programming language), xix
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory systems, 341, 346–347
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 208–222
  prefs: []
  type: TYPE_NORMAL
- en: shared-memory/threads model,
  prefs: []
  type: TYPE_NORMAL
- en: class for storing upper-triangular
  prefs: []
  type: TYPE_NORMAL
- en: GPUs, 345
  prefs: []
  type: TYPE_NORMAL
- en: matrices example, 214–219
  prefs: []
  type: TYPE_NORMAL
- en: Sherman-Morrison-Woodbury
  prefs: []
  type: TYPE_NORMAL
- en: finding implementations of generic
  prefs: []
  type: TYPE_NORMAL
- en: formula, 222
  prefs: []
  type: TYPE_NORMAL
- en: methods, 210–212
  prefs: []
  type: TYPE_NORMAL
- en: shortcuts
  prefs: []
  type: TYPE_NORMAL
- en: generic functions, 208
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 20
  prefs: []
  type: TYPE_NORMAL
- en: OOP in lm() function example,
  prefs: []
  type: TYPE_NORMAL
- en: help.search() function, 23
  prefs: []
  type: TYPE_NORMAL
- en: 208–210
  prefs: []
  type: TYPE_NORMAL
- en: showframe() function, 158
  prefs: []
  type: TYPE_NORMAL
- en: procedure for polynomial regression
  prefs: []
  type: TYPE_NORMAL
- en: sim global variable, 172–173
  prefs: []
  type: TYPE_NORMAL
- en: example, 219–222
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 172
  prefs: []
  type: TYPE_NORMAL
- en: vs. S4 classes, 226
  prefs: []
  type: TYPE_NORMAL
- en: simulation programming in R, 204–206
  prefs: []
  type: TYPE_NORMAL
- en: using inheritance, 214
  prefs: []
  type: TYPE_NORMAL
- en: built-in random variate generators,
  prefs: []
  type: TYPE_NORMAL
- en: writing, 212–213
  prefs: []
  type: TYPE_NORMAL
- en: 204–205
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 222–226
  prefs: []
  type: TYPE_NORMAL
- en: combinatorial simulation, 205–206
  prefs: []
  type: TYPE_NORMAL
- en: implementing generic function on,
  prefs: []
  type: TYPE_NORMAL
- en: obtaining same random stream in
  prefs: []
  type: TYPE_NORMAL
- en: 225–226
  prefs: []
  type: TYPE_NORMAL
- en: repeated runs, 205
  prefs: []
  type: TYPE_NORMAL
- en: vs. S3 classes, 226
  prefs: []
  type: TYPE_NORMAL
- en: single brackets, 87–88
  prefs: []
  type: TYPE_NORMAL
- en: writing, 223–225
  prefs: []
  type: TYPE_NORMAL
- en: single-server queuing system, 168
  prefs: []
  type: TYPE_NORMAL
- en: salary study, 108–109
  prefs: []
  type: TYPE_NORMAL
- en: sink() function, 258
  prefs: []
  type: TYPE_NORMAL
- en: Salzman, Pete, 285
  prefs: []
  type: TYPE_NORMAL
- en: sin() math function, 190
  prefs: []
  type: TYPE_NORMAL
- en: sapply() function, 42
  prefs: []
  type: TYPE_NORMAL
- en: slots, S4 class, 224
  prefs: []
  type: TYPE_NORMAL
- en: applying functions to lists, 95
  prefs: []
  type: TYPE_NORMAL
- en: snow package, 334–335
  prefs: []
  type: TYPE_NORMAL
- en: using on data frames, 112–113
  prefs: []
  type: TYPE_NORMAL
- en: implementing parallel R, 248–249
  prefs: []
  type: TYPE_NORMAL
- en: save() function, saving collection of
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering (KMC), 338–340
  prefs: []
  type: TYPE_NORMAL
- en: objects with, 228
  prefs: []
  type: TYPE_NORMAL
- en: snow code
  prefs: []
  type: TYPE_NORMAL
- en: saving graphs to files, 280–281
  prefs: []
  type: TYPE_NORMAL
- en: analyzing, 336–337
  prefs: []
  type: TYPE_NORMAL
- en: scalars, 10
  prefs: []
  type: TYPE_NORMAL
- en: running, 335–336
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operators, 145
  prefs: []
  type: TYPE_NORMAL
- en: speedup, 337–338
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 26
  prefs: []
  type: TYPE_NORMAL
- en: socketConnection() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: scan() function, 142, 232–234
  prefs: []
  type: TYPE_NORMAL
- en: sockets, 247–248
  prefs: []
  type: TYPE_NORMAL
- en: scatter/gather paradigm, 335–336
  prefs: []
  type: TYPE_NORMAL
- en: socketSelect() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: schedevnt() function, 165, 171
  prefs: []
  type: TYPE_NORMAL
- en: solve() function, 197
  prefs: []
  type: TYPE_NORMAL
- en: scope hierarchy, 152–155\. *See also* envi-
  prefs: []
  type: TYPE_NORMAL
- en: sorting, numerical, 194–196
  prefs: []
  type: TYPE_NORMAL
- en: ronment and scope
  prefs: []
  type: TYPE_NORMAL
- en: sos package, 24
  prefs: []
  type: TYPE_NORMAL
- en: sepsoundtone() function, 119
  prefs: []
  type: TYPE_NORMAL
- en: source, installing R from, 354
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 21, 33–34
  prefs: []
  type: TYPE_NORMAL
- en: sourceval parameter, mapsound()
  prefs: []
  type: TYPE_NORMAL
- en: serialize() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  prefs: []
  type: TYPE_NORMAL
- en: setbreakpoint() function, 290
  prefs: []
  type: TYPE_NORMAL
- en: Spearman rank correlation, 49
  prefs: []
  type: TYPE_NORMAL
- en: setClass() function, 223
  prefs: []
  type: TYPE_NORMAL
- en: '**370**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: speed
  prefs: []
  type: TYPE_NORMAL
- en: summary() function, 15, 18
  prefs: []
  type: TYPE_NORMAL
- en: byte code compilation, 320
  prefs: []
  type: TYPE_NORMAL
- en: summaryRprof() function, 319
  prefs: []
  type: TYPE_NORMAL
- en: finding slow spots in code, 316–319
  prefs: []
  type: TYPE_NORMAL
- en: summing contents of many files, 245–246
  prefs: []
  type: TYPE_NORMAL
- en: for loop, 306–313
  prefs: []
  type: TYPE_NORMAL
- en: superassignment operator (<<-), 9
  prefs: []
  type: TYPE_NORMAL
- en: achieving better speed in Monte
  prefs: []
  type: TYPE_NORMAL
- en: simplifying code, 174
  prefs: []
  type: TYPE_NORMAL
- en: Carlo simulation example,
  prefs: []
  type: TYPE_NORMAL
- en: writing to nonlocals with, 161–162
  prefs: []
  type: TYPE_NORMAL
- en: 308–311
  prefs: []
  type: TYPE_NORMAL
- en: sweep() linear algebra function, 197–198
  prefs: []
  type: TYPE_NORMAL
- en: generating powers matrix
  prefs: []
  type: TYPE_NORMAL
- en: symmetric matrix, 77
  prefs: []
  type: TYPE_NORMAL
- en: example, 312–313
  prefs: []
  type: TYPE_NORMAL
- en: syntax errors, 303
  prefs: []
  type: TYPE_NORMAL
- en: vectorization for speedup,
  prefs: []
  type: TYPE_NORMAL
- en: 306–308
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: writing fast R code, 306
  prefs: []
  type: TYPE_NORMAL
- en: Spinu, Vitalie, 300
  prefs: []
  type: TYPE_NORMAL
- en: tabdom() function, 134
  prefs: []
  type: TYPE_NORMAL
- en: split() function, 124–126, 336
  prefs: []
  type: TYPE_NORMAL
- en: tables, 127–130
  prefs: []
  type: TYPE_NORMAL
- en: S-Plus (programming language), xix
  prefs: []
  type: TYPE_NORMAL
- en: extracting subtable example,
  prefs: []
  type: TYPE_NORMAL
- en: sprintf() function, 253
  prefs: []
  type: TYPE_NORMAL
- en: 131–134
  prefs: []
  type: TYPE_NORMAL
- en: sqrt() function, 42, 189
  prefs: []
  type: TYPE_NORMAL
- en: finding largest cells in, 134
  prefs: []
  type: TYPE_NORMAL
- en: stack trace, 289
  prefs: []
  type: TYPE_NORMAL
- en: functions, 136–137
  prefs: []
  type: TYPE_NORMAL
- en: startup and shutdown, 19–20
  prefs: []
  type: TYPE_NORMAL
- en: aggregate(), 136
  prefs: []
  type: TYPE_NORMAL
- en: static task assignment, 348–350
  prefs: []
  type: TYPE_NORMAL
- en: cut(), 136–137
  prefs: []
  type: TYPE_NORMAL
- en: stationary distributions, Markov chains,
  prefs: []
  type: TYPE_NORMAL
- en: matrix/array-like operations,
  prefs: []
  type: TYPE_NORMAL
- en: 199–201
  prefs: []
  type: TYPE_NORMAL
- en: 130–131
  prefs: []
  type: TYPE_NORMAL
- en: statistical distributions, functions for,
  prefs: []
  type: TYPE_NORMAL
- en: tags, 86
  prefs: []
  type: TYPE_NORMAL
- en: 193–194
  prefs: []
  type: TYPE_NORMAL
- en: tapply() function
  prefs: []
  type: TYPE_NORMAL
- en: str() function, 14
  prefs: []
  type: TYPE_NORMAL
- en: vs. by() function, 126–127
  prefs: []
  type: TYPE_NORMAL
- en: string-manipulation functions, 11,
  prefs: []
  type: TYPE_NORMAL
- en: factors, 123–124
  prefs: []
  type: TYPE_NORMAL
- en: 251–254
  prefs: []
  type: TYPE_NORMAL
- en: vs. split() function, 124
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr(), 254
  prefs: []
  type: TYPE_NORMAL
- en: tbl argument, subtable() function, 132
  prefs: []
  type: TYPE_NORMAL
- en: grep(), 252
  prefs: []
  type: TYPE_NORMAL
- en: tblarray array, 133
  prefs: []
  type: TYPE_NORMAL
- en: nchar(), 252
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, 247
  prefs: []
  type: TYPE_NORMAL
- en: paste(), 252–253
  prefs: []
  type: TYPE_NORMAL
- en: termination condition, 177
  prefs: []
  type: TYPE_NORMAL
- en: regexpr(), 253–254
  prefs: []
  type: TYPE_NORMAL
- en: testing vector equality, 54–55
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(), 253
  prefs: []
  type: TYPE_NORMAL
- en: text, adding to graphs with text() func-
  prefs: []
  type: TYPE_NORMAL
- en: strsplit(), 253
  prefs: []
  type: TYPE_NORMAL
- en: tion, 270–271
  prefs: []
  type: TYPE_NORMAL
- en: substr(), 253
  prefs: []
  type: TYPE_NORMAL
- en: text concordance, 90–93, 95–98
  prefs: []
  type: TYPE_NORMAL
- en: stringsAsFactors argument, data.frame()
  prefs: []
  type: TYPE_NORMAL
- en: text editors, 186
  prefs: []
  type: TYPE_NORMAL
- en: function, 102
  prefs: []
  type: TYPE_NORMAL
- en: text files, reading, 237
  prefs: []
  type: TYPE_NORMAL
- en: string utilities, in edtdbg debugging tool,
  prefs: []
  type: TYPE_NORMAL
- en: text() function, adding text to graphs
  prefs: []
  type: TYPE_NORMAL
- en: 257–259
  prefs: []
  type: TYPE_NORMAL
- en: with, 270–271
  prefs: []
  type: TYPE_NORMAL
- en: strsplit() function, 253
  prefs: []
  type: TYPE_NORMAL
- en: t() function, 71, 119, 197
  prefs: []
  type: TYPE_NORMAL
- en: subdeterminants, 199
  prefs: []
  type: TYPE_NORMAL
- en: threaded code, 171
  prefs: []
  type: TYPE_NORMAL
- en: submatrices, assigning values to, 62–63
  prefs: []
  type: TYPE_NORMAL
- en: threads, 341
  prefs: []
  type: TYPE_NORMAL
- en: subnames argument, subtable()
  prefs: []
  type: TYPE_NORMAL
- en: three-dimensional tables, 129–130
  prefs: []
  type: TYPE_NORMAL
- en: function, 132
  prefs: []
  type: TYPE_NORMAL
- en: Tierney, Luke, 334
  prefs: []
  type: TYPE_NORMAL
- en: subscripting operations, 183
  prefs: []
  type: TYPE_NORMAL
- en: tocol parameter, mapsound()
  prefs: []
  type: TYPE_NORMAL
- en: subset() function, 47, 105
  prefs: []
  type: TYPE_NORMAL
- en: function, 116
  prefs: []
  type: TYPE_NORMAL
- en: subsetting, vector, 4–5
  prefs: []
  type: TYPE_NORMAL
- en: tools
  prefs: []
  type: TYPE_NORMAL
- en: substr() function, 253
  prefs: []
  type: TYPE_NORMAL
- en: for composing function code,
  prefs: []
  type: TYPE_NORMAL
- en: subtable() function, 132
  prefs: []
  type: TYPE_NORMAL
- en: 186–187
  prefs: []
  type: TYPE_NORMAL
- en: suffix, testing filename for given, 255–256
  prefs: []
  type: TYPE_NORMAL
- en: edit() function, 186–187
  prefs: []
  type: TYPE_NORMAL
- en: sum() function, 190, 337
  prefs: []
  type: TYPE_NORMAL
- en: text editors and IDEs, 186
  prefs: []
  type: TYPE_NORMAL
- en: debugging, 287–288, 300–302
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**371**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: top-level environment, 152
  prefs: []
  type: TYPE_NORMAL
- en: vectors, 10, 25–57
  prefs: []
  type: TYPE_NORMAL
- en: traceback() function, 291–292
  prefs: []
  type: TYPE_NORMAL
- en: all() and any() functions, 35–39
  prefs: []
  type: TYPE_NORMAL
- en: trace() function, 291
  prefs: []
  type: TYPE_NORMAL
- en: finding runs of consecutive ones
  prefs: []
  type: TYPE_NORMAL
- en: tracemem() function, 314–315
  prefs: []
  type: TYPE_NORMAL
- en: example, 35–37
  prefs: []
  type: TYPE_NORMAL
- en: training set, 37
  prefs: []
  type: TYPE_NORMAL
- en: predicting discrete-valued time
  prefs: []
  type: TYPE_NORMAL
- en: transcendental functions, 40
  prefs: []
  type: TYPE_NORMAL
- en: series example, 37–39
  prefs: []
  type: TYPE_NORMAL
- en: transition probability, 200
  prefs: []
  type: TYPE_NORMAL
- en: c() function, 56–57
  prefs: []
  type: TYPE_NORMAL
- en: treelike data structures, 177
  prefs: []
  type: TYPE_NORMAL
- en: common operations, 30–34
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic and logical operations,
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  prefs: []
  type: TYPE_NORMAL
- en: 30–31
  prefs: []
  type: TYPE_NORMAL
- en: colon operator (:), 32–33
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu, installing R on, 353–354
  prefs: []
  type: TYPE_NORMAL
- en: generating vector sequences with
  prefs: []
  type: TYPE_NORMAL
- en: unclass() function, 229
  prefs: []
  type: TYPE_NORMAL
- en: seq() function, 33–34
  prefs: []
  type: TYPE_NORMAL
- en: union() set operation, 202
  prefs: []
  type: TYPE_NORMAL
- en: repeating vector constants with
  prefs: []
  type: TYPE_NORMAL
- en: unlist() function, 93
  prefs: []
  type: TYPE_NORMAL
- en: rep() function, 34
  prefs: []
  type: TYPE_NORMAL
- en: unname() function, 94
  prefs: []
  type: TYPE_NORMAL
- en: vector indexing, 31–32
  prefs: []
  type: TYPE_NORMAL
- en: unserialize() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: computing inner product of two, 196
  prefs: []
  type: TYPE_NORMAL
- en: upn argument, showframe() function, 158
  prefs: []
  type: TYPE_NORMAL
- en: declarations, 28–29
  prefs: []
  type: TYPE_NORMAL
- en: upper-triangular matrices, class for stor-
  prefs: []
  type: TYPE_NORMAL
- en: defined, 4
  prefs: []
  type: TYPE_NORMAL
- en: ing, 214–219
  prefs: []
  type: TYPE_NORMAL
- en: elements
  prefs: []
  type: TYPE_NORMAL
- en: URLs, accessing files on remote
  prefs: []
  type: TYPE_NORMAL
- en: adding and deleting, 26
  prefs: []
  type: TYPE_NORMAL
- en: machines via, 243
  prefs: []
  type: TYPE_NORMAL
- en: naming, 56
  prefs: []
  type: TYPE_NORMAL
- en: u variable, 162
  prefs: []
  type: TYPE_NORMAL
- en: filtering, 45–48
  prefs: []
  type: TYPE_NORMAL
- en: generating indices for, 45–47
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  prefs: []
  type: TYPE_NORMAL
- en: with subset() function, 47
  prefs: []
  type: TYPE_NORMAL
- en: with which() function, 47–48
  prefs: []
  type: TYPE_NORMAL
- en: values
  prefs: []
  type: TYPE_NORMAL
- en: ifelse() function, 48–54
  prefs: []
  type: TYPE_NORMAL
- en: assigning to submatrices, 62–63
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: variables example, 49–51
  prefs: []
  type: TYPE_NORMAL
- en: list, accessing, 93–95
  prefs: []
  type: TYPE_NORMAL
- en: recoding abalone data set
  prefs: []
  type: TYPE_NORMAL
- en: NA, 43, 105–106
  prefs: []
  type: TYPE_NORMAL
- en: example, 51–54
  prefs: []
  type: TYPE_NORMAL
- en: NULL, 44
  prefs: []
  type: TYPE_NORMAL
- en: linear algebra operations on,
  prefs: []
  type: TYPE_NORMAL
- en: return, 147–149
  prefs: []
  type: TYPE_NORMAL
- en: 196–201
  prefs: []
  type: TYPE_NORMAL
- en: vanilla option, startup/shutdown, 20
  prefs: []
  type: TYPE_NORMAL
- en: matrices and arrays as, 28
  prefs: []
  type: TYPE_NORMAL
- en: variables
  prefs: []
  type: TYPE_NORMAL
- en: NA value, 43
  prefs: []
  type: TYPE_NORMAL
- en: assessing statistical relation of two,
  prefs: []
  type: TYPE_NORMAL
- en: NULL value, 44
  prefs: []
  type: TYPE_NORMAL
- en: 49–51
  prefs: []
  type: TYPE_NORMAL
- en: obtaining length of, 27
  prefs: []
  type: TYPE_NORMAL
- en: categorical, 121
  prefs: []
  type: TYPE_NORMAL
- en: recycling, 29–30
  prefs: []
  type: TYPE_NORMAL
- en: global, 9, 171–174
  prefs: []
  type: TYPE_NORMAL
- en: scalars, 26
  prefs: []
  type: TYPE_NORMAL
- en: nominal, 121
  prefs: []
  type: TYPE_NORMAL
- en: testing vector equality, 54–55
  prefs: []
  type: TYPE_NORMAL
- en: variable scope, 9
  prefs: []
  type: TYPE_NORMAL
- en: vectorized operations, 39–43
  prefs: []
  type: TYPE_NORMAL
- en: vector assignment issues, 314
  prefs: []
  type: TYPE_NORMAL
- en: vector in, matrix out, 42–43
  prefs: []
  type: TYPE_NORMAL
- en: vector cross product, 198–199
  prefs: []
  type: TYPE_NORMAL
- en: vector in, vector out, 40–42
  prefs: []
  type: TYPE_NORMAL
- en: vector filtering, 307
  prefs: []
  type: TYPE_NORMAL
- en: vertices, graph, finding, 75–78
  prefs: []
  type: TYPE_NORMAL
- en: vector-filtering capability, 176
  prefs: []
  type: TYPE_NORMAL
- en: vector functions, 311
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  prefs: []
  type: TYPE_NORMAL
- en: defined, 25
  prefs: []
  type: TYPE_NORMAL
- en: Web, downloading packages from,
  prefs: []
  type: TYPE_NORMAL
- en: for speedup, 306–308
  prefs: []
  type: TYPE_NORMAL
- en: 356–358
  prefs: []
  type: TYPE_NORMAL
- en: vectorized operations, 40
  prefs: []
  type: TYPE_NORMAL
- en: installing automatically, 356–357
  prefs: []
  type: TYPE_NORMAL
- en: vector/matrix distinction, 78–79
  prefs: []
  type: TYPE_NORMAL
- en: installing manually, 357–358
  prefs: []
  type: TYPE_NORMAL
- en: '**372**'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: where browser command, 289
  prefs: []
  type: TYPE_NORMAL
- en: which.max() function, 73, 190
  prefs: []
  type: TYPE_NORMAL
- en: which.min() function, 190
  prefs: []
  type: TYPE_NORMAL
- en: which() function, 47–48
  prefs: []
  type: TYPE_NORMAL
- en: whitespace, 233
  prefs: []
  type: TYPE_NORMAL
- en: Wickham, Hadley, 136
  prefs: []
  type: TYPE_NORMAL
- en: wireframe() function, 282–283
  prefs: []
  type: TYPE_NORMAL
- en: wmins matrix, 77
  prefs: []
  type: TYPE_NORMAL
- en: workers, snow package, 335
  prefs: []
  type: TYPE_NORMAL
- en: working directory, 19–20
  prefs: []
  type: TYPE_NORMAL
- en: writeBin() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: writeLines() function, 248
  prefs: []
  type: TYPE_NORMAL
- en: write.table() function, 244
  prefs: []
  type: TYPE_NORMAL
- en: writing, 161
  prefs: []
  type: TYPE_NORMAL
- en: binary operations, 187
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ functions to be called from R,
  prefs: []
  type: TYPE_NORMAL
- en: 323–324
  prefs: []
  type: TYPE_NORMAL
- en: compiling and running code, 325
  prefs: []
  type: TYPE_NORMAL
- en: debugging R/C code, 326–327
  prefs: []
  type: TYPE_NORMAL
- en: extracting subdiagonals from
  prefs: []
  type: TYPE_NORMAL
- en: square matrix example, 324–325
  prefs: []
  type: TYPE_NORMAL
- en: prediction of discrete-valued time
  prefs: []
  type: TYPE_NORMAL
- en: series example, 327–330
  prefs: []
  type: TYPE_NORMAL
- en: closures, 174–175
  prefs: []
  type: TYPE_NORMAL
- en: discrete-event simulation in R
  prefs: []
  type: TYPE_NORMAL
- en: example, 164–171
  prefs: []
  type: TYPE_NORMAL
- en: getting files and directory
  prefs: []
  type: TYPE_NORMAL
- en: information, 245
  prefs: []
  type: TYPE_NORMAL
- en: to nonlocals
  prefs: []
  type: TYPE_NORMAL
- en: with assign() function, 163
  prefs: []
  type: TYPE_NORMAL
- en: with superassignment operator,
  prefs: []
  type: TYPE_NORMAL
- en: 161–162
  prefs: []
  type: TYPE_NORMAL
- en: S3 classes, 212–213
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes, 223–225
  prefs: []
  type: TYPE_NORMAL
- en: summing contents of many files
  prefs: []
  type: TYPE_NORMAL
- en: example, 245–246
  prefs: []
  type: TYPE_NORMAL
- en: when to use global variables, 171–174
  prefs: []
  type: TYPE_NORMAL
- en: '**X**'
  prefs: []
  type: TYPE_NORMAL
- en: xlim option, 273–275
  prefs: []
  type: TYPE_NORMAL
- en: x variable, 162
  prefs: []
  type: TYPE_NORMAL
- en: '**Y**'
  prefs: []
  type: TYPE_NORMAL
- en: ylim option, 273–275
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**'
  prefs: []
  type: TYPE_NORMAL
- en: z variable, 162
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**373**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The Electronic Frontier Foundation (EFF) is the leading organization defending
    civil liberties in the digital world. We defend free speech on the Internet, fight
    illegal surveillance, promote the rights of innovators to develop new digital
    technologies, and work to ensure that the rights and freedoms we enjoy are enhanced
    —
  prefs: []
  type: TYPE_NORMAL
- en: rather than eroded — as our use of technology grows.
  prefs: []
  type: TYPE_NORMAL
- en: PRIVACY EFF has sued telecom giant AT&T for giving the NSA unfettered access
    to the private communications of millions of their customers. eff.org/nsa
  prefs: []
  type: TYPE_NORMAL
- en: FREE SPEECH EFF’s Coders’ Rights Project is defending the rights of programmers
    and security researchers to publish their findings without fear of legal challenges.
  prefs: []
  type: TYPE_NORMAL
- en: eff.org/freespeech
  prefs: []
  type: TYPE_NORMAL
- en: INNOVATION EFF's Patent Busting Project challenges overbroad patents that threaten
    technological innovation. eff.org/patent
  prefs: []
  type: TYPE_NORMAL
- en: FAIR USE EFF is fighting prohibitive standards that would take away your right
    to receive and use over-the-air television broadcasts any way you choose. eff.org/IP/fairuse
    TRANSPARENCY EFF has developed the Switzerland Network Testing Tool to give individuals
    the tools to test for covert traffic filtering. eff.org/transparency
  prefs: []
  type: TYPE_NORMAL
- en: INTERNATIONAL EFF is working to ensure that international treaties do not restrict
    our free speech, privacy or digital consumer rights. eff.org/global
  prefs: []
  type: TYPE_NORMAL
- en: EFF is a member-supported organization. Join Now! www.eff.org/support
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 46](index-401_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 47](index-401_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 48](index-401_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 49](index-401_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 50](index-401_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 51](index-401_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UPDATES
  prefs: []
  type: TYPE_NORMAL
- en: Visit *http://www.nostarch.com/artofr.htm* for updates, errata, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '*More no-nonsense books from*'
  prefs: []
  type: TYPE_NORMAL
- en: NO STARCH PRESS
  prefs: []
  type: TYPE_NORMAL
- en: MAP SCRIPTING 101
  prefs: []
  type: TYPE_NORMAL
- en: LEARN YOU A HASKELL
  prefs: []
  type: TYPE_NORMAL
- en: ELOQUENT JAVASCRIPT
  prefs: []
  type: TYPE_NORMAL
- en: An Example-Driven Guide to Building
  prefs: []
  type: TYPE_NORMAL
- en: FOR GREAT GOOD
  prefs: []
  type: TYPE_NORMAL
- en: A Modern Introduction to Programming
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Maps with Bing, Yahoo!,
  prefs: []
  type: TYPE_NORMAL
- en: A Beginner’s Guide
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MARIJN HAVERBEKE'
  prefs: []
  type: TYPE_NORMAL
- en: and Google Maps
  prefs: []
  type: TYPE_NORMAL
- en: JANUARY 2011, 224 PP., $29.95
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MIRAN LIPOVAýA'
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-282-1
  prefs: []
  type: TYPE_NORMAL
- en: '*by* ADAM DUVANDER'
  prefs: []
  type: TYPE_NORMAL
- en: APRIL 2011, 400 PP., $44.95
  prefs: []
  type: TYPE_NORMAL
- en: AUGUST 2010, 376 PP., $34.95
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-283-8
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-271-5
  prefs: []
  type: TYPE_NORMAL
- en: THE TCP/IP GUIDE
  prefs: []
  type: TYPE_NORMAL
- en: THE MANGA GUIDE™ TO
  prefs: []
  type: TYPE_NORMAL
- en: THE LINUX PROGRAMMING
  prefs: []
  type: TYPE_NORMAL
- en: A Comprehensive, Illustrated Internet
  prefs: []
  type: TYPE_NORMAL
- en: STATISTICS
  prefs: []
  type: TYPE_NORMAL
- en: INTERFACE
  prefs: []
  type: TYPE_NORMAL
- en: Protocols Reference
  prefs: []
  type: TYPE_NORMAL
- en: '*by* SHIN TAKAHASHI *and* TREND-PRO'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux and UNIX® System
  prefs: []
  type: TYPE_NORMAL
- en: '*by* CHARLES M. KOZIEROK'
  prefs: []
  type: TYPE_NORMAL
- en: CO., LTD
  prefs: []
  type: TYPE_NORMAL
- en: Programming Handbook
  prefs: []
  type: TYPE_NORMAL
- en: OCTOBER 2005, 1616 PP., $99.95, *hardcover*
  prefs: []
  type: TYPE_NORMAL
- en: NOVEMBER 2008, 232 PP., $19.95
  prefs: []
  type: TYPE_NORMAL
- en: '*by* MICHAEL KERRISK'
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-047-6
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-189-3
  prefs: []
  type: TYPE_NORMAL
- en: OCTOBER 2010, 1552 PP., $99.95, *hardcover*
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-59327-220-3
  prefs: []
  type: TYPE_NORMAL
- en: '**PHONE:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMAIL:**'
  prefs: []
  type: TYPE_NORMAL
- en: 800.420.7240 OR
  prefs: []
  type: TYPE_NORMAL
- en: SALES@NOSTARCH.COM
  prefs: []
  type: TYPE_NORMAL
- en: 415.863.9900
  prefs: []
  type: TYPE_NORMAL
- en: '**WEB:**'
  prefs: []
  type: TYPE_NORMAL
- en: MONDAY THROUGH FRIDAY,
  prefs: []
  type: TYPE_NORMAL
- en: 9 A.M. TO 5 P.M. (PST)
  prefs: []
  type: TYPE_NORMAL
- en: WWW.NOSTARCH.COM
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The fonts used in *The Art of R Programming* are New Baskerville, Futura, The
    Sans Mono Condensed and Dogma. The book was typeset with LATEX 2 *ε*
  prefs: []
  type: TYPE_NORMAL
- en: package nostarch by Boris Veytsman *(2008/06/06 v1.3 Typesetting books for No*
    *Starch Press).*
  prefs: []
  type: TYPE_NORMAL
- en: This book was printed and bound at Malloy Incorporated in Ann Arbor, Michigan.
    The paper is Glatfelter Spring Forge 60# Smooth, which is certi-fied by the Sustainable
    Forestry Initiative (SFI). The book uses a RepKover binding, which allows it to
    lie flat when open.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](index-404_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**T A M E Y O U R D A T A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T H E**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HE A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A R T O F R**'
  prefs: []
  type: TYPE_NORMAL
- en: R is the world’s most popular language for developing
  prefs: []
  type: TYPE_NORMAL
- en: • Interface R with C/C++ and Python for increased
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: 'statistical software: Archaeologists use it to track the'
  prefs: []
  type: TYPE_NORMAL
- en: speed or functionality
  prefs: []
  type: TYPE_NORMAL
- en: '**T O**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROGR A MMING**'
  prefs: []
  type: TYPE_NORMAL
- en: spread of ancient civilizations, drug companies use it
  prefs: []
  type: TYPE_NORMAL
- en: • Find new packages for text analysis, image manipula-
  prefs: []
  type: TYPE_NORMAL
- en: to discover which medications are safe and effective,
  prefs: []
  type: TYPE_NORMAL
- en: tion, and thousands more
  prefs: []
  type: TYPE_NORMAL
- en: and actuaries use it to assess financial risks and keep
  prefs: []
  type: TYPE_NORMAL
- en: '**A T O U R O F S T A T I S T I C A L S O F T W A R E D E S I G N**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F R P**'
  prefs: []
  type: TYPE_NORMAL
- en: markets running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: • Squash annoying bugs with advanced debugging
  prefs: []
  type: TYPE_NORMAL
- en: techniques
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of R Programming* takes you on a guided tour'
  prefs: []
  type: TYPE_NORMAL
- en: of software development with R, from basic types
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re designing aircraft, forecasting the
  prefs: []
  type: TYPE_NORMAL
- en: and data structures to advanced topics like closures,
  prefs: []
  type: TYPE_NORMAL
- en: weather, or you just need to tame your data, *The Art of*
  prefs: []
  type: TYPE_NORMAL
- en: '**N O R M A N M A T L O F F**'
  prefs: []
  type: TYPE_NORMAL
- en: recursion, and anonymous functions. No statistical
  prefs: []
  type: TYPE_NORMAL
- en: '*R Programming* is your guide to harnessing the power'
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: knowledge is required, and your programming skil s
  prefs: []
  type: TYPE_NORMAL
- en: of statistical computing.
  prefs: []
  type: TYPE_NORMAL
- en: can range from hobbyist to pro.
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A B O U T T H E A U T H O R**'
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, you’ll learn about functional and object-
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: Norman Matloff is a professor of computer science
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming, running mathematical simulations,
  prefs: []
  type: TYPE_NORMAL
- en: (and a former professor of statistics) at the University
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: and rearranging complex data into simpler, more useful
  prefs: []
  type: TYPE_NORMAL
- en: of California, Davis. His research interests include
  prefs: []
  type: TYPE_NORMAL
- en: 'formats. You’ll also learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: paral el processing and statistical regression, and
  prefs: []
  type: TYPE_NORMAL
- en: • Create artful graphs to visualize complex data sets
  prefs: []
  type: TYPE_NORMAL
- en: he is the author of several widely used web tutorials
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: and functions
  prefs: []
  type: TYPE_NORMAL
- en: on software development. He has written articles for
  prefs: []
  type: TYPE_NORMAL
- en: the *New York Times*, the *Washington Post*, *Forbes* **M**
  prefs: []
  type: TYPE_NORMAL
- en: • Write more efficient code using paral el R and
  prefs: []
  type: TYPE_NORMAL
- en: '*Magazine*, and the *Los Angeles Times*, and he is the'
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  prefs: []
  type: TYPE_NORMAL
- en: co-author of *The Art of Debugging* (No Starch Press).
  prefs: []
  type: TYPE_NORMAL
- en: '**NG**'
  prefs: []
  type: TYPE_NORMAL
- en: '***TH E FI N EST I N G E E K E NTE RTAI N M E NT™***'
  prefs: []
  type: TYPE_NORMAL
- en: www.nostarch.com
  prefs: []
  type: TYPE_NORMAL
- en: '**MAT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: '***“I LI E FLAT.”***'
  prefs: []
  type: TYPE_NORMAL
- en: '**$39.95 *($41.95 CDN)***'
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S C S**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This book uses RepKover —a durable binding that won’t snap shut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**T O H**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: '**M E**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LV**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I P**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ST U E**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I T I**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C E N**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A R :**'
  prefs: []
  type: TYPE_NORMAL
- en: '**L S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SO /M**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T T**'
  prefs: []
  type: TYPE_NORMAL
- en: '**W H**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A EM**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RE ATICAL &**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Copyright](index_split_000.html#p6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Brief Contents](index_split_000.html#p7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contents in Detail](index_split_000.html#p9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p19)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p21)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why Use R for Your Statistical Work?](index_split_000.html#p21)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Whom Is This Book For?](index_split_000.html#p24)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[My Own Background](index_split_000.html#p25)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1: Getting Started](index_split_000.html#p27)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.1 How to Run R](index_split_000.html#p27)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.2 A First R Session](index_split_000.html#p30)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.3 Introduction to Functions](index_split_000.html#p33)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.4 Preview of Some Important R Data Structures](index_split_000.html#p36)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.5 Extended Example: Regression Analysis of Exam Grades](index_split_000.html#p42)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.6 Startup and Shutdown](index_split_000.html#p45)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.7 Getting Help](index_split_000.html#p46)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2: Vectors](index_split_000.html#p51)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.1 Scalars, Vectors, Arrays, and Matrices](index_split_000.html#p52)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.2 Declarations](index_split_000.html#p54)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.3 Recycling](index_split_000.html#p55)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.4 Common Vector Operations](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.5 Using all() and any()](index_split_001.html#p61)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.6 Vectorized Operations](index_split_001.html#p65)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.7 NA and NULL Values](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.8 Filtering](index_split_001.html#p71)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.9 A Vectorized if-then-else: The ifelse() Function](index_split_001.html#p74)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.10 Testing Vector Equality](index_split_001.html#p80)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.11 Vector Element Names](index_split_001.html#p82)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.12 More on c()](index_split_001.html#p82)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3: Matrices and Arrays](index_split_001.html#p85)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.1 Creating Matrices](index_split_001.html#p85)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.2 General Matrix Operations](index_split_001.html#p87)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.3 Applying Functions to Matrix Rows and Columns](index_split_001.html#p96)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.4 Adding and Deleting Matrix Rows and Columns](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.5 More on the Vector/Matrix Distinction](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.6 Avoiding Unintended Dimension Reduction](index_split_001.html#p106)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.7 Naming Matrix Rows and Columns](index_split_001.html#p107)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.8 Higher-Dimensional Arrays](index_split_001.html#p108)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4: Lists](index_split_001.html#p111)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.1 Creating Lists](index_split_001.html#p111)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.2 General List Operations](index_split_001.html#p113)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.3 Accessing List Components and Values](index_split_002.html#p119)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.4 Applying Functions to Lists](index_split_002.html#p121)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.5 Recursive Lists](index_split_002.html#p125)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5: Data Frames](index_split_002.html#p127)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.1 Creating Data Frames](index_split_002.html#p128)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.2 Other Matrix-Like Operations](index_split_002.html#p130)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.3 Merging Data Frames](index_split_002.html#p135)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.4 Applying Functions to Data Frames](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6: Factors and Tables](index_split_002.html#p147)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.1 Factors and Levels](index_split_002.html#p147)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.2 Common Functions Used with Factors](index_split_002.html#p149)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.3 Working with Tables](index_split_002.html#p153)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.4 Other Factor- and Table-Related Functions](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7: R Programming Structures](index_split_003.html#p165)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.1 Control Statements](index_split_003.html#p165)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.2 Arithmetic and Boolean Operators and Values](index_split_003.html#p171)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.3 Default Values for Arguments](index_split_003.html#p172)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.4 Return Values](index_split_003.html#p173)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.5 Functions Are Objects](index_split_003.html#p175)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.6 Environment and Scope Issues](index_split_003.html#p177)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.7 No Pointers in R](index_split_003.html#p185)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.8 Writing Upstairs](index_split_003.html#p187)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.9 Recursion](index_split_003.html#p202)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.10 Replacement Functions](index_split_003.html#p208)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.11 Tools for Composing Function Code](index_split_004.html#p212)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.12 Writing Your Own Binary Operations](index_split_004.html#p213)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.13 Anonymous Functions](index_split_004.html#p213)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8: Doing Math and Simulations in R](index_split_004.html#p215)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.1 Math Functions](index_split_004.html#p215)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.2 Functions for Statistical Distributions](index_split_004.html#p219)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.3 Sorting](index_split_004.html#p220)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.4 Linear Algebra Operations on Vectors and Matrices](index_split_004.html#p222)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.5 Set Operations](index_split_004.html#p228)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8.6 Simulation Programming in R](index_split_004.html#p230)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9: Object-Oriented Programming](index_split_004.html#p233)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.1 S3 Classes](index_split_004.html#p234)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.2 S4 Classes](index_split_004.html#p248)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.3 S3 Versus S4](index_split_004.html#p252)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.4 Managing Your Objects](index_split_004.html#p252)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10: Input/Output](index_split_004.html#p257)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10.1 Accessing the Keyboard and Monitor](index_split_004.html#p258)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10.2 Reading and Writing Files](index_split_005.html#p261)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10.3 Accessing the Internet](index_split_005.html#p272)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11: String Manipulation](index_split_005.html#p277)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11.1 An Overview of String-Manipulation Functions](index_split_005.html#p277)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11.2 Regular Expressions](index_split_005.html#p280)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11.3 Use of String Utilities in the edtdbg Debugging Tool](index_split_005.html#p283)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12: Graphics](index_split_005.html#p287)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12.1 Creating Graphs](index_split_005.html#p287)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12.2 Customizing Graphs](index_split_005.html#p298)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12.3 Saving Graphs to Files](index_split_005.html#p306)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12.4 Creating Three-Dimensional Plots](index_split_005.html#p308)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13: Debugging](index_split_005.html#p311)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.1 Fundamental Principles of Debugging](index_split_005.html#p311)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.2 Why Use a Debugging Tool?](index_split_005.html#p313)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.3 Using R Debugging Facilities](index_split_005.html#p314)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.4 Moving Up in the World: More Convenient DebuggingTools](index_split_006.html#p326)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.5 Ensuring Consistency in Debugging Simulation Code](index_split_006.html#p328)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.6 Syntax and Runtime Errors](index_split_006.html#p329)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.7 Running GDB on R Itself](index_split_006.html#p329)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14: Performance Enhancement: Speed and Memory](index_split_006.html#p331)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.1 Writing Fast R Code](index_split_006.html#p332)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.2 The Dreaded for Loop](index_split_006.html#p332)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.3 Functional Programming and Memory Issues](index_split_006.html#p340)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.4 Using Rprof() to Find Slow Spots in Your Code](index_split_006.html#p342)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.5 Byte Code Compilation](index_split_006.html#p346)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14.6 Oh No, the Data Doesn’t Fit into Memory!](index_split_006.html#p346)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15: Interfacing R to Other Languages](index_split_006.html#p349)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15.1 Writing C/C++ Functions to Be Called from R](index_split_006.html#p349)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15.2 Using R from Python](index_split_006.html#p356)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16: Parallel R](index_split_006.html#p359)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.1 The Mutual Outlinks Problem](index_split_006.html#p359)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.2 Introducing the snow Package](index_split_006.html#p360)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.3 Resorting to C](index_split_006.html#p366)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.4 General Performance Considerations](index_split_006.html#p371)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.5 Debugging Parallel R Code](index_split_006.html#p377)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix A: Installing R](index_split_006.html#p379)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A.1 Downloading R from CRAN](index_split_006.html#p379)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A.2 Installing from a Linux Package Manager](index_split_006.html#p379)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A.3 Installing from Source](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix B: Installing and Using Packages](index_split_006.html#p381)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[B.1 Package Basics](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[B.2 Loading a Package from Your Hard Drive](index_split_006.html#p382)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[B.3 Downloading a Package from the Web](index_split_006.html#p382)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[B.4 Listing the Functions in a Package](index_split_006.html#p384)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_006.html#p385)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UPDATES](index_split_006.html#p401)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
