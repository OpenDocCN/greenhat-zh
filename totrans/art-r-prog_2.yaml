- en: 'That’s right, too. We could go another iteration, but instead, let’s look at
    the last iteration, a place where bugs frequently arise in loops. So, let’s add
    a conditional breakpoint, as follows:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，还可以再迭代一次，但相反，让我们看看最后一次迭代，这是循环中经常出现错误的地方。所以，让我们添加一个条件断点，如下所示：
- en: findruns <- function(x,k) {
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: findruns <- function(x,k) {
- en: n <- length(x)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: runs <- NULL
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- NULL
- en: for (i in 1:(n-k)) {
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n-k)) {
- en: if (all(x[i:(i+k-1)]==1)) runs <- c(runs,i)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: if (all(x[i:(i+k-1)]==1)) runs <- c(runs,i)
- en: 'if (i == n-k) browser() # break in last iteration of loop'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (i == n-k) browser() # 在循环的最后一次迭代中中断'
- en: '}'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(runs)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: return(runs)
- en: '}'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: And now run it again.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行它。
- en: source("findruns.R")
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("findruns.R")
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: 'Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
- en: Browse[1]> i
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 7'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 7'
- en: 'This shows the last iteration was for i = 7\. But the vector is nine elements
    long, and k = 2, so our last iteration should be i = 8\. Some thought then reveals
    that the range in the loop should have been written as follows: for (i in 1:(n-k+1))
    {'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明最后一次迭代是 i = 7。但向量有九个元素长，k = 2，所以我们的最后一次迭代应该是 i = 8。经过一些思考后，我们发现循环中的范围应该写成如下：for
    (i in 1:(n-k+1)) {
- en: By the way, note that the breakpoint that we set using setBreakpoint() is no
    longer valid, now that we’ve replaced the old version of the object findruns.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，请注意，我们现在已经替换了旧的 findruns 对象版本，因此我们使用 setBreakpoint() 设置的断点不再有效。
- en: Subsequent testing (not shown here) indicates the code now works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后续测试（此处未显示）表明代码现在可以正常工作。
- en: Let’s move on to a more complex example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到一个更复杂的例子。
- en: '**13.3.6.2 Debugging Finding City Pairs**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.6.2 调试寻找城市对**'
- en: 'Recall our code in Section 3.4.2, which found the pair of cities with the closest
    distance between them. Here is a buggy version of that code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在 3.4.2 节中的代码，该代码找到了距离最近的城市对。以下是该代码的一个有问题的版本：
- en: '1'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: returns the minimum value of d[i,j], i != j, and the row/col attaining 2
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 d[i,j] 的最小值，i != j，以及达到 2 的行/列
- en: that minimum, for square symmetric matrix d; no special policy on
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平方对称矩阵 d 的最小值，没有特殊策略
- en: '3'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: ties;
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ties;
- en: '4'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: motivated by distance matrices
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由距离矩阵激发
- en: Debugging
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**295**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**295**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '5'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mind <- function(d) {
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: mind <- function(d) {
- en: '6'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: n <- nrow(d)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(d)
- en: '7'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: add a column to identify row number for apply()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为 apply() 添加一个列以标识行号
- en: '8'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: dd <- cbind(d,1:n)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: dd <- cbind(d,1:n)
- en: '9'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: wmins <- apply(dd[-n,],1,imin)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n,],1,imin)
- en: '10'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: wmins will be 2xn, 1st row being indices and 2nd being values
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: wmins 将是 2xn，第一行是索引，第二行是值
- en: '11'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: i <- which.min(wmins[1,])
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[1,])
- en: '12'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: j <- wmins[2,i]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[2,i]
- en: '13'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: return(c(d[i,j],i,j))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(d[i,j],i,j))
- en: '14'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '15'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: finds the location, value of the minimum in a row x
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 x 中找到最小值的定位和值
- en: '17'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: imin <- function(x) {
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: imin <- function(x) {
- en: '18'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: n <- length(x)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: '19'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: i <- x[n]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: i <- x[n]
- en: '20'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: j <- which.min(x[(i+1):(n-1)])
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i+1):(n-1)])
- en: '21'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: return(c(j,x[j]))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(j,x[j]))
- en: '22'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s use R’s debugging tools to find and fix the problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 R 的调试工具来查找和修复问题。
- en: 'We’ll run it first on a small test case:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在一个小测试用例上运行它：
- en: source("cities.R")
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("cities.R")
- en: m <- rbind(c(0,12,5),c(12,0,8),c(5,8,0))
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- rbind(c(0,12,5),c(12,0,8),c(5,8,0))
- en: m
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2] [,3]'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '0'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '12'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '5'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[2,]'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '0'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '[3,]'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '5'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '0'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: mind(m)
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: 'Not an auspicious start! Unfortunately, the error message doesn’t tell us where
    the code blew up. But the debugger will give us that information:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是一个吉祥的开始！不幸的是，错误信息没有告诉我们代码在哪里崩溃。但调试器会给我们这个信息：
- en: options(error=recover)
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=recover)
- en: mind(m)
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: Enter a frame number, or 0 to exit
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个帧号，或 0 退出
- en: '1: mind(m)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '1: mind(m)'
- en: 'Selection: 1'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Selection: 1'
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'Called from: eval(expr, envir, enclos)'
- en: Browse[1]> where
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> where
- en: '**296**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**296**'
- en: Chapter 13
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'where 1: eval(expr, envir, enclos)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 1: eval(expr, envir, enclos)'
- en: 'where 2: eval(quote(browser()), envir = sys.frame(which))'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'where 2: eval(quote(browser()), envir = sys.frame(which))'
- en: 'where 3 at cities.R#13: function ()'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'where 3 at cities.R#13: function ()'
- en: '{'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (.isMethodsDispatchOn()) {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: if (.isMethodsDispatchOn()) {
- en: tState <- tracingState(FALSE)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: tState <- tracingState(FALSE)
- en: '...'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Okay, so the problem occurred in mind() rather than imin() and in particular
    at line 13\. It still could be the fault of imin(), but for now, let’s deal with
    the former.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，问题发生在 mind() 而不是 imin() 中，特别是在第 13 行。这仍然可能是 imin() 的错误，但暂时我们先处理前者。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is another way we could have determined that the blowup occurred on
    line 13\.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还有另一种方法可以确定崩溃发生在第13行。*'
- en: '*We would enter the debugger as before but probe the local variables. We could
    reason* *that if the subscript bounds error had occurred at line 9, then the variable
    wmins would* *not have been set, so querying it would give us an error message
    like* Error: object'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们像以前一样进入调试器，但检查局部变量。我们可以推理* *如果下标界限错误发生在第9行，那么变量wmins就不会被设置，所以查询它将给我们一个像这样的错误消息*
    错误：对象'
- en: '''wmins'' not found. *On the other hand, if the blowup occurred on line 13,
    even j* *would have been set.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '''wmins'' not found. *另一方面，如果崩溃发生在第13行，即使j* *也会被设置。*'
- en: 'Since the error occurred with d[i,j], let’s look at those variables: Browse[1]>
    d'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误发生在d[i,j]，让我们看看这些变量：Browse[1]> d
- en: '[,1] [,2] [,3]'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '0'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '12'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '5'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[2,]'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '0'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '[3,]'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '5'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '0'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Browse[1]> i
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 2'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Browse[1]> j
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> j
- en: '[1] 12'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 12'
- en: This is indeed a problem—d only has three columns, yet j, a column
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个问题——d只有三列，而j是一个列
- en: subscript, is 12\.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下标，是12。
- en: 'Let’s look at the variable from which we gleaned j, wmins:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们从中获得j的变量wmins：
- en: Browse[1]> wmins
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> wmins
- en: '[,1] [,2]'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '2'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[2,]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '12'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '12'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 'If you recall how the code was designed, column k of wmins is supposed to contain
    information about the minimum value in row k of d. So here wmins is saying that
    in the first row (k = 1) of d,(0,12,5), the minimum value is 12, occurring at
    index 2\. But it should be 5 at index 3\. So, something went wrong with this line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得代码是如何设计的，wmins的列k应该包含关于d的第k行最小值的信息。所以在这里，wmins表示在d的第一行（k = 1）中，(0,12,5)的最小值是12，发生在索引2。但应该是索引3的5。所以，这一行出了问题：
- en: wmins <- apply(dd[-n, ], 1, imin)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n, ], 1, imin)
- en: Debugging
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Debugging
- en: '**297**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**297**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: There are several possibilities here. But since ultimately imin() is called,
    we can check them all from within that function. So, let’s set the debug status
    of imin(), quit the debugger, and rerun the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个可能性。但由于最终imin()被调用，我们可以在该函数内部检查它们。所以，让我们设置imin()的调试状态，退出调试器，并重新运行代码。
- en: Browse[1]> Q
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> Q
- en: debug(imin)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: debug(imin)
- en: mind(m)
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'debugging in: FUN(newX[, i], ...)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在：FUN(newX[, i], ...)
- en: 'debug at cities.R#17: {'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.R#17: {'
- en: n <- length(x)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: i <- x[n]
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: i <- x[n]
- en: j <- which.min(x[(i + 1):(n - 1)])
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i + 1):(n - 1)])
- en: return(c(j, x[j]))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(j, x[j]))
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: So, we’re in imin(). Let’s see if it properly received the first row of dd,
    which should be (0,12,5,1).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在imin()中。让我们看看它是否正确接收了dd的第一行，它应该是(0,12,5,1)。
- en: Browse[4]> x
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[4]> x
- en: '[1] 0 12 5 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 12 5 1'
- en: It’s confirmed. This seems to indicate that the first two arguments to apply()
    were correct and that the problem is instead within imin(), though that remains
    to be seen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 已确认。这似乎表明apply()的第一个两个参数是正确的，问题实际上出在imin()中，尽管这一点还需要进一步确认。
- en: 'Let’s single-step through, occasionally typing confirmational queries: Browse[2]>
    n'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们单步执行，偶尔输入确认查询：Browse[2]> n
- en: 'debug at cities.r#17: n <- length(x)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#17: n <- length(x)'
- en: Browse[2]> n
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#18: i <- x[n]'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#18: i <- x[n]'
- en: Browse[2]> n
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#19: j <- which.min(x[(i + 1):(n - 1)])'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#19: j <- which.min(x[(i + 1):(n - 1)])'
- en: Browse[2]> n
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at cities.r#20: return(c(j, x[j]))'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at cities.r#20: return(c(j, x[j]))'
- en: Browse[2]> print(n)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> print(n)
- en: '[1] 4'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4'
- en: Browse[2]> i
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> i
- en: '[1] 1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[2]> j
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> j
- en: '[1] 2'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Recall that we designed our call which.min(x[(i + 1):(n - 1)] to look only at
    the above-diagonal portion of this row. This is because the matrix is symmetric
    and because we don’t want to consider the distance between a city and itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们设计调用which.min(x[(i + 1):(n - 1)])时只查看这一行的上三角部分。这是因为矩阵是对称的，而且我们不希望考虑一个城市与自身的距离。
- en: '**298**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**298**'
- en: Chapter 13
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'But the value j = 2 does not confirm. The minimum value in (0,12,5) is 5, which
    occurs at index 3 of that vector, not index 2\. Thus, the problem is in this line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但j = 2的值没有得到确认。在(0,12,5)中的最小值是5，发生在该向量的索引3，而不是索引2。因此，问题就在这一行：
- en: j <- which.min(x[(i + 1):(n - 1)])
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i + 1):(n - 1)])
- en: What could be wrong?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出了什么问题？
- en: After taking a break, we realize that although the minimum value of (0,12,5)
    occurs at index 3 of that vector, that is *not* what we asked which.min() to find
    for us. Instead, that i + 1 term means we asked for the index of the minimum in
    (12,5), which is 2\.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下后，我们意识到，尽管(0,12,5)的最小值出现在该向量的索引3处，但这**并不是**我们要求which.min()为我们找到的内容。相反，那个i
    + 1项意味着我们要求的是(12,5)中的最小值的索引，即2。
- en: 'We did ask which.min() for the correct information, but we failed to use it
    correctly, because we do want the index of the minimum in (0,12,5). We need to
    adjust the output of which.min() accordingly, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实要求which.min()提供正确的信息，但我们未能正确使用它，因为我们确实想要(0,12,5)中最小值的索引。我们需要相应地调整which.min()的输出，如下所示：
- en: j <- which.min(x[(i+1):(n-1)])
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(x[(i+1):(n-1)])
- en: k <- i + j
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: k <- i + j
- en: return(c(k,x[k]))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(k,x[k]))
- en: We make the fix and try again.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行修复并再次尝试。
- en: mind(m)
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: 'Error in mind(m) : subscript out of bounds'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in mind(m) : subscript out of bounds'
- en: Enter a frame number, or 0 to exit
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个帧号，或0退出
- en: '1: mind(m)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '1: mind(m)'
- en: 'Selection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 选择：
- en: Oh no, *another* bounds error! To see where the blowup occurred this time, we
    issue the where command as before, and we find it was at line 13
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不，**另一个**越界错误！为了看到这次爆炸发生的位置，我们像以前一样发出where命令，我们发现它是在第13行。
- en: again. What about i and j now?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次。现在i和j是什么？
- en: Browse[1]> i
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> i
- en: '[1] 1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[1]> j
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> j
- en: '[1] 5'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5'
- en: The value of j is still wrong; it cannot be larger than 3, as we have only three
    columns in this matrix. On the other hand, i is correct. The overall minimum value
    in dd is 5, occurring in row 1, column 3\.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: j的值仍然不正确；它不能大于3，因为在这个矩阵中我们只有三列。另一方面，i是正确的。在dd中的整体最小值是5，出现在第1行第3列。
- en: 'So, let’s check the source of j again, the matrix wmins:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们再次检查j的来源，即矩阵wmins：
- en: Browse[1]> wmins
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[1]> wmins
- en: '[,1] [,2]'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '3'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '3'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '[2,]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '5'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '8'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: Debugging
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**299**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**299**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Well, there are the 3 and 5 in column 1, just as should be the case.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，列1中的3和5正如预期的那样。
- en: Remember, column 1 here contains the information for row 1 in d, so wmins is
    saying that the minimum value in row 1 is 5, occurring at index 3 of that row,
    which is correct.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里的列1包含d中第1行的信息，所以wmins表示第1行的最小值是5，出现在该行的索引3处，这是正确的。
- en: After taking another break, though, we realize that while wmins is correct,
    our *use* of it isn’t. We have the rows and columns of that matrix mixed up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，休息一下后，我们意识到，虽然wmins是正确的，但我们的**使用**是不正确的。我们混淆了那个矩阵的行和列。
- en: 'This code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码：
- en: i <- which.min(wmins[1,])
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[1,])
- en: j <- wmins[2,i]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[2,i]
- en: 'should be like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是这样的：
- en: i <- which.min(wmins[2,])
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: i <- which.min(wmins[2,])
- en: j <- wmins[1,i]
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: j <- wmins[1,i]
- en: After making that change and resourcing our file, we try it out.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改并重新加载文件后，我们再次尝试。
- en: mind(m)
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mind(m)
- en: '[1] 5 1 3'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5 1 3'
- en: This is correct, and subsequent tests with larger matrices worked, too.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的，并且后续对更大矩阵的测试也成功了。
- en: '**13.4 Moving Up in the World: More Convenient Debugging**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.4 在世界上攀升：更方便的调试**'
- en: '**Tools**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具**'
- en: 'As just seen, R’s debugging tools are effective. However, they’re not very
    convenient. Fortunately, there are various tools that make the process easier.
    In approximate chronological order of development, they are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，R的调试工具是有效的。然而，它们并不非常方便。幸运的是，有一些工具可以使这个过程更容易。按照开发的大致时间顺序，它们如下所示：
- en: •
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The debug package by Mark Bravington
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 马克·布拉文顿的debug包
- en: •
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: My edtdbg package, which works with the Vim and Emacs text editors
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我的edtdbg包，它与Vim和Emacs文本编辑器一起工作
- en: •
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Vitalie Spinu’s ess-tracebug, which runs under Emacs (with the same goals as
    edtdbg but with more Emacs-specific features)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 维塔利·斯皮努的ess-tracebug，它在Emacs下运行（与edtdbg有相同的目标，但具有更多Emacs特定功能）
- en: •
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: REvolution Analytics’ Integrated Development Environment (IDE)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: REvolution Analytics的集成开发环境（IDE）
- en: '**NOTE**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of this writing (July 2011), work is in progress by the teams that develop
    the* *StatET and RStudio IDEs to add debugging tools.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至本文撰写时（2011年7月），开发StatET和RStudio IDE的团队正在进行添加调试工具的工作。*'
- en: All of these tools are cross-platform, working on Linux, Windows, and Mac systems,
    with the exception of the REvolution Analytics product. That IDE is available
    only on Windows systems with Microsoft Visual Studio. All of the tools are open
    source or free, again with the exception of the REvolution Analytics product.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都是跨平台的，可以在Linux、Windows和Mac系统上运行，但REvolution Analytics产品除外。该IDE仅适用于带有Microsoft
    Visual Studio的Windows系统。所有这些工具都是开源的或免费的，但REvolution Analytics产品除外。
- en: So, what do these packages have to offer? To me, one of the biggest problems
    with R’s built-in debugging tools is the lack of a window that shows the big picture—a
    window displaying your R code with a cursor that moves **300**
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些包有什么可以提供的呢？对我来说，R内置调试工具的最大问题之一是缺少一个显示整体情况的窗口——一个显示您的R代码并带有移动光标的窗口——**300**
- en: Chapter 13
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 39](index-327_1.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image 39](index-327_1.png)'
- en: '![Image 40](index-327_2.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Image 40](index-327_2.png)'
- en: 'through the code as you single-step through it. For example, consider this
    excerpt from our previous browser output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单步执行代码时，代码会显示出来。例如，考虑以下我们之前浏览器输出的摘录：
- en: Browse[2]> n
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2] > n
- en: 'debug at cities.r#17: n <- length(x)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '在cities.r#17: n <- length(x)'
- en: Browse[2]> n
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2] > n
- en: 'debug at cities.r#18: i <- x[n]'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '在cities.r#18: i <- x[n]'
- en: This is nice, but where are these lines in our code? Most GUI debuggers for
    other languages feature a window showing the user’s source code, with a symbol
    indicating the next line to be executed. All of the R tools listed at the start
    of this section remedy this lack in core R. The Bravington debug package creates
    a separate window for exactly this purpose. The other tools have your text editor
    double as that window, thus saving space on your screen compared to using debug.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但这些行在我们的代码中的位置在哪里？其他语言的多数GUI调试器都有一个显示用户源代码的窗口，其中有一个符号指示下一个要执行的行。本节开头列出的所有R工具都弥补了R核心中的这一不足。Bravington调试包创建了一个专门用于此目的的单独窗口。其他工具让您的文本编辑器充当那个窗口，从而与使用debug相比节省了屏幕空间。
- en: 'In addition, these tools allow you to set breakpoints and handle other debugging
    operations without moving your screen’s cursor from the editor window to your
    R execution window. This is convenient and saves typing as well, greatly enhancing
    your ability to concentrate on the real task at hand: finding your bugs.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些工具还允许您设置断点并处理其他调试操作，而无需将屏幕光标从编辑器窗口移到R执行窗口。这既方便又节省了输入，大大提高了您专注于手头真正任务的效率：找到您的错误。
- en: Let’s consider the cities example again. I opened the GVim text editor on my
    source file in conjunction with edtdbg, did some startup for edtdbg, and then
    hit the [ (left bracket) key twice to single-step twice through the code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑城市示例。我在GVim文本编辑器中打开了我的源文件，并配合edtdbg使用，为edtdbg进行了一些启动操作，然后按了两次[（左括号）键来单步通过代码。
- en: The resulting GVim window is shown in Figure 13-1\.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的GVim窗口如图13-1所示。
- en: '*Figure 13-1: Source window in edtdbg*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：edtdbg中的源代码窗口*'
- en: Debugging
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**301**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**301**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Operation of edtdbg for Emacs is the same as shown here, just with different
    keystrokes* *used for the commands. For instance, F8 is used for single-stepping
    instead of [.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*edtdbg在Emacs中的操作与这里显示的相同，只是用于命令的快捷键不同。例如，F8用于单步执行而不是[。*'
- en: 'First, note that the editor’s cursor is now on this line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意编辑器的光标现在在这一行：
- en: wmins <- apply(dd[-n, ], 1, imin)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: wmins <- apply(dd[-n, ], 1, imin)
- en: This shows the line to be executed next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了下一个要执行的行。
- en: Whenever I want to single-step a line, I simply hit the [ key while I’m in the
    editor window. The editor then tells the browser to execute its n command, without
    my needing to move the mouse to the R execution window, and then the editor moves
    its cursor to the next line. I can also hit ] for the browser’s c command. Each
    time I execute a line or lines in this manner, the editor’s cursor moves right
    along.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我想要单步执行一行时，我只需在编辑器窗口中按[键。然后编辑器会告诉浏览器执行其n命令，而无需我将鼠标移到R执行窗口，然后编辑器将光标移到下一行。我也可以按]来执行浏览器的c命令。每次我以这种方式执行一行或几行，编辑器的光标就会相应移动。
- en: Whenever I make a change to my source code, typing ,src (the comma
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我对我的源代码进行更改时，输入,src（逗号
- en: is part of the command) into my GVim window will tell R to call source() on
    it. Each time I want to rerun my code, I hit ,dt. I rarely, if ever, need to move
    my mouse away from the editor window to the R window and back.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: （这是命令的一部分）输入到GVim窗口中会告诉R调用source()。每次我想重新运行我的代码时，我都会按,dt。我很少，如果有的话，需要将鼠标从编辑器窗口移到R窗口然后再回来。
- en: In essence, the editor has become my debugger in addition to providing its editing
    operations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，编辑器已经成为了我的调试器，除了提供其编辑操作外。
- en: '**13.5 Ensuring Consistency in Debugging Simulation Code**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.5 确保调试模拟代码的一致性**'
- en: If you’re doing anything with random numbers, you’ll need to be able to reproduce
    the same stream of numbers each time you run your program during the debugging
    session. Without this, your bugs may not be reproducible, making them even harder
    to fix.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在进行任何与随机数相关的工作，您将需要能够在调试会话中每次运行程序时重现相同的数字流。如果没有这一点，您的错误可能无法重现，这使得它们更难修复。
- en: The set.seed() function controls this by reinitializing the random number sequence
    to a given value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.seed()` 函数通过重新初始化随机数序列到给定值来控制这一点。'
- en: 'Consider this example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[1] 0.8811480 0.2853269 0.5864738'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.8811480 0.2853269 0.5864738'
- en: runif(3)
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runif(3)`'
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5775979 0.4588383 0.8354707'
- en: runif(3)
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runif(3)`'
- en: '[1] 0.4155105 0.4852900 0.6591892'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.4155105 0.4852900 0.6591892'
- en: runif(3)
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runif(3)`'
- en: set.seed(8888)
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`set.seed(8888)`'
- en: runif(3)
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runif(3)`'
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5775979 0.4588383 0.8354707'
- en: set.seed(8888)
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`set.seed(8888)`'
- en: runif(3)
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runif(3)`'
- en: '[1] 0.5775979 0.4588383 0.8354707'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5775979 0.4588383 0.8354707'
- en: The call runif(3) generates three random numbers from the uniform
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`runif(3)` 调用生成三个从区间 (0,1) 的均匀分布的随机数。'
- en: distribution on the interval (0,1). Each time we make that call, we will get
    a different set of three numbers. But with set.seed(), we can start over and get
    the same sequence of numbers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用这个函数时，我们都会得到一组不同的三个数字。但通过 `set.seed()`，我们可以从头开始并得到相同的数字序列。
- en: '**302**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**302**'
- en: Chapter 13
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**13.6 Syntax and Runtime Errors**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.6 语法和运行时错误**'
- en: The most common syntax errors will be lack of matching parentheses, brackets,
    braces, or quotation marks. When you encounter a syntax
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的语法错误将是缺少匹配的括号、方括号、花括号或引号。当您遇到语法
- en: error, this is the first thing you should check and double-check. I highly recommend
    that you use a text editor that does parentheses matching and syntax coloring
    for R, such as Vim or Emacs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 错误，这是您应该首先检查并再次检查的第一件事。我强烈建议您使用具有括号匹配和 R 语法高亮的文本编辑器，如 Vim 或 Emacs。
- en: Be aware that often when you get a message saying there is a syntax error on
    a certain line, the error may actually be in a much earlier line.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您收到一条消息说某一行存在语法错误时，错误实际上可能在一个远早的行中。
- en: This can occur with any language, but R seems especially prone to it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这在任何语言中都可能发生，但 R 似乎特别容易发生这种情况。
- en: 'If it just isn’t obvious to you where your syntax error is, I recommend selectively
    commenting out some of your code, better enabling you to pinpoint the location
    of the syntax problem. Generally, it helps to follow a binary search approach:
    Comment out half of your code (being careful to maintain syntax integrity) and
    see if the same error arises. If it does, it’s in the remaining half; otherwise,
    it’s in the half you deleted. Then cut that half in half, and so on.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不清楚语法错误在哪里，我建议您有选择地注释掉一些代码，这样您就能更好地定位语法问题的位置。通常，遵循二分搜索方法是有帮助的：注释掉一半的代码（注意保持语法完整性）并查看是否出现相同的错误。如果出现了，那么错误就在剩下的部分；否则，错误就在您删除的那一半。然后，将那一半再分成两半，依此类推。
- en: 'You may sometimes get messages like the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到如下消息：
- en: There were 50 or more warnings (use warnings() to see the first 50) These should
    be heeded—run warnings() as suggested. The problem
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有 50 或更多的警告（使用 `warnings()` 查看前 50 个）。这些应该被注意——按照建议运行 `warnings()`。问题
- en: 'could range from nonconvergence of an algorithm to misspecification of a matrix
    argument to a function. In many cases, the program output may be invalid, though
    it may well be fine, too, say with this message:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可能从算法的非收敛性到函数矩阵参数的误指定，再到函数。在许多情况下，程序输出可能无效，尽管它可能很好，比如这个消息：
- en: 'Fitted probabilities numerically 0 or 1 occurred in: glm...'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `glm` 中数值概率为 0 或 1 的情况发生了：
- en: 'In some cases, you may find it useful to issue this command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会发现发出此命令很有用：
- en: options(warn=2)
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`options(warn=2)`'
- en: This instructs R to turn warnings into actual errors and makes the locations
    of the warnings easier to find.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 R 将警告转换为实际错误，并使警告的位置更容易找到。
- en: '**13.7 Running GDB on R Itself**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.7 在 R 上运行 GDB**'
- en: This section may be of interest to you even if you are not trying to fix a bug
    in R. For example, you may have written some C code to interface to R (covered
    in Chapter 15) and found it to be buggy. In order to run GDB on that C function,
    you must first run R itself through GDB.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不是在尝试修复 R 中的错误，这一节也可能对您有所帮助。例如，您可能编写了一些 C 代码来与 R 接口（在第 15 章中介绍），并发现它存在错误。为了在
    GDB 上运行那个 C 函数，您必须首先通过 GDB 运行 R 本身。
- en: Or, you may be interested in the internals of R, say to determine how you can
    write efficient R code, and wish to explore the internals by stepping through
    the R source code with a debugging tool such as GDB.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能对 R 的内部结构感兴趣，比如确定如何编写高效的 R 代码，并希望通过调试工具（如 GDB）逐步遍历 R 源代码来探索内部结构。
- en: Debugging
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**303**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**303**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Although you can invoke R through GDB from a shell command line (see Section
    15.1.4), for our purposes here, I suggest using separate windows for R and GDB.
    Here’s the procedure:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从 shell 命令行调用 R（见第 15.1.4 节），但在这里，我建议使用单独的窗口来运行 R 和 GDB。以下是步骤：
- en: 1\.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Start R in one window, as usual.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，在一个窗口中启动 R。
- en: 2\.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: In another window, determine the ID number of your R process. In
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，确定你的 R 进程的 ID 号。在
- en: UNIX family systems, for instance, this is obtained by something like ps -a.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 系统家族，例如，可以通过类似 ps -a 的命令获得。
- en: 3\.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: In that second window, submit GDB’s attach command with the R pro-
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个第二个窗口中，提交 GDB 的 attach 命令与 R 进程一起。
- en: cess number.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 进程号。
- en: 4\.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Submit the continue command to GDB.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 向 GDB 提交继续命令。
- en: You can set breakpoints in the R source code either before continuing or by
    interrupting GDB later with CTRL-C. See Section 15.1.4 for details for debugging
    C code called from R. If, on the other hand, you wish to use GDB
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在继续之前或在 GDB 中使用 CTRL-C 中断后设置 R 源代码中的断点。有关从 R 调用的 C 代码调试的详细信息，请参阅第 15.1.4
    节。另一方面，如果你希望使用 GDB
- en: to explore the R source code, note the following.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 R 源代码时，请注意以下事项。
- en: The R source code is dominated by S expression pointers (SEXPs),
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: R 的源代码主要由 S 表达式指针（SEXPs）组成，
- en: which are pointers to C structs that contain an R variable’s value, type, and
    so on. You can use the R internal function Rf_PrintValue(s) to inspect SEXP
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是指向包含 R 变量值、类型等信息的 C 结构的指针。你可以使用 R 内部函数 Rf_PrintValue(s) 来检查 SEXP
- en: 'values. For example, if the SEXP is named s, then in GDB, type this: call Rf_PrintValue(s)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 值。例如，如果 SEXP 被命名为 s，那么在 GDB 中，输入以下内容：call Rf_PrintValue(s)
- en: This prints the value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印值。
- en: '**304**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**304**'
- en: Chapter 13
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 41](index-331_1.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Image 41](index-331_1.png)'
- en: '**14**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**14**'
- en: '**PERFORMANCE ENHANCEMENT:**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能提升：**'
- en: '**SPEED AND MEMORY**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**速度和内存**'
- en: In computer science curricula, a common
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学课程中，一个常见的
- en: theme is the trade-off between time and
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是时间和
- en: space. In order to have a fast-running pro-
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 空间。为了有一个快速运行的程序，
- en: gram, you may need to use more memory space.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 程序，可能需要使用更多的内存空间。
- en: On the other hand, in order to conserve memory space,
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了节省内存空间，
- en: you might need to settle for slower code. In the R lan-
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要满足于较慢的代码。在 R 语言中，
- en: guage, this trade-off is of particular interest for the fol-
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 语言，这种权衡对以下方面尤其感兴趣：
- en: 'lowing reasons:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下原因：
- en: •
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: R is an interpreted language. Many of the commands are written in C
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一种解释型语言。许多命令是用 C
- en: and thus do run in fast machine code. But other commands, and your
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此确实以快速机器代码运行。但其他命令，以及你的
- en: own R code, are pure R and thus interpreted. So, there is a risk that your R
    application may run more slowly than you would like.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 自己的 R 代码，是纯 R 并因此是解释型的。因此，你的 R 应用程序可能运行得比你希望的慢。
- en: •
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: All objects in an R session are stored in memory. More precisely, all objects
    are stored in R’s memory address space. R places a limit of 231 *−* 1 bytes on
    the size of any object, even on 64-bit machines and even if you have a lot of
    RAM. Yet some applications do encounter
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: R 会话中的所有对象都存储在内存中。更确切地说，所有对象都存储在 R 的内存地址空间中。R 对任何对象的大小限制为 231 *−* 1 字节，即使在 64
    位机器上，即使你有大量的 RAM。然而，一些应用程序确实会遇到
- en: larger objects.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的对象。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This chapter will suggest ways that you can enhance the performance of your
    R code, taking into account the time/space trade-off.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提出你可以提高 R 代码性能的方法，考虑到时间/空间权衡。
- en: '**14.1 Writing Fast R Code**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.1 编写高效的 R 代码**'
- en: 'What can be done to make R code faster? Here are the main tools available to
    you:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使 R 代码更快？以下是你可用的主要工具：
- en: •
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Optimize your R code through vectorization, use of byte-code compilation, and
    other approaches.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向量化、使用字节码编译和其他方法优化你的 R 代码。
- en: •
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Write the key, CPU-intensive parts of your code in a compiled language such
    as C/C++.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码的关键、CPU 密集部分用编译语言（如 C/C++）编写。
- en: •
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Write your code in some form of parallel R.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的代码以某种形式的并行 R 编写。
- en: The first approach will be covered in this chapter, and the other approaches
    are covered in Chapters 15 and 16\.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将在本章中介绍，其他方法将在第 15 章和第 16 章中介绍。
- en: To optimize your R code, you need to understand R’s functional pro-
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化你的 R 代码，你需要理解 R 的函数编程特性。
- en: gramming nature and the way R uses memory.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: gramming nature and the way R uses memory.
- en: '**14.2 The Dreaded for Loop**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.2 可怕的 for 循环**'
- en: The r-help discussion listserv for R often has questions about how to accomplish
    various tasks without for loops. There seems to be a feeling that programmers
    should avoid these loops at all costs.1 Those who pose the queries usually have
    the goal of speeding up their code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: R 的 r-help 讨论列表经常有人询问如何在不使用循环的情况下完成各种任务。似乎有一种感觉，程序员应该不惜一切代价避免这些循环。1 提出问题的人通常的目标是加快他们的代码。
- en: It’s important to understand that simply rewriting code to avoid loops will
    not necessarily make the code faster. However, in some cases, dramatic speedup
    may be attained, usually through vectorization.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，仅仅重写代码以避免循环并不一定会使代码更快。然而，在某些情况下，可以通过向量化获得显著的加速。
- en: '***14.2.1 Vectorization for Speedup***'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.2.1 向量化以加速***'
- en: 'Sometimes, you can use vectorization instead of looping. For example, if x
    and y are vectors of equal lengths, you can write this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可以使用向量化而不是循环。例如，如果 x 和 y 是长度相等的向量，你可以这样写：
- en: z <- x + y
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: z <- x + y
- en: 'This is not only more compact, but even more important, it is faster than using
    this loop:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅更紧凑，更重要的是，它比使用这个循环更快：
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(x)) z[i] <- x[i] + y[i]
- en: 'Let’s do a quick timing comparison:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个快速的计时比较：
- en: x <- runif(1000000)
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- runif(1000000)
- en: y <- runif(1000000)
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- runif(1000000)
- en: 1 By contrast, while loops pose much more of a challenge, because they are difficult
    to vectorize effectively.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 1 与此相反，while 循环提出了更大的挑战，因为它们难以有效地向量化。
- en: '**306**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**306**'
- en: Chapter 14
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: z <- vector(length=1000000)
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- vector(length=1000000)
- en: system.time(z <- x + y)
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z <- x + y)
- en: user system elapsed
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.052'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '0.052'
- en: '0.016'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '0.068'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '0.068'
- en: system.time(for (i in 1:length(x)) z[i] <- x[i] + y[i])
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(for (i in 1:length(x)) z[i] <- x[i] + y[i])
- en: user system elapsed
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '8.088'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '8.088'
- en: '0.044'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '0.044'
- en: '8.175'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '8.175'
- en: What a difference! The version without a loop was more than 120 times faster
    in elapsed time. While timings may vary from one run to another (a second run
    of the loop version had elapsed time of 22.958), in some cases,
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 差异多么大啊！没有循环的版本在运行时间上快了超过 120 倍。虽然运行时间可能因运行而异（循环版本的第二次运行运行时间为 22.958），在某些情况下，
- en: “delooping” R code can really pay off.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: “去循环”R 代码确实可以带来好处。
- en: 'It’s worth discussing some of the sources of slowdown in the loop version.
    What may not be obvious to programmers coming to R from other languages is that
    numerous function calls are involved in the loop version of the previous code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论一下循环版本中减慢速度的一些原因。对于从其他语言转向 R 的程序员来说可能不明显的是，前述代码的循环版本中涉及了大量的函数调用：
- en: •
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Though syntactically the loop looks innocuous, for() is, in fact, a function.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从语法上看循环看起来无害，但实际上 for() 是一个函数。
- en: •
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'The colon : looks even more innocuous, but it’s a function too. For instance,
    1:10 is actually the : function called on the arguments 1'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '冒号 : 看起来更无害，但实际上也是一个函数。例如，1:10 实际上是 : 函数在 1'
- en: 'and 10:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'and 10:'
- en: '":"(1,10)'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '":"(1,10)'
- en: '[1] 1 2 3 4 5 6 7 8 9 10'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 3 4 5 6 7 8 9 10'
- en: •
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Each vector subscript operation represents a function call, with calls to [
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 每个向量索引操作代表一个函数调用，包括对 [
- en: for the two reads and to [<- in the case of the write.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两次读取和写入的情况。
- en: Function calls can be time-consuming, as they involve setting up stack frames
    and the like. Suffering that time penalty at every iteration of the loop adds
    up to a big slowdown.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用可能会消耗时间，因为它们涉及到设置栈帧等。在循环的每次迭代中承受这种时间惩罚会导致速度大幅下降。
- en: By contrast, if we were to write this in C, there would be no function calls.
    Indeed, that is essentially what happens in our first code snippet. There are
    function calls there as well, namely a call to + and one to - *>* , but each is
    called only once, not 1,000,000 times, as in the loop version. Thus, the first
    version of the code is much faster.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们用 C 语言来写这个，就不会有函数调用了。实际上，这正是我们第一个代码片段中发生的事情。那里也有函数调用，即对 + 和对 - *>*
    的调用，但每个只调用了一次，而不是像循环版本那样调用 1,000,000 次。因此，代码的第一个版本要快得多。
- en: 'One type of vectorization is *vector filtering* For instance, let’s rewrite
    our function oddcount() from Section 1.3:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化的一种类型是*向量过滤*。例如，让我们重写第1.3节中的oddcount()函数：
- en: oddcount <- function(x) return(sum(x%%2==1))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: oddcount <- function(x) return(sum(x%%2==1))
- en: There is no explicit loop here, and even though R will internally loop through
    the array, this will be done in native machine code. Again, the anticipated speedup
    does occur.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显式循环，尽管R会内部遍历数组，但这将在本地机器码中完成。再次强调，预期的加速确实发生了。
- en: x <- sample(1:1000000,100000,replace=T)
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- sample(1:1000000,100000,replace=T)
- en: system.time(oddcount(x))
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(oddcount(x))
- en: user system elapsed
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**307**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**307**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '0.012'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '0.012'
- en: '0.000'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.015'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '0.015'
- en: system.time(
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(
- en: +
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '{'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: +
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: c <- 0
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c <- 0
- en: +
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: for (i in 1:length(x))
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(x))
- en: +
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: if (x[i] %% 2 == 1) c <- c+1
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: if (x[i] %% 2 == 1) c <- c+1
- en: +
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: return(c)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: return(c)
- en: +
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '}'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: + )
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: + )
- en: user system elapsed
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.308'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '0.308'
- en: '0.000'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.310'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '0.310'
- en: You might wonder whether it matters in this case, since even the loop version
    of the code took less than a second to run. But if this code had been part of
    an enclosing loop, with many iterations, the difference could be important indeed.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在这种情况下这是否有关系，因为即使循环版本的代码运行时间也少于1秒。但如果这段代码是包含在嵌套循环中的，并且有很多迭代，那么差异确实可能很重要。
- en: Examples of other vectorized functions that may speed up your code
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 可能加快你代码速度的其他向量化函数示例
- en: are ifelse(), which(), where(), any(), all(), cumsum(), and cumprod(). In the
    matrix case, you can use rowSums(), colSums(), and so on. In “all possible combinations”
    types of settings, combin(), outer(), lower.tri(), upper.tri(), or expand.grid()
    may be just what you need.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是ifelse(), which(), where(), any(), all(), cumsum(), 和 cumprod()。在矩阵情况下，你可以使用rowSums(),
    colSums()等等。在“所有可能的组合”类型的设置中，combin(), outer(), lower.tri(), upper.tri(), 或 expand.grid()可能正是你所需要的。
- en: Though apply() eliminates an explicit loop, it is actually implemented in R
    rather than C and thus will usually not speed up your code. However, the other
    apply functions, such as lapply(), can be very helpful in speeding up your code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然apply()消除了显式循环，但实际上它在R中而不是在C中实现，因此通常不会加快你的代码速度。然而，其他apply函数，如lapply()，可以在加快你的代码速度方面非常有帮助。
- en: '***14.2.2 Extended Example: Achieving Better Speed in a Monte Carlo***'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.2.2 扩展示例：在蒙特卡洛中实现更好的速度***'
- en: '***Simulation***'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '***模拟***'
- en: In some applications, simulation code can run for hours, days, or even months,
    so speedup methods are of high interest. Here, we’ll look at two simulation examples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，模拟代码可能需要运行数小时、数天，甚至数月，因此加速方法是高度感兴趣的。在这里，我们将查看两个模拟示例。
- en: 'To begin, let’s consider the following code from Section 8.6:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑第8.6节中的以下代码：
- en: sum <- 0
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- 0
- en: nreps <- 100000
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: nreps <- 100000
- en: for (i in 1:nreps) {
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nreps) {
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 'xy <- rnorm(2) # 生成2个N(0,1)的随机数'
- en: sum <- sum + max(xy)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- sum + max(xy)
- en: '}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: print(sum/nreps)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: print(sum/nreps)
- en: 'Here’s a revision (hopefully faster):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个修订版（希望更快）：
- en: nreps <- 100000
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: nreps <- 100000
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: xymat <- matrix(rnorm(2*nreps),ncol=2)
- en: '**308**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**308**'
- en: Chapter 14
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: maxs <- pmax(xymat[,1],xymat[,2])
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: maxs <- pmax(xymat[,1],xymat[,2])
- en: print(mean(maxs))
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: print(mean(maxs))
- en: 'In this code, we generate all the random variates at once, storing them in
    a matrix xymat, with one (X,Y) pair per row:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们一次性生成所有随机变量，并将它们存储在矩阵xymat中，每行一个(X,Y)对：
- en: xymat <- matrix(rnorm(2*nreps),ncol=2)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: xymat <- matrix(rnorm(2*nreps),ncol=2)
- en: Next, we find all the max(X,Y) values, storing those values in maxs, and then
    simply call mean().
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们找到所有max(X,Y)的值，将这些值存储在maxs中，然后简单地调用mean()。
- en: It’s easier to program, and we believe it will be faster. Let’s check that.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易编程，我们相信它将更快。让我们检查一下。
- en: I had the original code in the file *MaxNorm.R* and the improved version in
    *MaxNorm2.R*.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我在文件*MaxNorm.R*中有原始代码，在*MaxNorm2.R*中有改进版本。
- en: system.time(source("MaxNorm.R"))
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(source("MaxNorm.R"))
- en: '[1] 0.5667599'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5667599'
- en: user system elapsed
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '1.700'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '1.700'
- en: '0.004'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '1.722'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '1.722'
- en: system.time(source("MaxNorm2.R"))
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(source("MaxNorm2.R"))
- en: '[1] 0.5649281'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5649281'
- en: user system elapsed
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.132'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '0.132'
- en: '0.008'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '0.008'
- en: '0.143'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '0.143'
- en: The speedup is dramatic, once again.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 速度提升再次非常显著。
- en: '**NOTE**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We achieved an increase in speed, at the expense of using more memory, by
    keeping our* *random numbers in an array instead of generating and discarding
    them one pair at a* *time. As mentioned earlier, the time/space trade-off is a
    common one in the computing* *world and in the R world in particular.*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们通过将随机数保存在数组中而不是一次生成和丢弃它们来提高速度，但代价是使用更多的内存。如前所述，时间/空间权衡在计算领域以及 R 世界的特定领域是常见的。*'
- en: We attained an excellent speedup in this example, but it was misleadingly easy.
    Let’s look at a slightly more complicated example.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取得了非常好的加速效果，但这是误导性的简单。让我们看看一个稍微复杂一点的例子。
- en: Our next example is a classic exercise from elementary probability
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的例子是初等概率中的一个经典练习
- en: courses. Urn 1 contains ten blue marbles and eight yellow ones. In urn 2, the
    mixture is six blue and six yellow. We draw a marble at random from urn 1, transfer
    it to urn 2, and then draw a marble at random from urn 2\.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉 1 中有十个蓝色弹珠和八个黄色弹珠。在抽屉 2 中，混合物是六个蓝色和六个黄色。我们随机从抽屉 1 中抽取一个弹珠，将其转移到抽屉 2，然后从抽屉
    2 中随机抽取一个弹珠。
- en: 'What is the probability that that second marble is blue? This is easy to find
    analytically, but we’ll use simulation. Here is the straightforward way: 1'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个弹珠是蓝色的概率是多少？这可以通过解析方法轻松找到，但我们将使用模拟。以下是直接的方法：1
- en: perform nreps repetitions of the marble experiment, to estimate
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行 nreps 次弹珠实验，以估计
- en: '2'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: P(pick blue from Urn 2)
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P(从抽屉 2 中抽取蓝色)
- en: '3'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: sim1 <- function(nreps) {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: sim1 <- function(nreps) {
- en: '4'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'nb1 <- 10 # 10 blue marbles in Urn 1'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'nb1 <- 10 # 抽屉 1 中有 10 个蓝色弹珠'
- en: '5'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'n1 <- 18 # number of marbles in Urn 1 at 1st pick'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'n1 <- 18 # 第一次抽取时抽屉 1 中的弹珠数量'
- en: '6'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'n2 <- 13 # number of marbles in Urn 2 at 2nd pick'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'n2 <- 13 # 第二次抽取时抽屉 2 中的弹珠数量'
- en: '7'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: 'count <- 0 # number of repetitions in which get blue from Urn 2'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 'count <- 0 # 从抽屉 2 中获得蓝色的重复次数'
- en: '8'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: for (i in 1:nreps) {
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nreps) {
- en: '9'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'nb2 <- 6 # 6 blue marbles orig. in Urn 2'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'nb2 <- 6 # 抽屉 2 中原本有 6 个蓝色弹珠'
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**309**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**309**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '10'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: pick from Urn 1 and put in Urn 2; is it blue?
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 1 中抽取并放入抽屉 2；它是蓝色的吗？
- en: '11'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: if (runif(1) < nb1/n1) nb2 <- nb2 + 1
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: if (runif(1) < nb1/n1) nb2 <- nb2 + 1
- en: '12'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: pick from Urn 2; is it blue?
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 2 中抽取；它是蓝色的吗？
- en: '13'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: if (runif(1) < nb2/n2) count <- count + 1
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: if (runif(1) < nb2/n2) count <- count + 1
- en: '14'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '15'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: 'return(count/nreps) # est. P(pick blue from Urn 2)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'return(count/nreps) # 估计 P(从抽屉 2 中抽取蓝色)'
- en: '16'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Here is how we can do it without loops, using apply():'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在不使用循环的情况下使用 apply() 来完成它的：
- en: '1'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sim2 <- function(nreps) {
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: sim2 <- function(nreps) {
- en: '2'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: nb1 <- 10
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: nb1 <- 10
- en: '3'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nb2 <- 6
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: nb2 <- 6
- en: '4'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n1 <- 18
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: n1 <- 18
- en: '5'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: n2 <- 13
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: n2 <- 13
- en: '6'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: pre-generate all our random numbers, one row per repetition
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预先生成所有随机数，每重复一次一行
- en: '7'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
- en: '8'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: define simfun for use in apply(); simulates one repetition
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 apply() 定义 simfun；模拟一次重复
- en: '9'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: simfun <- function(rw) {
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: simfun <- function(rw) {
- en: '10'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: rw ("row") is a pair of random numbers
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rw ("行") 是一对随机数
- en: '11'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: choose from Urn 1
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 1 中选择
- en: '12'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: if (rw[1] < nb1/n1) nb2 <- nb2 + 1
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: if (rw[1] < nb1/n1) nb2 <- nb2 + 1
- en: '13'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: choose from Urn 2, and return boolean on choosing blue
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽屉 2 中选择，并返回选择蓝色时的布尔值
- en: '14'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: return (rw[2] < nb2/n2)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: return (rw[2] < nb2/n2)
- en: '15'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '}'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '16'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: z <- apply(u,1,simfun)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: z <- apply(u,1,simfun)
- en: '17'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: z is a vector of booleans but they can be treated as 1s, 0s
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: z 是一个布尔向量，但它们可以被视为 1s 和 0s
- en: '18'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: return(mean(z))
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(z))
- en: '19'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here, we set up a matrix u with two columns of U(0,1) random variates.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置一个矩阵 u，包含两列 U(0,1) 随机变量。
- en: The first column is used for our simulation of drawing from urn 1, and the second
    for drawing from urn 2\. This way, we generate all our random numbers at once,
    which might save a bit of time, but the main point is to set up for using apply().
    Toward that goal, our function simfun() works on one repetition of the experiment—that
    is, one row of u. We set up the call to apply() to go through all of the nreps
    repetitions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列用于我们对抽屉 1 的模拟，第二列用于从抽屉 2 中抽取。这样，我们一次生成所有随机数，这可能节省一点时间，但主要目的是为使用 apply() 准备。为了达到这个目标，我们的
    simfun() 函数在一个实验重复中工作——即 u 的一行。我们设置 apply() 的调用以遍历所有的 nreps 重复。
- en: Note that since the function simfun() is declared within sim2(), the locals
    of sim2()—n1, n2, nb1, and nb2—are available as globals of simfun(). Also, since
    a Boolean vector will automatically be changed by R to 1s and 0s, we can find
    the fraction of TRUE values in the vector by simply calling mean().
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于simfun()函数是在sim2()内部声明的，所以sim2()的局部变量n1、n2、nb1和nb2可以作为simfun()的全局变量使用。此外，由于布尔向量将被R自动转换为1s和0s，我们可以通过简单地调用mean()来找到向量中TRUE值的比例。
- en: Now, let’s compare performance.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较性能。
- en: system.time(print(sim1(100000)))
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim1(100000)))
- en: '[1] 0.5086'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5086'
- en: user system elapsed
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '2.465'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '2.465'
- en: '0.028'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '0.028'
- en: '2.586'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '2.586'
- en: system.time(print(sim2(10000)))
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim2(10000)))
- en: '**310**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**310**'
- en: Chapter 14
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[1] 0.5031'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.5031'
- en: user system elapsed
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '2.936'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '2.936'
- en: '0.004'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '3.027'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '3.027'
- en: In spite of the many benefits of functional programming, this approach using
    apply() didn’t help. Instead, things got worse. Since this could be simply due
    to random sampling variation, I ran the code several times again, with similar
    results.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数式编程有许多好处，但使用apply()的方法并没有帮助。相反，情况变得更糟。这可能是由于随机抽样变异的简单原因，所以我再次运行了代码，结果相似。
- en: So, let’s look at vectorizing this simulation.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何将这个模拟向量化。
- en: '1'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sim3 <- function(nreps) {
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: sim3 <- function(nreps) {
- en: '2'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: nb1 <- 10
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: nb1 <- 10
- en: '3'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nb2 <- 6
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: nb2 <- 6
- en: '4'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n1 <- 18
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: n1 <- 18
- en: '5'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: n2 <- 13
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: n2 <- 13
- en: '6'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: u <- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)
- en: '7'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: set up the condition vector
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置条件向量
- en: '8'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
- en: '9'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: u[,1] > nb1/n1 & u[,2] <= nb2/n2
- en: '10'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: return(mean(cndtn))
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 返回cndtn的平均值
- en: '11'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The main work is done in this statement:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作在这条语句中完成：
- en: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: cndtn <- u[,1] <= nb1/n1 & u[,2] <= (nb2+1)/n2 |
- en: u[,1] > nb1/n1 & u[,2] <= nb2/n2
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: u[,1] > nb1/n1 & u[,2] <= nb2/n2
- en: To get that, we reasoned out which conditions would lead to choosing a blue
    marble on the second pick, coded them, and then assigned them to cndtn.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个结果，我们推理出哪些条件会导致在第二次选择时选择蓝色弹珠，将它们编码，然后将它们分配给cndtn。
- en: 'Remember that *<* = and & are functions; in fact, they are vector functions,
    so they should be fast. Sure enough, this brings quite an improvement:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*<* = 和 & 是函数；实际上，它们是向量函数，所以它们应该很快。确实，这带来了相当大的改进：
- en: system.time(print(sim3(10000)))
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(print(sim3(10000)))
- en: '[1] 0.4987'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.4987'
- en: user system elapsed
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.060'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '0.060'
- en: '0.016'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '0.076'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '0.076'
- en: In principle, the approach we took to speed up the code here could be applied
    to many other Monte Carlo simulations. However, it’s clear that the analog of
    the statement that computes cndtn would quickly become quite complex, even for
    seemingly simple applications.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，我们用来加速代码的方法可以应用于许多其他蒙特卡洛模拟。然而，很明显，计算cndtn的语句的类似物会迅速变得相当复杂，即使对于看似简单的应用也是如此。
- en: Moreover, the approach would not work in “infinite-stage” situations, meaning
    an unlimited number of time steps. Here, we are considering the marble example
    as being two-stage, with two columns to the matrix u.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法在“无限阶段”情况下不会起作用，这意味着无限的时间步数。在这里，我们将弹珠示例视为两阶段，矩阵u有两列。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**311**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**311**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***14.2.3 Extended Example: Generating a Powers Matrix***'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.2.3 扩展示例：生成幂矩阵***'
- en: 'Recall in Section 9.1.7, we needed to generate a matrix of powers of our predictor
    variable. We used the following code:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第9.1.7节，我们需要生成预测变量的幂矩阵。我们使用了以下代码：
- en: '1'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过度dg形成向量x的幂矩阵
- en: '2'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: powers1 <- function(x,dg) {
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: powers1 <- function(x,dg) {
- en: '3'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(x,nrow=length(x))
- en: '4'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'prod <- x # current product'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 'prod <- x # 当前乘积'
- en: '5'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: for (i in 2:dg) {
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '6'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: prod <- prod * x
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '7'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: pw <- cbind(pw,prod)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- cbind(pw,prod)
- en: '8'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '}'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '9'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: return(pw)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: return(pw)
- en: '10'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: One glaring problem is that cbind() is used to build up the output matrix, column
    by column. This is very costly in terms of memory-allocation time. It’s much better
    to allocate the full matrix at the beginning, even though it will be empty, as
    this will mean incurring the cost of only one memory-allocation operation.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是，cbind()被用来按列构建输出矩阵。这在内存分配时间上代价很高。最好一开始就分配整个矩阵，即使它是空的，因为这将意味着只需承担一次内存分配操作的代价。
- en: '1'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过度dg形成向量x的幂矩阵
- en: '2'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: powers2 <- function(x,dg) {
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: powers2 <- function(x,dg) {
- en: '3'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pw <- matrix(nrow=length(x),ncol=dg)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(nrow=length(x),ncol=dg)
- en: '4'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'prod <- x # current product'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 'prod <- x # 当前乘积'
- en: '5'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: pw[,1] <- prod
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: pw[,1] <- prod
- en: '6'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: for (i in 2:dg) {
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '7'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: prod <- prod * x
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '8'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: pw[,i] <- prod
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: pw[,i] <- prod
- en: '9'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '}'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '10'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: return(pw)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: return(pw)
- en: '11'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: And indeed, powers2() is a lot faster.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，powers2() 要快得多。
- en: x <- runif(1000000)
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- runif(1000000)
- en: system.time(powers1(x,8))
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers1(x,8))
- en: user system elapsed
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.776'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '0.776'
- en: '0.356'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '0.356'
- en: '1.334'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '1.334'
- en: system.time(powers2(x,8))
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers2(x,8))
- en: user system elapsed
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.388'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '0.388'
- en: '0.204'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '0.204'
- en: '0.593'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '0.593'
- en: '**312**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**312**'
- en: Chapter 14
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: And yet, powers2() still contains a loop. Can we do better? It would seem that
    this setting is perfect for outer(), whose call form is
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，powers2() 仍然包含一个循环。我们能做得更好吗？这似乎是 outer() 的调用形式完美的设置，其调用形式为
- en: outer(X,Y,FUN)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: outer(X,Y,FUN)
- en: This call applies the function FUN() to all possible pairs of elements of X
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将函数 FUN() 应用到 X 的所有可能元素对上
- en: and elements of Y. The default value of FUN is multiplication.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 Y 的元素。FUN 的默认值是乘法。
- en: 'Here, we can write the following:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以写出以下内容：
- en: powers3 <- function(x,dg) return(outer(x,1:dg,"^"))
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: powers3 <- function(x,dg) return(outer(x,1:dg,"^"))
- en: For each combination of element of x and element of 1:dg (resulting in length(x)
    *×* dg combinations in all), outer() calls the exponentiation function
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 x 的每个元素和 1:dg 的每个元素的组合（总共产生 length(x) *×* dg 个组合），outer() 调用指数函数
- en: ^ on that combination, placing the results in a length(x) *×* dg matrix. This
    is exactly what we need, and as a bonus, the code is quite compact. But is the
    code faster?
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: ^ 在那个组合上，将结果放入一个 length(x) *×* dg 矩阵中。这正是我们需要的，而且作为额外的好处，代码相当紧凑。但代码更快吗？
- en: system.time(powers3(x,8))
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers3(x,8))
- en: user system elapsed
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '1.336'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '1.336'
- en: '0.204'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '0.204'
- en: '1.747'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '1.747'
- en: What a disappointment! Here, we’re using a fancy R function, with very compact
    code, but getting the worst performance of the three functions.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 多么令人失望啊！在这里，我们使用了一个花哨的 R 函数，代码非常紧凑，但三个函数中性能最差。
- en: 'And it gets even worse. Here’s what happens if we try to make use of cumprod():'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 而且情况变得更糟。如果我们尝试使用 cumprod()，会发生什么：
- en: powers4
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: powers4
- en: function(x,dg) {
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: function(x,dg) {
- en: repx <- matrix(rep(x,dg),nrow=length(x))
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: repx <- matrix(rep(x,dg),nrow=length(x))
- en: return(t(apply(repx,1,cumprod)))
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: return(t(apply(repx,1,cumprod)))
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: system.time(powers4(x,8))
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(powers4(x,8))
- en: user system elapsed
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '28.106'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '28.106'
- en: 1.120 83.255
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 1.120 83.255
- en: In this example, we made multiple copies of x, since the powers of a number
    n are simply cumprod(c(1,n,n,n...)). But in spite of dutifully using two C-level
    R functions, the performance was disastrous.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了多个 x 的副本，因为一个数字 n 的幂仅仅是 cumprod(c(1,n,n,n...)) 的累积乘积。但尽管我们尽职尽责地使用了两个
    C 级别的 R 函数，性能仍然非常糟糕。
- en: The moral of the story is that performance issues can be unpredictable.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义在于性能问题可能是不可预测的。
- en: All you can do is be armed with an understanding of the basic issues, vectorization,
    and the memory aspects explained next and then try various approaches.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的就是掌握基本问题、向量化以及接下来解释的内存方面的理解，然后尝试各种方法。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**313**'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**313**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**14.3 Functional Programming and Memory Issues**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.3 函数式编程和内存问题**'
- en: Most R objects are *immutable*, or unchangeable. Thus, R operations are implemented
    as functions that reassign to the given object, a trait that can have performance
    implications.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 R 对象都是 *不可变的*，或者说不可更改的。因此，R 操作是通过将给定对象重新赋值的函数实现的，这种特性可能会对性能产生影响。
- en: '***14.3.1 Vector Assignment Issues***'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.1 向量赋值问题***'
- en: 'As an example of some of the issues that can arise, consider this simple-looking
    statement:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可能出现的一些问题的例子，考虑这个看起来简单的声明：
- en: z[3] <- 8
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: z[3] <- 8
- en: 'As noted in Chapter 7, this assignment is more complex than it seems. It is
    actually implemented via the replacement function "[<-" through this call and
    assignment:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 7 章所述，这个赋值比看起来要复杂。实际上，它是通过这个调用和赋值通过替换函数 "[<-" 实现的：
- en: z <- "[<-"(z,3,value=8)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: z <- "[<-"(z,3,value=8)
- en: An internal copy of z is made, element 3 of the copy is changed to 8, and then
    the resulting vector is reassigned to z. And recall that the latter simply means
    that z is pointed to the copy.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 对 z 的一个内部副本进行了操作，将副本中的第 3 个元素更改为 8，然后将得到的向量重新赋值给 z。记住，后者仅仅意味着 z 指向了副本。
- en: In other words, even though we are ostensibly changing just one element of the
    vector, the semantics say that *the entire vector is recomputed*. For a long vector,
    this would slow down the program considerably. The same would be true for a shorter
    vector if it were assigned from within a loop of our code.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，即使我们表面上只改变向量的一个元素，语义上讲，*整个向量都会被重新计算*。对于长向量，这会显著减慢程序的运行速度。如果是在我们的代码循环中赋值给短向量，情况也会相同。
- en: In some situations, R does take some measures to mitigate this impact, but it
    is a key point to consider when aiming for fast code. You should be mindful of
    this when working with vectors (including arrays). If your code seems to be running
    unexpectedly slowly, assignment of vectors should be a prime area of suspicion.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，R确实采取了一些措施来减轻这种影响，但在追求快速代码时，这是一个需要考虑的关键点。当与向量（包括数组）一起工作时，你应该注意这一点。如果你的代码似乎运行得异常缓慢，向量的赋值应该是一个首要的怀疑对象。
- en: '***14.3.2 Copy-on-Change Issues***'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.2 更改时复制问题***'
- en: 'A related issue is that R (usually) follows a *copy-on-change* policy. For
    instance, if we execute the following in the previous setting:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是，R（通常）遵循*更改时复制*策略。例如，如果我们执行以下操作：
- en: y <- z
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- z
- en: then initially y shares the same memory area with z. But if either of them changes,
    then a copy is made in a different area of memory, and the changed variable will
    occupy the new area of memory. However, only the *first* change is affected, as
    the relocating of the moved variable means there are no longer any sharing issues.
    The function tracemem() will report such memory relocations.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，y与z共享相同的内存区域。但如果有任何一个发生变化，那么就会在内存的不同区域创建一个副本，并且变化后的变量将占用新的内存区域。然而，只有*第一次*变化受到影响，因为移动变量的重新定位意味着不再有任何共享问题。tracemem()函数将报告此类内存重新定位。
- en: '**314**'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**314**'
- en: Chapter 14
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Though R usually adheres to copy-on-change semantics, there are excep-tions.
    For example, R doesn’t exhibit the location-change behavior in the following setting:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管R通常遵循更改时复制的语义，但也有一些例外。例如，R在以下设置中不会显示位置变化的行为：
- en: z <- runif(10)
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- runif(10)
- en: tracemem(z)
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: tracemem(z)
- en: '[1] "<0x88c3258>"'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "<0x88c3258>"'
- en: z[3] <- 8
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z[3] <- 8
- en: tracemem(z)
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: tracemem(z)
- en: '[1] "<0x88c3258>"'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "<0x88c3258>"'
- en: The location of z didn’t change; it was at memory address 0x88c3258
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: z的位置没有变化；它在内存地址0x88c3258
- en: both before and after the assignment to z[3] was executed. Thus, although you
    should be vigilant about location change, you also can’t assume it.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行对z[3]的赋值操作之前和之后。因此，尽管你应该警惕位置变化，但你也不能假设它会发生变化。
- en: Let’s look at the times involved.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涉及的时间。
- en: z <- 1:10000000
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- 1:10000000
- en: system.time(z[3] <- 8)
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z[3] <- 8)
- en: user system elapsed
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0.180'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '0.180'
- en: '0.084'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '0.084'
- en: '0.265'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '0.265'
- en: system.time(z[33] <- 88)
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z[33] <- 88)
- en: user system elapsed
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 系统 运行时间
- en: '0'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: In any event, if copying is done, the vehicle is R’s internal function duplicate().
    (The function is called duplicate1() in recent versions of R.) If you’re familiar
    with the GDB debugging tool and your R build includes debugging information, you
    can explore the circumstances under which a copy is performed.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果进行了复制，那么工具是R的内部函数duplicate()。（在R的较新版本中，该函数被称为duplicate1()。）如果你熟悉GDB调试工具，并且你的R构建包含调试信息，你可以探索执行复制的环境。
- en: 'Following the guide in Section 15.1.4, start up R with GDB, step through R
    through GDB, and place a breakpoint at duplicate1(). Each time you break at that
    function, submit this GDB command:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第15.1.4节中的指南，使用GDB启动R，通过GDB逐步执行R，并在duplicate1()函数处设置断点。每次在该函数处中断时，提交以下GDB命令：
- en: call Rf_PrintValue(s)
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: call Rf_PrintValue(s)
- en: This will print the value of s (or whatever variable is of interest).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印s（或任何感兴趣的变量）的值。
- en: '***14.3.3 Extended Example: Avoiding Memory Copy***'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.3.3 扩展示例：避免内存复制***'
- en: This example, though artificial, will demonstrate the memory-copy issues discussed
    in the previous section.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子，尽管是人为的，将演示上一节中讨论的内存复制问题。
- en: Suppose we have a large number of unrelated vectors and, among other things,
    we wish to set the third element of each to 8\. We could store the vectors in
    a matrix, one vector per row. But since they are unrelated, maybe even of different
    lengths, we may consider storing them in a list.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有许多无关的向量，并且我们希望将每个向量的第三个元素设置为8。我们可以将向量存储在一个矩阵中，每行一个向量。但由于它们是无关的，甚至可能长度不同，我们可能考虑将它们存储在一个列表中。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**315**'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '**315**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: But things can get very subtle when it comes to R performance issues, so let’s
    try it out.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当涉及到R的性能问题时，事情可能会变得非常微妙，所以让我们试试看。
- en: m <- 5000
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- 5000
- en: n <- 1000
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n <- 1000
- en: z <- list()
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- list()
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
- en: system.time(for (i in 1:m) z[[i]][3] <- 8)
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(for (i in 1:m) z[[i]][3] <- 8)
- en: user system elapsed
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 用户系统已用时间
- en: '0.288'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '0.288'
- en: '0.024'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '0.024'
- en: '0.321'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '0.321'
- en: z <- matrix(sample(1:10,m*n,replace=T),nrow=m)
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- matrix(sample(1:10,m*n,replace=T),nrow=m)
- en: system.time(z[,3] <- 8)
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z[,3] <- 8)
- en: user system elapsed
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.008'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '0.008'
- en: '0.044'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '0.044'
- en: '0.052'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '0.052'
- en: Except for system time (again), the matrix formulation did better.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统时间（再次），矩阵公式表现得更好。
- en: One of the reasons is that in the list version, we encounter the memory-copy
    problem in each iteration of the loop. But in the matrix version, we encounter
    it only once. And, of course, the matrix version is vectorized.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个原因是，在列表版本中，我们在循环的每次迭代中都会遇到内存复制问题。但在矩阵版本中，我们只遇到一次。当然，矩阵版本是向量化的。
- en: But what about using lapply() on the list version?
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用lapply()在列表版本上又如何呢？
- en: '>'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: set3 <- function(lv) {
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: set3 <- function(lv) {
- en: +
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: lv[3] <- 8
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: lv[3] <- 8
- en: +
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: return(lv)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: return(lv)
- en: + }
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: + }
- en: z <- list()
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- list()
- en: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: for (i in 1:m) z[[i]] <- sample(1:10,n,replace=T)
- en: system.time(lapply(z,set3))
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(lapply(z,set3))
- en: user system elapsed
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 用户系统已用时间
- en: '0.100'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '0.100'
- en: '0.012'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '0.012'
- en: '0.112'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '0.112'
- en: It’s hard to beat vectorized code.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化代码很难被超越。
- en: '**14.4 Using Rprof() to Find Slow Spots in Your Code**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.4 使用Rprof()查找代码中的慢速区域**'
- en: If you think your R code is running unnecessarily slowly, a handy tool for finding
    the culprit is Rprof(), which gives you a report of (approximately) how much time
    your code is spending in each of the functions it calls. This is important, as
    it may not be wise to optimize *every* section of your program.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你的R代码运行得过于缓慢，一个方便的工具是Rprof()，它可以给你一个报告，显示你的代码在它调用的每个函数中花费了大约多少时间。这很重要，因为优化程序中的每个部分可能并不明智。
- en: Optimization may come at the expense of coding time and code clarity, so it’s
    of value to know where optimization would really help.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 优化可能会以编码时间和代码清晰度为代价，因此了解优化真正能帮助的地方是有价值的。
- en: '***14.4.1 Monitoring with Rprof()***'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.4.1 使用Rprof()进行监控***'
- en: Let’s demonstrate using Rprof() with our three versions of code to find a powers
    matrix from the previous extended example. We’ll call Rprof() to get the monitor
    started, run our code, and then call Rprof() with a NULL
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Rprof()来演示如何使用我们前面扩展示例中的三个版本的代码来找到一个幂矩阵。我们将调用Rprof()来启动监控，运行我们的代码，然后使用NULL调用Rprof()。
- en: '**316**'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '**316**'
- en: Chapter 14
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: argument to stop the monitoring. Finally, we’ll call summaryRprof() to see the
    results.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 停止监控的参数。最后，我们将调用summaryRprof()来查看结果。
- en: x <- runif(1000000)
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- runif(1000000)
- en: Rprof()
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof()
- en: invisible(powers1(x,8))
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: invisible(powers1(x,8))
- en: Rprof(NULL)
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof(NULL)
- en: summaryRprof()
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: summaryRprof()
- en: $by.self
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: $by.self
- en: self.time self.pct total.time total.pct
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: self.time self.pct total.time total.pct
- en: '"cbind"'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '"cbind"'
- en: '0.74'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '86.0'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '86.0'
- en: '0.74'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '86.0'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '86.0'
- en: '"*"'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '"*"'
- en: '0.10'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '0.10'
- en: '11.6'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '11.6'
- en: '0.10'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '0.10'
- en: '11.6'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '11.6'
- en: '"matrix"'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.02'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '2.3'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '2.3'
- en: '0.02'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '2.3'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '2.3'
- en: '"powers1"'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers1"'
- en: '0.00'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '0.86'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '0.86'
- en: '100.0'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: $by.total
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: $by.total
- en: total.time total.pct self.time self.pct
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: total.time total.pct self.time self.pct
- en: '"powers1"'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers1"'
- en: '0.86'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '0.86'
- en: '100.0'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '0.00'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '"cbind"'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '"cbind"'
- en: '0.74'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '86.0'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '86.0'
- en: '0.74'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '86.0'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '86.0'
- en: '"*"'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '"*"'
- en: '0.10'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '0.10'
- en: '11.6'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '11.6'
- en: '0.10'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '0.10'
- en: '11.6'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '11.6'
- en: '"matrix"'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.02'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '2.3'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '2.3'
- en: '0.02'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '2.3'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '2.3'
- en: $sampling.time
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: $sampling.time
- en: '[1] 0.86'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.86'
- en: We see immediately that the runtime of our code is dominated by calls to cbind(),
    which as we noted in the extended example is indeed slowing things down.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即看到，我们的代码运行时间主要受cbind()调用的支配，正如我们在扩展示例中提到的，这确实会减慢速度。
- en: By the way, the call to invisible() in this example is used to suppress output.
    We certainly don’t want to see the 1,000,000-row matrix returned by powers1()
    here!
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这个例子中调用invisible()是为了抑制输出。我们当然不希望看到powers1()返回的1,000,000行矩阵！
- en: Profiling powers2() does not show any obvious bottlenecks.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 对powers2()进行性能分析没有显示出任何明显的瓶颈。
- en: Rprof()
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof()
- en: invisible(powers2(x,8))
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: invisible(powers2(x,8))
- en: Rprof(NULL)
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof(NULL)
- en: summaryRprof()
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: summaryRprof()
- en: $by.self
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: $by.self
- en: self.time self.pct total.time total.pct
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: self.time self.pct total.time total.pct
- en: '"powers2"'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers2"'
- en: '0.38'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '0.38'
- en: '67.9'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '67.9'
- en: '0.56'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '0.56'
- en: '100.0'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '"matrix"'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.14'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '25.0'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: '0.14'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '25.0'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: '"*"'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '"*"'
- en: '0.04'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '0.04'
- en: '7.1'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '7.1'
- en: '0.04'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '0.04'
- en: '7.1'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '7.1'
- en: $by.total
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: $by.total
- en: total.time total.pct self.time self.pct
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: total.time total.pct self.time self.pct
- en: '"powers2"'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers2"'
- en: '0.56'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '0.56'
- en: '100.0'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '0.38'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '0.38'
- en: '67.9'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '67.9'
- en: '"matrix"'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.14'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '25.0'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: '0.14'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '25.0'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: '"*"'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '"*"'
- en: '0.04'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '0.04'
- en: '7.1'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '7.1'
- en: '0.04'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '0.04'
- en: '7.1'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '7.1'
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**317**'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**317**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: $sampling.time
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: $sampling.time
- en: '[1] 0.56'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.56'
- en: What about powers3(), the promising approach that didn’t pan out?
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 powers3() 呢？这是一个有希望但最终没有成功的方案？
- en: Rprof()
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof()
- en: invisible(powers3(x,8))
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: invisible(powers3(x,8))
- en: Rprof(NULL)
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rprof(NULL)
- en: summaryRprof()
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: summaryRprof()
- en: $by.self
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: $by.self
- en: self.time self.pct total.time total.pct
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: self.time self.pct total.time total.pct
- en: '"FUN"'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN"'
- en: '0.94'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '0.94'
- en: '56.6'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '56.6'
- en: '0.94'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '0.94'
- en: '56.6'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '56.6'
- en: '"outer"'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '"outer"'
- en: '0.72'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '0.72'
- en: '43.4'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '43.4'
- en: '1.66'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '1.66'
- en: '100.0'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '"powers3"'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers3"'
- en: '0.00'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '1.66'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '1.66'
- en: '100.0'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: $by.total
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: $by.total
- en: total.time total.pct self.time self.pct
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: total.time total.pct self.time self.pct
- en: '"outer"'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '"outer"'
- en: '1.66'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '1.66'
- en: '100.0'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '0.72'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '0.72'
- en: '43.4'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '43.4'
- en: '"powers3"'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers3"'
- en: '1.66'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '1.66'
- en: '100.0'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '0.00'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '"FUN"'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN"'
- en: '0.94'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '0.94'
- en: '56.6'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '56.6'
- en: '0.94'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '0.94'
- en: '56.6'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '56.6'
- en: $sampling.time
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: $sampling.time
- en: '[1] 1.66'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1.66'
- en: The function logging the largest amount of time was FUN(), which as noted in
    our extended example is simply multiplication. For each pair of elements of x
    here, one of the elements is multiplied by the other; that is, a product of two
    scalars is found. In other words, no vectorization! No wonder it was slow.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 记录耗时最多的函数是 FUN()，正如我们在扩展示例中所提到的，它仅仅是乘法。对于这里 x 的每一对元素，其中一个元素会被另一个元素相乘；也就是说，找到了两个标量的乘积。换句话说，没有使用向量化！难怪它运行得慢。
- en: '***14.4.2 How Rprof() Works***'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.4.2 Rprof() 的工作原理***'
- en: 'Let’s explore in a bit more detail what Rprof() does. Every 0.02 seconds (the
    default value), R inspects the call stack to determine which function calls are
    in effect at that time. It writes the result of each inspection to a file, by
    default *Rprof.out*. Here is an excerpt of that file from our run of powers3():'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下 Rprof() 的作用。每 0.02 秒（默认值），R 会检查调用栈以确定当时哪些函数调用正在生效。它将每次检查的结果写入一个文件，默认为
    *Rprof.out*。以下是 powers3() 运行时该文件的摘录：
- en: '...'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '"outer" "powers3"'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '"outer" "powers3"'
- en: '"outer" "powers3"'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '"outer" "powers3"'
- en: '"outer" "powers3"'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '"outer" "powers3"'
- en: '"FUN" "outer" "powers3"'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN" "outer" "powers3"'
- en: '"FUN" "outer" "powers3"'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN" "outer" "powers3"'
- en: '"FUN" "outer" "powers3"'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN" "outer" "powers3"'
- en: '"FUN" "outer" "powers3"'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN" "outer" "powers3"'
- en: '...'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**318**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**318**'
- en: Chapter 14
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 第 14 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: So, Rprof() often found that at inspection time, powers3() had called outer(),
    which in turn had called FUN(), the latter being the currently executing function.
    The function summaryRprof() conveniently summarizes all those lines in the file,
    but you may find that looking at the file itself reveals more insights in some
    cases.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Rprof() 经常发现，在检查时，powers3() 调用了 outer()，后者又调用了 FUN()，后者是当前正在执行的功能。summaryRprof()
    函数方便地总结了文件中的所有这些行，但你可能会发现，在某些情况下，查看文件本身可以揭示更多见解。
- en: 'Note, too, that Rprof() is no panacea. If the code you’re profiling produces
    many function calls (including indirect calls, triggered when your code calls
    some function that then calls another within R), the profiling output may be hard
    to decipher. This is arguably the case for the output from powers4():'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Rprof() 并非万能。如果你正在分析的代码产生了许多函数调用（包括间接调用，当你的代码调用某个函数时，该函数又调用了另一个 R 函数），那么分析输出可能难以解读。对于
    powers4() 的输出来说，这可能是真的：
- en: $by.self
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: $by.self
- en: self.time self.pct total.time total.pct
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: self.time self.pct total.time total.pct
- en: '"apply"'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '"apply"'
- en: '19.46'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '19.46'
- en: '67.5'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '67.5'
- en: '27.56'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '27.56'
- en: '95.6'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '95.6'
- en: '"lapply"'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '"lapply"'
- en: '4.02'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '4.02'
- en: '13.9'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '13.9'
- en: '5.68'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '5.68'
- en: '19.7'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '19.7'
- en: '"FUN"'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN"'
- en: '2.56'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '2.56'
- en: '8.9'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '8.9'
- en: '2.56'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '2.56'
- en: '8.9'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '8.9'
- en: '"as.vector"'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '"as.vector"'
- en: '0.82'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '0.82'
- en: '2.8'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '2.8'
- en: '0.82'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '0.82'
- en: '2.8'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '2.8'
- en: '"t.default"'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '"t.default"'
- en: '0.54'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '0.54'
- en: '1.9'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '1.9'
- en: '0.54'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '0.54'
- en: '1.9'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '1.9'
- en: '"unlist"'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '"unlist"'
- en: '0.40'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '0.40'
- en: '1.4'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '1.4'
- en: '6.08'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '6.08'
- en: '21.1'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '21.1'
- en: '"!"'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '"!"'
- en: '0.34'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '0.34'
- en: '1.2'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '1.2'
- en: '0.34'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '0.34'
- en: '1.2'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '1.2'
- en: '"is.null"'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '"is.null"'
- en: '0.32'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '0.32'
- en: '1.1'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1'
- en: '0.32'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '0.32'
- en: '1.1'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1'
- en: '"aperm"'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '"aperm"'
- en: '0.22'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: '0.22'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: '"matrix"'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.14'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '0.5'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '0.5'
- en: '0.74'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '2.6'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '2.6'
- en: '"!="'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '"!="'
- en: '0.02'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '0.1'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '0.1'
- en: '0.02'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '0.1'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '0.1'
- en: '"powers4"'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers4"'
- en: '0.00'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '28.84'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '28.84'
- en: '100.0'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '"t"'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '"t"'
- en: '0.00'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '28.10'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '28.10'
- en: '97.4'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '97.4'
- en: '"array"'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '"array"'
- en: '0.00'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '0.22'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: $by.total
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: $by.total
- en: total.time total.pct self.time self.pct
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: total.time total.pct self.time self.pct
- en: '"powers4"'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '"powers4"'
- en: '28.84'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '28.84'
- en: '100.0'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '100.0'
- en: '0.00'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '"t"'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '"t"'
- en: '28.10'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '28.10'
- en: '97.4'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '97.4'
- en: '0.00'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '"apply"'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '"apply"'
- en: '27.56'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '27.56'
- en: '95.6'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '95.6'
- en: '19.46'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '19.46'
- en: '67.5'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '67.5'
- en: '"unlist"'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '"unlist"'
- en: '6.08'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '6.08'
- en: '21.1'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '21.1'
- en: '0.40'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '0.40'
- en: '1.4'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '1.4'
- en: '"lapply"'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '"lapply"'
- en: '5.68'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '5.68'
- en: '19.7'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '19.7'
- en: '4.02'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '4.02'
- en: '13.9'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '13.9'
- en: '"FUN"'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '"FUN"'
- en: '2.56'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '2.56'
- en: '8.9'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '8.9'
- en: '2.56'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '2.56'
- en: '8.9'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '8.9'
- en: '"as.vector"'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '"as.vector"'
- en: '0.82'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '0.82'
- en: '2.8'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '2.8'
- en: '0.82'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '0.82'
- en: '2.8'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '2.8'
- en: '"matrix"'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '"matrix"'
- en: '0.74'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '0.74'
- en: '2.6'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '2.6'
- en: '0.14'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '0.14'
- en: '0.5'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '0.5'
- en: '"t.default"'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '"t.default"'
- en: '0.54'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '0.54'
- en: '1.9'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '1.9'
- en: '0.54'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '0.54'
- en: '1.9'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '1.9'
- en: '"!"'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '"!"'
- en: '0.34'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '0.34'
- en: '1.2'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '1.2'
- en: '0.34'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '0.34'
- en: '1.2'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '1.2'
- en: '"is.null"'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '"is.null"'
- en: '0.32'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '0.32'
- en: '1.1'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1'
- en: '0.32'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '0.32'
- en: '1.1'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1'
- en: '"aperm"'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '"aperm"'
- en: '0.22'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: '0.22'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: '"array"'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '"array"'
- en: '0.22'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '0.22'
- en: '0.8'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '0.8'
- en: '0.00'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '0.00'
- en: '0.0'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: '"!="'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '"!="'
- en: '0.02'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '0.1'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '0.1'
- en: '0.02'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '0.02'
- en: '0.1'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '0.1'
- en: $sampling.time
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: $sampling.time
- en: '[1] 28.84'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 28.84'
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**319**'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '**319**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**14.5 Byte Code Compilation**'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.5 字节码编译**'
- en: Starting with version 2.13, R has included a *byte code compiler*, which you
    can use to try to speed up your code. Consider our example from Section 14.2.1\.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.13开始，R已经包含了一个*字节码编译器*，你可以用它来尝试加速你的代码。考虑我们第14.2.1节中的例子。
- en: As a trivial example, we showed that
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，我们展示了
- en: z <- x + y
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: z <- x + y
- en: was much faster than
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 比以下代码快得多
- en: for (i in 1:length(x)) z[i] <- x[i] + y[i]
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(x)) z[i] <- x[i] + y[i]
- en: 'Again, that was obvious, but just to get an idea of how byte code compilation
    works, let’s give it a try:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是显而易见的，但为了了解字节码编译是如何工作的，让我们试一试：
- en: library(compiler)
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(compiler)
- en: f <- function() for (i in 1:length(x)) z[i] <<- x[i] + y[i]
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f <- function() for (i in 1:length(x)) z[i] <<- x[i] + y[i]
- en: cf <- cmpfun(f)
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf <- cmpfun(f)
- en: system.time(cf())
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(cf())
- en: user system elapsed
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户系统耗时
- en: '0.845'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '0.845'
- en: '0.003'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '0.003'
- en: '0.848'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '0.848'
- en: We created a new function, cf(), from the original f(). The new code’s run time
    was 0.848 seconds, much faster than the 8.175 seconds the non-compiled version
    took. Granted, it still wasn’t as fast as the straightforward vectorized code,
    but it is clear that byte code compilation has potential. You should try it whenever
    you need faster code.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从原始的f()函数创建了一个新的函数cf()。新代码的运行时间为0.848秒，比非编译版本的8.175秒快得多。诚然，它仍然没有像直接向量化的代码那样快，但很明显，字节码编译有潜力。当你需要更快的代码时，你应该尝试它。
- en: '**14.6 Oh No, the Data Doesn’t Fit into Memory!**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.6 哎呀，数据放不进内存！**'
- en: As mentioned earlier, all objects in an R session are stored in memory. R
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，R会话中的所有对象都存储在内存中。R
- en: places a limit of 231 *−* 1 bytes on the size of any object, regardless of word
    size (32-bit versus 64-bit) and the amount of RAM in your machine. However, you
    really should not consider this an obstacle. With a little extra care, applications
    that have large memory requirements can indeed be handled well in R. Some common
    approaches are chunking and using R packages for memory management.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何对象的大小设置限制为231 *−* 1字节，无论字长（32位与64位）以及机器中的RAM量。然而，你真的不应该把它看作是一个障碍。只要稍微多加小心，具有大量内存需求的应用程序确实可以在R中得到很好的处理。一些常见的方法是分块和使用R包进行内存管理。
- en: '***14.6.1 Chunking***'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.6.1 分块***'
- en: One option involving no extra R packages at all is to read in your data from
    a disk file one chunk at a time. For example, suppose that our goal is to find
    means or proportions of some variables. We can use the skip argument in read.table().
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不涉及任何额外R包的选项是从磁盘文件一次读取一个数据块。例如，假设我们的目标是找到一些变量的均值或比例。我们可以使用read.table()中的skip参数。
- en: Say our data set has 1,000,000 records and we divide them into 10
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据集有1,000,000条记录，我们将它们分成10
- en: chunks (or more—whatever is needed to cut the data down to a size so it fits
    in memory). Then we set skip = 0 on our first read, set skip = 100000
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 块（或更多—— whatever is needed to cut the data down to a size so it fits in memory）。然后我们在第一次读取时设置skip
    = 0，第二次设置skip = 100000
- en: the second time, and so on. Each time we read in a chunk, we calculate **320**
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次读取时，以此类推。每次读取一个块时，我们计算**320**
- en: Chapter 14
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: the counts or totals for that chunk and record them. After reading all the chunks,
    we add up all the counts or totals in order to calculate our grand means or proportions.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 记录该块的数量或总和，并将它们记录下来。在读取所有块之后，我们将所有数量或总和加起来，以便计算我们的总体均值或比例。
- en: As another example, suppose we are performing a statistical operation, say calculating
    principle components, in which we have a huge number of rows—that is, a huge number
    of observations—but the number of variables is manageable. Again, chunking could
    be the solution. We apply the statistical operation to each chunk and then average
    the results over all the chunks. My mathematical research shows that the resulting
    estimators are statistically efficient in a wide class of statistical methods.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，假设我们正在进行一个统计操作，比如计算主成分，其中我们有一大批行——也就是说，有大量观测值——但变量的数量是可管理的。再次强调，分块可能是解决方案。我们将统计操作应用于每个块，然后对所有块的结果进行平均。我的数学研究显示，这些结果估计量在广泛的统计方法中在统计上是有效的。
- en: '***14.6.2 Using R Packages for Memory Management***'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '***14.6.2 使用R包进行内存管理***'
- en: Again looking at a bit more sophistication, there are alternatives for accommodating
    large memory requirements in the form of some specialized R
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑更复杂的例子，有一些替代方案可以用来适应大内存需求，形式是一些专门的R
- en: packages.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: packages.
- en: One such package is RMySQL, an R interface to SQL databases. Using it requires
    some database expertise, but this package provides a much more efficient and convenient
    way to handle large data sets. The idea is to have SQL do its variable/case selection
    operations for you back at the database end and then read the resulting selected
    data as it is produced by SQL.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个包是RMySQL，它是SQL数据库的R接口。使用它需要一些数据库专业知识，但这个包提供了处理大型数据集的更高效和更方便的方法。想法是在数据库端让SQL为你执行变量/情况选择操作，然后读取由SQL产生的所选数据。
- en: Since the latter will typically be much smaller than the overall data set, you
    will likely be able to circumvent R’s memory restriction.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后者通常比整体数据集小得多，你可能会绕过R的内存限制。
- en: 'Another useful package is biglm, which does regression and generalized linear-model
    analysis on very large data sets. It also uses chunking but in a different manner:
    Each chunk is used to update the running totals of sums needed for the regression
    analysis and then discarded.'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的包是biglm，它对非常大的数据集进行回归和广义线性模型分析。它也使用分块，但方式不同：每个块用于更新回归分析所需的运行总和，然后被丢弃。
- en: Finally, some packages do their own storage management indepen-
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些包自己进行存储管理独立于
- en: dently of R and thus can deal with very large data sets. The two most commonly
    used today are ff and bigmemory. The former sidesteps memory constraints by storing
    data on disk instead of memory, essentially transparently to the programmer. The
    highly versatile bigmemory package does the same, but it can store data not only
    on disk but also in the machine’s main memory, which is ideal for multicore machines.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于R，因此可以处理非常大的数据集。目前最常用的两个是ff和bigmemory。前者通过在磁盘上而不是内存中存储数据来规避内存限制，对程序员来说几乎是透明的。功能极其丰富的bigmemory包做同样的事情，但它不仅可以存储在磁盘上，还可以存储在机器的主内存中，这对于多核机器来说非常理想。
- en: 'Performance Enhancement: Speed and Memory'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升：速度和内存
- en: '**321**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**321**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 42](index-349_1.png)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![图像42](index-349_1.png)'
- en: '**15**'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**INTERFACING R TO OTHER**'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '**将R连接到其他**'
- en: '**LANGUAGES**'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言**'
- en: R is a great language, but it can’t do every-
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: R是一种伟大的语言，但它不能做每一件事
- en: thing well. Thus, it is sometimes desirable
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 事情处理得很好。因此，有时是可取的
- en: to call code written in other languages from
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他语言中调用代码
- en: R. Conversely, when working in other great lan-
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: R。相反，当在其他伟大的语言中工作时
- en: guages, you may encounter tasks that could be better
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 语言，你可能会遇到一些任务，这些任务可能更适合
- en: done in R.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中完成。
- en: R interfaces have been developed for a number of other languages,
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为许多其他语言开发了R接口，
- en: 'from ubiquitous languages like C to esoteric ones like the Yacas computer algebra
    system. This chapter will cover two interfaces: one for calling C/C++ from R and
    the other for calling R from Python.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 从无处不在的语言如C到晦涩难懂的语言如Yacas计算机代数系统。本章将介绍两个接口：一个是从R调用C/C++的接口，另一个是从Python调用R的接口。
- en: '**15.1 Writing C/C++ Functions to Be Called from R**'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.1 编写从R调用的C/C++函数**'
- en: You may wish to write your own C/C++ functions to be called from R. Typically,
    the goal is performance enhancement, since C/C++ code may run much faster than
    R, even if you use vectorization and other R optimization techniques to speed
    things up.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望编写自己的C/C++函数，以便从R中调用。通常，目标是性能提升，因为C/C++代码可能比R运行得更快，即使你使用向量化和其他R优化技术来加速。
- en: Another possible goal in dropping down to the C/C++ level is specialized I/O.
    For example, R uses the TCP protocol in layer 3 of the standard Internet communication
    system, but UDP can be faster in some settings.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 降低到C/C++级别的另一个可能目标是专门的I/O。例如，R在标准互联网通信系统的第3层使用TCP协议，但在某些设置中UDP可能更快。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: To work in UDP, you need C/C++, which requires an interface to R for those languages.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用UDP时，你需要C/C++，这些语言需要与R的接口。
- en: R actually offers two C/C++ interfaces via the functions .C() and
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: R实际上通过函数 .C() 和
- en: .Call(). The latter is more versatile but requires some knowledge of R’s internal
    structures, so we’ll stick with .C() here.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: .Call(). 后者更灵活，但需要了解R的内部结构，所以我们在这里坚持使用 .C()。
- en: '***15.1.1 Some R-to-C/C++ Preliminaries***'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.1 一些R到C/C++的初步知识***'
- en: In C, two-dimensional arrays are stored in row-major order, in contrast to R’s
    column-major order. For instance, if you have a 3-by-4 array, the element in the
    second row and second column is element number 5 of the array when viewed linearly,
    since there are three elements in the first column and this is the second element
    in the second column. Also keep in mind that C subscripts begin at 0, rather than
    at 1, as with R.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，二维数组以行主序存储，这与 R 的列主序相反。例如，如果您有一个 3x4 的数组，当线性查看时，第二行第二列的元素是数组的第 5 个元素，因为第一列有三个元素，这是第二列的第二元素。还要记住，C
    的索引从 0 开始，而不是像 R 那样从 1 开始。
- en: All the arguments passed from R to C are received by C as pointers.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从 R 传递到 C 的参数都以指针的形式接收。
- en: Note that the C function itself must return void. Values that you would ordinarily
    return must be communicated through the function’s arguments, such as result in
    the following example.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C 函数本身必须返回 void。您通常返回的值必须通过函数的参数传递，例如以下示例中的 result。
- en: '***15.1.2 Example: Extracting Subdiagonals from a Square Matrix***'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.2 示例：从方阵中提取子对角线***'
- en: Here, we will write C code to extract subdiagonals from a square matrix.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写 C 代码以从方阵中提取子对角线。
- en: '(Thanks to my former graduate assistant, Min-Yu Huang, who wrote an earlier
    version of this function.) Here’s the code for the file *sd.c*:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: (感谢我的前研究生助理，黄敏宇，他编写了这个函数的早期版本。) 这是文件 *sd.c* 的代码：
- en: '#include <R.h> // required'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h> // 必需'
- en: '// arguments:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: // 参数：
- en: //
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'm: a square matrix'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 'm: 一个方阵'
- en: //
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'n: number of rows/columns of m'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 'n: m 的行/列数'
- en: //
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'k: the subdiagonal index--0 for main diagonal, 1 for first'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 'k: 子对角线索引--主对角线为 0，第一个子对角线为 1'
- en: //
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: subdiagonal, 2 for the second, etc.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 子对角线，第二个子对角线为 2，等等。
- en: //
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'result: space for the requested subdiagonal, returned here'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'result: 请求的子对角线空间，此处返回'
- en: void subdiag(double *m, int *n, int *k, double *result)
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: void subdiag(double *m, int *n, int *k, double *result)
- en: '{'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int nval = *n, kval = *k;
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: int nval = *n, kval = *k;
- en: int stride = nval + 1;
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: int stride = nval + 1;
- en: for (int i = 0, j = kval; i < nval-kval; ++i, j+= stride)
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0, j = kval; i < nval-kval; ++i, j+= stride)
- en: result[i] = m[j];
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: result[i] = m[j];
- en: '}'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The variable stride alludes to a concept from the parallel-processing community.
    Say we have a matrix in 1,000 columns and our C code is looping through all the
    elements in a given column, from top to bottom. Again, since C uses row-major
    order, consecutive elements in the column are 1,000
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 stride 暗示了并行处理社区中的一个概念。比如说我们有一个 1,000 列的矩阵，我们的 C 代码正在遍历给定列中的所有元素，从上到下。再次强调，由于
    C 使用行主序，如果将矩阵视为一个长向量，则连续元素之间相隔 1,000 个元素。
- en: elements apart from each other if the matrix is viewed as one long vector.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: elements apart from each other if the matrix is viewed as one long vector.
- en: '**324**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**324**'
- en: Chapter 15
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Here, we would say that we are traversing that long vector with a stride of
    1,000—that is, accessing every thousandth element.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们会说我们以 1,000 的步长遍历这个长向量--也就是说，访问每千个元素。
- en: '***15.1.3 Compiling and Running Code***'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.3 编译和运行代码***'
- en: 'You compile your code using R. For example, in a Linux terminal window, we
    could compile our file like this:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 R 编译您的代码。例如，在 Linux 终端窗口中，我们可以像这样编译我们的文件：
- en: '% R CMD SHLIB sd.c'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '% R CMD SHLIB sd.c'
- en: gcc -std=gnu99 -I/usr/share/R/include
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -I/usr/share/R/include
- en: -fpic -g -O2 -c sd.c -o sd.o
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: -fpic -g -O2 -c sd.c -o sd.o
- en: gcc -std=gnu99 -shared -o sd.so sd.o
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -shared -o sd.so sd.o
- en: -L/usr/lib/R/lib -lR
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: -L/usr/lib/R/lib -lR
- en: This would produce the dynamic shared library file *sd.so*.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成动态共享库文件 *sd.so*。
- en: Note that R has reported how it invoked GCC in the output of the example. You
    can also run these commands by hand if you have special requirements, such as
    special libraries to be linked in. Also note that the locations of the *include*
    and *lib* directories may be system-dependent.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 R 在示例输出中报告了如何调用 GCC。如果您有特殊要求，例如需要链接的特殊库，您也可以手动运行这些命令。另外，请注意 *include* 和
    *lib* 目录的位置可能取决于系统。
- en: '**NOTE**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*GCC is easily downloadable for Linux systems. For Windows, it is included
    in* *Cygwin, an open source package available from* http://www.cygwin.com/ *.*'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCC 对于 Linux 系统很容易下载。对于 Windows，它包含在 *Cygwin* 中，这是一个可以从 *http://www.cygwin.com/*
    获取的开源软件包。*'
- en: 'We can then load our library into R and call our C function like this:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的库加载到 R 中，并像这样调用我们的 C 函数：
- en: dyn.load("sd.so")
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("sd.so")
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
- en: k <- 2
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k <- 2
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))
- en: '[[1]]'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1]]'
- en: '[1] 1 6 11 16 21 2 7 12 17 22 3 8 13 18 23 4 9 14 19 24 5 10 15 20 25'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 6 11 16 21 2 7 12 17 22 3 8 13 18 23 4 9 14 19 24 5 10 15 20 25'
- en: '[[2]]'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2]]'
- en: '[1] 5'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5'
- en: '[[3]]'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3]]'
- en: '[1] 2'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: $result
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: $result
- en: '[1] 11 17 23'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 11 17 23'
- en: For convenience here, we’ve given the name result to both the formal argument
    (in the C code) and the actual argument (in the R code). Note that we needed to
    allocate space for result in our R code.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们给形式参数（在 C 代码中）和实际参数（在 R 代码中）都命名为 result。请注意，我们需要在我们的 R 代码中为 result
    分配空间。
- en: As you can see from the example, the return value takes on the form of a list
    consisting of the arguments in the R call. In this case, the call had four arguments
    (in addition to the function name), so the returned list has four components.
    Typically, some of the arguments will be changed during execution of the C code,
    as was the case here with result.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，返回值采用由 R 调用中的参数组成的列表形式。在这种情况下，调用有四个参数（除了函数名之外），因此返回的列表有四个部分。通常，一些参数在 C
    代码执行过程中会发生变化，就像这里的 result 一样。
- en: Interfacing R to Other Languages
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 将 R 与其他语言接口
- en: '**325**'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '**325**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***15.1.4 Debugging R/C Code***'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.4 R/C 代码调试***'
- en: Chapter 13 discussed a number of tools and methods for debugging R code.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章讨论了调试 R 代码的许多工具和方法。
- en: However, the R/C interface presents an extra challenge. The problem in using
    a debugging tool such as GDB here is that you must first apply it to R
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，R/C 接口提出了额外的挑战。在这里使用像 GDB 这样的调试工具的问题是你必须首先将其应用于 R
- en: itself.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 本身。
- en: The following is a walk-through of the R/C debugging steps using GDB
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用 GDB 进行 R/C 调试步骤的概述
- en: on our previous *sd.c* code as the example.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的 *sd.c* 代码为例。
- en: $ R -d gdb
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: $ R -d gdb
- en: GNU gdb 6.8-debian
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: GNU gdb 6.8-debian
- en: '...'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: (gdb) run
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) run
- en: 'Starting program: /usr/lib/R/bin/exec/R'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 开始程序：/usr/lib/R/bin/exec/R
- en: '...'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: dyn.load("sd.so")
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("sd.so")
- en: '>'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: hit ctrl-c here
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在这里按 Ctrl-C
- en: Program received signal SIGINT, Interrupt.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 程序收到信号 SIGINT，中断。
- en: 0xb7ffa430 in __kernel_vsyscall ()
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 0xb7ffa430 in __kernel_vsyscall ()
- en: (gdb) b subdiag
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) b subdiag
- en: 'Breakpoint 1 at 0xb77683f3: file sd.c, line 3\.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 断点 1 在 0xb77683f3：文件 sd.c，行 3。
- en: (gdb) continue
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) continue
- en: Continuing.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行。
- en: Breakpoint 1, subdiag (m=0x92b9480, n=0x9482328, k=0x9482348, result=0x9817148)
    at sd.c:3
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 断点 1，subdiag (m=0x92b9480, n=0x9482328, k=0x9482348, result=0x9817148) 在 sd.c:3
- en: '3'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: int nval = *n, kval = *k;
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: int nval = *n, kval = *k;
- en: (gdb)
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb)
- en: So, what happened in this debugging session?
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这次调试过程中发生了什么？
- en: 1\.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: We launched the debugger, GDB, with R loaded into it, from a com-
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从命令行窗口启动了调试器 GDB，其中包含了加载了 R 的 GDB：
- en: 'mand line in a terminal window:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口的命令行中：
- en: R -d gdb
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: R -d gdb
- en: 2\.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: 'We told GDB to run R:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 GDB 运行 R：
- en: (gdb) run
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) run
- en: 3\.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: 'We loaded our compiled C code into R as usual:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样将编译好的 C 代码加载到 R 中：
- en: dyn.load("sd.so")
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("sd.so")
- en: 4\.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: We hit the CTRL-C interrupt key pair to pause R and put us back at the GDB prompt.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按下了 CTRL-C 中断键对来暂停 R 并回到 GDB 提示符。
- en: 5\.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: 'We set a breakpoint at the entry to subdiag():'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 subdiag() 的入口处设置了断点：
- en: (gdb) b subdiag
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) b subdiag
- en: '**326**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**326**'
- en: Chapter 15
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 6\.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: 'We told GDB to resume executing R (we needed to hit the ENTER key a second
    time in order to get the R prompt):'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 GDB 继续执行 R（我们需要再次按回车键以获得 R 提示符）：
- en: (gdb) continue
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) continue
- en: 'We then executed our C code:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后执行我们的 C 代码：
- en: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- rbind(1:5, 6:10, 11:15, 16:20, 21:25)
- en: k <- 2
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k <- 2
- en: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k),
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k),
- en: + result=double(dim(m)[1]-k))
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: + result=double(dim(m)[1]-k))
- en: Breakpoint 1, subdiag (m=0x942f270, n=0x96c3328, k=0x96c3348, result=0x9a58148)
    at subdiag.c:46
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 断点 1，subdiag (m=0x942f270, n=0x96c3328, k=0x96c3348, result=0x9a58148) 在 subdiag.c:46
- en: 46 if (*n < 1) error("n < 1\n");
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 46 if (*n < 1) error("n < 1\n");
- en: At this point, we can use GDB to debug as usual. If you’re not familiar with
    GDB, you may want to try one of the many quick tutorials on the Web.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以像往常一样使用 GDB 进行调试。如果你不熟悉 GDB，你可能想尝试网上众多的快速教程之一。
- en: Table 15-1 lists some of the most useful commands.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1 列出了一些最有用的命令。
- en: '**Table 15-1:** Common GDB Commands'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：常见的 GDB 命令**'
- en: '**Command**'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**'
- en: '**Description**'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**'
- en: l
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: l
- en: List code lines
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 列出代码行
- en: b
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: Set breakpoint
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点
- en: r
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: r
- en: Run/rerun
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行/重新运行
- en: n
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: Step to next statement
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到下一个语句
- en: s
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: Step into function call
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 进入函数调用
- en: p
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: p
- en: Print variable or expression
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 打印变量或表达式
- en: c
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: Continue
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 继续
- en: h
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: h
- en: Help
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助
- en: q
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: q
- en: Quit
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 退出
- en: '***15.1.5 Extended Example: Prediction of Discrete-Valued Time Series***'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.1.5 扩展示例：离散值时间序列的预测***'
- en: 'Recall our example in Section 2.5.2 where we observed 0- and 1-valued data,
    one per time period, and attempted to predict the value in any period from the
    previous k values, using majority rule. We developed two competing functions for
    the job, preda() and predb(), as follows:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们在 2.5.2 节中的例子，我们观察了 0 和 1 值的数据，每个时间周期一个值，并尝试使用多数规则从之前的 k 个值中预测任何周期的值。我们为此开发了两个竞争性的函数，preda()
    和 predb()，如下所示：
- en: prediction in discrete time series; 0s and 1s; use k consecutive
  id: totrans-1292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prediction in discrete time series; 0s and 1s; use k consecutive
- en: observations to predict the next, using majority rule; calculate the
  id: totrans-1293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: observations to predict the next, using majority rule; calculate the
- en: error rate
  id: totrans-1294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: error rate
- en: preda <- function(x,k) {
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: preda <- function(x,k) {
- en: n <- length(x)
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: k2 <- k/2
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: the vector pred will contain our predicted values
  id: totrans-1298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: the vector pred will contain our predicted values
- en: pred <- vector(length=n-k)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- vector(length=n-k)
- en: Interfacing R to Other Languages
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: Interfacing R to Other Languages
- en: '**327**'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**327**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: for (i in 1:(n-k)) {
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n-k)) {
- en: if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
- en: '}'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: predb <- function(x,k) {
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: predb <- function(x,k) {
- en: n <- length(x)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: k2 <- k/2
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: pred <- vector(length=n-k)
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- vector(length=n-k)
- en: sm <- sum(x[1:k])
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: sm <- sum(x[1:k])
- en: if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
- en: if (n-k >= 2) {
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: if (n-k >= 2) {
- en: for (i in 2:(n-k)) {
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:(n-k)) {
- en: sm <- sm + x[i+k-1] - x[i-1]
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: sm <- sm + x[i+k-1] - x[i-1]
- en: if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
- en: '}'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Since the latter avoids duplicate computation, we speculated it would be faster.
    Now is the time to check that.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后者避免了重复计算，我们推测它可能会更快。现在是检查这个的时候了。
- en: y <- sample(0:1,100000,replace=T)
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- sample(0:1,100000,replace=T)
- en: system.time(preda(y,1000))
  id: totrans-1324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(preda(y,1000))
- en: user system elapsed
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '3.816'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '3.816'
- en: '0.016'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '3.873'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '3.873'
- en: system.time(predb(y,1000))
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(predb(y,1000))
- en: user system elapsed
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '1.392'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '1.392'
- en: '0.008'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '0.008'
- en: '1.427'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '1.427'
- en: Hey, not bad! That’s quite an improvement.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，不错！这相当是一个改进。
- en: 'However, you should always ask whether R already has a fine-tuned function
    that will suit your needs. Since we’re basically computing a moving average, we
    might try the filter() function, with a constant coefficient vector, as follows:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该始终询问 R 是否已经有一个经过微调的函数可以满足你的需求。因为我们基本上是在计算移动平均，我们可能会尝试使用 filter() 函数，使用一个常数系数向量，如下所示：
- en: predc <- function(x,k) {
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: predc <- function(x,k) {
- en: n <- length(x)
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: f <- filter(x,rep(1,k),sides=1)[k:(n-1)]
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: f <- filter(x,rep(1,k),sides=1)[k:(n-1)]
- en: k2 <- k/2
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: k2 <- k/2
- en: pred <- as.integer(f >= k2)
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: pred <- as.integer(f >= k2)
- en: return(mean(abs(pred-x[(k+1):n])))
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(abs(pred-x[(k+1):n])))
- en: '}'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**328**'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '**328**'
- en: Chapter 15
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 15
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: That’s even more compact than our first version. But it’s a lot harder to read,
    and for reasons we will explore soon, it may not be so fast. Let’s check.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比我们的第一个版本更加紧凑。但它很难阅读，并且由于我们将很快探讨的原因，它可能不会那么快。让我们检查一下。
- en: system.time(predc(y,1000))
  id: totrans-1347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(predc(y,1000))
- en: user system elapsed
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '3.872'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '3.872'
- en: '0.016'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '0.016'
- en: '3.945'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '3.945'
- en: 'Well, our second version remains the champion so far. This actually should
    be expected, as a look at the source code shows. Typing the following shows the
    source for that function:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们的第二个版本至今仍然是冠军。这实际上是可以预料的，因为查看源代码就可以看到。输入以下内容显示了该函数的源代码：
- en: filter
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: filter
- en: This reveals (not shown here) that filter1() is called. The latter is written
    in C, which should give us some speedup, but it still suffers from the duplicate
    computation problem—hence the slowness.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了（此处未显示）filter1() 被调用的信息。后者是用 C 编写的，这应该会给我们带来一些速度提升，但它仍然存在重复计算的问题——因此速度较慢。
- en: So, let’s write our own C code.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写自己的 C 代码。
- en: '#include <R.h>'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h>'
- en: void predd(int *x, int *n, int *k, double *errrate)
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: void predd(int *x, int *n, int *k, double *errrate)
- en: '{'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int nval = *n, kval = *k, nk = nval - kval, i;
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: int nval = *n, kval = *k, nk = nval - kval, i;
- en: int sm = 0; // moving sum
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: int sm = 0; // 移动总和
- en: int errs = 0; // error count
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: int errs = 0; // 错误计数
- en: int pred; // predicted value
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: int pred; // 预测值
- en: double k2 = kval/2.0;
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: double k2 = kval/2.0;
- en: // initialize by computing the initial window
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过计算初始窗口进行初始化
- en: for (i = 0; i < kval; i++) sm += x[i];
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = 0; i < kval; i++) sm += x[i];
- en: if (sm >= k2) pred = 1; else pred = 0;
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred = 1; else pred = 0;
- en: errs = abs(pred-x[kval]);
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: errs = abs(pred-x[kval]);
- en: for (i = 1; i < nk; i++) {
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = 1; i < nk; i++) {
- en: sm = sm + x[i+kval-1] - x[i-1];
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: sm = sm + x[i+kval-1] - x[i-1];
- en: if (sm >= k2) pred = 1; else pred = 0;
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: if (sm >= k2) pred = 1; else pred = 0;
- en: errs += abs(pred-x[i+kval]);
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: errs += abs(pred-x[i+kval]);
- en: '}'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*errrate = (double) errs / nk;'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '*errrate = (double) errs / nk;'
- en: '}'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This is basically predb() from before, “hand translated” into C. Let’s see if
    it will outdo predb().
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是将之前的 predb() “手动翻译”成 C 语言。让我们看看它是否能超越 predb()。
- en: system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000),
  id: totrans-1376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000),
- en: +
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: errrate=double(1)))
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: errrate=double(1)))
- en: user system elapsed
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: user system elapsed
- en: '0.004'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '0.004'
- en: '0.000'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.003'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '0.003'
- en: Interfacing R to Other Languages
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: R 与其他语言的接口
- en: '**329**'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**329**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The speedup is breathtaking.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 加速效果令人惊叹。
- en: You can see that writing certain functions in C can be worth the effort.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，用 C 语言编写某些函数是值得努力的。
- en: This is especially true for functions that involve iteration, as R’s own iteration
    constructs, such as for(), are slow.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于涉及迭代的函数尤其如此，因为 R 的迭代构造，如 for()，速度较慢。
- en: '**15.2 Using R from Python**'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.2 从 Python 使用 R**'
- en: Python is an elegant and powerful language, but it lacks built-in facilities
    for statistical and data manipulation, two areas in which R excels. This section
    demonstrates how to call R from Python, using RPy, one of the most popular interfaces
    between the two languages.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种优雅且强大的语言，但它缺乏内置的统计和数据操作功能，这两个领域是 R 的强项。本节演示了如何使用 RPy（两种语言之间最受欢迎的接口之一）从
    Python 调用 R。
- en: '***15.2.1 Installing RPy***'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.2.1 安装 RPy***'
- en: RPy is a Python module that allows access to R from Python. For extra efficiency,
    it can be used in conjunction with NumPy.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: RPy 是一个 Python 模块，允许从 Python 访问 R。为了提高效率，它可以与 NumPy 一起使用。
- en: You can build the module from the source, available from *http://rpy*
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *http://rpy* 获取源代码构建模块。
- en: '*.sourceforge.net*, or download a prebuilt version. If you are running Ubuntu,
    simply type this:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '*.sourceforge.net*，或者下载一个预构建版本。如果你正在运行 Ubuntu，只需输入以下命令：'
- en: sudo apt-get install python-rpy
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get install python-rpy
- en: 'To load RPy from Python (whether in Python interactive mode or from code),
    execute the following:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Python 加载 RPy（无论是 Python 交互模式还是从代码中），请执行以下命令：
- en: from rpy import *
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: from rpy import *
- en: This will load a variable r, which is a Python class instance.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一个变量 r，它是一个 Python 类实例。
- en: '***15.2.2 RPy Syntax***'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '***15.2.2 RPy 语法***'
- en: 'Running R from Python is in principle quite simple. Here is an example of a
    command you might run from the *>>>* Python prompt:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 运行 R 在原则上非常简单。以下是从 *>>>* Python 提示符可能运行的命令示例：
- en: '>>> r.hist(r.rnorm(100))'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.hist(r.rnorm(100))'
- en: This will call the R function rnorm() to produce 100 standard normal variates
    and then input those values into R’s histogram function, hist().
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 R 函数 rnorm() 来生成 100 个标准正态变量，然后将这些值输入到 R 的直方图函数 hist() 中。
- en: As you can see, R names are prefixed by r., reflecting the fact that Python
    wrappers for R functions are members of the class instance r.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，R 名称以 r. 为前缀，反映了 R 函数的 Python 包装器是 r 类实例的成员。
- en: The preceding code will, if not refined, produce ugly output, with your (possibly
    voluminous!) data appearing as the graph title and the *x*-axis label.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行优化，前面的代码将产生丑陋的输出，你的（可能大量的！）数据将出现在图表标题和 *x* 轴标签中。
- en: 'You can avoid this by supplying a title and label, as in this example:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供标题和标签来避免这种情况，如下例所示：
- en: '>>> r.hist(r.rnorm(100),main='''',xlab='''')'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.hist(r.rnorm(100),main='''',xlab='''')'
- en: RPy syntax is sometimes less simple than these examples would lead you to believe.
    The problem is that R and Python syntax may clash. For instance, **330**
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: RPy 语法有时比这些示例所表明的要复杂。问题是 R 和 Python 语法可能冲突。例如，**330**
- en: Chapter 15
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: consider a call to the R linear model function lm(). In our example, we will
    predict b from a.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑调用 R 线性模型函数 lm()。在我们的例子中，我们将从 a 预测 b。
- en: '>>> a = [5,12,13]'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [5,12,13]'
- en: '>>> b = [10,28,30]'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [10,28,30]'
- en: '>>> lmout = r.lm(''v2 ~ v1'',data=r.data_frame(v1=a,v2=b))'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lmout = r.lm(''v2 ~ v1'',data=r.data_frame(v1=a,v2=b))'
- en: This is somewhat more complex than it would have been if done directly in R.
    What are the issues here?
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 这比直接在 R 中做要复杂一些。这里有什么问题？
- en: First, since Python syntax does not include the tilde character, we needed to
    specify the model formula via a string. Since this is done in R anyway, this is
    not a major departure.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于 Python 语法不包含波浪线字符，我们需要通过字符串指定模型公式。由于这已经在 R 中完成，因此这不是一个重大的改变。
- en: Second, we needed a data frame to contain our data. We created one
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一个数据框来包含我们的数据。我们创建了一个
- en: using R’s data.frame() function. In order to form a period in an R function
    name, we need to use an underscore on the Python end. Thus we called r.data_frame().
    Note that in this call, we named the columns of our data frame v1 and v2 and then
    used these in our model formula.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R的data.frame()函数。为了在R函数名称中形成点，我们需要在Python端使用下划线。因此我们调用了r.data_frame()。请注意，在这个调用中，我们命名了数据框的列v1和v2，然后在我们模型公式中使用这些列。
- en: 'The output object is a Python dictionary (analog of R’s list type), as you
    can see here (in part):'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对象是一个Python字典（类似于R的列表类型），正如你在这里可以看到的（部分）：
- en: '>>> lmout'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lmout'
- en: '{''qr'': {''pivot'': [1, 2], ''qr'': array([[ -1.73205081, -17.32050808],'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '{''qr'': {''pivot'': [1, 2], ''qr'': array([[ -1.73205081, -17.32050808],'
- en: '[ 0.57735027, -6.164414 ],'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0.57735027, -6.164414 ],'
- en: '[ 0.57735027,'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0.57735027,'
- en: '0.78355007]]), ''qraux'':'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '0.78355007]]), ''qraux'':'
- en: 'You should recognize the various attributes of lm() objects here. For example,
    the coefficients of the fitted regression line, which would be contained in lmout$coefficients
    if this were done in R, are here in Python as lmout[''coefficients'']. So, you
    can access those coefficients accordingly, for example like this:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够识别lm()对象的各个属性。例如，拟合回归线的系数，如果这在R中完成，将包含在lmout$coefficients中，在这里Python中作为lmout['coefficients']。因此，你可以相应地访问这些系数，例如像这样：
- en: '>>> lmout[''coefficients'']'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lmout[''coefficients'']'
- en: '{''v1'': 2.5263157894736841, ''(Intercept)'': -2.5964912280701729}'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '{''v1'': 2.5263157894736841, ''(Intercept)'': -2.5964912280701729}'
- en: '>>> lmout[''coefficients''][''v1'']'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lmout[''coefficients''][''v1'']'
- en: '2.5263157894736841'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '2.5263157894736841'
- en: You can also submit R commands to work on variables in R’s namespace, using
    the function r(). This is convenient if there are many syntax clashes.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用r()函数将R命令提交给R的命名空间中的变量进行工作，这在存在许多语法冲突时非常方便。
- en: 'Here is how we could run the wireframe() example in Section 12.4 in RPy:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在RPy中运行第12.4节中wireframe()示例的：
- en: '>>> r.library(''lattice'')'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.library(''lattice'')'
- en: '>>> r.assign(''a'',a)'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.assign(''a'',a)'
- en: '>>> r.assign(''b'',b)'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r.assign(''b'',b)'
- en: '>>> r(''g <- expand.grid(a,b)'')'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r(''g <- expand.grid(a,b)'')'
- en: '>>> r(''g$Var3 <- g$Var1^2 + g$Var1 * g$Var2'')'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r(''g$Var3 <- g$Var1^2 + g$Var1 * g$Var2'')'
- en: '>>> r(''wireframe(Var3 ~ Var1+Var2,g)'')'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r(''wireframe(Var3 ~ Var1+Var2,g)'')'
- en: '>>> r(''plot(wireframe(Var3 ~ Var1+Var2,g))'')'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r(''plot(wireframe(Var3 ~ Var1+Var2,g))'')'
- en: Interfacing R to Other Languages
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 将R与其他语言接口
- en: '**331**'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '**331**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: First, we used r.assign() to copy a variable from Python’s namespace to R’s.
    We then ran expand.grid() (with a period in the name instead of an underscore,
    since we are running in R’s namespace), assigning the result to g. Again, the
    latter is in R’s namespace. Note that the call to wireframe() did not automatically
    display the plot, so we needed to call plot().
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用r.assign()将变量从Python的命名空间复制到R的命名空间中。然后我们运行expand.grid()（在名称中使用点而不是下划线，因为我们是在R的命名空间中运行），将结果赋值给g。同样，后者也在R的命名空间中。请注意，wireframe()的调用并没有自动显示图形，因此我们需要调用plot()。
- en: The official documentation for RPy is at *http://rpy.sourceforge.net/rpy/doc/*
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: RPy的官方文档在 *http://rpy.sourceforge.net/rpy/doc/*。
- en: '*rpy.pdf*. Also, you can find a useful presentation, “RPy—R from Python,” at
    *http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html*.'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '*rpy.pdf*. 此外，你还可以在 *http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html*
    找到一个有用的演示，“RPy—从Python使用R”。'
- en: '**332**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**332**'
- en: Chapter 15
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 43](index-359_1.png)'
  id: totrans-1447
  prefs: []
  type: TYPE_IMG
  zh: '![Image 43](index-359_1.png)'
- en: '**16**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**16**'
- en: '**PARALLEL R**'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行R**'
- en: Since many R users have very large compu-
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多R用户有非常大的计算需求，
- en: tational needs, various tools for some kind
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 计算需求，为某些类型的工具设计了各种工具。
- en: of parallel operation of R have been devised.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为R的并行操作设计了各种工具。
- en: This chapter is devoted to parallel R.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍并行R。
- en: Many a novice in parallel processing has, with great anticipation, written parallel
    code for some application only to find that the parallel version actually ran
    more slowly than the serial one. For reasons to be discussed in this chapter,
    this problem is especially acute with R.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 许多并行处理的新手满怀期待地编写了一些应用的并行代码，却发现并行版本实际上比串行版本运行得更慢。由于本章将要讨论的原因，这个问题在R中尤其严重。
- en: Accordingly, understanding the nature of parallel-processing hardware and software
    is crucial to success in the parallel world. These issues will be discussed here
    in the context of common platforms for parallel R.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解并行处理硬件和软件的本质对于在并行世界中取得成功至关重要。这些问题将在并行R的常见平台背景下进行讨论。
- en: We’ll start with a few code examples and then move to general performance issues.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个代码示例开始，然后转向一般性能问题。
- en: '**16.1 The Mutual Outlinks Problem**'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.1 互链问题**'
- en: Consider a network graph of some kind, such as web links or links in a social
    network. Let A be the *adjacency matrix* of the graph, meaning that, say, A[3,8]
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑某种类型的网络图，例如网页链接或社交网络中的链接。设A为图的**邻接矩阵**，这意味着，例如，A[3,8]
- en: is 1 or 0, depending on whether there is a link from node 3 to node 8\.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 的值为1或0，取决于是否存在从节点3到节点8的链接。
- en: For any two vertices, say any two websites, we might be interested in mutual
    outlinks—that is, outbound links that are common to two sites. Suppose that we
    want to find the mean number of mutual outlinks, averaged
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何两个顶点，例如任何两个网站，我们可能对互链感兴趣——即两个网站共有的出链。假设我们想找到互链的平均数量，平均
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'over all pairs of websites in our data set. This mean can be found using the
    following outline, for an *n*-by- *n* matrix:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中所有网站对之间。这个平均值可以使用以下概述找到，对于一个 *n* 行 *n* 列的矩阵：
- en: '1'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sum = 0
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: sum = 0
- en: '2'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: for i = 0...n-1
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: for i = 0...n-1
- en: '3'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: for j = i+1...n-1
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: for j = i+1...n-1
- en: '4'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
- en: '5'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mean = sum / (n*(n-1)/2)
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: mean = sum / (n*(n-1)/2)
- en: Given that our graph could contain thousands—even millions—of web-
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的图可能包含成千上万的——甚至数百万个——网页-
- en: sites, our task could entail quite large amounts of computation. A common approach
    to dealing with this problem is to divide the computation into smaller chunks
    and then process each of the chunks simultaneously, say on separate computers.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 网站，我们的任务可能涉及相当大的计算量。处理此问题的常见方法是将计算分成更小的块，然后同时处理每个块，例如在单独的计算机上。
- en: Let’s say that we have two computers at our disposal. We might have one computer
    handle all the odd values of i in the for i loop in line 2 and have the second
    computer handle the even values. Or, since dual-core computers are fairly standard
    these days, we could take this same approach on a single computer. This may sound
    simple, but a number of major issues can arise, as you’ll learn in this chapter.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两台可用的计算机。我们可能让一台计算机处理第2行for i循环中的所有奇数i值，而让第二台计算机处理偶数值。或者，由于双核计算机现在相当普遍，我们可以在单台计算机上采取相同的方法。这听起来可能很简单，但正如你将在本章中学到的那样，可能会出现许多重大问题。
- en: '**16.2 Introducing the snow Package**'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2 介绍snow包**'
- en: Luke Tierney’s snow (Simple Network of Workstations) package, available from
    the CRAN R code repository, is arguably the simplest, easiest-to-use form of parallel
    R and one of the most popular.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: Luke Tierney的snow（简单工作站网络）包，可以从CRAN R代码仓库获得，可以说是最简单、最容易使用的并行R包之一，也是最受欢迎的。
- en: '**NOTE**'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The CRAN Task View page on parallel R,* http://cran.r-project.org/web/views/'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行R的CRAN任务视图页面，* http://cran.r-project.org/web/views/'
- en: HighPerformanceComputing.html *, has a fairly up-to-date list of available parallel
    R packages.*
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能计算.html *，列出了可用的并行R包的最新列表。*
- en: To see how snow works, here’s code for the mutual outlinks problem
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解snow是如何工作的，以下是对互链问题的代码示例
- en: 'described in the previous section:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中描述的：
- en: '1'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: snow version of mutual links problem
  id: totrans-1484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: snow版本的互链问题
- en: '2'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: mtl <- function(ichunk,m) {
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: mtl <- function(ichunk,m) {
- en: '4'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: n <- ncol(m)
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: n <- ncol(m)
- en: '5'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: matches <- 0
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: matches <- 0
- en: '6'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: for (i in ichunk) {
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in ichunk) {
- en: '7'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: if (i < n) {
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: if (i < n) {
- en: '8'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: rowi <- m[i,]
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: rowi <- m[i,]
- en: '9'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: matches <- matches +
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: matches <- matches +
- en: '10'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: sum(m[(i+1):n,] %*% rowi)
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: sum(m[(i+1):n,] %*% rowi)
- en: '11'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '12'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '}'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '13'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: matches
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: matches
- en: '14'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**334**'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: '**334**'
- en: Chapter 16
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '15'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: mutlinks <- function(cls,m) {
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: mutlinks <- function(cls,m) {
- en: '17'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: n <- nrow(m)
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(m)
- en: '18'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: nc <- length(cls)
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: nc <- length(cls)
- en: '19'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: determine which worker gets which chunk of i
  id: totrans-1521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定哪个工作器获得哪个i块的块
- en: '20'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: options(warn=-1)
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=-1)
- en: '21'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: ichunks <- split(1:n,1:nc)
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: ichunks <- split(1:n,1:nc)
- en: '22'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: options(warn=0)
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=0)
- en: '23'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: counts <- clusterApply(cls,ichunks,mtl,m)
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: counts <- clusterApply(cls,ichunks,mtl,m)
- en: '24'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: do.call(sum,counts) / (n*(n-1)/2)
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: do.call(sum,counts) / (n*(n-1)/2)
- en: '25'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: '}'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Suppose we have this code in the file *SnowMutLinks.R*. Let’s first discuss
    how to run it.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在这段代码文件 *SnowMutLinks.R* 中。让我们首先讨论如何运行它。
- en: '***16.2.1 Running snow Code***'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2.1 运行snow代码***'
- en: 'Running the above snow code involves the following steps:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述snow代码涉及以下步骤：
- en: 1\.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: Load the code.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 加载代码。
- en: 2\.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Load the snow library.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 加载snow库。
- en: 3\.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Form a snow cluster.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 形成snow集群。
- en: 4\.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: Set up the adjacency matrix of interest.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 设置感兴趣的邻接矩阵。
- en: 5\.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Run your code on that matrix on the cluster you formed.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 在你形成的集群上运行你的代码。
- en: 'Assuming we are running on a dual-core machine, we issue the following commands
    to R:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在双核机器上运行，我们向R发出以下命令：
- en: source("SnowMutLinks.R")
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("SnowMutLinks.R")
- en: library(snow)
  id: totrans-1549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(snow)
- en: cl <- makeCluster(type="SOCK",c("localhost","localhost"))
  id: totrans-1550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cl <- makeCluster(type="SOCK",c("localhost","localhost"))
- en: testm <- matrix(sample(0:1,16,replace=T),nrow=4)
  id: totrans-1551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testm <- matrix(sample(0:1,16,replace=T),nrow=4)
- en: mutlinks(cl,testm)
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mutlinks(cl,testm)
- en: '[1] 0.6666667'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.6666667'
- en: Here, we are instructing snow to start two new R processes on our
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示snow在我们的机器上启动两个新的R进程
- en: machine (localhost is a standard network name for the local machine), which
    I will refer to here as *workers*. I’ll refer to the original R process—the one
    in which we type the preceding commands—as the *manager*. So, at this point, three
    instances of R will be running on the machine (visible by running the ps command
    if you are in a Linux environment, for example).
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: machine（localhost是本地机器的标准网络名称），在这里我将称之为*工作者*。我将原始R进程（我们输入前面命令的那个进程）称为*管理者*。因此，在这个时候，机器上将运行三个R实例（如果你在Linux环境中，可以通过运行ps命令看到它们）。
- en: The workers form a *cluster* in snow parlance, which we have named cl.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者在snow术语中形成一个*集群*，我们将其命名为cl。
- en: 'The snow package uses what is known in the parallel-processing world as a *scatter/gather*
    paradigm, which works as follows:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: snow包使用并行处理世界中众所周知的一种*分散/聚合*范式，其工作方式如下：
- en: 1\.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The manager partitions the data into chunks and parcels them out to the workers
    (scatter phase).
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者将数据分割成块，并将它们分发给工作者（分散阶段）。
- en: Parallel R
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R
- en: '**335**'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '**335**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 2\.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The workers process their chunks.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者处理他们的数据块。
- en: 3\.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The manager collects the results from the workers (gather phase) and combines
    them as appropriate to the application.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者从工作者那里收集结果（聚合阶段），并根据应用需求将它们组合起来。
- en: We have specified that communication between the manager and work-
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了管理者和工作者之间的通信
- en: ers will be via network sockets (covered in Chapter 10).
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络套接字（在第10章中介绍）进行通信。
- en: 'Here’s a test matrix to check the code:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试矩阵，用于检查代码：
- en: testm
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testm
- en: '[,1] [,2] [,3] [,4]'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3] [,4]'
- en: '[1,]'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[2,]'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '0'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '[3,]'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '1'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[4,]'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '[4,]'
- en: '0'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Row 1 has zero outlinks in common with row 2, two in common with
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行与第2行没有共同的外部链接，与第2行有两个共同的外部链接，
- en: row 3, and one in common with row 4\. Row 2 has zero outlinks in common with
    the rest, but row 3 has one in common with row 4\. That is a total of four mutual
    outlinks out of 4 *×* 3 */* 2 = 6 pairs—hence, the mean value of 4/6 = 0.6666667,
    as you saw earlier.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行与第4行有一个共同的外部链接，而第2行与其它行没有共同的外部链接，但第3行与第4行有一个共同的外部链接。这样，总共有4个共同的外部链接，占4 *×*
    3 */* 2 = 6对中的4/6，即0.6666667，正如你之前看到的。
- en: You can make clusters of any size, as long as you have the machines.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建任何大小的集群，只要你有机器。
- en: 'In my department, for instance, I have machines whose network names are pc28,
    pc29, and pc30\. Each machine is dual core, so I could create a six-worker cluster
    as follows:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我所在的部门，我有机器的网络名称是pc28、pc29和pc30。每台机器都是双核的，因此我可以创建一个包含六个工作者的集群，如下所示：
- en: cl6 <- makeCluster(type="SOCK",c("pc28","pc28","pc29","pc29","pc30","pc30"))
  id: totrans-1596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cl6 <- makeCluster(type="SOCK",c("pc28","pc28","pc29","pc29","pc30","pc30"))
- en: '***16.2.2 Analyzing the snow Code***'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2.2 分析snow代码***'
- en: Now let’s see how the mutlinks() function works. First, we sense how many rows
    the matrix m has, in line 17, and the number of workers in our cluster, in line
    18\.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看mutlinks()函数是如何工作的。首先，我们在第17行中检测矩阵m的行数，在第18行中检测我们集群中的工作者数量。
- en: 'Next, we need to determine which worker will handle which values of i in the
    for i loop in our outline code shown earlier in Section 16.1\. R’s split() function
    is well suited for this. For instance, in the case of a 4-row matrix and a 2-worker
    cluster, that call produces the following:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定哪个工作者将处理我们之前在第16.1节中展示的轮廓代码中的for i循环中的哪个i值。R的split()函数非常适合这个任务。例如，在一个4行矩阵和2个工作者集群的情况下，该调用会产生以下结果：
- en: split(1:4,1:2)
  id: totrans-1600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: split(1:4,1:2)
- en: $`1`
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: $`1`
- en: '[1] 1 3'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 3'
- en: $`2`
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: $`2`
- en: '[1] 2 4'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 4'
- en: An R list is returned whose first element is the vector (1,3) and the second
    is (2,4). This will set up having one R process work on the odd values of i and
    the other work on the even values, as we discussed earlier. We ward off the **336**
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个R列表，其第一个元素是向量(1,3)，第二个元素是(2,4)。这将设置一个R进程处理i的奇数值，另一个进程处理偶数值，正如我们之前讨论的那样。我们避免了**336**
- en: Chapter 16
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: warnings that split() would give us (“data length is not a multiple of split
    variable”) by calling options().
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用options()来避免split()可能会给出的警告（“数据长度不是分割变量的倍数”）。
- en: The real work is done in line 23, where we call the snow function
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作是在第23行完成的，在那里我们调用snow函数
- en: 'clusterApply(). This function initiates a call to the same specified function
    (mtl() here), with some arguments specific to each worker and some optional arguments
    common to all. So, here’s what the call in line 23 does: 1\.'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: clusterApply(). 这个函数初始化对相同指定函数（这里的mtl()）的调用，其中包含一些针对每个工作者的特定参数和一些对所有工作者都可选的参数。所以，这里第23行的调用是这样的：1.
- en: Worker 1 will be directed to call the function mtl() with the arguments ichunks[[1]]
    and m.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者1将被指示使用ichunks[[1]]和m作为参数调用函数mtl()。
- en: 2\.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Worker 2 will call mtl() with the arguments ichunks[[2]] and m, and so on for
    all workers.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者2将使用ichunks[[2]]和m调用mtl()，对所有工作者也是如此。
- en: 3\.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Each worker will perform its assigned task and then return the result to the
    manager.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作者将执行其分配的任务，然后将结果返回给管理者。
- en: 4\.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The manager will collect all such results into an R list, which we have assigned
    here to counts.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者将收集所有这些结果到一个R列表中，我们在这里将其分配给counts。
- en: At this point, we merely need to sum all the elements of counts. Well, I shouldn’t
    say “merely,” because there is a little wrinkle to iron out in line 24\.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需要对counts中的所有元素进行求和。好吧，我不应该说“仅仅”，因为在第24行有一些小问题需要解决。
- en: 'R’s sum() function is capable of acting on several vector arguments, like this:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: R的sum()函数可以对多个向量参数进行操作，如下所示：
- en: sum(1:2,c(4,10))
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sum(1:2,c(4,10))
- en: '[1] 17'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 17'
- en: But here, counts is an R list, not a (numeric) vector. So we rely on do.call()
    to extract the vectors from counts, and then we call sum() on them.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，counts是一个R列表，而不是（数值）向量。因此，我们依赖于do.call()从counts中提取向量，然后对它们调用sum()。
- en: Note lines 9 and 10\. As you know, in R, we try to vectorize our computation
    wherever possible for better performance. By casting things in matrix-times-vector
    terms, we replace the for j and for k loops in the outline in Section 16.1 by
    a single vector-based expression.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第9行和第10行。正如你所知，在R中，我们尽可能地尝试将计算向量化以提高性能。通过将事物表示为矩阵-向量乘积的形式，我们将第16.1节概述中的for
    j和for k循环替换为一个基于向量的单一表达式。
- en: '***16.2.3 How Much Speedup Can Be Attained?***'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2.3 可以获得多少加速？**'
- en: I tried this code on a 1000-by-1000 matrix m1000\. I first ran it on a 4-worker
    cluster and then on a 12-worker cluster. In principle, I should have had speedups
    of 4 and 12, respectively. But the actual elapsed times were 6.2 seconds and 5.0
    seconds. Compare these figures to the 16.9 seconds runtime in nonparallel form.
    (The latter consisted of the call mtl(1:1000,m1000).) So, I attained a speedup
    of about 2.7 instead of a theoretical 4.0 for a 4-worker cluster and 3.4 rather
    than 12.0 on the 12-node system. (Note that some timing variation occurs from
    run to run.) What went wrong?
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个1000x1000的矩阵m1000上尝试了这段代码。我首先在一个4个工作者的集群上运行它，然后在一个12个工作者的集群上运行。原则上，我应该有4和12的加速比。但实际上，经过的时间是6.2秒和5.0秒。将这些数字与16.9秒的非并行运行时间进行比较。（后者是mtl(1:1000,m1000)的调用。）因此，我获得了大约2.7的加速比，而不是4.0的理论值，对于4个工作者的集群，以及在12节点系统上的3.4而不是12.0。请注意，运行之间的时间会有所变化。）出了什么问题？
- en: In almost any parallel-processing application, you encounter *overhead*, or
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎任何并行处理应用程序中，你都会遇到*开销*，或者
- en: “wasted” time spent on noncomputational activity. In our example, there is overhead
    in the form of the time needed to send our matrix from the manager to the workers.
    We also encountered a bit of overhead in sending the function mtl() itself to
    the workers. And when the workers finish their tasks, returning their results
    to the manager causes some overhead, too. We’ll Parallel R
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: “浪费”在非计算活动上的时间。在我们的例子中，存在从管理者到工作者的矩阵传输所需的时间开销。我们还在将函数mtl()本身发送到工作者时遇到了一点开销。当工作者完成他们的任务后，将结果返回给管理者也会造成一些开销。我们将在第16.4.1节中详细讨论这一点。
- en: '**337**'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '**337**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: discuss this in detail when we talk about general performance considerations
    in in Section 16.4.1\.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论一般性能考虑时。
- en: '***16.2.4 Extended Example: K-Means Clustering***'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.2.4 扩展示例：K-Means聚类**'
- en: To learn more about the capabilities of snow, we’ll look at another example,
    this one involving k-means clustering (KMC).
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于snow功能的能力，我们将查看另一个示例，这个示例涉及k-means聚类（KMC）。
- en: KMC is a technique for exporatory data analysis. In looking at scatter plots
    of your data, you may have the perception that the observations tend to cluster
    into groups, and KMC is a method for finding such groups. The output consists
    of the centroids of the groups.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: KMC是一种用于数据探索的技术。在查看数据的散点图时，你可能会有这样的感觉，即观测值倾向于聚集成组，KMC是一种寻找此类组的方法。输出结果包括组的质心。
- en: 'The following is an outline of the algorithm:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following is an outline of the algorithm:'
- en: '1'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: for iter = 1,2,...,niters
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: for iter = 1,2,...,niters
- en: '2'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: set vector and count totals to 0
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: set vector and count totals to 0
- en: '3'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: for i = 1,...,nrow(m)
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: for i = 1,...,nrow(m)
- en: '4'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: set j = index of the closest group center to m[i,]
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: set j = index of the closest group center to m[i,]
- en: '5'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: add m[i,] to the vector total for group j, v[j]
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: add m[i,] to the vector total for group j, v[j]
- en: '6'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: add 1 to the count total for group j, c[j]
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: add 1 to the count total for group j, c[j]
- en: '7'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: for j = 1,...,ngrps
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: for j = 1,...,ngrps
- en: '8'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: set new center of group j = v[j] / c[j]
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: set new center of group j = v[j] / c[j]
- en: Here, we specify niters iterations, with initcenters as our initial guesses
    for the centers of the groups. Our data is in the matrix m, and there are ngrps
    groups.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: Here, we specify niters iterations, with initcenters as our initial guesses
    for the centers of the groups. Our data is in the matrix m, and there are ngrps
    groups.
- en: 'The following is the snow code to compute KMC in parallel:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following is the snow code to compute KMC in parallel:'
- en: '1'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: snow version of k-means clustering problem
  id: totrans-1654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: snow version of k-means clustering problem
- en: '2'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: library(snow)
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: library(snow)
- en: '4'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: returns distances from x to each vector in y;
  id: totrans-1660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: returns distances from x to each vector in y;
- en: '6'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: here x is a single vector and y is a bunch of them;
  id: totrans-1662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: here x is a single vector and y is a bunch of them;
- en: '7'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: define distance between 2 points to be the sum of the absolute values 8
  id: totrans-1664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: define distance between 2 points to be the sum of the absolute values 8
- en: of their componentwise differences; e.g., distance between (5,4.2) and 9
  id: totrans-1665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个点之间距离的定义是它们分量差的绝对值之和；例如，点(5,4.2)和9之间的距离
- en: (3,5.6) is 2 + 1.4 = 3.4
  id: totrans-1666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: (3,5.6) is 2 + 1.4 = 3.4
- en: '10'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: dst <- function(x,y) {
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: dst <- function(x,y) {
- en: '11'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: 'tmpmat <- matrix(abs(x-y),byrow=T,ncol=length(x)) # note recycling 12'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 'tmpmat <- matrix(abs(x-y),byrow=T,ncol=length(x)) # note recycling 12'
- en: rowSums(tmpmat)
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: rowSums(tmpmat)
- en: '13'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '}'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '14'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: will check this worker's mchunk matrix against currctrs, the current 16
  id: totrans-1676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: will check this worker's mchunk matrix against currctrs, the current 16
- en: centers of the groups, returning a matrix; row j of the matrix will 17
  id: totrans-1677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: centers of the groups, returning a matrix; row j of the matrix will 17
- en: consist of the vector sum of the points in mchunk closest to jth
  id: totrans-1678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: consist of the vector sum of the points in mchunk closest to jth
- en: '18'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: current center, and the count of such points
  id: totrans-1680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前中心，以及此类点的计数
- en: '19'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: findnewgrps <- function(currctrs) {
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: findnewgrps <- function(currctrs) {
- en: '20'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: ngrps <- nrow(currctrs)
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: ngrps <- nrow(currctrs)
- en: '21'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: 'spacedim <- ncol(currctrs) # what dimension space are we in?'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 'spacedim <- ncol(currctrs) # what dimension space are we in?'
- en: '**338**'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '**338**'
- en: Chapter 16
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '22'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: set up the return matrix
  id: totrans-1691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: set up the return matrix
- en: '23'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: sumcounts <- matrix(rep(0,ngrps*(spacedim+1)),nrow=ngrps)
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: sumcounts <- matrix(rep(0,ngrps*(spacedim+1)),nrow=ngrps)
- en: '24'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: for (i in 1:nrow(mchunk)) {
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nrow(mchunk)) {
- en: '25'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: dsts <- dst(mchunk[i,],t(currctrs))
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: dsts <- dst(mchunk[i,],t(currctrs))
- en: '26'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: j <- which.min(dsts)
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: j <- which.min(dsts)
- en: '27'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: sumcounts[j,] <- sumcounts[j,] + c(mchunk[i,],1)
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: sumcounts[j,] <- sumcounts[j,] + c(mchunk[i,],1)
- en: '28'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '}'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '29'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: sumcounts
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: sumcounts
- en: '30'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '}'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '31'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '32'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: parkm <- function(cls,m,niters,initcenters) {
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: parkm <- function(cls,m,niters,initcenters) {
- en: '33'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: n <- nrow(m)
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(m)
- en: '34'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: 'spacedim <- ncol(m) # what dimension space are we in?'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 'spacedim <- ncol(m) # what dimension space are we in?'
- en: '35'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: determine which worker gets which chunk of rows of m
  id: totrans-1716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: determine which worker gets which chunk of rows of m
- en: '36'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: options(warn=-1)
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=-1)
- en: '37'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: ichunks <- split(1:n,1:length(cls))
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: ichunks <- split(1:n,1:length(cls))
- en: '38'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: options(warn=0)
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: options(warn=0)
- en: '39'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: form row chunks
  id: totrans-1724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: form row chunks
- en: '40'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: mchunks <- lapply(ichunks,function(ichunk) m[ichunk,])
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: mchunks <- lapply(ichunks,function(ichunk) m[ichunk,])
- en: '41'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: mcf <- function(mchunk) mchunk <<- mchunk
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: mcf <- function(mchunk) mchunk <<- mchunk
- en: '42'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: send row chunks to workers; each chunk will be a global variable at 43
  id: totrans-1730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send row chunks to workers; each chunk will be a global variable at 43
- en: the worker, named mchunk
  id: totrans-1731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: the worker, named mchunk
- en: '44'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: invisible(clusterApply(cls,mchunks,mcf))
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: invisible(clusterApply(cls,mchunks,mcf))
- en: '45'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '45'
- en: send dst() to workers
  id: totrans-1735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send dst() to workers
- en: '46'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: '46'
- en: clusterExport(cls,"dst")
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: clusterExport(cls,"dst")
- en: '47'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: start iterations
  id: totrans-1739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: start iterations
- en: '48'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: centers <- initcenters
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: centers <- initcenters
- en: '49'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: for (i in 1:niters) {
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:niters) {
- en: '50'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: sumcounts <- clusterCall(cls,findnewgrps,centers)
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: sumcounts <- clusterCall(cls,findnewgrps,centers)
- en: '51'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '51'
- en: tmp <- Reduce("+",sumcounts)
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: tmp <- Reduce("+",sumcounts)
- en: '52'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: centers <- tmp[,1:spacedim] / tmp[,spacedim+1]
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: centers <- tmp[,1:spacedim] / tmp[,spacedim+1]
- en: '53'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '53'
- en: if a group is empty, let's set its center to 0s
  id: totrans-1751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if a group is empty, let's set its center to 0s
- en: '54'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: centers[is.nan(centers)] <- 0
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: centers[is.nan(centers)] <- 0
- en: '55'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: '}'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '56'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: centers
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: centers
- en: '57'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: '}'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The code here is largely similar to our earlier mutual outlinks example.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: The code here is largely similar to our earlier mutual outlinks example.
- en: However, there are a couple of new snow calls and a different kind of usage
    of an old call.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有几个新的 snow 调用和一个旧调用的不同用法。
- en: Let’s start with lines 39 through 44\. Since our matrix m does not change from
    one iteration to the next, we definitely do not want to resend it to the workers
    repeatedly, exacerbating the overhead problem. Thus, first we need to send each
    worker its assigned chunk of m, just once. This is done in line 44
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第 39 行到第 44 行开始。由于我们的矩阵 m 在每次迭代中都不会改变，我们绝对不希望反复将其发送到工作者，这会加剧开销问题。因此，首先我们需要将
    m 的分配块发送给每个工作者，只发送一次。这是在第 44 行完成的。
- en: via snow’s clusterApply() function, which we used earlier but need to get creative
    with here. In line 41, we define the function mcf(), which will, running Parallel
    R
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们之前使用但现在需要发挥创造性的 snow 的 clusterApply() 函数，我们在第 41 行定义了函数 mcf()，该函数将在并行 R
    中运行。
- en: '**339**'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '**339**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: on a worker, accept the worker’s chunk from the manager and then keep it as
    a global variable mchunk on the worker.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作者上，接受管理者的数据块并将其作为全局变量 mchunk 保留在工作者上。
- en: 'Line 46 makes use of a new snow function, clusterExport(), whose job it is
    to make copies of the manager’s global variables at the workers. The variable
    in question here is actually a function, dst(). Here is why we need to send it
    separately: The call in line 50 will send the function findnewgrps() to the workers,
    but although that function calls dst(), snow will not know to send the latter
    as well. Therefore we send it ourselves.'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 第 46 行使用了新的 snow 函数，clusterExport()，其任务是复制管理员的全局变量到工作者。这里的变量实际上是一个函数，dst()。我们需要单独发送它的原因如下：第
    50 行的调用会将函数 findnewgrps() 发送到工作者，尽管该函数调用了 dst()，但 snow 不会知道也要发送后者。因此，我们自行发送。
- en: Line 50 itself uses another new snow call, clusterCall(). This instructs each
    worker to call findnewgrps(), with centers as argument.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 第 50 行本身使用了另一个新的 snow 调用，clusterCall()。这指示每个工作者调用 findnewgrps()，其中 centers 作为参数。
- en: Recall that each worker has a different matrix chunk, so this call will work
    on different data for each worker. This once again brings up the controversy regarding
    the use of global variables, discussed in Section 7.8.4\.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个工作者都有一个不同的矩阵块，因此这个调用将针对每个工作者的不同数据进行操作。这再次引发了关于全局变量使用的争议，这在第 7.8.4 节中讨论过。
- en: Some software developers may be troubled by the use of a hidden argument in
    findnewgrps(). On the other hand, as mentioned earlier, using mchunk as an argument
    would mean sending it to the workers repeatedly, compromising performance.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件开发者可能会对 findnewgrps() 中使用隐藏参数感到困扰。另一方面，如前所述，使用 mchunk 作为参数意味着需要反复将其发送到工作者，这会损害性能。
- en: Finally, take a look at line 51\. The snow function clusterApply() always returns
    an R list. In this case, the return value is in sumcounts, each element of which
    is a matrix. We need to sum the matrices, producing a totals matrix.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看第 51 行。snow 函数 clusterApply() 总是返回一个 R 列表。在这种情况下，返回值在 sumcounts 中，每个元素都是一个矩阵。我们需要对矩阵进行求和，生成一个总计矩阵。
- en: Using R’s sum() function wouldn’t work, as it would total all the elements of
    the matrices into a single number. Matrix addition is what we need.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 的 sum() 函数是不行的，因为它会将矩阵的所有元素加起来变成一个单一的数字。我们需要的是矩阵加法。
- en: Calling R’s Reduce() function will do the matrix addition. Recall that any arithmetic
    operation in R is implemented as a function; in this case, it is implemented as
    the function "+". The recall to Reduce() then successively applies "+" to the
    elements of the list sumcounts. Of course, we could just write a loop to do this,
    but using Reduce() may give us a small performance boost.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 R 的 Reduce() 函数可以进行矩阵加法。回想一下，R 中的任何算术运算都是以函数的形式实现的；在这种情况下，它是以 "+" 函数的形式实现的。然后对
    Reduce() 的调用会依次将 "+" 应用到 sumcounts 列表的元素上。当然，我们也可以直接写一个循环来完成这个操作，但使用 Reduce()
    可能会给我们带来一点性能提升。
- en: '**16.3 Resorting to C**'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3 转向 C**'
- en: As you’ve seen, using parallel R may greatly speed up your R code. This allows
    you to retain the convenience and expressive power of R, while still ameliorating
    large runtimes in big applications. If the parallelized R gives you sufficiently
    good performance, then all is well.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用并行 R 可以大大加快你的 R 代码的执行速度。这允许你保留 R 的便利性和表达力，同时仍然可以改善大型应用程序中的长时间运行。如果并行化的
    R 给你足够好的性能，那么一切就都很好了。
- en: Nevertheless, parallel R is still R and thus still subject to the performance
    issues covered in Chapter 14\. Recall that one solution offered in that chapter
    was to write a performance-critical portion of your code in C and then call that
    code from your main R program. (The references to C here mean C or C++.) We will
    explore this from a parallel-processing viewpoint. Here, instead of writing parallel
    R, we write ordinary R code that calls parallel C. (I assume a knowledge of C.)
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并行 R 仍然是 R，因此仍然受到第 14 章中讨论的性能问题的影响。回想一下，在第 14 章中提供的一个解决方案是将代码的关键部分用 C 语言编写，然后从主
    R 程序中调用该代码。（这里的 C 指的是 C 或 C++。）我们将从并行处理的角度来探讨这个问题。在这里，我们不是编写并行 R 代码，而是编写调用并行 C
    的普通 R 代码。（我假设您了解 C 语言。）
- en: '***16.3.1 Using Multicore Machines***'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.1 使用多核机器***'
- en: The C code covered here runs only on multicore systems, so we must discuss the
    nature of such systems.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的 C 代码仅在多核系统上运行，因此我们必须讨论这类系统的本质。
- en: '**340**'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '**340**'
- en: Chapter 16
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: You are probably familiar with dual-core machines. Any computer includes a CPU,
    which is the part that actually runs your program. In essence, a dual-core machine
    has two CPUs, a quad-core system has four, and so on.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉双核机器。任何计算机都包含一个 CPU，这是实际运行您程序的部分。本质上，双核机器有两个 CPU，四核系统有四个，依此类推。
- en: With multiple cores, you can do parallel computation!
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 多核处理器允许进行并行计算！
- en: This parallel computation is done with *threads*, which are analogous to snow’s
    workers. In computationally intensive applications, you generally set up as many
    threads as there are cores, for example two threads in a dual-core machine. Ideally,
    these threads run simultaneously, though overhead issues do arise, as will be
    explained when we look at general performance issues in Section 16.4.1\.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 这种并行计算是通过 *线程* 来实现的，它们类似于雪的工人。在计算密集型应用中，通常设置的线程数与核心数相同，例如在双核机器上设置两个线程。理想情况下，这些线程可以同时运行，尽管会出现开销问题，这将在我们查看第
    16.4.1 节中的通用性能问题时进行解释。
- en: If your machine has multiple cores, it is structured as a *shared-memory* system.
    All cores access the same RAM. The shared nature of the memory makes communication
    between the cores easy to program. If a thread writes to a memory location, the
    change is visible to the other threads, without the programmer needing to insert
    code to make that happen.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器具有多个核心，它将结构化为一个 *共享内存* 系统。所有核心都访问相同的 RAM。内存的共享特性使得核心之间的通信易于编程。如果一个线程写入内存位置，该变化对其他线程可见，而无需程序员插入代码来实现这一点。
- en: '***16.3.2 Extended Example: Mutual Outlinks Problem in OpenMP***'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.2 扩展示例：OpenMP 中的互链问题***'
- en: OpenMP is a very popular package for programming on multicore machines.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 是一个在多核机器上编程的非常流行的包。
- en: 'To see how it works, here is the mutual outlinks example again, this time in
    R-callable OpenMP code:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，这里再次展示互链示例，这次是在可由 R 调用的 OpenMP 代码中：
- en: '1'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#include <omp.h>'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <omp.h>'
- en: '2'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '#include <R.h>'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <R.h>'
- en: '3'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: int tot; // grand total of matches, over all threads
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: int tot; // 所有线程的匹配总计数
- en: '5'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: // processes row pairs (i,i+1), (i,i+2), ...
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: // 处理行对 (i,i+1)，(i,i+2)，...
- en: '7'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: int procpairs(int i, int *m, int n)
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: int procpairs(int i, int *m, int n)
- en: '8'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '{ int j,k,sum=0;'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int j,k,sum=0;'
- en: '9'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: for (j = i+1; j < n; j++) {
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: for (j = i+1; j < n; j++) {
- en: '10'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: for (k = 0; k < n; k++)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: for (k = 0; k < n; k++)
- en: '11'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: // find m[i][k]*m[j][k] but remember R uses col-major order
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: // find m[i][k]*m[j][k] but remember R uses col-major order
- en: '12'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: sum += m[n*k+i] * m[n*k+j];
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: sum += m[n*k+i] * m[n*k+j];
- en: '13'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '}'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '14'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: return sum;
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: return sum;
- en: '15'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '}'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '16'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: void mutlinks(int *m, int *n, double *mlmean)
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: void mutlinks(int *m, int *n, double *mlmean)
- en: '18'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '{ int nval = *n;'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int nval = *n;'
- en: '19'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: tot = 0;
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: tot = 0;
- en: '20'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '#pragma omp parallel'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp parallel'
- en: '21'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '{ int i,mysum=0,'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: '{ int i,mysum=0,'
- en: '22'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: me = omp_get_thread_num(),
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: me = omp_get_thread_num(),
- en: '23'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: nth = omp_get_num_threads();
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: nth = omp_get_num_threads();
- en: '24'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: // in checking all (i,j) pairs, partition the work according to i;
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: // 在检查所有 (i,j) 对时，根据 i 分配工作；
- en: '25'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: // this thread me will handle all i that equal me mod nth
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: // 此线程 me 将处理所有等于 me mod nth 的 i
- en: '26'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: for (i = me; i < nval; i += nth) {
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = me; i < nval; i += nth) {
- en: Parallel R
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R
- en: '**341**'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: '**341**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '27'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: mysum += procpairs(i,m,nval);
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(i,m,nval);
- en: '28'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '}'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '29'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: '#pragma omp atomic'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp atomic'
- en: '30'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: tot += mysum;
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: tot += mysum;
- en: '31'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '}'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '32'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: int divisor = nval * (nval-1) / 2;
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: int divisor = nval * (nval-1) / 2;
- en: '33'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '*mlmean = ((float) tot)/divisor;'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: '*mlmean = ((float) tot)/divisor;'
- en: '34'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '}'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '***16.3.3 Running the OpenMP Code***'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.3 运行 OpenMP 代码***'
- en: 'Again, compilation follows the recipe in Chapter 15\. We do need to link in
    the OpenMP library, though, by using the -fopenmp and -lgomp options. Suppose
    our source file is *romp.c*. Then we use the following commands to run the code:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，编译遵循第15章中的配方。不过，我们确实需要通过使用-fopenmp和-lgomp选项来链接OpenMP库。假设我们的源文件是*romp.c*。然后我们使用以下命令来运行代码：
- en: 'gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o
    gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp Here’s an
    R test:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o
    gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp 这里是一个R测试：
- en: dyn.load("romp.so")
  id: totrans-1860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dyn.load("romp.so")
- en: Sys.setenv(OMP_NUM_THREADS=4)
  id: totrans-1861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Sys.setenv(OMP_NUM_THREADS=4)
- en: n <- 1000
  id: totrans-1862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n <- 1000
- en: m <- matrix(sample(0:1,n^2,replace=T),nrow=n)
  id: totrans-1863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m <- matrix(sample(0:1,n^2,replace=T),nrow=n)
- en: system.time(z <- .C("mutlinks",as.integer(m),as.integer(n),result=double(1)))
    user system elapsed
  id: totrans-1864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.time(z <- .C("mutlinks",as.integer(m),as.integer(n),result=double(1)))
    user system elapsed
- en: '0.830'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '0.830'
- en: '0.000'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '0.000'
- en: '0.218'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: '0.218'
- en: z$result
  id: totrans-1868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z$result
- en: '[1] 249.9471'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 249.9471'
- en: The typical way to specify the number of threads in OpenMP is through an operating
    system environment variable, OMP_NUM_THREADS. R is capable of setting operating
    system environment variables with the Sys.setenv() function. Here, I set the number
    of threads to 4, because I was running on a quad-core machine.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenMP中指定线程数量的典型方式是通过操作系统环境变量，OMP_NUM_THREADS。R能够通过Sys.setenv()函数设置操作系统环境变量。在这里，我将线程数设置为4，因为我正在一个四核机器上运行。
- en: Note the runtime—only 0.2 seconds! This compares to the 5.0-second
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运行时间——只有0.2秒！这比之前5.0秒的
- en: time we saw earlier for a 12-node snow system. This might be surprising to some
    readers, as our code in the snow version was vectorized to a fair degree, as mentioned
    earlier. Vectorizing is good, but again, R has many hidden sources of overhead,
    so C might do even better.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的12节点雪系统的时间。这可能会让一些读者感到惊讶，因为我们的代码在雪版本中已经相当程度地进行了向量化，如前所述。向量化是好的，但同样，R有很多隐藏的开销来源，所以C可能做得更好。
- en: '**NOTE**'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I tried R’s new byte-compilation function cmpfun(), but mtl() actually became
    slower.*'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '*我尝试了R的新字节编译函数cmpfun()，但mtl()实际上变慢了*。'
- en: Thus, if you are willing to write part of your code in parallel C, dramatic
    speedups may be possible.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你愿意用并行C编写你代码的一部分，可能会实现显著的加速。
- en: '**342**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '**342**'
- en: Chapter 16
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.3.4 OpenMP Code Analysis***'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.4 OpenMP代码分析***'
- en: OpenMP code is C, with the addition of *pragmas* that instruct the compiler
    to insert some library code to perform OpenMP operations. Look at line 20, for
    instance. When execution reaches this point, the threads will be activated. Each
    thread then executes the block that follows—lines 21 through 31—in parallel.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP代码是C，增加了*pragmas*，这些pragma指示编译器插入一些库代码以执行OpenMP操作。例如，看看第20行。当执行到达这个点时，线程将被激活。然后每个线程将并行执行随后的块——第21行到第31行。
- en: A key point is variable scope. All the variables within the block starting on
    line 21 are local to their specific threads. For example, we’ve named the total
    variable in line 21 mysum because each thread will maintain its own sum.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点是变量作用域。从第21行开始的块内的所有变量都是它们特定线程的局部变量。例如，我们之所以在第21行将总变量命名为mysum，是因为每个线程将维护自己的总和。
- en: By contrast, the global variable tot on line 4 is held in common by all the
    threads. Each thread makes its contribution to that grand total on line 30\.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第4行的全局变量tot被所有线程共享。每个线程在第30行对那个总和做出贡献。
- en: But even the variable nval on line 18 is held in common with all the threads
    (during the execution of mutlinks()), as it is declared outside the block beginning
    on line 21\. So, even though it is a local variable in terms of C scope, it is
    global to all the threads. Indeed, we could have declared tot on that line, too.
    It needs to be shared by all the threads, but since it’s not used outside mutlinks(),
    it could have been declared on line 18\.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使在第18行的变量nval也是与所有线程共享的（在mutlinks()执行期间），因为它是在第21行开始的块外部声明的。所以，尽管它从C的作用域角度来看是一个局部变量，但对于所有线程来说它是全局的。实际上，我们也可以在第21行声明tot。它需要被所有线程共享，但由于它不在mutlinks()外部使用，它可以在第18行声明。
- en: Line 29 contains another pragma, atomic. This one applies only to the single
    line following it—line 30, in this case—rather than to a whole block.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 第29行包含另一个pragma，atomic。这个pragma只适用于它后面的单行——在这个例子中是第30行——而不是整个块。
- en: The purpose of the atomic pragma is to avoid what is called a *race condition*
    in parallel-processing circles. This term describes a situation in which two threads
    are updating a variable at the same time, which may produce incorrect results.
    The atomic pragma ensures that line 30 will be executed by only one thread at
    a time. Note that this implies that in this section of the code, our parallel
    program becomes temporarily serial, which is a potential source of slowdown.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 原子预处理语句的目的是避免并行处理领域所说的“竞争条件”。这个术语描述了两个线程同时更新一个变量的情况，这可能会导致错误的结果。原子预处理语句确保一次只有一个线程执行第
    30 行。注意，这暗示了在这个代码段中，我们的并行程序暂时变成了串行，这可能是减慢速度的一个潜在原因。
- en: Where is the manager’s role in all of this? Actually, the manager is the original
    thread, and it executes lines 18 and 19, as well as .C(), the R function that
    makes the call to mutlinks(). When the worker threads are activated in line 21,
    the manager goes dormant. The worker threads become dormant once they finish line
    31\. At that point, the manager resumes execution. Due to the dormancy of the
    manager while the workers are executing, we do want to have as many workers as
    our machine has cores.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，管理者的角色在哪里？实际上，管理者是原始线程，它执行第 18 和 19 行，以及 .C()，这是调用 mutlinks() 的 R 函数。当工作线程在第
    21 行被激活时，管理者进入休眠状态。工作线程一旦完成第 31 行，就会进入休眠状态。在那个时刻，管理者恢复执行。由于管理者在工作线程执行期间处于休眠状态，我们希望有尽可能多的工作线程，就像机器的核数一样。
- en: 'The function procpairs() is straightforward, but note the manner in which the
    matrix m is being accessed. Recall from the discussion in Chapter 15 on interfacing
    R to C that the two languages store matrices differently: column by column in
    R and row-wise in C. We need to be aware of that difference here. In addition,
    we have treated the matrix m as a one-dimensional array, as is common in parallel
    C code. In other words, if n is, say, 4, then we treat m as a vector of 16 elements.
    Due to the column-major nature of R'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 procpairs() 很简单，但请注意访问矩阵 m 的方式。回想一下第 15 章关于 R 与 C 接口讨论中的内容，两种语言存储矩阵的方式不同：R
    中是按列存储，C 中是按行存储。我们需要注意这个差异。此外，我们将矩阵 m 作为一维数组处理，这在并行 C 代码中很常见。换句话说，如果 n 是，比如说，4，那么我们将
    m 视为一个包含 16 个元素的向量。由于 R 的列主序特性
- en: matrix storage, the vector will consist first of the four elements of column
    1, then the four of column 2, and so on. To further complicate matters, we must
    keep in mind that array indices in C start at 0, instead of starting at 1 as in
    R.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵存储，向量将首先包含第 1 列的四个元素，然后是第 2 列的四个元素，依此类推。为了进一步复杂化问题，我们必须记住，C 中的数组索引从 0 开始，而不是像
    R 中的那样从 1 开始。
- en: Putting all of this together yields the multiplication in line 12\. The factors
    here are the (k,i) and (k,j) elements of the version of m in the C code, which
    are the (i+1,k+1) and (j+1,k+1) elements back in the R code.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，就得到了第 12 行的乘法。这里的因子是 C 代码中 m 版本的 (k,i) 和 (k,j) 元素，在 R 代码中对应的是 (i+1,k+1)
    和 (j+1,k+1) 元素。
- en: Parallel R
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R
- en: '**343**'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '**343**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.3.5 Other OpenMP Pragmas***'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.5 其他 OpenMP 预处理器***'
- en: OpenMP includes a wide variety of possible operations—far too many to list here.
    This section provides an overview of some OpenMP pragmas that I consider especially
    useful.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 包含了各种各样的可能操作——多得无法在此一一列举。本节提供了我对一些特别有用的 OpenMP 预处理器的概述。
- en: '**16.3.5.1 The omp barrier Pragma**'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.1 omp barrier 预处理语句**'
- en: 'The parallel-processing term *barrier* refers to a line of code at which the
    threads rendezvous. The syntax for the omp barrier pragma is simple:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理术语 *屏障* 指的是线程会合的代码行。omp barrier 预处理语句的语法很简单：
- en: '#pragma omp barrier'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma omp barrier`'
- en: When a thread reaches a barrier, its execution is suspended until all other
    threads have reached that line. This is very useful for iterative algorithms;
    threads wait at a barrier at the end of every iteration.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程达到屏障时，它的执行会暂停，直到所有其他线程都到达那条线。这对于迭代算法非常有用；线程在每个迭代的末尾都在屏障处等待。
- en: Note that in addition to this explicit barrier invocation, some other pragmas
    place an implicit barrier following their blocks. These include single and parallel.
    There is an implied barrier immediately following line 31 in the previous listing,
    for example, which is why the manager stays dormant until all worker threads finish.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了这个显式的屏障调用之外，一些其他的预处理语句在其块之后放置了一个隐式的屏障。这些包括单线程和并行。例如，在前面的列表中，第 31 行之后立即有一个隐式的屏障，这就是为什么管理器保持休眠状态直到所有工作线程完成。
- en: '**16.3.5.2 The omp critical Pragma**'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.2 omp critical Pragma**'
- en: The block that follows this pragma is a *critical section*, meaning one in which
    only one thread is allowed to execute at a time. The omp critical pragma essentially
    serves the same purpose as the atomic pragma discussed earlier, except that the
    latter is limited to a single statement.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma之后的部分是一个*临界区*，意味着一次只允许一个线程执行。omp critical pragma基本上与前面讨论的atomic pragma具有相同的目的，只不过后者仅限于单个语句。
- en: '**NOTE**'
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The OpenMP designers defined a special pragma for this single-statement situation
    in* *the hope that the compiler can translate this to an especially fast machine
    instruction.*'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenMP的设计者定义了一个特殊的pragma来处理这种单语句情况，希望编译器可以将它转换为一个特别快速的机器指令。*'
- en: 'Here is the omp critical syntax:'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 这是omp critical语法的示例：
- en: '1'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#pragma omp critical'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp critical'
- en: '2'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: // place one or more statements here
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: // 在此处放置一个或多个语句
- en: '4'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '}'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**16.3.5.3 The omp single Pragma**'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.3.5.3 omp single Pragma**'
- en: 'The block that follows this pragma is to be executed by only one of the threads.
    Here is the syntax for the omp single pragma:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 此pragma之后的部分将由只有一个线程执行。以下是omp single pragma的语法：
- en: '1'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '#pragma omp single'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp single'
- en: '2'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: // place one or more statements here
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: // 在此处放置一个或多个语句
- en: '4'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '}'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**344**'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: '**344**'
- en: Chapter 16
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This is useful for initializing sum variables that are shared by the threads,
    for instance. As noted earlier, an automatic barrier is placed after the block.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于初始化由线程共享的求和变量很有用。如前所述，在块之后放置了一个自动屏障。
- en: This should make sense to you. If one thread is initializing a sum, you wouldn’t
    want other threads that make use of this variable to continue execution until
    the sum has been properly set.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对你来说是有意义的。如果一个线程正在初始化求和，你不会希望使用这个变量的其他线程在求和被正确设置之前继续执行。
- en: You can learn more about OpenMP in my open source textbook on par-
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的开源教科书上了解更多关于OpenMP的信息，关于并行编程的——
- en: allel processing at *http://heather.cs.ucdavis.edu/parprocbook*.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: allel处理在*http://heather.cs.ucdavis.edu/parprocbook*。
- en: '***16.3.6 GPU Programming***'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3.6 GPU编程***'
- en: Another type of shared-memory parallel hardware consists of graphics processing
    units (GPUs). If you have a sophisticated graphics card in your machine, say for
    playing games, you may not realize that it is also a very powerful computational
    device—so powerful that the slogan “A supercomputer on your desk!” is often used
    to refer to PCs equipped with high-end GPUs.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种共享内存并行硬件类型是图形处理单元（GPU）。如果你机器中有用于游戏的复杂显卡，你可能不会意识到它也是一个非常强大的计算设备——强大到经常用“桌面上的超级计算机！”这个口号来指代配备了高端GPU的PC。
- en: As with OpenMP, the idea here is that instead of writing parallel R, you write
    R code interfaced to parallel C. (Similar to the OpenMP case, *C*
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenMP一样，这里的想法是，你不需要编写并行R代码，而是编写与并行C接口的R代码。（与OpenMP的情况类似，*C*
- en: here means a slightly augmented version of the C language.) The technical details
    become rather complex, so I won’t show any code examples, but an overview of the
    platform is worthwhile.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 这里指的是C语言的略微增强版本。）技术细节变得相当复杂，所以我不展示任何代码示例，但对该平台的概述是值得的。
- en: As mentioned, GPUs do follow the shared-memory/threads model,
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GPU遵循共享内存/线程模型，
- en: but on a much larger scale. They have dozens, or even hundreds, of
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 但规模要大得多。它们有数十个，甚至数百个
- en: cores (depending on how you define *core*). One major difference is that several
    threads can be run together in a block, which can produce certain efficiencies.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 核心（取决于你如何定义*核心*）。一个主要区别是，可以在一个块中同时运行多个线程，这可以产生一定的效率。
- en: Programs that access GPUs begin their run on your machine’s CPU,
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GPU的程序从你机器的CPU开始运行，
- en: referred to as the *host*. They then start code running on the GPU, or *device*.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*主机*。然后它们在GPU上启动代码，或*设备*。
- en: This means that your data must be transferred from the host to the device, and
    after the device finishes its computation, the results must be transferred back
    to the host.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的数据必须从主机传输到设备，设备完成计算后，结果必须传输回主机。
- en: As of this writing, GPU has not yet become common among R users.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，GPU尚未在R用户中变得普遍。
- en: The most common usage is probably through the CRAN package gputools, which consists
    of some matrix algebra and statistical routines callable from R. For instance,
    consider matrix inversion. R provides the function solve() for this, but a parallel
    alternative is available in gputools with the name gpuSolve().
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的使用方式可能是通过CRAN包gputools，它包含一些可以从R调用的矩阵代数和统计例程。例如，考虑矩阵求逆。R提供了solve()函数来完成这个任务，但在gputools中有一个名为gpuSolve()的并行替代方案。
- en: For more about GPU programming, again see my book on parallel pro-
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GPU编程的更多信息，请再次参阅我关于并行编程的书籍。
- en: cessing at *http://heather.cs.ucdavis.edu/parprocbook*.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *http://heather.cs.ucdavis.edu/parprocbook* 处处理。
- en: '**16.4 General Performance Considerations**'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4 一般性能考虑**'
- en: This section discusses some issues that you may find generally useful in parallelizing
    R applications. I’ll present some material on the main sources of overhead and
    then discuss a couple of algorithmic issues.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了一些在并行化R应用时可能普遍有用的问题。我将介绍关于主要负载来源的一些材料，然后讨论几个算法问题。
- en: Parallel R
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R
- en: '**345**'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: '**345**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***16.4.1 Sources of Overhead***'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.1 负载来源***'
- en: Having at least a rough idea of the physical causes of overhead is essential
    to successful parallel programming. Let’s take a look at these in the contexts
    of the two main platforms, shared-memory and networked computers.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 了解开销的物理原因对于成功的并行编程至关重要。让我们从共享内存和网络计算机这两个主要平台的角度来看看这些问题。
- en: '**16.4.1.1 Shared-Memory Machines**'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.1.1 共享内存机器**'
- en: As noted earlier, the memory sharing in multicore machines makes for easier
    programming. However, the sharing also produces overhead, since the two cores
    will bump into each other if they both try to access memory at the same time.
    This means that one of them will need to wait, causing overhead. That overhead
    is typically in the range of hundreds of nanoseconds (billionths of seconds).
    This sounds really small, but keep in mind that the CPU is working at a subnanosecond
    speed, so memory access often becomes a bottleneck.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多核机器中的内存共享使得编程更容易。然而，共享也会产生开销，因为如果两个核心同时尝试访问内存，它们会相互冲突。这意味着其中一个需要等待，从而产生开销。这种开销通常在数百纳秒（秒的十亿分之一）的范围内。这听起来真的很小，但请记住，CPU以亚纳秒的速度工作，所以内存访问经常成为瓶颈。
- en: Each core may also have a *cache*, in which it keeps a local copy of some of
    the shared memory. It’s intended to reduce contention for memory among the cores,
    but it produces its own overhead, involving time spent in keeping the caches consistent
    with each other.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 每个核心也可能有一个*缓存*，其中它保留了一些共享内存的本地副本。它的目的是减少核心之间的内存竞争，但它会产生自己的开销，包括保持缓存之间一致性的时间开销。
- en: Recall that GPUs are special types of multicore machines. As such, they suffer
    from the problems I’ve described, and more. First, the *latency*, which is the
    time delay before the first bit arrives at the GPU from its memory after a memory
    read request, is quite long in GPUs.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，GPU是特殊的多核机器。因此，它们会遭受我描述的问题，以及更多。首先，*延迟*，即从内存读取请求后，第一个比特到达GPU的时间延迟，在GPU中相当长。
- en: There is also the overhead incurred in transferring data between the host and
    the device. The latency here is on the order of microseconds (millionths of seconds),
    an eternity compared to the nanosecond scale of the CPU and GPU.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机和设备之间传输数据时，也会产生开销。这里的延迟在微秒（百万分之一秒）的量级，与CPU和GPU的纳秒尺度相比，这是一个永恒的时间。
- en: GPUs have great performance potential for certain classes of applications, but
    overhead can be a major issue. The authors of gputools note that their matrix
    operations start achieving a speedup only at matrix sizes of 1000
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: GPU对于某些类别的应用具有巨大的性能潜力，但开销可能是一个主要问题。gputools的作者指出，他们的矩阵运算只有在矩阵大小达到1000时才开始实现加速。
- en: by 1000\. I wrote a GPU version of our mutual outlinks application, which turned
    out to have a runtime of 3.0 seconds—about half of the snow version but still
    far slower than the OpenMP implementation.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 通过1000个例子。我编写了我们共同链接应用的GPU版本，其运行时间为3.0秒——大约是雪版的一半，但仍然比OpenMP实现慢得多。
- en: Again, there are ways of ameliorating these problems, but they require very
    careful, creative programming and a sophisticated knowledge of the physical GPU
    structure.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有方法可以缓解这些问题，但它们需要非常仔细、有创造性的编程和深入了解物理GPU结构。
- en: '**16.4.1.2 Networked Systems of Computers**'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.1.2 计算机网络系统**'
- en: As you saw earlier, another way to achieve parallel computation is through networked
    systems of computers. You still have multiple CPUs, but in this case, they are
    in entirely separate computers, each with its own memory.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，实现并行计算的另一种方式是通过计算机网络系统。您仍然有多个CPU，但在这个案例中，它们位于完全独立的计算机中，每个计算机都有自己的内存。
- en: As pointed out earlier, network data transfer causes overhead. Its latency is
    again on the order of microseconds. Thus, even accessing a small amount of data
    across the network incurs a major delay.
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网络数据传输会产生开销。其延迟再次在微秒级别。因此，即使通过网络访问少量数据也会产生很大的延迟。
- en: Also note that snow has additional overhead, as it changes numeric
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，雪有额外的开销，因为它会改变数值
- en: objects such as vectors and matrices to character form before sending them,
    say from the manager to the workers. Not only does this entail time for the conversion
    (both in changing from numeric to character form and **346**
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送之前将对象如向量和矩阵转换为字符形式，比如说从管理者到工作者。这不仅涉及到转换的时间（无论是从数值形式转换为字符形式还是**346**）
- en: Chapter 16
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: in charging back to numeric at the receiver), but the character form tends to
    make for much longer messages, thus longer network transfer time.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端重新计算数值时)，但字符形式往往会导致消息更长，从而增加网络传输时间。
- en: Shared-memory systems can be networked together, which, in fact, we did in the
    previous example. We had a hybrid situation in which we formed snow clusters from
    several networked dual-core computers.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存系统可以联网，实际上，我们在前面的例子中就是这样做的。我们有一个混合情况，即从几个联网的双核计算机中形成了雪簇。
- en: '***16.4.2 Embarrassingly Parallel Applications and Those That Aren’t***'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.2 令人尴尬的并行应用和那些不是的应用***'
- en: It’s no shame to be poor, but it’s no great honor either.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 贫穷并不丢人，但也不算是什么荣耀。
- en: —Tevye, *Fiddler on the Roof*
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: ——Tevye，《屋顶上的提琴手》
- en: Man is the only animal that blushes, or needs to.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是唯一会脸红，或者需要脸红的动物。
- en: —Mark Twain
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: ——马克·吐温
- en: The term *embarrassingly parallel* is heard often in talk about parallel R
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于并行R的讨论中，经常听到“令人尴尬的并行”这个术语。
- en: (and in the parallel processing field in general). The word *embarrassing* alludes
    to the fact that the problems are so easy to parallelize that there is no intellectual
    challenge involved; they are embarrassingly easy.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: （以及在并行处理领域）。单词“尴尬”暗示了这样一个事实，即问题如此容易并行化，以至于其中不涉及任何智力挑战；它们是尴尬地容易。
- en: Both of the example applications we’ve looked at here would be con-
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里查看的两个示例应用都会是
- en: sidered embarrassingly parallel. Parallelizing the for i loop for the mutual
    outlinks problem in Section 16.1 was pretty obvious. Partitioning the work in
    the KMC example in Section 16.2.4 was also natural and easy.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是令人尴尬的并行。在16.1节中，对互连出链问题的for i循环进行并行化是非常明显的。在16.2.4节中，KMC示例中的工作划分也是自然且容易的。
- en: By contrast, most parallel sorting algorithms require a great deal of interaction.
    For instance, consider merge sort, a common method of sorting numbers. It breaks
    the vector to be sorted into two (or more) independent parts, say the left half
    and right half, which are then sorted in parallel by two processes. So far, this
    is embarrassingly parallel, at least after the vector is divided in half. But
    then the two sorted halves must be merged to produce the sorted version of the
    original vector, and that process is *not* embarrassingly parallel. It can be
    parallelized but in a more complex manner.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，大多数并行排序算法需要大量的交互。例如，考虑归并排序，这是一种常见的排序数字的方法。它将待排序的向量分成两个（或更多）独立的部分，比如左半部分和右半部分，然后由两个进程并行排序。到目前为止，这是令人尴尬的并行，至少在向量被分成一半之后。但是，然后必须将两个已排序的半部分合并以产生原始向量的排序版本，而这个过程**不是**令人尴尬的并行。它可以并行化，但方式更为复杂。
- en: Of course, to paraphrase Tevye, it’s no shame to have an embarrassingly parallel
    problem! It may not exactly be an honor, but it is a cause for cele-bration, as
    it is easy to program. More important, embarrassingly parallel problems tend to
    have low communication overhead, which is crucial to performance, as discussed
    earlier. In fact, when most people refer to embarrassingly parallel applications,
    they have this low overhead in mind.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用Tevye的话来说，有一个令人尴尬的并行问题并不丢人！这也许并不完全是一种荣誉，但它是值得庆祝的，因为它容易编程。更重要的是，令人尴尬的并行问题通常具有低通信开销，正如前面讨论的那样，这对于性能至关重要。事实上，当大多数人提到令人尴尬的并行应用时，他们心中想的正是这种低开销。
- en: 'But what about nonembarrassingly parallel applications? Unfortunately, parallel
    R code is simply not suitable for many of them for a very basic reason: the functional
    programming nature of R. As discussed in Section 14.3, a statement like this:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于非令人尴尬的并行应用呢？不幸的是，由于R的函数式编程特性，并行R代码对于许多这样的应用来说并不适合，这是一个非常基本的原因：如第14.3节所述，一个像这样的语句：
- en: x[3] <- 8
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: x[3] <- 8
- en: is deceptively simple, because it can cause the entire vector x to be rewritten.
    This really compounds communication traffic problems. Accordingly, if your application
    is not embarrassingly parallel, your best strategy is probably to write the computationally
    intensive parts of the code in C, say using OpenMP or GPU programming.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 是表面上很简单，因为它可能导致整个向量x被重写。这实际上加剧了通信流量问题。因此，如果你的应用不是令人尴尬的并行，你的最佳策略可能是将代码的计算密集部分用C编写，例如使用OpenMP或GPU编程。
- en: Parallel R
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R
- en: '**347**'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: '**347**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Also, note carefully that even being embarrassingly parallel does not make an
    algorithm efficient. Some such algorithms can still have significant communication
    traffic, thus compromising performance.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，即使是令人尴尬的并行化也不一定使算法高效。某些这样的算法仍然可能存在大量的通信流量，从而影响性能。
- en: Consider the KMC problem, run under snow. Suppose we were to set
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在雪地中运行的KMC问题。假设我们要设置
- en: up a large enough number of workers so that each worker had relatively little
    work to do. In that case, the communication with the manager after each iteration
    would become a signficant portion of run time. In this situation, we would say
    that the *granularity* is too fine, and then probably switch to using fewer workers.
    We would then have larger tasks for each worker, thus a *coarser* granularity.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 增加足够多的工人，以便每个工人有相对较少的工作要做。在这种情况下，每次迭代后与经理的通信将变成运行时间的一个很大部分。在这种情况下，我们会说粒度太细，然后可能切换到使用更少的工人。这样，每个工人的任务就会更大，因此粒度会更**粗**。
- en: '***16.4.3 Static Versus Dynamic Task Assignment***'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.3 静态与动态任务分配***'
- en: Look again at the loop beginning on line 26 of our OpenMP example,
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的OpenMP示例的第26行开始的循环，
- en: 'reproduced here for convenience:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容为方便查阅而复制：
- en: for (i = me; i < nval; i += nth) {
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: for (i = me; i < nval; i += nth) {
- en: mysum += procpairs(i,m,nval);
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(i,m,nval);
- en: '}'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The variable me here was the thread number, so the effect of this code was that
    the various threads would work on nonoverlapping sets of values of i. We do want
    the values to be nonoverlapping, to avoid duplicate work and an incorrect count
    of total number of links, so the code was fine. But the point now is that we were,
    in effect, preassigning the tasks that each thread would handle. This is called
    *static* assignment.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变量me是线程号，因此这段代码的效果是各个线程将工作在i的值的非重叠集合上。我们确实希望这些值是非重叠的，以避免重复工作和总链接数的错误计数，所以代码是好的。但现在的问题是，我们实际上是在预先分配每个线程要处理的任务。这被称为**静态**分配。
- en: 'An alternative approach is to revise the for loop to look something like this:'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是修改for循环，使其看起来像这样：
- en: int nexti = 0; // global variable
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: int nexti = 0; // 全局变量
- en: '...'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: for ( ; myi < n; ) { // revised "for" loop
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: for ( ; myi < n; ) { // 修改后的"for"循环
- en: '#pragma omp critical'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma omp critical'
- en: '{'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: nexti += 1;
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: nexti += 1;
- en: myi = nexti;
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: myi = nexti;
- en: '}'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (myi < n) {
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: if (myi < n) {
- en: mysum += procpairs(myi,m,nval);
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: mysum += procpairs(myi,m,nval);
- en: '...'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: This is *dynamic* task assignment, in which it is not determined ahead of time
    which threads handle which values of i. Task assignment is done during execution.
    At first glance, dynamic assignment seems to have the potential for better performance.
    Suppose, for instance, that in a static assignment **348**
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种**动态**的任务分配，其中在执行之前并没有确定哪些线程处理哪些i的值。任务分配是在执行过程中完成的。乍一看，动态分配似乎有更好的性能潜力。例如，假设在静态分配中**348**
- en: Chapter 16
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: setting, one thread finishes its last value of i early, while another thread
    still has two values of i left to do. This would mean our program would finish
    somewhat later than it could. In parallel-processing parlance, we would have a
    *load balance* problem. With dynamic assignment, the thread that finished when
    there were two values of i left to handle could have taken up one of those values
    itself. We would have better balance and theoretically less overall runtime.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 设置时，一个线程提前完成了其最后一个i的值，而另一个线程还有两个i的值未完成。这意味着我们的程序可能会比预期晚一些完成。在并行处理术语中，我们会遇到一个*负载平衡*问题。使用动态分配，当还剩下两个i的值要处理时，完成工作的线程可以自己承担其中一个值。这样我们会获得更好的平衡，并且理论上整体运行时间会更短。
- en: But don’t jump to conclusions. As always, we have the overhead issue to reckon
    with. Recall that a critical pragma, used in the dynamic version of the code above,
    has the effect of temporarily rendering the program serial rather than parallel,
    thus causing a slowdown. In addition, for reasons too technical to discuss here,
    these pragmas may cause considerable cache activity overhead. So in the end, the
    dynamic code could actually be substantially slower than the static version.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要急于下结论。像往常一样，我们还有开销问题要考虑。回想一下，上面代码的动态版本中使用的临界pragma会暂时将程序变为串行而不是并行，从而造成速度减慢。此外，由于这里讨论的技术原因过于复杂，这些pragma可能会引起相当大的缓存活动开销。因此，最终，动态代码实际上可能比静态版本慢得多。
- en: Various solutions to this problem have been developed, such as an
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发出各种解决这个问题的方法，例如一个
- en: OpenMP construct named guided. But rather than present these, the point I wish
    to make is that they are unnecessary. In most situations, static assignment is
    just fine. Why is this the case?
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP中名为guided的构造。但我不想介绍这些，我想说的是，它们是不必要的。在大多数情况下，静态分配就足够好了。为什么是这样呢？
- en: 'You may recall that the standard deviation of the sum of independent, identically
    distributed random variables, divided by the mean of that sum, goes to zero as
    the number of terms goes to infinity. In other words, sums are approximately constant.
    This has a direct implication for our load-balancing concerns: Since the total
    work time for a thread in static assignment is the sum of its individual task
    times, that total work time will be approximately constant; there will be very
    little variation from thread to thread. Thus, they will all finish at pretty close
    to the same time, and we do not need to worry about load imbalance. Dynamic scheduling
    will not be necessary.'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，独立同分布随机变量的总和的标准差，除以该总和的均值，当项数趋于无穷大时趋近于零。换句话说，总和是近似恒定的。这对我们的负载平衡问题有直接影响：由于静态分配中线程的总工作时间是其各个任务时间的总和，因此总工作时间将近似恒定；线程之间的差异将非常小。因此，它们将几乎同时完成，我们不需要担心负载不平衡。动态调度将不是必要的。
- en: 'This reasoning does depend on a statistical assumption, but in practice, the
    assumption will typically be met sufficiently well for the outcome: Static scheduling
    does as well as dynamic in terms of uniformity of total work times across threads.
    And since static scheduling doesn’t have the overhead problems of the dynamic
    kind, in most cases the static approach will give better performance.'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理依赖于一个统计假设，但在实践中，这个假设通常能够很好地满足结果：在总工作时间的均匀性方面，静态调度与动态调度相当。而且由于静态调度没有动态调度那样的开销问题，在大多数情况下，静态方法将提供更好的性能。
- en: 'There is one more aspect of this to discuss. To illustrate the issue, consider
    again the mutual outlinks example. Let’s review the outline of the algorithm:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于这个问题的更多方面需要讨论。为了说明问题，再次考虑互链示例。让我们回顾一下算法的大纲：
- en: '1'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sum = 0
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: sum = 0
- en: '2'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: for i = 0...n-1
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: for i = 0...n-1
- en: '3'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: for j = i+1...n-1
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: for j = i+1...n-1
- en: '4'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: for k = 0...n-1 sum = sum + a[i][k]*a[j][k]
- en: '5'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: mean = sum / (n*(n-1)/2)
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: mean = sum / (n*(n-1)/2)
- en: Say n is 10000 and we have four threads, and consider ways to partition the
    for i loop. Naively, we might at first decide to have thread 0 handle the i values
    0 through 2499, thread 1 handle 2500 through 4999, and so on.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 假设n是10000，我们有四个线程，考虑如何划分for i循环。一开始，我们可能决定让线程0处理i值0到2499，线程1处理2500到4999，依此类推。
- en: However, this would produce a severe load imbalance, since the thread that Parallel
    R
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致严重的负载不平衡，因为并行R
- en: '**349**'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: '**349**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'handles a given value of i does an amount of work proportional to n-i. That,
    in fact, is why we staggered the values of i in our actual code: Thread 0 handled
    the i values 0, 4, 8 ..., thread 1 worked on 1, 5, 9, ..., and so on, yielding
    good load balance.'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 处理i的给定值时，所做的工量与n-i成比例。事实上，这就是我们实际代码中交错i值的原因：线程0处理i值0、4、8...，线程1处理1、5、9...，以此类推，从而实现良好的负载平衡。
- en: The point then is that static assignment might require a bit more plan-ning.
    One general approach to this is to randomly assign tasks (i values, in our case
    here) to threads (still doing so at the outset, before work begins).
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，静态分配可能需要更多的计划。一种一般的方法是将任务（在我们的例子中是i值）随机分配给线程（仍然在开始工作之前这样做）。
- en: With a bit of forethought such as this, static assignment should work well in
    most applications.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的事先考虑，静态分配在大多数应用中应该工作得很好。
- en: '***16.4.4 Software Alchemy: Turning General Problems into Embarrassingly***'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4.4 软件炼金术：将一般问题转化为令人尴尬的***'
- en: '***Parallel Ones***'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: '***并行问题***'
- en: As discussed earlier, it’s difficult to attain good performance from nonembarrassingly
    parallel algorithms. Fortunately, for statistical applications, there is a way
    to turn nonembarrassingly parallel problems into embarrassingly parallel ones.
    The key is to exploit some statistical properties.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从非令人尴尬的并行算法中获得良好性能很困难。幸运的是，对于统计应用，有一种方法可以将非令人尴尬的并行问题转化为令人尴尬的并行问题。关键是利用一些统计特性。
- en: To demonstrate the method, let’s once again turn to our mutual out-
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种方法，让我们再次转向我们的共同输出-
- en: 'links problem. The method, applied with w workers on a links matrix m, consists
    of the following:'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 链接问题。使用w个工人在链接矩阵m上应用的方法包括以下内容：
- en: 1\.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Break the rows of m into w chunks.
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 将m行的行分成w个块。
- en: 2\.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Have each worker find the mean number of mutual outlinks for pairs of vertices
    in its chunk.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 让每个工人找到其块中顶点对相互输出链接的平均数。
- en: 3\.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Average the results returned by the workers.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 平均工人返回的结果。
- en: It can be shown mathematically that for large problems (the only ones you would
    need parallel computing for anyway), this chunked approach gives the estimators
    of the same statistical accuracy as in the nonchunked method. But meanwhile, we’ve
    turned a nonparallel problem into not just a parallel one but an embarrassingly
    parallel one! The workers in the preceding outline compute entirely independently
    of each other.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从数学上证明，对于大型问题（你无论如何都需要并行计算的问题），这种块方法给出了与无块方法相同的统计精度估计。但与此同时，我们将一个非并行问题变成了不仅是一个并行问题，而且是一个令人尴尬的并行问题！前面概述中的工人完全独立于彼此计算。
- en: This method should not be confused with the usual chunk-based
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不应与通常基于块的
- en: approaches in parallel processing. In those, such as the merge-sort example
    discussed on page 347, the chunking is embarrassingly parallel, but the combining
    of results is not. By contrast, here the combining of results consists of simple
    averaging, thanks to the mathematical theory.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理方法。在这些方法中，例如在第347页讨论的归并排序示例，块处理是令人尴尬的并行，但结果的合并不是。相比之下，这里结果的合并由简单的平均组成，这得益于数学理论。
- en: I tried this approach on the mutual outlinks problem in a 4-worker snow cluster.
    This reduced the runtime to 1.5 seconds. This is far better than the serial time
    of about 16 seconds, double the speedup obtained by the GPU
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个4个工作者的雪集群上尝试了这种方法来解决相互输出链接问题。这减少了运行时间到1.5秒。这远远优于大约16秒的串行时间，是GPU获得的加速速度的两倍。
- en: and approaching comparability to the OpenMP time. And the theory showing that
    the two methods give the same statistical accuracy was confirmed as well. The
    chunked method found the mean number of mutual outlinks to be 249.2881, compared
    to 249.2993 for the original estimator.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 并接近OpenMP时间。同时，证实了两种方法给出相同统计准确性的理论。块方法发现相互输出链接的平均数为249.2881，与原始估计器的249.2993相比。
- en: '**350**'
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: '**350**'
- en: Chapter 16
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**16.5 Debugging Parallel R Code**'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.5 调试并行R代码**'
- en: Parallel R packages such as Rmpi, snow, foreach, and so on do not set up a terminal
    window for each process, thus making it impossible to use R’s debugger on the
    workers. (My Rdsm package, which adds a threads capability to R, is an exception
    to this.)
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 并行R包，如Rmpi、snow、foreach等，不会为每个进程设置终端窗口，因此无法在工人上使用R的调试器。（我的Rdsm包，它为R添加了线程功能，是这一点的例外。）
- en: What then can you do to debug apps for those packages? Let’s consider snow for
    a concrete example.
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您可以为这些包进行哪些调试操作？让我们以 snow 为一个具体的例子来考虑。
- en: First, you should debug the underlying single-worker function, such as mtl()
    in Section 16.2\. Here, we would set up some artificial values of the arguments
    and then use R’s ordinary debugging facilities.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该调试底层单工作进程函数，例如 16.2 节中的 mtl()。在这里，我们会设置一些参数的人工值，然后使用 R 的常规调试功能。
- en: Debugging the underlying function may be sufficient. However, the bug may be
    in the arguments themselves or in the way we set them up. Then things get more
    difficult.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 调试底层函数可能就足够了。然而，错误可能存在于参数本身或我们设置参数的方式中。然后事情就变得更加困难。
- en: It’s even hard to print out trace information, such as values of variables,
    since print() won’t work in the worker processes. The message() function may work
    for some of these packages; if not, you may need to resort to using cat() to write
    to a file.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至打印出跟踪信息（如变量的值）都很困难，因为 print() 在工作进程中将不起作用。message() 函数可能适用于某些这些包；如果不适用，您可能需要求助于使用
    cat() 将内容写入文件。
- en: Parallel R
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R
- en: '**351**'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: '**351**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 44](index-379_1.png)'
  id: totrans-2066
  prefs: []
  type: TYPE_IMG
  zh: '![Image 44](index-379_1.png)'
- en: '**A**'
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**'
- en: '**INSTALLING R**'
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 R**'
- en: This appendix covers the methods for
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖了安装 R 的方法
- en: installing R on your system. You can eas-
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上安装 R。您可以轻松地下载和安装预编译的
- en: ily download and install the precompiled
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: ily download and install the precompiled
- en: binaries, use your package manager on a UNIX-
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: binaries，使用 UNIX-包管理器
- en: based system, or even install from source if you prefer.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: based system，或者如果您愿意，甚至可以从源代码安装。
- en: '**A.1 Downloading R from CRAN**'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.1 从 CRAN 下载 R**'
- en: R, in both its base form and user-written packages, is available on the Comprehensive
    R Archive Network (CRAN) at the R home page, *http://www*
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: R，无论是其基本形式还是用户编写的包，都可以在 R 主页的 Comprehensive R Archive Network (CRAN) 上找到，*http://www*
- en: '*.r-project.org/*. Click CRAN and choose a site near you to download the appropriate
    base package for your operating system (OS).'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: '*.r-project.org/*. 点击 CRAN 并选择您附近的站点以下载适合您操作系统的适当基础包。'
- en: For most users, installing R is quite simple, regardless of the platform.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用户来说，无论平台如何，安装 R 都相当简单。
- en: You can find precompiled binaries for Windows, Linux, and Mac OS X on CRAN.
    You should be able to simply download the appropriate file and install R.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 CRAN 上找到 Windows、Linux 和 Mac OS X 的预编译二进制文件。您应该能够简单地下载适当的文件并安装 R。
- en: '**A.2 Installing from a Linux Package Manager**'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.2 从 Linux 包管理器安装**'
- en: Rather than using the precompiled binaries, if you’re running a Linux distribution
    with a centralized package repository, such as Fedora or Ubuntu, you
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行具有集中式软件仓库的 Linux 发行版，例如 Fedora 或 Ubuntu，而不是使用预编译的二进制文件，您
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'can install R using your OS’s package manager. For example, if you’re running
    Fedora, you can install R by typing the following at the command line: $ yum install
    R'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用您的操作系统包管理器安装 R。例如，如果您正在运行 Fedora，您可以在命令行中键入以下内容来安装 R：$ yum install R
- en: For a Debian-based system, such as Ubuntu, the command looks
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Debian 的系统，例如 Ubuntu，命令如下
- en: 'like this:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 'like this:'
- en: $ sudo apt-get install r-base
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt-get install r-base
- en: Check your distribution’s documentation for more details on installing and removing
    packages.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅您发行版的文档以获取有关安装和删除包的更多详细信息。
- en: '**A.3 Installing from Source**'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.3 从源代码安装**'
- en: 'On Linux or other UNIX-based machines (probably including Mac OS X), you can
    also compile R’s source code yourself. Simply unpack the source archive and follow
    the classic three-command installation procedure: $ configure'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或其他基于 UNIX 的机器（可能包括 Mac OS X）上，您也可以自己编译 R 的源代码。只需解压源代码存档，然后遵循经典的三个命令安装程序：$
    configure
- en: $ make
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: $ make
- en: $ make install
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: $ make install
- en: 'Note that you may need to run make install as root, depending on your write
    permissions and the location to which you’re installing R. If you want to install
    to a nonstandard directory, say */a/b/c*, you can run configure with the --prefix
    parameter, like this:'
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能需要以 root 用户身份运行 make install，这取决于您的写入权限和您安装 R 的位置。如果您想安装到非标准目录，例如 */a/b/c*，您可以使用
    --prefix 参数运行 configure，如下所示：
- en: $ configure --prefix=/a/b/c
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: $ configure --prefix=/a/b/c
- en: This might be helpful if you’re working on a shared machine and don’t have write
    permissions to the standard installation directories like */usr*.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用共享机器并且没有写入标准安装目录（如 */usr*）的权限，这可能很有帮助。
- en: '**354**'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: '**354**'
- en: Appendix A
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 45](index-381_1.png)'
  id: totrans-2097
  prefs: []
  type: TYPE_IMG
  zh: '![Image 45](index-381_1.png)'
- en: '**B**'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**'
- en: '**INSTALLING AND USING PACKAGES**'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装和使用包**'
- en: One of the major strengths of R is that
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: R的一个主要优势是
- en: thousands of user-written packages are
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 数千个用户编写的包
- en: available on the Comprehensive R Archive
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 在综合R存档
- en: Network (CRAN) at the R home page, *http://*
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 网络（CRAN）在R主页上，*http://*
- en: '*www.r-project.org/*. Package installation is easy in most'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.r-project.org/*. R包的安装在大多数情况下都很简单'
- en: cases, but there are nuances to be aware of for some of
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 的情况下，但需要注意一些细微差别
- en: the specialty packages.
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些专业包。
- en: This appendix starts with some package basics and then explains how to load
    R packages from your hard drive and from the Web.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录首先介绍一些包的基本知识，然后解释如何从你的硬盘驱动器和网络加载R包。
- en: '**B.1 Package Basics**'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.1 包的基本知识**'
- en: R uses packages to store groups of related pieces of software. The packages
    that are included with the R distribution are visible as subdirectories of your
    *library* directory in your R installation tree, as in */usr/lib/R/library*.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: R使用包来存储相关软件的组。包含在R发行版中的包作为你的R安装树中 *library* 目录的子目录可见，例如 */usr/lib/R/library*。
- en: '**NOTE**'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the R community, the term* library *is often used in place of* package
    *.*'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: '*在R社区中，术语* library *通常用来代替* package *.*'
- en: Some packages are loaded automatically when you start R, such as the *base*
    subdirectory. However, in order to save memory and time, R does not load all available
    packages automatically.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包在启动R时会自动加载，例如 *base* 子目录。然而，为了节省内存和时间，R不会自动加载所有可用的包。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can check which packages are currently loaded by typing this:'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容来检查当前加载了哪些包：
- en: .path.package()
  id: totrans-2115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .path.package()
- en: '**B.2 Loading a Package from Your Hard Drive**'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.2 从你的硬盘驱动器加载包**'
- en: 'If you need a package that is in your R installation but not loaded into memory
    yet, you can load it using the library() function. For instance, suppose you wish
    to generate multivariate normal random vectors. The function mvrnorm() in the
    package MASS does this. So, load the package as follows:'
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个在R安装中但尚未加载到内存中的包，你可以使用 library() 函数来加载它。例如，假设你希望生成多元正态随机向量。MASS包中的 mvrnorm()
    函数可以做到这一点。所以，按照以下方式加载包：
- en: library(MASS)
  id: totrans-2118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(MASS)
- en: The mvrnorm() function will now be ready to use. And so will its documentation
    (before you loaded MASS, entering help(mvrnorm) would have generated an error
    message).
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: mvrnorm() 函数现在可以使用了。它的文档也可以使用（在你加载MASS之前，输入 help(mvrnorm) 会生成一个错误信息）。
- en: '**B.3 Downloading a Package from the Web**'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.3 从网络下载包**'
- en: The package you want may not be in your R installation. One of the big advantages
    of open source software is that people love to share. People all over the world
    have written their own special-purpose R packages, placing them in the CRAN repository
    and elsewhere.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的包可能不在你的R安装中。开源软件的一个主要优势是人们喜欢分享。世界各地的人们都编写了自己的专用R包，并将它们放置在CRAN仓库和其他地方。
- en: '**NOTE**'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*User contributions to CRAN go through a vetting process and are generally
    of high* *quality. They are, however, not tested as throughly as R itself.*'
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户对CRAN的贡献会经过审查过程，通常质量很高。然而，它们并没有像R本身那样经过彻底的测试。*'
- en: '***B.3.1 Installing Packages Automatically***'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3.1 自动安装包***'
- en: One way to install a package is to use the install_packages() function. For
    example, suppose you wish to use the mvtnorm package, which computes multivariate
    normal cumulative distribution functions and other quantities.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包的一种方法是使用 install_packages() 函数。例如，假设你希望使用 mvtnorm 包，该包计算多元正态累积分布函数和其他量。
- en: 'First, choose a directory in which you wish to install the package (and maybe
    others in the future), say */a/b/c*. Then at the R prompt, type this:'
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一个你希望安装包（以及未来可能的其他包）的目录，比如 */a/b/c*。然后在R提示符下，输入以下内容：
- en: install.packages("mvtnorm","/a/b/c/")
  id: totrans-2127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: install.packages("mvtnorm","/a/b/c/")
- en: 'This will cause R to automatically go to CRAN, download the package, compile
    it, and load it into a new directory: */a/b/c/mvtnorm*.'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致R自动前往CRAN，下载包，编译它，并将其加载到新的目录中：*/a/b/c/mvtnorm*。
- en: 'You do need to tell R where to find that package once it’s installed, which
    you can do via the .libPaths() function:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉R在哪里可以找到已安装的包，这可以通过 .libPaths() 函数来完成：
- en: .libPaths("/a/b/c/")
  id: totrans-2130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .libPaths("/a/b/c/")
- en: This will add that new directory to the ones R was already using. If you use
    that directory often enough, you may wish to add that call to .libPaths() in your
    *.Rprofile* startup file in your home directory.
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将新目录添加到 R 已经使用的目录中。如果你经常使用该目录，你可能希望将此调用添加到你的家目录中的 *.Rprofile* 启动文件中。
- en: '**356**'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: '**356**'
- en: Appendix B
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: A call to .libPaths() without an argument will show you a list of all the places
    R will currently look for loading a package when requested.
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数的 .libPaths() 调用将显示 R 在请求加载包时当前会查找的所有位置。
- en: '***B.3.2 Installing Packages Manually***'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3.2 手动安装包***'
- en: Sometimes you need to install “by hand” to make modifications required to make
    a particular R package work on your system. The following example demonstrates
    how I did so in one particular instance, and it will serve as a case study on
    handling situations in which ordinary methods don’t work.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要手动安装以进行必要的修改，使特定的 R 包能在你的系统上运行。以下示例展示了我在一个特定情况下是如何做到这一点的，这将成为一个关于处理常规方法不起作用的情形的案例研究。
- en: '**NOTE**'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Situations in which you need to install packages by hand typically are operating
    system* *dependent and require more computer expertise than is generally assumed
    in this book.*'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: '*需要手动安装包的情况通常与操作系统相关，并且需要比本书中通常假设的更多计算机专业知识。*'
- en: '*For help in very specific cases, the* r-help *mailing list is invaluable.
    To access it, go to* *the R home page (* http://www.r-project.org/ *), click the
    FAQs link and then the R*'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于非常具体的情况的帮助，r-help 邮件列表非常有价值。要访问它，请访问 R 主页 (* http://www.r-project.org/ *)，点击
    FAQs 链接，然后点击 R*'
- en: '*FAQ link, and scroll down to Section 2.9, “What mailing lists exist for R?”*'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: '*FAQ 链接，并滚动到第 2.9 节，“存在哪些 R 的邮件列表？”*'
- en: I wanted to install the Rmpi package on our department’s instructional machines
    in the directory */home/matloff/R*. I tried using install.packages() first but
    found that the automated process could not find the MPI library on our machines.
    The problem was that R was looking for those files in
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在我们的系的教学机器上目录 */home/matloff/R* 中安装 Rmpi 包。我首先尝试使用 install.packages()，但发现自动过程无法在我们的机器上找到
    MPI 库。问题在于 R 正在寻找这些文件的位置
- en: '*/usr/local/lam*, whereas I knew they were in */usr/local/LAM*. Since these
    were public machines, not my own, I did not have the authority to change the name.
    So, I downloaded the Rmpi files in the packed form *Rmpi_0.5-3*'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/local/lam*，而我知道它们在 */usr/local/LAM* 中。由于这些是公共机器，不是我的，我没有权限更改名称。因此，我下载了打包形式的
    Rmpi 文件 *Rmpi_0.5-3*'
- en: '*.tar.gz*. I unpacked that file in my directory *~/tmp*, producing a directory
    named *~/tmp/Rmpi*.'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: '*.tar.gz*. 我在我的目录 *~/tmp* 中解压了该文件，生成了一个名为 *~/tmp/Rmpi* 的目录。'
- en: 'If I had not experienced this problem, at this point, I could have just typed
    the following in a terminal window from within the *~/tmp* directory: R CMD INSTALL
    -l /home/matloff/R Rmpi'
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有遇到这个问题，在这个时候，我只需在 *~/tmp* 目录下的终端窗口中键入以下命令即可：R CMD INSTALL -l /home/matloff/R
    Rmpi
- en: That command would install the package contained in *~/tmp/Rmpi*, placing it
    in */home/matloff/R*. This would have been an alternative to calling install.packages().
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装 *~/tmp/Rmpi* 中包含的包，并将其放置在 */home/matloff/R* 中。这将是一个调用 install.packages()
    的替代方案。
- en: 'But as noted, I had to deal with a problem. Within the *~/tmp/Rmpi* directory,
    there was a *configure* file, so I ran this command on my Linux command line:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如所注，我必须处理一个问题。在 *~/tmp/Rmpi* 目录中，有一个 *configure* 文件，因此我在 Linux 命令行上运行了这个命令：
- en: configure --help
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: configure --help
- en: 'It told me that I could specify the location of my MPI files to configure,
    as follows:'
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我我可以指定配置时 MPI 文件的位置，如下所示：
- en: configure --with-mpi=/usr/local/LAM
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: configure --with-mpi=/usr/local/LAM
- en: 'This applies if you run configure directly, but I ran it via R:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于你直接运行 configure 的情况，但我通过 R 运行的：
- en: R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM
- en: Installing and Using Packages
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和使用包
- en: '**357**'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: '**357**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Well, that seemed to work, in the sense that R did install the package, but
    R also noted that it had a problem with the threads library on our machines. Sure
    enough, when I tried to load Rmpi, I got a runtime error, saying that a certain
    threads function wasn’t there.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这似乎是可行的，从 R 安装了包这个意义上来说，但 R 也指出，它在我们的机器上的线程库存在问题。确实如此，当我尝试加载 Rmpi 时，我得到了一个运行时错误，说某个线程函数不存在。
- en: 'I knew that our threads library was fine, so I went into the configure file
    and commented out two lines:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我们的线程库是好的，所以我进入了配置文件并注释了两行：
- en: if test $ac_cv_lib_pthread_main = yes; then
  id: totrans-2158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if test $ac_cv_lib_pthread_main = yes; then
- en: MPI_LIBS="$MPI_LIBS -lpthread"
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: MPI_LIBS="$MPI_LIBS -lpthread"
- en: fi
  id: totrans-2160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fi
- en: In other words, I forced it to use what I knew (or was fairly sure) would work.
    I then reran R CMD INSTALL, and the package loaded without any problems.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我强迫它使用我知道（或相当肯定）会工作的方法。然后我重新运行 R CMD INSTALL，并且包加载没有任何问题。
- en: '**B.4 Listing the Functions in a Package**'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.4 列出包中的函数**'
- en: 'You can get a list of functions in a package by calling library() with the
    help argument. For instance, for help on the mvtnorm package, type one of the
    following:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用带有帮助参数的 `library()` 来获取包中的函数列表。例如，要获取 `mvtnorm` 包的帮助，键入以下之一：
- en: •
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: library(help=mvtnorm)
  id: totrans-2165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`library(help=mvtnorm)`'
- en: •
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: help(package=mvtnorm)
  id: totrans-2167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`help(package=mvtnorm)`'
- en: '**358**'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: '**358**'
- en: Appendix B
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**I N D E X**'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引**'
- en: '**Special Characters**'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊字符**'
- en: lines with abline() function, 263–264
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `abline()` 函数绘制线条，263–264
- en: list elements, 88–90
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素，88–90
- en: ': (colon operator), 32–33'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: :（冒号运算符），32–33
- en: matrix rows and columns, 73–78
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵行和列，73–78
- en: == operator, 54–55
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: == 操作符，54–55
- en: points to graphs with points() func-
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: '`points()` 函数指向图形，246–250'
- en: operator, 40
  id: totrans-2179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运算符，40
- en: tion, 269–270
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 实现，269–270
- en: .libpaths() function, 356–357
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: '`.libpaths()` 函数，356–357'
- en: text to graphs with text() function,
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `text()` 函数将文本添加到图形中，
- en: '*.Rdata* file, 20'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rdata* 文件，20'
- en: 270–271
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 270–271
- en: '*.Rhistory* file, 20'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rhistory* 文件，20'
- en: addmargins() function, 131
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: '`addmargins()` 函数，131'
- en: '*.Rprofile* file, 19'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rprofile* 文件，19'
- en: adjacency matrix, 333
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵，333
- en: <<- (superassignment operator), 9
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: <<-（超级赋值运算符），9
- en: aggregate() function, 136
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregate()` 函数，136'
- en: simplifying code, 174
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 简化代码，174
- en: all() function, 35–39
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 函数，35–39'
- en: writing to nonlocals with, 161–162
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `print()` 函数写入非局部变量，161–162
- en: analogous operations, resizing
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 类似操作，调整大小
- en: + operator, 31
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: + 运算符，31
- en: matrices, 74
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，74
- en: '"%mut%"() function, 218'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: '"%mut%"() 函数，218'
- en: anonymous functions, 99, 187–188
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数，99，187–188
- en: antibugging, 287
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试，287
- en: '**A**'
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**'
- en: any() function, 35–39
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()` 函数，35–39'
- en: application-specific functions, 165
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定函数，165
- en: abalone data set
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: 贻贝数据集
- en: apply() function
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()` 函数'
- en: recoding, 51–54
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编码，51–54
- en: applying functions to matrix rows
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于矩阵行
- en: using lapply() function, 99
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lapply()` 函数，99
- en: and columns, 70–72
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 以及列，70–72
- en: abline() graphics function, 150
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: '`abline()` 图形函数，150'
- en: matrix-like operations, 107
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵类似操作，107
- en: abs() math function, 189
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs()` 数学函数，189'
- en: obtaining variable marginal
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 获取变量的边际
- en: accessing
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 访问
- en: values, 131
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 值，131
- en: data frames, 102–104
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框，102–104
- en: arguments. *See also specific argument*
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。*另见特定参数*
- en: files on remote machines via
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过远程机器上的文件
- en: '*by name*'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: '*按名称*'
- en: URLs, 243
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: URL，243
- en: actual, 9
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际，9
- en: Internet, 246–250
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网，246–250
- en: default, 9–10
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认，9–10
- en: implementing parallel R exam-
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并行 R 检查
- en: default values for, 146–147
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值，146–147
- en: ple, 248–250
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 请，248–250
- en: formal, 9
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 正式，9
- en: sockets, 247–248
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字，247–248
- en: arithmetic operations, 30–31, 145–146
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算，30–31，145–146
- en: TCP/IP, 247
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP，247
- en: array() function, 134
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()` 函数，134'
- en: keyboard and monitor, 232–235
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘和显示器，232–235
- en: arrays
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 数组
- en: using print() function, 234–235
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `print()` 函数，234–235
- en: higher-dimensional arrays, 82–83
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 高维数组，82–83
- en: using readline() function, 234
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readline()` 函数，234
- en: as vectors, 28
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向量，28
- en: using scan() function, 232–234
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `scan()` 函数，232–234
- en: as.matrix() function, 81
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: '`as.matrix()` 函数，81'
- en: list components and values, 93–95
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表组件和值，93–95
- en: aspell() function, 211
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspell()` 函数，211'
- en: actual argument, 9
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际参数，9
- en: assign() function
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign()` 函数'
- en: adding
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 添加
- en: variables, 109
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，109
- en: legends to graphs with legend()
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `legend()` 函数为图形添加图例
- en: writing nonlocals with, 163
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `print()` 函数，163
- en: function, 270
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，270
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: atomic pragma, 343
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 原子祈使，343
- en: character strings, 251–259
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，251–259
- en: atomic vectors, 85–86
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 原子向量，85–86
- en: defined, 11
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，11
- en: attr() function, 212
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr()` 函数，212'
- en: regular expressions, 254–257
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，254–257
- en: forming filenames example,
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件名示例，
- en: '**B**'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**'
- en: 256–257
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 256–257
- en: testing filename for given suffix
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件名是否具有给定后缀
- en: batch mode, 1
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 批量模式，1
- en: example, 255–256
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，255–256
- en: help feature, 24
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助功能，24
- en: string-manipulation functions,
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作函数，
- en: running R in, 3
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中运行 R，3
- en: 251–254
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 251–254
- en: Bernoulli sequence, 204
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 伯努利序列，204
- en: gregexpr(), 254
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: '`gregexpr()`，254'
- en: biglm package, 321
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: '`biglm` 包，321'
- en: grep(), 252
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep()`，252'
- en: bigmemory package, 321
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: '`bigmemory` 包，321'
- en: nchar(), 252
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: '`nchar()`，252'
- en: binary files, 237
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件，237
- en: paste(), 252–253
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: '`paste()`，252–253'
- en: binary search tree, 177–182
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树，177–182
- en: regexpr(), 253–254
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexpr()`，253–254'
- en: body() function, 149, 151
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: '`body()` 函数，149，151'
- en: sprintf(), 253
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf()`，253'
- en: Boolean operators, 145–146
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符，145–146
- en: strsplit(), 253
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: strsplit()，253
- en: braces, 144
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号，144
- en: substr(), 253
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: substr()，253
- en: brackets, 87–88
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 括号，87–88
- en: use of string utilities in edtdbg debug-
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 edtdbg 调试中使用字符串实用工具
- en: Bravington, Mark, 300
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: Bravington, Mark，300
- en: ging tool, 257–259
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 生成工具，257–259
- en: breakpoints, setting, 289–290
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点，289–290
- en: child nodes, binary search tree, 177
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的孩子节点，177
- en: calling browser() function directly,
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用 browser() 函数，
- en: Chinese dialects, aids for learning,
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 中国方言，学习辅助工具，
- en: 289–290
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 289–290
- en: 115–120
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 115–120
- en: using setbreakpoint() function, 290
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 setbreakpoint() 函数，290
- en: chi-square distribution, 193–194
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方分布，193–194
- en: breaks component, hist() function, 14
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: breaks 组件，hist() 函数，14
- en: chol() linear algebra function, 197
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: chol() 线性代数函数，197
- en: break statement, 141
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: break 语句，141
- en: choose() set operation, 202
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: choose() 集合操作，202
- en: browser commands, 289
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: browser 命令，289
- en: chunking memory, 320–321
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 分块内存，320–321
- en: browser() function
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: browser() 函数
- en: class() function, 212
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: class() 函数，212
- en: setting breakpoints, 289–290
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点，289–290
- en: cleaner code, 172
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的代码，172
- en: single-stepping through code, 288
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 单步执行代码，288
- en: client/server model, 247
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 客户/服务器模型，247
- en: by() function, 126–127
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: by() 函数，126–127
- en: closures, 151, 174–175
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包，151，174–175
- en: byrow argument, matrix() function,
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: byrow 参数，matrix() 函数，
- en: cloud() function, 282–283
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: cloud() 函数，282–283
- en: 61, 236
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 61，236
- en: cluster, snow package, 335
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: cluster，snow 包，335
- en: byte code compilation, 320
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码编译，320
- en: clusterApply() function, snow package,
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: clusterApply() 函数，snow 包，
- en: 72, 337, 339–340
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 72, 337, 339–340
- en: '**C**'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: '**C**'
- en: code files, 3
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文件，3
- en: code safety, 41
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 代码安全性，41
- en: c %in% y set operation, 202
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: c %in% y 集合操作，202
- en: col() function, 69–70
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: col() 函数，69–70
- en: cache, 346
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存，346
- en: colon operator (:), 32–33
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号运算符 (:), 32–33
- en: calculus, 192–193
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分，192–193
- en: color images, 63
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色图像，63
- en: categorical variables, 121
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 分类型变量，121
- en: column-major order, matrix storage,
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵存储的列主序，
- en: cbind() function, 12, 74–75, 106–107
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: cbind() 函数，12，74–75，106–107
- en: 59, 61
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 59, 61
- en: c browser command, 289
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: c browser 命令，289
- en: combinatorial simulation, 205–206
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模拟，205–206
- en: cdf (cumulative distribution
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: cdf (累积分布
- en: combn() function, 203
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: combn() 函数，203
- en: function), 193
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 函数)，193
- en: comdat$countabsamecomm component, 206
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$countabsamecomm 组件，206
- en: ceiling() math function, 190
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: ceiling() 数学函数，190
- en: comdat$numabchosen component, 206
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$numabchosen 组件，206
- en: cell counts, changing to
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 单元计数，转换为
- en: comdat$whosleft component, 206
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$whosleft 组件，206
- en: proportions, 130
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 比例，130
- en: comma-separated value (CSV) files, 103
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值 (CSV) 文件，103
- en: cex option, changing graph character
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: cex 选项，改变图形字符
- en: comments, 3
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 注释，3
- en: sizes with, 272–273
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 与其大小，272–273
- en: complete.cases() function, 105–106
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: complete.cases() 函数，105–106
- en: c() function, 56–57
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: c() 函数，56–57
- en: Comprehensive R Archive Network
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: 综合R存档网络
- en: Chambers, John, 226
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: Chambers, John，226
- en: (CRAN), 24, 193, 353
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: (CRAN)，24，193，353
- en: '**360**'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: '**360**'
- en: INDEX
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: computed mean, saving in variable, 5
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平均值，保存到变量中，5
- en: applying logistic regression
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 应用逻辑回归
- en: concatenating, vectors, 4
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 向量连接，4
- en: models example, 113–115
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 模型示例，113–115
- en: connections, 237–238
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 连接，237–238
- en: using lapply() and sapply() on
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lapply() 和 sapply() 上使用
- en: constructors, 217
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，217
- en: data frames, 112–113
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框，112–113
- en: contingency tables, 128, 229
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 列联表，128，229
- en: matrix-like operations, 104–109
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵类似操作，104–109
- en: control statements, 139–144
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句，139–144
- en: apply() function, 107
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: apply() 函数，107
- en: if-else function, 143–144
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: if-else 函数，143–144
- en: extracting subdata frames,
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: 提取子数据框，
- en: looping over nonvector sets, 143
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历非向量集合，143
- en: 104–105
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: 104–105
- en: loops, 140–142
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 循环，140–142
- en: NA values, 105–106
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: NA 值，105–106
- en: copy-on-change policy, 314–315
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 改变复制策略，314–315
- en: rbind() and cbind() functions,
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: rbind() 和 cbind() 函数，
- en: cos() math function, 190
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: cos() 数学函数，190
- en: 106–107
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 106–107
- en: counter() function, 175
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: counter() 函数，175
- en: salary study example, 108–109
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 工资研究示例，108–109
- en: counts component
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 计数组件
- en: merging, 109–112
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 合并，109–112
- en: hist() function, 14
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: hist() 函数，14
- en: employee database example,
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 员工数据库示例，
- en: mapsound() function, 116
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: mapsound() 函数，116
- en: 111–112
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 111–112
- en: covariance matrix, generating, 69–70
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵，生成，69–70
- en: reading from files, 236
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取，236
- en: CRAN (Comprehensive R Archive Net-
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN (综合 R 存档网络
- en: regression analysis of exam grades
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 考试成绩的回归分析
- en: work), 24, 193, 353
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 工作)，24，193，353
- en: example, 103–104
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，103–104
- en: critical section, OpenMP, 344
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区，OpenMP，344
- en: data structures, 10–16
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构，10–16
- en: crossprod() function, 196
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: crossprod() 函数，196
- en: character strings, 11
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，11
- en: cross-validation, 219, 222
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证，219，222
- en: classes, 15–16
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 类，15–16
- en: C-style looping, 140
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: C样式循环，140
- en: data frames, 14–15
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框，14–15
- en: CSV (comma-separated value) files, 103
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: CSV (逗号分隔值) 文件，103
- en: lists, 12–14
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，12–14
- en: ct.dat file, 128
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: ct.dat 文件，128
- en: matrices, 11–12
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，11–12
- en: cumprod() math function, 190, 191
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: cumprod() 数学函数，190，191
- en: vectors, 10
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，10
- en: cumsum() math function, 39, 190–191
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: cumsum() 数学函数，39，190–191
- en: debug() function, 288
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: debug() 函数，288
- en: cumulative distribution function
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 累积分布函数
- en: debugger() function, performing checks
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: debugger() 函数，执行检查
- en: (cdf), 193
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: (cdf)，193
- en: after crash with, 291–292
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 与崩溃后的，291–292
- en: cumulative sums and products, 191
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 累积和与乘积，191
- en: debugging, 285–304
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 调试，285–304
- en: curve() function, 277–278
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: curve() 函数，277–278
- en: ensuring consistency in debugging
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: 确保调试一致性
- en: customizing graphs, 272–280
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 定制图形，272–280
- en: simulation code, 302
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟代码，302
- en: adding polygons with polygon() func-
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 polygon() 函数添加多边形
- en: facilities, 288–300
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: 设施，288–300
- en: tion, 275–276
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 用，275–276
- en: browser commands, 289
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: browser 命令，289
- en: changing character sizes with cex
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cex 改变字符大小
- en: debug() and browser()
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: debug() 和 browser()
- en: option, 272–273
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 选项，272–273
- en: functions, 288
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，288
- en: changing ranges of axes with xlim
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlim 改变坐标轴范围
- en: debugging sessions, 292–300
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: 调试会话，292–300
- en: and ylim options, 273–275
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: 和 ylim 选项，273–275
- en: setting breakpoints, 289–290
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点，289–290
- en: graphing explicit functions, 276–277
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制显式函数，276–277
- en: traceback() and debugger()
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: traceback() 和 debugger()
- en: magnifying portions of curve
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 放大曲线的部分
- en: functions, 291–292
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，291–292
- en: example, 277–280
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，277–280
- en: trace() function, 291
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: trace() 函数，291
- en: smoothing points with lowess() and
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lowess() 和平滑点
- en: global variables and, 173
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量和，173
- en: loess() functions, 276
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: loess() 函数，276
- en: parallel R, 351
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R，351
- en: cut() function, 136–137
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: cut() 函数，136–137
- en: principles of, 285–287
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 原则，285–287
- en: antibugging, 287
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 防虫，287
- en: '**D**'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: '**D**'
- en: confirmation, 285–286
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 确认，285–286
- en: modular, top-down manner, 286
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化，自顶向下的方式，286
- en: data argument, array() function, 134
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: data 参数，array() 函数，134
- en: starting small, 286
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 从小开始，286
- en: data frames, 14–15, 101–102
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框，14–15，101–102
- en: running GDB on R, 303–304
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 上运行 GDB，303–304
- en: accessing, 102–104
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 访问，102–104
- en: syntax and runtime errors, 303
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 语法和运行时错误，303
- en: applying functions to, 112–120
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函数，112–120
- en: tools, 287–288, 300–302
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 工具，287–288，300–302
- en: aids for learning Chinese dialects
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 学习汉语方言的辅助工具
- en: debug package, 300–301
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: debug 软件包，300–301
- en: example, 115–120
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，115–120
- en: declarations, 28–29
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 声明，28–29
- en: INDEX
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**361**'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: '**361**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: default arguments, 9–10
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数，9–10
- en: employee database example, 111–112
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 员工数据库示例，111–112
- en: deleting
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 删除
- en: encapsulation, 207
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 封装，207
- en: list elements, 88–90
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素，88–90
- en: end of file (EOF), 238
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结束 (EOF)，238
- en: matrix rows and columns, 73–78
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵行和列，73–78
- en: envir argument
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: envir 参数
- en: a node from binary search tree, 181
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树中的一个节点，181
- en: get() function, 159
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: get() 函数，159
- en: density estimates, same graph, 264–266
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 密度估计，同一图形，264–266
- en: ls() function, 155
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: ls() 函数，155
- en: DES (discrete-event simulation),
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: DES (离散事件模拟),
- en: environment and scope, 151–159
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 环境和范围，151–159
- en: writing, 164–171
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 编写，164–171
- en: functions have (almost) no side
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（几乎）没有副作用
- en: det() linear algebra function, 197
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: det() 线性代数函数，197
- en: effects, 156–157
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 影响，156–157
- en: dev.off() function, 3
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: dev.off() 函数，3
- en: function to display contents of call
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 显示调用内容的功能
- en: df parameter, mapsound() function, 116
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: df 参数，mapsound() 函数，116
- en: frame example, 157–159
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: frame 示例，157–159
- en: dgbsendeditcmd() function, 257–258
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: dgbsendeditcmd() 函数，257–258
- en: ls() function, 155–156
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: ls() 函数，155–156
- en: diag() linear algebra function, 197–198
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: diag() 线性代数函数，197–198
- en: scope hierarchy, 152–155
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 范围层次，152–155
- en: diff() function, 50–51
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: diff() 函数，50–51
- en: top-level environment, 152
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级环境，152
- en: dim argument, array() function, 134
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: dim 参数，array() 函数，134
- en: EOF (end of file), 238
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: EOF (文件结束)，238
- en: dim attribute, matrix class, 79
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: dim 属性，矩阵类，79
- en: ess-tracebug package, 300
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: ess-tracebug 软件包，300
- en: dimcode argument, apply() function, 70
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: dimcode 参数，apply() 函数，70
- en: event list, DES, 164
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 事件列表，DES，164
- en: dimension reduction, avoiding, 80–81
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: 维度降低，避免，80–81
- en: event-oriented paradigm, 164
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 事件导向范式，164
- en: dim() function, 79
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: dim() 函数，79
- en: example() function, 21–22
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: example() 函数，21–22
- en: dimnames argument, array() function, 134
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: dimnames 参数，array() 函数，134
- en: exists() function, 230
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: exists() 函数，230
- en: dimnames() function, 131
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: dimnames() 函数，131
- en: expandut() function, 218
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: expandut() 函数，218
- en: dir() function, 245
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: dir() 函数，245
- en: explicit functions, graphing, 276–277
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: 显式函数，绘图，276–277
- en: discrete-event simulation (DES),
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 离散事件模拟 (DES),
- en: exp() math function, 189
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: exp() 数学函数，189
- en: writing, 164–171
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 编写，164–171
- en: extracting
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 提取
- en: discrete-valued time series, predicting,
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 离散值时间序列，预测，
- en: subdata frames, 104–105
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 子数据框，104–105
- en: 37–39
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 37–39
- en: subtables, 131–134
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 子表，131–134
- en: do.call() function, 133
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: do.call() 函数，133
- en: dosim() function, 165
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: dosim() 函数，165
- en: '**F**'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: '**F**'
- en: double brackets, 87–88
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 双括号，87–88
- en: drop argument, 68, 81
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: drop 参数，68，81
- en: factorial() math function, 190
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: factorial() 数学函数，190
- en: dtdbg debugging tool, use of string utili-
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: dtdbg 调试工具，使用字符串利用-
- en: factors, 121
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 因子，121
- en: ties in, 257–259
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 中的绑定，257–259
- en: functions, 123, 136
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，123，136
- en: dual-core machines, 341
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 双核机器，341
- en: aggregate(), 136
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: aggregate()，136
- en: duplicate() function, 315
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: duplicate() 函数，315
- en: by(), 126–127
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: by()，126–127
- en: dynamic task assignment, 348–350
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 动态任务分配，348–350
- en: cut(), 136–137
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
  zh: cut()，136–137
- en: split(), 124–126
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: split()，124–126
- en: '**E**'
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: '**E**'
- en: tapply(), 123–124
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: tapply()，123–124
- en: levels and, 121–122
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 层级和，121–122
- en: each argument, rep() function, 34
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 参数，rep() 函数，34
- en: fangyan, 115
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 方言，115
- en: edit() function, 150, 186–187
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: edit() 函数，150，186–187
- en: fargs argument, apply() function, 70
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: fargs 参数，apply() 函数，70
- en: edtdbg package, 300–302
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: edtdbg 包，300–302
- en: f argument, apply() function, 70
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: f 参数，apply() 函数，70
- en: eigen() function, 197, 201
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: eigen() 函数，197，201
- en: Fedora, installing R on, 353–354
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 上安装 R，353–354
- en: eigenvalues, 201
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值，201
- en: file.exists() function, 245
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: file.exists() 函数，245
- en: eigenvectors, 201
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量，201
- en: file.info() function, 245, 246
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: file.info() 函数，245，246
- en: elements
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 元素
- en: filetype criterion, Google, 24
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型标准，Google，24
- en: list, adding and deleting, 88–90
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，添加和删除，88–90
- en: filter() function, 328
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: filter() 函数，328
- en: vectors
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 向量
- en: filtering, 45–48
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤，45–48
- en: adding and deleting, 26
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除，26
- en: defined, 25
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，25
- en: naming, 56
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 命名，56
- en: generating filtering indices, 45–47
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: 生成过滤索引，45–47
- en: embarrassingly parallel applications
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 显式并行应用
- en: matrices, 66–69
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，66–69
- en: defined, 347–348
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，347–348
- en: with subset() function, 47
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 subset() 函数，47
- en: turning general problems into, 350
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: 将一般问题转化为，350
- en: with which() selection function, 47–48
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 which() 选择函数，47–48
- en: '**362**'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: '**362**'
- en: INDEX
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: findud() function, 50
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: findud() 函数，50
- en: '**G**'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: '**G**'
- en: findwords() function, 90–91
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: findwords() 函数，90–91
- en: first-class objects, 149
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 一等对象，149
- en: GCC, 325
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: GCC，325
- en: floor() math function, 190
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: floor() 数学函数，190
- en: GDB (GNU debugger), 288, 327
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: GDB（GNU 调试器），288，327
- en: for loop, 306–313
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环，306–313
- en: general-purpose editors, 186
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 通用编辑器，186
- en: achieving better speed in Monte
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Monte 中实现更好的速度
- en: generating
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 生成
- en: Carlo simulation example,
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 卡罗尔模拟示例，
- en: covariance matrices, 69–70
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵，69–70
- en: 308–311
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 308–311
- en: filtering indices, 45–47
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤索引，45–47
- en: generating powers matrix example,
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 生成幂矩阵示例，
- en: powers matrices, 312–313
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 力矩阵，312–313
- en: 312–313
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 312–313
- en: generic functions, xxi
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数，xxi
- en: vectorization for speedup, 306–308
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化以加速，306–308
- en: classes, 15
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 类，15
- en: formal parameters
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 形参
- en: implementing on S4 classes, 225–226
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 在 S4 类中实现，225–226
- en: mapsound() function, 116
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: mapsound() 函数，116
- en: getAnywhere() function, 211
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: getAnywhere() 函数，211
- en: oddcount() function, 9
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: oddcount() 函数，9
- en: get() function, 159
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: get() 函数，159
- en: formals() function, 149, 151
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: formals() 函数，149，151
- en: looping over nonvector sets, 142
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历非向量集合，142
- en: forming filenames, 256–257
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件名，256–257
- en: getnextevnt() function, 165
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: getnextevnt() 函数，165
- en: four-element vector, adding
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 四元素向量，添加
- en: getwd() function, 245
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: getwd() 函数，245
- en: element to, 26
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 元素到，26
- en: global variables, 9, 171–174
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量，9，171–174
- en: fromcol parameter, mapsound()
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: fromcol 参数，mapsound()
- en: GNU debugger (GDB), 288, 327
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: GNU 调试器（GDB），288，327
- en: function, 116
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，116
- en: GNU S language, xix
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: GNU S 语言，xix
- en: functional programming, xxi–xxii,
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程，xxi–xxii,
- en: GPU programming, 171, 345
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 编程，171，345
- en: 314–316
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 314–316
- en: GPUs (graphics processing units), 345
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: GPU（图形处理单元），345
- en: avoiding memory copy example,
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存复制示例，
- en: gputools package, 345–346
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: gputools 包，345–346
- en: 315–316
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 315–316
- en: granularity, 348
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 粒度，348
- en: copy-on-change issues, 314–315
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 基于更改复制的问题，314–315
- en: graphical user interfaces (GUIs), xx
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUIs），xx
- en: vector assignment issues, 314
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 向量赋值问题，314
- en: graphics processing units (GPUs), 345
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: 图形处理单元（GPUs），345
- en: functions, 7–10\. *See also* math functions;
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，7–10\. *另见* 数学函数；
- en: graphs, 261–283
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: 图表，261–283
- en: string-manipulation functions
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作函数
- en: customizing, 272–280
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义，272–280
- en: anonymous, 187–188
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名，187–188
- en: adding legends with legend()
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 legend() 添加图例
- en: applying to data frames, 112–120
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到数据框，112–120
- en: function, 270
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，270
- en: aids for learning Chinese dialects
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 学习汉语方言的辅助工具
- en: adding lines with abline()
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 abline() 添加线条
- en: example, 115–120
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，115–120
- en: function, 263–264
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，263–264
- en: applying logistic regression
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 应用逻辑回归
- en: adding points with points()
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 points() 添加点
- en: models example, 113–115
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
  zh: 模型示例，113–115
- en: function, 269–270
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，269–270
- en: using lapply() and sapply()
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lapply() 和 sapply()
- en: adding polygons with polygon()
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 polygon() 添加多边形
- en: functions, 112–113
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，112–113
- en: function, 275–276
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，275–276
- en: applying to lists, 95–99
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到列表，95–99
- en: adding text with text() function,
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 text() 函数添加文本，
- en: abalone data example, 99
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: abalone 数据示例，99
- en: 270–271
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 270–271
- en: lapply() and sapply() functions, 95
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: lapply() 和 sapply() 函数，95
- en: changing character sizes with cex
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cex 改变字符大小
- en: text concordance example, 95–98
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: 文本一致性示例，95–98
- en: option, 272–273
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 选项，272–273
- en: applying to matrix rows and columns,
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到矩阵行和列，
- en: changing ranges of axes with xlim
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlim 改变坐标轴范围
- en: 70–73
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 70–73
- en: and ylim options, 273–275
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: 和 ylim 选项，273–275
- en: apply() function, 70–72
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: apply() 函数，70–72
- en: graphing explicit functions,
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制显式函数的图表，
- en: finding outliers example, 72–73
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找异常值示例，72–73
- en: 276–277
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 276–277
- en: default arguments, 9–10
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数，9–10
- en: magnifying portions of curve
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: 放大曲线的部分
- en: listing in packages, 358
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 在包中列出，358
- en: example, 277–280
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，277–280
- en: as objects, 149–151
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象，149–151
- en: smoothing points with lowess()
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lowess() 平滑点
- en: replacement, 182–186
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 替换，182–186
- en: and loess() functions, 276
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 和 loess() 函数，276
- en: for statistical distributions, 193–194
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计分布，193–194
- en: pinpointing locations with locator()
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 locator() 函数定位位置
- en: transcendental, 40
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 超越，40
- en: function, 271–272
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，271–272
- en: variable scope, 9
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域，9
- en: plot() function, 262
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: plot() 函数，262
- en: vector, 35–39, 311
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，35–39，311
- en: INDEX
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**363**'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: '**363**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: graphs ( *continued*)
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 图表（*继续*）
- en: matrices, 62–63
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，62–63
- en: plots
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 图表
- en: vector, 31–32
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，31–32
- en: restoring, 272
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复，272
- en: indices, filtering, 45–47
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 索引，过滤，45–47
- en: three-dimensional, 282–283
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 三维，282–283
- en: inheritance
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: 继承
- en: polynomial regression example,
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式回归示例，
- en: defined, 207
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，207
- en: 266–269
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: 266–269
- en: S3 classes, 214
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: S3 类，214
- en: saving to files, 280–281
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到文件，280–281
- en: initglbls() function, 165
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: initglbls() 函数，165
- en: starting new graph while keeping
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持新图表的同时开始
- en: input/output (I/O). *See* I/O
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出 (I/O)。*见* I/O
- en: old, 264
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的，264
- en: installing packages. *See* packages
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包。*见* 包
- en: two density estimates on same graph
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: 同一图上的两个密度估计
- en: installing R, 353–354
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 R，353–354
- en: example, 264–266
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，264–266
- en: downloading base package from
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 从下载基本包，
- en: grayscale images, 63
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像，63
- en: CRAN, 353
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN，353
- en: gregexpr() function, 254
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: gregexpr() 函数，254
- en: from Linux package manager,
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Linux 软件包管理器，
- en: grep() function, 109, 252
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: grep() 函数，109，252
- en: 353–354
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 353–354
- en: GUIs (graphical user interfaces), xx
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面 (GUIs)，xx
- en: from source, 354
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码，354
- en: install_packages() function, 356
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: install_packages() 函数，356
- en: '**H**'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: '**H**'
- en: integrated development environments
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: (IDEs), xx, 186
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: (IDEs)，xx，186
- en: hard drive, loading packages from, 356
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘，从硬盘加载包，356
- en: intensity, pixel, 63–64
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 强度，像素，63–64
- en: help feature, 20–24
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助功能，20–24
- en: interactive mode, 2–3
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 交互模式，2–3
- en: additional topics, 23–24
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: 其他主题，23–24
- en: interfacing R to other languages, 323–332
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 将 R 与其他语言接口，323–332
- en: batch mode, 24
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理模式，24
- en: using R from Python, 330–332
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 使用 R，330–332
- en: example() function, 21–22
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: example() 函数，21–22
- en: writing C/C++ functions to be called
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 将 C/C++ 函数编写为可调用的
- en: help() function, 20–21
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
  zh: help() 函数，20–21
- en: from R, 323–330
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 从 R，323–330
- en: help.search() function, 22–23
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: help.search() 函数，22–23
- en: compiling and running code, 325
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行代码，325
- en: online, 24
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 在线，24
- en: debugging R/C code, 326–327
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 R/C 代码，326–327
- en: help() function, 20–21
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
  zh: help() 函数，20–21
- en: extracting subdiagonals from
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: 从子对角线中提取
- en: help.search() function, 22–23
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: help.search() 函数，22–23
- en: square matrix example, 324–325
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵示例，324–325
- en: higher-dimensional arrays, 82–83
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: 高维数组，82–83
- en: prediction of discrete-valued time
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 预测离散值时间
- en: hist() function, 3, 13–14
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: hist() 函数，3，13–14
- en: series example, 327–330
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: 序列示例，327–330
- en: hosts, 345
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 主机，345
- en: internal data sets, 5
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 内部数据集，5
- en: Huang, Min-Yu, 324
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 黄，明宇，324
- en: internal storage, matrix, 59, 61
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存储，矩阵，59，61
- en: Internet, accessing, 246–250
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Internet，246–250
- en: '**I**'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: '**I**'
- en: implementing parallel R example,
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并行 R 示例，
- en: 248–250
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 248–250
- en: identical() function, 55
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: identical() 函数，55
- en: sockets, 247–248
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字，247–248
- en: IDEs (integrated development environ-
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: IDEs (集成开发环境
- en: TCP/IP, 247
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP，247
- en: ments), xx, 186
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 语句），xx，186
- en: Internet Protocol (IP) address, 247
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: Internet 协议 (IP) 地址，247
- en: ifelse() function, 48–49
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: ifelse() 函数，48–49
- en: intersect() set operation, 202
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: intersect() 集合操作，202
- en: assessing statistical relation of two
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 评估两个统计关系的统计关系，
- en: intextract() function, 243
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: intextract() 函数，243
- en: variables example, 49–51
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: 变量示例，49–51
- en: I/O (input/output), 231–250
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: I/O (输入/输出)，231–250
- en: control statements, 143–144
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句，143–144
- en: accessing Internet, 246–250
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Internet，246–250
- en: recoding abalone data set example,
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 重编码鲍鱼数据集示例，
- en: implementing parallel R example,
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并行 R 示例，
- en: 51–54
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 51–54
- en: 248–250
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 248–250
- en: if statements, nested, 141–142
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套 if 语句，141–142
- en: sockets in R, 247–248
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的套接字，247–248
- en: image manipulation, 63–66
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理，63–66
- en: TCP/IP, 247
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP，247
- en: images component, mapsound()
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: 图像组件，mapsound()
- en: accessing keyboard and monitor,
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 访问键盘和监视器，
- en: function, 116
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，116
- en: 232–235
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 232–235
- en: immutable objects, 314
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象，314
- en: using print() function, 234–235
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 print() 函数，234–235
- en: indexing
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: using readline() function, 234
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 readline() 函数，234
- en: list, 87–88
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，87–88
- en: using scan() function, 232–234
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 scan() 函数，232–234
- en: '**364**'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: '**364**'
- en: INDEX
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: reading files, 235
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读文件，235
- en: lines() function, 264
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: lines() 函数，264
- en: accessing files on remote
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 访问远程文件
- en: Linux package manager, installing R
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 软件包管理器，安装 R
- en: machines via URLs, 243
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 URL 访问机器，243
- en: from, 353–354
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 从，353–354
- en: connections, 237–238
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 连接，237–238
- en: lists, 12–14, 85–100
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，12–14，85–100
- en: reading data frame or matrix from
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 从中读取数据框或矩阵
- en: accessing components and values,
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: 访问组件和值
- en: files, 236
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，236
- en: 93–95
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 93–95
- en: reading PUMS census files
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 PUMS 人口普查文件
- en: applying functions to, 95–99
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函数，95–99
- en: example, 239–243
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，239–243
- en: abalone data example, 99
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍鱼数据示例，99
- en: reading text files, 237
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文本文件，237
- en: lapply() and sapply() functions, 95
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: lapply() 和 sapply() 函数，95
- en: writing files
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件
- en: text concordance example, 95–98
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 文本一致性示例，95–98
- en: getting files and directory
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件和目录
- en: general operations, 87–93
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 一般操作，87–93
- en: information, 245
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 信息，245
- en: adding and deleting list elements,
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除列表元素
- en: sum contents of many files
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 合并多个文件的文件内容
- en: 88–90
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 88–90
- en: example, 245–246
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，245–246
- en: getting size of list, 90
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列表大小，90
- en: writing to files, 243–245
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件，243–245
- en: list indexing, 87–88
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 列表索引，87–88
- en: IP (Internet Protocol) address, 247
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: IP（互联网协议）地址，247
- en: text concordance example, 90–93
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 文本一致性示例，90–93
- en: recursive lists, 99–100
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 递归列表，99–100
- en: '**J**'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: '**J**'
- en: lm()function, 15, 208–210
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: lm() 函数，15，208–210
- en: load balance, 349–350
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡，349–350
- en: join operation, 109
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: 连接操作，109
- en: locator() function
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: locator() 函数
- en: determining relevant rows and col-
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: 确定相关行和列
- en: '**K**'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: '**K**'
- en: umns, 64–65
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: umns，64–65
- en: pinpointing locations with, 271–272
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pinpointing locations with，271–272
- en: keyboard, accessing, 232–235
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键盘访问，232–235
- en: loess() function, 276
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: loess() 函数，276
- en: printing to screen, 234–235
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 打印到屏幕，234–235
- en: log10() math function, 189
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: log10() 数学函数，189
- en: using readline() function, 234
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 readline() 函数，234
- en: logical operations, 30–31
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算，30–31
- en: using scan() function, 232–234
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 scan() 函数，232–234
- en: logistic regression models, applying,
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 应用逻辑回归模型
- en: KMC (k-means clustering), 338–340
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: KMC（k-均值聚类），338–340
- en: 113–115
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 113–115
- en: log() math function, 189
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: log() 数学函数，189
- en: '**L**'
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: '**L**'
- en: long-run state distribution, Markov
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: 长期状态分布，马尔可夫
- en: modeling, 200
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 模型，200
- en: lag operations, vector, 50–51
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: 向量滞后操作，50–51
- en: loops, control statements, 140–142
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 循环，控制语句，140–142
- en: lapply() function
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: lapply() 函数
- en: lowess() function, 276
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: lowess() 函数，276
- en: applying functions to lists, 95
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于列表，95
- en: ls() function
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: ls() 函数
- en: lists, 50
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，50
- en: environment and scope, 155–156
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 环境和作用域，155–156
- en: looping over nonvector sets, 142
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历非向量集合，142
- en: listing objects with, 226–227
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 exists() 函数列出对象，226–227
- en: using on data frames, 112–113
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框中使用，112–113
- en: latency, 346
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟，346
- en: lazy evaluation principle, 52, 147
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估原则，52，147
- en: '**M**'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: '**M**'
- en: leaving-one-out method, 219, 222
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 留一法，219，222
- en: magnifying portions of curve, 277–280
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 放大曲线的部分，277–280
- en: legend() function, 270
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: legend() 函数，270
- en: makerow() function, 241–242
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: makerow() 函数，241–242
- en: length() function
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: length() 函数
- en: managers, snow package, 335
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员，snow 包，335
- en: obtaining length of vector, 27
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 获取向量长度，27
- en: managing objects, 226–230
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象，226–230
- en: vector indexing, 32
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 向量索引，32
- en: determining object structure,
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 确定对象结构
- en: levels, factors and, 121–122
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: 层级，因子和，121–122
- en: 228–230
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 228–230
- en: .libPaths() function, 356–357
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: .libPaths() 函数，356–357
- en: exists() function, 230
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: exists() 函数，230
- en: library functions, 165
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数，165
- en: listing objects with ls() function,
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ls() 函数列出对象
- en: linear algebra operations, on vectors
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数操作，在向量上
- en: 226–227
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: 226–227
- en: and matrices, 61, 196–201
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 和矩阵，61，196–201
- en: removing specific objects with rm()
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 rm() 删除特定对象
- en: finding stationary distributions of
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找平稳分布
- en: function, 227–228
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，227–228
- en: Markov chains example, 199–201
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链示例，199–201
- en: saving collection of objects with
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 save() 函数保存对象集合
- en: vector cross product example, 198–199
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 向量叉积示例，198–199
- en: save() function, 228
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: save() 函数，228
- en: INDEX
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**365**'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: '**365**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: mapsound() function, 115–116
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: mapsound() 函数，115–116
- en: memory
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 内存
- en: marginal values, variable, 131
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 边际值，变量，131
- en: chunking, 320–321
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 分块，320–321
- en: m argument, apply() function, 70
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: m 参数，apply() 函数，70
- en: functional programming, 314–316
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程，314–316
- en: Markov chains, 199–201
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链，199–201
- en: avoiding memory copy example,
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存拷贝示例
- en: MASS package, 23, 356
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: MASS 包，23，356
- en: 315–316
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: 315–316
- en: math functions, 189–193
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数，189–193
- en: copy-on-change issues, 314–315
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: 处理拷贝更改问题，314–315
- en: calculating probability example,
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: 计算概率示例
- en: vector assignment issues, 314
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 向量赋值问题，314
- en: 190–191
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: 190–191
- en: using R packages for memory
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 包进行内存管理
- en: calculus, 192–193
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分，192–193
- en: management, 321
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 管理，321
- en: cumulative sums and products, 191
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: 累加和乘积，191
- en: merge() function, 109–110
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: merge() 函数，109–110
- en: minima and maxima, 191–192
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: 极小值和极大值，191–192
- en: merge sort method, numerical
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序方法，数值
- en: matrices, 11–12, 59–83
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，11–12，59–83
- en: sorting, 347
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，347
- en: adding and deleting rows and col-
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除行和列
- en: merging data frames, 109–112
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 合并数据框，109–112
- en: umns, 73–78
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: umns，73–78
- en: employee database example,
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: 员工数据库示例，
- en: finding closest pair of vertices in
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中寻找最近的顶点对
- en: 111–112
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: 111–112
- en: graph example, 75–78
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: 图形示例，75–78
- en: metacharacters, 254
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 元字符，254
- en: resizing matrix, 73–75
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: 调整矩阵大小，73–75
- en: methods() function, 210
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: methods() 函数，210
- en: applying functions to rows and col-
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于行和列
- en: microdata, 239
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: 微数据，239
- en: umns, 70–73
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 列，70–73
- en: minima function, 191–192
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值函数，191–192
- en: apply() function, 70–72
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: apply() 函数，70–72
- en: min() math function, 190, 191
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: min() 数学函数，190，191
- en: finding outliers example, 72–73
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找异常值示例，72–73
- en: M/M/1 queue, 165, 168
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: M/M/1 队列，165，168
- en: avoiding unintended dimension
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 避免意外的维度
- en: modes
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: reduction, 80–81
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 减少，80–81
- en: batch, 1, 3, 24
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 批量，1，3，24
- en: linear algebra operations on, 196–201
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: 在其上执行线性代数操作，196–201
- en: defined, 26
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，26
- en: naming rows and columns, 81–82
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 命名行和列，81–82
- en: interactive, 2–3
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式，2–3
- en: operations, 61–70
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，61–70
- en: modulo operator, 44
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符，44
- en: filtering, 66–69
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤，66–69
- en: monitor, accessing, 232–235
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器，访问，232–235
- en: generating covariance matrix
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 生成协方差矩阵
- en: using print() function, 234–235
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 print() 函数，234–235
- en: example, 69–70
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，69–70
- en: using readline() function, 234
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 readline() 函数，234
- en: image manipulation example,
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理示例，
- en: using scan() function, 232–234
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 scan() 函数，232–234
- en: 63–66
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 63–66
- en: Monte Carlo simulation, achieving bet-
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: Monte Carlo 模拟，实现 bet-
- en: linear algebra operations, 61
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数操作，61
- en: ter speed in, 308–311
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中的速度，308–311
- en: matrix indexing, 62–63
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵索引，62–63
- en: multicore machines, 340–341
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 多核机器，340–341
- en: reading from files, 236
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件读取，236
- en: mutlinks() function, 336
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: mutlinks() 函数，336
- en: vector/matrix distinction, 78–79
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 向量/矩阵的区别，78–79
- en: mutual outlinks, 333–334, 341–342
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: 互链，333–334，341–342
- en: as vectors, 28
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向量，28
- en: mvrnorm() function, MASS package, 23, 356
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: mvrnorm() 函数，MASS 包，23，356
- en: matrix/array-like operations, 130–131
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 类似矩阵/数组的操作，130–131
- en: matrix class, 79
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵类，79
- en: '**N**'
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**'
- en: matrix() function, 60
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: matrix() 函数，60
- en: matrix-inverse update method, 222
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵逆更新方法，222
- en: named arguments, 146–147
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数，146–147
- en: matrix-like operations, 104–109
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: 类似矩阵的操作，104–109
- en: names() function, 56
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: names() 函数，56
- en: apply() function, 107
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: apply() 函数，107
- en: naming
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: 命名
- en: extracting subdata frames, 104–105
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 提取子数据框，104–105
- en: matrix rows and columns, 81–82
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的行和列，81–82
- en: NA values, 105–106
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: NA 值，105–106
- en: vector elements, 56
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 向量元素，56
- en: rbind() and cbind() functions,
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: rbind() 和 cbind() 函数，
- en: NA values
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: NA 值
- en: 106–107
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 106–107
- en: matrix-like operations, 105–106
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: 类似矩阵的操作，105–106
- en: salary study example, 108–109
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 工资研究示例，108–109
- en: vectors, 43
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，43
- en: matrix-multiplication operator, 12
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法运算符，12
- en: n browser command, 289
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: n 浏览器命令，289
- en: maxima function, 191–192
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值函数，191–192
- en: nchar() function, 252
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: nchar() 函数，252
- en: max() math function, 190, 192
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: max() 数学函数，190，192
- en: ncol() function, 79
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: ncol() 函数，79
- en: mean() function, 38
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: mean() 函数，38
- en: '**366**'
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
  zh: '**366**'
- en: INDEX
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: negative subscripts, 32, 63
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: 负下标，32，63
- en: matrix, 61–70
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵，61–70
- en: network, defined, 247
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，定义，247
- en: filtering, 66–69
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤，66–69
- en: Newton-Raphson method, 192
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉夫森方法，192
- en: generating covariance matrix
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: 生成协方差矩阵
- en: next statement, 141
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句，141
- en: example, 69–70
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，69–70
- en: Nile data set, 5
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 尼罗数据集，5
- en: image manipulation example,
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理示例，
- en: noise, adding to image, 65–66
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: 向图像中添加噪声，65–66
- en: 63–66
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: 63–66
- en: nominal variables, 121
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 名义变量，121
- en: indexing, 62–63
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: 索引，62–63
- en: nonlocals
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: 非局部变量
- en: linear algebra operations, 61
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数操作，61
- en: writing to with superassignment
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 superassignment 写入
- en: matrix/array-like, 130–131
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵/数组类似，130–131
- en: operator, 161–162
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符，161–162
- en: vector, 30–34
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，30–34
- en: writing with assign() function, 163
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 assign() 函数写入，163
- en: arithmetic and logical operations,
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑操作，
- en: nonvector sets, looping control state-
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: 非向量集合，循环控制状态
- en: 30–31
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
  zh: 30–31
- en: ments over, 143
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 在其上执行操作，143
- en: colon operator (:), 32–33
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号运算符 (:), 32–33
- en: nonvisible functions, 211
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: 不可见函数，211
- en: generating vector sequences with
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 generateVectorSequences() 生成向量序列
- en: nreps values, 205
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
  zh: nreps 值，205
- en: seq() function, 33–34
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: seq() 函数，33–34
- en: nrow() function, 79
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
  zh: nrow() 函数，79
- en: repeating vector constants with
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 repeatVectorConstants() 重复向量常数
- en: NULL values, 44
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: NULL 值，44
- en: rep() function, 34
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: rep() 函数，34
- en: vector in, matrix out, 42–43
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: 输入向量，输出矩阵，42–43
- en: '**O**'
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
  zh: '**O**'
- en: vector in, vector out, 40–42
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 输入向量，输出向量，40–42
- en: vector indexing, 31–32
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
  zh: 向量索引，31–32
- en: object-oriented programming. *See* OOP
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程。*另见* OOP
- en: operator precedence, 33
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符优先级，33
- en: objects. *See also* managing objects
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。*另见*管理对象
- en: order() function, 97, 194–195
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: order() 函数，97，194–195
- en: first-class, 149
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 首类，149
- en: outliers, 49
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值，49
- en: immutable, 314
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变，314
- en: oddcount() function, 7, 140
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: oddcount() 函数，7，140
- en: '**P**'
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
  zh: '**P**'
- en: omp barrier pragma, OpenMP, 344
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: omp barrier 指令，OpenMP，344
- en: omp critical pragma, OpenMP, 344
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: omp critical 指令，OpenMP，344
- en: packages, 355–358
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: 包，355–358
- en: omp single pragma, OpenMP, 344–345
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: omp single 指令，OpenMP，344–345
- en: installing
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: 安装
- en: OOP (object-oriented programming),
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: OOP（面向对象编程），
- en: automatically, 356–357
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 自动，356–357
- en: xxi, 207–230
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
  zh: xxi，207–230
- en: manually, 357–358
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 手动，357–358
- en: managing objects. *See* managing
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象。*见* 管理
- en: listing functions in, 358
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中列出函数，358
- en: objects
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: loading from hard drive, 356
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬盘加载，356
- en: S3 classes. *See* S3 classes
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: S3 类。*见* S3 类
- en: parallel R, 333–351
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R，333–351
- en: S4 classes, 222–226
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: S4 类，222–226
- en: debugging, 351
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 调试，351
- en: implementing generic function
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
  zh: 实现泛型函数
- en: embarrassingly parallel applica-
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 显式并行应用程序，
- en: on, 225–226
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 在，225–226
- en: tions, 347–348
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 347–348
- en: vs. S3 classes, 226
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 与 S3 类，226
- en: turning general problems into, 350
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 将一般问题转化为，350
- en: writing, 223–225
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: 写作，223–225
- en: implementing, 248–250
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
  zh: 实现，248–250
- en: OpenMP, 344–345
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP，344–345
- en: mutual outlinks, 333–334
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
  zh: 互链，333–334
- en: code analysis, 343
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析，343
- en: resorting to C, 340–345
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: 诉诸 C，340–345
- en: omp barrier pragma, 344
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: omp barrier 禁言，344
- en: GPU programming, 345
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 编程，345
- en: omp critical pragma, 344
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: omp critical 禁言，344
- en: multicore machines, 340–341
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: 多核机器，340–341
- en: omp single pragma, 344–345
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: omp single 禁言，344–345
- en: mutual outlinks, 341–342
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: 互链，341–342
- en: operations
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 操作
- en: OpenMP code analysis, 343
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 代码分析，343
- en: list, 87–93
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，87–93
- en: OpenMP pragmas, 344–345
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 禁言，344–345
- en: adding and deleting list elements,
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除列表元素，
- en: running OpenMP code, 342
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 OpenMP 代码，342
- en: 88–90
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
  zh: 88–90
- en: snow package, 334–340
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: snow 包，334–340
- en: getting size of list, 90
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列表大小，90
- en: analyzing snow code, 336–337
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: 分析雪代码，336–337
- en: list indexing, 87–88
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 列表索引，87–88
- en: k-means clustering (KMC), 338–340
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 聚类（KMC），338–340
- en: text concordance example, 90–93
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
  zh: 文本一致性示例，90–93
- en: running snow code, 335–336
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 snow 代码，335–336
- en: speedup, 337–338
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
  zh: 加速，337–338
- en: INDEX
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**367**'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: '**367**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: snow package ( *continued*)
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: snow 包（*继续*）
- en: polynomial regression, 219–222, 266–269
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式回归，219–222，266–269
- en: sources of overhead, 346–347
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 资源开销来源，346–347
- en: port number, 247
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: 端口，247
- en: networked systems of computers,
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络系统，
- en: powers matrix, generating, 312–313
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 生成幂矩阵，312–313
- en: 346–347
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 346–347
- en: pragmas, OpenMP, 343–345
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: 禁言，OpenMP，343–345
- en: shared-memory machines, 346
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存机器，346
- en: preda() function, 38
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: preda() 函数，38
- en: static vs. dynamic task assignment,
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: 静态与动态任务分配，
- en: principle of confirmation, debugging,
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: 确认原则，调试，
- en: 348–350
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
  zh: 348–350
- en: 285–286
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 285–286
- en: parent.frame() function, 156
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: parent.frame() 函数，156
- en: print() function, 18, 234–235
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
  zh: print() 函数，18，234–235
- en: paste() function, 252–253, 257, 269
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: paste() 函数，252–253，257，269
- en: print.ut() function, 218
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: print.ut() 函数，218
- en: PDF devices, saving displayed
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
  zh: PDF 设备，保存显示
- en: prntrslts() function, 165
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: prntrslts() 函数，165
- en: graphs, 281
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 图，281
- en: probability, calculating, 190–191
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
  zh: 概率，计算，190–191
- en: pdf() function, 3
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
  zh: pdf() 函数，3
- en: probability mass function (pmf), 193
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 概率质量函数 (pmf)，193
- en: Pearson product-moment
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: Pearson 积矩
- en: procpairs() function, 343
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
  zh: procpairs() 函数，343
- en: correlation, 49
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性，49
- en: prod() math function, 190
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
  zh: prod() 数学函数，190
- en: performance enhancement, 305–321
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升，305–321
- en: programming structures. *See* R program-
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: 编程结构。*见* R 程序-
- en: byte code compilation, 320
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码编译，320
- en: ming structures
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
  zh: 构建结构
- en: chunking, 320–321
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: 块处理，320–321
- en: Public Use Microdata Samples (PUMS)
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 公共使用微观数据样本 (PUMS)
- en: functional programming, 314–316
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程，314–316
- en: census files, reading, 239
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 人口普查文件，读取，239
- en: avoiding memory copy example,
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存复制示例，
- en: Python, using R from, 330–332
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
  zh: Python，从 Python 使用 R，330–332
- en: 315–316
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 315–316
- en: copy-on-change issues, 314–315
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 复制更改问题，314–315
- en: '**Q**'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q**'
- en: vector assignment issues, 314
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: 向量赋值问题，314
- en: for loop, 306–313
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环，306–313
- en: Q browser command, 289
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: Q 浏览器命令，289
- en: achieving better speed in a Monte
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: 在蒙特
- en: qr() linear algebra function, 197
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: qr() 线性代数函数，197
- en: Carlo simulation example,
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 卡罗尔模拟示例，
- en: Quicksort implementation, 176–177
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序实现，176–177
- en: 308–311
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: 308–311
- en: generating powers matrix exam-
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 生成幂矩阵考试，
- en: '**R**'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: '**R**'
- en: ple, 312–313
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，312–313
- en: vectorization for speedup, 306–308
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化以加速，306–308
- en: race condition, 343
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件，343
- en: using R packages for memory
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 包进行内存
- en: random variate generators, 204–205
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: 随机变量生成器，204–205
- en: rank()
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
  zh: rank()
- en: management, 321
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 管理，321
- en: function, 195–196
  id: totrans-3123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，195–196
- en: rbind()
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: rbind()
- en: using Rprof() function to find slow
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rprof() 函数查找慢
- en: function, 12, 106–107
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，12，106–107
- en: spots in code, 316–319
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的点，316–319
- en: ordering events, 171
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: 排序事件，171
- en: writing fast R code, 306
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: 编写快速 R 代码，306
- en: resizing matrices, 74–75
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: 调整矩阵大小，74–75
- en: rbinom()
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: rbinom()
- en: Perron-Frobenius theorem, 201
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
  zh: Perron-Frobenius 定理，201
- en: function, 204
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，204
- en: persp() function, 22, 282
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
  zh: persp() 函数，22，282
- en: R console, 2
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: R 控制台，2
- en: pixel intensity, 63–64
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 像素强度，63–64
- en: '*.Rdata* file, 20'
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rdata* 文件，20'
- en: plot()
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: plot()
- en: Rdsm
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
  zh: Rdsm
- en: function, xxi, 16, 262
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，xxi，16，262
- en: package, implementing
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 包，实现
- en: plots
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
  zh: 图表
- en: parallel R, 249
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 R，249
- en: reactevnt()
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: reactevnt()
- en: restoring, 272
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复，272
- en: function, 165
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，165
- en: readBin()
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
  zh: readBin()
- en: three-dimensional, 282–283
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 三维，282–283
- en: function, 248
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，248
- en: plyr
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: plyr
- en: read.csv()
  id: totrans-3151
  prefs: []
  type: TYPE_NORMAL
  zh: read.csv()
- en: package, 136
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包，136
- en: function, 108
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，108
- en: pmax() math function, 190, 192
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
  zh: pmax() 数学函数，190，192
- en: reading files, 235
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件，235
- en: pmf (probability mass function), 193
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 概率质量函数 (pmf)，193
- en: accessing files on remote machines
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 访问远程机器上的文件
- en: pmin() math function, 190, 191
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
  zh: pmin() 数学函数，190，191
- en: via URLs, 243
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 URL，243
- en: pointers, 159–161
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
  zh: 指针，159–161
- en: connections, 237–238
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
  zh: 连接，237–238
- en: points() function, 269–270
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
  zh: points() 函数，269–270
- en: reading data frames or matrices from
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
  zh: 从中读取数据框或矩阵，
- en: polygon() function, 275–276
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: polygon() 函数，275–276
- en: files, 236
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，236
- en: polymorphism
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 多态
- en: reading PUMS census files example,
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 PUMS 人口普查文件示例，
- en: defined, xxi, 207
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，xxi，207
- en: 239–243
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 239–243
- en: generic functions, 208
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数，208
- en: reading text files, 237
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文本文件，237
- en: '**368**'
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: '**368**'
- en: INDEX
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: readline() function, 234
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: readline() 函数，234
- en: R programming structures, 139
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: R 编程结构，139
- en: readLines() function, 248
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: readLines() 函数，248
- en: anonymous functions, 187–188
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数，187–188
- en: reassigning matrices, 73–74
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配矩阵，73–74
- en: arithmetic and Boolean operators
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和布尔运算符
- en: recursion, 176–182
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，176–182
- en: and values, 145–146
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
  zh: 和值，145–146
- en: binary search tree example, 177–182
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树示例，177–182
- en: control statements, 139–144
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句，139–144
- en: Quicksort implementation, 176–177
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序实现，176–177
- en: if-else function, 143–144
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: if-else 函数，143–144
- en: recursive argument, concatenate
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
  zh: 递归参数，连接
- en: looping over nonvector sets, 143
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历非向量集合，143
- en: function, 100
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，100
- en: loops, 140–142
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: 循环，140–142
- en: recursive vectors, 86
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
  zh: 递归向量，86
- en: default values for arguments, 146–147
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的默认值，146–147
- en: recycling
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
  zh: 回收
- en: environment and scope issues,
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 环境和作用域问题，
- en: defined, 25
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，25
- en: 151–159
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
  zh: 151–159
- en: vectors, 29–30
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，29–30
- en: function to display contents of call
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
  zh: 显示调用内容的函数
- en: reference classes, 160
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: 参考类，160
- en: frame example, 157–159
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
  zh: 框架示例，157–159
- en: regexpr() function, 253–254
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
  zh: regexpr() 函数，253–254
- en: ls() function, 155–156
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
  zh: ls() 函数，155–156
- en: regression analysis of exam grades,
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
  zh: 考试成绩的回归分析，
- en: scope hierarchy, 152–155
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域层次结构，152–155
- en: 16–19, 103–104
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
  zh: 16–19，103–104
- en: side effects, 156–157
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用，156–157
- en: regular expressions, character string
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，字符字符串
- en: top-level environment, 152
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级环境，152
- en: manipulation, 254–257
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，254–257
- en: functions as objects, 149–151
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象，149–151
- en: remote machines, accessing files
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: 访问远程机器上的文件
- en: pointers, lack of, 159–161
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
  zh: 指针，缺乏，159–161
- en: on, 243
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: 在，243
- en: recursion, 176–182
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，176–182
- en: repeat loop, 241–242
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
  zh: repeat 循环，241–242
- en: binary search tree example,
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树示例，
- en: repeat statement, 141
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
  zh: repeat 语句，141
- en: 177–182
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: 177–182
- en: rep() function, repeating vector con-
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: rep() 函数，重复向量连接
- en: Quicksort implementation,
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序实现，
- en: stants with, 34
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: 与，34
- en: 176–177
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: 176–177
- en: replacement functions, 182–186
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
  zh: 替换函数，182–186
- en: replacement functions, 182–186
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: 替换函数，182–186
- en: defined, 183–184
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，183–184
- en: return values, 147–149
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值，147–149
- en: self-bookkeeping vector class
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 自我记账向量类
- en: deciding whether to explicitly call
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 决定是否显式调用
- en: example, 184–186
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，184–186
- en: return() function, 148
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
  zh: return() 函数，148
- en: reshape package, 136
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: reshape 软件包，136
- en: returning complex objects,
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: 返回复杂对象，
- en: resizing matrices, 73–75
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
  zh: 调整矩阵大小，73–75
- en: 148–149
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 148–149
- en: return statement, 8
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回语句，8
- en: tools for composing function code,
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数代码的工具，
- en: return values, 147–149
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值，147–149
- en: 186–187
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
  zh: 186–187
- en: deciding whether to explicitly call
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 决定是否显式调用
- en: edit() function, 186–187
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
  zh: edit() 函数，186–187
- en: return() function, 148
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: return() 函数，148
- en: text editors and IDEs, 186
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器和 IDE，186
- en: returning complex objects, 148–149
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: 返回复杂对象，148–149
- en: writing, 161–175
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
  zh: 写入，161–175
- en: REvolution Analytics, 300
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: REvolution Analytics，300
- en: binary operations, 187
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制运算，187
- en: rexp() function, 204
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
  zh: rexp() 函数，204
- en: closures, 174–175
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包，174–175
- en: Rf_PrintValue(s) function, 304
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
  zh: Rf_PrintValue(s) 函数，304
- en: discrete-event simulation (DES) in
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: 在离散事件模拟 (DES) 中
- en: rgamma() function, 204
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
  zh: rgamma() 函数，204
- en: R example, 164–171
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: R 示例，164–171
- en: '*.Rhistory* file, 20'
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rhistory* 文件，20'
- en: when to use global variables,
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: 当何时使用全局变量，
- en: rm() function, 227–228
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
  zh: rm() 函数，227–228
- en: 171–174
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
  zh: 171–174
- en: rnorm() function, 3, 204
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: rnorm() 函数，3，204
- en: writing to nonlocals with assign()
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 assign() 写入非局部变量
- en: round() function, 40–41, 190
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
  zh: round() 函数，40–41，190
- en: function, 163
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，163
- en: routers, 247
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器，247
- en: writing to nonlocals with the super-
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 super- 写入非局部变量
- en: row() function, 69–70
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: row() 函数，69–70
- en: assignment operator, 161–162
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符，161–162
- en: rownames() function, 82
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: rownames() 函数，82
- en: RPy module
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: RPy 模块
- en: R packages, for memory
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
  zh: R 软件包，用于内存
- en: installing, 330
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: 安装，330
- en: management, 321
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
  zh: 管理，321
- en: syntax, 330–332
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: 语法，330–332
- en: rpois() function, 204
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
  zh: rpois() 函数，204
- en: runif() function, 204
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: runif() 函数，204
- en: Rprof() function, 316–319
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
  zh: Rprof() 函数，316–319
- en: running
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行
- en: '*.Rprofile* file, 19'
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: '*.Rprofile* 文件，19'
- en: GDB on R, 303–304
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: R 上的 GDB，303–304
- en: OpenMP code, 342
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 代码，342
- en: INDEX
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**369**'
  id: totrans-3279
  prefs: []
  type: TYPE_NORMAL
  zh: '**369**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: running ( *continued*)
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: 运行（*继续*）
- en: setdiff() set operation, 202
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
  zh: setdiff() 集合操作，202
- en: R, 1–2
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
  zh: R，1–2
- en: setequal() set operation, 202
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: setequal() 集合操作，202
- en: batch mode, 3
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: 批量模式，3
- en: setMethod() function, 225
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: setMethod() 函数，225
- en: first session, 4–7
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一节课，4–7
- en: set operations, 202–203
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作，202–203
- en: interactive mode, 2–3
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 交互模式，2–3
- en: set.seed() function, 302
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: set.seed() 函数，302
- en: snow code, 335–336
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: snow 代码，335–336
- en: setting breakpoints, 289–290
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点，289–290
- en: runs of consecutive ones, finding, 35–37
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
  zh: 找到连续的 1 的运行，35–37
- en: calling browser() function directly,
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用 browser() 函数，
- en: runtime errors, 303
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误，303
- en: 289–290
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
  zh: 289–290
- en: using setbreakpoint() function, 290
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 setbreakpoint() 函数，290
- en: '**S**'
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
  zh: '**S**'
- en: setwd() function, 245
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: setwd() 函数，245
- en: S expression pointers (SEXPs), 304
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
  zh: S 表达式指针 (SEXPs)，304
- en: S (programming language), xix
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: S（编程语言），xix
- en: shared-memory systems, 341, 346–347
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存系统，341，346–347
- en: S3 classes, 208–222
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
  zh: S3 类，208–222
- en: shared-memory/threads model,
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存/线程模型，
- en: class for storing upper-triangular
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
  zh: 存储上三角矩阵的类
- en: GPUs, 345
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: GPU，345
- en: matrices example, 214–219
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵示例，214–219
- en: Sherman-Morrison-Woodbury
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
  zh: Sherman-Morrison-Woodbury
- en: finding implementations of generic
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
  zh: 找到泛型函数的实现
- en: formula, 222
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 公式，222
- en: methods, 210–212
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，210–212
- en: shortcuts
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 快捷方式
- en: generic functions, 208
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数，208
- en: help() function, 20
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: help() 函数，20
- en: OOP in lm() function example,
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lm() 函数示例中的面向对象编程，
- en: help.search() function, 23
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: help.search() 函数，23
- en: 208–210
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: 208–210
- en: showframe() function, 158
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
  zh: showframe() 函数，158
- en: procedure for polynomial regression
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式回归的步骤
- en: sim global variable, 172–173
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
  zh: sim 全局变量，172–173
- en: example, 219–222
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，219–222
- en: simplifying code, 172
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
  zh: 简化代码，172
- en: vs. S4 classes, 226
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: 与 S4 类的比较，226
- en: simulation programming in R, 204–206
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的模拟编程，204–206
- en: using inheritance, 214
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，214
- en: built-in random variate generators,
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 内置随机变量生成器，
- en: writing, 212–213
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
  zh: 写作，212–213
- en: 204–205
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: 204–205
- en: S4 classes, 222–226
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
  zh: S4 类，222–226
- en: combinatorial simulation, 205–206
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模拟，205–206
- en: implementing generic function on,
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
  zh: 在上实现泛型函数，
- en: obtaining same random stream in
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: 获取相同的随机流在
- en: 225–226
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
  zh: 225–226
- en: repeated runs, 205
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的运行，205
- en: vs. S3 classes, 226
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
  zh: 与 S3 类的比较，226
- en: single brackets, 87–88
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: 单括号，87–88
- en: writing, 223–225
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
  zh: 写作，223–225
- en: single-server queuing system, 168
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 单服务器排队系统，168
- en: salary study, 108–109
  id: totrans-3339
  prefs: []
  type: TYPE_NORMAL
  zh: 工资研究，108–109
- en: sink() function, 258
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: sink() 函数，258
- en: Salzman, Pete, 285
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
  zh: Salzman，Pete，285
- en: sin() math function, 190
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: sin() 数学函数，190
- en: sapply() function, 42
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: sapply() 函数，42
- en: slots, S4 class, 224
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽，S4 类，224
- en: applying functions to lists, 95
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于列表，95
- en: snow package, 334–335
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: snow 包，334–335
- en: using on data frames, 112–113
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框上使用，112–113
- en: implementing parallel R, 248–249
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并行 R，248–249
- en: save() function, saving collection of
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: save() 函数，保存集合，
- en: k-means clustering (KMC), 338–340
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 聚类 (KMC)，338–340
- en: objects with, 228
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有对象的，228
- en: snow code
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: snow 代码
- en: saving graphs to files, 280–281
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: 将图形保存到文件，280–281
- en: analyzing, 336–337
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 分析，336–337
- en: scalars, 10
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
  zh: 标量，10
- en: running, 335–336
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: 运行，335–336
- en: Boolean operators, 145
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符，145
- en: speedup, 337–338
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
  zh: 加速，337–338
- en: vectors, 26
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，26
- en: socketConnection() function, 248
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: socketConnection() 函数，248
- en: scan() function, 142, 232–234
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: scan() 函数，142，232–234
- en: sockets, 247–248
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字，247–248
- en: scatter/gather paradigm, 335–336
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: 散列/聚集范例，335–336
- en: socketSelect() function, 248
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: socketSelect() 函数，248
- en: schedevnt() function, 165, 171
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: schedevnt() 函数，165，171
- en: solve() function, 197
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: solve() 函数，197
- en: scope hierarchy, 152–155\. *See also* envi-
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: 范围层次，152–155\. *另见* 环境
- en: sorting, numerical, 194–196
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，数值，194–196
- en: ronment and scope
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 环境 和 范围
- en: sos package, 24
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: sos 包，24
- en: sepsoundtone() function, 119
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: sepsoundtone() 函数，119
- en: source, installing R from, 354
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
  zh: 从源安装 R，354
- en: seq() function, 21, 33–34
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: seq() 函数，21，33–34
- en: sourceval parameter, mapsound()
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: sourceval 参数，mapsound()
- en: serialize() function, 248
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: serialize() 函数，248
- en: function, 116
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，116
- en: setbreakpoint() function, 290
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
  zh: setbreakpoint() 函数，290
- en: Spearman rank correlation, 49
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: 斯皮尔曼等级相关，49
- en: setClass() function, 223
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
  zh: setClass() 函数，223
- en: '**370**'
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: '**370**'
- en: INDEX
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: speed
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: summary() function, 15, 18
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: summary() 函数，15，18
- en: byte code compilation, 320
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码编译，320
- en: summaryRprof() function, 319
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: summaryRprof() 函数，319
- en: finding slow spots in code, 316–319
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中找到慢点，316–319
- en: summing contents of many files, 245–246
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 对多个文件内容求和，245–246
- en: for loop, 306–313
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环，306–313
- en: superassignment operator (<<-), 9
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 超赋值运算符 (<<-), 9
- en: achieving better speed in Monte
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 在蒙特卡洛模拟中实现更好的速度
- en: simplifying code, 174
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
  zh: 简化代码，174
- en: Carlo simulation example,
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟示例，
- en: writing to nonlocals with, 161–162
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它向非局部写入，161–162
- en: 308–311
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: 308–311
- en: sweep() linear algebra function, 197–198
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
  zh: sweep() 线性代数函数，197–198
- en: generating powers matrix
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: 生成幂矩阵
- en: symmetric matrix, 77
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: 对称矩阵，77
- en: example, 312–313
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，312–313
- en: syntax errors, 303
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误，303
- en: vectorization for speedup,
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化以加速，
- en: 306–308
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
  zh: 306–308
- en: '**T**'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: '**T**'
- en: writing fast R code, 306
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 编写快速R代码，306
- en: Spinu, Vitalie, 300
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
  zh: Spinu, Vitalie，300
- en: tabdom() function, 134
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: tabdom() 函数，134
- en: split() function, 124–126, 336
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: split() 函数，124–126，336
- en: tables, 127–130
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: 表格，127–130
- en: S-Plus (programming language), xix
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
  zh: S-Plus (编程语言)，xix
- en: extracting subtable example,
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 提取子表示例，
- en: sprintf() function, 253
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: sprintf() 函数，253
- en: 131–134
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 131–134
- en: sqrt() function, 42, 189
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: sqrt() 函数，42，189
- en: finding largest cells in, 134
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中查找最大的单元格，134
- en: stack trace, 289
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
  zh: 栈跟踪，289
- en: functions, 136–137
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，136–137
- en: startup and shutdown, 19–20
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和关闭，19–20
- en: aggregate(), 136
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
  zh: aggregate()，136
- en: static task assignment, 348–350
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: 静态任务分配，348–350
- en: cut(), 136–137
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
  zh: cut()，136–137
- en: stationary distributions, Markov chains,
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
  zh: 稳态分布，马尔可夫链，
- en: matrix/array-like operations,
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵/数组类似操作，
- en: 199–201
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
  zh: 199–201
- en: 130–131
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: 130–131
- en: statistical distributions, functions for,
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
  zh: 统计分布，函数，用于
- en: tags, 86
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
  zh: 标签，86
- en: 193–194
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 193–194
- en: tapply() function
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
  zh: tapply() 函数
- en: str() function, 14
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: str() 函数，14
- en: vs. by() function, 126–127
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
  zh: 与 by() 函数比较，126–127
- en: string-manipulation functions, 11,
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作函数，11，
- en: factors, 123–124
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
  zh: 因子，123–124
- en: 251–254
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 251–254
- en: vs. split() function, 124
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
  zh: 与 split() 函数比较，124
- en: gregexpr(), 254
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: gregexpr()，254
- en: tbl argument, subtable() function, 132
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
  zh: tbl 参数，subtable() 函数，132
- en: grep(), 252
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: grep()，252
- en: tblarray array, 133
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
  zh: tblarray 数组，133
- en: nchar(), 252
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: nchar()，252
- en: TCP/IP, 247
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP，247
- en: paste(), 252–253
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: paste()，252–253
- en: termination condition, 177
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: 终止条件，177
- en: regexpr(), 253–254
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: regexpr()，253–254
- en: testing vector equality, 54–55
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: 测试向量相等，54–55
- en: sprintf(), 253
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: sprintf()，253
- en: text, adding to graphs with text() func-
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 文本，使用 text() 函数添加到图形中
- en: strsplit(), 253
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
  zh: strsplit()，253
- en: tion, 270–271
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
  zh: 270–271
- en: substr(), 253
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
  zh: substr()，253
- en: text concordance, 90–93, 95–98
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: 文本一致性，90–93，95–98
- en: stringsAsFactors argument, data.frame()
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: stringsAsFactors 参数，data.frame()
- en: text editors, 186
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器，186
- en: function, 102
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，102
- en: text files, reading, 237
  id: totrans-3454
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件，读取，237
- en: string utilities, in edtdbg debugging tool,
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串实用工具，在 edtdbg 调试工具中，
- en: text() function, adding text to graphs
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
  zh: text() 函数，向图形中添加文本
- en: 257–259
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
  zh: 257–259
- en: with, 270–271
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: with，270–271
- en: strsplit() function, 253
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: strsplit() 函数，253
- en: t() function, 71, 119, 197
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
  zh: t() 函数，71，119，197
- en: subdeterminants, 199
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 子行列式，199
- en: threaded code, 171
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
  zh: 线程代码，171
- en: submatrices, assigning values to, 62–63
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: 子矩阵，赋值，62–63
- en: threads, 341
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
  zh: 线程，341
- en: subnames argument, subtable()
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: subnames 参数，subtable()
- en: three-dimensional tables, 129–130
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
  zh: 三维表格，129–130
- en: function, 132
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，132
- en: Tierney, Luke, 334
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: Tierney, Luke，334
- en: subscripting operations, 183
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: 下标操作，183
- en: tocol parameter, mapsound()
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
  zh: tocol 参数，mapsound()
- en: subset() function, 47, 105
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: subset() 函数，47，105
- en: function, 116
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，116
- en: subsetting, vector, 4–5
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: 向量子集，4–5
- en: tools
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 工具
- en: substr() function, 253
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: substr() 函数，253
- en: for composing function code,
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写函数代码，
- en: subtable() function, 132
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
  zh: subtable() 函数，132
- en: 186–187
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: 186–187
- en: suffix, testing filename for given, 255–256
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀，测试给定文件名，255–256
- en: edit() function, 186–187
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: edit() 函数，186–187
- en: sum() function, 190, 337
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
  zh: sum() 函数，190，337
- en: text editors and IDEs, 186
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器和 IDE，186
- en: debugging, 287–288, 300–302
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
  zh: 调试，287–288，300–302
- en: INDEX
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '**371**'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: '**371**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: top-level environment, 152
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级环境，152
- en: vectors, 10, 25–57
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，10，25–57
- en: traceback() function, 291–292
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
  zh: traceback() 函数，291–292
- en: all() and any() functions, 35–39
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: all() 和 any() 函数，35–39
- en: trace() function, 291
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
  zh: trace() 函数，291
- en: finding runs of consecutive ones
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找连续的1的序列
- en: tracemem() function, 314–315
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
  zh: tracemem() 函数，314–315
- en: example, 35–37
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，35–37
- en: training set, 37
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: 训练集，37
- en: predicting discrete-valued time
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 预测离散值时间
- en: transcendental functions, 40
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: 超越函数，40
- en: series example, 37–39
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: 系列示例，37–39
- en: transition probability, 200
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 转移概率，200
- en: c() function, 56–57
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
  zh: c() 函数，56–57
- en: treelike data structures, 177
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
  zh: 树状数据结构，177
- en: common operations, 30–34
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: 常用操作，30–34
- en: arithmetic and logical operations,
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑运算，
- en: '**U**'
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: '**U**'
- en: 30–31
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
  zh: 30–31
- en: colon operator (:), 32–33
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号运算符(:)，32–33
- en: Ubuntu, installing R on, 353–354
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 R，353–354
- en: generating vector sequences with
  id: totrans-3508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成向量序列，
- en: unclass() function, 229
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: unclass() 函数，229
- en: seq() function, 33–34
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
  zh: seq() 函数，33–34
- en: union() set operation, 202
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: union() 集合操作，202
- en: repeating vector constants with
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: 重复向量常数，
- en: unlist() function, 93
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: unlist() 函数，93
- en: rep() function, 34
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
  zh: rep() 函数，34
- en: unname() function, 94
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: unname() 函数，94
- en: vector indexing, 31–32
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 向量索引，31–32
- en: unserialize() function, 248
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
  zh: unserialize() 函数，248
- en: computing inner product of two, 196
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个的内积，196
- en: upn argument, showframe() function, 158
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: upn 参数，showframe() 函数，158
- en: declarations, 28–29
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
  zh: 声明，28–29
- en: upper-triangular matrices, class for stor-
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 上三角矩阵，用于存储
- en: defined, 4
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，4
- en: ing, 214–219
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
  zh: 214–219
- en: elements
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
  zh: 元素
- en: URLs, accessing files on remote
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: URLs，通过访问远程文件
- en: adding and deleting, 26
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除，26
- en: machines via, 243
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问，243
- en: naming, 56
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 命名，56
- en: u variable, 162
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
  zh: u 变量，162
- en: filtering, 45–48
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤，45–48
- en: generating indices for, 45–47
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: 为其生成索引，45–47
- en: '**V**'
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**'
- en: with subset() function, 47
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 subset() 函数，47
- en: with which() function, 47–48
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 which() 函数，47–48
- en: values
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
  zh: 值
- en: ifelse() function, 48–54
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: ifelse() 函数，48–54
- en: assigning to submatrices, 62–63
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值到子矩阵，62–63
- en: assessing statistical relation of two
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
  zh: 评估两个统计关系
- en: Boolean, 145–146
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔，145–146
- en: variables example, 49–51
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
  zh: 变量示例，49–51
- en: list, accessing, 93–95
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，访问，93–95
- en: recoding abalone data set
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: 重编码鲍鱼数据集
- en: NA, 43, 105–106
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
  zh: NA，43，105–106
- en: example, 51–54
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: example, 51–54
- en: NULL, 44
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: NULL，44
- en: linear algebra operations on,
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数运算，
- en: return, 147–149
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
  zh: 返回，147–149
- en: 196–201
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: 196–201
- en: vanilla option, startup/shutdown, 20
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: vanilla 选项，启动/关闭，20
- en: matrices and arrays as, 28
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和数组作为，28
- en: variables
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: NA value, 43
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: NA 值，43
- en: assessing statistical relation of two,
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: 评估两个统计关系，
- en: NULL value, 44
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
  zh: NULL 值，44
- en: 49–51
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 49–51
- en: obtaining length of, 27
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
  zh: 获取长度，27
- en: categorical, 121
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: 分类，121
- en: recycling, 29–30
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 回收，29–30
- en: global, 9, 171–174
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: 全局，9，171–174
- en: scalars, 26
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
  zh: 标量，26
- en: nominal, 121
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: 名义，121
- en: testing vector equality, 54–55
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: 测试向量相等，54–55
- en: variable scope, 9
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域，9
- en: vectorized operations, 39–43
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化操作，39–43
- en: vector assignment issues, 314
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: 向量赋值问题，314
- en: vector in, matrix out, 42–43
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
  zh: 向量输入，矩阵输出，42–43
- en: vector cross product, 198–199
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
  zh: 向量叉积，198–199
- en: vector in, vector out, 40–42
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 向量输入，向量输出，40–42
- en: vector filtering, 307
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
  zh: 向量过滤，307
- en: vertices, graph, finding, 75–78
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点，图，查找，75–78
- en: vector-filtering capability, 176
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 向量过滤能力，176
- en: vector functions, 311
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 向量函数，311
- en: '**W**'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: '**W**'
- en: vectorization
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化
- en: defined, 25
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 定义，25
- en: Web, downloading packages from,
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
  zh: Web，从 Web 下载包，
- en: for speedup, 306–308
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速，306–308
- en: 356–358
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
  zh: 356–358
- en: vectorized operations, 40
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化操作，40
- en: installing automatically, 356–357
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
  zh: 自动安装，356–357
- en: vector/matrix distinction, 78–79
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: 向量/矩阵区别，78–79
- en: installing manually, 357–358
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
  zh: 手动安装，357–358
- en: '**372**'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: '**372**'
- en: INDEX
  id: totrans-3584
  prefs: []
  type: TYPE_NORMAL
  zh: INDEX
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: where browser command, 289
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器命令中，289
- en: which.max() function, 73, 190
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: which.max() 函数，73，190
- en: which.min() function, 190
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
  zh: which.min() 函数，190
- en: which() function, 47–48
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: which() 函数，47–48
- en: whitespace, 233
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: 空白字符，233
- en: Wickham, Hadley, 136
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: Wickham，Hadley，136
- en: wireframe() function, 282–283
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
  zh: wireframe() 函数，282–283
- en: wmins matrix, 77
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: wmins 矩阵，77
- en: workers, snow package, 335
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: workers，snow 包，335
- en: working directory, 19–20
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
  zh: 工作目录，19–20
- en: writeBin() function, 248
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
  zh: writeBin() 函数，248
- en: writeLines() function, 248
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: writeLines() 函数，248
- en: write.table() function, 244
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: write.table() 函数，244
- en: writing, 161
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: 编写，161
- en: binary operations, 187
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制运算，187
- en: C/C++ functions to be called from R,
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: 从 R 调用的 C/C++ 函数，
- en: 323–324
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: 323–324
- en: compiling and running code, 325
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行代码，325
- en: debugging R/C code, 326–327
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 R/C 代码，326–327
- en: extracting subdiagonals from
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: 从中提取子对角线
- en: square matrix example, 324–325
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵示例，324–325
- en: prediction of discrete-valued time
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
  zh: 离散值时间预测
- en: series example, 327–330
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
  zh: 系列示例，327–330
- en: closures, 174–175
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包，174–175
- en: discrete-event simulation in R
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的离散事件模拟
- en: example, 164–171
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
  zh: example，164–171
- en: getting files and directory
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件和目录
- en: information, 245
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 信息，245
- en: to nonlocals
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 到非局部变量
- en: with assign() function, 163
  id: totrans-3615
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 assign() 函数，163
- en: with superassignment operator,
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超级赋值运算符，
- en: 161–162
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
  zh: 161–162
- en: S3 classes, 212–213
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: S3 类，212–213
- en: S4 classes, 223–225
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
  zh: S4 类，223–225
- en: summing contents of many files
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: 求多个文件内容之和
- en: example, 245–246
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: example, 245–246
- en: when to use global variables, 171–174
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用全局变量，171–174
- en: '**X**'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: '**X**'
- en: xlim option, 273–275
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
  zh: xlim 选项，273–275
- en: x variable, 162
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: x 变量，162
- en: '**Y**'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: '**Y**'
- en: ylim option, 273–275
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: ylim 选项，273–275
- en: '**Z**'
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z**'
- en: z variable, 162
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
  zh: z 变量，162
- en: INDEX
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: INDEX
- en: '**373**'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: '**373**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The Electronic Frontier Foundation (EFF) is the leading organization defending
    civil liberties in the digital world. We defend free speech on the Internet, fight
    illegal surveillance, promote the rights of innovators to develop new digital
    technologies, and work to ensure that the rights and freedoms we enjoy are enhanced
    —
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
  zh: 电子前沿基金会 (EFF) 是领先的捍卫数字世界公民自由的组织。我们捍卫互联网上的言论自由，反对非法监控，促进创新者开发新的数字技术，并努力确保我们享有的权利和自由得到增强——
- en: rather than eroded — as our use of technology grows.
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是被侵蚀——随着我们使用技术的增长。
- en: PRIVACY EFF has sued telecom giant AT&T for giving the NSA unfettered access
    to the private communications of millions of their customers. eff.org/nsa
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: PRIVACY EFF 已起诉电信巨头 AT&T，因其允许 NSA 无限制地访问数百万客户的私人通信。eff.org/nsa
- en: FREE SPEECH EFF’s Coders’ Rights Project is defending the rights of programmers
    and security researchers to publish their findings without fear of legal challenges.
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
  zh: FREE SPEECH EFF 的 Coders’ Rights Project 正在捍卫程序员和安全研究人员在无法律挑战恐惧的情况下发布其发现的权利。
- en: eff.org/freespeech
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: eff.org/freespeech
- en: INNOVATION EFF's Patent Busting Project challenges overbroad patents that threaten
    technological innovation. eff.org/patent
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
  zh: 创新EFF的专利破坏项目挑战过于宽泛的专利，这些专利威胁到技术创新。eff.org/patent
- en: FAIR USE EFF is fighting prohibitive standards that would take away your right
    to receive and use over-the-air television broadcasts any way you choose. eff.org/IP/fairuse
    TRANSPARENCY EFF has developed the Switzerland Network Testing Tool to give individuals
    the tools to test for covert traffic filtering. eff.org/transparency
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: FAIR USE EFF 正在抵制那些会剥夺你以任何方式接收和使用空中电视广播权利的禁止性标准。eff.org/IP/fairuse 透明度 EFF 开发了瑞士网络测试工具，为个人提供测试隐蔽流量过滤的工具。eff.org/transparency
- en: INTERNATIONAL EFF is working to ensure that international treaties do not restrict
    our free speech, privacy or digital consumer rights. eff.org/global
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
  zh: 国际 EFF 正在努力确保国际条约不会限制我们的言论自由、隐私或数字消费者权利。eff.org/global
- en: EFF is a member-supported organization. Join Now! www.eff.org/support
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: EFF 是一个会员支持的组织。立即加入！www.eff.org/support
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 46](index-401_1.jpg)'
  id: totrans-3643
  prefs: []
  type: TYPE_IMG
  zh: '![Image 46](index-401_1.jpg)'
- en: '![Image 47](index-401_2.jpg)'
  id: totrans-3644
  prefs: []
  type: TYPE_IMG
  zh: '![Image 47](index-401_2.jpg)'
- en: '![Image 48](index-401_3.jpg)'
  id: totrans-3645
  prefs: []
  type: TYPE_IMG
  zh: '![Image 48](index-401_3.jpg)'
- en: '![Image 49](index-401_4.jpg)'
  id: totrans-3646
  prefs: []
  type: TYPE_IMG
  zh: '![Image 49](index-401_4.jpg)'
- en: '![Image 50](index-401_5.jpg)'
  id: totrans-3647
  prefs: []
  type: TYPE_IMG
  zh: '![Image 50](index-401_5.jpg)'
- en: '![Image 51](index-401_6.jpg)'
  id: totrans-3648
  prefs: []
  type: TYPE_IMG
  zh: '![Image 51](index-401_6.jpg)'
- en: UPDATES
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: 更新
- en: Visit *http://www.nostarch.com/artofr.htm* for updates, errata, and more.
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *http://www.nostarch.com/artofr.htm* 获取更新、勘误和其他信息。
- en: '*More no-nonsense books from*'
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: '*更多无废话的书籍来自*'
- en: NO STARCH PRESS
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
  zh: 诺斯塔奇出版社
- en: MAP SCRIPTING 101
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编程 101
- en: LEARN YOU A HASKELL
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Haskell
- en: ELOQUENT JAVASCRIPT
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅的 JavaScript
- en: An Example-Driven Guide to Building
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: 以示例驱动的构建指南
- en: FOR GREAT GOOD
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 为了伟大的善
- en: A Modern Introduction to Programming
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程导论
- en: Interactive Maps with Bing, Yahoo!,
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bing、Yahoo! 和 Google Maps 的交互式地图
- en: A Beginner’s Guide
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: 入门指南
- en: '*by* MARIJN HAVERBEKE'
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 马里恩·哈弗贝克'
- en: and Google Maps
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Google Maps
- en: JANUARY 2011, 224 PP., $29.95
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年1月，224页，$29.95
- en: '*by* MIRAN LIPOVAýA'
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 米兰·利波瓦亚'
- en: ISBN 978-1-59327-282-1
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-282-1
- en: '*by* ADAM DUVANDER'
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 亚当·杜万德'
- en: APRIL 2011, 400 PP., $44.95
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年4月，400页，$44.95
- en: AUGUST 2010, 376 PP., $34.95
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年8月，376页，$34.95
- en: ISBN 978-1-59327-283-8
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-283-8
- en: ISBN 978-1-59327-271-5
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-271-5
- en: THE TCP/IP GUIDE
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 指南
- en: THE MANGA GUIDE™ TO
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: THE MANGA GUIDE™ TO
- en: THE LINUX PROGRAMMING
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: THE LINUX 编程
- en: A Comprehensive, Illustrated Internet
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
  zh: 综合图解互联网
- en: STATISTICS
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学
- en: INTERFACE
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
  zh: 界面
- en: Protocols Reference
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: 协议参考
- en: '*by* SHIN TAKAHASHI *and* TREND-PRO'
  id: totrans-3678
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 斋藤隆治 *和* TREND-PRO'
- en: A Linux and UNIX® System
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 UNIX® 系统
- en: '*by* CHARLES M. KOZIEROK'
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 查尔斯·M·科齐奥罗克'
- en: CO., LTD
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: 株式会社
- en: Programming Handbook
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: 编程手册
- en: OCTOBER 2005, 1616 PP., $99.95, *hardcover*
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年10月，1616页，$99.95，*精装*
- en: NOVEMBER 2008, 232 PP., $19.95
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年11月，232页，$19.95
- en: '*by* MICHAEL KERRISK'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: '*by* 迈克尔·凯里斯科'
- en: ISBN 978-1-59327-047-6
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-047-6
- en: ISBN 978-1-59327-189-3
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-189-3
- en: OCTOBER 2010, 1552 PP., $99.95, *hardcover*
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年10月，1552页，$99.95，*精装*
- en: ISBN 978-1-59327-220-3
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-59327-220-3
- en: '**PHONE:**'
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
  zh: '**电话：**'
- en: '**EMAIL:**'
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件：**'
- en: 800.420.7240 OR
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 800.420.7240 或
- en: SALES@NOSTARCH.COM
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: SALES@NOSTARCH.COM
- en: 415.863.9900
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
  zh: 415.863.9900
- en: '**WEB:**'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: '**WEB：**'
- en: MONDAY THROUGH FRIDAY,
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: 周一至周五，
- en: 9 A.M. TO 5 P.M. (PST)
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
  zh: 上午9点至下午5点（太平洋标准时间）
- en: WWW.NOSTARCH.COM
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: WWW.NOSTARCH.COM
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The fonts used in *The Art of R Programming* are New Baskerville, Futura, The
    Sans Mono Condensed and Dogma. The book was typeset with LATEX 2 *ε*
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 《R 编程艺术》使用的字体是 New Baskerville、Futura、The Sans Mono Condensed 和 Dogma。本书使用 LATEX
    2 *ε* 排版。
- en: package nostarch by Boris Veytsman *(2008/06/06 v1.3 Typesetting books for No*
    *Starch Press).*
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
  zh: 包含诺斯塔奇出版社的 Boris Veytsman *(2008/06/06 v1.3 为 No* *Starch Press) 装订的书籍。*
- en: This book was printed and bound at Malloy Incorporated in Ann Arbor, Michigan.
    The paper is Glatfelter Spring Forge 60# Smooth, which is certi-fied by the Sustainable
    Forestry Initiative (SFI). The book uses a RepKover binding, which allows it to
    lie flat when open.
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 本书由密歇根州安阿伯的 Malloy Incorporated 印刷和装订。纸张是 Glatfelter Spring Forge 60# Smooth，由可持续林业倡议（SFI）认证。本书采用
    RepKover 胶装，使其打开时可以平铺。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 52](index-404_1.png)'
  id: totrans-3705
  prefs: []
  type: TYPE_IMG
  zh: '![Image 52](index-404_1.png)'
- en: '**T A M E Y O U R D A T A**'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理你的数据**'
- en: '**T**'
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
  zh: '**T**'
- en: '**T H E**'
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: '**T H E**'
- en: '**HE A**'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
  zh: '**HE A**'
- en: '**A R T O F R**'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: '**A R T O F R**'
- en: R is the world’s most popular language for developing
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
  zh: R 是世界上最受欢迎的语言，用于开发
- en: • Interface R with C/C++ and Python for increased
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 C/C++ 和 Python 将 R 与界面连接，以增加
- en: '**R**'
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: '**R**'
- en: 'statistical software: Archaeologists use it to track the'
  id: totrans-3714
  prefs: []
  type: TYPE_NORMAL
  zh: 统计软件：考古学家用它来追踪
- en: speed or functionality
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
- en: '**T O**'
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
- en: '**PROGR A MMING**'
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
- en: spread of ancient civilizations, drug companies use it
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
- en: • Find new packages for text analysis, image manipula-
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
- en: to discover which medications are safe and effective,
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
- en: tion, and thousands more
  id: totrans-3721
  prefs: []
  type: TYPE_NORMAL
- en: and actuaries use it to assess financial risks and keep
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
- en: '**A T O U R O F S T A T I S T I C A L S O F T W A R E D E S I G N**'
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
- en: '**F R P**'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
- en: markets running smoothly.
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
- en: • Squash annoying bugs with advanced debugging
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
- en: techniques
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of R Programming* takes you on a guided tour'
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
- en: of software development with R, from basic types
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re designing aircraft, forecasting the
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
- en: and data structures to advanced topics like closures,
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
- en: weather, or you just need to tame your data, *The Art of*
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
- en: '**N O R M A N M A T L O F F**'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
- en: recursion, and anonymous functions. No statistical
  id: totrans-3734
  prefs: []
  type: TYPE_NORMAL
- en: '*R Programming* is your guide to harnessing the power'
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3736
  prefs: []
  type: TYPE_NORMAL
- en: knowledge is required, and your programming skil s
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
- en: of statistical computing.
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
- en: can range from hobbyist to pro.
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
- en: '**A B O U T T H E A U T H O R**'
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, you’ll learn about functional and object-
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
- en: Norman Matloff is a professor of computer science
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming, running mathematical simulations,
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
- en: (and a former professor of statistics) at the University
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
- en: and rearranging complex data into simpler, more useful
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
- en: of California, Davis. His research interests include
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
- en: 'formats. You’ll also learn to:'
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
- en: paral el processing and statistical regression, and
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
- en: • Create artful graphs to visualize complex data sets
  id: totrans-3753
  prefs: []
  type: TYPE_NORMAL
- en: he is the author of several widely used web tutorials
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  id: totrans-3755
  prefs: []
  type: TYPE_NORMAL
- en: and functions
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
- en: on software development. He has written articles for
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
- en: the *New York Times*, the *Washington Post*, *Forbes* **M**
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
- en: • Write more efficient code using paral el R and
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
- en: '*Magazine*, and the *Los Angeles Times*, and he is the'
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
- en: co-author of *The Art of Debugging* (No Starch Press).
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
- en: '**NG**'
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
- en: '***TH E FI N EST I N G E E K E NTE RTAI N M E NT™***'
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
- en: www.nostarch.com
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
- en: '**MAT**'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
- en: '***“I LI E FLAT.”***'
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
- en: '**$39.95 *($41.95 CDN)***'
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
- en: '**S C S**'
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
- en: '*This book uses RepKover —a durable binding that won’t snap shut.*'
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
- en: '**T O H**'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
- en: '**M E**'
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
- en: '**LV**'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
- en: '**I P**'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
- en: '**ST U E**'
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
- en: '**I T I**'
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
- en: '**C E N**'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
- en: '**A R :**'
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
- en: '**L S**'
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
- en: '**SO /M**'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
- en: '**F A**'
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
- en: '**T T**'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
- en: '**W H**'
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
- en: '**A EM**'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
- en: '**RE ATICAL &**'
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  id: totrans-3794
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Copyright](index_split_000.html#p6)'
  id: totrans-3795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Brief Contents](index_split_000.html#p7)'
  id: totrans-3796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contents in Detail](index_split_000.html#p9)'
  id: totrans-3797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p19)'
  id: totrans-3798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p21)'
  id: totrans-3799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why Use R for Your Statistical Work?](index_split_000.html#p21)'
  id: totrans-3800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Whom Is This Book For?](index_split_000.html#p24)'
  id: totrans-3801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[My Own Background](index_split_000.html#p25)'
  id: totrans-3802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1: Getting Started](index_split_000.html#p27)'
  id: totrans-3803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.1 How to Run R](index_split_000.html#p27)'
  id: totrans-3804
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.2 A First R Session](index_split_000.html#p30)'
  id: totrans-3805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.3 Introduction to Functions](index_split_000.html#p33)'
  id: totrans-3806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.4 Preview of Some Important R Data Structures](index_split_000.html#p36)'
  id: totrans-3807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.5 Extended Example: Regression Analysis of Exam Grades](index_split_000.html#p42)'
  id: totrans-3808
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.5 扩展示例：考试成绩回归分析](index_split_000.html#p42)'
- en: '[1.6 Startup and Shutdown](index_split_000.html#p45)'
  id: totrans-3809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.6 启动和关闭](index_split_000.html#p45)'
- en: '[1.7 Getting Help](index_split_000.html#p46)'
  id: totrans-3810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.7 获取帮助](index_split_000.html#p46)'
- en: '[2: Vectors](index_split_000.html#p51)'
  id: totrans-3811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2: 向量](index_split_000.html#p51)'
- en: '[2.1 Scalars, Vectors, Arrays, and Matrices](index_split_000.html#p52)'
  id: totrans-3812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1 标量、向量、数组和矩阵](index_split_000.html#p52)'
- en: '[2.2 Declarations](index_split_000.html#p54)'
  id: totrans-3813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2 声明](index_split_000.html#p54)'
- en: '[2.3 Recycling](index_split_000.html#p55)'
  id: totrans-3814
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3 回收](index_split_000.html#p55)'
- en: '[2.4 Common Vector Operations](index_split_000.html#p56)'
  id: totrans-3815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.4 常见向量操作](index_split_000.html#p56)'
- en: '[2.5 Using all() and any()](index_split_001.html#p61)'
  id: totrans-3816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.5 使用all()和any()](index_split_001.html#p61)'
- en: '[2.6 Vectorized Operations](index_split_001.html#p65)'
  id: totrans-3817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.6 向量化操作](index_split_001.html#p65)'
- en: '[2.7 NA and NULL Values](index_split_001.html#p69)'
  id: totrans-3818
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.7 NA和NULL值](index_split_001.html#p69)'
- en: '[2.8 Filtering](index_split_001.html#p71)'
  id: totrans-3819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.8 过滤](index_split_001.html#p71)'
- en: '[2.9 A Vectorized if-then-else: The ifelse() Function](index_split_001.html#p74)'
  id: totrans-3820
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.9 向量化if-then-else：ifelse()函数](index_split_001.html#p74)'
- en: '[2.10 Testing Vector Equality](index_split_001.html#p80)'
  id: totrans-3821
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.10 测试向量等价性](index_split_001.html#p80)'
- en: '[2.11 Vector Element Names](index_split_001.html#p82)'
  id: totrans-3822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.11 向量元素名称](index_split_001.html#p82)'
- en: '[2.12 More on c()](index_split_001.html#p82)'
  id: totrans-3823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.12 关于c()的更多内容](index_split_001.html#p82)'
- en: '[3: Matrices and Arrays](index_split_001.html#p85)'
  id: totrans-3824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3: 矩阵和数组](index_split_001.html#p85)'
- en: '[3.1 Creating Matrices](index_split_001.html#p85)'
  id: totrans-3825
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.1 创建矩阵](index_split_001.html#p85)'
- en: '[3.2 General Matrix Operations](index_split_001.html#p87)'
  id: totrans-3826
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2 矩阵通用操作](index_split_001.html#p87)'
- en: '[3.3 Applying Functions to Matrix Rows and Columns](index_split_001.html#p96)'
  id: totrans-3827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.3 将函数应用于矩阵行和列](index_split_001.html#p96)'
- en: '[3.4 Adding and Deleting Matrix Rows and Columns](index_split_001.html#p99)'
  id: totrans-3828
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.4 添加和删除矩阵行和列](index_split_001.html#p99)'
- en: '[3.5 More on the Vector/Matrix Distinction](index_split_001.html#p104)'
  id: totrans-3829
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.5 关于向量/矩阵区别的更多内容](index_split_001.html#p104)'
- en: '[3.6 Avoiding Unintended Dimension Reduction](index_split_001.html#p106)'
  id: totrans-3830
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.6 避免意外的维度缩减](index_split_001.html#p106)'
- en: '[3.7 Naming Matrix Rows and Columns](index_split_001.html#p107)'
  id: totrans-3831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.7 命名矩阵行和列](index_split_001.html#p107)'
- en: '[3.8 Higher-Dimensional Arrays](index_split_001.html#p108)'
  id: totrans-3832
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.8 高维数组](index_split_001.html#p108)'
- en: '[4: Lists](index_split_001.html#p111)'
  id: totrans-3833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4: 列表](index_split_001.html#p111)'
- en: '[4.1 Creating Lists](index_split_001.html#p111)'
  id: totrans-3834
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.1 创建列表](index_split_001.html#p111)'
- en: '[4.2 General List Operations](index_split_001.html#p113)'
  id: totrans-3835
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2 列表通用操作](index_split_001.html#p113)'
- en: '[4.3 Accessing List Components and Values](index_split_002.html#p119)'
  id: totrans-3836
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3 访问列表组件和值](index_split_002.html#p119)'
- en: '[4.4 Applying Functions to Lists](index_split_002.html#p121)'
  id: totrans-3837
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.4 将函数应用于列表](index_split_002.html#p121)'
- en: '[4.5 Recursive Lists](index_split_002.html#p125)'
  id: totrans-3838
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.5 递归列表](index_split_002.html#p125)'
- en: '[5: Data Frames](index_split_002.html#p127)'
  id: totrans-3839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5: 数据框](index_split_002.html#p127)'
- en: '[5.1 Creating Data Frames](index_split_002.html#p128)'
  id: totrans-3840
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.1 创建数据框](index_split_002.html#p128)'
- en: '[5.2 Other Matrix-Like Operations](index_split_002.html#p130)'
  id: totrans-3841
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.2 其他矩阵类操作](index_split_002.html#p130)'
- en: '[5.3 Merging Data Frames](index_split_002.html#p135)'
  id: totrans-3842
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.3 合并数据框](index_split_002.html#p135)'
- en: '[5.4 Applying Functions to Data Frames](index_split_002.html#p138)'
  id: totrans-3843
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.4 将函数应用于数据框](index_split_002.html#p138)'
- en: '[6: Factors and Tables](index_split_002.html#p147)'
  id: totrans-3844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6: 因子和表格](index_split_002.html#p147)'
- en: '[6.1 Factors and Levels](index_split_002.html#p147)'
  id: totrans-3845
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.1 因子和水平](index_split_002.html#p147)'
- en: '[6.2 Common Functions Used with Factors](index_split_002.html#p149)'
  id: totrans-3846
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.2 因子常用函数](index_split_002.html#p149)'
- en: '[6.3 Working with Tables](index_split_002.html#p153)'
  id: totrans-3847
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.3 与表格一起工作](index_split_002.html#p153)'
- en: '[6.4 Other Factor- and Table-Related Functions](index_split_002.html#p162)'
  id: totrans-3848
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.4 其他因子和表格相关函数](index_split_002.html#p162)'
- en: '[7: R Programming Structures](index_split_003.html#p165)'
  id: totrans-3849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7: R编程结构](index_split_003.html#p165)'
- en: '[7.1 Control Statements](index_split_003.html#p165)'
  id: totrans-3850
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.1 控制语句](index_split_003.html#p165)'
- en: '[7.2 Arithmetic and Boolean Operators and Values](index_split_003.html#p171)'
  id: totrans-3851
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2 算术和布尔运算符及值](index_split_003.html#p171)'
- en: '[7.3 Default Values for Arguments](index_split_003.html#p172)'
  id: totrans-3852
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.3 参数的默认值](index_split_003.html#p172)'
- en: '[7.4 Return Values](index_split_003.html#p173)'
  id: totrans-3853
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.4 返回值](index_split_003.html#p173)'
- en: '[7.5 Functions Are Objects](index_split_003.html#p175)'
  id: totrans-3854
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.5 函数是对象](index_split_003.html#p175)'
- en: '[7.6 Environment and Scope Issues](index_split_003.html#p177)'
  id: totrans-3855
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.6 环境和作用域问题](index_split_003.html#p177)'
- en: '[7.7 No Pointers in R](index_split_003.html#p185)'
  id: totrans-3856
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.7 R中没有指针](index_split_003.html#p185)'
- en: '[7.8 Writing Upstairs](index_split_003.html#p187)'
  id: totrans-3857
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.8 向上写入](index_split_003.html#p187)'
- en: '[7.9 Recursion](index_split_003.html#p202)'
  id: totrans-3858
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.9 递归](index_split_003.html#p202)'
- en: '[7.10 Replacement Functions](index_split_003.html#p208)'
  id: totrans-3859
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.10 替换函数](index_split_003.html#p208)'
- en: '[7.11 Tools for Composing Function Code](index_split_004.html#p212)'
  id: totrans-3860
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.11 编写函数代码的工具](index_split_004.html#p212)'
- en: '[7.12 Writing Your Own Binary Operations](index_split_004.html#p213)'
  id: totrans-3861
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.12 编写自己的二进制操作](index_split_004.html#p213)'
- en: '[7.13 Anonymous Functions](index_split_004.html#p213)'
  id: totrans-3862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.13 匿名函数](index_split_004.html#p213)'
- en: '[8: Doing Math and Simulations in R](index_split_004.html#p215)'
  id: totrans-3863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8: 在 R 中进行数学和模拟](index_split_004.html#p215)'
- en: '[8.1 Math Functions](index_split_004.html#p215)'
  id: totrans-3864
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.1 数学函数](index_split_004.html#p215)'
- en: '[8.2 Functions for Statistical Distributions](index_split_004.html#p219)'
  id: totrans-3865
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.2 统计分布函数](index_split_004.html#p219)'
- en: '[8.3 Sorting](index_split_004.html#p220)'
  id: totrans-3866
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.3 排序](index_split_004.html#p220)'
- en: '[8.4 Linear Algebra Operations on Vectors and Matrices](index_split_004.html#p222)'
  id: totrans-3867
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.4 向量和矩阵的线性代数运算](index_split_004.html#p222)'
- en: '[8.5 Set Operations](index_split_004.html#p228)'
  id: totrans-3868
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.5 集合运算](index_split_004.html#p228)'
- en: '[8.6 Simulation Programming in R](index_split_004.html#p230)'
  id: totrans-3869
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.6 R 中的模拟编程](index_split_004.html#p230)'
- en: '[9: Object-Oriented Programming](index_split_004.html#p233)'
  id: totrans-3870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9: 面向对象编程](index_split_004.html#p233)'
- en: '[9.1 S3 Classes](index_split_004.html#p234)'
  id: totrans-3871
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.1 S3 类](index_split_004.html#p234)'
- en: '[9.2 S4 Classes](index_split_004.html#p248)'
  id: totrans-3872
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2 S4 类](index_split_004.html#p248)'
- en: '[9.3 S3 Versus S4](index_split_004.html#p252)'
  id: totrans-3873
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3 S3 与 S4 的比较](index_split_004.html#p252)'
- en: '[9.4 Managing Your Objects](index_split_004.html#p252)'
  id: totrans-3874
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.4 管理你的对象](index_split_004.html#p252)'
- en: '[10: Input/Output](index_split_004.html#p257)'
  id: totrans-3875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10: 输入/输出](index_split_004.html#p257)'
- en: '[10.1 Accessing the Keyboard and Monitor](index_split_004.html#p258)'
  id: totrans-3876
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.1 访问键盘和监视器](index_split_004.html#p258)'
- en: '[10.2 Reading and Writing Files](index_split_005.html#p261)'
  id: totrans-3877
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.2 读取和写入文件](index_split_005.html#p261)'
- en: '[10.3 Accessing the Internet](index_split_005.html#p272)'
  id: totrans-3878
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.3 访问互联网](index_split_005.html#p272)'
- en: '[11: String Manipulation](index_split_005.html#p277)'
  id: totrans-3879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11: 字符串操作](index_split_005.html#p277)'
- en: '[11.1 An Overview of String-Manipulation Functions](index_split_005.html#p277)'
  id: totrans-3880
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.1 字符串操作函数概述](index_split_005.html#p277)'
- en: '[11.2 Regular Expressions](index_split_005.html#p280)'
  id: totrans-3881
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.2 正则表达式](index_split_005.html#p280)'
- en: '[11.3 Use of String Utilities in the edtdbg Debugging Tool](index_split_005.html#p283)'
  id: totrans-3882
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.3 edtdbg 调试工具中的字符串实用工具的使用](index_split_005.html#p283)'
- en: '[12: Graphics](index_split_005.html#p287)'
  id: totrans-3883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12: 图形](index_split_005.html#p287)'
- en: '[12.1 Creating Graphs](index_split_005.html#p287)'
  id: totrans-3884
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.1 创建图表](index_split_005.html#p287)'
- en: '[12.2 Customizing Graphs](index_split_005.html#p298)'
  id: totrans-3885
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.2 自定义图表](index_split_005.html#p298)'
- en: '[12.3 Saving Graphs to Files](index_split_005.html#p306)'
  id: totrans-3886
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.3 将图表保存到文件](index_split_005.html#p306)'
- en: '[12.4 Creating Three-Dimensional Plots](index_split_005.html#p308)'
  id: totrans-3887
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.4 创建三维图表](index_split_005.html#p308)'
- en: '[13: Debugging](index_split_005.html#p311)'
  id: totrans-3888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13: 调试](index_split_005.html#p311)'
- en: '[13.1 Fundamental Principles of Debugging](index_split_005.html#p311)'
  id: totrans-3889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.1 调试的基本原则](index_split_005.html#p311)'
- en: '[13.2 Why Use a Debugging Tool?](index_split_005.html#p313)'
  id: totrans-3890
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.2 为什么使用调试工具？](index_split_005.html#p313)'
- en: '[13.3 Using R Debugging Facilities](index_split_005.html#p314)'
  id: totrans-3891
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.3 使用 R 调试设施](index_split_005.html#p314)'
- en: '[13.4 Moving Up in the World: More Convenient DebuggingTools](index_split_006.html#p326)'
  id: totrans-3892
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.4 向上走：更方便的调试工具](index_split_006.html#p326)'
- en: '[13.5 Ensuring Consistency in Debugging Simulation Code](index_split_006.html#p328)'
  id: totrans-3893
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.5 确保调试模拟代码的一致性](index_split_006.html#p328)'
- en: '[13.6 Syntax and Runtime Errors](index_split_006.html#p329)'
  id: totrans-3894
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.6 语法和运行时错误](index_split_006.html#p329)'
- en: '[13.7 Running GDB on R Itself](index_split_006.html#p329)'
  id: totrans-3895
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.7 在 R 本身上运行 GDB](index_split_006.html#p329)'
- en: '[14: Performance Enhancement: Speed and Memory](index_split_006.html#p331)'
  id: totrans-3896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14: 性能提升：速度和内存](index_split_006.html#p331)'
- en: '[14.1 Writing Fast R Code](index_split_006.html#p332)'
  id: totrans-3897
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.1 编写快速的 R 代码](index_split_006.html#p332)'
- en: '[14.2 The Dreaded for Loop](index_split_006.html#p332)'
  id: totrans-3898
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.2 可怕的 for 循环](index_split_006.html#p332)'
- en: '[14.3 Functional Programming and Memory Issues](index_split_006.html#p340)'
  id: totrans-3899
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3 函数式编程与内存问题](index_split_006.html#p340)'
- en: '[14.4 Using Rprof() to Find Slow Spots in Your Code](index_split_006.html#p342)'
  id: totrans-3900
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.4 使用 Rprof() 查找代码中的慢点](index_split_006.html#p342)'
- en: '[14.5 Byte Code Compilation](index_split_006.html#p346)'
  id: totrans-3901
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.5 字节码编译](index_split_006.html#p346)'
- en: '[14.6 Oh No, the Data Doesn’t Fit into Memory!](index_split_006.html#p346)'
  id: totrans-3902
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.6 哎呀，数据放不进内存！](index_split_006.html#p346)'
- en: '[15: Interfacing R to Other Languages](index_split_006.html#p349)'
  id: totrans-3903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15: 将 R 与其他语言接口](index_split_006.html#p349)'
- en: '[15.1 Writing C/C++ Functions to Be Called from R](index_split_006.html#p349)'
  id: totrans-3904
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15.1 将 C/C++ 函数编写为 R 可调用的函数](index_split_006.html#p349)'
- en: '[15.2 Using R from Python](index_split_006.html#p356)'
  id: totrans-3905
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15.2 从 Python 使用 R](index_split_006.html#p356)'
- en: '[16: Parallel R](index_split_006.html#p359)'
  id: totrans-3906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16: 并行 R](index_split_006.html#p359)'
- en: '[16.1 The Mutual Outlinks Problem](index_split_006.html#p359)'
  id: totrans-3907
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.1 互链问题](index_split_006.html#p359)'
- en: '[16.2 Introducing the snow Package](index_split_006.html#p360)'
  id: totrans-3908
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.2 介绍 snow 包](index_split_006.html#p360)'
- en: '[16.3 Resorting to C](index_split_006.html#p366)'
  id: totrans-3909
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.3 转向 C 语言](index_split_006.html#p366)'
- en: '[16.4 General Performance Considerations](index_split_006.html#p371)'
  id: totrans-3910
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.4 一般性能考虑](index_split_006.html#p371)'
- en: '[16.5 Debugging Parallel R Code](index_split_006.html#p377)'
  id: totrans-3911
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16.5 调试并行 R 代码](index_split_006.html#p377)'
- en: '[Appendix A: Installing R](index_split_006.html#p379)'
  id: totrans-3912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录 A：安装 R](index_split_006.html#p379)'
- en: '[A.1 Downloading R from CRAN](index_split_006.html#p379)'
  id: totrans-3913
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.1 从 CRAN 下载 R](index_split_006.html#p379)'
- en: '[A.2 Installing from a Linux Package Manager](index_split_006.html#p379)'
  id: totrans-3914
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从 Linux 软件包管理器安装](index_split_006.html#p379)'
- en: '[A.3 Installing from Source](index_split_006.html#p380)'
  id: totrans-3915
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.3 从源代码安装](index_split_006.html#p380)'
- en: '[Appendix B: Installing and Using Packages](index_split_006.html#p381)'
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录 B：安装和使用软件包](index_split_006.html#p381)'
- en: '[B.1 Package Basics](index_split_006.html#p381)'
  id: totrans-3917
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.1 软件包基础](index_split_006.html#p381)'
- en: '[B.2 Loading a Package from Your Hard Drive](index_split_006.html#p382)'
  id: totrans-3918
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.2 从您的硬盘加载软件包](index_split_006.html#p382)'
- en: '[B.3 Downloading a Package from the Web](index_split_006.html#p382)'
  id: totrans-3919
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从 Web 下载软件包](index_split_006.html#p382)'
- en: '[B.4 Listing the Functions in a Package](index_split_006.html#p384)'
  id: totrans-3920
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B.4 列出软件包中的函数](index_split_006.html#p384)'
- en: '[Index](index_split_006.html#p385)'
  id: totrans-3921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引](index_split_006.html#p385)'
- en: '[UPDATES](index_split_006.html#p401)'
  id: totrans-3922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更新](index_split_006.html#p401)'
