<html><head></head><body><div class="appendix" title="Appendix&#xA0;B.&#xA0;IDC/SDK Cross-Reference"><div class="titlepage"><div><div><h1 class="title"><a id="idc_solidus_sdk_cross-reference"/>Appendix B. IDC/SDK Cross-Reference</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id27"/><div class="mediaobject"><a id="I_mediaobject_d1e46334"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>The following table serves to map IDC scripting functions to their SDK implementation. The intent of this table is to help programmers familiar with IDC understand how similar actions are carried out using SDK functions. The need for such a table arises for two reasons: (1) IDC function names do not map cleanly to their SDK counterparts, and (2) in some cases a single IDC function is composed of several SDK actions. This table also exposes some of the ways in which the SDK utilizes <span class="emphasis"><em>netnodes</em></span> as a means of storing information into an IDA database. Specifically, the manner in which netnodes are utilized to implement IDC arrays becomes evident when we review the IDC array-manipulation functions.<a class="indexterm" id="IDX-APP-B-0097"/><a class="indexterm" id="IDX-APP-B-0098"/><a class="indexterm" id="IDX-APP-B-0099"/></p><p>The table attempts to keep SDK descriptions brief. In doing so, error-checking code has been omitted, along with many C++ syntactic elements (notably braces, <code class="literal">{}</code>). Many of the SDK functions return results by copying data into caller-supplied buffers. These buffers have been left undeclared for brevity. For consistency, such buffers have been named <code class="literal">buf</code>, and their size, in most cases, is assumed to be 1,024 bytes, which is the value of the IDA 6.1 SDK’s <code class="literal">MAXSTR</code> constant. Finally, variable declarations have been used only where their use adds to an understanding of the example. Undeclared variables are most frequently the IDC function input parameters as named in the corresponding reference pages within IDA’s built-in help system.<a class="indexterm" id="IDX-APP-B-0100"/><a class="indexterm" id="IDX-APP-B-0101"/><a class="indexterm" id="IDX-APP-B-0102"/></p><p>Please keep in mind that IDC has evolved substantially over the years. In its earliest versions, IDC’s primary purpose was to expose some of the more commonly used functionality of the SDK to script programmers. As features have been added to the language, new IDC functions have been added whose sole purpose is to support advanced IDC features, such as objects and exceptions. All IDC functions are ultimately supported by SDK functions, and as a result, in something of a role reversal, new IDC features demanded the addition of new SDK functionality. The latest versions of the SDK now include a number of functions designed to provide the low-level implementation of the IDC object model. In most cases, it is unlikely that users will need to make use of these functions from within compiled modules. One instance where you may find the object manipulation functions useful is when you find yourself developing plug-ins that will extend the IDC language by adding new functions.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>IDC Function</p></th><th style="text-align: left" valign="bottom"><p>SDK Implementation</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">AddAutoStkPnt2</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_auto_stkpnt2(get_func(func_ea), ea, delta);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddBpt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro for AddBptEx(ea, 0, BPT_SOFT);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddBptEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_bpt(ea, size, bpttype);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddCodeXref</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_cref(From, To, flowtype);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddConstEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_const(enum_id, name, value, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddEntryPoint</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_entry(ordinal, ea, name, makecode);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddEnum</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_enum(idx, name, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddHotkey</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_idc_hotkey(hotkey, idcfunc);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddSeg</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46473"/><pre class="programlisting">segment_t s;
s.startEA = startea;
s.endEA = endEA;
s.sel = setup_selector(base);
s.bitness = use32;
s.align = align;
s.comb = comb;
add_segm_ex(&amp;s, NULL, NULL, ADDSEG_NOSREG);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddSourceFile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_sourcefile(ea1, ea2, filename);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddStrucEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_struc(index, name, is_union);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AddStrucMember</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46502"/><pre class="programlisting">typeinfo_t mt;
//calls an internal function to initialize mt using typeid
add_struc_member(get_struc(id), name, offset, flag, &amp;mt, nbytes);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AltOp</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46512"/><pre class="programlisting">get_forced_operand(ea, n, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Analysis</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro for SetCharPrm(INF_AUTO, x)</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AnalyzeArea</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">analyze_area(sEA, eEA);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Appcall</code><a class="indexterm" id="IDX-APP-B-0103"/></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46545"/><pre class="programlisting">//nargs is the number of arguments following type
//args is idc_value_t[] of args following type
idc_value_t result;
if (type.vtype == VT_LONG &amp;&amp; type.num == 0)
   appcall(ea, 0, NULL, NULL, nargs, args, &amp;result);
else
   idc_value_t tval, fields;
   internal_parse_type(&amp;type, &amp;tval, &amp;fields);
   appcall(ea, 0, &amp;tval, &amp;fields, nargs, args, &amp;result);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AppendFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">append_func_tail(get_func(funcea), ea1, ea2);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ApplySig</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">plan_to_apply_idasgn(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskAddr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46573"/><pre class="programlisting">ea_t addr = defval;
askaddr(&amp;addr, "%s", prompt):
return addr;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskFile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(askfile_c(forsave, mask, "%s", prompt));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskIdent</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(askident(defval, "%s", prompt));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskLong</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46601"/><pre class="programlisting">sval_t val = defval;
asklong(&amp;val, "%s", prompt):
return val;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskSeg</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46612"/><pre class="programlisting">sel_t seg = defval;
askseg(&amp;sel, "%s", prompt):
return val;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskSelector</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return ask_selector(sel);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskStr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(askstr(HIST_CMT, defval, "%s", prompt));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AskYN</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return askyn_c(defval, "%s", prompt);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AttachProcess</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return attach_process(pid, event_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AutoMark</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see AutoMark2</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AutoMark2</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">auto_mark_range(start, end, queuetype);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AutoShow</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">AutoUnmark</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46685"/><pre class="programlisting">//*** undocumented function
autoUnmark(start, end, type);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Batch</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">::batch = batch;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BeginEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BeginTypeUpdating</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return begin_type_updating(utp)</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Byte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_full_byte(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CanExceptionContinue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;can_cont;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ChangeConfig</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">internal_change_config(line)</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CheckBpt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">check_bpt(ea)</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Checkpoint</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//*** undocumented function</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ChooseFunction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return choose_func(ea, −1)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CleanupAppcall</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return cleanup_appcall(0) == 0;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CmtIndent</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CommentEx</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46795"/><pre class="programlisting">get_cmt(ea, repeatable, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Comments</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Compile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro for CompileEx(file, 1);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CompileEx</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46824"/><pre class="programlisting">if (isfile)
   CompileEx(input, CPL_DEL_MACROS | CPL_USE_LABELS,
            errbuf, sizeof(errbuf));
else
   CompileLineEx(input, errbuf, sizeof(errbuf));</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CreateArray</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46834"/><pre class="programlisting">qsnprintf(buf, sizeof(buf), "$ idc_array %s", name);
netnode n(buf, 0, true);
return (nodeidx_t)n;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgByte</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46844"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   uint8_t b;
   dbg-&gt;read_memory(ea, &amp;b, sizeof(b));
   return b;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgDword</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46854"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   uint32_t d;
   dbg-&gt;read_memory(ea, &amp;d, sizeof(d));
   return d;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgQword</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46864"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   uint64_t q;
   dbg-&gt;read_memory(ea, &amp;q, sizeof(q));
   return q;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgRead</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46874"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   uint8_t *buf = (uint8_t*) qalloc(len);
   dbg-&gt;read_memory(ea, buf, len);
   return buf;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgWord</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46884"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   uint16_t w;
   dbg-&gt;read_memory(ea, &amp;w, sizeof(w));
   return w;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DbgWrite</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46894"/><pre class="programlisting">if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
   dbg-&gt;write_memory(ea, data, length of data);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DecodeInstruction</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e46904"/><pre class="programlisting">ua_ana0(ea);
return cmd;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DefineException</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return define_exception(code, name, desc, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelArrayElement</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).supdel(idx, tag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelBpt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_bpt(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelCodeXref</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_cref(From, To, undef);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelConstEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_const(enum_id, value, serial, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelEnum</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_enum(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelExtLnA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(ea).supdel(n + 1000);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelExtLnB</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(ea).supdel(n + 2000);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelFixup</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_fixup(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelFunction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_func(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelHashElement</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47005"/><pre class="programlisting">netnode n(id);
n.hashdel(idx);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelHiddenArea</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_hidden_area (ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelHotkey</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_idc_hotkey(hotkey);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelLineNumber</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_source_linnum(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelSeg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_segm(ea, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelSelector</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_selector(sel);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelSourceFile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_sourcefile(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelStkPnt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_stkpnt(get_func(func_ea), ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelStruc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_struc(get_struc(id));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelStrucMember</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_struc_member(get_struc(id), offset);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DelXML</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_xml(path);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DeleteAll</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47106"/><pre class="programlisting">while (get_segm_qty ())
   del_segm(getnseg (0), 0);
FlagsDisable(0, inf.ominEA);
FlagsDisable(inf.omaxEA, 0xFFFFFFFF);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DeleteArray</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).kill();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Demangle</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47126"/><pre class="programlisting">demangle_name(buf, sizeof(buf), name, disable_mask);
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DetachProcess</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">detach_process();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Dfirst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_dref_from(From);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DfirstB</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_dref_to(To);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Dnext</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_dref_from(From, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DnextB</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_dref_to(To, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Dword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_full_long(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">EnableBpt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">enable_bpt(ea, enable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">EnableTracing</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47199"/><pre class="programlisting">if (trace_level == 0)
   return enable_step_trace(enable);
else if (trace_level == 1)
   return enable_insn_trace(enable);
else if (trace_level == 2)
   return enable_func_trace(enable);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">EndTypeUpdating</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">end_type_updating(utp);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Eval</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">idc_value_t v;</code></p>
<p><code class="literal">calcexpr(-1, expr, &amp;v, errbuf, sizeof(errbuf));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Exec</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">call_system(command);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ExecIDC</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47241"/><pre class="programlisting">char fname[16];
uint32_t fnum = globalCount++; //mutex around globalCount
qsnprintf(fname, sizeof(fname), "___idcexec%d", fnum);
uint32_t len;
len = qsnprintf(NULL, 0, "static %s() {\n%s\n; }", fname, input);
char *func = (char*)qalloc(len);
qsnprintf(func, len, "static %s() {\n%s\n; }", fname, input);
ExecuteLine(func, fname, NULL, 0, NULL, NULL, err, sizeof(err));
globalCount--; //mutex around globalCount
qfree(func);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Exit</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qexit(code);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ExtLinA</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47260"/><pre class="programlisting">netnode n(ea).supset(n + 1000, line);
setFlbits(ea, FF_LINE);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ExtLinB</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47270"/><pre class="programlisting">netnode n(ea).supset(n + 2000, line);
setFlbits(ea, FF_LINE);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Fatal</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">error(format, ...);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindBinary</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47289"/><pre class="programlisting">ea_t endea = (flag &amp; SEARCH_DOWN) ? inf.maxEA : inf.minEA;
return find_binary(ea, endea, str, getDefaultRadix(), flag);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindCode</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_code(ea, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindData</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_data(ea, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindExplored</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_defined(ea, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindFuncEnd</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47326"/><pre class="programlisting">func_t f;
find_func_bounds(ea, &amp;f, FIND_FUNC_DEFINE);
return f-&gt;endEA;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindImmediate</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_imm(ea, flag, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindSelector</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_selector(val);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindText</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_text(ea, y, x, str, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindUnexplored</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_unknown(ea, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FindVoid</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_void(ea, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FirstFuncFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">get_func(funcea)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">FirstSeg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return getnseg (0)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ForgetException</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47400"/><pre class="programlisting">excvec_t *ev = retrieve_exceptions();
for (excvec_t::iterator i = ev-&gt;begin(); i != ev-&gt;end(); i++)
   if ((*i).code == code)
      ev-&gt;erase(i);
      return store_exceptions();
return 0;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GenCallGdl</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">gen_simple_call_chart(outfile, "Building graph", title, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GenFuncGdl</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47419"/><pre class="programlisting">func_t *f = get_func(ea1);
gen_flow_graph(outfile, title, f, ea1, ea2, flags);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GenerateFile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">gen_file(type, file_handle, ea1, ea2, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetArrayElement</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47439"/><pre class="programlisting">netnode n(id);
if (tag == 'A') return n.altval(idx);
else if (tag == 'S')
   n.supstr(idx, buf, sizeof(buf));
   return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetArrayId</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47449"/><pre class="programlisting">qsnprintf(buf, sizeof(buf), "$ idc_array %s", name);
netnode n(buf);
return (nodeidx_t)n;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetBmaskCmt</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47459"/><pre class="programlisting">get_bmask_cmt(enum_id, bmask, repeatable, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetBmaskName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47469"/><pre class="programlisting">get_bmask_name(enum_id, bmask, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetBptAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47478"/><pre class="programlisting">bpt_t bpt;
if (get_bpt(ea, &amp;bpt) == 0) return −1;
if (bpattr == BPTATTR_EA) return bpt.ea;
else if (bpattr == BPTATTR_SIZE) return bpt.size;
else if (bpattr ==BPTATTR_TYPE) return bpt.type;
else if (bpattr == BPTATTR_COUNT) return bpt.pass_count;
else if (bpattr == BPTATTR_FLAGS) return bpt.flags;
else if (bpattr == BPTATTR_COND) return qstrdup(bpt.condition);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetBptEA</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47488"/><pre class="programlisting">bpt_t bpt;
return getn_bpt(n, &amp;bpt) ? bpt.ea : −1;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetBptQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_bpt_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCharPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47507"/><pre class="programlisting">if (offset &lt;= 191)
   return *(unsigned char*)(offset + (char*)&amp;inf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetColor</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47517"/><pre class="programlisting">if (what == CIC_ITEM)
   return get_color(ea);
else if (what == CIC_FUNC)
   return get_func(ea)-&gt;color;
else if (what == CIC_SEGM)
   return get_seg(ea)-&gt;color;
return 0xFFFFFFFF;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstBmask</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_const_bmask(const_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstByName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_const_by_name(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstCmt</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47546"/><pre class="programlisting">get_const_cmt(const_id, repeatable, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstEnum</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_const_enum(const_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_const(enum_id, value, serial, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47574"/><pre class="programlisting">get_const_name(const_id, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetConstValue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_const_value(const_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCurrentLine</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47592"/><pre class="programlisting">tag_remove(get_curline(), buf, sizeof(buf))
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCurrentThreadId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_current_thread();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCustomDataFormat</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_custom_data_format(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCustomDataType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return find_custom_data_type(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetDebuggerEvent</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return wait_for_next_event(wfne, timeout);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetDisasm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47637"/><pre class="programlisting">generate_disasm_line(ea, buf, sizeof(buf));
tag_remove(buf, buf, 0);
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEntryName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47647"/><pre class="programlisting">get_entry_name(ordinal, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEntryOrdinal</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_entry_ordinal(index);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEntryPoint</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_entry(ordinal);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEntryPointQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_entry_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnum</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_enum(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumCmt</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47693"/><pre class="programlisting">get_enum_cmt(enum_id, repeatable, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumFlag</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_enum_flag(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_enum_idx(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47720"/><pre class="programlisting">get_enum_name(enum_id, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_enum_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_enum_size(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEnumWidth</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47749"/><pre class="programlisting">if (enum_id &gt; 0xff000000)
   netnode n(enum_id);
   return (n.altval(0xfffffffb) &gt;&gt; 3) &amp; 7;
else
   return 0;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventBptHardwareEa</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;bpt.hea;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventEa</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;ea;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventExceptionCode</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;exc.code;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventExceptionEa</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;exc.ea;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventExceptionInfo</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_debug_event()-&gt;exc.info);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventExitCode</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;exit_code;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;eid;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventInfo</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_debug_event()-&gt;info);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventModuleBase</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;modinfo.base;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventModuleName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_debug_event()-&gt;modinfo.name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventModuleSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;modinfo.size;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventPid</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;pid;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetEventTid</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;tid;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetExceptionCode</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47876"/><pre class="programlisting">excvec_t *ev = retrieve_exceptions();
return idx &lt; ev-&gt;size() ? (*ev)[idx].code : 0;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetExceptionFlags</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47885"/><pre class="programlisting">excvec_t *ev = retrieve_exceptions();
for (excvec_t::iterator i = ev-&gt;begin(); i != ev-&gt;end(); i++)
   if ((*i).code == code)
      return (*i).flags;
return −1;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetExceptionName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47895"/><pre class="programlisting">excvec_t *ev = retrieve_exceptions();
for (excvec_t::iterator i = ev-&gt;begin(); i != ev-&gt;end(); i++)
   if ((*i).code == code)
      return new qstring((*i).name);
return NULL;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetExceptionQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return retrieve_exceptions()-&gt;size();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFchunkAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47914"/><pre class="programlisting">func_t *f = get_func(ea);
return internal_get_attr(f, attr);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFchunkReferer</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47924"/><pre class="programlisting">func_t *f = get_fchunk(ea);
func_parent_iterator_t fpi(f);
return n &lt; f-&gt;refqty ? f-&gt;referers[n] : BADADDR;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstBmask</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_bmask(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstConst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_const(enum_id, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstHashKey</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47953"/><pre class="programlisting">netnode n(id).hash1st(buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstIndex</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return netnode n(id).sup1st(tag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstMember</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_first_offset(get_struc(id));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstModule</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e47981"/><pre class="programlisting">module_info_t modinfo;
get_first_module(&amp;modinfo);
return modinfo.base;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFirstStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_struc_idx();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFixupTgtDispl</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48000"/><pre class="programlisting">fixup_data_t fd;
get_fixup(ea, &amp;fd);
return fd.displacement;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFixupTgtOff</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48010"/><pre class="programlisting">fixup_data_t fd;
get_fixup(ea, &amp;fd);
return fd.off</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFixupTgtSel</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48019"/><pre class="programlisting">fixup_data_t fd;
get_fixup(ea, &amp;fd);
return fd.sel;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFixupTgtType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48028"/><pre class="programlisting">fixup_data_t fd;
get_fixup(ea, &amp;fd);
return fd.type;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFlags</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">getFlags(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFpNum</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48047"/><pre class="programlisting">//*** undocumented function
char buf[16];
union {float f; double d; long double ld} val;
get_many_bytes(ea, buf, len &gt; 16 ? 16 : len);
ph.realcvt(buf, &amp;val, (len &gt;&gt; 1) - 1);
return val;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFrame</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFrameArgsSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFrameLvarSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFrameRegsSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFrameSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_frame_size(get_func(ea));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFuncOffset</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48103"/><pre class="programlisting">int flags =  GNCN_REQFUNC | GNCN_NOCOLOR;
get_nice_colored_name(ea, buf, sizeof(buf),flags);
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFunctionAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48113"/><pre class="programlisting">func_t *f = get_func(ea);
return internal_get_attr(f, attr);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFunctionCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_func_cmt(get_func(ea), repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFunctionFlags</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetFunctionName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48141"/><pre class="programlisting">get_func_name(ea, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetHashLong</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).hashval_long(idx);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetHashString</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48161"/><pre class="programlisting">netnode n(id).hashval(idx, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetIdaDirectory</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48171"/><pre class="programlisting">qstrncpy(buf, idadir(NULL), sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetIdbPath</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48180"/><pre class="programlisting">qstrncpy(buf, database_idb, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetInputFile</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48189"/><pre class="programlisting">get_root_filename(buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetInputFilePath</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48198"/><pre class="programlisting">RootNode.valstr(buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetInputMD5</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48207"/><pre class="programlisting">uint8_t md5bin[16];
char out[1024];
char *outp = out;
int len = sizeof(out);
out[0] = 0;
RootNode.supval(RIDX_MD5, md5bin, sizeof(md5bin));
for (int j = 0; j &lt; sizeof(md5bin); j++) {
   int nbytes = qsnprintf(out, len, "%02X", md5bin[j]);
   outp += nbytes;
   len -= nbytes;
}
return qstrdup(out);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastBmask</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_last_bmask(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastConst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_last_const(enum_id, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastHashKey</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48235"/><pre class="programlisting">netnode n(id).hashlast(buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastIndex</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return netnode n(id).suplast(tag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastMember</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_last_offset(get_struc(id));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLastStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_last_struc_idx();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLineNumber</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_source_linnum(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLocalType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48282"/><pre class="programlisting">const type_t *type;
const p_list *fields;
get_numbered_type(idati, ordinal, &amp;type, &amp;fields,
                  NULL, NULL, NULL);
char *name = get_numbered_type_name(idati, ordinal);
qstring res;
print_type_to_qstring(&amp;res, 0, 2, 40, flags, idati, type,
                      name, NULL, fields, NULL);
return qstrdup(res.c_str());</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLocalTypeName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_numbered_type_name(idati, ordinal));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetLongPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48301"/><pre class="programlisting">if (offset &lt;= 188)
   return *(int*)(offset + (char*)&amp;inf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetManualInsn</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48311"/><pre class="programlisting">get_manual_insn(ea, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetManyBytes</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48321"/><pre class="programlisting">uint8_t *out = (uint8_t*)qalloc(size + 1);
if (use_dbg)
   if (dbg &amp;&amp; (dbg-&gt;may_disturb() || get_process_state() &lt; 0))
      dbg-&gt;read_memory(ea, out, size);
   else
      qfree(out);
      out = NULL;
else
   get_many_bytes(ea, out, size);
return out;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMarkComment</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48331"/><pre class="programlisting">curloc loc.markdesc(slot, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMarkedPos</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return curloc loc.markedpos(&amp;slot);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMaxLocalType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_ordinal_qty(idati);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberComment</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48359"/><pre class="programlisting">tid_t m = get_member(get_struc(id), offset)-&gt;id;
netnode n(m).supstr(repeatable ? 1 : 0, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberFlag</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_member(get_struc(id), offset)-&gt;flag;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48379"/><pre class="programlisting">tid_t m = get_member(get_struc(id), offset)-&gt;id;
get_member_name(m, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberOffset</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_member_by_name(get_struc(id), member_name)-&gt;soff;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">get_struc(id)-&gt;memqty;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberSize</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48407"/><pre class="programlisting">member_t *m = get_member(get_struc(id), offset);
return get_member_size(m);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMemberStrId</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48417"/><pre class="programlisting">tid_t m = get_member(get_struc(id), offset)-&gt;id;
return netnode n(m).altval(3) - 1;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMinSpd</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48427"/><pre class="programlisting">func_t *f = get_func(ea);
return f ? get_min_spd_ea(f) : BADADDR;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetMnem</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48437"/><pre class="programlisting">ua_mnem(ea, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetModuleName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48447"/><pre class="programlisting">module_info_t modinfo;
if (base == 0)
   get_first_module(&amp;modinfo);
else
   modinfo.base = base - 1;
   get_next_module(&amp;modinfo);
return qstrdup(modinfo.name);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetModuleSize</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48457"/><pre class="programlisting">module_info_t modinfo;
if (base == 0)
   get_first_module(&amp;modinfo);
else
   modinfo.base = base - 1;
   get_next_module(&amp;modinfo);
return modinfo.size;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextBmask</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_bmask(eum_id, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextConst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_const(enum_id, value, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextFixupEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_fixup_ea(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextHashKey</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48495"/><pre class="programlisting">netnode n(id).hashnxt(idx, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextIndex</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return netnode n(id).supnxt(idx, tag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextModule</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48514"/><pre class="programlisting">module_info_t modinfo;
modinfo.base = base;
get_next_module(&amp;modinfo);
return modinfo.base;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetNextStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_struc_idx();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetOpType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48533"/><pre class="programlisting">*buf = 0;
if (isCode(get_flags_novalue(ea)))
   ua_ana0(ea);
   return cmd.Operands[n].type;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetOperandValue</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48543"/><pre class="programlisting">Use ua_ana0 to fill command struct then return
appropriate value based on cmd.Operands[n].type</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetOpnd</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48552"/><pre class="programlisting">*buf = 0;
if (isCode(get_flags_novalue(ea)))
   ua_outop2(ea, buf, sizeof(buf), n);
tag_remove(buf, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetOriginalByte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_original_byte(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevBmask</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_bmask(enum_id, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevConst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_const(enum_id, value, bmask);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevFixupEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_fixup_ea(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevHashKey</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48599"/><pre class="programlisting">netnode n(id).hashprev(idx, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevIndex</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return netnode n(id).supprev(idx, tag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetPrevStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_struc_idx(index);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcessName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48627"/><pre class="programlisting">process_info_t p;
pid_t pid = get_process_info(idx, &amp;p);
return qstrdup(p.name);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcessPid</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_process_info(idx, NULL);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcessQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_process_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcessState</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_process_state();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetReg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return getSR(ea, str2reg(reg));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetRegValue</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48673"/><pre class="programlisting">regval_t r;
get_reg_val(name, &amp;r);
if (is_reg_integer(name))
   return (int)r.ival;
else
   //memcpy(result, r.fval, 12);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetSegmentAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48684"/><pre class="programlisting">segment_t *s = get_seg(segea);
return internal_get_attr(s, attr);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetShortPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48694"/><pre class="programlisting">if (offset &lt;= 190)
   return *(unsigned short*)(offset + (char*)&amp;inf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetSourceFile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_sourcefile(ea));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetSpDiff</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_sp_delta(get_func(ea), ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetSpd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_spd(get_func(ea), ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetString</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48730"/><pre class="programlisting">if (len == −1)
   len = get_max_ascii_length(ea, type, true);
get_ascii_contents(ea, len, type, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStringType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return netnode n(ea).altval(16) - 1;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucComment</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48749"/><pre class="programlisting">get_struc_cmt(id, repeatable, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_by_idx(index);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucIdByName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_id(name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_idx(id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48786"/><pre class="programlisting">get_struc_name(id, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucNextOff</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_next_offset(get_struc(id), offset);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucPrevOff</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_prev_offset(get_struc(id), offset);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetStrucSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc_size(id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetTestId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//*** undocumented, returns internal testId</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetThreadId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return getn_thread(idx);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetThreadQty</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_thread_qty();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetTinfo</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//no comparable return type in SDK, generally uses get_tinfo</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetTrueName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetTrueNameEx</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetTrueNameEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_true_name(from, ea, buf, sizeof(buf)));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48886"/><pre class="programlisting">get_ti(ea, tbuf, sizeof(tbuf), plist, sizeof(plist));
print_type_to_one_line(buf, sizeof(buf), idati,
                       tbuf, NULL, NULL, plist, NULL);
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetnEnum</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return getn_enum(idx);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetVxdFuncName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48904"/><pre class="programlisting">//*** undocumented function
get_vxd_func_name(vxdnum, funcnum, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetXML</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48914"/><pre class="programlisting">valut_t res;
get_xml(path, &amp;res);
return res;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GuessType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e48924"/><pre class="programlisting">guess_type(ea, tbuf, sizeof(tbuf), plist, sizeof(plist));
print_type_to_one_line(buf, sizeof(buf), idati, tbuf,
                       NULL, NULL, plist, NULL);
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">HideArea</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_hidden_area(start, end, description, header, footer, color);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">HighVoids</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IdbByte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_db_byte(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Indent</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsBitfield</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return is_bf(enum_id);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsEventHandled</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_debug_event()-&gt;handled;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsFloat</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//IDC variable type query, n/a for SDK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsLong</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//IDC variable type query, n/a for SDK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsObject</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//IDC variable type query, n/a for SDK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsString</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//IDC variable type query, n/a for SDK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">IsUnion</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_struc(id)-&gt;is_union();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ItemEnd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_item_end(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ItemHead</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_item_head(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ItemSize</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_item_end(ea) - ea;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Jump</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jumpto(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LineA</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49070"/><pre class="programlisting">netnode n(ea).supstr(1000 + num, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LineB</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49080"/><pre class="programlisting">netnode n(ea).supstr(2000 + num, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LoadDebugger</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">load_debugger(dbgname, use_remote);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LoadTil</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return add_til2(name, 0);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LocByName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_name_ea(-1, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LocByNameEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_name_ea(from, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">LowVoids</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MK_FP</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return ((seg&lt;&lt;4) + off);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeAlign</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">doAlign(ea, count, align);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeArray</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49153"/><pre class="programlisting">typeinfo_t ti;
flags_t f = get_flags_novalue(ea);
get_typeinfo(ea, 0, f, &amp;ti);
asize_t sz = get_data_elsize(ea, f, &amp;ti);
do_data_ex (ea, f, sz * nitems, ti.tid);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeByte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeCode</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">ua_code(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeComm</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_cmt(ea, cmt, false);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeData</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">do_data_ex(ea, flags, size, tid);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeDouble</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeDword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeFloat</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeFrame</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49226"/><pre class="programlisting">func_t *f = get_func(ea);
set_frame_size(f, lvsize, frregs, argsize);
return f-&gt;frame;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeFunction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_func(start, end);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeLocal</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49245"/><pre class="programlisting">func_t *f = get_func(ea);
if (*location != '[')
   add_regvar(f, start, end, location, name, NULL);
else
   struc_t *fr = get_frame(f);
   int start = f-&gt;frsize + offset;
   if (get_member(fr, start))
      set_member_name(fr, start, name);
   else
      add_struc_member(fr, name, start,  0x400, 0, 1);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeNameEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_name(ea, name, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeOword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakePackReal</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeQword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeRptCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_cmt(ea, cmt, true);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeStr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49301"/><pre class="programlisting">int len = endea == −1 ? 0 : endea - ea;
make_ascii_string(ea, len, current_string_type);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeStructEx</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49311"/><pre class="programlisting">netnode n(strname);
nodeidx_t idx = (nodeidx_t)n;
if (size != −1)
   do_data_ex(ea, FF_STRU, size, idx);
else
   size_t sz = get_struc_size(get_struc(idx));
   do_data_ex(ea, FF_STRU, sz, idx);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeTbyte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeUnkn</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">do_unknown(ea, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeUnknown</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">do_unknown_range(ea, size, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeVar</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">doVar(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MakeWord</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see MakeData</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MarkPosition</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49366"/><pre class="programlisting">curloc loc;
loc.ea = ea; loc.lnnum = lnnum; loc.x = x; loc.y = y;
loc.mark(slot, NULL, comment);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MaxEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Message</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">msg(format, ...);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MinEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MoveSegm</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return move_segm(get_seg(ea), to, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Name</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_name(-1, ea, buf, sizeof(buf)));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NameEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(get_name(from, ea, buf, sizeof(buf)));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextAddr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return nextaddr(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return funcs-&gt;getn_area(funcs-&gt;get_next_area(ea))-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextFuncFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">func_tail_iterator_t fti(get_func(funcea), tailea);</code></p>
<p><code class="literal">return fti.next() ? fti.chunk().startEA : −1;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextFunction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_func(ea)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextHead</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return next_head(ea, maxea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextNotTail</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return next_not_tail(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">NextSeg</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49489"/><pre class="programlisting">int n = segs.get_next_area(ea);
return getnseg (n)-&gt;startEA;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpAlt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_forced_operand(ea, n, str);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpBinary</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_bin(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpChr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_chr(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpDecimal</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_dec(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpEnumEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_enum(ea, n, enumid, serial);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpFloat</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_flt(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpHex</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_hex(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpHigh</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return op_offset(ea, n, REF_HIGH16, target);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpNot</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">toggle_bnot(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpNumber</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_num(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpOctal</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_oct(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpOff</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49600"/><pre class="programlisting">if (base != 0xFFFFFFFF) set_offset(ea, n, base);
else noType(ea, n);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpOffEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_offset(ea, n, reftype, target, base, tdelta);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpSeg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_seg(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpSign</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">toggle_sign(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpStkvar</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_stkvar(ea, n);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">OpStroffEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">op_stroff(ea, n, &amp;strid, 1, delta);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ParseType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49655"/><pre class="programlisting">qstring in(input);
if (in.last() != ';') in += ';';
flags |= PT_TYP;
if (flags &amp; PT_NDC) flags |= PT_SIL;
else flags &amp;= ~PT_SIL;
flags &amp;= ~PT_NDC;
qstring name, type, fields;
parse_decl(idati, in.c_str(), &amp;name, &amp;type, &amp;fields, flags);
internal_build_idc_typeinfo(&amp;result, &amp;type, &amp;fields);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ParseTypes</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49665"/><pre class="programlisting">int hti_flags = (flags &amp; 0x70) &lt;&lt; 8;
if (flags &amp; 1) hti_flags |= HTI_FIL;
parse_types2(input, (flags &amp; 2) ? NULL : printer_func,
             hti_flags);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PatchByte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">patch_byte(ea, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PatchDbgByte</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49684"/><pre class="programlisting">if (qthread_same(idc_debthread))
   dbg-&gt;write_memory(ea, &amp;value, 1);
else
   put_dbg_byte(ea, value);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PatchDword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">patch_long(ea, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PatchWord</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">patch_word(ea, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PauseProcess</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">suspend_process();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PopXML</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">pop_xml();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PrevAddr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return prevaddr(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PrevFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_fchunk(ea)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PrevFunction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_prev_func(ea)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PrevHead</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return prev_head(ea, minea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PrevNotTail</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return prev_not_tail(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ProcessUiAction</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return process_ui_action(name, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">PushXML</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">push_xml(path);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Qword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_qword(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RebaseProgram</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return rebase_program(delta, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RecalcSpd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return recalc_spd(cur_ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Refresh</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">refresh_idaview_anyway();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RefreshDebuggerMemory</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49831"/><pre class="programlisting">invalidate_dbgmem_config();
invalidate_dbgmem_contents(BADADDR, −1);
if (dbg &amp;&amp; dbg-&gt;stopped_at_debug_event)
   dbg-&gt;stopped_at_debug_event(true);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RefreshLists</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">callui(ui_list);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RemoveFchunk</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">remove_func_tail(get_func(funcea), tailea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RenameArray</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49858"/><pre class="programlisting">qsnprintf(buf, sizeof(buf), "$ idc_array %s", name);
netnode n(id).rename(newname);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RenameEntryPoint</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">rename_entry(ordinal, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RenameSeg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_segm_name(get_seg(ea), "%s", name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ResumeThread</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return resume_thread(tid);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Rfirst</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_cref_from(From);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Rfirst0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_fcref_from(From);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RfirstB</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_cref_to(To);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RfirstB0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_first_fcref_to(To);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Rnext</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_cref_from(From, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Rnext0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_fcref_from(From, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RnextB</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_cref_to(To, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RnextB0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_next_fcref_to(To, current);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RunPlugin</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">run_plugin(load_plugin(name), arg);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RunTo</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">run_to(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SaveBase</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e49985"/><pre class="programlisting">char *fname = idbname ? idbname : database_idb;
uint32_t tflags = database_flags;
database_flags = (flags &amp; 4) | (tflags &amp; 0xfffffffb);
bool res = save_database(fname, 0);
database_flags = tflags;
return res;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ScreenEA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_screen_ea();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegAddrng</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see SetSegAddressing</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegAlign</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetSegmentAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegBounds</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see SetSegBounds</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegByBase</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_segm_by_sel(base)-&gt;startEA;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegByName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50041"/><pre class="programlisting">sel_t seg;
atos(segname, *seg);
return seg;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegClass</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see SetSegClass</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegComb</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetSegmentAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegCreate</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see AddSeg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegDefReg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see SetSegDefReg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegDelete</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see DelSeg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegEnd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetSegmentAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegName</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50105"/><pre class="programlisting">segment_t *s = (segment_t*) get_seg(ea);
get_true_segm_name(s, buf, sizeof(buf));
return qstrdup(buf);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegRename</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see RenameSeg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SegStart</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see GetSegmentAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SelEnd</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50133"/><pre class="programlisting">ea_t ea1, ea2;
read_selection(&amp;ea1, &amp;ea2);
return ea2;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SelStart</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50142"/><pre class="programlisting">ea_t ea1, ea2;
read_selection(&amp;ea1, &amp;ea2);
return ea1;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SelectThread</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">select_thread(tid);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetArrayFormat</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50160"/><pre class="programlisting">segment_t *s = get_seg(ea);
if (s)
   uint32_t format[3];
   netnode array(ea);
   format[0] = flags;
   format[1] = litems;
   format[2] = align;
   array.supset(5, format, sizeof(format));</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetArrayLong</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).altset(idx, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetArrayString</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).supset(idx, str);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetBmaskCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_bmask_cmt(enum_id, bmask, cmt, repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetBmaskName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_bmask_name(enum_id, bmask, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetBptAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50206"/><pre class="programlisting">bpt_t bpt;
if (get_bpt(ea, &amp;bpt) == 0) return;
if (bpattr == BPTATTR_SIZE) bpt.size = value;
else if (bpattr == BPTATTR_TYPE) bpt.type = value;
else if (bpattr == BPTATTR_COUNT) bpt.pass_count = value;
else if (bpattr == BPTATTR_FLAGS) bpt.flags = value;
update_bpt(&amp;bpt);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetBptCnd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro for SetBptCndEx(ea, cnd, 0);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetBptCndEx</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50225"/><pre class="programlisting">bpt_t bpt;
if (get_bpt(ea, &amp;bpt) == 0) return;
bpt. cndbody = cnd;
if (is_lowcnd)
   bpt.flags |= BPT_LOWCND;
else
   bpt.flags &amp;= ~ BPT_LOWCND;
update_bpt(&amp;bpt);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetCharPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50234"/><pre class="programlisting">if (offset &gt;= 13 &amp;&amp; offset &lt;= 191)
   *(offset + (char*)&amp;inf) = value;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetColor</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50243"/><pre class="programlisting">if (what == CIC_ITEM)
   set_item_color(ea, color);
else if (what == CIC_FUNC)
   func_t *f = get_func(ea);
   f-&gt;color = color;
   update_func(f);
else if (what == CIC_SEGM)
   segment_t *s = get_seg(ea);
   s-&gt;color = color;
   s-&gt;update();</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetConstCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_const_cmt(const_id, cmt, repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetConstName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_const_name(const_id, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetDebuggerOptions</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return set_debugger_options(options);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumBf</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_enum_bf(enum_id, flag ? 1 : 0);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_enum_cmt(enum_id, cmt, repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumFlag</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_enum_flag(enum_id, flag);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_enum_idx(enum_id, idx);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_enum_name(enum_id, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetEnumWidth</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return set_enum_width(enum_id, width);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetExceptionFlags</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50335"/><pre class="programlisting">excvec_t *ev = retrieve_exceptions();
for (excvec_t::iterator i = ev-&gt;begin(); i != ev-&gt;end(); i++)
   if ((*i).code == code)
      if ((*i).flags == flags)
         return true;
      else
         (*i).flags = flags;
         return store_exceptions();
return 0;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFchunkAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50344"/><pre class="programlisting">func_t *f = get_func(ea);
internal_set_attr(f, attr, value);
update_func(f);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFchunkOwner</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_tail_owner(get_func(tailea), funcea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFixup</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50362"/><pre class="programlisting">fixup_data_t f = {type, targetsel, targetoff, displ};
set_fixup(ea, &amp;f);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFlags</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">setFlags(ea, flags);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFunctionAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50380"/><pre class="programlisting">func_t *f = get_func(ea);
internal_set_attr(f, attr, value);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFunctionCmt</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_func_cmt (get_func(ea), cmt, repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFunctionEnd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">func_setend(ea, end);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetFunctionFlags</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetFunctionAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetHashLong</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).hashset(idx, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetHashString</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">netnode n(id).hashset(idx, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetHiddenArea</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50435"/><pre class="programlisting">hidden_area_t *ha = get_hidden_area (ea);
ha-&gt;visible = visible;
update_hidden_area(ha);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetInputFilePath</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50444"/><pre class="programlisting">if (strlen(path) == 0) RootNode.set("");
else RootNode.set(path);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetLineNumber</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_source_linnum(ea, lnnum);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetLocalType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50462"/><pre class="programlisting">if (input == NULL || *input == 0)
   del_numbered_type(idati, ordinal);
else
   qstring name;
   qtype type, fields;
   parse_decl(idati, input, &amp;name, &amp;type, &amp;fields, flags);
   if (ordinal == 0)
      if (!name.empty())
         get_named_type(idati, name.c_str(),
                        NTF_TYPE | NTF_NOBASE, NULL, NULL,
                        NULL, NULL, NULL, &amp;ordinal);
         if (!ordinal)
            ordinal = alloc_type_ordinal(idati);
   set_numbered_type(idati, value, 0, name.c_str(),
                     type.c_str(), fields.c_str(),
                     NULL, NULL, NULL);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetLongPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50472"/><pre class="programlisting">if (offset &gt;= 13 &amp;&amp; offset &lt;= 188)
   *(int*)(offset + (char*)&amp;inf) = value;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetManualInsn</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_manual_insn(ea, insn);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetMemberComment</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50490"/><pre class="programlisting">member_t *m = get_member(get_struc(ea), member_offset);
set_member_cmt(m, comment, repeatable);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetMemberName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_member_name(get_struc(ea), member_offset, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetMemberType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50509"/><pre class="programlisting">typeinfo_t mt;
//calls an internal function to initialize mt using typeid
int size =  get_data_elsize(-1, flag, &amp;mt) *  nitems;
set_member_type(get_struc(id), member_offset, flag, &amp;mt,size);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetProcessorType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_processor_type(processor, level);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetReg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro for SetRegEx(ea, reg, value, SR_user);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetRegEx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">splitSRarea1(ea, str2reg(reg), value, tag, false);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetRegValue</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50545"/><pre class="programlisting">regval_t r;
if (is_reg_integer(name))
   r.ival = (unsigned int)VarLong(value);
else
   memcpy(r.fval, VarFloat(value), 12);
set_reg_val(name, &amp;r);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetRemoteDebugger</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_remote_debugger(hostname, password, portnum);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegAddressing</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_segm_addressing(get_seg(ea), use32);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegBounds</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50572"/><pre class="programlisting">if (get_seg(ea))
   set_segm_end(ea, endea, flags);
   set_segm_end(ea, startea, flags);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegClass</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_segm_class(get_seg(ea), class);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegDefReg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">SetDefaultRegisterValue(get_seg(ea), str2reg(reg), value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegmentAttr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50599"/><pre class="programlisting">segment_t *s = get_seg(segea);
internal_set_attr(s, attr, value);
s-&gt;update();</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSegmentType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetSegmentAttr</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSelector</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_selector(sel, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetShortPrm</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50627"/><pre class="programlisting">if (offset &gt;= 13 &amp;&amp; offset &lt;= 190)
   *(short*)(offset + (char*)&amp;inf) = value;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetSpDiff</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_user_stkpnt(ea, delta);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetStatus</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">setStat(status);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetStrucComment</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_struc_cmt(id, cmt, repeatable);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetStrucIdx</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_struc_idx(get_struc(id), index);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetStrucName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_struc_name(id, name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetTargetAssembler</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_target_assembler(asmidx);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetType</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50690"/><pre class="programlisting">apply_cdecl(ea, type)
if (get_aflags(ea) &amp; AFL_TILCMT)
   set_ti(ea, "", NULL);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SetXML</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">set_xml(path, name, value);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Sleep</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qsleep(milliseconds);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StartDebugger</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">start_process(path, args, sdir);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StepInto</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">step_into();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StepOver</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">step_over();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StepUntilRet</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">step_until_ret();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StopDebugger</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">exit_process();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">StringStp</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Tabs</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">TakeMemorySnapshot</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">take_memory_snapshot(only_loader_segs);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">TailDepth</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Til2Idb</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return til2idb(idx, type_name);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Voids</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Wait</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">autoWait();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Warning</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">warning(format, ...);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Word</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_full_word(ea);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">XrefShow</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetCharPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">XrefType</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">Returns value of an internal global variable</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">____</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50863"/><pre class="programlisting">//*** undocumented function (four underscores)
//returns database creation timestamp
return RootNode.altval(RIDX_ALT_CTIME);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">_call</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50873"/><pre class="programlisting">//*** undocumented function
//uint32_t _call(uint32_t (*f)())
//f is a pointer in IDA's (NOT the database's) address space
return (*f)();</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">_lpoke</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50882"/><pre class="programlisting">//*** undocumented function
//uint32_t _lpoke(uint32_t *addr, uint32_t val)
//addr is an address in IDA's (NOT the database's) address
//space. This modifies IDA’s address space NOT the database’s
uint32_t old = *addr;
*addr = val;
return old;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">_peek</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50891"/><pre class="programlisting">//*** undocumented function
//uint8_t *_peek(uint8_t *addr)
//addr is in IDA's address space
return *addr;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">_poke</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50900"/><pre class="programlisting">//*** undocumented function
//uint8_t _lpoke(uint8_t *addr, uint8_t val)
//addr is an address in IDA's (NOT the database's) address
//space. This modifies IDA's address space NOT the database's
uint8_t old = *addr;
*addr = val;
return old;</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">_time</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50911"/><pre class="programlisting">//*** undocumented function
return _time64(NULL);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">add_dref</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">add_dref(From, To, drefType);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">atoa</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e50930"/><pre class="programlisting">ea2str(ea, buf, sizeof(buf));
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">atol</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return atol(str);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">byteValue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">del_dref</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">del_dref(From, To);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">delattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">VarDelAttr(self, attr);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fclose</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qfclose(handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fgetc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qfgetc(handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">filelength</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return efilelength(handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fopen</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qfopen(file, mode);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">form</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//deprecated, see sprintf</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fprintf</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qfprintf(handle, format, ...);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fputc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qfputc(byte, handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fseek</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qfseek(handle, offset, origin);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ftell</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qftell(handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">get_field_ea</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">Too complex to summarize</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">get_nsec_stamp</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return get_nsec_stamp();</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">getattr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51075"/><pre class="programlisting">idc_value_t res;
VarGetAttr(self, attr, &amp;res);
return res;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">hasattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return VarGetAttr(self, attr, NULL) == 0;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">hasName</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">hasValue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isBin0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isBin1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isChar0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isChar1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isCode</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isData</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isDec0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isDec1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isDefArg0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isDefArg1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isEnum0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isEnum1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isExtra</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isFlow</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isFop0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isFop1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isHead</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isHex0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isHex1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isLoaded</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isOct0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isOct1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isOff0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isOff1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isRef</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isSeg0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isSeg1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isStkvar0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isStkvar1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isStroff0</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isStroff1</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isTail</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isUnknown</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">isVar</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">lastattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(VarLastAttr(self));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">loadfile</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51430"/><pre class="programlisting">linput_t *li = make_linput(handle);
file2base(li, pos, ea, ea + size, false);
unmake_linput(li);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ltoa</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">Calls internal conversion routine</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mkdir</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qmkdir(dirname, mode);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">nextattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(VarNextAttr(self, attr));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ord</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return str[0];</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">prevattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return qstrdup(VarPrevAttr(self, attr));</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">print</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51484"/><pre class="programlisting">qstring qs;
VarPrint(&amp;qs, arg);
msg("%s\n", qs.c_str());</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">readlong</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51493"/><pre class="programlisting">unsigned int res;
freadbytes(handle, &amp;res, 4, mostfirst);
return res;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">readshort</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51502"/><pre class="programlisting">unsigned short res;
freadbytes(handle, &amp;res, 2, mostfirst);
return res;</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">readstr</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51512"/><pre class="programlisting">qfgets(buf, sizeof(buf), handle);
return qstrdup(buf);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">rename</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return rename(oldname, newname);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">rotate_left</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return rotate_left(value, count, nbits, offset);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">savefile</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">base2file(handle, pos, ea, ea + size);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">set_start_cs</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">set_start_ip</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">//macro, see SetLongPrm</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setattr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return VarSetAttr(self, attr, value) == 0;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sizeof</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51575"/><pre class="programlisting">type_t *t = internal_type_from_idc_typeinfo(type);
return get_type_size(idati, t);</pre>
</td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sprintf</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51585"/><pre class="programlisting">qstring buf;
buf.sprnt(format, ...);
return qstrdup(buf.c_str());</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">strfill</code></p></td><td style="text-align: left" valign="top">
<a id="I_programlisting_d1e51594"/><pre class="programlisting">qstring s;
s.resize(len + 1, &amp;chr);
return new qstring(s);</pre></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">strlen</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return strlen(str);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">strstr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return strstr(str, substr);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">substr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">Calls internal slice routine</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">trim</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return new qstring(string.c_str());</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">unlink</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return _unlink(filename);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">writelong</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">fwritebytes(handle, &amp;dword, 4, mostfirst);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">writeshort</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">fwritebytes(handle, &amp;word, 2, mostfirst);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">writestr</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">qfputs(str, handle);</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">xtol</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">return strtoul(str, NULL, 16);</code></p></td></tr></tbody></table></div></div></body></html>