<html><head></head><body><div class="preface" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="introduction"/>Introduction</h1></div></div></div><p>Haskell is fun, and that’s what it’s all about!</p><p>This book is aimed at people who have experience programming in imperative languages—such as C++, Java, and Python—and now want to try out Haskell. But even if you don’t have any significant programming experience, I’ll bet a smart person like you will be able to follow along and learn Haskell.</p><p>My first reaction to Haskell was that the language was just too weird. But after getting over that initial hurdle, it was smooth sailing. Even if Haskell seems strange to you at first, don’t give up. Learning Haskell is almost like learning to program for the first time all over again. It’s fun, and it forces you to think differently.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you ever get really stuck, the IRC channel <span class="emphasis"><em>#haskell</em></span> on the freenode network is a great place to ask questions. The people there tend to be nice, patient, and understanding. They’re a great resource for Haskell newbies.</p></div><div class="sect1" title="So, What's Haskell?"><div class="titlepage"><div><div><h1 class="title"><a id="so_comma_what_apostrophy_s_haskell"/>So, What's Haskell?</h1></div></div></div><p>Haskell is a <span class="emphasis"><em>purely functional</em></span> programming language.</p><p>In <span class="emphasis"><em>imperative</em></span> programming languages, you give the computer a sequence of tasks, which it then executes. While executing them, the computer can change state. For instance, you can set the variable <code class="literal">a</code> to 5 and then do some stuff that might change the value of <code class="literal">a</code>. There are also flow-control structures for executing instructions several times, such as <code class="literal">for</code> and <code class="literal">while</code> loops.</p><p>Purely functional programming is different. You don’t tell the computer what to do—you tell it <span class="emphasis"><em>what stuff is</em></span>. For instance, you can tell the computer that the factorial of a number is the product of every integer from 1 to that number or that the sum of a list of numbers is the first number plus the sum of the remaining numbers. You can express both of these operations as <span class="emphasis"><em>functions</em></span>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e174"/><img src="httpatomoreillycomsourcenostarchimages802500.png" alt="image with no caption"/></div></div><p>In functional programming, you <span class="emphasis"><em>can’t</em></span> set a variable to one value and then set it to something else later on. If you say <code class="literal">a</code> is 5, you can’t just change your mind and say it’s something else. After all, you said it was 5. (What are you, some kind of liar?)</p><p>In purely functional languages, a function has no <span class="emphasis"><em>side effects</em></span>. The only thing a function can do is calculate something and return the result. At first, this seems limiting, but it actually has some very nice consequences. If a function is called twice with the same parameters, it’s guaranteed to return the same result both times. This property is called <span class="emphasis"><em>referential transparency</em></span>. It lets the programmer easily deduce (and even prove) that a function is correct. You can then build more complex functions by gluing these simple functions together.</p><p>Haskell is <span class="emphasis"><em>lazy</em></span>. This means that unless specifically told otherwise, Haskell won’t execute functions until it needs to show you a result. This is made possible by referential transparency. If you know that the result of a function depends only on the parameters that function is given, it doesn’t matter when you actually calculate the result of the function. Haskell, being a lazy language, takes advantage of this fact and defers actually computing results for as long as possible. Once you want your results to be displayed, Haskell will do just the bare minimum computation required to display them. Laziness also allows you to make seemingly infinite data structures, because only the parts of the data structures that you choose to display will actually be computed.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e201"/><img src="httpatomoreillycomsourcenostarchimages802502.png.jpg" alt="image with no caption"/></div></div><p>Let’s look at an example of Haskell’s laziness. Say you have a list of numbers, <code class="literal">xs = [1,2,3,4,5,6,7,8]</code>, and a function called <code class="literal">doubleMe</code> that doubles every element and returns the result as a new list. If you want to multiply your list by 8, your code might look something like this:</p><a id="I_programlisting_d1e214"/><pre class="programlisting">doubleMe(doubleMe(doubleMe(xs)))</pre><p>An imperative language would probably pass through the list once, make a copy, and then return it. It would then pass through the list another two times, making copies each time, and return the result.</p><p>In a lazy language, calling <code class="literal">doubleMe</code> on a list without forcing it to show you the result just makes the program tell you, “Yeah yeah, I’ll do it later!” Once you want to see the result, the first <code class="literal">doubleMe</code> calls the second one and says it wants the result immediately. Then the second one says the same thing to the third one, and the third one reluctantly gives back a doubled 1, which is 2. The second <code class="literal">doubleMe</code> receives that and returns 4 to the first one. The first <code class="literal">doubleMe</code> then doubles this result and tells you that the first element in the final resulting list is 8. Because of Haskell’s laziness, the <code class="literal">doubleMe</code> calls pass through the list just once, and only when you really need that to happen.</p><p>Haskell is <span class="emphasis"><em>statically typed</em></span>. This means that when you compile your program, the compiler knows which piece of code is a number, which is a string, and so on. Static typing means that a lot of possible errors can be caught at compile time. If you try to add together a number and a string, for example, the compiler will whine at you.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e242"/><img src="httpatomoreillycomsourcenostarchimages802504.png.jpg" alt="image with no caption"/></div></div><p>Haskell uses a very good type system that has <span class="emphasis"><em>type inference</em></span>. This means that you don’t need to explicitly label every piece of code with a type, because Haskell’s type system can intelligently figure it out. For example, if you say <code class="literal">a = 5 + 4</code>, you don’t need to tell Haskell that <code class="literal">a</code> is a number—it can figure that out by itself. Type inference makes it easier for you to write code that’s more general. If you write a function that takes two parameters and adds them together, but you don’t explicitly state their type, the function will work on any two parameters that act like numbers.</p><p>Haskell is <span class="emphasis"><em>elegant and concise</em></span>. Because it uses a lot of high-level concepts, Haskell programs are usually shorter than their imperative equivalents. Shorter programs are easier to maintain and have fewer bugs.</p><p>Haskell was made by some really smart guys (with PhDs). Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language. The Haskell Report, which defines a stable version of the language, was published in 1999.</p></div></div>
<div class="sect1" title="What You Need to Dive In"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_need_to_dive_in"/>What You Need to Dive In</h1></div></div></div><p>In short, to get started with Haskell, you need a text editor and a Haskell compiler. You probably already have your favorite text editor installed, so we won’t waste time on that. The most popular Haskell compiler is the Glasgow Haskell Compiler (GHC), which we will be using throughout this book.</p><p>The best way to get what you need is to download the <span class="emphasis"><em>Haskell Platform</em></span>. The Haskell Platform includes not only the GHC compiler but also a bunch of useful Haskell libraries! To get the Haskell Platform for your system, go to <a class="ulink" href="http://hackage.haskell.org/platform/">http://hackage.haskell.org/platform/</a> and follow the instructions for your operating system.</p><p>GHC can compile Haskell scripts (usually with an <span class="emphasis"><em>.hs</em></span> extension), and it also has an interactive mode. From there, you can load functions from scripts and then call them directly to see immediate results. Especially when you’re learning, it’s much easier to use the interactive mode than it is to compile and run your code every time you make a change.</p><p>Once you’ve installed the Haskell Platform, open a new terminal window, assuming you’re on a Linux or Mac OS X system. If your operating system of choice is Windows, go to the command prompt. Once there, type <strong class="userinput"><code>ghci</code></strong> and press <span class="keycap">enter</span> to start the interactive mode. (If your system fails to find the GHCi program, you can try rebooting your computer.)</p><p>If you’ve defined some functions in a script—for example, <span class="emphasis"><em>myfunctions.hs</em></span>—you can load these functions into GHCi by typing <code class="literal">:l myfunctions</code>. (Make sure that <span class="emphasis"><em>myfunctions.hs</em></span> is in the same folder from which you started GHCi.)</p><p>If you change the <span class="emphasis"><em>.hs</em></span> script, run <code class="literal">:l myfunctions</code> to load the file again or run <code class="literal">:r</code>, which reloads the current script. My usual workflow is to define some functions in an <span class="emphasis"><em>.hs</em></span> file, load it into GHCi, mess around with it, change the file, and repeat. This is what we’ll be doing in this book.</p></div>
<div class="sect1" title="Acknowledgments"><div class="titlepage"><div><div><h1 class="title"><a id="acknowledgments"/>Acknowledgments</h1></div></div></div><p>Thanks to everyone who sent in corrections, suggestions, and words of encouragement. Also thanks to Keith, Sam, and Marilyn for making me look like a real writer.</p></div></body></html>