<html><head></head><body>
  <h1><span class="chapter">Chapter 8 -</span><br/>
  Reverse Engineering Xbox Security</h1>

  <p>In this chapter, I will describe how I defeated the initial production version of the Xbox security system that was first encountered in Chapter 6. The security system was discovered after analyzing the FLASH ROM and realizing that the true hardware initialization and boot image decryption sequence was somehow hidden outside of the FLASH ROM. The Chapter 7 introduced some basic cryptography concepts that will be useful understanding the contents of this chapter.</p>

  <h2 id="sigil_toc_id_60"><b class="calibre3">Extracting Secrets from Hardware</b></h2>

  <p>The hidden boot code in the Xbox, as concluded in Chapter 6, can be <span style="font-size: 1em;">recovered by eavesdropping on one of the following buses: (1) the FSB,</span> <span style="font-size: 1em;">(2) the main memory bus, or (3) the Northbridge-Southbridge connection.</span></p>

  <p>The format of the Front Side Bus (FSB) of the Pentium processor used in <span style="font-size: 1em;">the Xbox is documented in the Pentium III processor datasheets, available</span> <span style="font-size: 1em;">at Intel’s Developer Website. The FSB is a bidirectional 64-bit data bus with about fifty address and control signals, all running at 133 MHz. The bus</span> <span style="font-size: 1em;">uses a signaling convention known as AGTL+. Eavesdropping on this bus</span> <span style="font-size: 1em;">is an expensive and difficult proposition because of the high signal count</span> <span style="font-size: 1em;">and challenging physical form factor. Viable approaches include: (a) socketing the processor with a special emulator break-out socket that costs many</span> <span style="font-size: 1em;">thousands of dollars, or (b) reverse engineering the meaning of each FSB</span> <span style="font-size: 1em;">trace on the Xbox motherboard, and tack soldering a short probe wire onto</span> <span style="font-size: 1em;">each of the almost one hundred signals. In addition, a logic analyzer that</span> <span style="font-size: 1em;">supports AGTL+ signaling is required. The combination of all these factors</span> <span style="font-size: 1em;">made me look elsewhere for a starting point for eavesdropping.</span></p>

  <p>Our next eavesdropping candidate, the main memory bus, is a 128-bit <span style="font-size: 1em;">data bus plus address and control signals running at 200 MHz with</span> <span style="font-size: 1em;">double data rate (DDR) clocking. The memory bus uses a signaling</span> <span style="font-size: 1em;">convention known as SSTL-2. (The details of this bus can be inferred by</span> <span style="font-size: 1em;">reading the datasheet for the Samsung K4D263238M memory part,</span> <span style="font-size: 1em;">available at the Samsung Electronics website.) Despite its higher speeds,</span> <span style="font-size: 1em;">eavesdropping the main memory bus is probably easier than eavesdrop</span><span style="font-size: 1em;">ping the processor FSB, because of the empty (spare) memory footprints</span> <span style="font-size: 1em;">designed into the Xbox motherboard.</span></p>

  <p><span style="font-size: 1em;">A relatively inexpensive, standard 100-pin TQFP adapter (Thin Quad Flat</span> <span style="font-size: 1em;">Pack, a rectangular chip package with 100 gull-wing shaped pins) could be</span> <span style="font-size: 1em;">soldered onto the empty memory footprints. These adapters would provide</span> <span style="font-size: 1em;">convenient probe points for connecting a logic analyzer. The problem with</span> <span style="font-size: 1em;">this approach is that you can only capture data that is written to main</span> <span style="font-size: 1em;">memory. Decryption keys are generally read-only data, and read-only</span> <span style="font-size: 1em;">data will go straight from the hidden boot ROM into the processor cache</span> <span style="font-size: 1em;">without ever being stored into main memory. Once the processor is done</span> <span style="font-size: 1em;">with the cache line containing the key, it will be overwritten, so the key</span> <span style="font-size: 1em;">should never leave the physical perimeter of the processor.</span></p>

  <div class="infobox">
    <h2 id="sigil_toc_id_61"><b class="calibre3">More About High Speed</b> <b class="calibre3" style="font-size: 1em;">Information Transmission</b></h2>

    <p>Eavesdropping and modifying data on computer buses is <span style="font-size: 1em;">a powerful technique that is difficult to counter. In order to</span> <span style="font-size: 1em;">understand how to eavesdrop, you will need a little bit of</span> <span style="font-size: 1em;">background on how digital information is transmitted in</span><span style="font-size: 1em;">side a computer.</span></p>

    <p>There are two major categories of signaling standards: single-<span style="font-size: 1em;">ended and differential. The transmission of digital informa</span><span style="font-size: 1em;">tion over a wire requires a translation into physical quanti</span><span style="font-size: 1em;">ties such as voltage and current. Classically, signals were</span> <span style="font-size: 1em;">defined in terms of voltages measured with respect to a</span> <span style="font-size: 1em;">common reference potential called the “ground.” This kind</span> <span style="font-size: 1em;">of signaling is known as single-ended or unbalanced sig</span><span style="font-size: 1em;">naling. Unfortunately, the idea of a ground reference point</span> <span style="font-size: 1em;">only works when signals change slowly with respect to their</span> <span style="font-size: 1em;">propagation time. In reality, every change in potential is</span> <span style="font-size: 1em;">accompanied by a flow of current. The laws of nature de</span><span style="font-size: 1em;">mand that current be conserved, i.e., for every flow of cur</span><span style="font-size: 1em;">rent in one direction, there must be a flow of current in the</span> <span style="font-size: 1em;">reverse direction. In single-ended signaling, the reverse cur</span><span style="font-size: 1em;">rent, also known as a return current, must find its way back</span> <span style="font-size: 1em;">through the “ground”. At very high speeds, the return paths</span> <span style="font-size: 1em;">for current do not necessarily follow the same path as the</span> <span style="font-size: 1em;">signal current. This imbalance results in a distorted signal.</span></p>

    <p><span style="font-size: 1em;">Differential signaling combats this problem by using two wires</span> <span style="font-size: 1em;">to transmit a signal, with one wire used for the signal current</span> <span style="font-size: 1em;">and the other used for an explicit return current path. The</span> <span style="font-size: 1em;">differential approach allows the signal and return paths to</span> <span style="font-size: 1em;">be laid out so that they track each other, ensuring that the</span> <span style="font-size: 1em;">flow of current is balanced. The result is a more robust signal</span> <span style="font-size: 1em;">transmission system at the cost of twice the number of wires.</span></p>

    <p style="font-size: medium;">A specific standard for interpreting voltages as logic values <span style="font-size: 1em;">is called a signaling convention. The venerable TTL and</span> <span style="font-size: 1em;">3.3V CMOS signaling conventions were invented in an era</span> <span style="font-size: 1em;">when transistors performed so poorly that large signal ex</span><span style="font-size: 1em;">cursions were necessary. Lately, a host of new and even old</span> <span style="font-size: 1em;">signaling conventions have been gaining popularity, such</span> <span style="font-size: 1em;">as SSTL (series stub terminated logic), GTL (gunning trans</span><span style="font-size: 1em;">ceiver logic), LVDS (low voltage differential signaling), and</span> <span style="font-size: 1em;">PECL (pseudo emitter coupled logic). These high-speed sig</span><span style="font-size: 1em;">naling conventions account for the fact that electric waves</span> <span style="font-size: 1em;">travel slowly with respect to the rate of data transmission.</span> <span style="font-size: 1em;">They also account for the fact that electric waves carry</span> <span style="font-size: 1em;">energy that must be dissipated upon the termination of its</span> <span style="font-size: 1em;">journey, otherwise the energy will reflect and cause inter</span><span style="font-size: 1em;">ference with incoming waves.</span></p>

    <p style="font-size: medium;">In high-speed applications, wires are often called “trans<span style="font-size: 1em;">mission lines” in order to emphasize the fact that these waves</span> <span style="font-size: 1em;">travel slowly in comparison to the signal transition time (the</span> <span style="font-size: 1em;">time required for a signal to transition between a “1” and a</span> <span style="font-size: 1em;">“0” state). (Note that the speed comparison is made rela</span><span style="font-size: 1em;">tive to transition time of the signal, and not its gross signaling</span> <span style="font-size: 1em;">frequency.) A common mistake is to think that transmission</span> <span style="font-size: 1em;">line effects can be ignored because the clock frequency</span> <span style="font-size: 1em;">of the signal is slow. Even if there is only one transition every</span> <span style="font-size: 1em;">year, problems can still arise if the duration of that transition</span> <span style="font-size: 1em;">takes only a picosecond (one trillionth of a second).</span></p>

    <p style="font-size: medium;"><span style="font-size: 1em;">The good news for novices is that the latest FPGAs from</span> <span style="font-size: 1em;">vendors such as Xilinx come with built-in support for almost</span> <span style="font-size: 1em;">every widely deployed signaling standard. The other piece</span> <span style="font-size: 1em;">of good news is that signaling standards are becoming</span> <span style="font-size: 1em;">increasingly well documented. The Xilinx FPGA data sheets,</span> <span style="font-size: 1em;">for example, illustrate the expected position and value of</span> <span style="font-size: 1em;">the termination resistors for every supported signaling stan</span><span style="font-size: 1em;">dard. By following the recommended practices in the</span> <span style="font-size: 1em;">datasheet and application notes, you can use the FPGA</span> <span style="font-size: 1em;">to eavesdrop on a wide range of signals. Just remember to</span> <span style="font-size: 1em;">keep your eavesdropping taps as short as possible and</span> <span style="font-size: 1em;">you shouldn’t go wrong.</span></p>
  </div>

  <p>The third potential eavesdropping candidate, the Northbridge to <span style="font-size: 1em;">Southbridge connection, is a pair of unidirectional, 8-bit wide differential busses, each with just one control signal and one clock signal. The bus uses the HyperTransport signaling convention and runs at 200 MHz with DDR</span> <span style="font-size: 1em;">clocking. The signaling convention of the bus was deduced from the</span> <span style="font-size: 1em;">publicly available information at nVidia’s website about the nForce, a chipset closely related to the Xbox’s chipset. A few measurements with an</span> <span style="font-size: 1em;">oscilloscope, cross-checked against the open HyperTransport specifica</span><span style="font-size: 1em;">tions available at the HyperTransport consortium’s website, were used to</span> <span style="font-size: 1em;">verify the assumption that the HyperTransport signalling convention is</span> <span style="font-size: 1em;">indeed being used.</span></p>

  <p><span style="font-size: 1em;">The HyperTransport bus is implemented on the Xbox motherboard with</span> <span style="font-size: 1em;">all the signals parallel and evenly spaced, a decision likely driven by the high operating speed of the bus. This makes the bus an ideal target for eavesdropping, except for the fact that it runs at such a high data rate. Eavesdropping a bus that runs at this speed requires special attention to the stub length of the eavesdropping traces (in order to preserve the integrity of the signals) and it also requires a rather expensive logic analyzer or a custom analyzer circuit.</span></p>

  <p>Ultimately, the Northbridge-Southbridge connection was chosen as the <span style="font-size: 1em;">first bus to eavesdrop because it has by far the fewest wires, and therefore requires the least amount of soldering. The Northbrige-Southbridge</span> <span style="font-size: 1em;">connection has only ten unique signals, whereas both the FSB and the main</span> <span style="font-size: 1em;">memory have about one hundred signals each. Soldering a large number of</span> <span style="font-size: 1em;">connections not only consumes a large amount of time, but also greatly</span> <span style="font-size: 1em;">increases the risk of hardware failures due to solder bridges or damaged</span> <span style="font-size: 1em;">traces. Thus, minimizing the number of solder connections minimizes the</span> <span style="font-size: 1em;">risk of collateral damage to the motherboard.</span></p>

  <h3 id="sigil_toc_id_62"><b class="calibre3">Eavesdropping a High Speed Bus</b></h3>

  <p>I had committed to the HyperTransport eavesdropping approach in late <span style="font-size: 1em;">January 2002. The significant technical issues with this approach were:</span></p>

  <p>• Tapping the high-speed differential bus without disrupting signal <span style="font-size: 1em;">integrity</span></p>

  <p>• Finding or building a logging tool that could keep up with the 400 <span style="font-size: 1em;">MB/s data rates on the HyperTransport bus</span></p>

  <p>• Determining the polarity and bit ordering of the differential <span style="font-size: 1em;">HyperTransport bus traces on the motherboard</span></p>

  <h4 id="sigil_toc_id_63"><b class="calibre3">Tapping the Bus on a Budget</b></h4>

  <p>The first two issues are intimately linked. High-speed bus analysis and <span style="font-size: 1em;">logging tools typically have proprietary interfaces that would require a</span> <span style="font-size: 1em;">custom adapter to the Xbox motherboard. The last issue, determining bit</span> <span style="font-size: 1em;">polarity and ordering, just requires a lot of post-processing and data</span> <span style="font-size: 1em;">massaging after the data logger is attached and functioning.</span></p>

  <p>HyperTransport is an open standard that has gained industry acceptance, <span style="font-size: 1em;">meaning that off-the-shelf protocol analyzers and logging tools are available for the bus. One such example is the HyperTransport protocol analyzer</span> <span style="font-size: 1em;">by FuturePlus. Unfortunately, this protocol analyzer was priced in excess</span> <span style="font-size: 1em;">of $25,000 at the time the work was being done. In addition, the proto</span><span style="font-size: 1em;">col analyzer requires the target board to be specially designed to accom</span><span style="font-size: 1em;">modate the protocol analyzer’s bus interface pod.</span></p>

  <p>Instead of buying a protocol analyzer and investing the time and effort to <span style="font-size: 1em;">adapt it for use with the Xbox, I built my own simplified one. This task is feasible because the HyperTransport protocol is quite simple. The Xbox</span> <span style="font-size: 1em;">implementation of HyperTransport uses two 8-bit unidirectional buses,</span> <span style="font-size: 1em;">one for transmit and one for receive. Each bus has a clock and a strobe line associated with it. The signaling standard requires valid data to be presented on each edge of the clock. The beginning of a new packet is indicated by the data lines leaving their idle state. The strobe line differentiates between command and data packets. All of the sideband signals typical of other busses, such as the address, read/write control, chip select, and interrupt lines, are handled in HyperTransport using in-band command packets.</span> <span style="font-size: 1em;">Hence, just ten differential signals (twenty wires) are all you need for</span> <span style="font-size: 1em;">eavesdropping the bus — great news for hackers.</span></p>

  <p>The HyperTransport protocol is simple enough, but what about finding <span style="font-size: 1em;">something that can both physically interface to the Xbox bus and keep up</span> <span style="font-size: 1em;">with the 400 MB/s speeds? The ideal tool for building this HyperTransport</span> <span style="font-size: 1em;">bus tap would be an FPGA. However, at the time, no FPGA was available</span> <span style="font-size: 1em;">that could keep up with the high data rates and more importantly, no FPGA</span> <span style="font-size: 1em;">was available that was certified by the vendor for use with HyperTransport.</span> <span style="font-size: 1em;">Theoretically, a Xilinx Virtex-II FPGA would work for this application, but the product had just been launched and the devices were extremely pricey</span> <span style="font-size: 1em;">and hard to get (today, you can purchase a low-end Virtex-II FPGA for well</span> <span style="font-size: 1em;">under a hundred dollars). The best FPGA that I had on hand at the time</span> <span style="font-size: 1em;">was a Xilinx Virtex-E FPGA that I had previously designed into a prototype</span> <span style="font-size: 1em;">supercomputer network router as part of my thesis. The network router</span> <span style="font-size: 1em;">board used CTT (Center Tap Terminated) signaling for its network inter</span><span style="font-size: 1em;">faces, and also had an Intel StrongArm processor on board for configura</span><span style="font-size: 1em;">tion, control, and debugging purposes.</span></p>

  <p>The challenge therefore boiled down to figuring out how to interface <span style="font-size: 1em;">HyperTransport signals to CTT signals, and how to coax 400 MB/s</span> <span style="font-size: 1em;">performance out of an FPGA that wasn’t intended to run at those speeds.</span></p>

  <p>The HyperTransport signaling convention, it turns out, is a close relative of the more common LVDS (low voltage differential signaling) convention, <span style="font-size: 1em;">specified in the TIA/EIA-644 standard. HyperTransport drivers create a</span> <span style="font-size: 1em;">signal with a differential swing of 600 mV typically, centered around a</span> <span style="font-size: 1em;">common mode voltage of 600 mV. LVDS receivers, on the other hand, can</span> <span style="font-size: 1em;">make sense out of data that has a differential swing of greater than 100 mV</span> <span style="font-size: 1em;">and a common mode voltage anywhere between 50 mV and 2.35 V. So</span> <span style="font-size: 1em;">LVDS receivers are directly compatible with HyperTransport drivers!</span> <span style="font-size: 1em;">(Although the Virtex-E supports a direct interface to LVDS signals, I could not take advantage of this because the Virtex-E parts I had were already</span> <span style="font-size: 1em;">designed into a system that is hard-wired for CTT signals.) If you are</span> <span style="font-size: 1em;">designing your own tap board, the best approach would be to use the</span> <span style="font-size: 1em;">native LVDS capabilities of the FPGA instead of the hack described</span> <span style="font-size: 1em;">here. In addition, the LVDS receiver must be located very close to the</span> <span style="font-size: 1em;">Xbox motherboard in order to not corrupt the target signals. A long</span> <span style="font-size: 1em;">cable would dissipate energy out of the wires and introduce noise and</span> <span style="font-size: 1em;">reflections that might cause the system to cease functioning.</span></p>

  <div class="infobox">
    <h2 id="sigil_toc_id_64"><b class="calibre3">What About Driving Signals onto</b> <b class="calibre3" style="font-size: 1em;">HyperTransport?</b></h2>

    <p>The eavesdropping application described in this chapter <span style="font-size: 1em;">only requires a HyperTransport receiver. Applications such</span> <span style="font-size: 1em;">as “man-in-the-middle” attacks require a device that can</span> <span style="font-size: 1em;">override HyperTransport signals and insert a false bit or two.</span> <span style="font-size: 1em;">Such a device is feasible because HyperTransport, like LVDS,</span> <span style="font-size: 1em;">uses current-mode drivers. In other words, the drivers are</span> <span style="font-size: 1em;">designed to drive only a measured amount of current into</span> <span style="font-size: 1em;">the wire, regardless of the voltage it creates. In a normal</span> <span style="font-size: 1em;">situation, this works perfectly well because the impedance</span> <span style="font-size: 1em;">of the wire transforms the current into a voltage in accor</span><span style="font-size: 1em;">dance with Ohm’s Law. However, currents can sum and</span> <span style="font-size: 1em;">cancel each other out. An antagonistic differential driver</span> <span style="font-size: 1em;">that applies an overdrive current that cancels out the in</span><span style="font-size: 1em;">tended signal can be attached to a HyperTransport line.</span> <span style="font-size: 1em;">This kind of overdrive can be accomplished using the flex</span><span style="font-size: 1em;">ible, programmable I/O provided in FPGAs such as the Xilinx</span> <span style="font-size: 1em;">Virtex-E and Virtex II.</span></p>

    <p>The simplest application of such a bus override device would <span style="font-size: 1em;">be one that modifies the destination of the reset vector as</span> <span style="font-size: 1em;">it is transmitted to the CPU, enabling you to gain control of</span> <span style="font-size: 1em;">the Xbox. The reset vector destination is coded into a single</span> <span style="font-size: 1em;">byte that follows the “jump” opcode located at 0xFFFF.FFF0.</span> <span style="font-size: 1em;">The reset vector is likely transmitted a deterministic number</span> <span style="font-size: 1em;">of clocks from the de-activation of reset, so the timing ele</span><span style="font-size: 1em;">ment for this attack can consist of just a timer that is clocked</span> <span style="font-size: 1em;">by the HyperTransport bus clock and synchronized to a</span> <span style="font-size: 1em;">reset signal. A “man-in-the-middle” attack like this wil de</span><span style="font-size: 1em;">feat even a cryptographically secure public-key boot block</span> <span style="font-size: 1em;">implementation.</span></p>
  </div>

  <p>The solution to the problem of getting the HyperTransport signals to the <span style="font-size: 1em;">FPGA is to use a signal conversion chip. LVDS is a popular standard for</span> <span style="font-size: 1em;">LCD panel interfaces and backplanes used in telecomm systems, so numer</span><span style="font-size: 1em;">ous inexpensive LVDS-to-CMOS converters are available. Of course, the</span> <span style="font-size: 1em;">desired signaling convention is CTT, but a closer look reveals that interfacing CMOS drivers to CTT receivers is actually not a problem. CTT is a current-mode signaling convention that drives +8 mA or -8 mA into a 50 ohm transmission line terminated at 1.5 volts. The receiver is a differential</span> <span style="font-size: 1em;">amplifier that compares the reference termination voltage with the transmission line voltage. In the Virtex-E, a CTT receiver amplifier is specified to work as long as the received voltage swings more than 200 mV up or down from the reference voltage. Most CMOS transmitters driving a CTT</span> <span style="font-size: 1em;">terminated line will have no problem sourcing or sinking 8 mA of current</span> <span style="font-size: 1em;">into a 50 ohm load. Also, CMOS transmitters should have no problem</span> <span style="font-size: 1em;">driving a wire terminated into a fixed voltage. Thus, a standard LVDS to</span> <span style="font-size: 1em;">CMOS converter chip can be used to take the Xbox motherboard’s</span> <span style="font-size: 1em;">HyperTransport signals and feed them into the board I had previously built</span> <span style="font-size: 1em;">for my thesis. The chip I chose was the Texas Instruments SN65LVDS386,</span> <span style="font-size: 1em;">and you can find data sheets for this chip at Texas Instruments’ website.</span></p>

  <p><span style="font-size: 1em;">Attaching the LVDS-to-CMOS converter chip to the board is made</span> <span style="font-size: 1em;">delightfully simple by the clean layout used for the HyperTransport bus on</span> <span style="font-size: 1em;">the Xbox motherboard. Figure 8-1 is a picture of what the HyperTransport</span> <span style="font-size: 1em;">bus traces look like. Notice how all the wires run in parallel and how they are evenly spaced. Some of the wires, such as the clock (TX CK/TX CX* and RX</span> <span style="font-size: 1em;">CK/RX CX*) and the strobe line (TXD8/TXD8* and RXD8/RXD8*), are</span> <span style="font-size: 1em;">even labeled for us with polarity markings! This simple layout enables the</span> <span style="font-size: 1em;">use of an easy-to-engineer tap board.</span></p>

  <p>The tap board contains just the LVDS-to-CMOS converter chip, some <span style="font-size: 1em;">power conditioning circuitry, and a set of traces laid out right up to the edge of the board that are identically spaced to the HyperTransport bus on the Xbox motherboard. For identical spacing and easy alignment and mount</span><span style="font-size: 1em;">ing, I measured the dimensions of these traces using a digital caliper tool.</span> <span style="font-size: 1em;">Figure 8-2 illustrates the dimensions of the HyperTransport bus traces.</span></p>

  <p><img alt="" class="calibre2" src="../Images/index-143_1.png"/><br/></p>

  <p class="caption"><b class="calibre3">Figure 8-1</b>: HyperTransport bus traces as laid out on an Xbox motherboard.</p>

  <p><span style="font-size: 1em;">The measurements were a little tricky to make. My approach was to</span> <span style="font-size: 1em;">measure the overall width of the bus and divide the width by the number</span> <span style="font-size: 1em;">of traces and spaces to get the average expected spacing and trace width.</span> <span style="font-size: 1em;">I then laid out these traces with a PCB CAD program and printed the</span> <span style="font-size: 1em;">layout on paper at a 1:1 scale. I compared the printed traces with the</span> <span style="font-size: 1em;">board traces and made a few adjustments by hand. (Note that many</span> <span style="font-size: 1em;">printers have some small amount of scaling error, so if you are trying</span> <span style="font-size: 1em;">this, calibrate yourself by printing out a few long lines of known length and measuring them. Printers can have different scaling errors along the</span> <span style="font-size: 1em;">horizontal and vertical axes, so be sure to print lines in both directions.)</span></p>

  <p><img alt="figure_8-2" src="../Images/figure_8-2.png" style="width:100%;"/><span style="font-size: 1em;"><br/></span></p>

  <p><b class="calibre3" style="font-size: 1em;">Figure 8-2</b><span style="font-size: 1em;">: Dimensions of the HyperTransport bus traces on the Xbox</span> <span style="font-size: 1em;">motherboard. A “mil” is 1/1000th of an inch or 25.4 microns.</span></p>

  <p>Designing your own boards is fairly easy with the right software. You can <span style="font-size: 1em;">find out more about how to make your own boards by reading the</span> <span style="font-size: 1em;">Appendix C, “Getting Into PCB Layout.”</span></p>

  <p>Once the component selection process was finished, the design and layout <span style="font-size: 1em;">of the HyperTransport tap and signal conversion board took just a few</span> <span style="font-size: 1em;">more hours. A schematic of the board’s design can be seen in Figure 8-6.</span> <span style="font-size: 1em;">The board was then fabricated by an order placed via the Internet. Many</span> <span style="font-size: 1em;">board houses offer affordable, quick-turn board fabrication services that take board designs in Gerber file format via an email or ftp upload. In this case, I had two copies of the board built in five days for a price of $33 per board (see Appendix C, “Getting Into PCB Layout,” for more information on how to build your own boards). This price only includes the price of cutting the board into a square piece. However, I needed the side of the board with the HyperTransport tap to have a special shape that facilitates board mounting without interfering with the existing components on the Xbox</span> <span style="font-size: 1em;">motherboard. I also needed the mating edge of the board to be beveled</span> <span style="font-size: 1em;">such that the board mounts at a slight angle, to simplify the task of</span> <span style="font-size: 1em;">soldering the tap board to the motherboard. I used a belt sander to</span> <span style="font-size: 1em;">manually sculpt the edge into the shape described in Figure 8-3. When</span> <span style="font-size: 1em;">sculpting, the board had to be oriented such that the belt sander’s abrasive belt made contact with the trace side of the board first to prevent the</span> <span style="font-size: 1em;">belt sander from tearing the copper traces off of the board. Be careful</span> <span style="font-size: 1em;">when using a belt sander to sculpt small boards like the tap board — a</span> <span style="font-size: 1em;">belt sander could just as easily sculpt your fingers by accident.</span></p>

  <p class="caption"><b class="calibre3" style="font-size: 1em;"><img alt="figure_8-3" src="../Images/figure_8-3.png" style="width: 100%;"/>Figure 8-3</b><span style="font-size: 1em;">: Shaping of the HyperTransport tap board edge.</span><br/></p>

  <p>After sculpting the beveled edge, all the parts were soldered onto the <span style="font-size: 1em;">board. (See Appendix B, “Soldering Techniques.”)</span></p>

  <p><span style="font-size: 1em;">The finished tap board now had to be attached to the Xbox motherboard.</span> <span style="font-size: 1em;">This critical step was perhaps the most difficult one. First, the Xbox</span> <span style="font-size: 1em;">motherboard was prepared by using a fine grit sandpaper to strip away</span> <span style="font-size: 1em;">the green soldermask, revealing the bright bare copper of the target</span> <span style="font-size: 1em;">traces. Then, these traces were fluxed and a thin coat of solder was</span> <span style="font-size: 1em;">applied using a hot soldering iron tip.</span></p>

  <p>The procedure I used for attaching the tap board to the motherboard is <span style="font-size: 1em;">shown in Figure 8-4. The prepared tap board was tacked onto the</span> <span style="font-size: 1em;">motherboard at the approximate location and angle using a thin (30</span> <span style="font-size: 1em;">AWG) wire soldered between a trace on the tap board and the</span> <span style="font-size: 1em;">motherboard. The tack wire serves only as a temporary aid for holding</span> <span style="font-size: 1em;">the board in place and will be removed, so it does not matter if the wire</span> <span style="font-size: 1em;">bridges multiple traces. Once the wire was attached, I carefully adjusted</span> <span style="font-size: 1em;">the position of the tap board on the motherboard, heating the wire to</span> <span style="font-size: 1em;">release its bond to avoid lifting any of the copper traces. (I used a</span> <span style="font-size: 1em;">microscope to aid in determining the optimal alignment.) Once I was</span> <span style="font-size: 1em;">satisfied with the position of the board, I applied a strong epoxy to the</span> <span style="font-size: 1em;">board joint to hold it all in place. The epoxy should cure and form a</span> <span style="font-size: 1em;">rigid, stiff joint. (Note that some epoxies when applied incorrectly cure</span> <span style="font-size: 1em;">into a gel; this is not acceptable, as the entire mechanical integrity of the joint must come from the epoxy and not the solder joints.) I used Miller-Stephenson Epoxy formula 907, and it sets with enough strength for me to lift the Xbox by the tap board and not disturb the tap connection.</span></p>

  <p><img alt="figure_8-4" src="../Images/figure_8-4.png" style="width: 100%;"/><br/></p>

  <p class="caption"><b class="calibre3">Figure 8-4</b>: Tap board soldering procedure.</p>

  <p><img alt="" class="calibre2" src="../Images/index-146_1.png" style="height: auto; width: auto;"/></p>

  <p class="caption"><b class="calibre3">Figure 8-5</b>: HyperTransport tap board mounted on the Xbox motherboard.</p>

  <p><br/></p>

  <p>Once the epoxy had cured, I removed the temporary tack wire that was <span style="font-size: 1em;">used to hold the tap board in place, and cleaned the bare mated traces</span> <span style="font-size: 1em;">with a bit of solderwick and flux. The last step of soldering the tap board traces to the bare motherboard traces was now no different from</span> <span style="font-size: 1em;">soldering any surface mount component onto a board; most of the</span> <span style="font-size: 1em;">standard techniques described in Appendix B applied directly to this</span> <span style="font-size: 1em;">situation. Figure 8-5 shows what the finished assembly looks like.</span></p>

  <h4 id="sigil_toc_id_65"><b class="calibre3">Building the Data Logger</b></h4>

  <p>The second challenge of eavesdropping the HyperTransport bus is <span style="font-size: 1em;">acquiring or building a logging device that can keep up with the 400 MB/</span><span style="font-size: 1em;">s data rate of the bus. Considering my budget, I decided that my only</span> <span style="font-size: 1em;">option was to build a logger, as buying any tools with sufficient perfor</span><span style="font-size: 1em;">mance for this job was well outside of my budget.</span></p>

  <p><img alt="" class="calibre2" src="../Images/index-147_1.png" style="height: auto; width: auto;"/></p>

  <p class="caption"><b class="calibre3">Figure 8-6</b><span style="font-size: 1em;">: Schematic of the HyperTransport tap board.</span><br/></p>

  <p><span style="font-size: 1em;">In building the logging device, I had settled on using a Virtex-E FPGA</span> <span style="font-size: 1em;">that was integrated into a board that I had previously built. However, the</span> <span style="font-size: 1em;">one problem with using the Virtex-E FPGA is that the performance of</span> <span style="font-size: 1em;">the FPGA (as specified in the databook) is insufficient to keep up with</span> <span style="font-size: 1em;">the HyperTransport bus. Fortunately, FPGAs overclock well because</span> <span style="font-size: 1em;">their manufacturing margin is very conservative, and because FPGA</span> <span style="font-size: 1em;">performance is largely limited by signal propagation delays in the</span> <span style="font-size: 1em;">configurable wiring fabric. As a result, some key performance-limiting</span> <span style="font-size: 1em;">paths can be manually identified and compensated using soft delay lines</span> <span style="font-size: 1em;">and selectively inverted clocks. The most performance sensitive blocks</span> <span style="font-size: 1em;">can be hand-placed to optimize the delays, while the compiler and</span> <span style="font-size: 1em;">automated place-and-route tool handle the non-critical parts of the</span> <span style="font-size: 1em;">circuit. Figure 8-7 shows the overall design that was used to capture the</span> <span style="font-size: 1em;">data on the HyperTransport bus.</span></p>

  <p><img alt="figure_8-7" src="../Images/figure_8-7.png" style="width: 100%"/><br/></p>

  <p class="caption"><b class="calibre3" style="font-size: 1em;">Figure 8-7</b><span style="font-size: 1em;">: Block diagram of the data logger built in the Xilinx Virtex-E FPGA.</span><br/></p>

  <p><span style="font-size: 1em;">The design is fairly simple in concept: take the high speed data off of the HyperTransport bus and clock it into four phases of a quarter speed clock, creating a data stream that is four times slower but four times wider. This confines all hand-placing and tweaking to just the first few input flip flops.</span> <span style="font-size: 1em;">Next, realign the data using a set of delays and rotators, and store the data one piece at a time inside a first in, first out (FIFO) memory. The signal that triggers the start of FIFO capture is generated by a timer-comparator that starts counting up from first reset. Long windows of data can be captured by concatenating the results of multiple runs, each with the capture trigger point delayed from the previous. A later optimization applied to the trigger circuit is a “do not store zeros” (DNSZ) function. In the DNSZ mode, data consisting of all 0’s is not stored in the FIFO. This is helpful in culling out all of the idle data on the HyperTransport bus. The resulting data traces are a time-stamped series of 32-bit words.</span></p>

  <p>The most difficult part of the FPGA data logger design was calibrating the <span style="font-size: 1em;">delays on the input paths. Delay calibration was accomplished by using an</span> <span style="font-size: 1em;">oscilloscope to probe a small window of data on the HyperTransport bus.</span> <span style="font-size: 1em;">Wire delays and byte-wide rotations were tweaked until the probed data</span> <span style="font-size: 1em;">matched the log data. This process was aided by the fact that during idle</span> <span style="font-size: 1em;">times, a common sequence of commands was repeated on the bus every</span> <span style="font-size: 1em;">few hundred microseconds, which served as the calibration reference.</span></p>

  <h4 id="sigil_toc_id_66"><b class="calibre3">Determining the Bus Order and Polarity</b></h4>

  <p>The final challenge after logging the data is figuring out the order of the signals on the HyperTransport bus and their polarities. Note that while the two most important signals of the HyperTransport bus on the Xbox motherboard are labeled for us, the remaining eight data lines have ambigu<span style="font-size: 1em;">ous polarity and bit ordering.</span></p>

  <p>The correct polarity of the eight data signals was determined by observ<span style="font-size: 1em;">ing the idle bus data bit pattern. The HyperTransport bus spends most of</span> <span style="font-size: 1em;">its time in an idle state, so this is not difficult. If the idle pattern is supposed to be all 0s, then any bit position that shows up as a 1 has its</span> <span style="font-size: 1em;">polarity inverted. This was corrected in hardware by inserting an inver</span><span style="font-size: 1em;">sion term in the FPGA on the appropriate wire.</span></p>

  <p><span style="font-size: 1em;">Determining the correct bit ordering is much more difficult, however.</span> <span style="font-size: 1em;">Operating under the assumption that data coming across the</span> <span style="font-size: 1em;">HyperTransport bus must in large part come from the FLASH ROM, a 1’s</span> <span style="font-size: 1em;">count was performed on a byte by byte basis. The theory is that the bus</span> <span style="font-size: 1em;">ordering is a pure permutation, meaning that the number of binary 1’s in a byte is preserved between the FLASH ROM data and the data captured by</span> <span style="font-size: 1em;">the logger. Patterns of 1’s counts were lined up against each other to identify candidate regions of correspondence between FLASH ROM and logged</span> <span style="font-size: 1em;">data. Fortunately, the first few words to come across the HyperTransport</span> <span style="font-size: 1em;">bus are some chipset-specific initializations that are located near the bottom of FLASH memory, so finding a set of patterns that lined up correctly did not take too long. A set of bytes from each ROM and the logger were tabulated, and, with the aid of a short C program, columns of bits were</span> <span style="font-size: 1em;">transposed until an ordering was found that made all of the row values</span> <span style="font-size: 1em;">match up.</span></p>

  <h2 id="sigil_toc_id_67"><b class="calibre3">Making Sense of the Captured Data</b></h2>

  <p>Now that valid data traces have been extracted, the problem remains of <span style="font-size: 1em;">deciphering the meaning of it all. Before doing so, let us recap what we</span> <span style="font-size: 1em;">know about the data we have collected thus far.</span></p>

  <p>• <b class="calibre3">Temporal correlation.</b> The logged data, on a macroscopic scale, <span style="font-size: 1em;">should have a strong time correlation to the expected sequence of</span> <span style="font-size: 1em;">initialization events: jam table initialization, followed by a decryption</span> <span style="font-size: 1em;">step, fol owed by execution from RAM. The regions of the log traces</span> <span style="font-size: 1em;">that correspond to each of these events can be determined by just</span> <span style="font-size: 1em;">observing when large bursts of activity happen, followed by regions</span> <span style="font-size: 1em;">of silence.</span></p>

  <p>• <b class="calibre3">Transaction lengths.</b> Since the Pentium processor has both a <span style="font-size: 1em;">data and an instruction cache, al fetches on the HyperTransport bus</span> <span style="font-size: 1em;">to FLASH ROM or the hidden boot ROM should come in even-</span><span style="font-size: 1em;">length bursts of traffic.</span></p>

  <p>• <b class="calibre3">Guaranteed ordering.</b> The collected data is time stamped and <span style="font-size: 1em;">chronologically correct, so if the first instruction fetched in the reset</span> <span style="font-size: 1em;">vector can be identified in the data logs, the position and structure</span> <span style="font-size: 1em;">of the remainder of the instructions can be deduced.</span> <span style="font-size: 1em;">Initially, I neglected to check the macroscopic organization of data coming across the HyperTransport bus, and this caused me some problems. The</span> <span style="font-size: 1em;">simplified block diagram of the logging machine in Figure 8-7 would have</span> <span style="font-size: 1em;">the log FIFO resetting each time the HyperTransport bus is reset. This</span> <span style="font-size: 1em;">seems like a fine idea, however I originally incorrectly assumed that the</span> <span style="font-size: 1em;">HyperTransport bus is reset only once upon the application of power. In</span> <span style="font-size: 1em;">reality, the HyperTransport bus is reset a second time following the jam table initialization step. Thus, when I first started looking at traces, all I saw was the encrypted data plus a smattering of code, none of which could really be lined up in any logical fashion with a boot vector.</span></p>

  <p>Imagine how disappointing that was! I took a step back and observed the <span style="font-size: 1em;">HyperTransport bus events on an oscilloscope with the time scale set at</span> <span style="font-size: 1em;">the milliseconds per division. I observed that there was an earlier reset</span> <span style="font-size: 1em;">pulse, and after adjusting the trigger mechanism to catch only the first</span> <span style="font-size: 1em;">pulse, the boot instruction was easy to identify. The sixteen bytes at</span> <span style="font-size: 1em;">0xFFFF.FFF0 in the secret ROM happened to be identical to the same</span> <span style="font-size: 1em;">sixteen bytes in the FLASH ROM. From that point, I tracked the current</span> <span style="font-size: 1em;">value of the program counter by performing a lot of grungy tracing and</span> <span style="font-size: 1em;">disassembling with bookkeeping, so that I could place each instruction</span> <span style="font-size: 1em;">block at the correct location in memory. Every cache line fetch consisted</span> <span style="font-size: 1em;">of 16 or 32 consecutive bytes of memory, resulting in a distinctive data</span> <span style="font-size: 1em;">logger time stamp pattern which aided the reverse engineering process.</span> <span style="font-size: 1em;">After a few hours of sifting through traces looking for cache lines, I had</span> <span style="font-size: 1em;">collected enough code to feed into a disassembler. (See the sidebar on</span> <span style="font-size: 1em;">software analysis tools for more information about the disassembler that</span> <span style="font-size: 1em;">I used.)</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3">More Tools of the Trade: Software</b> <b class="calibre3" style="font-size: 1em;">Analysis Tools</b></h2>

    <p>Inevitably at some point in your hacking experiences, you <span style="font-size: 1em;">will come across a need to disassemble some assembly</span> <span style="font-size: 1em;">language code. I was introduced to an excellent tool for</span> <span style="font-size: 1em;">this job by some fel ow software hackers in January 2002</span> <span style="font-size: 1em;">while I was reverse engineering the Xbox security. The tool is</span> <span style="font-size: 1em;">called “IDA Pro” by Ilfak Guilfanov, sold by DataRescue Cor</span><span style="font-size: 1em;">poration (http://www.datarescue.com/idabase/). IDA Pro is ca</span><span style="font-size: 1em;">pable of disassembling not only x86 code, but a huge vari</span><span style="font-size: 1em;">ety of embedded processors’ code as well. The quality of</span> <span style="font-size: 1em;">IDA Pro’s output is also very high: Code segments are auto</span><span style="font-size: 1em;">matically annotated and organized for readability. IDA Pro</span> <span style="font-size: 1em;">also features a vast array of useful and fun tools. Some of my</span> <span style="font-size: 1em;">favorites include the ability to automatically pattern match</span> <span style="font-size: 1em;">code library signatures to function calls, and the ability to</span> <span style="font-size: 1em;">follow jumps at the press of a key.</span></p>

    <p><span style="font-size: 1em;">Another tool that was quite handy during the code analy</span><span style="font-size: 1em;">sis was HackMan. HackMan is freeware from</span> <span style="font-size: 1em;">TechnoLogismiki Corporation (http://www.technologismiki.com/</span><span style="font-size: 1em;">hackman/). It is nominally a “hex editor,” i.e., a file editor that</span> <span style="font-size: 1em;">allows you to manipulate binary data directly, but it has a</span> <span style="font-size: 1em;">lot of unique capabilities that go far beyond simple editing.</span> <span style="font-size: 1em;">For example, HackMan has a built in disassembler. The</span> <span style="font-size: 1em;">disassembler is not as powerful as IDA Pro, but it is interactive</span> <span style="font-size: 1em;">with the hex editor. This allowed me to rapidly test candi</span><span style="font-size: 1em;">date cache lines for valid code while tracing through the</span> <span style="font-size: 1em;">data logs, while assembling the final binary image of the</span> <span style="font-size: 1em;">secret ROM.</span></p>
  </div>

  <p>After a bit of data massaging and a good bit of help from some on-line <span style="font-size: 1em;">hacker friends, we had determined that the cipher being used was RC-4/128.</span> <span style="font-size: 1em;">RC-4 is a symmetric cipher, and the key had to be stored somewhere in the</span> <span style="font-size: 1em;">Xbox, but I was having difficulty trying to identify the key in the data</span> <span style="font-size: 1em;">stream. The key seemed to span cache line fetches that were shared with</span> <span style="font-size: 1em;">pieces of code which at the time I could not map to a definitive location.</span></p>

  <p><span style="font-size: 1em;">As the night was drawing long and I was growing weary of staring at hex</span> <span style="font-size: 1em;">digits, I decided to try something that should never have worked. I adapted an RC-4 decryption program to decrypt the target image in FLASH ROM</span> <span style="font-size: 1em;">using a key that was derived from a sliding window within the data log. This is a fairly brute-force approach, as it requires tens of thousands of</span> <span style="font-size: 1em;">decryptions (one for every byte in the log) to search the whole data stream. I automated the process by feeding the output of the RC-4 decryption into a histogram routine. If the key did not match, the output should be statisti</span><span style="font-size: 1em;">cally “white.” In other words, a histogram of the output should show that</span> <span style="font-size: 1em;">all values are roughly equally probable for a non-matching key. However, if the key was the correct one, the histogram should be biased, with some</span> <span style="font-size: 1em;">values being significantly more popular than al the other values.</span></p>

  <p>Eventually I finished the program, trykeys, to perform this brute-force <span style="font-size: 1em;">search around 5 AM. Bleary-eyed and tired, I decided to give the program a</span> <span style="font-size: 1em;">test run before calling it quits for the night. Imagine the dumbfounded look on my face as I watched the output of the program as it crunched away at</span> <span style="font-size: 1em;">the candidate data stream:</span></p>
  <pre>$ ./trykeys.exe ms4.bin binout.full
.............................................................
.....................found possible key combo: avg 96, min 5,
offset 8745..................................................
..............................................................</pre>

  <p>The FLASH ROM image is named ms4.bin, and the binary data logger <span style="font-size: 1em;">trace is named binout.full. The trykeys program had identified a</span> <span style="font-size: 1em;">statistically different histogram (with an average value of 96 and a minimum bucket height of 5) for a decryption of the ROM image using, as a test key, data starting at offset 8745. I then isolated the candidate key from the data stream and analyzed the decrypted output using the candidate key. The output looked like real, valid code. I had found the key in a hidden boot</span> <span style="font-size: 1em;">sector, stored in the Southbridge chip! A few days later after getting</span> <span style="font-size: 1em;">some sleep and catching up on my schoolwork, I finished doing a proper</span> <span style="font-size: 1em;">analysis of the data stream and I had patched together an image of the</span> <span style="font-size: 1em;">entire secret boot sector.</span></p>

  <p>With the secret boot code’s RC-4 key in hand, I had the ability to generate FLASH ROM images that could be accepted by any Xbox at the time. The <span style="font-size: 1em;">implication is that the entire trust mechanism of the Xbox could be violated</span> <span style="font-size: 1em;">by just overriding or replacing the ROM on the Xbox motherboard. This</span> <span style="font-size: 1em;">is accomplished by using the test structures provided by Microsoft to</span> <span style="font-size: 1em;">override the FLASH ROM during manufacturing for test and diagnostic</span> <span style="font-size: 1em;">purposes. Xboxes must roll off the production line at a rate of one every couple seconds, therefore Microsoft had designed a set of quick-connect</span> <span style="font-size: 1em;">test points that enable FLASH ROM override. The ability to boot to an</span> <span style="font-size: 1em;">alternate ROM image is valuable for running production test programs</span> <span style="font-size: 1em;">using the native Xbox CPU. The physical structure of the Xbox LPC</span> <span style="font-size: 1em;">interface implementation allows users, as well as Microsoft’s contract</span> <span style="font-size: 1em;">manufacturer, to install a properly designed FLASH ROM override</span> <span style="font-size: 1em;">device without any soldering.</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3">The Legal Challenges of Hacking</b></h2>

    <p>In retrospect, hacking the Xbox was less challenging tech<span style="font-size: 1em;">nically than it was socially and legally. After retrieving the</span> <span style="font-size: 1em;">secret key from the Southbridge chip, I met with my re</span><span style="font-size: 1em;">search advisor, Prof. Tom Knight, at the MIT Artificial Intelli</span><span style="font-size: 1em;">gence Laboratory to discuss my results. My advisor pointed</span> <span style="font-size: 1em;">out that my work could possibly be in violation of the DMCA,</span> <span style="font-size: 1em;">so prior to publishing we contacted MIT’s legal department</span> <span style="font-size: 1em;">for counsel. MIT Legal eventually responded that the DMCA</span> <span style="font-size: 1em;">made the case too risky and that I had to publish as an</span> <span style="font-size: 1em;">individual, despite the fact that my work was conducted</span> <span style="font-size: 1em;">at MIT as a part of my research in computer architecture. I</span> <span style="font-size: 1em;">despaired, thinking I would never be able to afford a law</span><span style="font-size: 1em;">yer and that I would never be able to publish my results,</span> <span style="font-size: 1em;">but then Prof. Hal Abelson connected me with the Elec</span><span style="font-size: 1em;">tronic Frontier Foundation (EFF). As a result, Lee Tien and Joe</span> <span style="font-size: 1em;">Liu from the EFF and Boston College were assigned to help</span> <span style="font-size: 1em;">me publish my work. Months of deliberation and position</span><span style="font-size: 1em;">ing ensued. It was a battle fought on two fronts: we had to</span> <span style="font-size: 1em;">convince MIT to accept the work, while trying to appease</span> <span style="font-size: 1em;">Microsoft at the same time. After four months, MIT capitu</span><span style="font-size: 1em;">lated after an encouraging review of my work by Microsoft,</span> <span style="font-size: 1em;">and the overwhelming support of my laboratory colleagues</span> <span style="font-size: 1em;">and professors. MIT decided that I could publish my work as</span> <span style="font-size: 1em;">a student of MIT, instead of as an independent entity. The</span> <span style="font-size: 1em;">result of five months of legal stalemate was an AI Labora</span><span style="font-size: 1em;">tory technical memorandum, followed by an academic</span> <span style="font-size: 1em;">presentation of the work at the conference on Crypto</span><span style="font-size: 1em;">graphic Hardware in Embedded Systems (CHES) in August</span> <span style="font-size: 1em;">2002.</span></p>

    <p>While the ending of this story may be happy, things could <span style="font-size: 1em;">have been very different if not for the support of my advisor,</span> <span style="font-size: 1em;">my laboratory and the talented lawyers at the EFF. The</span> <span style="font-size: 1em;">DMCA draws a fuzzy line between a rogue hacker and a</span> <span style="font-size: 1em;">legitimate researcher; perhaps without MIT’s endorsement,</span> <span style="font-size: 1em;">I would not have been able to satisfy the DMCA’s research</span> <span style="font-size: 1em;">exemption and my research would never have been pub</span><span style="font-size: 1em;">lished, or it might have been published and been con</span><span style="font-size: 1em;">tested by Microsoft. Free speech applies to all, not just to</span> <span style="font-size: 1em;">those who are lucky enough to sit in the ivory towers of</span> <span style="font-size: 1em;">esteemed academic institutions. There are countless others</span> <span style="font-size: 1em;">who were also working on the Xbox with excellent results,</span> <span style="font-size: 1em;">but their voices shal remain forever silent behind the cur</span><span style="font-size: 1em;">tain of the DMCA.</span></p>
  </div>

  <p>Clearly, the ability to override the trust mechanism used in the Xbox has <span style="font-size: 1em;">sticky legal implications. While</span> <i class="calibre4" style="font-size: 1em;">my</i> <span style="font-size: 1em;">intent was mostly to satisfy my curiosity and secondly to run my own code on the Xbox under my fair-use rights, other people have a desire to copy games and to modify and redistribute</span> <span style="font-size: 1em;">Microsoft’s copyrighted kernel code. Because a cipher is blind to its application, the extraction of the RC-4 key enables all applications equally. As a result, I contacted the Electronic Frontier Foundation (EFF) to help me sort through the legal issues. The legal process is a slow and ponderous one. I had extracted the key in February, 2002, and it took until almost June before I was allowed to publish the results of my study in the appropriate</span> <span style="font-size: 1em;">academic forum.</span></p>

  <p>Never had I experienced so much ado over 128 bits. The Digital Millen<span style="font-size: 1em;">nium Copyright Act (DMCA) of 1998 has eternally changed the land</span><span style="font-size: 1em;">scape of hardware hacking. Reverse engineering used to be a protected</span> <span style="font-size: 1em;">act, deemed part of what makes a marketplace healthy and competitive.</span> <span style="font-size: 1em;">Now, tinkering with and bypassing a cryptographic security system to</span> <span style="font-size: 1em;">exercise your fair-use rights in the privacy of your own home could serve</span> <span style="font-size: 1em;">you thousands of dollars of fines and lawsuits. I strongly recommend that you read Chapter 12, “Caveat Hacker,” so that you understand your legal</span> <span style="font-size: 1em;">rights and responsibilities.</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3">Security Through Obscurity</b></h2>

    <p>The technique used by Microsoft in the first version of the <span style="font-size: 1em;">Xbox security is an excellent example of security through</span> <span style="font-size: 1em;">obscurity. A strong cipher, RC-4/128, was used to encrypt</span> <span style="font-size: 1em;">the ROM image in order to prevent people from analyzing</span> <span style="font-size: 1em;">the ROM contents or from creating their own ROMs. How</span><span style="font-size: 1em;">ever, RC-4/128 is a symmetric cipher, which means that the</span> <span style="font-size: 1em;">Xbox must contain a decryption key also usable as an</span> <span style="font-size: 1em;">encryption key. This decryption/encryption key is the im</span><span style="font-size: 1em;">portant piece of information buried inside the secret boot</span> <span style="font-size: 1em;">ROM. Hiding this key is security through obscurity: once the</span> <span style="font-size: 1em;">key is found, the cipher is moot and all security is lost.</span></p>

    <p><span style="font-size: 1em;">True security would require that the user have access to</span> <span style="font-size: 1em;">every single piece of the Xbox and still be unable to en</span><span style="font-size: 1em;">crypt their own valid FLASH ROM image. This implies that</span> <span style="font-size: 1em;">some secret must be kept outside of the Xbox. Public-key</span> <span style="font-size: 1em;">cryptography was invented for precisely this scenario. If</span> <span style="font-size: 1em;">Microsoft had used a public-key cipher to encrypt or sign</span> <span style="font-size: 1em;">the Xbox boot code, then knowing the entire contents of</span> <span style="font-size: 1em;">the secure boot ROM would be useless, since the main</span> <span style="font-size: 1em;">secret, Microsoft’s private key, remains safely out of our reach</span> <span style="font-size: 1em;">in a vault somewhere in Redmond, Washington.</span></p>
  </div>

  <p><span style="font-size: 1em;">There is an upside, however. The next chapter introduces the findings of</span> <span style="font-size: 1em;">my colleagues, many of which include the discovery of back doors in the</span> <span style="font-size: 1em;">Xbox initialization sequence. These backdoors enable you to run your own</span> <span style="font-size: 1em;">code on the Xbox without enabling access to Microsoft’s copyrighted works,</span> <span style="font-size: 1em;">and without enabling the copying of games. The next chapter will also</span> <span style="font-size: 1em;">introduce Xbox security version 1.1, which was cracked in just a few days by Andy Green in the UK.</span></p>
</body></html>