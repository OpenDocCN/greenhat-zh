["```\nif (subtotal < 0.0) then\n   subtotal = 0.0\nend\n```", "```\nif aDay == 'Saturday' or aDay == 'Sunday'\n   daytype = 'weekend'\nelse\n   daytype = 'weekday'\nend\n```", "```\nif x == 1 then puts( 'ok' ) end    # with 'then'\nif x == 1 puts( 'ok' ) end         # syntax error!\n```", "```\nif x == 1 : puts( 'ok' ) end    # This works with Ruby 1.8 only\n```", "```\nworking_overtime = true\nif aDay == 'Saturday' or aDay == 'Sunday' and not working_overtime\n   daytype = 'holiday'\n   puts( \"Hurrah!\" )\nelse\n   daytype = 'working day'\nend\n```", "```\nif aDay == 'Saturday' or (aDay == 'Sunday' and not working_overtime)\n```", "```\nif aDay == 'Saturday' or aDay == 'Sunday' and not working_overtime\n   daytype = 'holiday'\nend\n```", "```\nif aDay == 'Saturday' || aDay == 'Sunday' &&  !working_overtime\n   daytype = 'holiday'\nend\n```", "```\n!(1==1)         #=> false\n1!=1            #=> false\n```", "```\nnot( 1==1 )        #=> false\n```", "```\nwhile input != 'q' do\n   puts(\"Enter a number between 1 and 1000 (or 'q' to quit)\")\n   print(\"?- \")\n   input = gets().chomp()\n   if input == 'q'\n      puts( \"Bye\" )\n   elsif input.to_i > 800\n      puts( \"That's a high rate of pay!\" )\n   elsif input.to_i <= 800\n      puts( \"We can afford that\" )\n   end\nend\n```", "```\nif input == 'q'\n   puts( \"Bye\" )\nelsif input.to_i > 800 && input.to_i <= 1000\n   puts( \"That's a high rate of pay!\" )\nelsif input.to_i <= 800 && input.to_i > 0\n   puts( \"We can afford that\" )\nelse\n   puts( \"I said: Enter a number between 1 and 1000!\" )\nend\n```", "```\n*`< Test Condition >`* ? *`<if true do this>`* : *`<else do this>`*\n```", "```\nx == 10 ? puts(\"it's 10\") : puts( \"it's some other number\" )\n```", "```\n(aDay == 'Saturday' or aDay == 'Sunday') ?\n   daytype = 'weekend' :\n   daytype = 'weekday'\n```", "```\ndef showDay( i )\n   if i == 1 then puts(\"It's Monday\" )\n   elsif i == 2 then puts(\"It's Tuesday\" )\n   elsif i == 3 then puts(\"It's Wednesday\" )\n   elsif i == 4 then puts(\"It's Thursday\" )\n   elsif i == 5 then puts(\"It's Friday\" )\n   elsif (6..7) === i then puts( \"Yippee! It's the weekend! \" )\n   else puts( \"That's not a real day!\" )\n   end\nend\n```", "```\n(6..7) === i\n```", "```\n(6..7).include?(i)\n```", "```\nunless aDay == 'Saturday' or aDay == 'Sunday'\n   daytype = 'weekday'\nelse\n   daytype = 'weekend'\nend\n```", "```\nif !(aDay == 'Saturday' or aDay == 'Sunday')\n   daytype = 'weekday'\nelse\n   daytype = 'weekend'\nend\n```", "```\nwhile tired do sleep end\n```", "```\nsleep while tired\n```", "```\nsleep if tired\n\nbegin\n   sleep\n   snore\nend if tired\n\nsleep unless not tired\n\nbegin\n   sleep\n   snore\nend unless not tired\n```", "```\nputs( \"somevar = #{somevar}\" ) if DEBUG\n```", "```\ncase( i )\n   when 1 then puts(\"It's Monday\" )\n   when 2 then puts(\"It's Tuesday\" )\n   when 3 then puts(\"It's Wednesday\" )\n   when 4 then puts(\"It's Thursday\" )\n   when 5 then puts(\"It's Friday\" )\n   when (6..7) then puts( \"Yippee! It's the weekend! \" )\n   else puts( \"That's not a real day!\" )\nend\n```", "```\nObject.constants\n```", "```\nRUBY_VERSION = \"1.8.7\"\nRUBY_VERSION = \"2.5.6\"\n```", "```\nputs Math::PI    #=> 3.141592653589793\nMath::PI = 100   #=> warning: already initialized constant PI\nputs Math::PI    #=> 100\n```", "```\nwhen 1 : puts(\"It's Monday\" )  # This works in Ruby 1.8 only!\n```", "```\ndef showDay( i )\n    case( i )\n    when 5 then puts(\"It's Friday\" )\n        puts(\"...nearly the weekend!\")\n    when 6 then puts(\"It's Saturday!\" )\n        # the following never executes\n    when 5 then puts( \"It's Friday all over again!\" )\n    end\nend\n\nshowDay( 5 )\nshowDay( 6 )\n```", "```\nIt's Friday\n...nearly the weekend!\nIt's Saturday!\n```", "```\nwhen 6, 7 then puts( \"Yippee! It's the weekend! \" )\n```", "```\ncase( i + 1 )\n```", "```\nwhen 1, 'Monday', 'Mon' then puts( \"Yup, '#{i}' is Monday\" )\n```", "```\ncase( i )\n    when 1 then puts(\"It's Monday\" )\n    when 2 then puts(\"It's Tuesday\" )\n    when 3 then puts(\"It's Wednesday\" )\n    when 4 then puts(\"It's Thursday\" )\n    when 5 then puts(\"It's Friday\" )\n          puts(\"...nearly the weekend!\")\n    when 6, 7\n          puts(\"It's Saturday!\" ) if i == 6\n          puts(\"It's Sunday!\" ) if i == 7\n          puts( \"Yippee! It's the weekend! \" )\n          # the following never executes\n    when 5 then puts( \"It's Friday all over again!\" )\n    else puts( \"That's not a real day!\" )\nend\n```", "```\nwhen (6..7) then puts( \"Yippee! It's the weekend! \" )\n```", "```\nsalary = 2000000\nseason = 'summer'\n\nhappy = case\n    when salary > 10000 && season == 'summer' then\n        puts( \"Yes, I really am happy!\" )\n        'Very happy'\n    when salary > 500000 && season == 'spring' then 'Pretty happy'\n    else puts( 'miserable' )\nend\n\nputs( happy ) #=> 'Very happy'\n```", "```\n# Example 1\nif ( 1==3 ) and (2==1) || (3==3) then\n   puts('true')\nelse\n   puts('false')\nend\n\n# Example 2\nif ( 1==3 ) and (2==1) or (3==3) then\n   puts('true')\nelse\n   puts('false')\nend\n```", "```\n# Example 1 (b) - now returns true\nif (( 1==3 ) and (2==1)) || (3==3) then\n   puts('true')\nelse\n   puts('false')\nend\n\n# Example 2 (b) - now returns false\nif ( 1==3 ) and ((2==1) or (3==3)) then\n   puts('true')\nelse\n   puts('false')\nend\n```", "```\nputs( (not( 1==1 )) )                # This is okay\nputs( not( 1==1 ) )                  # Syntax error in Ruby 1.8\n                                     # but okay in Ruby 1.9\n\nputs( true && true && !(true) )      # This is okay\nputs( true && true and !(true) )     # This is a syntax error\n\nputs( ((true) and (true)) )          # This is okay\nputs( true && true )                 # This is okay\nputs( true and true )                # This is a syntax error\n```", "```\n# think of this as a block called :done\ncatch( :done ){\n   # some code here\n}\n\n# and this is a block called :finished\ncatch( :finished ) do\n   # some code here\nend\n```", "```\ncatch( :finished) do\n   print( 'Enter a number: ' )\n   num = gets().chomp.to_i\n   if num == 0 then\n      throw :finished # if num is 0, jump out of the block\n   end\n      # Here there may be hundreds of lines of\n      # calculations based on the value of num\n      # if num is 0 this code will be skipped\nend\n      # the throw method causes execution to\n      # jump to here - outside of the block\nputs( \"Finished\" )\n```", "```\ndef dothings( aNum )\n   i = 0\n   while true\n      puts( \"I'm doing things...\" )\n      i += 1\n      throw( :go_for_tea ) if (i == aNum )\n                        # throws to end of go_to_tea block\n   end\nend\n\ncatch( :go_for_tea ){   # this is the :go_to_tea block\n      dothings(5)\n}\n```", "```\ncatch( :finished) do\n   print( 'Enter a number: ' )\n   num = gets().chomp.to_i\n   if num == 0 then throw :finished end\n      puts( 100 / num )\n\n   catch( :go_for_tea ){\n      dothings(5)\n   }\n\n   puts( \"Things have all been done. Time for tea!\" )\nend\n```"]