["```\n  #!/usr/bin/env ruby\n  # factorial1.rb\n\n  class Integer\n\n    def fact()\n❶     return 1 if (self.zero?) or (self == 1)\n❷     return self * (self-1).fact\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # fibonacci1.rb\n\n  class Integer\n\n    def fib()\n❸     return 0 if (self.zero?)\n      return 1 if self == 1\n❹     return (self-1).fib + (self-2).fib\n    end\n\n  end\n```", "```\n$ irb -r factorial1.rb -r fibonacci1.rb\nirb(main):001:0> 3.fact\n=> 6\nirb(main):002:0> 4.fact\n=> 24\nirb(main):003:0> 5.fact\n=> 120\n```", "```\nirb(main):004:0> 3.fib\n=> 2\nirb(main):005:0> 4.fib\n=> 3\nirb(main):006:0> 5.fib\n=> 5\n```", "```\n  #!/usr/bin/env ruby\n  # factorial2.rb\n\n  class Integer\n\n    def fact()\n❺     return 1 if [0, 1].include?(self)\n      return self * (self-1).fact\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # fibonacci2.rb\n\n  class Integer\n\n    def fib()\n❺     return self if [0, 1].include?(self)\n      return (self-1).fib + (self-2).fib\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # factorial3.rb\n\n  class Integer\n\n❻   def fact(returns1 = [0, 1])\n      return 1 if returns1.include?(self)\n❼     return self * (self-1).fact(returns1)\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # fibonacci3.rb\n\n  class Integer\n\n❻   def fib(returns_self = [0, 1])\n      return self if returns_self.include?(self)\n❼     return (self-1).fib(returns_self) + (self-2).fib(returns_self)\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # factorial4.rb\n\n  class Integer\n\n❽   RETURNS_1_FOR_FACTORIAL = [0, 1]\n\n    def fact()\n      return 1 if RETURNS_1_FOR_FACTORIAL.include?(self)\n      return self * (self-1).fact\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # fibonacci4.rb\n\n  class Integer\n\n❽   RETURNS_SELF = [0, 1]\n\n    def fib()\n      return self if RETURNS_SELF.include?(self)\n      return (self-1).fib() + (self-2).fib()\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # factorial5.rb\n\n  class Integer\n\n❾   @@factorial_results = [1, 1] # Both 0 and 1 have a value of 1\n\n    def fact()\n❿     @@factorial_results[self] ||= self * (self-1).fact    *Memoization*\n    end\n\n    def show_mems()\n      @@factorial_results.inspect\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # fibonacci5.rb\n\n  class Integer\n\n❾   @@fibonacci_results = [1, 1] # Both 0 and 1 have a value of 1\n\n    def fib()\n❿     @@fibonacci_results[self] ||= (self-1).fib + (self-2).fib\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # test_opts.rb\n\n  =begin comment\n  Run this without warnings to avoid messages about method redefinition,\n  which we are doing intentionally for this testing script.\n  =end\n\n❶ require 'benchmark'    *Benchmark Module*\n  include Benchmark\n\n❷   FUNC_OF_FILE = {\n      'factorial' => 'fact',\n      'fibonacci' => 'fib',\n    }\n\n    UPPER_OF_FILE = {\n      'factorial' => 200,\n      'fibonacci' => 30,\n    }\n\n❸ ['factorial', 'fibonacci'].each do |file|\n\n❹   (1..5).to_a.each do |num|\n❺     require \"#{file}#{num}\"\n      upper = UPPER_OF_FILE[file]\n\n❻     bm do |test|\n\n❼       test.report(\"#{file}#{num}\") do\n❽         upper.send(FUNC_OF_FILE[file])\n        end\n\n      end\n\n    end\n\n  end\n```", "```\n      user     system      total        real\nfactorial1  0.016667   0.000000   0.016667 (  0.002705)\n      user     system      total        real\nfactorial2  0.000000   0.000000   0.000000 (  0.001517)\n      user     system      total        real\nfactorial3  0.000000   0.000000   0.000000 (  0.001532)\n      user     system      total        real\nfactorial4  0.000000   0.000000   0.000000 (  0.001491)\n      user     system      total        real\nfactorial5  0.000000   0.000000   0.000000 (  0.001508)\n      user     system      total        real\nfibonacci1  8.416667   1.900000  10.316667 (  6.207565)\n      user     system      total        real\nfibonacci2 11.316667   1.866667  13.183333 (  8.567413)\n      user     system      total        real\nfibonacci3  9.066667   1.816667  10.883333 (  6.809812)\n      user     system      total        real\nfibonacci4  9.233333   1.533333  10.766667 (  6.520220)\n      user     system      total        real\nfibonacci5  0.000000   0.000000   0.000000 (  0.000166)\n```", "```\nruby -r profile -r 99bottles.rb -e 'wall = Wall.new(99); wall.sing_one_verse!\nuntil wall.empty?'.\n```", "```\n2 bottles of beer on the wall, 2 bottles of beer\ntake one down, pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer\ntake one down, pass it around, no more bottles of beer on the wall.\n\n  %   cumulative   self              self     total\n time   seconds   seconds    calls  ms/call  ms/call  name\n 31.25     0.08      0.08      297     0.28     0.45  Wall#sing\n 18.75     0.13      0.05       99     0.51     2.53  Wall#sing_one_verse!\n 18.75     0.18      0.05       99     0.51     0.51  Wall#take_one_down!\n 12.50     0.22      0.03      297     0.11     0.11  Fixnum#==\n  6.25     0.23      0.02      100     0.17     0.17  Wall#empty?\n  6.25     0.25      0.02      297     0.06     0.06  Fixnum#>\n  6.25     0.27      0.02       99     0.17     0.17  Kernel.puts\n  0.00     0.27      0.00        1     0.00     0.00  Wall#initialize\n  0.00     0.27      0.00        5     0.00     0.00  Module#method_added\n  0.00     0.27      0.00        1     0.00     0.00  Class#inherited\n  0.00     0.27      0.00       99     0.00     0.00  IO#write\n  0.00     0.27      0.00      594     0.00     0.00  String#+\n  0.00     0.27      0.00       99     0.00     0.00  Fixnum#-\n  0.00     0.27      0.00      100     0.00     0.00  Fixnum#zero?\n  0.00     0.27      0.00        1     0.00     0.00  Class#new\n  0.00     0.27      0.00      296     0.00     0.00  Fixnum#to_s\n  0.00     0.27      0.00        1     0.00     0.00  Module#private\n  0.00     0.27      0.00        1     0.00   266.67  #toplevel\n```", "```\n  #!/usr/bin/env ruby\n  # temperature_converter.rb\n  # See also GNU units at http://www.gnu.org/software/units/units.html\n\n  # Converts Metric/SI <-> English units.\n\n  =begin rdoc\n  Converts to and from various units of temperature.\n  =end\n  class Temperature_Converter\n\n    # every factor has some base unit for multi-stage conversion\n    # I allow either full or shortened name as the key\n❶    BASE_UNIT_OF = {\n      'temperature' => 'K',\n      'temp'        => 'K',\n    }\n\n❷   C_TO_F_ADD        = 32.0\n    F_TO_C_RATIO      = 5.0/9.0\n    C_TO_K_ADD        = 273.15\n\n❸   C2K = lambda { |c| c + C_TO_K_ADD }\n    F2C = lambda { |f| (f - C_TO_F_ADD ) * F_TO_C_RATIO }\n    K2C = lambda { |k| k - C_TO_K_ADD }\n    C2F = lambda { |c| (c / F_TO_C_RATIO) + C_TO_F_ADD }\n    F2K = lambda { |f| C2K.call( F2C.call(f) ) }    *Composition of Functions*\n    K2F = lambda { |k| C2F.call( K2C.call(k) ) }\n\n❹   CONVERSIONS = {\n      # most units just need to get to the base unit\n      # have => {want => how_many_wants_per_have},\n      'C'   => { 'K' => C2K },\n      'F'   => { 'K' => F2K },\n\n❺     # The base unit requires more conversion targets\n      'K'   => {\n        'F'   => K2F,\n        'C'   => K2C,\n      },\n\n    }\n\n    OUTPUT_FORMAT = \"%.2f\"\n\n❻   def convert(params)\n      conversion_proc =\n        CONVERSIONS[params[:have_unit]][params[:want_unit]] ||\n        get_proc_via_base_unit(params)\n\n      return \"#{params[:have_num]} #{params[:have_unit]} = \" +\n        \"#{sprintf( OUTPUT_FORMAT, conversion_proc[params[:have_num]] )} \" +\n        \"#{params[:want_unit]}\"\n    end\n\n    private\n\n  =begin rdoc\n  If there is no direct link between the known unit and the desired unit,\n  we must do a two-stage conversion, using the base unit for that factor\n  as a \"Rosetta Stone.\"\n  =end\n    def get_proc_via_base_unit(params)\n❼     base_unit         = BASE_UNIT_OF['temperature']\n❽     have_to_base_proc = CONVERSIONS[params[:have_unit]][base_unit]\n❾     base_to_want_proc = CONVERSIONS[base_unit][params[:want_unit]]\n❿     return lambda do |have|\n        base_to_want_proc.call( have_to_base_proc.call( have ) )\n      end\n    end\n\n  end\n```", "```\n$ irb -r temperature_converter.rb\nirb(main):001:0> tc = Temperature_Converter.new\n=> #<Temperature_Converter:0xb7ccdb04>\nirb(main):002:0> tc.convert( {:have_unit => 'C', :want_unit => 'K', :have_num\n=> 15} )\n=> \"15 C = 288.15 K\"\n```", "```\n$ irb -r temperature_converter.rb\nirb(main):001:0> tc = Temperature_Converter.new\n=> #<Temperature_Converter:0xb7c75b5c>\nirb(main):002:0> tc.convert( { :have_num => 65.0, :have_unit => 'F', :want_unit => 'C' } )\n=> \"65.0 F = 18.33 C\"\nirb(main):003:0> tc.convert( { :have_num => 0, :have_unit => 'K', :want_unit => 'F' } )\n=> \"0 K = -459.67 F\"\n```", "```\nirb(main):001:0> def compose(inner_proc, outer_proc, *args)\nirb(main):002:1> return lambda { |*args| outer_proc.call(inner_proc[*args]) }\nirb(main):003:1> end\n=> nil\nirb(main):004:0> square = lambda { |x| x ** 2 }\n=> #<Proc:0xb7cda048@(irb):4>\nirb(main):005:0> inc = lambda { |x| x + 1 }\n=> #<Proc:0xb7ccb8f4@(irb):5>\nirb(main):006:0> square_then_inc = compose( square, inc )\n=> #<Proc:0xb7ce5204@(irb):2>\nirb(main):007:0> inc_then_square = compose( inc, square )\n=> #<Proc:0xb7ce5204@(irb):2>\nirb(main):008:0> square_then_inc.call(1)\n=> 2\nirb(main):009:0> square_then_inc.call(2)\n=> 5\nirb(main):010:0> inc_then_square.call(2)\n=> 9\n```", "```\n  #!/usr/bin/env ruby\n  # test_temp_converter.rb\n\n❶ require 'temperature_converter'\n  require 'test/unit'\n\n❷ class Tester < Test::Unit::TestCase    *Unit Testing*\n\n    def setup\n      @converter = Temperature_Converter.new()\n    end\n\n    def test_temps()\n\n❸     tests = {\n        '100.0 C = 212.00 F' => {\n          :have_num  => 100.0,\n          :have_unit => 'C',\n          :want_unit => 'F',\n        },\n        '212.0 F = 100.00 C' => {\n          :have_num => 212.0,\n          :have_unit => 'F',\n          :want_unit => 'C',\n        },\n        '70.0 F = 294.26 K' => {\n          :have_num => 70.0,\n          :have_unit => 'F',\n          :want_unit => 'K',\n        },\n        '25.0 C = 298.15 K' => {\n          :have_num => 25.0,\n          :have_unit => 'C',\n          :want_unit => 'K',\n        },\n      }\n      general_tester( tests )\n\n    end\n\n    private\n\n❹   def general_tester(tests)\n❺     tests.each_pair do |result,test_args|\n❻       assert_equal( result, @converter.convert( test_args ) )\n      end\n    end\n\n  end\n```", "```\n$ ruby -w tests/test_temp_converter.rb\nLoaded suite tests/test_temp_converter\nStarted\n.\nFinished in 0.001094 seconds.\n\n1 tests, 4 assertions, 0 failures, 0 errors\n```"]