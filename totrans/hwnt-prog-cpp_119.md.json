["```\n          // The bit we are printing now\n          short int bit = (1<<16);\n\n```", "```\n          ---------------\n\n```", "```\n          if (size > MAX)\n              std::cout << \"Size is too large\\n\";\n              size = MAX;\n\n```", "```\n          if (size > MAX)\n              std::cout << \"Size is too large\\n\";\n          size = MAX;\n\n```", "```\n          if (size > MAX)\n          {\n              std::cout << \"Size is too large\\n\";\n              size = MAX;\n          }\n\n```", "```\n          6 void main()\n\n```", "```\n 1 /************************************************\n 2  * The \"standard\" hello world program.          *\n 3  ************************************************/\n 4 #include <ostream>\n 5\n 6 int main()\n 7 {\n 8     std::cout << \"Hello world!\\n\";\n 9     return (0);\n10 }\n\n```", "```\n        12   printf(\"pi is %f\\n\", M_PI);\n\n```", "```\n          privs |= P_BACKUP;    // P_BACKUP = (1 << 8)\n\n```", "```\n            data_holder &operator = (\n                  const data_holder &old_data_holder) {\n\n```", "```\n        if (width < MIN) {\n            std::cout << \"Width is too small\\n\";\n            width = MIN;\n\n```", "```\n        if (height < MIN)\n            std::cout << \"Height is too small\\n\";\n            height = MIN;\n        }\n\n```", "```\n        if (width < MIN) {\n            std::cout << \"Width is too small\\n\";\n            width = MIN;\n\n            if (height < MIN)\n                 std::cout << \"Height is too small\\n\";\n            height = MIN;\n        }\n\n```", "```\n        if (width < MIN) {\n            std::cout << \"Width is too small\\n\";\n            width = MIN;\n        }\n\n        if (height < MIN) {\n            std::cout << \"Height is too small\\n\";\n            height = MIN;\n        }\n\n```", "```\n        save_queue = a_queue\n\n```", "```\n        18         result = 408;\n\n```", "```\n           3 0011\n        & 12 1100\n        =========\n           0 0000\n\n```", "```\n           if (x)\n\n```", "```\n           if (x != 0)\n\n```", "```\n           if ((i1 != 0) && (i2 != 0))\n\n```", "```\n           bit >>= 1;\n\n```", "```\n       0x8000 >> 1      1000 0000 0000 0000 (b)\n\n```", "```\n       0x4000           0100 0000 0000 0000 (b)\n\n```", "```\n       0xC000           1100 0000 0000 0000 (b)\n\n```", "```\n        memset(\n            void *ptr,// Pointer to the data\n            int value,// Value to set\n            size_t size// Number of bytes to fill\n        );\n\n```", "```\n        memset(array, '\\0', sizeof(array));\n\n```", "```\n            5880:0000\n\n```", "```\n            5880:001E\n\n```", "```\n            5880:0000\n\n```", "```\n            5880:FFFE\n\n```", "```\n            data_ptr >= data\n\n```", "```\n            5880:0000\n\n```", "```\n    i = &tmp2\n    tmp1 destroyed\n    tmp2 destroyed\n\n    ```", "```\n        13    std::cout << \"Twice\" << number << \"is\" <<\n        14        (number *2) << '\\n';\n\n```", "```\n        Twice5is10\n\n```", "```\n        if (n2 =! 0)\n\n```", "```\n        n2 = !0;\n        if (n2)\n\n```", "```\n        if (n2 != 0)\n\n```", "```\n            diff[diff_index++] =\n                array[i++] - array[i++];\n\n```", "```\n        12    result = 1/3;     // Assign result something\n\n```", "```\n        12    result = 1.0 / 3.0;// Assign result something\n\n```", "```\n        22          scanf(\"%c %d\", &oper, &value);\n\n```", "```\n        % calc\n        Enter operator and value:+ 5\n        Total: 5\n        Enter operator and value:+ 10\n        Bad operator entered\n        Total: 5\n        Enter operator and value:Bad operator entered\n        Total: 5\n        Enter operator and value:q\n        Bad operator entered\n        Total: 5\n        Enter operator and value:q\n\n```", "```\n        + 5\n\n```", "```\n           fgets(line, sizeof(line), stdin);\n           sscanf(line, \"%c %d\", &operator, &value);\n\n```", "```\n        37 + 33 * 10\n\n```", "```\n        // Total top size\n        #define TOP_TOTAL (TOP_PART1 + TOP_PART2)\n\n```", "```\n        23 if (balance < 0)\n        24     if (balance < - (100*DOLLAR))\n        25         cout << \"Credit \" << -balance << endl;\n        26     else\n        27         cout << \"Debt \" << balance << endl;\n\n```", "```\n        if (balance < 0) {\n            if (balance < - (100*DOLLAR))\n                cout << \"Credit \" << -balance << endl;\n        } else\n            cout << \"Debt \" << balance << endl;\n\n```", "```\n        First: John\n        Last:  Smith\n        Hello: John\n         Smith\n\n```", "```\n            for (index = 1; index <= 10; ++index);\n\n```", "```\n        for (index = 1; index <= 10; ++index);\n        std::cout << index << \" squared \" <<\n             (index * index) << '\\n';\n\n```", "```\n        for (index = 1; index <= 10; ++index)\n            /* Do nothing */;\n        std::cout << index << \" squared \" <<\n            (index * index) << '\\n';\n\n```", "```\n        16    if (remove) {\n\n```", "```\n         15     // The name we are generating\n         16     std::string name;\n\n```", "```\n       \"<return>oot<newline>ew<tab>able\"\n\n```", "```\n       const char name[] = \"\\\\root\\\\new\\\\table\";  // DOS path\n\n```", "```\n       #include \"\\usr\\include\\table.h\"\n\n```", "```\n       if (balance < 0)\n\n```", "```\n       You owe 0.\n\n```", "```\n        factor1 * factor2;\n\n```", "```\n        17     int register1 = factor1 * factor2;\n        18     // We know that 1863 multiplies\n        19     // delay the proper amount\n        20     for (i = 0; i < 1863; ++i)\n        21     {\n        22         result = register1;\n        23     }\n\n```", "```\n         1 /************************************************\n         2 * bit_delay -- Delay one bit time for           *\n         3 *      serial output.                           *\n         4 *                                               *\n         5 * Note: This function is highly system          *\n         6 *      dependent.  If you change the            *\n         7 *      processor or clock it will go bad.       *\n         8 *************************************************/\n         9 void bit_delay(void)\n        10 {\n        11     int i;      // Loop counter\n        12     volatile int result;// Result of the multiply\n        13\n        14     // Factors for multiplication\n        15     volatile int factor1 = 12;\n        16     volatile int factor2 = 34;\n        17\n        18     // We know that 1863 multiples delay\n        19     // the proper amount\n        20     for (i = 0; i < 1863; ++i)\n        21     {\n        22         result = factor1 * factor2;\n        23     }\n        24 }\n\n```", "```\n        void print_msg_one(\n            // File to write the message to\n            class ostream &out_file,\n\n            // Where to send it\n            const char msg[]\n        )\n\n```", "```\n        strcat(file_name, '/');\n\n```", "```\n       printer_status.online = 1;\n\n```", "```\n       if (printer_status == 1)\n\n```", "```\n      The answer is 4C:>#\n      (# is the cursor)\n\n```", "```\n      The answer is 4$ #\n\n```", "```\n      std::cout << \"The answer is \" << result << '\\n';\n\n```", "```\n      if (x)\n          std::cout << \"X set. Clearing\\n\", x = 0;\n\n```", "```\n       one_million = 1,000,000;\n\n```", "```\n       one_million = 1,\n       000,\n       000;\n\n```", "```\n       one_million = 1;\n       000;\n       000;\n\n```", "```\n     std::cout << static_cast<char>(ch+1);\n     std::cout << static_cast<char>(ch+2);\n\n```", "```\n     The double of 1 is 2\n     The double of 2 is 3\n     The double of 3 is 4\n     The double of 4 is 5\n     The double of 5 is 6\n\n```", "```\n     (i+1 * 2)\n\n```", "```\n      #define DOUBLE(x) ((x) * 2)\n\n```", "```\n       if (amount = 0)\n\n```", "```\n      if (amount == 0)\n\n```", "```\n        i = 3 - i;\n\n```", "```\n         switch (i) {\n             case 1\n                 i = 2;\n                 break;\n             case 2:\n                 i = 1;\n                 break;\n             default:\n                 std::cerr << \"Error: i is not 1 or 2\\n\";\n                 exit (99)\n         }\n\n```", "```\n           y = x<<2 + 1;\n\n```", "```\n           y = x << (2+1);\n\n```", "```\n      Hello\n      Hello\n\n```", "```\n       9   int sum = 0;\n\n```", "```\n       flags |= CD_SIGNAL;\n\n```", "```\n       ; 80x86 assembly\n       orb $2,flags\n\n```", "```\n1\\. sethi %hi(flags),%o0    ; Get the address of the flags in %o0,%o1\n2\\. sethi %hi(flags),%o1\n3\\. ld [%o1+%lo(flags)],%o2 ;%o2 = contents of the variable flags\n4\\. or %o2,2,%o1             ;%o1 = The results of seeting the flag\n5\\. st %o1,[%o0+%lo(flags)] ;Store results in %o0\n\n```", "```\n    48       printf(\"%o\\t\", matrix[row][col]);\n\n```", "```\n       1/3 = 0.33333\n       1/3 = 0.33333\n       1/3 = 0.33333\n       -------------\n             0.99999\n\n```", "```\n       if (i3 < 0)\n           throw (problem(\"Bad data\"));\n\n```", "```\n       ~stack(void) {\n           if (count != 0) {\n               throw (problem(\"Stack not empty\"));\n           }\n       }\n\n```", "```\n       new fast_bit_array\n\n```", "```\n           int value = 20;\n\n```", "```\n           int value = 30;\n\n```", "```\n            static int value = 20;\n\n```", "```\n            static int value = 30;\n\n```", "```\n       var_array(const var_array &other) {\n           data = other.data;\n           size = other.size;\n       }\n\n```", "```\n    private:\n        var_array (const var_array &);\n        // No one can copy var_arrays\n\n    ```", "```\n    // Copy Constructor defaults\n\n    ```", "```\n      int fd = open(cur_ent->d_name, O_RDONLY);\n      if (fd < 0)\n          continue;   // Can't get the file so try again\n\n      int magic;       // The file's magic number\n      int read_size = read(fd, &magic, sizeof(magic));\n      if (read_size != sizeof(magic)) {\n          close(fd);   // <---- added\n          continue;\n      }\n\n      if (magic == MAGIC) {\n          close(fd);     // <---- added\n          return (cur_ent->d_name);\n}\n      close(fd);         // <---- added\n\n```", "```\n      void scan_dir(\n          const char dir_name[]   // Directory name to use\n      )\n      {\n          DIR *dir_info = opendir(dir_name);\n          if (dir_info == NULL)\n              return;\n          chdir(dir_name);\n\n          while (1) {\n              char *name = next_file(dir_info);\n\n              if (name == NULL)\n                  break;\n              std::cout << \"Found: \" << name << '\\n';\n          }\n         closedir(dir_info);      // <---- added\n      }\n\n```", "```\n      5 const char *volatile in_port_ptr =\n      6 (char *)0xFFFFFFE0;\n\n```", "```\n      4 // Input register\n      5 volatile char *const in_port_ptr =\n      6         (char *)0xFFFFFFE0;\n      7\n      8 // Output register\n     10 volatile char *const out_port_ptr =\n     11         (char *)0xFFFFFFE1;\n\n```", "```\n        10    base = 5;    /* Set the base of the triangle\n\n```", "```\n        10    base = 5;    /* Set the base of the triangle\n        11    height = 2;  /* Initialize the height */\n\n```", "```\n        ch = (unsigned char)(-1)\n\n```", "```\n  1 /************************************************\n  2  * copy -- Copy stdin to stdout.                *\n  3  ************************************************/\n  4 #include <stdio.h>\n  5\n  6 int main()\n  7 {\n  8\n  9     while (1) {\n 10     {\n 11         int ch; // Character to copy\n 12\n 13         ch = getchar();\n 14\n 15         if (ch == EOF)\n 16             break;\n 17\n 18         putchar(ch);\n 19     }\n 20     return (0);\n 21 }\n\n```", "```\n      Name (a): /var/tmp/tmp.2\n      Name (b): /var/tmp/tmp.2\n\n```", "```\n        a_name --> name = \"/var/tmp/tmp.1\"\n\n```", "```\n        b_name --> name = \"/var/tmp/tmp.2\"\n\n```", "```\n        a_name --> name = \"/var/tmp/tmp.2\"\n        b_name --> name = \"/var/tmp/tmp.2\"\n\n```", "```\n       for (i = 0; i < BLOCK_SIZE; ++i) {\n            int ch;\n\n            ch = in_file.get();\n            serial_out.put(ch);\n       }\n       serial_out.fflush();\n\n```", "```\n       defualt:\n           std::cout << i << \" is not prime\\n\";\n           break;\n\n```", "```\n           printf(\"Starting....\");\n           fflush(stdout);\n\n```", "```\n         std::cout << \"Hello World!/n\";\n\n```", "```\n         std::cout << \"Hello World!\\n\";\n\n```", "```\n         Hello World/n\n\n```", "```\n        54     while (\n        55         (std::strcmp(cur_cmd->cmd, cmd) != 0) &&\n        56         cur_cmd != NULL)\n\n```", "```\n      while (\n          (cur_cmd != NULL) &&\n          (std::strcmp(cur_cmd->cmd, cmd) != 0))\n\n```", "```\n          while (1) {\n              if (cur_cmd == NULL)\n                   break;\n              if (std::strcmp(cur_cmd->cmd, cmd) == 0)\n                   break;\n\n```", "```\n       struct data {\n           char flag;       // 1 byte\n           long int value;  // 4 bytes\n       };\n\n```", "```\n       struct data {\n           char flag;       // 1 byte\n           char pad[3];     // 3 bytes (automatic padding)\n           long int value;  // 4 bytes\n       };\n\n```", "```\n      if (number1 + number2 == number1)\n\n```", "```\n     movefp_0, number1\n     add fp_0, number2\n     movefp_1, number1\n     fcmpfp_0, fp_1\n     jump_zero out_of_the_while\n\n```", "```\n       while (1)\n       {\n       // Volatile keeps the optimizer from\n       // putting the result in a register\n       volatile float result;\n\n       result = number1 + number2;\n       if (result == number1)\n           break;\n\n```", "```\n        an_array = an_array;\n\n```", "```\n        82    to_array = from_array;\n\n```", "```\n           array & operator = (const arrary &old_array) {\n       if (this == &old_array)\n                   return;\n\n```", "```\n          if (strcmp(x,y))\n\n```", "```\n          if (strmp(x,y) != 0)\n\n```", "```\n       while (first != NULL) {\n           delete first;\n           first = first->next;\n       }\n\n```", "```\n        delete first\n        first = NULL;\n        first = first->next;\n\n```", "```\n       char * sam, joe;\n\n```", "```\n       const int GROSS = (12 ** 2);\n\n```", "```\n       if (a > b > c)\n\n```", "```\n       if ((a > b) > c)\n\n```", "```\n       if (1 > c)\n\n```", "```\n       seq = seq;\n\n```", "```\n         8.5; -1.0;;\n\n```", "```\n         double text_width = 8.5; -1.0;;\n\n```", "```\n       double text_width = 8.5;\n       -1.0;\n        ;\n\n```", "```\n        printf(\"That's all\\n\");\n\n```", "```\n        static char buffer[BUFSIZ];\n\n```", "```\n       if (debugging)\n\n```", "```\n       13   if (debugging)\n       14   {\n       15       dump_variables();\n       16   }\n\n```", "```\n       // Nothing\n\n```", "```\n       9 void do_work()\n      10 {\n      11     // Declaration optimized out\n      12\n      13     // Block optimized out\n      14     //\n      15     //\n      16     // End of block that was removed\n      17     // Do real work\n      18 }\n\n```", "```\n     static volatile int debugging = 0;\n\n```", "```\n       11    printf(\"The answer is %d\\n\");\n\n```", "```\n       printf(\"The answer is %d\\n\", answer);\n\n```", "```\n        matrix[1][2]\n\n```", "```\n     ++++i;\n\n```", "```\n       ++++i\n\n```", "```\n         #define SQR(x) ((x) * (x))\n\n```", "```\n            SQR(++number)\n\n```", "```\n            ((++number) * (++number))\n\n```", "```\n          20    for (i = 0; i < 1863; ++i)\n          21    {\n          22        result = factor1 * factor2;\n          23    }\n\n```", "```\n          20    for (i = 0; i < 1863; ++i)\n          21    {\n          22        /* Do nothing */;\n          23    }\n\n```", "```\n          20    /* No loop needed */\n          21    {\n          22        /* Do nothing */;\n          23    }\n\n```", "```\n       array[0], array[1], array[2], array[3], array[4]\n\n```", "```\n         for (i = 1; i <= 5; ++i) {\n\n```", "```\n         for (i = 0; i < 5; ++i) {\n\n```", "```\n         result=result/*divisor; /* Do divide */;\n\n```", "```\n         result = result /* a very big comment */;\n\n```", "```\n         result=result / *divisor; /* Do divide */;\n\n```", "```\n       ++count;  // We've got a new character\n       *in_ptr = ch;// Store the character\n\n```", "```\n       reader:++count;// We've got a new character\n\n       thread switch to writer\n\n       writer: check count > 0 -- it is\n\n       writer: Get the character\n\n       thread switch to reader\n\n       reader: Put the character in the buffer AFTER writer has already read it.\n\n```", "```\n       ++count; // We've got a new character\n       *in_ptr = ch;// Store the character\n\n```", "```\n       *in_ptr = ch;// Store the character\n       ++count; // We've got a new character\n\n```", "```\n       pthread_mutex_lock(&buffer_mutex);\n\n       ++count;\n       *in_ptr = ch;\n       ++in_ptr;\n\n       pthread_mutex_unlock(&buffer_mutex);\n\n```", "```\n       ) : width(i_width),\n           height(i_height),\n           area(width*height)\n\n```", "```\n       int sum(i1, i2, i3)\n       {\n\n```", "```\n       int sum(i1, i2, i3)\n       {\n           int i1;   /* Local variable, not parameter */\n           int i2;   /* Local variable, not parameter */\n           int i3;   /* Local variable, not parameter */\n\n```", "```\n     24    sscanf(line, \"%c %d\", oper, value);\n\n```", "```\n       24     sscanf(line, \"%c %d\", &oper, &value);\n\n```", "```\n       for (index = 0; string[index] != '\\0'; ++index)\n           /* do nothing */\n       return (index);\n\n```", "```\n       for (index = 0; string[index] != '\\0'; ++index)\n           /* do nothing */\n           return (index);\n\n```", "```\n       for (index = 0; string[index] != '\\0'; ++index)\n           /* do nothing */;\n       return (index);\n\n```", "```\n       result =\n           (struct info *)malloc(sizeof(struct info));\n       memset(result, '\\0', sizeof(result));\n\n```", "```\n       result = new info;\n\n```", "```\n          out_file << ch;\n\n```", "```\n          printf(\"%c\", ch);\n\n```", "```\n         out_file << static_cast<char>(ch);\n\n```", "```\n     First: second Second: second\n\n```", "```\n       First 1\n       First 1\n       First 1\n       Second 1\n       Second 2\n       Second 3\n\n```", "```\n       First 0\n       First 0\n       First 0\n       Second 0\n       Second 1\n       Second 2\n\n```", "```\n       return (i++);\n\n```", "```\n       i = 1;\n       return (i++);\n\n```", "```\n       struct end_block_struct\n       {\n           unsigned long int next_512_pos;  // [0123]\n           unsigned char next_8k_pos1;      // [4]\n           unsigned char next_8k_pos2;      // [5]\n\n           unsigned long int prev_251_pos;  // [6789]\n\n```", "```\n       struct end_block_struct\n       {\n           unsigned long int next_512_pos;  // [0123]\n           unsigned char next_8k_pos1;      // [4]\n           unsigned char next_8k_pos2;      // [5]\n\n           unsigned char pad1, pad2;        // [67]\n           unsigned long int prev_251_pos;  // [89 10 11]\n\n```", "```\n       assert(sizeof(end_block_struct) == 16);\n\n```", "```\n        if (value < 0)\n            std::cerr << \"Illegal root\" << std::endl;exit (8);\n\n```", "```\n        if (value < 0)\n             std::cerr << \"Illegal root\" << std::endl;\n        exit (8);\n\n```", "```\n       inline void ABORT(const char msg[]) {\n           std::cerr << msg << std::endl;\n           exit(8);\n       }\n\n```", "```\n       #define ABORT(msg) \\\n           {std::cerr << msg << std::endl;exit(8);}\n\n```", "```\n           char prev_ch = '\\0';\n\n```", "```\n       printf(\"-xxx\") prints -xxx\n       printf(\"-xxx\" + 1) prints xxx\n\n```", "```\n                trouble operator = (const trouble &i_trouble)\n                {\n                    std::cout << \"= operator called\\n\";\n                    data = i_trouble.data;\n                    return (*this);\n                }\n\n```", "```\n               trouble& operator = (const trouble &i_trouble)\n\n```", "```\n       for (counter =MAX; counter > 0; --counter)\n\n```", "```\n      for (counter ==10; counter > 0; --counter)\n\n```", "```\n*for (counter = =10 ; counter > 0; --counter)*\n\n```", "```\n       #define DOUBLE (value) ((value) + (value))\n\n```", "```\n       (value) ((value) + (value))\n\n```", "```\n       std::cout << \"Twice \" << counter << \" is \" <<\n           DOUBLE(counter) << '\\n';\n\n```", "```\n       std::cout << \"Twice \" << counter << \" is \" <<\n           (value) ((value) + (value)) (counter) << '\\n';\n\n```", "```\n       #define DOUBLE(value) ((value) + (value))\n\n```", "```\n       inline DOUBLE(const int value) {\n           return (value + value);\n       }\n\n```", "```\n  1 /************************************************\n  2  * sum -- Sum the sine of the numbers from 0 to *\n  3  *      0X3FFFFFFF.   Actually we don't care    *\n  4  *      about the answer, all we're trying to   *\n  5  *      do is create some sort of compute       *\n  6  *      bound job so that the status_monitor    *\n  7  *      can be demonstrated.                    *\n  8  ************************************************/\n  9 /* --- After the optimizer --- */\n 10 /* --- gets through with it --- */\n 11 static void sum(void)\n 12 {\n 13     static double sum = 0;      /* Sum so far */\n 14     register int reg_counter = counter;\n 15\n 16     for (reg_counter = 0;\n 17          reg_counter < 0x3FFFFFF; ++reg_counter)\n 18     {\n 19         sum += sin(double(reg_counter));\n 20     }\n 21     printf(\"Total %f\\n\", sum);\n 22     counter = reg_counter;\n 23     exit (0);\n 24 }\n\n```", "```\n       volatile int counter;\n\n```", "```\n       34        // Copy constructor\n       35        v_string(const v_string &old)\n       36        {\n       37            if (data != NULL)\n       38            {\n       39            delete[] data;\n       40            data = NULL;\n       41        }\n       42        data = strdup(old.data);\n       43    }\n\n```", "```\n       34       // Copy constructor\n       35       v_string(const v_string &old):\n       36           data(strdup(old.data))\n       37       {}\n\n```"]