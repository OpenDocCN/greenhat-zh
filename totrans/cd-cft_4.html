<html><head></head><body><div class="part" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="part_of_the_process"/>Part V. PART OF THE PROCESS</h1></div></div></div><div class="partintro" xml:lang="en"><div/><p>Writing high-quality software isn't just about churning out good code. Obviously, good code helps. A little. But there's much more to it than that. Good software is created intentionally; it takes planning, foresight, and a robust battle plan. We'll see exactly what this battle plan looks like in the next section. However, before we assemble the troops, we must know what they should do. It helps to point them all in the same direction.</p><p>This section looks at some specific parts of the development process, the extra activities we schedule time for that help us to intentionally craft excellent code. We'll see:</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>How to write and read software specifications. The correct approach to recording what you will do, and what you have done. This chapter shows how specifications can make your life easier, rather than get on your nerves.</p></dd><dt><span class="term"><a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a></span></dt><dd><p>A discussion of <span class="emphasis"><em>code reviews</em></span>—an important practice that ensures you are writing high-quality code.</p></dd><dt><span class="term"><a class="xref" href="ch21.html" title="Chapter 21. HOW LONG IS A PIECE OF STRING?">Chapter 21</a></span></dt><dd><p>Software timescale estimation—an essential activity in the planning process, yet still one of the mystic black arts of the software development community. This chapter busts some estimation myths and provides practical advice to use on the front line.</p></dd></dl></div><p>The relentless pressures of the software factory continually drive us to work faster and harder. The only way to cope is to learn ways to work smarter. We need to employ each of these pracices to stand a chance in the endgame.</p></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="being_specific"/>Chapter 19. BEING SPECIFIC</h1></div><div><h3 class="subtitle"><i>Writing Software Specifications</i></h3></div></div></div><div class="epigraph"><p>I've never known any trouble that an hour's reading didn't assuage.</p><div class="attribution"><span>--<span class="attribution">Charles De Secondat</span></span></div></div><p>Almost everything worth using is documented. Your DVD player has an instruction manual. Your car has a maintenance manual. A contract has small print. Chocolate cake has a recipe. There are books and magazines dedicated to practically every pursuit known to man. If your software is worth using, it also should be well documented.<sup>[<a class="footnote" href="#ftn.CHP-19-FN-1" id="CHP-19-FN-1">1</a>]</sup></p><p>We all know that the carefully tested software we give to our customers needs to have documentation. Just how much documentation is a moot point. The user of an office suite certainly thinks there should be more than the publisher does. Without a manual to describe the usage mechanics of your software, whatever form it takes, people will falsely assume that it can do more than it was designed to, or use it for purposes no sane programmer would have ever imagined.<a class="indexterm" id="IDX-CHP-19-1495"/></p><p>Developers can just as easily make the same kinds of mistakes during coding. Just as the final software product needs documentation, so do the intermediate development steps. This is the sort of documentation that the end user will (usually) never see. These are the definitions of how the program will be designed and built. These are the software <span class="emphasis"><em>specifications</em></span>.<a class="indexterm" id="IDX-CHP-19-1496"/><a class="indexterm" id="IDX-CHP-19-1497"/></p><p>Writing and working with specifications is an important skill of the practicing programmer. Communicating in English (or any other natural language) is just as important as communicating in code.<sup>[<a class="footnote" href="#ftn.CHP-19-FN-2" id="CHP-19-FN-2">2</a>]</sup> Like eating your vegetables and exercising regularly, specifications are "good for you" and good for your software. However, like cabbage and the gym, we avoid them, feel guilty, and then live to regret the consequences: We end up with unhealthy, flabby software development.</p><p>The traditional notion of a software specification involves a huge wedge of paper filled with dense text, cryptic tables, and meaningless terminology. It's a highly uninspiring prospect: a document that requires more maintenance effort than the code it describes. Developers live in perpetual fear of being forced to work with the spec.</p><p>But it doesn't have to be this way. Used correctly, specifications oil the development process. They reduce development risk, help you to work effectively, and make your life a lot easier. In this chapter, we'll investigate the sorts of specifications we need, what should be in them, and why reality differs so greatly from this ideal.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_are_they_comma_specifically_question"/>What Are They, Specifically?</h1></div></div></div><div class="epigraph"><p>Apply your heart to instruction and your ears to words of knowledge.<a class="indexterm" id="IDX-CHP-19-1498"/></p><div class="attribution"><span>--<span class="attribution">Proverbs 23:12</span></span></div></div><p>Specifications are formal documents that form part of the development process, providing internal software documentation. There are many different types of specification (we'll see them shortly) containing different information and targeted at different audiences. Each one is appropriate to a particular stage of the software construction process, from the conception of a project to its final deliverable. We use them to capture exactly what the user requires (or exactly what they are going to get, if the two differ—they usually do), to detail the architecture of a software solution, the interface of a particular code module, the design and implementation decisions for a piece of code, and more.</p><p>Specifications help you to work smarter and to produce better software. But a bad specification can do quite the opposite. Like your code, the quality of a software specification is vital. Good specifications and documentation are generally taken for granted, whereas poor specifications rapidly become loathed; a millstone around the project's neck.<a class="indexterm" id="IDX-CHP-19-1499"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Not just the existence, but also the quality of software specifications is vital to the software development process</em></span>.</p></dd></dl></div><p>Specifications are a form of inter- and intrateam communication. We've seen that projects can die from a lack of communication. We should therefore exploit specifications as a communication medium—where appropriate. (Projects can just as easily fail because too much time is spent writing documents, and not enough time is actually spent writing software!)<a class="indexterm" id="IDX-CHP-19-1500"/><a class="indexterm" id="IDX-CHP-19-1501"/></p><p>Specifications become increasingly important as the size of a project increases. This is not because specifications are unimportant in smaller projects but because larger projects have more to lose—there are more people whose lack of communication and coordination will have a greater negative impact on the outcome of the software development process.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Specifications are an important communication mechanism for software developers. Use them to capture information that must not be lost or forgotten</em></span>.</p></dd></dl></div><p>Writing specifications helps to make your information:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Safer</strong></span></span></dt><dd><p>Information isn't stored in people's heads where it can be lost, forgotten, or remembered incorrectly. With all important facts written down, there's less risk when people leave the project: The amount of information loss will be minimized, and there will be a solid base to help any replacement programmer get up to speed.</p><p>Thorough, complete specifications reduce the risk of two people making different sets of assumptions—the classic reason why two separately created modules do not worktogether when first integrated. Specifications help to prevent subtle bugs.<a class="indexterm" id="IDX-CHP-19-1502"/></p></dd><dt><span class="term"><span class="strong"><strong>Accessible</strong></span></span></dt><dd><p>All information is conveniently recorded in a known place. New people can join your project and understand what each component does and how they fit together, just by reading the documentation. They don't have to search for the information in a hundred different people's heads before they become productive.</p></dd><dt><span class="term"><span class="strong"><strong>More accurate</strong></span></span></dt><dd><p>When all information is gathered and captured, you are more likely to see problems, to indentify missing parts of the design, and to spot any unfortunate consequences or side effects. A few disconnected thoughts floating around your brain are not as easy to validate.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-1" id="ftn.CHP-19-FN-1">1</a>] </sup>Of course, that's no excuse to craft a bad interface; it must still be easy and intuitive to use.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-2" id="ftn.CHP-19-FN-2">2</a>] </sup>Indeed, Dijkstra once remarked, "Besides a mathematical inclination, an exceptionally good mastery of one's native tongue is the most vital asset of a competent programmer."</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_types_of_specification"/>The Types of Specification</h1></div></div></div><p>Each type of specification forms an intermediate gate of the software process: A method of handover between separate parts of the development process. For example, a specification for the API of a software component is written by the group of people who are scoping its functionality and interface. The programmer works to this specification; it is complete enough to implement all the code. The same specification is a contract detailing how the systems integrator can stitch it into the system and how other programmers can use it. It also describes expected behavior, so the test department can validate that the software is working correctly.</p><p>In this way, the output of one specification flows naturally into the contents of the next, leaving a trail of documents in the wake of the rapidly evolving software. An example of this paper trail is shown in <a class="xref" href="ch19s02.html#the_typical_specification_paper_trail" title="Figure 19-1. The typical specification paper trail">Figure 19-1</a>. We see a natural hierarchy of documents generated as a project matures—each subcomponent has a similar set of documents to the overall project; its development can be managed as a mini-project.</p><p>Since software design is an iterative process, this is not a one-way flow of information (otherwise you're trapped in a waterfall methodology straight-jacket—see "<a class="xref" href="ch22s03.html#waterfall_model" title="Waterfall Model">Waterfall Model</a>" on page 427). As you discover missing information or need to adjust the software design, the specifications must be updated accordingly. If your documents are not malleable and maintainable, your software development will suffer. Bureaucratic development processes try to stifle good software development by ensuring that all work is performed to The Specification, even if it's 10 years old and completely out of date. Good programmers consider their specifications to be just as malleable as their code.</p><div class="figure"><a id="the_typical_specification_paper_trail"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e26635"/><img alt="The typical specification paper trail" src="tagoreillycom20080909nostarchimages207566.png"/></div></div><p class="title"><b>Figure 19-1. The typical specification paper trail</b></p></div><br class="figure-break"/><p>Let's look at the different types of software specifications and see how they enhance your code-writing lifestyle. Unfortunately, in the Real World, these documents are called by many different names. A <span class="emphasis"><em>requirements specification</em></span> is variously called a <span class="emphasis"><em>user requirements specification</em></span> and a <span class="emphasis"><em>functional constraints specification</em></span> by different people.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="requirements_specification"/>Requirements Specification</h2></div></div></div><p>If all other specifications disappeared in a software development process meltdown, this is the one document that you should fight for. It's the head of the merry software development parade and the stumbling block for many failing projects. The information in here is vital. It will keep you sane.<a class="indexterm" id="IDX-CHP-19-1503"/><a class="indexterm" id="IDX-CHP-19-1504"/><a class="indexterm" id="IDX-CHP-19-1505"/><a class="indexterm" id="IDX-CHP-19-1506"/><a class="indexterm" id="IDX-CHP-19-1507"/><a class="indexterm" id="IDX-CHP-19-1508"/></p><p>The requirements for a project are never clear at first; customers can't tell you <span class="emphasis"><em>exactly</em></span> what they want their software to do (they're not computer experts, so they don't know). This can cause all kinds of problems, so there must be a single document that pins down what your software is supposed to do and the characteristics of an acceptable implementation: the <span class="emphasis"><em>requirements specification</em></span>. It lists in great detail (or at least appropriate detail, which will usually be great) how the code is expected to behave. It must cover all the important, high-risk, high-value areas of system behavior, comprehensively and unambiguously.<a class="indexterm" id="IDX-CHP-19-1509"/></p><p>The requirements are usually written as a series of numbered sentences each containing a single factual piece of information. For example:</p><div class="blockquote"><blockquote class="blockquote"><p>1.3.5 The user interface shall consist of a black rectangle containing the words Don't Panic in a red sans-serif typeface at 13pt.</p></blockquote></div><p>Uniquely numbering each requirement enables easy cross-referencing in subsequent documents and helps you to trace a particular design or implementation decision back to a single requirement.<a class="indexterm" id="IDX-CHP-19-1510"/></p><p>We must consider:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Functional requirements</strong></span></span></dt><dd><p>These requirements detail what the program must do. For example: <span class="emphasis"><em>Must process BMP images and convert them to either JPEG or GIF format</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>Performance requirements</strong></span></span></dt><dd><p>These requirements show how fast it must work and whether there are operations with deadlines. For example: <span class="emphasis"><em>The user must receive feedback for every operation within one second, and all operations must complete within five seconds</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>Interoperability requirements</strong></span></span></dt><dd><p>These requirements describe the other software, hardware, and external systems that it must interact with. For example: <span class="emphasis"><em>Must support HTTP and RS232 communication with an upgrade server</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>Future operation requirements</strong></span></span></dt><dd><p>These requirements determine what functionality must be <span class="emphasis"><em>accommodated</em></span> now, even if it's not implemented right away. For example: <span class="emphasis"><em>Must provide a skinnable UI so that the user can customize the look and feel</em></span>.</p></dd></dl></div><p>These requirements fall into two camps. <span class="emphasis"><em>Discrete requirements</em></span> are binary. You can easily check whether your program meets them by looking at the source: There will be a chunk of code dedicated to each bit of functionality. You can write specific tests to ensure that each discrete requirement is honored.<a class="indexterm" id="IDX-CHP-19-1511"/></p><p><span class="emphasis"><em>Nondiscrete requirements</em></span> are less tangible. You can't check whether your program meets them just by inspecting the source. These include the required fault-tolerance of a system, the required uptime of a server, a program's mean time between failure, its security, or its scalability. These kinds of requirements can be massively important and remarkably hard to verify.</p><p>The process for creating a requirements specification will differ from company to company, and often depends on the project characteristics and the customers (how smart and competent they are). The requirements specification is collated by the marketing team, a future product focus group, or a <span class="emphasis"><em>business analyst</em></span> whose job is to understand the problem domain and scope the work required. Usually the customer, or a representative of the customer, is involved.<a class="indexterm" id="IDX-CHP-19-1512"/><a class="indexterm" id="IDX-CHP-19-1513"/><a class="indexterm" id="IDX-CHP-19-1514"/></p><p>The customer must agree to and sign off on the requrements specification; it forms an effective contract between the software developer and its client. The supplier agrees to ship a product whose functionality meets these requirements; the customer agrees to pay for it. Without an agreed specification, the customer can refuse the product on a whim, and the developers will have spent a lot of effort to no avail. Sadly, this is a common problem in the software factory that I have seen many times, especially when the customer is not a technical expert and doesn't know what a good software solution looks like. When the requested software is finally built, the customer realizes that what it asked for wasn't what it actually wanted: <span class="emphasis"><em>Rewrite it in pink</em></span>. You're back to square one. This sort of thing happens all the time; the requirements specification is your insurance policy.</p><p>Sadly, many software factories skip requirements gathering or do not give it sufficient import. It's <span class="emphasis"><em>vital</em></span> to agree on the requirements early on, before software design has started and certainly before any code has been written. We use the functional requirements specification:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To keep the project on track and on time—by preventing (or at least reducing) the tardy addition of new features that will postpone delivery.</p></li><li class="listitem"><p>To improve customer satisfaction—by setting expectations up front.</p></li><li class="listitem"><p>To reduce bugs—by restricting <span class="emphasis"><em>feature creep</em></span>, we avoid last-minute code additions, which helps to avoid scary bugs.<a class="indexterm" id="IDX-CHP-19-1515"/></p></li><li class="listitem"><p>To maintain your sanity—without requirements specifications, developers rapidly lose their hair.</p></li></ul></div><p>Depending on the type of development methodology you employ, a single monolithic requirements specification might be written up front before any software development begins, or it might be developed incrementally alongside the code. Understand how your requirements are gathered from the customer and how this impacts the way you develop code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Software requirements must be captured early to set expectations, to prevent feature creep, and to reduce developer angst</em></span>.</p></dd></dl></div><p>Also consider your <span class="emphasis"><em>developmental requirements</em></span>: the things that you as a developer must have in order to develop the software. For example, you might require a certain kind of internal architecture to provide adequate future extensibility, and you <span class="emphasis"><em>need</em></span> version control to develop software (it is not optional). Some of these might justifiably belong in a requirements specification.<a class="indexterm" id="IDX-CHP-19-1516"/><a class="indexterm" id="IDX-CHP-19-1517"/><a class="indexterm" id="IDX-CHP-19-1518"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="functional_specification"/>Functional Specification</h2></div></div></div><p>Perhaps the document most frequently used by programmers, the <span class="emphasis"><em>functional specification</em></span> describes the observable behavior of a piece of software. It is derived from—and must satisfy—the requirements specification. There are usually a number of functional specifications in one project: one for the overall product and then individual specifications for individual software components.<a class="indexterm" id="IDX-CHP-19-1519"/></p><p>For a software component, the functional specification includes a complete and unambiguous description of its public interface. This equates to a list of every method or function in the module's API, together with a description of what they do and how to use them. It contains details of all external data structures and formats, and all dependencies on other components, work packages, or specifications.<a class="indexterm" id="IDX-CHP-19-1520"/></p><p>This is more than a user guide to a piece of software. There is enough detail to build the component from it. Two teams could read the document and work separately on implementions. Although the implementations will differ, both components should behave identically.</p><p>This fact is exploited in practice: Some NASA spacecraft employ five computers to do the job of one; four computers implement the specification for a particular computation, running independently developed implementations. The fifth computer is used to average the results of the four calculations (or to decide if one computer wildly disagrees with the others).</p><p>If you're writing a software component without a functional specification, begin by writing one yourself. Show it to all interested parties so they can agree that what you'll build is sufficient and so they won't be surprised when it is delivered.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>If your software task is not adequately specified, don't start coding until you've written a functional specification, and people agree that it's correct</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="system_architecture_specification"/>System Architecture Specification</h2></div></div></div><p>The <span class="emphasis"><em>architecture specification</em></span> describes the overall shape and structure of the software solution. It encompasses such things as:<a class="indexterm" id="IDX-CHP-19-1521"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Physical computer layout. (Is it distributed client/server software or a single user desktop application?)</p></li><li class="listitem"><p>Software componentization. (How is it split up? Which parts do we need to write; which can we buy in?)</p></li><li class="listitem"><p>Concurrency. (How many threads run at the same time?)</p></li><li class="listitem"><p>Data storage (including database design).</p></li><li class="listitem"><p>All other aspects of the system's architecture (redundancy, communication channels, and more).</p></li></ul></div><p>It is important to specify these things in detail before too much development work happens. The architecture affects the later stages of development; a mistake or ambiguity here will filter down to become serious flaws in later phases. Of course, nothing is set in stone: If you discover a flaw in the architecture specification, then it must be fixed, regardless of how much work has already occurred. Don't accept a bad architecture specification as a millstone around your neck. However, it is important to perform adequate architectural design up front. We discuss software architecture in detail in <a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a>.<a class="indexterm" id="IDX-CHP-19-1522"/><a class="indexterm" id="IDX-CHP-19-1523"/><a class="indexterm" id="IDX-CHP-19-1524"/><a class="indexterm" id="IDX-CHP-19-1525"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="user_interface_specification"/>User Interface Specification</h2></div></div></div><p>This document contains information about the user interface: what it will look like and how it will react. This is how we present the system's capabilities to the user. It might describe a GUI application or a web-based interface, an audible phone menu system, a braille accessibility interface, or a simple, single-LED display.<a class="indexterm" id="IDX-CHP-19-1526"/><a class="indexterm" id="IDX-CHP-19-1527"/></p><p>Sometimes the user's view of the system is very different from the implementation behind the shiny façade. Here are two examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A highly networked system can be deployed on a single box and hidden behind a unified UI.<a class="indexterm" id="IDX-CHP-19-1528"/></p></li><li class="listitem"><p>The available functionality can be simplified for ease of use or to create a cut-down cheaper version.</p></li></ul></div><p>The UI specification describes the interface conventions and metaphors and shows how the user sees the functions interact. It is comprised of a textual description, with pictures and screenshots. It often contains a <span class="emphasis"><em>storyboard</em></span> representation of the UI in action—a pictorial map of each UI state, its transitions, and what is displayed in each. It includes every screen that the user will see and all detail (that is, all graphics, fields, lists, buttons, and the on-screen layout of each). It will also detail acceptable response times for each operation and the behavior in common error cases (this isn't exhaustive—trying to enumerate <span class="emphasis"><em>all</em></span> possible error conditions is a practically endless task!).</p><p>This work may include or lead to a <span class="emphasis"><em>UI prototype</em></span>. Prototypes can be made with varying levels of detail and accuracy; this depends on the application and how much testing and review will be done. Inevitably, the UI design is incomplete at this stage, but this is your first chance to see what the finished product will look like. Although prototypes help to envision how the interface will behave, it's not until the system is integrated that the UI can be properly reviewed and tweaked.<a class="indexterm" id="IDX-CHP-19-1529"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="design_specification"/>Design Specification</h2></div></div></div><p>A <span class="emphasis"><em>design specification</em></span> (or <span class="emphasis"><em>technical specification</em></span>) documents the internal design of a component. It describes how a functional specification will be, or has been, implemented. The design specification describes all internal APIs, data structures, and formats. It should detail all key algorithms, execution paths, and thread interactions. It describes the choice of programming language and the tools used to build the code. All of this is critical information for the code implementers and maintainters.<a class="indexterm" id="IDX-CHP-19-1530"/></p><p>Many heavyweight development processes mandate the production of a design specification prior to implementation; it is reviewed before coding begins to prevent work from progressing down a dead end. However, in most software factories, this document is written alongside, or after, the code.<a class="indexterm" id="IDX-CHP-19-1531"/></p><p>It sounds like such a good idea, but most design specifications are a big waste of time! They need continual maintenance to stay in sync with the code being described. Without care, they quickly rot and are left inaccurate and incomplete—potential snares for unwary readers. For this reason, I suggest that you <span class="emphasis"><em>don't write a design specification</em></span>!</p><p>But wait, before you run off unencumbered, there's more. Replace it with something that contains the same information but is easier to keep accurate. <span class="emphasis"><em>Literate programming tools</em></span> (see "<a class="xref" href="ch04s03.html" title="Practical Self-Documentation Methodologies">Practical Self-Documentation Methodologies</a>" on page 66) are a great documentation mechanism that can replace heavyweight design specifications by generating documentation from the code itself. You need only supply any extra commentary in specially formatted code blocks.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Use literate programming tools to write your technical documentation. Don't write a word-processed document that will quickly go stale</em></span>.</p></dd></dl></div><p>You don't need the complete production code to use literate documentation tools in this way. You can document your intended code structure in the same manner: Mock up some code and run the tool over it. This automatically generates design documentation, serves as prototype proof-of-concept code and, with care, can evolve into the production code.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="test_specification"/>Test Specification</h2></div></div></div><p>The <span class="emphasis"><em>test specification</em></span> describes the testing strategy for a particular piece of software. It shows how to validate the implementation against its functional specification so you know when the software is acceptable for release. Naturally, the size and scope of this task depends on what is being tested: whether it's a single software component, an entire subsystem, a desktop application, or an embedded consumer product.<a class="indexterm" id="IDX-CHP-19-1534"/><a class="indexterm" id="IDX-CHP-19-1532"/><a class="indexterm" id="IDX-CHP-19-1533"/><a class="indexterm" id="IDX-CHP-19-1535"/></p><p>The test specification contains a list of every test that must be performed. Each test is detailed in a <span class="emphasis"><em>test script</em></span>: a set of simple steps to run the test, together with its acceptance criteria and the environment in which the test will run. The scripts themselves may be written in separate documents or included in this one.<a class="indexterm" id="IDX-CHP-19-1536"/></p><p>As we've seen in <a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a>, many code-level tests can be performed <span class="emphasis"><em>in code</em></span> themselves and run as an automated part of the development process. These tests stand distinct from high-level tests that can only be performed by running the software in its final context with scripted human input.</p><p>Wherever you can create programmatic unit tests for your software, prefer to do this rather than create a lengthy test specification. Just as design specifications can rapidly become out of date, test specifications written at the code level will rot as the system evolves around them. Use programatic test code as the documentation of your testing strategy—you can write literate test code as easily as literate normal code. Automated test cycles will also force you to keep the tests up to date with the code; your tests will fail if you don't!</p><div class="sidebar"><a id="devil_apostrophy_s_advocate"/><p class="title"><b>DEVIL'S ADVOCATE</b></p><p>Specifications are expensive: Reading and writing them requires both time and effort. They require extra work. Are all of these documents <span class="emphasis"><em>really</em></span> necessary? Yes, they are—to write high-quality software, you need to consciously generate all this information and then record it somewhere where it can be retrieved when necessary. Specifications encourage us to follow good development practices—to track requirements, perform design, and construct a test plan—and we've seen how they facilitate communication.</p><p>Agile processes (see "<a class="xref" href="ch22s03.html#agile_methodologies" title="Agile Methodologies">Agile Methodologies</a>" on page 433) place far less emphasis on writing specifications, but they don't advocate coding by the seat of your pants. Since specifications don't write themselves, can easily get out-of-date, and require extra work to maintain, and programmers have more than enough to do already, it's sensible to only write as many documents as necessary. We should always avoid lengthy procedural hurdles. <span class="emphasis"><em>But any specification you remove must be replaced by an equivalent store of information</em></span>. Don't skip a specification unless you have conciously replaced it with something of equal quality containing the same set of information.</p><p>Extreme Programming doesn't produce a lengthy requirements specification, but it captures all requirements in an equivalent set of user stories, held on a stack of story cards. Design specifications are eschewed: The code is its own documentation.</p><p>Agile practice also promotes test-driven <span class="emphasis"><em>design</em></span>, where codified tests act as additional documentation of the code and its behavior. This full and clear suite of unit tests can replace the test specification for individual components but is seldom suitable to verify the final product against its validation criteria.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_should_specifications_contain_question"/>What Should Specifications Contain?</h1></div></div></div><p>The contents of each type of specification are naturally very different. However, the information in any specification must be:<a class="indexterm" id="IDX-CHP-19-1537"/><a class="indexterm" id="IDX-CHP-19-1538"/><a class="indexterm" id="IDX-CHP-19-1539"/><a class="indexterm" id="IDX-CHP-19-1540"/><a class="indexterm" id="IDX-CHP-19-1541"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Correct</strong></span></span></dt><dd><p>This might seem obvious, but it is absolutely vital. An incorrect specification can cause days of wasted effort. It must be kept up to date or it will become dangerously misleading: It will waste readers' time, cause confusion, and may lead to bugs being introduced as a consequence.</p><p>If a specification can be interpreted in more than one way, then the "specification" isn't specific—it's not doing its job. Two readers could make different interpretations of the ambiguous information, with inevitable unfortunate consequences. Make sure that your specifications can only be interpreted as you intended.</p><p>The text must not contradict itself. When a specification gets reasonably large, it becomes difficult to ensure consistency. This becomes a particular problem when a maintainer (different from the original author) makes modifications—it can be very easy to alter information in one place and not change any subsequent sections that allude to the same information.</p><p>A specification should be carefully written to comply with all relevant standards (for example, language definitions and company coding standards). It should follow the document standards/conventions of your company and use any document templates that exist.</p></dd><dt><span class="term"><span class="strong"><strong>Comprehensible</strong></span></span></dt><dd><p>An effective specification is inviting to read and easy to understand. It makes sense to every reader. If it's so technical that only engineers can understand it, then non-techie departments (like marketing and management) will not feel part of the audience and will not look at it carefully. Problems won't be spotted until it's too late.</p><p>Like good code, the best specifications are written from the perspective of the reader, not the writer. The information is organized to make it comprehensible to a newcomer, rather than convenient for the author. Blaise Pascal once apologized, "I made this letter longer than usual because I lack the time to make it short." Good writing is concise and doesn't hide the main point behind a wall of words. This does require more work and will take more time, but it's worth it if the result is simpler to understand.<a class="indexterm" id="IDX-CHP-19-1542"/></p><p>Don't feel compelled to write reams of boring prose in a specification. Consider using devices to compress it and make it easier to read. Bulleted and numbered lists, diagrams, headings and subheadings, tables, and judicious use of whitespace break up the flow and help the reader to create a mental map of the material.</p></dd><dt><span class="term"><span class="strong"><strong>Complete</strong></span></span></dt><dd><p>A specification should be self-contained and complete. That doesn't mean it should contain <span class="emphasis"><em>all</em></span> possible information; it is perfectly acceptable to reference other relevant documents, as long as the reference is precise (consider document revisions in your references) and will allow the reader to easily locate the document.</p><p>The level of detail in a specification should be significantly less than the detail in the implementation; otherwise it is either overly prescriptive or too dense to understand. People tend to ignore complicated specifications, so they become abandoned. Left festering in a corner, they only serve to confuse readers who don't realize that they're no longer authoritative.</p></dd><dt><span class="term"><span class="strong"><strong>Verifiable</strong></span></span></dt><dd><p>A specification for a software component interface will lead to the production of two things: the software implementation and a test harness to verify it. The contents of a specification must, therefore, be verifiable. In practice, this largely equates to being correct, unambiguous, and complete.</p></dd><dt><span class="term"><span class="strong"><strong>Modifiable</strong></span></span></dt><dd><p>Nothing is set in stone, neither code nor documents. If a specification needs updating (perhaps to correct a factual error) then this should be easy. A cast-iron specification prevents the world changing underneath your feet. However, it's no use if the specification is wrong. The document must be editable (i.e., you should be able to get to the source, not just a PDF copy), and its release and update procedure must not be too troublesome.</p><p>In order to make modifications easily, the document must be carefully structured and no bigger than absolutely necessary.</p></dd><dt><span class="term"><span class="strong"><strong>Self-describing</strong></span></span></dt><dd><p>Each specification must contain at least:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>frontsheet</em></span>, clearly showing the document title, subtitle, author(s), revision number, date last modified, and document release status (e.g., company confidential, supplied externally under NDA, or a public release).<a class="indexterm" id="IDX-CHP-19-1543"/></p></li><li class="listitem"><p>An <span class="emphasis"><em>introduction</em></span> to the document, providing a brief summary of its aims, scope, and the target audience.</p></li><li class="listitem"><p>All relevant <span class="emphasis"><em>terms and definitions</em></span> that the reader needs in order to understand the contents. (But don't patronize the reader: If your audience is made up of software engineers, don't explain what RAM stands for.)</p></li><li class="listitem"><p>A set of <span class="emphasis"><em>references</em></span> to other related or cross-referenced documents.</p></li><li class="listitem"><p>A <span class="emphasis"><em>history</em></span> section that lists all important modification and revision information.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Traceable</strong></span></span></dt><dd><p>There should be a document control procedure (akin to a source management system) and a central file store in which all documents reside. Every release version of a specification should be lodged in the repository and must remain be accessible, so you can discover which version of a spec you were working to a year ago; one day you'll need it again. Consider using a revision control system—it's a great tool for versioning any sort of file.</p><p>The document frontsheet contains control information (version number, date, author, etc.) so you can check that you have the most up-to-date copy.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Think about the contents of your specification as you write it. Choose a structure and vocabulary that the audience will understand, and make sure that the document is correct, complete, and self-describing</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_specification-writing_process"/>The Specification-Writing Process</h1></div></div></div><div class="epigraph"><p>What is written without effort is in general read without pleasure.<a class="indexterm" id="IDX-CHP-19-1544"/><a class="indexterm" id="IDX-CHP-19-1545"/></p><div class="attribution"><span>--<span class="attribution">Samuel Johnson</span></span></div></div><p>Now knowing the types of specification we must produce and what should go in them, we're armed and ready. It's time to write something! The specification-writing process is simple:<a class="indexterm" id="IDX-CHP-19-1546"/><a class="indexterm" id="IDX-CHP-19-1547"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Select the appropriate document template to start from. This may be provided as part of a defined project development process. If there is no template, base it on an existing specification.</p></li><li class="listitem"><p>Write the document. Okay, this is the hard part. What you write naturally depends on the type of specification.</p></li><li class="listitem"><p>Arrange for the document to be reviewed. Include all the people with an interest in it.</p></li><li class="listitem"><p>Once it's agreed upon (and, if your process demands, formally signed off on), put a versioned copy in the document repository and release it to the appropriate audience.</p></li><li class="listitem"><p>If there are any later problems, raise a change request for the specification and make sure that you understand how the modification affects the scope of your development work. If you don't, then the coding effort will double without anyone noticing.</p></li></ol></div><p>This is a simple procedure to list, but it isn't simple to do. It's easy to focus only on step 2—we skip the rest for an easy life. But without these other actions, you haven't created a formal identifiable document; this may cause problems later.</p><p>Consider these spec-writing guidelines when composing your literary masterpiece. The first few relate to authorship and to your artistic sensibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Writing usually works best when there is one author per document. It's hard to coordinate multiple authors and accommodate different writing styles. If you are documenting a big system, then split the specification into parts and give one to each person to work on separately. Create an umbrella document that links them all together.<a class="indexterm" id="IDX-CHP-19-1548"/></p><p>Contrary to some opinions, it is not at all egotistical to have one person's name on the front of a specification. Someone needs to take credit for it—praise when it's a good job and blame when it's not.</p><p>If you significantly extend someone else's document, don't feel embarassed to add yourself to the list of authors. But don't remove someone from the author list unless his or her original input has now been removed.</p><div class="sidebar"><a id="language_barriers-id1"/><p class="title"><b>LANGUAGE BARRIERS</b></p><p>I hate definitions.</p><p>—Benjamin Disraeli</p><p>Compose your specification's text very carefully. Compared to code, the English language is full of ambiguity and complexity. These <span class="emphasis"><em>genuine</em></span> newspaper headlines show just how ambiguous seemingly simple English statements can be: "Stolen painting found by tree," "Kids make nutritious snacks," "Red tape holds up new bridge," and "Hospitals are sued by <span class="emphasis"><em>7</em></span> foot doctors."</p><p>Specifications are formal documents and they must not be chatty or verbose; this tends to hide the important facts behind a wall of words. Non-native English readers may struggle. However, a terse document is hard to follow. This is a delicate balance, and document review helps to determine the correct style of writing.</p><p>Formal documents are written in the third person, in present tense. An accurate selection of words is very important. A useful convention is defined in the Internet RFC document #2119. This defines the following key terms for protocol specifications (which are also very useful in requirements specifications):<a class="indexterm" id="IDX-CHP-19-1549"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Must</strong></span></span></dt><dd><p>The word <span class="emphasis"><em>must</em></span> (<span class="emphasis"><em>or shall or is required to</em></span>) means that the following definition is an absolute requirement of the specification.</p></dd><dt><span class="term"><span class="strong"><strong>Must not</strong></span></span></dt><dd><p>The words <span class="emphasis"><em>must not</em></span> (<span class="emphasis"><em>or shall not</em></span>) signify an absolute prohibition of the specification.</p></dd><dt><span class="term"><span class="strong"><strong>Should</strong></span></span></dt><dd><p>Use <span class="emphasis"><em>should</em></span> (or the adjective <span class="emphasis"><em>recommended</em></span>) to indicate an optional requirement— behavior that may be ignored, but only when the full implications are understood and have been carefully considered.</p></dd><dt><span class="term"><span class="strong"><strong>Should not</strong></span></span></dt><dd><p>Use <span class="emphasis"><em>should</em></span> not (or the adjective not <span class="emphasis"><em>recommended</em></span>) to describe a particular behavior that should be avoided unless there are valid reasons to choose it— again, the consequences must be fully understood.</p></dd><dt><span class="term"><span class="strong"><strong>May</strong></span></span></dt><dd><p>Using <span class="emphasis"><em>may</em></span> (or the adjective optional) means that an item is truly optional. An implementer can choose to support it or ignore it but, when applied to protocols, it must interoperate with another implementation that made a different choice.</p><p>This is the word that should often be used when people write can. <span class="emphasis"><em>Can</em></span> is a commonly misused word in specifications and standards; it is ambiguous and, depending on the reader's interpretation, could be taken to mean <span class="emphasis"><em>must</em></span> or <span class="emphasis"><em>may</em></span>.</p></dd></dl></div></div></li><li class="listitem"><p>The author must be the right person. The marketing department doesn't write your functional specification; it provides requirements. Managers don't design the code; the developer with the right skill and knowledge does it. The author must be capable of writing—it's a skill that's learned, a muscle that requires exercise.</p></li><li class="listitem"><p>Each document must have a defined <span class="emphasis"><em>owner</em></span> who takes responsibility for it. The owner may be different from the original author; it might be the technical authority or the document's maintainer now that the primary author has moved on.</p></li></ul></div><p>Here are some tips for the document writing process:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It's good to have a <span class="emphasis"><em>best practice</em></span> example of each kind of specification. This will help authors to understand what is expected of them as they write.</p></li><li class="listitem"><p>Early drafts of a specification should be marked as such, with a disclaimer stating that it is incomplete. This will prevent people from mistakenly interpreting it as complete—they can't moan at you about the content (yet). Maintain a list of the incomplete sections and open issues within the document itself.</p></li><li class="listitem"><p>Document review is important: It checks that the contents are correct and well presented. It is a mechanism to get others' agreement with your decisions and to thereby bestow authority on the document. This is especially important for specifications that are sent outside the project: to the customer or to other departments.<a class="indexterm" id="IDX-CHP-19-1550"/></p></li><li class="listitem"><p>Once you've finished the specification, don't forget about it. Keep it alive and up to date. A functional specification is not complete when the design phase is over. Requirements inevitably change, and we continue to learn more about the system's operation. Capture all of this in revised specifications.</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_dont_we_write_specifications_question"/>Why Don't We Write Specifications?</h1></div></div></div><div class="epigraph"><p>I do not understand what I do. For what I want to do I do not do, but what I hate I do.<a class="indexterm" id="IDX-CHP-19-1551"/></p><div class="attribution"><span>--<span class="attribution">Romans 7:15</span></span></div></div><p>Decent specifications are conspicuous by their absence in the Real World. We know it's not good practice to avoid them, so hasty developers gloss over their absense and pretend that there's no problem. It's not unusual to be given a coding task without an adequate requirements or functional specification. (This is a procedural problem that must be overcome by persistent moaning, education, and abuse of the powers that be.)</p><p>But it's equally common for sloppy programmers to sidestep their own document writing. Why is this? There are a few excuses we meet repeatedly. Developers don't write specifications because:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They don't know that they should</p></li><li class="listitem"><p>They forget</p></li><li class="listitem"><p>They don't have the time</p></li><li class="listitem"><p>They consciously decide not to, thinking they can get by without them ("Who reads specifications, anyway?")</p></li></ul></div><p>None of these reasons are defensible. An experienced developer certainly shouldn't fall foul of the first two if a specification is an expected deliverable of his or her work.</p><p>Programmers like to program, not write long documents. Most programmers don't have good writing skills; they write elegant code but awful English. It's hardly surprising that they try to avoid writing specs: It's hard work, uninteresting, or they just don't like doing it. Often it's seen as a time wasting activity that isn't really necessary. Or they think, <span class="emphasis"><em>I'll code first, then come back to the documentation later</em></span>. Bitter experience shows that this does not happen.</p><p>The depressing thought that <span class="emphasis"><em>no one will ever read my beautiful specification</em></span> puts many more programmers off of the idea of committing their brainwaves to prose. And it's probably true: No other soul may ever read your literary masterpiece. But so what? The act of specification writing forces <span class="emphasis"><em>you</em></span> to engage your brain: a very important step. Sure, a few Gurus can code on the run and produce excellent work. But most programmers, whether they admit it or not, simply can't. We need to design. Carefully. First. That design should then be captured: in a document. Potentially, this document will be for your eyes only. But, if one day you hear a higher calling and run off to become a Croatian monk, how can a maintenance programmer pick up your work? The specification will outlive you. Think of it as your legacy.</p><p>Not having time is the only scenario that <span class="emphasis"><em>you</em></span> don't have control over: Sometimes a coding task lands in front of you and there genuinely isn't enough time to write a good specification for it. If you have no time to write a specification, then you probably don't have time to write the code properly either. Make sure you're aware of when you're doing things properly and when you're rushing code out without any real discipline—that sort of code really doesn't belong in a production release.</p><p>Saving time by avoiding specifications is almost certainly a false economy; specifications help to <span class="emphasis"><em>save time</em></span> communicating. When you write a specification, you only have to describe how the program works once. If you skip this step, at least the same amount of communication happens anyway, but on an ad hoc basis—over a longer space of time and in a less controlled manner. This communication is far less effective and will actually take <span class="emphasis"><em>longer</em></span>, because you will have to explain the same things over and over again with a slightly different spin for each audience.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>It is dangerous and unprofessional to avoid writing specifications. If there isn't enough time to write a specification, there probably isn't enough time to write the code</em></span>.</p></dd></dl></div><p>Of course, few people write detailed specifications at home for their own personal pet projects. This is an extreme case of an appropriately detailed specification. Any reasonably large project (which could be determined by the number of source files, modules, developers, or customers) really does require specification support.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id18"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Words are, of course, the most powerful drug used by mankind.<a class="indexterm" id="IDX-CHP-19-1552"/></p><div class="attribution"><span>--<span class="attribution">Rudyard Kipling</span></span></div></div><p>They're not the most glamorous part of a software developer's life, but specifications are an important part of our code-writing routine. Learn to read and write them effectively—to record the right information in the right place, in a way that will save time and hassle later. But don't become enslaved by a paper-chain bureaucracy.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand the importance of specifications and use them to make their development lives easier</p></li><li class="listitem"><p>Know the <span class="emphasis"><em>appropriate</em></span> level of documentation required<a class="indexterm" id="IDX-CHP-19-1553"/></p></li><li class="listitem"><p>Want to improve their writing skills and seek reviews and chances to practice</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Dive headlong into a code task without a thought for design, documentation, or review</p></li><li class="listitem"><p>Don't think about the text they are writing; they produce unstructured, hard-to-follow specifications</p></li><li class="listitem"><p>Avoid writing documents, thinking it's boring and pointless</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id18"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p><span class="emphasis"><em>Self-documenting code</em></span> is a solid technique that helps to eliminate some code documentation. Good code is so easy and intuitive to work with that it doesn't need a long manual.</p></dd><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></span></dt><dd><p>Consider change control and a backup strategy for your specifications—they're as vital as your code and need protecting.</p></dd><dt><span class="term"><a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a></span></dt><dd><p>Just like your code, any document you write should be reviewed to ensure that it's correct and of a high quality.</p></dd><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>Specifications are an essential part of the software development process and are often the gates between development phases.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e27578"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207568.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id19"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 544.<a class="indexterm" id="IDX-CHP-19-1554"/><a class="indexterm" id="IDX-CHP-19-1555"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id18"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Is a poor specification better than no specification at all?</p></li><li class="listitem"><p>How detailed does a good specification have to be?</p></li><li class="listitem"><p>Is it important that all the documents in a company/project have a common presentation style?</p></li><li class="listitem"><p>How should you store documents? Should you provide an index of them (by type or by project), for example?</p></li><li class="listitem"><p>How should you conduct a specification review?</p></li><li class="listitem"><p>Does self-documenting code render all specifications useless? Specific ones?<a class="indexterm" id="IDX-CHP-19-1556"/></p></li><li class="listitem"><p>How can a document be collaborated on by more than one author?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id19"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Who decides on the contents of your documents?</p></li><li class="listitem"><p>Consider your current project. Do you have:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A requirements specification?</p></li><li class="listitem"><p>An architecture specification?</p></li><li class="listitem"><p>A design specification?</p></li><li class="listitem"><p>A functional specification?</p></li><li class="listitem"><p>Any other specification?</p><p>Are they up to date? Are they complete? Do you know how to get the latest versions? Can you access historical revisions?</p></li></ol></div></li><li class="listitem"><p>Do you revision control your documents? If so, how?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="a_review_to_a_kill"/>Chapter 20. A REVIEW TO A KILL</h1></div><div><h3 class="subtitle"><i>Performing Code Reviews</i></h3></div></div></div><div class="epigraph"><p>Reviewing has one advantage over suicide: in suicide you take it out on yourself; in reviewing you take it out on other people.</p><div class="attribution"><span>--<span class="attribution">George Bernard Shaw</span></span></div></div><p>How do you learn to be a good carpenter? You become a carpenter's apprentice. You watch the master work, help him daily, gradually take on more responsibility, and learn from his advice. You don't jump in feet first without any practical ability and expect to churn out quality woodwork right away.</p><p>We don't have a version of that in the coding world, even though programming is as much a craft as it is an engineering discipline (possibly more so). A good programmer learns the difference between good and bad code by experiencing it firsthand, discovering what works in Real Life and what doesn't. This is the stuff that books can't teach you, andonly a lucky few ever learn these things from a mentor. <span class="emphasis"><em>Code reviews</em></span> are about as close as most of us will ever come to this ideal.</p><p>Code reviews (also called <span class="emphasis"><em>inspections</em></span> or <span class="emphasis"><em>walkthroughs</em></span>) are similar to the open source model of software development—providing a structured opportunity for others to eyeball your precious code and for you to inspect others' work. They facilitate knowledge interchange. But their primary goal is to increase software quality. They help you to spot faults before they become raging disasters.<a class="indexterm" id="IDX-CHP-20-1559"/><a class="indexterm" id="IDX-CHP-20-1560"/><a class="indexterm" id="IDX-CHP-20-1561"/></p><p>Code reviews also have another subtle advantage: They encourage you to take greaterresponsibility for your handiwork. When you know that the code isn't just for <span class="emphasis"><em>you</em></span> to look at, but that it will be viewed, used, maintained, and criticized by others, your approach tends to change. You're less likely to make the quick-and-dirty fix that you'll never have time to revise. The accountability brought on by code reviews brings a greater quality to your coding. They help to establish the "<a class="xref" href="ch17s06.html#collective_code_ownership" title="Collective Code Ownership">Collective Code Ownership</a>" culture described in "<a class="xref" href="ch17s06.html#collective_code_ownership" title="Collective Code Ownership">Collective Code Ownership</a>" on page 336.<a class="indexterm" id="IDX-CHP-20-1562"/></p><p>Sound good, don't they? Let's pop the hood and see how they work. . . .</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_code_review_question"/>What Is a Code Review?</h1></div></div></div><p>A review places source code under the microscope—really aiming to criticize and verify it. This is not to ridicule or get at the author, but to improve the quality of software that the team produces. The process normally generates a list of must-fix issues (the size of the list is a reflection of the quality of your programming skills!). Sometimes you will spot improvements that are not worth making now; chalk up those discoveries for future experience.<a class="indexterm" id="IDX-CHP-20-1563"/></p><p>We look for bugs and any code that could be improved. The code review weeds out problems at several levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The overall design (we check the choice of algorithms and external interfaces).<a class="indexterm" id="IDX-CHP-20-1564"/></p></li><li class="listitem"><p>The expression of that design in the code (its breakdown into classes andfunctions).</p></li><li class="listitem"><p>The code in each semantic block (we check that each class, function, and loop is correct, follows appropriate language idioms, and is a practical implementation choice).</p></li><li class="listitem"><p>Each individual code statement (each must follow project coding standardsand best practices).</p></li></ul></div><p>Code reviews can be:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Personal</strong></span></span></dt><dd><p>The author carefully and methodically reviews his or her own work to makesure that it's good. Don't get this confused with casually reading your code after typingit; a personal code review is a more detailed and involved task.<a class="indexterm" id="IDX-CHP-20-1565"/></p></dd><dt><span class="term"><span class="strong"><strong>One-on-one</strong></span></span></dt><dd><p>You walk another programmer through your code. The other programmer checks the logic and looks out for faults as you lead through it. These reviews tend to be informal, driven by the author. The code is therefore approached from the author's perspective: with his or her set of assumptions, rather than from a more objective, outside view.</p></dd><dt><span class="term"><span class="strong"><strong>Formal</strong></span></span></dt><dd><p>Involving other programmers brings new expertise, more experience, and more eyeballs to the task and shifts the perspective from which the review is run. Large-scale reviews are consequently harder to coordinate and require greater overall effort, but they are more likely to root out problems. It's difficult to delve this deeply in a personal review; often the author is too close to the code, and it's easy to overlook flaws.</p><p>This usually takes place in a formal meeting, but it can be run as a virtual review: online, with no physical meeting.</p></dd></dl></div><p>Each type of review can be used at a different time in the development process. One-to-ones might be used daily throughout code development, as an integration review before modifications are committed to the main source tree. Formal reviews are brought in toward the end of code development, as a final software quality audit.</p><p>Apart from the obvious benefits of correct code, reviews have other useful side effects. The cross fertilization that comes from looking at each other's code ensures that coding style is more uniform across a whole project. A review also spreads knowledge about the inner workings of core bits of code, so there is less risk of losing information when people leave a project (a very real problem—see "<a class="xref" href="ch17s07.html#team_closure" title="Team Closure">Team Closure</a>" on page 343).</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Code reviews are excellent tools to detect and eliminate hard-to-find bugs, to increase code quality, to enforce collective code responsibility, and to spread knowledge</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="when_do_you_review_question"/>When Do You Review?</h1></div></div></div><div class="epigraph"><p>If you are not criticized, you may not be doing much.<a class="indexterm" id="IDX-CHP-20-1566"/><a class="indexterm" id="IDX-CHP-20-1567"/></p><div class="attribution"><span>--<span class="attribution">Donald H. Rumsfeld</span></span></div></div><p>In an ideal world, every bit of code would be carefully reviewed prior to release. According to the Software Engineering Institute at Carnegie Mellon University, a thoroughcode review should take at least 50 percent or more of coding time (personal code review is included in this statistic). (Humphrey 98) That would take longer than most Real Worldprojects are prepared to invest.<sup>[<a class="footnote" href="#ftn.CHP-20-FN-1" id="CHP-20-FN-1">1</a>]</sup></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>As we write a system, we need to ask</em></span> whether <span class="emphasis"><em>to review the code and, if so, exactly</em></span> which <span class="emphasis"><em>code to review</em></span>.</p></dd></dl></div><div class="sidebar"><a id="reviewing_the_alternatives"/><p class="title"><b>REVIEWING THE ALTERNATIVES</b></p><p>There are a number of development techniques that have been argued to make formal code reviews redundant. These are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Pair programming</strong></span></span></dt><dd><p>When you pair program (described in "<a class="xref" href="ch17s02.html#it_apostrophy_s_all_going_pair_shaped" title="IT'S ALL GOING PAIR SHAPED">IT'S ALL GOING PAIR SHAPED</a>" on page 319), your code is effectively reviewed on the fly. Two pairs of eyes are better than one and will find many, many more faults—as they are entered. However, code reviews cancatch even more problems by employing reviewers who are physically and emotionally removed from the implementation work.</p></dd><dt><span class="term"><span class="strong"><strong>Open source</strong></span></span></dt><dd><p>Opening and freely releasing the source code allows anyone to see it, to judge the code's quality, and to fix problems. Some call this the ultimate code review. However, it doesn't actually guarantee that anyone <span class="emphasis"><em>will</em></span> inspect the source. Only really popular open projects have actively maintained codebases. Making your code open source will not instantly bring code review–like benefits.<a class="indexterm" id="IDX-CHP-20-1568"/></p></dd><dt><span class="term"><span class="strong"><strong>Unit tests</strong></span></span></dt><dd><p>These are an automatic means to show that a modification hasn't degraded the <span class="emphasis"><em>correctness</em></span> of your code's output (see "<a class="xref" href="ch08s07.html" title="Look! No Hands!">Look! No Hands!</a>" on page 144), but they don'thelp to increase the overall quality of the written code statements. Your code could be ajumbled mess of spaghetti, but if it passes the unit tests, no one will notice. If the unit tests aren't rigorous, bugs could still slip through, regardless.<a class="indexterm" id="IDX-CHP-20-1569"/></p></dd><dt><span class="term"><span class="strong"><strong>Not reviewing</strong></span></span></dt><dd><p>Alternatively, you can just trust the programmer to get it right—that's his job after all. If this is a winning strategy, then you don't need to test the code either. Good luck!</p><p>None of these, on their own, can honestly replace the code review. Perhaps a combination of them and a particularly effective development team culture would render reviews less necessary, but I've yet to meet a team where that has been the case.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="whether_to_review"/>Whether to Review</h2></div></div></div><p>We've seen that bugs are inevitable, and that you can be sure your code contains some classic mistakes. There will be obvious flaws that you'll find quickly and many more subtle problems that would only be spotted by a fresh pair of eyes approaching the code with no preconceptions. It's hard for the original author to see the inherent faults in hisown work—he's too close to the codeface, suffering the psychological <span class="emphasis"><em>cognitive dissonance</em></span> described in. (Weinberg 71) If your code is at all important (clue: it is, or you wouldn't have written it) and if you care about its quality (clue: you do, or you're a disgrace), then you <span class="emphasis"><em>must</em></span> review it.<a class="indexterm" id="IDX-CHP-20-1572"/><a class="indexterm" id="IDX-CHP-20-1570"/><a class="indexterm" id="IDX-CHP-20-1571"/></p><p>Not reviewing code drastically increases the chance of faults slipping into your production software. That could spell your embarrassment, a lot of expensive rework and in-the-field upgrades and, in extreme cases, your company's financial ruin. The effort of a code review pales in comparison to the consequences. According to Humphrey, "Students andengineers typically inject 1 to 3 defects per hour during design and 5 to 8 defects when writing code. They only remove about 2 to 4 defects per hour in testing but find 6 to 12 per hour during code review." (Humphrey 97)</p><p>People often make excuses to justify avoiding reviews. They say, "The code's too large to review fully," or "It's too complex; no one person could ever understand it—there's no point in even <span class="emphasis"><em>trying</em></span> to review it." If a project can muster enough man-hours to write a large program, it can find enough time to review it. If the code is too complex, then it desperately needs to be reviewed! In fact, it probably needs something a little more drastic. Well-written code is decomposed into self-contained sections that can undergo separate reviews.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="which_code_to_review"/>Which Code to Review</h2></div></div></div><p>Any project will quickly produce a ton of source code. For all but the most stringent development processes, there simply isn't enough time to review every last scrap of code. So how do you decide which parts to review? That isn't easy.<a class="indexterm" id="IDX-CHP-20-1573"/><a class="indexterm" id="IDX-CHP-20-1574"/><a class="indexterm" id="IDX-CHP-20-1575"/></p><p>You must select the code that will benefit most from review. This is the code that is most likely to be bad or that is most important to the correct functioning of your system. You could try these strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Select core bits of code in the central components.</p></li><li class="listitem"><p>Run a profiler to see where most CPU time is spent, and review those parts of code.</p></li><li class="listitem"><p>Run compexity analysis tools, and review the worst offending code.</p></li><li class="listitem"><p>Target areas that have already exhibited a high bug count.</p></li><li class="listitem"><p>Pick on code written by programmers you don't trust (a code review vendetta!).<a class="indexterm" id="IDX-CHP-20-1576"/></p></li></ul></div><p>The most practical approach is probably a hybrid of all of the above. Pick the bestcode candidates based on a sober assessment of your team, the codebase, and the current system characteristics (performance, bug count, etc.).</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Select the code you review carefully. If you can't review everything, make</em></span> informed <span class="emphasis"><em>choices about review candidates. Don't guess—you might waste your precious time</em></span>.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-1" id="ftn.CHP-20-FN-1">1</a>] </sup>The fact that they're rarely prepared to invest any time in code review is a more serious problem.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="performing_code_reviews"/>Performing Code Reviews</h1></div></div></div><div class="epigraph"><p>That which we persist in doing becomes easier, not that the task itself has become easier, but that our ability to perform it has improved.</p><div class="attribution"><span>--<span class="attribution">Ralph Waldo Emerson</span></span></div></div><p>Simply <span class="emphasis"><em>having</em></span> a code review is not enough. It's not going to solve all the problems itself. You also need to make sure that you review <span class="emphasis"><em>properly</em></span>. The next few sections describe how to do this.<a class="indexterm" id="IDX-CHP-20-1577"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="code_review_meetings"/>Code Review Meetings</h2></div></div></div><p>The most common review setting (at least in high-ceremony development processes) isthe formal <span class="emphasis"><em>code review meeting</em></span>. There is a fixed agenda (to ensure that no action is forgotten) and a defined ending (not necessarily a time limit, but a definition of exactly which code you are reviewing, and which you aren't—it's very easy to be unclear about this).<a class="indexterm" id="IDX-CHP-20-1578"/><a class="indexterm" id="IDX-CHP-20-1579"/><a class="indexterm" id="IDX-CHP-20-1580"/><a class="indexterm" id="IDX-CHP-20-1581"/><a class="indexterm" id="IDX-CHP-20-1582"/></p><p>An example code review meeting procedure is described below.</p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="where_question"/>Where?</h3></div></div></div><p>The best place to hold a code review meeting is in a quiet room. The reviewers should not be disturbed. There should be coffee (and, for those who must, tea) available.</p><p>A suite of networked laptops with code editors may be useful, as may a computer hooked up to a projector. Old-school programmers swear by printouts and pen-and-paper notetaking—detaching from the computer screen can help to find new faults. This really depends on how much respect you have for trees and electricity consumption.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="when_question"/>When?</h3></div></div></div><p>Obviously, at a mutually convenient time. Common sense tells us that Friday at 5 PMis not a good time. You need to devote serious time to this, so make sure that you won't be disturbed or distracted.</p><p>If the code is too large, split the review into a number of separate sessions. You can't sit people in an enclosed space for hours on end and expect the quality of their review to remain high.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="roles_and_responsibilities"/>Roles and Responsibilities</h3></div></div></div><p>One of the most important factors contributing to the success of a code review meeting is who attends. Each attendee should be assigned a specific role; in small groups it is likely that people will take on multiple roles. These roles will include:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Author</strong></span></span></dt><dd><p>Obviously the person who wrote the code should attend the review to describe what he or she has done, refute unfair or incorrect criticism, and listen to (and subsequently act on) valid, constructive feedback.</p></dd><dt><span class="term"><span class="strong"><strong>Reviewers</strong></span></span></dt><dd><p>The reviewers should be carefully picked, people with available time and skill to review. It helps if the code is within their area of expertise or if they are involved with it in some way. For instance, the writer of a library should be invited to review a program that uses the library to diagnose incorrect API usage.</p><p>There should be an appropriate number of experienced software engineers present. There should possibly be a representative from the QA or testing department (see "<a class="xref" href="ch08.html#quality_assurance" title="QUALITY ASSURANCE">QUALITY ASSURANCE</a>" on page 132) so QA can be assured of the software's quality and of the quality of thedevelopment process.</p></dd><dt><span class="term"><span class="strong"><strong>Chairman</strong></span></span></dt><dd><p>Any meeting needs a chairman, or chaos will ensue (see "<a class="xref" href="ch17s07.html#meeting_your_fate" title="MEETING YOUR FATE">MEETING YOUR FATE</a>" on page 340). This person leads the review and guides the discussion. He or she ensuresthat the conversation keeps to the point and that the meeting doesn't get sidetracked. Any minor issues that don't need to be discussed in the meeting should be quickly taken offline by the chairman. Given half a chance, programmers will discuss a minute technical detail for hours at the expense of the rest of the code review.<a class="indexterm" id="IDX-CHP-20-1583"/></p></dd><dt><span class="term"><span class="strong"><strong>Secretary</strong></span></span></dt><dd><p>The secretary takes minutes. This means writing down all points that arise, to make sure that nothing is forgotten after the review. If there is a review checklist (see the example on page 398), the secretary fills it in. The secretary role should notbe fulfilled by the same person who acts as chairman.<a class="indexterm" id="IDX-CHP-20-1584"/></p></dd></dl></div><p>Before arrival, everyone is expected to have familiarized themselves with the code. Everyone must have read the supporting documentation (any relevant specifications, etc.)<sup>[<a class="footnote" href="#ftn.CHP-20-FN-2" id="CHP-20-FN-2">2</a>]</sup> and must be aware of any project coding standards. Whoever organizes the meeting should highlight these documents in the meeting announcement to prevent misunderstanding.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="agenda"/>Agenda</h3></div></div></div><p>To organize the code review meeting:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The author signals that their code is ready for review.</p></li><li class="listitem"><p>The chairman arranges the meeting (booking an appropriate location, setting the time, and assembling the correct set of reviewers).</p></li><li class="listitem"><p>All required resources (computers, a projector, printouts, etc.) are arranged.</p></li><li class="listitem"><p>The meeting must be called sufficiently ahead of time to allow the reviewers to prepare.</p></li><li class="listitem"><p>After the meeting announcement, the author cannot change the code gratuitously—this is not fair to the reviewers.</p></li></ul></div><p>The code review meeting is run as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The chairman arranges for the room to be prepared beforehand so the review can start on time.</p></li><li class="listitem"><p>The author takes a few minutes (no longer!) to explain the purpose of the code and a little bit about its structure. This should be prior knowledge, but it's surprising what misunderstandings can be caught at this first stage.</p></li><li class="listitem"><p>Structural design comments are invited. These are comments relating to the structure of the implementation—not the code at statement level. This could include the breakdown of functionality into classes, the split of code into files, and the style of function writing. (Is it sufficiently defensive, andare there good tests?)</p></li><li class="listitem"><p>General code comments are invited. These may relate to a consistent incorrect coding style, bad application of design patterns, or incorrect language idioms.<a class="indexterm" id="IDX-CHP-20-1585"/><a class="indexterm" id="IDX-CHP-20-1586"/></p></li><li class="listitem"><p>The code is carefully stepped through in detail, a line or block at a time, to look for flaws. The things to look out for are described later (in "<a class="xref" href="ch20s05.html" title="Code Perfection">Code Perfection</a>" on page 395).</p></li><li class="listitem"><p>A number of example scenarios of code usage are considered, and the flow of control is investigated. If there is a complete suite of unit tests (there should be) then these detail all the scenarios to explore. This helps the reviewers cover all execution paths.</p></li><li class="listitem"><p>The secretary notes all changes required (recording the filename and line number).</p></li><li class="listitem"><p>Any issue that might percolate out to the wider codebase is recorded for further investigation.</p></li><li class="listitem"><p>When the review has finished, a follow-up step should be agreed upon. The possible scenarios are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Okay</strong></span></span></dt><dd><p>The code is fine, no further work is necessary.</p></dd><dt><span class="term"><span class="strong"><strong>Rework and verify</strong></span></span></dt><dd><p>The code needs some rework, but another code review meeting is unnecessary. The chairman nominates someone to act as <span class="emphasis"><em>verifier</em></span>. When the rework is complete, the verifier checks it against the recorded minutes of the code review meeting.</p><p>A reasonable deadline should be imposed for any rework, so that the detail of and reasons for actions stay fresh in people's minds.</p></dd><dt><span class="term"><span class="strong"><strong>Rework and re-review</strong></span></span></dt><dd><p>The code needs a lot of rework, and another code review is deemed necessary.</p></dd></dl></div></li></ul></div><p>Remember, the aim here is to identify problems, not to fix them during the meeting. Some problems require considerable thought to fix, and this is a job for the author (or modifier) after the review has finished.</p><p>You may find it useful to use the code review checklist at the end of this chapter when conducting your reviews.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="integration_reviews"/>Integration Reviews</h2></div></div></div><p>Code review meetings are a high-ceremony review method. They're hard work, but theyundoubtedly find many problems that would otherwise go undetected.</p><p>Other, less intense review procedures exist, providing most of the benefits of codereview meetings but packaged in an easier-to-swallow pill. Perhaps the most effective is the <span class="emphasis"><em>integration review</em></span>, performed whenever new code is integrated onto a mainline code branch.</p><p>This could be when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A new piece of code <span class="emphasis"><em>is about to be</em></span> checked into source control</p></li><li class="listitem"><p>A new piece of code <span class="emphasis"><em>has just been</em></span> checked into source control</p></li><li class="listitem"><p>A code package is merged from a feature development branch onto the main release branch</p></li></ul></div><p>At such a point, the code in question is marked for review, and a suitable revieweris picked: either someone responsible for that module (the code integrator or maintainer<sup>[<a class="footnote" href="#ftn.CHP-20-FN-3" id="CHP-20-FN-3">3</a>]</sup>) or a <span class="emphasis"><em>shadow</em></span> (or <span class="emphasis"><em>code buddy</em></span>) who is assignedto verify that author's work in a one-on-one review session.<a class="indexterm" id="IDX-CHP-20-1587"/><a class="indexterm" id="IDX-CHP-20-1588"/></p><p>These gated code check-ins are often implemented with a software tool that is integrated with the source control system. They're quite hard to arrange manually and are usually left as a check-in discipline: You are not supposed to check any code in until it hasbeen peer reviewed. This approach is quite hard to police; errors can slip past in hurried, last-minute check-ins.</p><p>The actual review step here is usually a lot less formal than the meetings described earlier. The reviewer scans the code to check that it isn't obviously broken, tests it (perhaps reviewing the available unit tests to ensure that they're valid), and then authorizes it for inclusion in the mainline. Only then will the code integrator migrate the verified code into the release tree. For more serious projects, or at more sensitive times ( just before a major release milestone, for example) this review step may become much more stringent—requiring more eyeballs and more effort.</p><p>Since the reviewer and author don't need to actually meet face to face (although itis preferable to do so), this can be considered a form of virtual review process.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-2" id="ftn.CHP-20-FN-2">2</a>] </sup>Naturally, all supporting documentation will have been thoroughly reviewed beforehand.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-3" id="ftn.CHP-20-FN-3">3</a>] </sup>Compare this with an open source project's maintainer, who collates patches submitted by other hackers and integrates them into the main source tree, performing periodic software update releases.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="review_your_attitudes"/>Review Your Attitudes</h1></div></div></div><div class="epigraph"><p>Do to others as you would have them do to you.<a class="indexterm" id="IDX-CHP-20-1589"/><a class="indexterm" id="IDX-CHP-20-1590"/><a class="indexterm" id="IDX-CHP-20-1591"/><a class="indexterm" id="IDX-CHP-20-1592"/></p><div class="attribution"><span>--<span class="attribution">Luke 6:31</span></span></div></div><p>Code reviews require a constructive attitude—you need to approach a review with the correct mindset, or it will be unsuccessful. This works two ways: for the author and the reviewer.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_authors_attitude"/>The Author's Attitude</h2></div></div></div><p>Many people shy away from a code review for fear it will expose their inadequacies. Don't do this. Having your code reviewed is a good way to learn new techniques. You must be humble enough to admit that you're not perfect and are willing to accept criticism from others. Your coding style will improve as you learn from the changes made to your work.</p><div class="sidebar"><a id="method_in_our_madness"/><p class="title"><b>METHOD IN OUR MADNESS</b></p><p>Code reviews are a universally acknowledged technique and have been around since people punched their programs into stacks of cards. We've looked at two review procedures in detail, but there are many subtle variants. Programming teams pick a review mechanism to suit their members and the nature of their work. (Poor teams perform no code review at all.)</p><p>Here are two other common review methods:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Fagan inspections</strong></span></span></dt><dd><p>This is a well-respected process for formal reviews, much as described inthis chapter, defined by Michael Fagan in his <span class="emphasis"><em>Defect Free Process</em></span>. (Fagan 76) Fagan emphasizes the importance of an ability to review and shows how to improve review skills. Fagan inspections identify problems both with the work product and with the process that created it.<a class="indexterm" id="IDX-CHP-20-1593"/></p></dd><dt><span class="term"><span class="strong"><strong>Shadowing</strong></span></span></dt><dd><p>This is a a halfway house between pair programming and code reviews. Eachcode module has a <span class="emphasis"><em>lead developer</em></span> who works on the code. A <span class="emphasis"><em>shadow developer</em></span> is also assigned; periodically the shadow reviews the module with the lead. As design solidifies, the shadow developer verifies the decisions that are made. As the code fills out, the shadow reviews progress and offers constructive advice.<a class="indexterm" id="IDX-CHP-20-1594"/><a class="indexterm" id="IDX-CHP-20-1595"/></p><p>In more formal settings, the shadow is given authority to approve the code for release. No module can be integrated until the shadow developer agrees that it'sready for inclusion in the release build.</p></dd></dl></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>No one's code is above review and peer scrutiny. Actively invite review of your code</em></span>.</p></dd></dl></div><p>As an author, do not be defensive about your code. There is a natural tendency to take all criticism personally and assume that it's an assault on your abilities. To cope with a code review, you need to reduce ego and personal pride. Understand that no one writes perfect code: Even the most awesome programmer's code will be criticized for tedious little problems in a code review.</p><p>This is <span class="emphasis"><em>egoless programming</em></span>, described by Gerald M. Weinberg in his 1971 book <span class="emphasis"><em>The Psychology of Computer Programming</em></span>: a timeless description of the critical attitude that makes reviews work. (Weinberg 71) Programmers who aren't afraid of bugs in their code or of others finding those bugs will generate better, safer, more correct software. A willingness for others to help find faults in your work is an essential attribute of the master programmer.<a class="indexterm" id="IDX-CHP-20-1596"/></p><p>When you're in the hotseat, try not to waste other people's time. Before you present your code for review, run a dummy review by yourself first. Imagine you're presenting your work to the others. You'll be surprised by how many little flaws you'll filter out, and it will help you to be more confident in the real review. Don't rush out half-baked code and expect others to review the flaws away for you.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_reviewers_attitude"/>The Reviewer's Attitude</h2></div></div></div><p>When reviewing code and making criticism, you must be sensitive. Comments must always be constructive and not intended to lay blame. Do not launch personal attacks on the author. Diplomacy and tact are important. Address your comments to the code, rather than the coder; prefer to say <span class="emphasis"><em>The code does this</em></span> . . . rather than <span class="emphasis"><em>You always do this</em></span>. . . .<a class="indexterm" id="IDX-CHP-20-1597"/><a class="indexterm" id="IDX-CHP-20-1598"/><a class="indexterm" id="IDX-CHP-20-1599"/></p><p>Code review is a <span class="emphasis"><em>peer process</em></span>: Every reviewer is considered equal. Seniority doesn't matter, and all views are considered. It is interesting that even the least experienced programmer will have something worth mentioning in a code review. And just as the author learns from the review, so may a reviewer.</p><p>Over time, you will perform many, many reviews (especially if you perform integration reviews). Be careful that your review process doesn't become a mundane chore; it'll soon be an ineffective waste of everyone's time. Maintain a positive approach to your code reviewing. As a reviewer, always try to have something useful to say at each review. Sometimes this is easy; sometimes it is very difficult to say anything interesting. But by forcing yourself to make comments, you won't fall into the easy review rut, becoming a yes man who adds nothing to the process.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The success of a code review depends heavily on the author and reviewers adopting a positive attitude. The aim of a review is to collaboratively improve the code, not to apportion blame or to justify implementation decisions</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="code_perfection"/>Code Perfection</h1></div></div></div><div class="epigraph"><p>When perfection comes, the imperfect disappears.</p><div class="attribution"><span>--<span class="attribution">1 Corinthians 13:10</span></span></div></div><p>We haven't yet considered what type of code will pass review and what code will fail. It's beyond the scope of this chapter to describe what good code looks like—the first 15 chapters of this book describe important aspects of high-quality code. As we look for bad code design and hunt software bugs, there are a few recurring themes. The reviewed code must be:<a class="indexterm" id="IDX-CHP-20-1600"/><a class="indexterm" id="IDX-CHP-20-1601"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Bug free</strong></span></span></dt><dd><p>Bugs are our enemy, the nemesis of good software development. We must be confident about the quality of our work and need to find faults as early as possible in the development process. The earlier we try to find problems, the more we are likely to find and fix and the less cost and hassle they incur (see "<a class="xref" href="ch09s02.html#the_economics_of_failure" title="THE ECONOMICS OF FAILURE">THE ECONOMICS OF FAILURE</a>" on page 157).</p></dd><dt><span class="term"><span class="strong"><strong>Correct</strong></span></span></dt><dd><p>The code must meet all relevant standards and its requirements. Ensure that all variables are of the correct type (e.g., there is no chance of numeric overflow). Comments must be completely accurate. The code must meet any memory size or performance requirements (especially important for embedded platforms). Check that there is appropriate use of libraries and that all function parameters are correct.</p><p>The code is validated to conform with its requirements and functional specifications. The content of its specification is taken to be correct; if it wasn't, then the task would be herculean! Sometimes code review comments might feed up to the specification (for example, where clarification is needed), but this is not our goal at code review—don't get sidetracked into discussions on whether the specification is wrong; the secretary should record the issue in the minutes, and the review should continue.<a class="indexterm" id="IDX-CHP-20-1602"/><a class="indexterm" id="IDX-CHP-20-1603"/></p></dd><dt><span class="term"><span class="strong"><strong>Complete</strong></span></span></dt><dd><p>The code must implement the entire functional specification. It must have been integrated and debugged satisfactorily and pass all test suites. The test suites must be comprehensive.</p></dd><dt><span class="term"><span class="strong"><strong>Well structured</strong></span></span></dt><dd><p>Check that the implementation's design is sound, that the code is easy tounderstand, and that there is no duplication or redundant code. Look for any obvious <span class="emphasis"><em>cut-and-paste programming</em></span>, for example.<a class="indexterm" id="IDX-CHP-20-1604"/></p></dd><dt><span class="term"><span class="strong"><strong>Predictable</strong></span></span></dt><dd><p>There must be no unnecessary complexity and no unexpected surprises. The code should not be self-modifying, must not rely on magic default values, and must not contain the subtle chance of infinite loops or recursion.<a class="indexterm" id="IDX-CHP-20-1605"/><a class="indexterm" id="IDX-CHP-20-1606"/><a class="indexterm" id="IDX-CHP-20-1607"/></p></dd><dt><span class="term"><span class="strong"><strong>Robust</strong></span></span></dt><dd><p>The code is defensive. Wherever possible, it protects against detectable run-time errors (divide by zero, number-out-of-range errors, etc.). All input should be checked (both function parameters and program input). The code handles all error conditions and is exception safe. All appropriate signals are caught.<a class="indexterm" id="IDX-CHP-20-1608"/><a class="indexterm" id="IDX-CHP-20-1609"/></p></dd><dt><span class="term"><span class="strong"><strong>Data checking</strong></span></span></dt><dd><p>Bounds checking is performed on C-style array access. Other similarly insidious data access errors are avoided. Multithreaded code has correct use of mutexes to prevent race conditions and deadlock. The return values of <span class="emphasis"><em>all</em></span> system/library calls are checked.</p></dd><dt><span class="term"><span class="strong"><strong>Maintainable</strong></span></span></dt><dd><p>The programmer has been wise in his or her use of comments. The code is kept under correct revision control. There is appropriate configuration information. The code formatting meets house standard. It compiles quietly, without spurious warnings.<a class="indexterm" id="IDX-CHP-20-1610"/><a class="indexterm" id="IDX-CHP-20-1611"/></p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>If you don't know what good code looks like, then you can't make a valid judgment of other people's work</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="beyond_the_code_review"/>Beyond the Code Review</h1></div></div></div><p>A review process is key to the production of any high-quality item, so it is not solely useful for source code development. A similar review process is used for specification documents, lists of requirements, and so on.<a class="indexterm" id="IDX-CHP-20-1612"/><a class="indexterm" id="IDX-CHP-20-1613"/><a class="indexterm" id="IDX-CHP-20-1614"/><a class="indexterm" id="IDX-CHP-20-1615"/><a class="indexterm" id="IDX-CHP-20-1616"/></p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id19"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>It is easier to be critical than to be correct.</p><div class="attribution"><span>--<span class="attribution">Benjamin Disraeli</span></span></div></div><p>Code reviews are an essential part of the software development process and help us to maintain a high quality of code. Just as an apprentice learns a trade from knowledge passed on, code reviews spread knowledge and teach coding capability. As more of a peer-to-peer than master-apprentice activity, they provide a learning opportunity for author andreviewer alike.</p><p>Write your code to be reviewed. Remember that it's never just for you to read; other people must be able to maintain it as well. The author is always accountable for the quality of his or her work. A good programmer cares more about crafting great code than hisor her own pride.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Desire code reviews and are confident in their code quality</p></li><li class="listitem"><p>Accept others' opinions and learn from them</p></li><li class="listitem"><p>Can sensitively and accurately comment on other people's code</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Are scared of code reviews and frightened of others' opinions</p></li><li class="listitem"><p>Take criticism badly; they are defensive and easily offended</p></li><li class="listitem"><p>Use reviews to demonstrate their superiority over lesser abled coders; their comments are unduly harsh and unconstructive</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id19"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a> through <a class="xref" href="ch15.html" title="Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?">Chapter 15</a></strong></span></span></dt><dd><p>Each of the opening chapters of this book describes important aspects of good code.</p></dd><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>A description of the types of bugs that may exist in your code.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Code is reviewed against its <span class="emphasis"><em>specification</em></span>. The specification also requires careful reviewing.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e28606"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207570.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="checklist"/>Checklist</h1></div></div></div><p>Many review processes involve a <span class="emphasis"><em>checklist</em></span>—a set of characteristics of good (passable) code to check off as you go along. If your code doesn't meet these criteria, then it has failed the review. These checklists vary in detail, length, and subject matter.</p><p>The following code review checklist is an example. You can use it to help direct your review work. Unlike some checklists, it doesn't systematically list every potential problem in every possible language; it just helps to guide the review process and figure out when to continue to the next review step.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e28622"/><img alt="Checklist" src="tagoreillycom20080909nostarchimages207572.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id20"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 547.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id19"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Does the required number of reviewers depend on the size of the code being reviewed?</p></li><li class="listitem"><p>Which tools are useful aids for code reviewing?</p></li><li class="listitem"><p>Should you perform a code review before or after running it through source code checking tools?</p></li><li class="listitem"><p>What preparation is required for a code review meeting?</p></li><li class="listitem"><p>How do you differentiate review comments to be acted upon immediately from those to chalk up for experience on the next project?</p></li><li class="listitem"><p>How do you run a virtual review meeting?</p></li><li class="listitem"><p>How useful are informal code reviews?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id20"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Does your project perform code reviews? Does it perform <span class="emphasis"><em>enough</em></span> code reviews?<a class="indexterm" id="IDX-CHP-20-1617"/></p></li><li class="listitem"><p>Do you work with any programmers whose code is considered to be above review?</p></li><li class="listitem"><p>What percentage of your code has ever been subject to code review?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="how_long_is_a_piece_of_string_question"/>Chapter 21. HOW LONG IS A PIECE OF STRING?</h1></div><div><h3 class="subtitle"><i>The Black Art of Software Timescale Estimation</i></h3></div></div></div><div class="epigraph"><p>I never guess. It is a shocking habit—destructive to the logical faculty.</p><div class="attribution"><span>--<span class="attribution">Sherlock Holmes (Sir Arthur Conan Doyle)</span></span></div></div><p>How long <span class="emphasis"><em>is</em></span> a piece of string? Or for our purposes, how long does a piece of string take? It's as simple a question to answer, and it makes about as much sense.<a class="indexterm" id="IDX-CHP-21-1620"/></p><p>This chapter is about <span class="emphasis"><em>software timescale estimation</em></span>, an important skill of the professional programmer. It's one of the mystical black arts of development, based more on hunches than science, with frequently inaccurate results. It's complicated, but an essential part of the software development process, and is something that every programmer must learn to do.</p><p>The rules of the software factory are necessarily governed by economics: the flow of money. Timing estimates are important, since the bulk of the cost of software development is manpower—programmers aren't cheap. Development environments and hardware costs pale into insignificance. To make a software product, we must know how much work is involved, how many people are required to build it, and when it will be completed and ready to make money. This tells us how much construction will cost. The marketing department will predict how much it will make in sales. These two predictions go head-to-head in a dramatic fight to the death; the bean counters draw up budgets to work out whether a project is financially viable.<a class="indexterm" id="IDX-CHP-21-1621"/><a class="indexterm" id="IDX-CHP-21-1622"/><a class="indexterm" id="IDX-CHP-21-1623"/></p><p>This is an odd thing called <span class="emphasis"><em>planning</em></span>, something at which most programmers don't excel. Don't worry: That's why we have managers. But you have to understand the rules of the game if you really want to play well. Writing commercially successful software requires a huge amount of foresight and planning. Oh, and nerves of steel.<a class="indexterm" id="IDX-CHP-21-1624"/></p><p>To construct a development plan, we perform a high-level design of the software system, break it into components, and estimate how long each component will take to write. There's rarely enough time to seriously scope and design each one, so this is a very rough science. Choosing a software development model (see "<a class="xref" href="ch22s03.html" title="Development Processes">Development Processes</a>" on page 425), we assemble the estimates on a plan, spread across a number of programmers, and use this to work out the economics. The quality of this plan is clearly founded on the quality of the timescale estimates. Catastrophically bad guesses could spell financial ruin, so it's important stuff!</p><p>Without plans, you're creating products by luck, not on purpose. Estimation is an integral part of the project planning process—but that doesn't mean that it's done by the project planners! The only people able to provide timescale information are the programmers who have to do the work. That's you! This is part of the commercial reality of life in the software factory.<a class="indexterm" id="IDX-CHP-21-1625"/></p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="a_stab_in_the_dark"/>A Stab in the Dark</h1></div></div></div><p>In any company, on any project, at any point in time, software timescale estimates are nothing more than educated guesses—or else they wouldn't be estimates. Guesswork doesn't sound very professional, does it? But it's the best you can do: You'll never know exactly how long a task will take until it's complete, when it's generally too late for the information to be useful.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-1" id="CHP-21-FN-1">1</a>]</sup></p><p>The quality of an estimate is primarily determined by how well you understand the task being estimated. That is, how well you <span class="emphasis"><em>really</em></span> understand it, not how well you <span class="emphasis"><em>think</em></span> you do. It also depends on how much time you have to create the estimate, and therefore how much effort you can put into a realistic design effort or feasibility review. With a very precise specification, you can make an estimate in a short time; with a vague specification, it could take ages. A reasonable, justified estimate might require several prototypes to investigate implementation choices—different options could have radically different time consequences and levels of inherent risk.</p><p>Without enough time to do this, you need to concoct a worst-case figure that development should not exceed. The less effort you put into a timescale estimate, the less the confidence you may have in the figure, and the greater the likely variance of reality from the estimate. Development could take half of the estimate, the full period or—even worse—could require more time. We manage this risk by building <span class="emphasis"><em>contingency</em></span> into the development plan to balance risky areas. How much contingency do you provide? You have to guess! We'll look at this later.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Software timescale estimation requires</em></span> educated guesswork. <span class="emphasis"><em>Each estimate should come with a gauge of your confidence in it</em></span>.</p></dd></dl></div><p>While good estimates are reasoned and justified, bad estimates are little more than a stab in the dark. This is a standard engineering issue, requiring a perceptive and flexible management. It has been an engineering issue for centuries.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-2" id="CHP-21-FN-2">2</a>]</sup> Managers and planners deal with estimations for the whole project. That's <span class="emphasis"><em>exceptionally</em></span> hard. We'll just look at estimating single programming jobs. Thankfully, that's not exceptionally hard, just <span class="emphasis"><em>really</em></span> hard.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-1" id="ftn.CHP-21-FN-1">1</a>] </sup>Except, of course, as experience to base future estimates on.<a class="indexterm" id="IDX-CHP-21-1626"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-2" id="ftn.CHP-21-FN-2">2</a>] </sup>For a Biblical example, see Luke 14:28!</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_is_estimation_so_hard_question"/>Why Is Estimation So Hard?</h1></div></div></div><p>I live in Cambridge, UK; my family lives in Bristol. Software timescale estimation is like estimating how long it will take me to visit them. Given a strong tailwind and no traffic, I can tell you how long the drive takes. But if there is road work or a traffic jam, if my car breaks down, I leave late, or I travel at rush hour, then this estimate becomes a lot less reliable. Foreseeing some of these problems, I will commit to a likely arrival window. I know the best-case journey time; I have an idea of the worst case (I've had some nightmare trips). I can judge an expected arrival time somewhere between the two. However, I can't ever fully account for the unforeseen—if my car breaks down, I'm stuck. Mobile phones are helpful in this situation: If I'm going to be late, I can call and let my folks know to keep dinner heated (and preferably out of the dog's bowl).<a class="indexterm" id="IDX-CHP-21-1627"/></p><p>The software development process follows a similar pattern. When planning software, there are foreseeable potential problems to account for, third-party dependencies to manage, and a need for contingency to cope with the unforeseen. You can give a best-case development time for a slice of work, and you need to consider a worst-case time. Of course, the impact of a bad guess isn't just your dinner inside the family pet—it's the success or failure of a project, and possibly the solvency of your company.<a class="indexterm" id="IDX-CHP-21-1628"/></p><div class="sidebar"><a id="the_weakest_link"/><p class="title"><b>THE WEAKEST LINK</b></p><p>Unforeseen problems can trip you up in unexpected places. Recently, my linker couldn't cope with the size of executable image I was generating, and I needed to go off and fix the linker before I could run my code. The development time more than tripled its original estimate.</p></div><p>This begins to show us why estimating the length of a development task is so hard and so crucial. There are plenty of things conspiring to make this a tricky task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are lots of variables to consider. They come with the inherent complexity of the problem, the implications of your code design, and the existing software ecosystem it must fit into. Some of those variables may change from day to day.</p></li><li class="listitem"><p>Requirements will change under your feet, leading to software scope increases. As the feasibility of a project is investigated, new problems and user-level requirements are unearthed at a phenomenal rate. This makes the estimation job tricky—you've got to work hard to keep up with it all (see "<a class="xref" href="ch19s02.html#requirements_specification" title="Requirements Specification">Requirements Specification</a>" on page 371 for strategies to manage this).<a class="indexterm" id="IDX-CHP-21-1629"/></p></li><li class="listitem"><p>You can't give an accurate estimate without knowing <span class="emphasis"><em>all</em></span> the work involved. Perhaps you'll need to rework existing libraries that don't provide enough functionality or refactor to enable safe extension of existing code. If you haven't discovered this, then your estimate will be too low.</p></li><li class="listitem"><p>Few projects start on a blank canvas. You must learn the existing system before you can estimate how long work will take. You seldom have time to do this properly before the estimate is delivered.</p></li><li class="listitem"><p>If the task is something that has not been attempted before, then it is harder to figure how long it will take. You have no prior experience to base the estimate on.</p></li><li class="listitem"><p>Many projects rely on third parties, and these dependencies can prove to be nightmarish. The source of the dependency could be an operating system vendor, a small but significant code library, an external specification, even the customer. You can't control the third-party delivery; your estimates depend on it shipping on time. This increases the risk of delay and must be monitored carefully.<a class="indexterm" id="IDX-CHP-21-1630"/></p></li></ul></div><p>Estimation is hard. But that doesn't absolve us from responsibility. We must account for the things that are genuinely foreseeable: Like road work or bad weather, we can reasonably expect some of these pitfalls. You need to find the right balance of pessimism, optimism, and—somewhere in the middle—realism.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Creating timescale estimates is a genuinely hard task. Don't underestimate how much work is involved. Appreciate the repercussions of making a bad estimate</em></span>.</p></dd></dl></div><p>The story doesn't end there: It's not just making the estimate that's hard. Living with the consequences can be just as painful.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Estimates become contractual, used to set delivery schedules with customers. Once set in concrete, these dates are hard to move and costly to get wrong.</p></li><li class="listitem"><p>It is hard to work to someone else's estimate—were you not up to the task if you miss a deadline, or was the estimate wrong?</p></li><li class="listitem"><p>New tasks are often discovered during development which need accounting for and slotting into the schedule, pushing everything else back. Similarly, you'll only discover specification problems once the development work is actually under way. These specification changes will affect the amount of work required, and therefore the time estimate.</p></li><li class="listitem"><p>There are <span class="emphasis"><em>always</em></span> unforeseen problems. You can absorb the impact of small problems by working a little harder to stay on schedule. You didn't need to sleep this month, did you? But large problems introduce buckets of extra work and cause schedule mayhem.</p></li><li class="listitem"><p>The estimate is just <span class="emphasis"><em>another</em></span> responsibility: You are not only accountable for creating the code, and for it to be good, well-designed, maintainable code; you also have to deliver it to a timescale that you have promised. Pity the poor programmers!</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="under_pressure"/>Under Pressure</h1></div></div></div><p>The software factory is not a reasonable place, and the temptation to give optimistic estimates is strong. Programmers new to the estimation game are particularly vulnerable. There is pressure from above to promise short schedules so that we can win contracts, announce new releases, maintain internal political stability, and so on. This is an understandable, sad reality; no company exists in a vacuum, and the shareholders want to be kept in caviar and champagne.<a class="indexterm" id="IDX-CHP-21-1631"/><a class="indexterm" id="IDX-CHP-21-1632"/><a class="indexterm" id="IDX-CHP-21-1633"/></p><p>But the pressure isn't entirely from above. It also comes from a programmer's personal pride. Techies like to promise an optimistic timescale; we are motivated people who are proud of what we deliver and how fast we can do it. It's tempting to think, "Oh, it shouldn't take too long." But there's a very real difference between a quick code hack or prototype effort and a full, production-ready piece of work. Our timescales must be grounded in reality, not in hopeful ideals.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Everyone (including you) wants shorter development timescales. Don't kid yourself about what is technically possible in the given development time. Don't promise a hack timescale when you must deliver production code</em></span>.</p></dd></dl></div><p>We must be aware of this pressure and react to it carefully. Beware of the danger of an extreme opposite reaction. It is easy to be a pessimistic doom-sayer, to imagine a task lasting indefinitely, and compensating with a stupidly large timescale estimate. The very real danger of an overestimate is that projects inevitably expand to fit the available time! You'll always find bits of code to polish when there are a few days spare.</p><p>In an ideal world, project deadlines are established <span class="emphasis"><em>after</em></span> a feasibility review that proves the project is possible in reasonable time. The Real World is rarely that kind. Instead, you are given a deadline ("Get it shipping by Christmas"), and then have to figure out how to deliver. If the work doesn't fit, you must negotiate how you'll get there: Remove features, add programmers, outsource risky parts, or perhaps provide a later upgrade with more functionality. Sometimes this planning becomes more of a marketing exercise and gets quite creative!<a class="indexterm" id="IDX-CHP-21-1634"/></p><p>No one said that it was supposed to be easy.</p><div class="sidebar"><a id="a_war_story-id5"/><p class="title"><b>A WAR STORY</b></p><p>The company had just taken the biggest and most strategically important order in its five-year history. This one was <span class="emphasis"><em>make or break</em></span>. Sales fought hard to close the deal, agreeing to a hard customer deadline: The software <span class="emphasis"><em>must</em></span> ship by the end of the year. With contracts signed, everyone patted themselves on the back.</p><p>But no one had the time (or wit) to confer with the technical staff to ensure that the project was feasible. It wasn't. Managers started panicking, but with an immobile deadline and fixed feature set, there wasn't much they could do. The engineers complained and waved their project plans aloft, but were told to "just make it fit." They worked hard day after day, late into the night, and were soon exhausted. Each week saw them slip further away from the hopelessly optimistic schedule.</p><p>In one last herculean effort, they completed the code by their deadline, only to be tripped up by an unforeseen hardware problem that delayed the project by two months. There was no contingency in the plan to account for this disaster.</p><p>The project was a failure, the engineers got burned out, nerves were fraught, and the customer was unhappy. Not long into the next project, most of the development team quit.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="practical_ways_to_estimate"/>Practical Ways to Estimate</h1></div></div></div><p>With the increasing pressure to be prophets as much as programmers, how do we meet expectations? Estimation, like many other skills, is something you get better at it with experience. It's not an old man's game, but if you don't work against a backdrop of schedules and set yourself targets to work toward, then you won't grow in the skill. Practice makes perfect.<a class="indexterm" id="IDX-CHP-21-1635"/><a class="indexterm" id="IDX-CHP-21-1636"/><a class="indexterm" id="IDX-CHP-21-1637"/><a class="indexterm" id="IDX-CHP-21-1638"/><a class="indexterm" id="IDX-CHP-21-1639"/><a class="indexterm" id="IDX-CHP-21-1640"/><a class="indexterm" id="IDX-CHP-21-1641"/><a class="indexterm" id="IDX-CHP-21-1642"/><a class="indexterm" id="IDX-CHP-21-1643"/><a class="indexterm" id="IDX-CHP-21-1644"/><a class="indexterm" id="IDX-CHP-21-1645"/><a class="indexterm" id="IDX-CHP-21-1646"/><a class="indexterm" id="IDX-CHP-21-1647"/><a class="indexterm" id="IDX-CHP-21-1648"/><a class="indexterm" id="IDX-CHP-21-1649"/></p><p>In the Real World, we rarely have the luxury of practice projects or a sandbox to experiment with timescale estimation. Somewhere along the road from junior programmer to guru, you have to pick up this skill! Sadly there is no magic formula or easy recipe for coming up with an estimate. But following these simple steps will immeasurably improve your accuracy:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Break the task down into the smallest blocks possible, effectively performing a first pass of system design.</p></li><li class="listitem"><p>When you reach a fine resolution with suitably comprehensible parts, provide a timescale estimate for each block in <span class="emphasis"><em>man-hours</em></span> or <span class="emphasis"><em>man-days</em></span>.</p></li><li class="listitem"><p>Once you've estimated all of the individual timescales, place them back-to-back, add up their durations, and voilà: an instant timescale estimate.</p></li></ol></div><p>This strategy works because you can fully comprehend and accurately estimate a series of smaller activities more easily than one gargantuan task. Estimates should <span class="emphasis"><em>never</em></span> be made in units larger than man-days: Such large tasks show that you don't really understand the problem yet; your estimate cannot be at all reliable. Mercilessly decompose large tasks until you end up with fine-grained—estimatable—work units.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Time estimates should be made for small tasks whose individual scope is easy to understand. The measurement should be in units of</em></span> man-hours <span class="emphasis"><em>or</em></span> man-days.<a class="indexterm" id="IDX-CHP-21-1650"/></p></dd></dl></div><p>Of course, development work can often be parallelized between people; by breaking it into small comprehensible parts, we can juggle tasks around and work out how to run them concurrently, bringing forward the completion date. This becomes a project planning issue.</p><p>Set aside a reasonable amount of time to make an estimate. The requisite high-level design is not immediate; don't presume that timescales can be guessed easily. You'll fool yourself by producing a finger-in-the-air estimate with no foundation on prior experience and no basis in a system design.</p><p>It is vital to consider <span class="emphasis"><em>every</em></span> activity that will be required to deliver the software. This means including time for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Performing adequate thoughtful design</p></li><li class="listitem"><p>Any exploratory work or prototyping required</p></li><li class="listitem"><p>The actual code implementation work</p></li><li class="listitem"><p>Debugging</p></li><li class="listitem"><p>Writing unit tests</p></li><li class="listitem"><p>Integration testing</p></li><li class="listitem"><p>Writing the documentation</p></li><li class="listitem"><p>Any research or training you'll be undertaking in the period</p></li></ul></div><p>This list shows that less time than you might expect is spent writing code, compared to other peripheral activities. Programming isn't just about cutting code; don't forget to include testing and documentation in your timescale estimates. They are essential. Without testing and documentation, you'll deliver code that doesn't work properly and can't be fixed later because no one knows how to use it.</p><p>Don't try to calculate <span class="emphasis"><em>elapsed time</em></span> (by incorporating distractions from other projects, reading email, browsing the web, drinking coffee, and answering the call of nature). It will inevitably be very different from the actual time spent on the task. The task may run concurrently with another, or be interrupted to provide space for another project. We deal with this on a project plan (described in "<a class="xref" href="ch21s05.html" title="The Planning Game">The Planning Game</a>" on page 409).</p><p>How conservative should your estimate be? Should you veer toward optimism or pessimism? The correct answer is: The estimate must be realistic. Anticipate likely problems and factor them in, but don't invent 1,000 ways a simple task could fail and use it as an excuse to give an inflated estimate. Don't overestimate just to cover your tracks, or to give yourself more slack to fill with games of solitaire. Our individual task estimates can't mitigate for everything that can go wrong. Risk should be managed at the <span class="emphasis"><em>project level</em></span>; the scheduler takes our estimates and works them into a reasonable plan with suitable contingency.</p><p>To make more accurate estimates, consider these important issues:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The more concrete and specified a project is, the easier it is to estimate. Have you been given a good spec?</p><p>Without a specification, there is no traceability, and a lot of the work involved in each package will be assumed. Two people could assume very different things about the project scope and expect different things at the project deadline. Rigorous specifications avoid this problem.</p><p>Delivering the wrong system on time can be just as damaging as delivering the right one, late. If there is no specification, write one and get it approved by the task stakeholders.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-3" id="CHP-21-FN-3">3</a>]</sup> At the very least, document all assumptions that you have made about the work.<a class="indexterm" id="IDX-CHP-21-1651"/></p></li><li class="listitem"><p>The more functionality requested, the harder the estimate is to make. Try to shave off all unnecessary work. An excellent approach is to stage the delivery of the software, giving estimates for each deliverable iteration.</p><p>Feed estimate information back upstream. The project decision-makers can then balance the importance of each requirement against its technical difficulty. It helps to see which small feature requests will double development time.</p></li><li class="listitem"><p>If you don't fully comprehend the entire problem, then you'll make a very bad estimate. Spend time getting to know exactly what the software must do. If you need more time to make an estimate, then ask for it, or indicate your confidence in the time values. Never guess an estimate and hope that it's about right—if you can't justify an estimate, then don't give it.</p></li><li class="listitem"><p>If the task depends on third-party input, then it is harder to estimate. Who is responsible for chasing the third party for delivery? You may need to factor this into your development estimate. Get the third party's estimated delivery date, and then add time to integrate its work with your codebase (it never "just slots in"). Consider how much you trust the third party, and include a suitable amount of contingency as a buffer to accommodate problems.<a class="indexterm" id="IDX-CHP-21-1652"/></p></li><li class="listitem"><p>Different people will work on the same task at different rates. This is natural; everyone has a different set of skills, level of experience, confidence level, and relative number of distractions (e.g., older projects vying for attention or home commitments). You need to gauge how fast you work, and have a good understanding of the task you're embarking on. Estimation is personal.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Understand whether you're creating an estimate for work that</em></span> you <span class="emphasis"><em>will do (on a system you understand well) or that someone else will do (who might have to learn it first)</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Don't accept pressure from above to be optimistic. Don't promise unrealistic timescales, thinking you can make it up if you work overtime. Have an appropriate response to managers who say, "It just has to be done faster."<a class="indexterm" id="IDX-CHP-21-1653"/></p></li><li class="listitem"><p>Perhaps most importantly, <span class="emphasis"><em>never</em></span> plan up front on working overtime.</p></li></ul></div><p>A simple way to improve your estimates is to ask for help with them. If you don't understand a problem, then find someone who does, and ask for his or her opinion. James Surowiecki's book <span class="emphasis"><em>The Wisdom of Crowds</em></span> describes how large groups of people can be smarter than an elite few. Taking this extreme approach, get all the developers in your team to give rough estimates for all tasks on the plan, and then take the average of their individual estimates. That estimate might not be too far off!</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't make estimates in isolation. Solicit other people's opinions to help improve your estimates</em></span>.</p></dd></dl></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-3" id="ftn.CHP-21-FN-3">3</a>] </sup>Of course, that will take time you didn't plan for!</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_planning_game"/>The Planning Game</h1></div></div></div><p>A few disconnected timescale estimates are no use to anyone. You have to join them up and convert them into something useful: a project plan with which you can manage the development schedule. Based on their individual timescale estimates, tasks are assembled on a timeline and allotted to developers. Dependencies between tasks are identified and factored in to the plan (obviously, dependent tasks cannot start before their dependencies have completed). The final result is a pictorial chart with time running along the horizontal axis and tasks positioned concurrently on it, looking something like <a class="xref" href="ch21s05.html#a_gantt_chart" title="Figure 21-1. A Gantt chart">Figure 21-1</a> (a variant of the classic <span class="emphasis"><em>Gantt chart</em></span>).<a class="indexterm" id="IDX-CHP-21-1659"/><a class="indexterm" id="IDX-CHP-21-1660"/><a class="indexterm" id="IDX-CHP-21-1654"/><a class="indexterm" id="IDX-CHP-21-1655"/><a class="indexterm" id="IDX-CHP-21-1656"/><a class="indexterm" id="IDX-CHP-21-1657"/><a class="indexterm" id="IDX-CHP-21-1658"/></p><div class="figure"><a id="a_gantt_chart"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e29214"/><img alt="A Gantt chart" src="tagoreillycom20080909nostarchimages207574.png"/></div></div><p class="title"><b>Figure 21-1. A Gantt chart</b></p></div><br class="figure-break"/><p>Project planning is about allocating tasks to developers and working out how to schedule development effort. But that's the easy half of the game. The important part is <span class="emphasis"><em>risk management</em></span>—creating a safe and sensible plan in the face of uncertainty and hidden traps.<a class="indexterm" id="IDX-CHP-21-1661"/><a class="indexterm" id="IDX-CHP-21-1662"/><a class="indexterm" id="IDX-CHP-21-1663"/></p><p>The safest project plans:<a class="indexterm" id="IDX-CHP-21-1664"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Reduce the</strong></span> <em class="replaceable"><code>critical path</code></em></span></dt><dd><p>This is the single line of back-to-back tasks that trace from the start to the end of the project, shown by the darker blocks in the diagram above. A slip in any one of these tasks will force back all the tasks depending on it and push out the final deadline.<a class="indexterm" id="IDX-CHP-21-1665"/></p><p>There is always—by definition—a critical path on the plan. This is what gives project planners grey hair! We aim for the optimum juxtaposition of tasks to provide the smallest (or least risky) critical path.</p></dd><dt><span class="term"><span class="strong"><strong>Are not massively parallel</strong></span></span></dt><dd><p>The standard planning misconception when trying to compress a large project is that throwing more developers at a problem will speed it up. This rarely works. An extra burden is imposed when managing more people—there are more lines of communication, more people to coordinate, and more points of failure. This is the subject of Brooks's seminal essay, "The Mythical Man-Month." (Brooks 95)</p><p>You mustn't over-parallelize a project plan, and you shouldn't parallelize individual developers, either. If you put one developer against two tasks concurrently, you can't expect them to finish in the same length of time as those two tasks serialized. This sounds obvious, but it often happens in practice: You might be asked to support an old project and simultaneously start development work on another. Significant time is taken up switching between tasks, which reduces your overall efficiency. If you did the two tasks back to back, then you'd complete faster (but probably fail to meet the business requirements of your organization).</p></dd><dt><span class="term"><span class="strong"><strong>Are not too long</strong></span></span></dt><dd><p>A lengthy project plan is too ambitious. One small problem on the critical path at any point could jeopardize the entire project.</p><p>This is where iterative and incremental development (see "<a class="xref" href="ch22s03.html#iterative_and_incremental_development" title="Iterative and Incremental Development">Iterative and Incremental Development</a>" on page 432) brings benefits, by breaking large development schedules into smaller, less risky iterations that can be more easily managed. This makes the plan more dynamic; it is effectively re-created at each delivery point. Although this approach is inherently safer and will highlight problems earlier in the development process, it consequently involves more work overall. Many managers don't like this—they like the illusion of an up-front waterfall plan that cannot be deviated from.<a class="indexterm" id="IDX-CHP-21-1666"/></p></dd></dl></div><p>Good plans don't just butt timescale estimates back to back. They account for the reality of the software factory and build in important risk-reducing structures. This includes accounting for:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Vacation</strong></span></span></dt><dd><p>The amount of vacation allocated to each developer is known in advance and must be built in to the schedule. We must also include public holidays and any company shutdown over a Christmas break. On average, a developer takes half a day a week as vacation.</p></dd><dt><span class="term"><span class="strong"><strong>Loading</strong></span></span></dt><dd><p>To be realistic, the plan must factor in normal interruptions (meetings, training, sickness, and so on). It's normal to employ an 80 percent loading on the plan for each developer to accommodate this. People who are in more demand are spread more thinly. You must be honest about this, or the "popular" developers will slip against the schedule, despite their hard work, and will quickly become frustrated.</p></dd><dt><span class="term"><span class="strong"><strong>Contingency</strong></span></span></dt><dd><p>This is the biggie. You have to account for the problems seen looming on the horizon and provide space for the unforeseen disasters that might stand between you and your release date. This is where the risk management rubber hits the road.</p><p>Risk is best managed at this project level, rather than within individual timescale estimates. On a development plan, we can accommodate potential problems by making informed judgments in full sight of the whole development process. The alternative, a series of pessimistic estimates placed on a plan, will inevitably be wildly out.</p><p>The million dollar question is: How much contingency should you add in? You can't simply multiply the plan by three and call it contingency! A good strategy is to give each task a confidence value. Based on this, provide an extra pseudo-task on the plan for the riskiest tasks as "danger time." Make this a fraction of the original task length, based on your confidence value.<a class="indexterm" id="IDX-CHP-21-1667"/></p></dd><dt><span class="term"><span class="strong"><strong>Integration</strong></span></span></dt><dd><p>A task is not done once a component is code complete and unit tested. Reserve adequate time to glue all of the components together, and to test that the entire system works as expected. There will be debugging required and issues that only surface when components meet (performance issues or interface mismatches, for example).</p></dd><dt><span class="term"><span class="strong"><strong>Support</strong></span></span></dt><dd><p>The longer people have been within an organization, the more call there will be on them to support old projects, answer bug reports from the field, and so on. Ensure that this is incorporated into their loading, and that they then stick to the plan, highlighting when other projects are demanding more of their time.</p><p>Projects slip subtly when key people are stretched in all directions.</p></dd><dt><span class="term"><span class="strong"><strong>Mopping up</strong></span></span></dt><dd><p>Provide time to tidy up at the end of your plan. In the battle to release software, corners are cut to meet the deadline. This is known as amassing <span class="emphasis"><em>technical debt</em></span>. Despite our preaching about good design and coding practices, this isn't necessarily evil; it's quite pragmatic. However, you must set aside time to tidy up and maintain a good, clean codebase. Otherwise, the next development iteration will build upon a broken, crufty codebase. Left unaddressed, this increasing pile of short-term hacks will become a burden to your programmers.<a class="indexterm" id="IDX-CHP-21-1668"/></p><p>Think of this exercise as part of the <span class="emphasis"><em>previous</em></span> job (despite occurring after the release deadline), and not as the beginning of the next one. Pay off your debt in the project that accrued it.</p><p>Never let these tidy-ups been viewed as optional extras; they are an important integral part of the project. In the frantic world of the software factory, optional tasks placed at the end of the schedule simply will not happen. Guard these tasks carefuly.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Create development schedules that will leave your codebase in a clean state. Plan to repay your technical debt</em></span>.</p></dd></dl></div><p>An in-depth investigation of project planning is outside the scope of this book; it's a large, complex task. But it is important to understand the basic principles. You must be able to develop software according to a plan, and must understand the rationale behind a plan to truly understand what you're asked to do.</p><p>The are many planning models: formal methods of making educated guesses. <span class="emphasis"><em>Program Evaluation and Review Technique (PERT)</em></span> is a classic planning method developed in the 1950s by the US Navy. It's like my arrival window calculation when driving to Bristol. For each task, you estimate three times corresponding to different likelihoods of meeting delivery dates: a best case, worst case, and likely case. This ties into a scheduling procedure that identifies the critical path and calculates the best- and worst-case project completion time. The bigger the gap between each task's estimate, the bigger the risk associated with the task. Perhaps it will need more careful management or to be given to a more experienced member of the staff.</p><p>Boehm's <span class="emphasis"><em>Constructive Cost Model (COCOMO)</em></span> dates from 1981 and is an estimation model based on analysis of real software projects. It has evolved into <span class="emphasis"><em>COCOMO II</em></span>, which more accurately reflects the nature of modern software projects. (Boehm 81) <span class="emphasis"><em>Projects in Controlled Environments</em></span> (known by the rather contrived acronym <span class="emphasis"><em>PRINCE</em></span>) is a classic British piece of bureaucracy embodied in project management form; if it could mandate standing in queues, it would!<sup>[<a class="footnote" href="#ftn.CHP-21-FN-4" id="CHP-21-FN-4">4</a>]</sup> Its scope is the entire project life cycle, from start to closure. The PRINCE planning process comprises seven steps, covering designing the plan, through estimation and scheduling, to plan completion. It too has evolved, into a method imaginatively called <span class="emphasis"><em>PRINCE2</em></span>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-4" id="ftn.CHP-21-FN-4">4</a>] </sup>Queueing is a popular British pastime, like drinking tea and playing cricket.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="keep_up"/>Keep Up!</h1></div></div></div><div class="epigraph"><p>How does a project get to be a year late? . . . One day at a time.<a class="indexterm" id="IDX-CHP-21-1669"/><a class="indexterm" id="IDX-CHP-21-1670"/><a class="indexterm" id="IDX-CHP-21-1671"/><a class="indexterm" id="IDX-CHP-21-1672"/><a class="indexterm" id="IDX-CHP-21-1673"/><a class="indexterm" id="IDX-CHP-21-1674"/><a class="indexterm" id="IDX-CHP-21-1675"/><a class="indexterm" id="IDX-CHP-21-1676"/><a class="indexterm" id="IDX-CHP-21-1677"/><a class="indexterm" id="IDX-CHP-21-1678"/><a class="indexterm" id="IDX-CHP-21-1679"/><a class="indexterm" id="IDX-CHP-21-1680"/><a class="indexterm" id="IDX-CHP-21-1681"/><a class="indexterm" id="IDX-CHP-21-1682"/><a class="indexterm" id="IDX-CHP-21-1683"/><a class="indexterm" id="IDX-CHP-21-1684"/><a class="indexterm" id="IDX-CHP-21-1685"/><a class="indexterm" id="IDX-CHP-21-1686"/><a class="indexterm" id="IDX-CHP-21-1687"/></p><div class="attribution"><span>--<span class="attribution">Frederick P. Brooks Jr.</span></span></div></div><p>As work slips and the project deadline looms, engineers work very hard and get little credit. The idea of rigorous testing is squeezed out in a mad rush to get something passable out the door on time. Bad estimates are a prime cause of this software circus. They foster managers' incorrect assumptions about the difficulty of the development work, since they have no way to know the schedule was incorrect in the first place. When we make an estimate, it is therefore essential to get it right.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-5" id="CHP-21-FN-5">5</a>]</sup></p><div class="sidebar"><a id="it_apostrophy_s_all_about_planning"/><p class="title"><b>IT'S ALL ABOUT PLANNING</b></p><p>The development team was getting quite large, and our working space had become really cramped. After a lot of effort, a new office was found and the team was told on Friday that we'd be working in the new location on Monday. Over the weekend, all the computers, servers, cables, routers, printers—everything—would be manhandled into vans and transported to the new location. We were assured that it would be seamless and that everything would be ready on Monday morning.</p><p>On Monday morning, we turned up at the new office and, sure enough, everything had been set up and worked perfectly! All the IT infrastructure had been installed. The servers were back online and fully operational. Everyone's workspace had been set up. A truly herculean effort.</p><p>But there was one small problem: There were no chairs. Not one. They had somehow been forgotten in the move plan, had gotten lost, and couldn't be found anywhere! We had no chairs for three days.</p><p>Now that's what you call planning.</p></div><p>Given a realistic estimate for a software task, there are a few key ways to keep to schedule and prevent this kind of last-minute squeeze:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When starting a new task, check whether or not the allotted timescale really <span class="emphasis"><em>is</em></span> practical—especially if you didn't have the luxury of making the estimate yourself. Even if you did make the estimate, start by verifying it. Don't rush headlong into a code editor, <span class="emphasis"><em>hoping</em></span> that you can complete on time; be sure that you are genuinely able to deliver. A little sanity checking up front can save you from a world of pain and embarrassment later.</p></li><li class="listitem"><p>Refer to the schedule—it matters. Keep a constant eye on how long you're taking against scheduled time. Write down your timescales and keep them close at hand. Add personal estimates for any intermediate tasks that don't figure on the main software plan, and run yourself as a mini-project. If you hit your internal milestones, you'll have more chance of keeping on track with your externally visible timescales. Repeatedly review your list—at least once a day.</p><p>If you discover that you won't hit the deadline, make this known as soon as possible so the plan can be adjusted. Like phoning ahead when I'm traveling to Bristol, it is better to get this fact out in the open as soon as possible. If the possibility of overrun is foreseen, then different scheduling decisions can be made to minimize the impact of the overrun.</p><p>This happens far too rarely in practice. If an important project has five programmers who must all report their progress, then none of them wants to be the first one to admit falling behind the schedule. This is known as playing <span class="emphasis"><em>schedule chicken</em></span>. The result is everything seems to be fine, but then suddenly the project is hugely late. It was getting late one day at a time, but no wanted to admit it. Break this cycle and broadcast a warning as early as possible.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Continually monitor your progress against the plan. Then you will never be surprised that your task has slipped</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Do as much work as necessary, and no more. It might be fun to add that cute extra feature. But don't. There are more important—planned—things to be done. Ask for important extras to be scheduled in later if they aren't <span class="emphasis"><em>really</em></span> needed now. An ill-chosen detour on my route to Bristol will really set back my arrival time—even if it is a lovely scenic drive—so I take the sensible straight route to arrive on time.</p></li><li class="listitem"><p>Careful design exploiting modularity tends to reduce component dependency, and so reduces the ill effects of slippage and the bunching up of tasks on the schedule. Agree on component interfaces early on, and provide stub components so development can continue while others parts of the system are being built.<a class="indexterm" id="IDX-CHP-21-1688"/></p></li><li class="listitem"><p>Write good code, with a thorough set of unit tests. As keen craftsmen, this should be self-evident! It helps to reduce debug and maintenance time radically.<a class="indexterm" id="IDX-CHP-21-1689"/></p><p>Don't forget to finish coding with time to document and test thoroughly. Don't build up to a final coding sprint in the last few days of the schedule. You need time to prove that your code works. Otherwise, you'll slip as debugging inches out beyond your deadline. If you don't have time to complete all this work, say so and get the timescale extended. Don't skip these things—they'll bite you later.</p></li><li class="listitem"><p>Watch out for changing requirements and specifications and track how this will affect your timescales. If it's an adverse change, report it immediately. Don't silently absorb functionality changes.<a class="indexterm" id="IDX-CHP-21-1690"/></p></li><li class="listitem"><p>Be strict with distractions. Don't work on other tasks unless they are accounted for on a plan. Learn to say <span class="emphasis"><em>no</em></span> to old projects, extra work from other departments, and intrusions from the phone and email.</p><p>Guard against these external distractions, even the short ones that seem harmless; they can really lower the quality of your work. It takes time to <span class="emphasis"><em>get into the zone</em></span>, that productive place where your mind is on the task and the code is flowing freely from your fingertips (psychologists call this state <span class="emphasis"><em>flow</em></span>). Even short distractions interrupt this effectiveness, and when you return to work, you must spend more time getting back into the zone. The impact of interruptions can be more than three times their duration. (DeMarco 99)<a class="indexterm" id="IDX-CHP-21-1691"/><a class="indexterm" id="IDX-CHP-21-1692"/></p><p>Foster a development culture that's conducive to getting work done. Respect each other's brain-space: a person's time to think and work. Make sure that every meeting really is necessary—don't pull developers into random, time-wasting get-togethers.</p></li><li class="listitem"><p>Maintain a positive and optimistic approach. Believing a project is doomed is a surefire way to make that happen in reality.</p></li></ul></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-5" id="ftn.CHP-21-FN-5">5</a>] </sup>5Ironically, good estimates can also cause this problem. DeMarco and Lister recount a genuine episode where a project lead reported their 100 percent confidence that the project would complete on time and to budget. (DeMarco 99) The managers, taken aback by this unexpected piece of good news, consequently decided to bring the deadline forward! No matter how good the engineer, you can always build a better manager to destroy his or her hard work!</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id20"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Good luck is a lazy man's estimate of a worker's success.<a class="indexterm" id="IDX-CHP-21-1693"/></p><div class="attribution"><span>--<span class="attribution">Anonymous</span></span></div></div><p>Timescale estimation and planning help us to develop commercially successful software. However, there is no rigorous method to accurately determine software timescale values. That's why it's <span class="emphasis"><em>estimation</em></span>.</p><p>Aim to develop your estimation techniques, and become wary of potential problems that can ruin your neatly scheduled development plan. Learn how to work to a schedule and to identify when your schedules are impractical.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create good timescale estimates by considering all parts of the development process, based on a sound component breakdown</p></li><li class="listitem"><p>Try to produce tested code with full documentation, properly integrated within the timescales</p></li><li class="listitem"><p>Highlight timescale problems early on so that they can be dealt with</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Produce hopeful estimates, based solely on hunches and gut feelings</p></li><li class="listitem"><p>Can hack out some code within their timescale estimates but will not produce production quality, bug-free code</p></li><li class="listitem"><p>Think that admitting a timescale problem is a sign of weakness, and work themselves silly trying to catch up—when they fail, they look silly (and tired)</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id20"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Good timescale estimates can only be based on a sound initial code design.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Making an estimate requires a well-defined scope of work, which must be captured unambiguously in a <span class="emphasis"><em>specification</em></span>.</p></dd><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>Development methodologies determine how tasks are slotted together and placed on a project plan.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e29651"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207576.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id21"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 550.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id20"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How can you rescue a slipping project and bring it back on track?</p></li><li class="listitem"><p>What's the correct response to having a deadline imposed on you before feasibility or planning work commences?</p></li><li class="listitem"><p>How do you ensure that a development plan is genuinely useful?</p></li><li class="listitem"><p>Why do different programmers work at different rates? How can you reflect this on the plan?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id21"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What percentage of the projects that you've worked on have run to schedule?<a class="indexterm" id="IDX-CHP-21-1694"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>For those that did: What contributed to the success of the planning effort?</p></li><li class="listitem"><p>For those that failed: What were the main problems?</p></li></ol></div></li><li class="listitem"><p>How accurate are your timescale estimates? How far off target are you normally?</p></li></ol></div></div></div></body></html>