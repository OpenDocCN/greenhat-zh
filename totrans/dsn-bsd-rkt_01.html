<html><head></head><body><div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="loadable_kernel_modules"/>Chapter 1. LOADABLE KERNEL MODULES</h1></div></div></div><p>The simplest way to introduce code into a running kernel is through a <span class="emphasis"><em>loadable kernel module (LKM)</em></span>, which is a kernel subsystem that can be loaded and unloaded after bootup, allowing a system administrator to dynamically add and remove functionality from a live system. This makes LKMs an ideal platform for kernel-mode rootkits. In fact, the vast majority of modern rootkits are simply LKMs.<a id="IDX-CHP-1-0003" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In FreeBSD 3.0, substantial changes were made to the kernel module subsystem, and the LKM Facility was renamed the Dynamic Kernel Linker (KLD) Facility. Subsequently, the term KLD is commonly used to describe LKMs under FreeBSD.<a id="IDX-CHP-1-0004" class="indexterm"/></p></div><p>In this chapter we'll discuss LKM (that is, KLD) programming within FreeBSD for programmers new to kernel hacking.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Throughout this book, the terms <span class="emphasis"><em>device driver</em></span>, <span class="emphasis"><em>KLD</em></span>, <span class="emphasis"><em>LKM</em></span>, <span class="emphasis"><em>loadable module</em></span>, and <span class="emphasis"><em>module</em></span> are all used interchangeably.</p></div><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="module_event_handler"/>Module Event Handler</h1></div></div></div><p>Whenever a KLD is loaded into or unloaded from the kernel, a function known as the <span class="emphasis"><em>module event handler</em></span> is called. This function handles the initialization and shutdown routines for the KLD. Every KLD must include an event handler.<sup>[<a id="CHP-1-FN-1" href="#ftn.CHP-1-FN-1" class="footnote">1</a>]</sup> The prototype for the event handler function is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:<a id="IDX-CHP-1-0006" class="indexterm"/><a id="IDX-CHP-1-0007" class="indexterm"/><a id="IDX-CHP-1-0005" class="indexterm"/></p><a id="I_programlisting1_d1e302"/><pre class="programlisting">
typedef int (*modeventhand_t)(module_t, int /* modeventtype_t */, void *);
</pre><p>where <code class="literal">module_t</code> is a pointer to a <code class="literal">module</code> structure and <code class="literal">modeventtype_t</code> is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e318"/><pre class="programlisting">
typedef enum modeventtype {
        MOD_LOAD,       /* Set when module is loaded. */
        MOD_UNLOAD,     /* Set when module is unloaded. */
        MOD_SHUTDOWN,   /* Set on shutdown. */
        MOD_QUIESCE     /* Set on quiesce. */
} modeventtype_t;
</pre><p>Here is an example of an event handler function:</p><a id="I_programlisting1_d1e322"/><pre class="programlisting">
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("Hello, world!\n");
                break;

        case MOD_UNLOAD:
                uprintf("Good-bye, cruel world!\n");
                break;

        default:
                error = EOPNOTSUPP;
                break;

        }

        return(error);
}
</pre><p>This function will print "Hello, world!" when the module loads, "Good-bye, cruel world!" when it unloads, and will return with an error (<code class="literal">EOPNOTSUPP</code>)<sup>[<a id="CHP-1-FN-2" href="#ftn.CHP-1-FN-2" class="footnote">2</a>]</sup> on shutdown and quiesce.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-1" href="#CHP-1-FN-1" class="para">1</a>] </sup><sup>1</sup> Actually, this isn't entirely true. You can have a KLD that just includes a <code class="literal">sysctl</code>. You can also dis-pense with module handlers if you wish and just use <code class="literal">SYSINIT</code> and <code class="literal">SYSUNINIT</code> directly to register func-tions to be invoked on load and unload, respectively. You can't, however, indicate failure in those.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-2" href="#CHP-1-FN-2" class="para">2</a>] </sup><sup>2</sup> <code class="literal">EOPNOTSUPP</code> stands for <span class="emphasis"><em>Error: Operation not supported</em></span></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_declare_module_macro"/>The DECLARE_MODULE Macro</h1></div></div></div><p>When a KLD is loaded (by the <code class="literal">kldload(8)</code> command, described in <a class="xref" href="ch01s03.html" title="&quot;Hello, world!&quot;">"Hello, world!"</a>), it must link and register itself with the kernel. This can be easily accomplished by calling the <code class="literal">DECLARE_MODULE</code> macro, which is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:<a id="IDX-CHP-1-0015" class="indexterm"/><a id="IDX-CHP-1-0008" class="indexterm"/><a id="IDX-CHP-1-0009" class="indexterm"/><a id="IDX-CHP-1-0010" class="indexterm"/><a id="IDX-CHP-1-0011" class="indexterm"/><a id="IDX-CHP-1-0012" class="indexterm"/><a id="IDX-CHP-1-0013" class="indexterm"/><a id="IDX-CHP-1-0014" class="indexterm"/></p><a id="I_programlisting1_d1e411"/><pre class="programlisting">
#define DECLARE_MODULE(name, data, sub, order)                          \
        MODULE_METADATA(_md_##name, MDT_MODULE, &amp;data, #name);          \
        SYSINIT(name##module, sub, order, module_register_init, &amp;data)  \
        struct __hack
</pre><p>Here is a brief description of each parameter :</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>name</code></strong></span></dt><dd><p>This specifies the generic module name, which is passed as a character string.</p></dd><dt><span class="term"><strong class="userinput"><code>data</code></strong></span></dt><dd><p>This parameter specifies the official module name and event handler function, which is passed as a <code class="literal">moduledata</code> structure. <code class="literal">struct moduledata</code> is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e439"/><pre class="programlisting">
typedef struct moduledata {
        const char      *name;          /* module name */
        modeventhand_t  evhand;         /* event handler */
        void            *priv;          /* extra data */
} moduledata_t;
</pre></dd><dt><span class="term"><strong class="userinput"><code>sub</code></strong></span></dt><dd><p>This specifies the system startup interface, which identifies the module type. Valid entries for this parameter can be found in the <code class="literal">&lt;sys/kernel.h&gt;</code> header within the <code class="literal">sysinit_sub_id</code> enumeration list.</p><p>For our purposes, we'll always set this parameter to <code class="literal">SI_SUB_DRIVERS</code>, which is used when registering a device driver.</p></dd><dt><span class="term"><strong class="userinput"><code>order</code></strong></span></dt><dd><p>This specifies the KLD's order of initialization within the subsystem. You'll find valid entries for this parameter in the <code class="literal">&lt;sys/kernel.h&gt;</code> header within the <code class="literal">sysinit_elem_order</code> enumeration list.</p><p>For our purposes, we'll always set this parameter to <code class="literal">SI_ORDER_MIDDLE</code>, which will initialize the KLD somewhere in the middle.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="quotation_mark_hello_comma_world_exclamation_quotation_mark"/>"Hello, world!"</h1></div></div></div><p>You now know enough to write your first KLD. Listing 1-1 is a complete "Hello, world!" module.<a id="IDX-CHP-1-0016" class="indexterm"/><a id="IDX-CHP-1-0017" class="indexterm"/><a id="IDX-CHP-1-0018" class="indexterm"/><a id="IDX-CHP-1-0019" class="indexterm"/><a id="IDX-CHP-1-0020" class="indexterm"/><a id="IDX-CHP-1-0021" class="indexterm"/><a id="IDX-CHP-1-0022" class="indexterm"/><a id="IDX-CHP-1-0023" class="indexterm"/></p><a id="I_programlisting1_d1e518"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("Hello, world!\n");
                break;

        case MOD_UNLOAD:
                uprintf("Good-bye, cruel world!\n");
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);

}

/* The second argument of DECLARE_MODULE. */
static moduledata_t hello_mod = {
        "hello",        /* module name */
        load,           /* event handler */
        NULL            /* extra data */

};

DECLARE_MODULE(hello, hello_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);
</pre><p><span class="emphasis"><em>Listing 1-1: hello.c</em></span></p><p>As you can see, this module is simply a combination of the sample event handler function from <a class="xref" href="ch01.html#module_event_handler" title="Module Event Handler">Module Event Handler</a> and a filled-out <code class="literal">DECLARE_MODULE</code> macro.</p><p>To compile this module, you can use the system Makefile<sup>[<a id="CHP-1-FN-3" href="#ftn.CHP-1-FN-3" class="footnote">3</a>]</sup> <code class="literal">bsd.kmod.mk</code>. Listing 1-2 shows the complete Makefile for hello.c.<a id="IDX-CHP-1-0024" class="indexterm"/><a id="IDX-CHP-1-0025" class="indexterm"/></p><a id="I_programlisting1_d1e551"/><pre class="programlisting">
KMOD=   hello           # Name of KLD to build.
SRCS=   hello.c         # List of source files.

.include &lt;bsd.kmod.mk&gt;
</pre><p><span class="emphasis"><em>Listing1-2: Makefile</em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Throughout this book, we'll adapt this Makefile to compile every KLD by filling out <em class="replaceable"><code>KMOD</code></em> and <em class="replaceable"><code>SRCS</code></em> with the appropriate module name and source listing(s), respectively.</p></div><p>Now, assuming the Makefile and hello.c are in the same directory, simply type <strong class="userinput"><code>make</code></strong> and (if we haven't botched anything) the compilation should proceed—very verbosely—and produce an executable file named hello.ko, as shown here:</p><a id="I_programlisting1_d1e570"/><pre class="programlisting">
$ <strong class="userinput"><code>make</code></strong>
Warning: Object directory not changed from original /usr/home/ghost/hello
@ -&gt; /usr/src/sys
machine -&gt; /usr/src/sys/i386/include
cc -O2 -pipe -funroll-loops -march=athlon-mp -fno-strict-aliasing -Werror -D_
KERNEL -DKLD_MODULE -nostdinc -I-   -I. -I@ -I@/contrib/altq -I@/../include -
I/usr/include -finline-limit=8000 -fno-common  -mno-align-long-strings -mpref
erred-stack-boundary=2  -mno-mmx -mno-3dnow -mno-sse -mno-sse2 -ffreestanding
 -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prot
otypes -Wpointer-arith -Winline -Wcast-qual  -fformat-extensions -std=c99 -c
hello.c
ld  -d -warn-common -r -d -o hello.kld hello.o
touch export_syms
awk -f /sys/conf/kmod_syms.awk hello.kld  export_syms | xargs -J% objcopy % h
ello.kld
ld -Bshareable  -d -warn-common -o hello.ko hello.kld
objcopy --strip-debug hello.ko
$ <strong class="userinput"><code>ls -F</code></strong>
@@           export_syms  hello.kld    hello.o
Makefile     hello.c      hello.ko*    machine@
</pre><p>You can load and unload hello.ko with the <code class="literal">kldload(8)</code> and <code class="literal">kldunload(8)</code> utilities,<sup>[<a id="CHP-1-FN-4" href="#ftn.CHP-1-FN-4" class="footnote">4</a>]</sup> as shown below:</p><a id="I_programlisting1_d1e602"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./hello.ko</code></strong>
Hello, world!
$ <strong class="userinput"><code>sudo kldunload hello.ko</code></strong>
Good-bye, cruel world!
</pre><p>Excellent—you have successfully loaded and unloaded code into a running kernel. Now, let's try something a little more advanced.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-3" href="#CHP-1-FN-3" class="para">3</a>] </sup><sup>3</sup> A <span class="emphasis"><em>Makefile</em></span> is used to simplify the process of converting a file or files from one form to another by describing the dependencies and build scripts for a given output. For more on Makefiles, see the make(1) manual page.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-4" href="#CHP-1-FN-4" class="para">4</a>] </sup><sup>4</sup> With a Makefile that includes <code class="literal">&lt;bsd.kmod.mk&gt;</code>, you can also use <code class="literal">make load</code> and <code class="literal">make unload</code> to load and unload the module once you have built it.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="system_call_modules"/>System Call Modules</h1></div></div></div><p><span class="emphasis"><em>System call modules</em></span> are simply KLDs that install a system call. In operating systems, a <span class="emphasis"><em>system call</em></span>, also known as a <span class="emphasis"><em>system service request</em></span>, is the mechanism an application uses to request service from the operating system's kernel.<a id="IDX-CHP-1-0026" class="indexterm"/><a id="IDX-CHP-1-0027" class="indexterm"/><a id="IDX-CHP-1-0028" class="indexterm"/><a id="IDX-CHP-1-0029" class="indexterm"/><a id="IDX-CHP-1-0030" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In <a class="xref" href="ch02.html" title="Chapter 2. HOOKING">Chapter 2</a>, <a class="xref" href="ch03.html" title="Chapter 3. DIRECT KERNEL OBJECT MANIPULATION">Chapter 3</a>, and <a class="xref" href="ch06.html" title="Chapter 6. PUTTING IT ALL TOGETHER">Chapter 6</a>, you'll be writing rootkits that either hack the existing system calls or install new ones. Thus, this section serves as a primer.</p></div><p>There are three items that are unique to each system call module: the system call function, the <code class="literal">sysent</code> structure, and the offset value.<a id="IDX-CHP-1-0031" class="indexterm"/><a id="IDX-CHP-1-0032" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_system_call_function"/>The System Call Function</h2></div></div></div><p>The system call function implements the system call. Its function prototype is defined in the <code class="literal">&lt;sys/sysent.h&gt;</code> header as:</p><a id="I_programlisting1_d1e678"/><pre class="programlisting">
typedef int     sy_call_t(struct thread *, void *);
</pre><p>where <code class="literal">struct thread *</code> points to the currently running thread, and <code class="literal">void *</code> points to the system call's arguments' structure, if there is any.</p><p>Here is an example system call function that takes in a character pointer (i.e., a string) and outputs it to the system console and logging facility via <code class="literal">printf(9)</code>.</p><a id="I_programlisting1_d1e693"/><pre class="programlisting">
❶struct sc_example_args {
        char *str;
};

static int
sc_example(struct thread *td, void *syscall_args)
{
         ❷struct sc_example_args *uap;
         ❸uap = (struct sc_example_args *)syscall_args;

        printf("%s\n", uap-&gt;str);

        return(0);

}
</pre><p>Notice that the system call's arguments are ❶ declared within a structure (<code class="literal">sc_example_args</code>). Also, notice that these arguments are accessed within the system call function by ❷ first declaring a <code class="literal">struct sc_example_args</code> pointer (<code class="literal">uap</code>) and then assigning ❸ the coerced <code class="literal">void</code> pointer (<code class="literal">syscall_args</code>) to that pointer.</p><p>Keep in mind that the system call's arguments reside in user space but that the system call function executes in kernel space.<sup>[<a id="CHP-1-FN-5" href="#ftn.CHP-1-FN-5" class="footnote">5</a>]</sup> Thus, when you access the arguments via <code class="literal">uap</code>, you are actually working by value, not reference. This means that, with this approach, you aren't able to modify the actual arguments.<a id="IDX-CHP-1-0033" class="indexterm"/><a id="IDX-CHP-1-0034" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In <a class="xref" href="ch01s05.html" title="Kernel/User Space Transitions">Kernel/User Space Transitions</a>, I'll detail how to modify data residing in user space while in kernel space.</p></div><p>It is probably worth mentioning that the kernel expects each system call argument to be of size <code class="literal">register_t</code> (which is an <code class="literal">int</code> on i386, but is typically a <code class="literal">long</code> on other platforms) and that it builds an array of <code class="literal">register_t</code> values that are then cast to <code class="literal">void *</code> and passed as the arguments. For this reason, you might need to include explicit padding in your arguments' structure to make it work correctly if it has any types that aren't of size <code class="literal">register_t</code> (e.g., <code class="literal">char</code>, or <code class="literal">int</code> on a 64-bit platform). The <code class="literal">&lt;sys/sysproto.h&gt;</code> header provides some macros to do this, along with examples.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_sysent_structure"/>The sysent Structure</h2></div></div></div><p>System calls are defined by their entries in a <code class="literal">sysent</code> structure, which is defined in the <code class="literal">&lt;sys/sysent.h&gt;</code> header as follows:<a id="IDX-CHP-1-0040" class="indexterm"/><a id="IDX-CHP-1-0041" class="indexterm"/><a id="IDX-CHP-1-0035" class="indexterm"/><a id="IDX-CHP-1-0036" class="indexterm"/><a id="IDX-CHP-1-0037" class="indexterm"/><a id="IDX-CHP-1-0038" class="indexterm"/><a id="IDX-CHP-1-0039" class="indexterm"/></p><a id="I_programlisting1_d1e825"/><pre class="programlisting">
struct sysent {
        int sy_narg;            /* number of arguments */
        sy_call_t *sy_call;     /* implementing function */
        au_event_t sy_auevent;  /* audit event associated with system call */

};
</pre><p>Here is the complete <code class="literal">sysent</code> structure for the example system call (shown in <a class="xref" href="ch01s04.html#the_system_call_function" title="The System Call Function">The System Call Function</a>):</p><a id="I_programlisting1_d1e834"/><pre class="programlisting">
static struct sysent sc_example_sysent = {
        1,                      /* number of arguments */
        sc_example              /* implementing function */
};
</pre><p>Recall that the example system call has only one argument (a character pointer) and is named <code class="literal">sc_example</code>.</p><p>One additional point is also worth mentioning. In FreeBSD, the system call table is simply an array of <code class="literal">sysent</code> structures, and it is declared in the <code class="literal">&lt;sys/sysent.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e849"/><pre class="programlisting">
extern struct sysent sysent[];
</pre><p>Whenever a system call is installed, its <code class="literal">sysent</code> structure is placed within an open element in <code class="literal">sysent[]</code>. (This is an important point that will come into play in <a class="xref" href="ch02.html" title="Chapter 2. HOOKING">Chapter 2</a> and <a class="xref" href="ch06.html" title="Chapter 6. PUTTING IT ALL TOGETHER">Chapter 6</a>.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Throughout this book, I'll refer to FreeBSD's system call table as <em class="replaceable"><code>sysent[]</code></em>.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_offset_value"/>The Offset Value</h2></div></div></div><p>The <span class="emphasis"><em>offset value</em></span> (also known as the <span class="emphasis"><em>system call number</em></span>) is a unique integer between 0 and 456 that is assigned to each system call to indicate its <code class="literal">sysent</code> structure's offset within <code class="literal">sysent[]</code>.<a id="IDX-CHP-1-0045" class="indexterm"/><a id="IDX-CHP-1-0046" class="indexterm"/><a id="IDX-CHP-1-0042" class="indexterm"/><a id="IDX-CHP-1-0043" class="indexterm"/><a id="IDX-CHP-1-0044" class="indexterm"/></p><p>Within a system call module, the offset value needs to be explicitly declared. This is typically done as follows:</p><a id="I_programlisting1_d1e916"/><pre class="programlisting">
static int offset = NO_SYSCALL;
</pre><p>The constant <code class="literal">NO_SYSCALL</code> sets <code class="literal">offset</code> to the next available or open element in <code class="literal">sysent[]</code>.</p><p>Although you could manually set <code class="literal">offset</code> to any unused system call number, it's considered good practice to avoid doing so when implementing something dynamic, like a KLD.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For a list of used and unused system call numbers, see the file /sys/kern/syscalls.master.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_syscall_module_macro"/>The SYSCALL_MODULE Macro</h2></div></div></div><p>Recall from <a class="xref" href="ch01s02.html" title="The DECLARE_MODULE Macro">The DECLARE_MODULE Macro</a> that when a KLD is loaded, it must link and register itself with the kernel and that you use the <code class="literal">DECLARE_MODULE</code> macro to do so. However, when writing a system call module, the <code class="literal">DECLARE_MODULE</code> macro is somewhat inconvenient, as you'll soon see. Thus, we use the <code class="literal">SYSCALL_MODULE</code> macro instead, which is defined in the <code class="literal">&lt;sys/sysent.h&gt;</code> header as follows:<a id="IDX-CHP-1-0047" class="indexterm"/><a id="IDX-CHP-1-0048" class="indexterm"/></p><a id="I_programlisting1_d1e969"/><pre class="programlisting">
#define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)     \
static struct syscall_module_data name##_syscall_mod = {       \
       evh, arg, offset, new_sysent, { 0, NULL }               \
};                                                             \
                                                               \
static moduledata_t name##_mod = {                             \
       #name,                                                  \
       syscall_module_handler,                                 \
       &amp;name##_syscall_mod                                 \
};                                                             \
DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)
</pre><p>As you can see, if we were to use the <code class="literal">DECLARE_MODULE</code> macro, we would've had to set up a <code class="literal">syscall_module_data</code> and <code class="literal">moduledata</code> structure first; thankfully, <code class="literal">SYSCALL_MODULE</code> saves us this trouble.</p><p>The following is a brief description of each parameter in <code class="literal">SYSCALL_MODULE</code>:<a id="IDX-CHP-1-0049" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>name</code></strong></span></dt><dd><p>This specifies the generic module name, which is passed as a character string.</p></dd><dt><span class="term"><strong class="userinput"><code>offset</code></strong></span></dt><dd><p>This specifies the system call's offset value, which is passed as an integer pointer.</p></dd><dt><span class="term"><strong class="userinput"><code>new_sysent</code></strong></span></dt><dd><p>This specifies the completed <code class="literal">sysent</code> structure, which is passed as a <code class="literal">struct sysent</code> pointer.</p></dd><dt><span class="term"><strong class="userinput"><code>evh</code></strong></span></dt><dd><p>This specifies the event handler function.</p></dd><dt><span class="term"><strong class="userinput"><code>arg</code></strong></span></dt><dd><p>This specifies the arguments to be passed to the event handler function. For our purposes, we'll always set this parameter to <code class="literal">NULL</code>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example"/>Example</h2></div></div></div><p>Listing 1-3 is a complete system call module.<a id="IDX-CHP-1-0051" class="indexterm"/><a id="IDX-CHP-1-0052" class="indexterm"/><a id="IDX-CHP-1-0053" class="indexterm"/><a id="IDX-CHP-1-0050" class="indexterm"/></p><a id="I_programlisting1_d1e1075"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;

/* The system call's arguments. */
struct sc_example_args {
        char *str;

};

/* The system call function. */
static int
sc_example(struct thread *td, void *syscall_args)
{
        struct sc_example_args *uap;
        uap = (struct sc_example_args *)syscall_args;

        printf("%s\n", uap-&gt;str);

        return(0);
}

/* The sysent for the new system call. */
static struct sysent sc_example_sysent = {
        1,                      /* number of arguments */
        sc_example              /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);
}

SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 1-3: sc_example.c</em></span></p><p>As you can see, this module is simply a combination of all the components described throughout this section, with the addition of an event handler function. Simple, no?</p><p>Here are the results of loading this module:</p><a id="I_programlisting1_d1e1084"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./sc_example.ko</code></strong>
System call loaded at offset 210.
</pre><p>So far, so good. Now, let's write a simple user space program to execute and test this new system call. But first, an explanation of the <code class="literal">modfind</code>, <code class="literal">modstat</code>, and <code class="literal">syscall</code> functions is required.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_modfind_function"/>The modfind Function</h2></div></div></div><p>The <code class="literal">modfind</code> function returns the modid of a kernel module based on its module name.<a id="IDX-CHP-1-0058" class="indexterm"/><a id="IDX-CHP-1-0059" class="indexterm"/><a id="IDX-CHP-1-0054" class="indexterm"/><a id="IDX-CHP-1-0055" class="indexterm"/><a id="IDX-CHP-1-0056" class="indexterm"/><a id="IDX-CHP-1-0057" class="indexterm"/></p><a id="I_programlisting1_d1e1136"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/module.h&gt;

int
modfind(const char *modname);
</pre><p><span class="emphasis"><em>Modids</em></span> are integers used to uniquely identify each loaded module in the system.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_modstat_function"/>The modstat Function</h2></div></div></div><p>The <code class="literal">modstat</code> function returns the status of a kernel module referred to by its modid.<a id="IDX-CHP-1-0060" class="indexterm"/><a id="IDX-CHP-1-0061" class="indexterm"/></p><a id="I_programlisting1_d1e1162"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/module.h&gt;

int
modstat(int modid, struct module_stat *stat);
</pre><p>The returned information is stored in <code class="literal">stat</code>, a <code class="literal">module_stat</code> structure, which is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:<a id="IDX-CHP-1-0062" class="indexterm"/></p><a id="I_programlisting1_d1e1180"/><pre class="programlisting">
struct module_stat {
        int             version;
        char            name[MAXMODNAME];       /* module name */
        int             refs;                   /* number of references */
        int             id;                     /* module id number */
        modspecific_t   data;                   /* module specific data */
};
typedef union modspecific {
        int             intval;                 /* offset value */
        u_int           uintval;
        long            longval;
        u_long          ulongval;
} modspecific_t;
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_syscall_function"/>The syscall Function</h2></div></div></div><p>The <code class="literal">syscall</code> function executes the system call specified by its system call number.<a id="IDX-CHP-1-0067" class="indexterm"/><a id="IDX-CHP-1-0068" class="indexterm"/><a id="IDX-CHP-1-0063" class="indexterm"/><a id="IDX-CHP-1-0064" class="indexterm"/><a id="IDX-CHP-1-0065" class="indexterm"/><a id="IDX-CHP-1-0066" class="indexterm"/></p><a id="I_programlisting1_d1e1225"/><pre class="programlisting">
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;

int
syscall(int number, ...);
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="executing_the_system_call"/>Executing the System Call</h2></div></div></div><p>Listing 1-4 is a user space program designed to execute the system call in Listing 1-3 (which is named <code class="literal">sc_example</code>). This program takes one command-line argument: a string to be passed to <code class="literal">sc_example</code>.</p><a id="I_programlisting1_d1e1238"/><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;

int
main(int argc, char *argv[])
{
        int syscall_num;
        struct module_stat stat;
        if (argc != 2) {
                printf("Usage:\n%s &lt;string&gt;\n", argv[0]);
                exit(0);
        }

        /* Determine sc_example's offset value. */
        stat.version = sizeof(stat);
        ❶modstat(modfind("sc_example"), &amp;stat);
        syscall_num = stat.data.intval;

        /* Call sc_example. */
        return(syscall(❷syscall_num, argv[1]));
}
</pre><p><span class="emphasis"><em>Listing 1-4: interface.c</em></span></p><p>As you can see, we first call ❶ <code class="literal">modfind</code> and <code class="literal">modstat</code> to determine <code class="literal">sc_example</code>'s offset value. This value is then passed to ❷ <code class="literal">syscall</code>, along with the first command-line argument, which effectively executes <code class="literal">sc_example</code>.</p><p>Some sample output follows:</p><a id="I_programlisting1_d1e1262"/><pre class="programlisting">
$ <strong class="userinput"><code>./interface Hello,\ kernel!</code></strong>
$ <strong class="userinput"><code>dmesg | tail -n 1</code></strong>
Hello, kernel!
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="executing_the_system_call_without_c_code"/>Executing the System Call Without C Code</h2></div></div></div><p>While writing a user space program to execute a system call is the "proper" way to do it, when you just want to test a system call module, it's annoying to have to write an additional program first. To execute a system call without writing a user space program, here's what I do:<a id="IDX-CHP-1-0069" class="indexterm"/><a id="IDX-CHP-1-0070" class="indexterm"/><a id="IDX-CHP-1-0071" class="indexterm"/><a id="IDX-CHP-1-0072" class="indexterm"/><a id="IDX-CHP-1-0073" class="indexterm"/><a id="IDX-CHP-1-0074" class="indexterm"/></p><a id="I_programlisting1_d1e1305"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./sc_example.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>perl -e '$str = "Hello, kernel!";' -e 'syscall(210, $str);'</code></strong>
$ <strong class="userinput"><code>dmesg | tail -n 1</code></strong>
Hello, kernel!
</pre><p>As the preceding demonstration shows, by taking advantage of Perl's command-line execution (i.e., the <code class="literal">-e</code> option), its <code class="literal">syscall</code> function, and the fact that you know your system call's offset value, you can quickly test any system call module. One thing to keep in mind is that you cannot use string literals with Perl's <code class="literal">syscall</code> function, which is why I use a variable (<code class="literal">$str</code>) to pass the string to <code class="literal">sc_example</code>.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-5" href="#CHP-1-FN-5" class="para">5</a>] </sup><sup>5</sup> FreeBSD segregates its virtual memory into two parts: <span class="emphasis"><em>user space</em></span> and <span class="emphasis"><em>kernel space</em></span>. User space is where all user-mode applications run, while kernel space is where the kernel and kernel exten-sions (i.e., LKMs) run. Code running in user space cannot access kernel space directly (but code running in kernel space <span class="emphasis"><em>can</em></span> access user space). To access kernel space from user space, an application issues a system call.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="kernel_solidus_user_space_transitions"/>Kernel/User Space Transitions</h1></div></div></div><p>I'll now describe a set of core functions that you can use from kernel space to copy, manipulate, and overwrite the data stored in user space. We'll put these functions to much use throughout this book.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_copyin_and_copyinstr_functions"/>The copyin and copyinstr Functions</h2></div></div></div><p>The <code class="literal">copyin</code> and <code class="literal">copyinstr</code> functions allow you to copy a continuous region of data from user space to kernel space.<a id="IDX-CHP-1-0075" class="indexterm"/></p><a id="I_programlisting1_d1e1352"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;

int
copyin(const void *uaddr, void *kaddr, size_t len);

int
copyinstr(const void *uaddr, void *kaddr, size_t len, size_t *done);
</pre><p>The <code class="literal">copyin</code> function copies <code class="literal">len</code> bytes of data from the user space address <code class="literal">uaddr</code> to the kernel space address <code class="literal">kaddr</code>.<a id="IDX-CHP-1-0076" class="indexterm"/></p><p>The <code class="literal">copyinstr</code> function is similar, except that it copies a null-terminated string, which is at most <code class="literal">len</code> bytes long, with the number of bytes actually copied returned in <code class="literal">done</code>.<sup>[<a id="CHP-1-FN-6" href="#ftn.CHP-1-FN-6" class="footnote">6</a>]</sup><a id="IDX-CHP-1-0077" class="indexterm"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_copyout_function"/>The copyout Function</h2></div></div></div><p>The <code class="literal">copyout</code> function is similar to <code class="literal">copyin</code>, except that it operates in the opposite direction, copying data from kernel space to user space.<a id="IDX-CHP-1-0078" class="indexterm"/></p><a id="I_programlisting1_d1e1413"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;

int
copyout(const void *kaddr, void *uaddr, size_t len);
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_copystr_function"/>The copystr Function</h2></div></div></div><p>The <code class="literal">copystr</code> function is similar to <code class="literal">copyinstr</code>, except that it copies a string from one kernel space address to another.<a id="IDX-CHP-1-0079" class="indexterm"/></p><a id="I_programlisting1_d1e1431"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/systm.h&gt;

int
copystr(const void *kfaddr, void *kdaddr, size_t len, size_t *done);
</pre></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-6" href="#CHP-1-FN-6" class="para">6</a>] </sup><sup>6</sup> In Listing 1-3, the system call function should, admittedly, first call <code class="literal">copyinstr</code> to copy in the user space string and then print that. As is, it prints a userland string directly from kernel space, which can trigger a fatal panic if the page holding the string is unmapped (i.e., swapped out or not faulted in yet). That's why it's just an example and not a real system call.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="character_device_modules"/>Character Device Modules</h1></div></div></div><p><span class="emphasis"><em>Character device modules</em></span> are KLDs that create or install a character device. In FreeBSD, a <span class="emphasis"><em>character device</em></span> is the interface for accessing a specific device within the kernel. For example, data is read from and written to the system console via the character device /dev/console.<a id="IDX-CHP-1-0082" class="indexterm"/><a id="IDX-CHP-1-0080" class="indexterm"/><a id="IDX-CHP-1-0081" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In <a class="xref" href="ch04.html" title="Chapter 4. KERNEL OBJECT HOOKING">Chapter 4</a> you'll be writing rootkits that hack the existing character devices on the system. Thus, this section serves as a primer.</p></div><p>There are three items that are unique to each character device module: a <code class="literal">cdevsw</code> structure, the character device functions, and a device registration routine. We'll discuss each in turn below.<a id="IDX-CHP-1-0083" class="indexterm"/><a id="IDX-CHP-1-0084" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_cdevsw_structure"/>The cdevsw Structure</h2></div></div></div><p>A character device is defined by its entries in a character device switch table, <code class="literal">struct cdevsw</code>, which is defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e1491"/><pre class="programlisting">
struct cdevsw {
        int                     d_version;
        u_int                   d_flags;
        const char              *d_name;
        d_open_t                *d_open;
        d_fdopen_t              *d_fdopen;
        d_close_t               *d_close;
        d_read_t                *d_read;
        d_write_t               *d_write;
        d_ioctl_t               *d_ioctl;
        d_poll_t                *d_poll;
        d_mmap_t                *d_mmap;
        d_strategy_t            *d_strategy;
        dumper_t                *d_dump;
        d_kqfilter_t            *d_kqfilter;
        d_purge_t               *d_purge;
        d_spare2_t              *d_spare2;
        uid_t                   d_uid;
        gid_t                   d_gid;
        mode_t                  d_mode;
        const char              *d_kind;

        /* These fields should not be messed with by drivers */
        LIST_ENTRY(cdevsw)      d_list;
        LIST_HEAD(, cdev)       d_devs;
        int                     d_spare3;
        struct cdevsw           *d_gianttrick;
};
</pre><p><a class="xref" href="ch01s06.html#entry_points_for_character_device_drivers" title="Table 1-1. Entry Points for Character Device Drivers">Table 1-1</a> provides a brief description of the most relevant entry points.</p><div class="table"><a id="entry_points_for_character_device_drivers"/><p class="title"><b>Table 1-1. Entry Points for Character Device Drivers</b></p><div class="table-contents"><table summary="Entry Points for Character Device Drivers" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Entry Point</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">d_open</code></p></td><td style="text-align: left" valign="top"><p>Opens a device for I/O operations</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_close</code></p></td><td style="text-align: left" valign="top"><p>Closes a device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_read</code></p></td><td style="text-align: left" valign="top"><p>Reads data from a device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_write</code></p></td><td style="text-align: left" valign="top"><p>Writes data to a device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_ioctl</code></p></td><td style="text-align: left" valign="top"><p>Performs an operation other than a read or a write</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_poll</code></p></td><td style="text-align: left" valign="top"><p>Polls a device to see if there is data to be read or space available for writing</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Here is an example <code class="literal">cdevsw</code> structure for a simple read/write character device module:</p><a id="I_programlisting1_d1e1564"/><pre class="programlisting">
static struct cdevsw cd_example_cdevsw = {
        .d_version =    D_VERSION,
        .d_open =       open,
        .d_close =      close,
        .d_read =       read,
        .d_write =      write,
        .d_name =       "cd_example"
};
</pre><p>Notice that I do not define every entry point or fill out every attribute. This is perfectly okay. For every entry point left null, the operation is considered unsupported. For example, when creating a write-only device, you would not declare the read entry point.</p><p>Still, there are two elements that must be defined in every <code class="literal">cdevsw</code> structure: <code class="literal">d_version</code>, which indicates the versions of FreeBSD that the driver supports, and <code class="literal">d_name</code>, which specifies the device's name.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The constant <em class="replaceable"><code>D_VERSION</code></em> is defined in the <em class="replaceable"><code>&lt;sys/conf.h&gt;</code></em> header, along with other version numbers.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="character_device_functions"/>Character Device Functions</h2></div></div></div><p>For every entry point defined in a character device module's <code class="literal">cdevsw</code> structure, you must implement a corresponding function. The function prototype for each entry point is defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header.<a id="IDX-CHP-1-0085" class="indexterm"/><a id="IDX-CHP-1-0086" class="indexterm"/><a id="IDX-CHP-1-0087" class="indexterm"/><a id="IDX-CHP-1-0088" class="indexterm"/><a id="IDX-CHP-1-0089" class="indexterm"/><a id="IDX-CHP-1-0090" class="indexterm"/><a id="IDX-CHP-1-0091" class="indexterm"/><a id="IDX-CHP-1-0092" class="indexterm"/></p><p>Below is an example implementation for the write entry point.</p><a id="I_programlisting1_d1e1640"/><pre class="programlisting">
/* Function prototype. */
d_write_t       write;

int
write(struct cdev *dev, struct uio *uio, int ioflag)
{
        int error = 0;
        error = copyinstr(uio-&gt;uio_iov-&gt;iov_base, &amp;buf, 512, &amp;len);
        if (error != 0)
                uprintf("Write to \"cd_example\" failed.\n");
        return(error);
}
</pre><p>As you can see, this function simply calls <code class="literal">copyinstr</code> to copy a string from user space and store it in a buffer, <code class="literal">buf</code>, in kernel space.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In <a class="xref" href="ch01s06.html#example-id1" title="Example">Example</a> I'll show and explain some more entry-point implementations.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_device_registration_routine"/>The Device Registration Routine</h2></div></div></div><p>The device registration routine creates or installs the character device on /dev and registers it with the device file system (DEVFS). You can accomplish this by calling the <code class="literal">make_dev</code> function within the event handler function as follows:<a id="IDX-CHP-1-0093" class="indexterm"/><a id="IDX-CHP-1-0094" class="indexterm"/></p><a id="I_programlisting1_d1e1673"/><pre class="programlisting">
static struct cdev *sdev;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;
        switch (cmd) {

        case MOD_LOAD:
                sdev = make_dev(&amp;cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL,
                    0600, "cd_example");
                uprintf("Character device loaded\n");
                break;

        case MOD_UNLOAD:
                destroy_dev(sdev);
                uprintf("Character device unloaded\n");
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }
        return(error);
}
</pre><p>This example function will register the character device, <code class="literal">cd_example</code>, when the module loads by calling the <code class="literal">make_dev</code> function, which will create a <code class="literal">cd_example</code> device node on /dev. Also, this function will unregister the character device when the module unloads by calling the <code class="literal">destroy_dev</code> function, which takes as its sole argument the <code class="literal">cdev</code> structure returned from a preceding <code class="literal">make_dev</code> call.<a id="IDX-CHP-1-0095" class="indexterm"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id1"/>Example</h2></div></div></div><p>Listing 1-5 shows a complete character device module (based on Rajesh Vaidheeswarran's cdev.c) that installs a simple read/write character device. This device acts on an area of kernel memory, reading and writing a single character string from and to it.<a id="IDX-CHP-1-0097" class="indexterm"/><a id="IDX-CHP-1-0096" class="indexterm"/></p><a id="I_programlisting1_d1e1714"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/uio.h&gt;

/* Function prototypes. */
d_open_t        open;
d_close_t       close;
d_read_t        read;
d_write_t       write;

static struct cdevsw cd_example_cdevsw = {
        .d_version =    D_VERSION,
        .d_open =       open,
        .d_close =      close,
        .d_read =       read,
        .d_write =      write,
        .d_name =       "cd_example"
};

static char buf[512+1];
static size_t len;

int
open(struct cdev *dev, int flag, int otyp, struct thread *td)
{
        /* Initialize character buffer. */
        memset(&amp;buf, '\0', 513);
        len = 0;

        return(0);
}

int
close(struct cdev *dev, int flag, int otyp, struct thread *td)
{
        return(0);
}

int
write(struct cdev *dev, struct uio *uio, int ioflag)
{
        int error = 0;

        /*
         * Take in a character string, saving it in buf.
         * Note: The proper way to transfer data between buffers and I/O
         * vectors that cross the user/kernel space boundary is with
         * uiomove(), but this way is shorter. For more on device driver I/O
         * routines, see the uio(9) manual page.
         */
        error = copyinstr(uio-&gt;uio_iov-&gt;iov_base, &amp;buf, 512, &amp;len);
        if (error != 0)
                uprintf("Write to \"cd_example\" failed.\n");

        return(error);
}

int
read(struct cdev *dev, struct uio *uio, int ioflag)
{
        int error = 0;

        if (len &lt;= 0)
                error = −1;
        else
                /* Return the saved character string to userland. */
                copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len);

        return(error);
}

/* Reference to the device in DEVFS. */
static struct cdev *sdev;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                sdev = make_dev(&amp;cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL,
                    0600, "cd_example");
                uprintf("Character device loaded.\n");
                break;

        case MOD_UNLOAD:
                destroy_dev(sdev);
                uprintf("Character device unloaded.\n");
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);
}
DEV_MODULE(cd_example, load, NULL);
</pre><p><span class="emphasis"><em>Listing 1-5: cd_example.c</em></span></p><p>The following is a breakdown of the above listing. First, at the beginning, we declare the character device's entry points (open, close, read, and write). Next, we appropriately fill out a <code class="literal">cdevsw</code> structure. Afterward, we declare two global variables: <code class="literal">buf</code>, which is used to store the character string that this device will be reading in, and <code class="literal">len</code>, which is used to store the string length. Next, we implement each entry point. The open entry point simply initializes <code class="literal">buf</code> and then returns. The close entry point does nothing, more or less, but it still needs to be implemented in order to close the device. The write entry point is what is called to store the character string (from user space) in <code class="literal">buf</code>, and the read entry point is what is called to return it. Lastly, the event handler function takes care of the character device's registration routine.</p><p>Notice that the character device module calls <code class="literal">DEV_MODULE</code> at the end, instead of <code class="literal">DECLARE_MODULE</code>. The <code class="literal">DEV_MODULE</code> macro is defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header as follows:<a id="IDX-CHP-1-0098" class="indexterm"/></p><a id="I_programlisting1_d1e1755"/><pre class="programlisting">
#define DEV_MODULE(name, evh, arg)                                      \
static moduledata_t name##_mod = {                                      \
    #name,                                                              \
    evh,                                                                \
    arg                                                                 \
};                                                                      \
DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)
</pre><p>As you can see, <code class="literal">DEV_MODULE</code> wraps <code class="literal">DECLARE_MODULE</code>. <code class="literal">DEV_MODULE</code> simply allows you to call <code class="literal">DECLARE_MODULE</code> without having to explicitly set up a <code class="literal">moduledata</code> structure first.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <em class="replaceable"><code>DEV_MODULE</code></em> macro is typically associated with character device modules. Thus, when I write a generic KLD (such as the "Hello, world!" example in <a class="xref" href="ch01s03.html" title="&quot;Hello, world!&quot;">"Hello, world!"</a>), I'll continue to use the <em class="replaceable"><code>DECLARE_MODULE</code></em> macro, even if <em class="replaceable"><code>DEV_MODULE</code></em> would save space and time.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="testing_the_character_device"/>Testing the Character Device</h2></div></div></div><p>Now let's look at the user space program (Listing 1-6) that we'll use to interact with the <code class="literal">cd_example</code> character device. This program (based on Rajesh Vaidheeswarran's testcdev.c) calls each <code class="literal">cd_example</code> entry point in the following order: open, write, read, close; then it exits.<a id="IDX-CHP-1-0099" class="indexterm"/><a id="IDX-CHP-1-0100" class="indexterm"/><a id="IDX-CHP-1-0101" class="indexterm"/></p><a id="I_programlisting1_d1e1816"/><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;paths.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;

#define CDEV_DEVICE     "cd_example"
static char buf[512+1];

int
main(int argc, char *argv[])
{
        int kernel_fd;
        int len;

        if (argc != 2) {
                printf("Usage:\n%s &lt;string&gt;\n", argv[0]);
                exit(0);
        }

        /* Open cd_example. */
        if ((kernel_fd = open("/dev/" CDEV_DEVICE, O_RDWR)) == −1) {
                perror("/dev/" CDEV_DEVICE);
                exit(1);
        }

        if ((len = strlen(argv[1]) + 1) &gt; 512) {
                printf("ERROR: String too long\n");
                exit(0);
        }

        /* Write to cd_example. */
        if (write(kernel_fd, argv[1], len) == −1)
                perror("write()");
        else
                printf("Wrote \"%s\" to device /dev/" CDEV_DEVICE ".\n",
                    argv[1]);

        /* Read from cd_example. */
        if (read(kernel_fd, buf, len) == −1)
                perror("read()");
        else
                printf("Read \"%s\" from device /dev/" CDEV_DEVICE ".\n",
                    buf);

        /* Close cd_example. */
        if ((close(kernel_fd)) == −1) {
                perror("close()");
                exit(1);
        }

        exit(0);
}
</pre><p><span class="emphasis"><em>Listing 1-6: interface.c</em></span></p><p>Here are the results of loading the character device module and interacting with it:</p><a id="I_programlisting1_d1e1823"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./cd_example.ko</code></strong>
Character device loaded.
$ <strong class="userinput"><code>ls -l /dev/cd_example</code></strong>
crw-------  1 root  wheel    0,  89 Mar 26 00:32 /dev/cd_example
$ <strong class="userinput"><code>./interface</code></strong>
Usage:
./interface &lt;string&gt;
$ <strong class="userinput"><code>sudo ./interface Hello,\ kernel!</code></strong>
Wrote "Hello, kernel!" to device /dev/cd_example.
Read "Hello, kernel!" from device /dev/cd_example.
</pre></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="linker_files_and_modules"/>Linker Files and Modules</h1></div></div></div><p>Before wrapping up this chapter, let's take a brief look at the <code class="literal">kldstat(8)</code> command, which displays the status of any files dynamically linked into the kernel.<a id="IDX-CHP-1-0102" class="indexterm"/><a id="IDX-CHP-1-0103" class="indexterm"/><a id="IDX-CHP-1-0104" class="indexterm"/></p><a id="I_programlisting1_d1e1859"/><pre class="programlisting">
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    4 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
 3    1 0xc1e8b000 2000     hello.ko
</pre><p>In the above listing, three "modules" are loaded: the kernel (<code class="literal">kernel</code>), the ACPI power-management module (<code class="literal">acpi.ko</code>), and the "Hello, world!" module (<code class="literal">hello.ko</code>) that we developed in <a class="xref" href="ch01s03.html" title="&quot;Hello, world!&quot;">"Hello, world!"</a>.</p><p>Running the command <code class="literal">kldstat -v</code> (for more verbose output) gives us the following:</p><a id="I_programlisting1_d1e1882"/><pre class="programlisting">
$ <strong class="userinput"><code>kldstat -v</code></strong>
Id Refs Address    Size     Name
 1    4 0xc0400000 63070c   kernel
        Contains modules:
                Id Name
                18 xpt
                19 probe
                20 cam
. . .
 3    1 0xc1e8b000 2000     hello.ko
        Contains modules:
                Id Name
                367 hello
</pre><p>Note that <code class="literal">kernel</code> contains multiple "submodules" (<code class="literal">xpt</code>, <code class="literal">probe</code>, and <code class="literal">cam</code>). This brings us to the real point of this section. In the preceding output, <code class="literal">kernel</code> and <code class="literal">hello.ko</code> are technically linker files, and <code class="literal">xpt</code>, <code class="literal">probe</code>, <code class="literal">cam</code>, and <code class="literal">hello</code> are the actual modules. This means that the arguments(s) for <code class="literal">kldload(8)</code> and <code class="literal">kldunload(8)</code> are actually linker files, not modules, and that for every module loaded into the kernel, there is an accompanying linker file. (This point will come into play when we discuss hiding KLDs.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For our purposes, think of a linker file as an usher (or escort) for one or more kernel modules, guiding them into kernel space.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="concluding_remarks-id1"/>Concluding Remarks</h1></div></div></div><p>This chapter has been a whirlwind tour of FreeBSD kernel-module programming. I've described some of the various types of KLDs that we'll encounter again and again, and you've seen numerous small examples to give you a feel for what the remainder of this book is like.<a id="IDX-CHP-1-0105" class="indexterm"/><a id="IDX-CHP-1-0106" class="indexterm"/></p><p>Two additional points are also worth mentioning. First, the kernel source tree, which is located in /usr/src/sys/,<sup>[<a id="CHP-1-FN-7" href="#ftn.CHP-1-FN-7" class="footnote">7</a>]</sup> is the best reference and learning tool for a newbie FreeBSD kernel hacker. If you have yet to look through this directory, by all means, do so; much of the code in this book is gleaned from there.<a id="IDX-CHP-1-0107" class="indexterm"/></p><p>Second, consider setting up a FreeBSD machine with a debug kernel or kernel-mode debugger; this helps considerably when you write your own kernel code. The following online resources will help you.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>The FreeBSD Developer's Handbook</em></span>, specifically Chapter 10, located at <a class="ulink" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook">http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook</a>.<a id="IDX-CHP-1-0108" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Debugging Kernel Problems</em></span> by Greg Lehey, located at <a class="ulink" href="http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf">http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf</a></p></li></ul></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-7" href="#CHP-1-FN-7" class="para">7</a>] </sup><sup>7</sup> Typically, there is also a symlink from /sys/ to /usr/src/sys/.</p></div></div></div></body></html>