["```\nEAX == 100             // break if eax holds the value 100\nESI > EDI              // break if esi is greater than edi\nDword(EBP-20) == 10    // Read current stack frame (var_20) and compare to 10\nGetRegValue(\"ZF\")      // break if zero flag is set\nEAX = 1                // Set EAX to 1, this also evaluates to true (non-zero)\nEIP = 0x0804186C       // Change EIP, perhaps to bypass code\n```", "```\nThread   Address             Instruction    Result\n   ------   -------             -----------    ------\n  00000150\n .text:sub_401320+17 rep movsb      ECX=00000000 ESI=0022FE2C EDI=0022FCF4\n   00000150 .text:sub_401320+19 pop esi        ESI=00000000 ESP=0022FCE4\n```", "```\nThread   Address             Instruction   Result\n------   -------             -----------   ------\n000012AC .text:sub_401320+17 rep movsb     ECX=0000000B\n ESI=0022FE21 EDI=0022FCE9 EFL=00010206 RF=1\n000012AC .text:sub_401320+17 rep movsb     ECX=0000000A ESI=0022FE22 EDI=0022FCEA\n000012AC .text:sub_401320+17 rep movsb     ECX=00000009 ESI=0022FE23 EDI=0022FCEB\n000012AC .text:sub_401320+17 rep movsb     ECX=00000008 ESI=0022FE24 EDI=0022FCEC\n000012AC .text:sub_401320+17 rep movsb     ECX=00000007 ESI=0022FE25 EDI=0022FCED\n000012AC .text:sub_401320+17 rep movsb     ECX=00000006 ESI=0022FE26 EDI=0022FCEE\n000012AC .text:sub_401320+17 rep movsb     ECX=00000005 ESI=0022FE27 EDI=0022FCEF\n000012AC .text:sub_401320+17 rep movsb     ECX=00000004 ESI=0022FE28 EDI=0022FCF0\n000012AC .text:sub_401320+17 rep movsb     ECX=00000003 ESI=0022FE29 EDI=0022FCF1\n000012AC .text:sub_401320+17 rep movsb     ECX=00000002 ESI=0022FE2A EDI=0022FCF2\n000012AC .text:sub_401320+17 rep movsb     ECX=00000001 ESI=0022FE2B EDI=0022FCF3\n000012AC .text:sub_401320+17 rep movsb     ECX=00000000\n ESI=0022FE2C EDI=0022FCF4 EFL=00000206 RF=0\n000012AC .text:sub_401320+19 pop esi       ESI=00000000 ESP=0022FCE4\n```", "```\nThread   Address             Instruction  Result\n------   -------             -----------  ------\n000017AC .text:sub_401320+17 rep movsb    ECX=0000000B ESI=0022F\nE21 EDI=0022FCE9 EFL=00010206 RF=1\n=        =                   =            ECX=0000000A ESI=0022FE22 EDI=0022FCEA\n=        =                   =            ECX=00000009 ESI=0022FE23 EDI=0022FCEB\n=        =                   =            ECX=00000008 ESI=0022FE24 EDI=0022FCEC\n=        =                   =            ECX=00000007 ESI=0022FE25 EDI=0022FCED\n=        =                   =            ECX=00000006 ESI=0022FE26 EDI=0022FCEE\n=        =                   =            ECX=00000005 ESI=0022FE27 EDI=0022FCEF\n=        =                   =            ECX=00000004 ESI=0022FE28 EDI=0022FCF0\n=        =                   =            ECX=00000003 ESI=0022FE29 EDI=0022FCF1\n=        =                   =            ECX=00000002 ESI=0022FE2A EDI=0022FCF2\n=        =                   =            ECX=00000001 ESI=0022FE2B EDI=0022FCF3\n=        =                   =            ECX=00000000 ESI=0022FE2C\n EDI=0022FCF4 EFL=00000206 RF=0\n000017AC .text:sub_401320+19 pop esi      ESI=00000000 ESP=0022FCE4\n```", "```\n#include <idc.idc>\n/*\n * The following should return 1 to break, and 0 to continue execution.\n */\nstatic my_breakpoint_condition() {\n   return AskYN(1, \"my_breakpoint_condition activated, break now?\") == 1;\n}\n\n/*\n * This function is required to register my_breakpoint_condition\n * as a breakpoint conditional expression\n */\nstatic main() {\n   auto addr;\n   addr = ScreenEA();\n   AddBpt(addr);\n   SetBptCnd(addr, \"my_breakpoint_condition()\");\n}\n```", "```\nStepOver();\nStepOver();    //this and all subsequent calls will fail\nStepOver();\nStepOver();\n```", "```\nStepOver();\nGetDebuggerEvent(WFNE_SUSP, −1);\nStepOver();\nGetDebuggerEvent(WFNE_SUSP, −1);\nStepOver();\nGetDebuggerEvent(WFNE_SUSP, −1);\nStepOver();\nGetDebuggerEvent(WFNE_SUSP, −1);\n```", "```\nGetDebuggerEvent(WFNE_SUSP | WFNE_CONT, −1);\n```", "```\nstatic main() {\n     auto ca, code, addr, count, idx;\n    ca = GetArrayId(\"stats\");\n     if (ca != −1) {\n        DeleteArray(ca);\n     }\n     ca = CreateArray(\"stats\");\n    EnableTracing(TRACE_STEP, 1);\n    for (code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1); code > 0;\n            code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)) {\n       addr = GetEventEa();\n       count = GetArrayElement(AR_LONG, ca, addr) + 1;\n       SetArrayLong(ca, addr, count);\n     }\n     EnableTracing(TRACE_STEP, 0);\n    for (idx = GetFirstIndex(AR_LONG, ca);\n            idx != BADADDR;\n            idx = GetNextIndex(AR_LONG, ca, idx)) {\n        count = GetArrayElement(AR_LONG, ca, idx);\n        Message(\"%x: %d\\n\", idx, count);\n     }\n    DeleteArray(ca);\n  }\n```", "```\n401028: 1\n40102b: 1\n40102e: 2\n401031: 2\n401034: 2\n401036: 1\n40103b: 1\n```", "```\nfor (code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1); code > 0;\n          code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)) {\n        addr = GetEventEa();\n       mnem = GetMnem(addr);\n       count = GetHashLong(ht, mnem) + 1;\n       SetHashLong(ht, mnem, count);\n     }\n```", "```\nadd:   18\nand:   2\ncall:  46\ncmp:   16\ndec:   1\nimul:  2\njge:   2\njmp:   5\njnz:   7\njs:    1\njz:    5\nlea:   4\nmov:   56\npop:   25\npush:  59\nretn:  19\nsar:   2\nsetnz: 3\ntest:  3\nxor:   7\n```", "```\n//A netnode to gather stats into\n netnode stats(\"$ stats\", 0, true);\n\nint idaapi init(void) {\n   hook_to_notification_point(HT_DBG, dbg_hook, NULL);\n   return PLUGIN_KEEP;\n}\n\nvoid idaapi term(void) {\n   unhook_from_notification_point(HT_DBG, dbg_hook, NULL);\n}\n```", "```\nvoid idaapi run(int arg) {\n     stats.altdel();   //clear any existing stats\n    request_enable_step_trace();\n    request_step_until_ret();\n    run_requests();\n  }\n```", "```\nint idaapi dbg_hook(void *user_data, int notification_code, va_list va) {\n     switch (notification_code) {\n       case dbg_trace:  //notification arguments are detailed in dbg.hpp\n           va_arg(va, thid_t);\n          ea_t ea = va_arg(va, ea_t);\n           //increment the count for this address\n          stats.altset(ea, stats.altval(ea) + 1);\n           return 0;\n       case dbg_step_until_ret:\n           //print results\n          for\n(nodeidx_t i = stats.alt1st(); i != BADNODE; i = stats.altnxt(i)) {\n               msg(\"%x: %d\\n\", i, stats.altval(i));\n           }\n           //delete the netnode and stop tracing\n          stats.kill();\n          request_disable_step_trace();\n          run_requests();\n           break;\n     }\n  }\n```", "```\nUPX1:00410370 start proc near\n   UPX1:00410370 pusha\n    UPX1:00410371 mov     esi, offset off_40A000\n    UPX1:00410376 lea     edi, [esi-9000h]\n    UPX1:0041037C push    edi\n    ...\n    UPX1:004104EC pop     eax\n   UPX1:004104ED popa                            ; opcode 0x53\n    UPX1:004104EE lea     eax, [esp-80h]\n    UPX1:004104F2\n    UPX1:004104F2 loc_4104F2:                       ; CODE XREF: start+186↓j\n    UPX1:004104F2 push    0\n    UPX1:004104F4 cmp     esp, eax\n    UPX1:004104F6 jnz     short loc_4104F2\n    UPX1:004104F8 sub     esp, 0FFFFFF80h\n   UPX1:004104FB jmp     loc_40134C\n```", "```\n#include <idc.idc>\n\n    #define POPA 0x53\n\n    static main() {\n       auto addr, seg;\n       addr = BeginEA();   //Obtain the entry point address\n       seg = SegName(addr);\n      while (addr != BADADDR && SegName(addr) == seg) {\n         if (Byte(addr) == POPA) {\n            RunTo(addr);\n             GetDebuggerEvent(WFNE_SUSP, −1);\n             Warning(\"Program is unpacked!\");\n            TakeMemorySnapshot(1);\n             return;\n            }\n         addr = FindCode(addr, SEARCH_NEXT | SEARCH_DOWN);\n       }\n       Warning(\"Failed to locate popa!\");\n    }\n```", "```\nstart = BeginEA()\n  RunTo(start)\n   GetDebuggerEvent(WFNE_SUSP, −1)\n  EnableTracing(TRACE_STEP, 1)\n   code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)\n   while code > 0:\n     if GetEventEa() < start: break\n      code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)\n  PauseProcess()\n   GetDebuggerEvent(WFNE_SUSP, −1)\n  EnableTracing(TRACE_STEP, 0)\n  MakeCode(GetEventEa())\n   TakeMemorySnapshot(1)\n```", "```\nUPX1:0040A000 dword_40A000    dd 7C812F1Dh        ; DATA XREF: start+1↓o\nUPX1:0040A004 dword_40A004    dd 7C91043Dh        ; DATA XREF: sub_403BF3+68↑r\nUPX1:0040A004                                     ; sub_405F0B+2B4↑r ...\nUPX1:0040A008                 dd 7C812ADEh\nUPX1:0040A00C dword_40A00C    dd 7C9105D4h        ; DATA XREF: sub_40621F+5D↑r\nUPX1:0040A00C                                     ; sub_4070E8+F↑r ...\nUPX1:0040A010                 dd 7C80ABC1h\nUPX1:0040A014 dword_40A014    dd 7C901005h        ; DATA XREF: sub_401564+34↑r\nUPX1:0040A014                                     ; sub_4015A0+27↑r ...\n```", "```\nUPX0:00403C5B               call    ds:dword_40A004\nUPX0:00403C61                 test    eax, eax\nUPX0:00403C63                 jnz     short loc_403C7B\nUPX0:00403C65                call    sub_40230F\nUPX0:00403C6A                 mov     esi, eax\nUPX0:00403C6C                call    ds:dword_40A058\n```", "```\nUPX1:0040A000 off_40A000 dd offset kernel32_GetCommand\nLineA ; DATA XREF:UPX0:loc_40128F↑r\nUPX1:0040A000                                               ; start+1↓o\nUPX1:0040A004 off_40A004 dd offset ntdll_RtlFreeHeap        ; DATA XREF:\n UPX0:004011E4↑r\nUPX1:0040A004                                               ; UPX0:0040120A↑r ...\nUPX1:0040A008 off_40A008 dd offset kernel32_GetVersionExA   ; DATA\n XREF: UPX0:004011D4↑r\nUPX1:0040A00C dd offset ntdll_RtlAllocateHeap               ; DATA\n XREF: UPX0:004011B3↑r\nUPX1:0040A00C                                               ; sub_405E98+D↑r ...\nUPX1:0040A010 off_40A010 dd offset kernel32_GetProcessHeap  ; DATA\n XREF: UPX0:004011AA↑r\nUPX1:0040A014 dd offset ntdll_RtlEnterCriticalSection ; DATA XREF: sub_401564+34↑r\nUPX1:0040A014                                         ; sub_4015A0+27↑r ...\n```", "```\nUPX1:00408897           call    dword ptr [esi+8090h]\nUPX1:0040889D             or      eax, eax\nUPX1:0040889F             jz      short loc_4088A8\nUPX1:004088A1            mov     [ebx], eax\nUPX1:004088A3            add     ebx, 4\n```", "```\nUPX1:0040A000 ; LPSTR __stdcall GetCommandLineA()\nUPX1:0040A000 GetCommandLineA dd offset kernel32_GetCommandLineA\nUPX1:0040A000                                         ; DATA XREF: UPX0:loc_40128F↑r\nUPX1:0040A000                                         ; start+1↓o\nUPX1:0040A004 RtlFreeHeap dd offset ntdll_RtlFreeHeap ; DATA XREF: UPX0:004011E4↑r\nUPX1:0040A004                                         ; UPX0:0040120A↑r ...\nUPX1:0040A008 ; BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)\nUPX1:0040A008 GetVersionExA dd offset kernel32_GetVersionExA ; DATA\n XREF: UPX0:004011D4↑r\nUPX1:0040A00C RtlAllocateHeap dd offset ntdll_RtlAllocateHeap ; DATA\n XREF: UPX0:004011B3↑r\nUPX1:0040A00C                                         ; sub_405E98+D↑r ...\nUPX1:0040A010 ; HANDLE __stdcall GetProcessHeap()\nUPX1:0040A010 GetProcessHeap dd offset kernel\n32_GetProcessHeap ; DATA XREF: UPX0:004011AA↑r\nUPX1:0040A014 RtlEnterCriticalSection dd offset ntdll_RtlEnterCriticalSection\nUPX1:0040A014                                         ; DATA XREF: sub_401564+34↑r\nUPX1:0040A014                                         ; sub_4015A0+27↑r ...\n```", "```\nstatic createImportLabel() {\n   auto n = Name(EAX);\n   auto i = strstr(n, \"_\");\n   while (i != −1) {\n      n = n[i+1:];\n      i = strstr(n, \"_\");\n   }\n   MakeUnkn(EBX,DOUNK_EXPAND);\n   MakeDword(EBX);\n   if (MakeNameEx(EBX,n,SN_NOWARN) == 0) {\n      MakeNameEx(EBX,n + \"_\",SN_NOWARN);\n   }\n   return 0;\n}\n```", "```\nstatic main() {\n   AddBpt(ScreenEA());\n   SetBptCnd(ScreenEA(), \"createImportLabel()\");\n}\n```", "```\nUPX0:00403C5B call    ds:RtlFreeHeap\nUPX0:00403C61 test    eax, eax\nUPX0:00403C63 jnz     short loc_403C7B\nUPX0:00403C65 call    sub_40230F\nUPX0:00403C6A mov     esi, eax\nUPX0:00403C6C call    ds:RtlGetLastWin32Error\n```", "```\nauto n;\n   for (n = 0; n < GetEntryPointQty(); n++) {\n      auto ord = GetEntryOrdinal(n);\n      if (GetEntryName(ord) == \"TlsCallback_0\") {\n         AddBpt(GetEntryPoint(ord));\n         break;\n      }\n   }\n   RunTo(BeginEA());\n   GetDebuggerEvent(WFNE_SUSP, −1);\n```", "```\nauto seg;\n   auto peb = 0;\n   auto tid = GetCurrentThreadId();\n   auto tib = sprintf(\"TIB[%08X]\", tid); //IDA naming convention\n   for (seg = FirstSeg(); seg != BADADDR; seg = NextSeg(seg)) {\n      if (SegName(seg) == tib) {\n         peb = Dword(seg + 0x30); //read PEB pointer from TIB\n         break;\n      }\n   }\n   if (peb != 0) {\n      PatchDbgByte(peb + 2, 0);  //Set PEB!IsDebugged to zero\n   }\n```", "```\nglobalFlags = Dword(peb + 0x68) & ~0x70; //read and mask PEB.NtGlobalFlags\nPatchDword(peb + 0x68, globalFlags);     //patch PEB.NtGlobalFlags\n```", "```\nfunc = LocByName(\"ntdll_NtQueryInformationProcess\");\n   AddBpt(func);\n   SetBptCnd(func, \"bpt_NtQueryInformationProcess()\");\n```", "```\nNTSTATUS WINAPI NtQueryInformationProcess(\n      __in       HANDLE ProcessHandle,\n     __in       PROCESSINFOCLASS ProcessInformationClass,\n     __out      PVOID ProcessInformation,\n      __in       ULONG ProcessInformationLength,\n      __out_opt  PULONG ReturnLength\n  );\n```", "```\n#define ProcessDebugPort 7\n  static bpt_NtQueryInformationProcess() {\n     auto p_ret;\n   if (Dword(ESP + 8) == ProcessDebugPort) {//test ProcessInformationClass\n       p_ret = Dword(ESP + 12);\n       if (p_ret) {\n          PatchDword(p_ret, 0);  //fake no debugger present\n        }\n       EIP = Dword(ESP);   //skip function, just return\n       ESP = ESP + 24;     //stdcall so clear args from stack\n       EAX = 0;            //signifies success\n     }\n     return 0;  //don't pause at the breakpoint\n  }\n```", "```\nNTSTATUS NtSetInformationThread(\n   IN HANDLE  ThreadHandle,\n   IN THREADINFOCLASS  ThreadInformationClass,\n   IN PVOID  ThreadInformation,\n   IN ULONG  ThreadInformationLength\n);\n```", "```\nfunc = LocByName(\"ntdll_NtSetInformationThread\");\nAddBpt(func);                  //break at function entry\nSetBptCnd(func, \"bpt_NtSetInformationThread()\");\n```", "```\n#define ThreadHideFromDebugger 0x11\n  static bpt_NtSetInformationThread() {\n    if\n (Dword(ESP + 8) == ThreadHideFromDebugger) {//test ThreadInformationClass\n       EAX = 0;        //STATUS_SUCCESS\n       EIP = Dword(ESP); //just return\n       ESP = ESP + 20;   //simulate stdcall\n     }\n     return 0;\n  }\n```", "```\nvoid WINAPI OutputDebugStringA(\n   __in_opt  LPCTSTR lpOutputString\n);\n```", "```\nfunc = LocByName(\"kernel32_OutputDebugStringA\");\n  AddBpt(func);\n  //fix the return value as expected in non-debugged processes\n  //also adjust EIP and ESP\n SetBptCnd(func, \"!((EAX = 1) && (EIP = Dword(ESP)) && (ESP = ESP + 8))\");\n```", "```\nTIB[000009E0]:7FFDF000 TIB_000009E0_ segment byte public 'DATA' use32\n  TIB[000009E0]:7FFDF000 assume cs:TIB_000009E0_\n  TIB[000009E0]:7FFDF000 ;org 7FFDF000h\n TIB[000009E0]:7FFDF000 dd offset dword_22FFE0\n```", "```\nStack[000009E0]:0022FFE0 \ndword_22FFE0 dd 0FFFFFFFFh     ; DATA XREF: TIB[000009E0]:7FFDF000↓o\nStack[000009E0]:0022FFE4              dd offset loc_7C839AA8\n```", "```\nstatic main() {\n   auto func;\n   RunTo(BeginEA());\n   GetDebuggerEvent(WFNE_SUSP, −1);\n   func = LocByName(\"ntdll_NtContinue\");\n   AddBpt(func);\n   SetBptCnd(func, \"bpt_NtContinue()\");\n}\n```", "```\nstatic bpt_NtContinue() {\n    auto p_ctx = Dword(ESP + 4);            //get CONTEXT pointer argument\n    auto next_eip = Dword(p_ctx + 0xB8);    //retrieve eip from CONTEXT\n    AddBpt(next_eip);                  //set a breakpoint at the new eip\n    SetBptCnd(next_eip, \"Warning(\\\"Exception return hit\\\") || 1\");\n          return 0;           //don't stop\n  }\n```", "```\n// Define additional DLL path\n// (add triple slashes to enable the following lines)\n/// path /home/idauser/xp_dlls/=c:\\winnt\\system32\\\n```", "```\nLPVOID WINAPI VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize,\n                           DWORD flAllocationType, DWORD flProtect);\n```", "```\nVirtualAlloc(NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n```", "```\nVirtualAlloc(0, 4096, 0x3000, 4);\n```", "```\nkernel32.dll:766B2FB6 ; ====== S U B R O U T I N E ========\nkernel32.dll:766B2FB6\nkernel32.dll:766B2FB6 ; Attributes: bp-based frame\nkernel32.dll:766B2FB6\nkernel32.dll:766B2FB6 kernel32_VirtualAlloc proc near\n```", "```\nkernel32.dll:766B2FB6 ; Attributes: bp-based frame\nkernel32.dll:766B2FB6\nkernel32.dll:766B2FB6 ; int __stdcall kernel32_VirtualAlloc(int, int, int, int)\nkernel32.dll:766B2FB6 kernel32_VirtualAlloc proc near\n```", "```\nIDC>Message(\"%x\\n\", kernel32_VirtualAlloc(0, 4096, 0x3000, 4));\n3c0000\n```", "```\nPython>Message(\"%x\\n\" % Appcall.kernel32_VirtualAlloc(0, 4096, 0x3000, 4))\n3d0000\n```"]