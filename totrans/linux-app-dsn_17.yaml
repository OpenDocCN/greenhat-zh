- en: '![](../images/333-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**REVIEW OF SNMP**](toc.html#app2)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This appendix is supplied for those who would like additional details or background
    information on SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this appendix, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why SNMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents and managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace, grammar, and protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MIB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIB-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SNMP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMPv1, SNMPv2, and SNMPv3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining new types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of an MIB file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Why SNMP?**](toc.html#app2.1)'
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1970s, computers and their I/O devices were large enough to need
    air-conditioned rooms of their own. Most large companies performed their computing
    tasks on stand-alone systems. It wasn’t hard to tell when something went wrong—an
    error would print on the system console, and the front panel lights would stop
    blinking.
  prefs: []
  type: TYPE_NORMAL
- en: Today, even small technology companies have a server room with racks of computers
    and network appliances from multiple vendors, including switches, routers, print
    servers, webservers, RAID servers, and so forth. Network printers are distributed
    at convenient locations around the site, and each desk has a desktop or laptop
    computer. In fact, high-tech firms typically have more computers than employees.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike those large computers of yore, the failure of any single component in
    this network of devices is not so easy to detect. IT managers need some form of
    automation to help them manage all these devices.
  prefs: []
  type: TYPE_NORMAL
- en: The automation may be as simple as a roll-your-own script that performs periodic
    ping sweeps, but larger networks are likely to rely on a Network Management System
    (NMS) that uses SNMP, such as Hewlett Packard’s OpenView. Such a system can tell
    much more than when a device breaks down. It can record performance statistics,
    keep a restart history, and maintain a log of notifications sent from the devices
    themselves about impending problems. Devices may report excessive packet drops
    or retransmissions; connectivity failures; a fan running slowly or a CPU running
    too hot; excessive CPU, memory, or disk utilization; as well as system restarts.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Agents and Managers**](toc.html#app2.2)'
  prefs: []
  type: TYPE_NORMAL
- en: The managed devices (routers, switches, web hosts, desktop computers, network
    printers, and so on) each run a server process (daemon) called an SNMP agent.
    This *agent* listens on a particular UDP port (usually, but not always, port 161)
    for read (GET) and write (SET) commands. It’s the agent’s responsibility to fetch
    the requested data and return it. This agent, as well as other monitoring software
    on the device, may also send spontaneous notifications called *traps* or *informs*
    to one or more configured target systems.
  prefs: []
  type: TYPE_NORMAL
- en: Management applications (*managers*) poll the agents for information. They may
    keep historical information, generate reports, or create graphical maps of the
    devices in your network. Some management applications are just simple command-line
    tools (like the snmpwalk, snmpget, and snmpset commands supplied with Net-SNMP).
  prefs: []
  type: TYPE_NORMAL
- en: '[**Namespace, Grammar, and Protocol**](toc.html#app2.3)'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP stands for Simple Network Management Protocol, but it is actually more
    than just a protocol—it’s a way of naming data, a grammar for describing data,
    and a protocol for exchanging data over a network. These components are called
    the *MIB* (the naming scheme), *SMI* (the grammar) and the *SNMP protocol*. The
    RFCs that describe SNMP include a common set of information useful in managing
    networked devices. This is called called *MIB-2* (it took two tries to get it
    right). We’ll be discussing more about MIB-2 later.
  prefs: []
  type: TYPE_NORMAL
- en: '[**The MIB**](toc.html#app2.4)'
  prefs: []
  type: TYPE_NORMAL
- en: MIB stands for *Management Information Base.* That’s a mouthful, but you can
    just think of it as a hierarchical naming scheme for a virtual database. This
    is a “virtual” database because the data may not exist anywhere in storage until
    the agent receives a request to read the data. When asked for an object (think
    of this as a field in a record in the database) the agent retrieves the information
    and returns it in a process that may involve getting multiple pieces of information
    from the managed system and computing the value to be returned. (You might think
    of this as a just-in-time database.) The very act of requesting a piece of information
    may trigger the creation of the value.
  prefs: []
  type: TYPE_NORMAL
- en: Although there is one universal addressing scheme, we break it down into subdivisions,
    which we also call MIBs. Normally, when people use the word *MIB,* they are referring
    not to the overall namespace, but to one of these subdivisions. MIB-2 is one of
    them, and many others are defined by different groups for different purposes.
    Some are produced by standards groups, while others are defined by private companies
    to describe proprietary data furnished by their networked products. (In Chapter
    14 we describe how you can define a private MIB for your own appliance and find
    a place for it in the namespace.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**The OID**](toc.html#app2.5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every object in every MIB has an object identifier (OID). An *OID* is a unique
    name consisting of a sequence of decimal digits separated by periods, or dots,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .1.3.6.1.2.1.1.2.0
  prefs: []
  type: TYPE_NORMAL
- en: This name represents the object’s location in the namespace. The first dot represents
    the root of the tree, and each number represents a *node* (the base of a branch)
    in the tree. Everything nameable in SNMP is located somewhere in this OID tree,
    and every name (OID) contains the entire path to that object from the root of
    the tree.
  prefs: []
  type: TYPE_NORMAL
- en: This may look strange at first, but it works in the same way as the Unix filesystem,
    with which you should be familiar. Paths to files start at root, indicated by
    an initial slash (/), proceed through a number of named nodes *(directories)*
    separated by more slashes, and end with the name of the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the example of a file on a Unix filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/local/bin/myprog
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use a dot to separate directories instead of a slash, the path to the
    file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .usr.local.bin.myprog
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the following table defined a map between the directory names and a
    set of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/336-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use the numbers in place of the names, the path would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .1.3.6.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure B-1 shows part of the OID tree (or namespace). Note that some nodes
    in the tree are named for organizations: ISO is the International Standards Organization,
    and DOD is the US Department of Defense. (The DOD is in this structure because
    it was instrumental in the creation of DARPANet, which originally consisted of
    a four-computer network. By 1972, DARPANet had grown to a network of 37 computers
    and was renamed ARPANet, which led to today’s Internet. End of history lesson.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/336-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure B-1: The OID tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Assigned Numbers Authority (IANA) is responsible for assigning
    numbers to companies and organizations under the *enterprises node*, giving the
    company or organization the authority to administer the OIDs in their own subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the tree that we’re most interested in is under .1.3.6.1 (.iso.org
    .dod.internet). Beneath this node are the mgmt.mib-2 (.1.3.6.1.2.1) subtree and
    the private.enterprises (.1.3.6.1.4.1) subtree. MIB-2 is the common set of objects
    that we mentioned earlier; it is supported by all networked devices that are manageable
    by SNMP. The enterprises OID is where organizations register their private MIBs.
    (For more on this topic, see Chapter 14.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**MIB-2**](toc.html#app2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: MIB-2, defined in RFC 1213,¹ describes a core set of information that is helpful
    for managing networked devices. MIB-2 is organized into the ten groups shown below.
    Not all groups are supported on all networked devices, but you can generally expect
    to find most of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**System**'
  prefs: []
  type: TYPE_NORMAL
- en: This group contains objects such as sysDescr (a printable description of the
    operating system, hardware, networking software, etc.), sysContact (typically
    the email address of the person administering this system), sysLocation (a printable
    description of where the system is located), and sysObjectID (an OID that can
    be used to determine the type of device).
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: This group is a table describing the network interfaces available on the system.
    The interfaces table contains information on the speed of each interface and the
    activity on the interface (octets in and out). By polling the in and out octets
    periodically, you can tell what percent of the bandwidth available in the interface
    is being used. This can help you monitor the capacity of routers in a network.
  prefs: []
  type: TYPE_NORMAL
- en: '**AT**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the Address Translation group. MIB-2 deprecates this group and includes
    it only for compatibility with devices implementing MIB-1\. You should ignore
    this group unless you have a particular interest in SNMP history.
  prefs: []
  type: TYPE_NORMAL
- en: '**IP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group includes information related to the IP (network) layer, including
    ipAddrTable (IP Address Table), which describes the IP address of the interfaces
    available on the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**ICMP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group includes various Internet Control Message Protocol (ICMP) statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group includes various TCP layer statistics, including the tcpConnTable
    (TCP Connection Table) describing the current TCP connections between this and
    other systems in the network. This table is often used in network discovery. Once
    you have the address of this system, you can find out the addresses of other systems
    that are in contact with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group includes various User Datagram Protocol (UDP) datagram statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '**EGP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group contains Exterior Gateway Protocol (EGP) statistics for those systems
    supporting the EGP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmission**'
  prefs: []
  type: TYPE_NORMAL
- en: This group contains information related to managing transmission media.
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP**'
  prefs: []
  type: TYPE_NORMAL
- en: This group includes various statistics related to the SNMP protocol, itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[**The SMI**](toc.html#app2.7)'
  prefs: []
  type: TYPE_NORMAL
- en: MIBs are described using a grammar defined by the Structure of Management Information
    (SMI), which is a subset of Abstract Syntax Notation One (ASN.1). ASN.1 was created
    to allow description of data in a way independent of machine architecture (for
    example, no assumptions about endian-ness or word size). The SNMP SMI adopted
    a subset of the object types definable under ASN.1 and then simplified the notation.
  prefs: []
  type: TYPE_NORMAL
- en: All you really need to know about all this is how to read and write the notation
    used to describe a MIB. This is best accomplished with minimal notation definitions
    illustrated by examples. You can create a new MIB largely by cutting and pasting
    from other MIBs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ve attempted to keep our discussion of MIBs as simple as possible. For
    more in-depth coverage, pick up a copy of* Understanding SNMP MIBs *by David Perkins
    and Evan McGinnis (Prentice Hall, 1996).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an object definition using the grammar described in the
    SMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/338-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ::= reads *is defined as*, and {mib-2 1} means that if mib-2 is .1.3.6.1.2.1,
    then system is .1.3.6.1.2.1.1\. Therefore, sysDescr is .1.3.6.1.2.1.1.1\. Each
    definition describes a single step in the OID tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some object identifiers simply describe nodes in the tree structure
    and others describe objects you may actually read (leaf nodes). These are like
    directories and files in a filesystem. In fact, when you try to read sysDescr,
    you must ask for .1.3.6.1.4.1.1.1.0\. This is where we diverge a bit from the
    filesystem analogy. The ending zero says you are retrieving an *instance* of the
    object. Scalar object instances (scalars are just stand-alone objects not in a
    table) are always .0 (dot zero). In object-oriented terminology, it’s like .1.3.6.1.2.1.1.1
    is the *class*, while .0 describes an object that is an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: This may make more sense if you think of objects as fields in a table structure
    that must be retrieved by a row index. The table row number would replace the
    zero. For example, ifDescr is a field in a table whose rows each describe information
    about a particular network interface on the machine. Another node under mib-2,
    interfaces, is described as
  prefs: []
  type: TYPE_NORMAL
- en: interfaces OBJECT IDENTIFIER ::= { mib-2 2 }
  prefs: []
  type: TYPE_NORMAL
- en: 'If you retrieved the ifDescr field for the first two interfaces on a system,
    you might get this:'
  prefs: []
  type: TYPE_NORMAL
- en: interfaces.ifTable.ifEntry.ifDescr.1 = lo
  prefs: []
  type: TYPE_NORMAL
- en: interfaces.ifTable.ifEntry.ifDescr.2 = eth0
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with what you might retrieve when asking for sysDescr:'
  prefs: []
  type: TYPE_NORMAL
- en: 'system.sysDescr.0 = Linux localhost.localdomain 2.4.18-27.8.0 #1 Fri Mar 14
    06:45:49 EST 2003 i686'
  prefs: []
  type: TYPE_NORMAL
- en: The .1 and .2 at the end of the ifDescr OIDs indicate the table row from which
    they were retrieved. In SNMP table rows are numbered from 1, which leaves 0 to
    indicate a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: The SMI description of a MIB is normally distributed in a *MIB file.* This is
    a text file containing the unambiguous description of a portion of the universal
    MIB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes descriptions of individual tables are placed in separate files. Other
    files just contain common objects or definitions, such as textual conventions,
    used by a set of other MIB files. Generally, a private MIB for a particular product
    is described in a single file or a small set of files, importing types and conventions
    as needed from other files, much like the use of the #include statement in the
    C language.'
  prefs: []
  type: TYPE_NORMAL
- en: The MIB file is used as a formal definition of the MIB for humans, but it is
    also used programmatically to interpret SNMP responses for display to human beings.
    (We’ll see this below.) MIB files, therefore, must be as syntactically correct
    as any computer program. There are MIB compilers and checkers (the equivalent
    of the lint program for C) to help verify the correctness of a MIB file. (We discuss
    this further in Chapter 14, where we cover the creation and validation of our
    own MIB.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**The SNMP Protocol**](toc.html#app2.8)'
  prefs: []
  type: TYPE_NORMAL
- en: Although worthy of a chapter all its own, we can understand most of what we
    need to know about the SNMP protocol from the Protocol Data Units (PDUs) it defines
    and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: '[***The Basic Commands: GET, SET, GETNEXT***](toc.html#app2.9)'
  prefs: []
  type: TYPE_NORMAL
- en: The SNMP protocol is used to exchange information between managed systems and
    the applications written to manage them. Managed systems host a daemon called
    an *agent,* usually named snmpd, which provides the ability to read information
    from or write information to one or more MIBs. The GET, SET, and GETNEXT PDUs
    are used to read from, write to, and walk a MIB.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Walking a MIB with GETNEXT***](toc.html#app2.10)'
  prefs: []
  type: TYPE_NORMAL
- en: GETNEXT allows you to name one object and ask the agent to return the OID and
    value of the next object in the MIB tree. *Walking a MIB* means starting at some
    point in the OID tree and traversing the entire subtree below it with repeated
    use of the GETNEXT command. The walk is finished when the OID returned is not
    within the subtree defined by the first OID. An application can find out which
    MIBs are supported on a managed system by walking the entire MIB tree in this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Traps and Informs***](toc.html#app2.11)'
  prefs: []
  type: TYPE_NORMAL
- en: Managed systems can also spontaneously send information to a configured target-management
    node, a process called sending an SNMP *trap* or *inform.* A trap is sent toward
    a target system, but the sender never knows if it got there. An inform is an improvement
    over a trap because it expects a reply from the receiver; it can be retried if
    the reply is not received in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Command-Line Tools: Examples***](toc.html#app2.12)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some examples of using command-line tools that use the SNMP PDUs
    we have just discussed to achieve their function. These commands are supplied
    as part of the Net-SNMP package ([http://net-snmp.sourceforge.net](http://net-snmp.sourceforge.net/)),
    which we use throughout the SNMP chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the sysDescr field shown in the previous section, you might issue
    the command
  prefs: []
  type: TYPE_NORMAL
- en: snmpget -c public 10.1.1.21 .1.3.6.1.2.1.1.1.0
  prefs: []
  type: TYPE_NORMAL
- en: This asks for the instance of the sysDescr object from the system whose IP address
    is 10.1.1.21, using the community name public (think of this as a password). As
    you can guess from its name, the snmpget command generates an SNMP GET PDU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s walk a subtree. The snmpwalk command uses a series of GETNEXT PDUs.
    If you issue the following command to retrieve the interface table from a system:'
  prefs: []
  type: TYPE_NORMAL
- en: snmpwalk -c public 10.1.1.21 .1.3.6.1.2.1.2
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what you might get back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/341-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This output is a little awkward to read because it is a depth-first walk; that
    is, it walks down each column before going back to row one and starting down the
    next column. This is a result of the lexical ordering of the OIDs. For example,
    since ifDescr is ifEntry.1 and ifType is ifEntry.2, you see all ifDescr fields
    before any ifType fields.
  prefs: []
  type: TYPE_NORMAL
- en: '**KNOWING AN APPLIANCE BY ITS MIBS**'
  prefs: []
  type: TYPE_NORMAL
- en: Walking can often identify the type of a machine by the MIBs it supports. For
    example, one of the authors was once assigned an IP address for a new workstation
    and found that someone else was already using this address. Since he had been
    assigned this address through proper channels, he assumed someone else was invalidly
    using it. He turned off his system and used another system to read system.sysContact
    from the offending system; this should have been set to the contact information
    for the administrator for that node, but it was not. He then tried walking all
    the MIBs supported by that system and found that it supported the printer MIB.
    Hmm . . . As it turned out, he had been incorrectly given the IP address of the
    department’s printer!
  prefs: []
  type: TYPE_NORMAL
- en: '[**SNMPv1, SNMPv2, and SNMPv3**](toc.html#app2.13)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main variants of SNMP. The original, SNMPv1 (version 1), is
    the simplest, but it has some drawbacks that newer versions seek to remedy. Its
    shortcomings include:'
  prefs: []
  type: TYPE_NORMAL
- en: No support for integers larger than 32 bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No means to ask for bulk data (each object must be asked for by name).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No mechanism to ensure that a trap reaches its destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security/authentication is accomplished using community names, which are like
    passwords, but are transmitted on the network in the clear (that is, unencrypted).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMPv2c (community-based SNMPv2) addressed the first three of these problems,
    but reaching an agreement on a new security mechanism proved more difficult, so
    SNMPv2c still relies on community names for authentication. SNMPv2c includes 64-bit
    integers, the GETBULK command, and introduces informs, which are confirmed traps.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3 replaces the community-name authentication mechanism with more secure
    authentication and encryption, but in-depth discussion of it is beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*SNMPv1 has been moved to “historical” status, but many applications used by
    IT organizations still use it. Your network appliance may need to speak SNMPv1
    for compatibility with these older applications. Expect, however, that in the
    not-too-distant future, some of your customers will want to disable the older,
    less secure versions of SNMP.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[**SNMP Data Types**](toc.html#app2.14)'
  prefs: []
  type: TYPE_NORMAL
- en: 'SNMP data types are a subset of ASN.1 types. A complete description of the
    SNMP data types and their uses is beyond the scope of this brief introduction,
    but this section is a summary of the major types. SNMP defines three kinds of
    data types: primitive, defined, and constructor. We won’t dwell on the differences
    here, other than to say primitives are the basic types, defined types have special
    meanings but have underlying primitive types, and constructor types are the tables
    we will discuss below. Although it may look a little strange, we’ll try to stay
    consistent here with SNMP’s standard of using all capital letters in the names
    of primitive types, but just initial capitals for the defined types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTEGER**'
  prefs: []
  type: TYPE_NORMAL
- en: An INTEGER may be positive or negative. Its values may be enumerated, a range
    of legal values specified in the form of (lowValue..highValue), or a fixed size
    (e.g., Size(4)). In SNMPv2 INTEGER becomes Integer32, explicitly indicating the
    size as 32 bits. SNMPv2 also adds an Unsigned32 type for a 32-bit integer of only
    positive values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gauge**'
  prefs: []
  type: TYPE_NORMAL
- en: Gauges are integers that take only non-negative values and whose values rise
    or fall within a specified range (e.g., between 0 and 100 percent, or between
    0 and some maximum capacity). SNMPv2 redefines this as Gauge32.
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter**'
  prefs: []
  type: TYPE_NORMAL
- en: Like Gauge, Counter is an integer that takes only non-negative values. Unlike
    Gauge, the value of a counter only increases until it wraps back to zero at its
    maximum limit. SNMPv2 replaced Counter with Counter32 and Counter64.
  prefs: []
  type: TYPE_NORMAL
- en: '**TimeTicks**'
  prefs: []
  type: TYPE_NORMAL
- en: TimeTicks are integers describing time in 1/100ths of a second. They are generally
    used to describe the time since some significant event or starting point, such
    as system boot or last configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: '**OCTET STRING**'
  prefs: []
  type: TYPE_NORMAL
- en: An OCTET STRING is a string of eight-bit bytes. It is not necessarily a null-terminated
    C string; each octet can contain any value (0..255) at any position (i.e., there
    may be nulls in the middle). SNMPv2 added the restriction that an OCTET STRING
    may be no longer than 65,535 (i.e., its length must be expressible in 16 bits).
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJECT IDENTIFIER**'
  prefs: []
  type: TYPE_NORMAL
- en: This is used to contain SNMP OID values. SNMPv2 added the restriction that an
    OBJECT IDENTIFIER may contain no more than 128 components, each of which must
    be expressible in a maximum of 32 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '**IpAddress**'
  prefs: []
  type: TYPE_NORMAL
- en: The IpAddress string is an octet string of length four. (Note that this allows
    expression only of Ipv4 addresses.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Opaque**'
  prefs: []
  type: TYPE_NORMAL
- en: This type is much like OCTET STRING in that it is a string of octets with similar
    restrictions. Opaque was defined to allow extensions of the SMI. Defining new
    types based on the Opaque type is strongly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: '**BITS**'
  prefs: []
  type: TYPE_NORMAL
- en: BITS was added in SNMPv2 to provide a way to express bit fields of labeled bits
    (i.e., where each bit has a separate meaning).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Types that have been removed from the later revisions of SNMP are not shown
    in the above list.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[**SNMP Tables**](toc.html#app2.15)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the simple types described above, tables may be described using
    SEQUENCE and SEQUENCE OF. A table in a MIB is described as a SEQUENCE OF a type
    that describes the entry. The table entry is then described as a SEQUENCE containing
    the individual fields of the entry. The entry type describes the columns that
    constitute each row in the table, while the table itself is described as an array
    of these entry structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s the definition of the interfaces table from MIB-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/344-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/345-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the use of both if Entry and IfEntry, one initial-capped and the other
    not. All object names start with lowercase; for example, ifTable and if Entry.
    Because If Entry is initial-capped, we know that it describes a type, rather than
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IfEntry type is like a struct in C; it describes the layout of each table
    row. The lowercase ifEntry is a node in the OID tree beneath which the column
    objects will be defined. Thus, the description of a particular interface will
    have an OID like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ifTable.ifEntry.ifDescr.*x*
  prefs: []
  type: TYPE_NORMAL
- en: where *x* is the row index.
  prefs: []
  type: TYPE_NORMAL
- en: Following the definition of the entry type will be the definitions of each of
    the objects that make up the entry sequence. You will see this format again and
    again in MIB definitions; much MIB information is organized into tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Defining New Types**](toc.html#app2.16)'
  prefs: []
  type: TYPE_NORMAL
- en: Although the data types defined in the SMI are sufficient, it is sometimes convenient
    to be a bit more specific. For example, you may want to restrict the possible
    values in an OCTET STRING or the range covered by an Integer32; if your MIB uses
    the same restricted values repeatedly, it will become tedious to describe these
    same restrictions repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 1903 describes the *textual convention,* a macro that allows you to bind
    your clarifications together into a new type. The following textual convention
    is taken from the file SNMPv2-TC.txt distributed with Net-SNMP (version 5.0.8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/345-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/346-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This describes a type called DisplayString that can take up to 255 octets whose
    values are restricted to those that correspond to displayable characters. The
    DISPLAY-HINT clause shows how a DisplayString may appear. *255a* means it can
    take the form of up to 255 ASCII characters. RFC 1903 describes the complete syntax
    for the display hint.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Structure of a MIB File**](toc.html#app2.17)'
  prefs: []
  type: TYPE_NORMAL
- en: When you read a MIB file, you will notice that it is named and defined between
    BEGIN and END statements. It will describe what it includes from other MIB files,
    and it will name the module being defined in this MIB file, the contact information
    for the person responsible for the MIB, and the revision history. Next you will
    see the definition of the objects in the MIB.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the IF-MIB, again distributed with the Net-SNMP package, you
    can see all of these parts. The MIB is enclosed within these lines
  prefs: []
  type: TYPE_NORMAL
- en: IF-MIB DEFINITIONS ::= BEGIN
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: The first section states the external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/346-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/347-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then comes the definition of the module.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/347-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This describes the module ifMib, which takes the location { mib-2 31 } in the
    overall MIB address space. The organization and contact information are clearly
    identifiable, followed by the descriptions of the various revisions of this MIB
    in reverse chronological order. The time and date look pretty cryptic, but they
    are just a concatenation of year, month, day, hour, and minute in GMT (indicated
    by the *Z* for Zulu Time). Therefore, the most recent revision (200006140000Z)
    was made on June 14, 2000.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll see the definition of the actual structure of the MIB objects,
    along with any textual conventions new to this MIB.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Summary**](toc.html#app2.18)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has been a whirlwind tour of SNMP. We’ve covered the basic parts of SNMP:
    the protocol, the grammar, and the first group of managed objects. You should
    now understand the acronyms *SMI*, *MIB*, and *OID*, and the terms *object* and
    *trap*. You should also be familiar with the term MIB-2 and have an idea of what
    it contains. We have discussed the various data types, both scalars and tables.
    At this point, you should be able to take an unfamiliar MIB and read through it,
    understanding its basic structure and what it is trying to describe. We have also
    touched on a couple of the command-line utilities you may find useful to probe
    an SNMP-enabled device: snmpwalk and snmpget.'
  prefs: []
  type: TYPE_NORMAL
- en: With a little cut and paste and some judicious modifications, you may now be
    able to develop a simple MIB.
  prefs: []
  type: TYPE_NORMAL
- en: __________________
  prefs: []
  type: TYPE_NORMAL
- en: '¹ Network Working Group, Request For Comments: 1213\. *Management Information
    Base for Network Management of TCP/IP-based internets: MIB-II*. K. McCloghrie
    and M. Rose, March 1991.'
  prefs: []
  type: TYPE_NORMAL
