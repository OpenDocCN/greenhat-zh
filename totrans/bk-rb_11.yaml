- en: Chapter 11. Symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many newcomers to Ruby are confused by symbols. A symbol is an identifier whose
    first character is a colon (`:`), so `:this` is a symbol and so is `:that`. Symbols
    are, in fact, not at all complicated—and, in certain circumstances, they may be
    extremely useful, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first be clear about what a symbol is *not*: It is not a string, it is
    not a constant, and it is not a variable. A symbol is, quite simply, an identifier
    with no intrinsic meaning other than its own name. Whereas you might assign a
    value to a variable like this . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'you would *not* assign a value to a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value of a symbol is itself. So, the value of a symbol called `:name`is
    `:name`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more technical account of what a symbol is, refer to [Digging Deeper](ch11s03.html#digging_deeper-id10
    "Digging Deeper") in [Digging Deeper](ch11s03.html#digging_deeper-id10 "Digging
    Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'You have, of course, used symbols before. In [Chapter 2](ch02.html "Chapter 2. Class
    Hierarchies, Attributes, and Class Variables"), for instance, you created attribute
    readers and writers by passing symbols to the `attr_reader` and `attr_writer`
    methods, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may recall that the previous code causes Ruby to create a `@description`
    instance variable plus a pair of getter (reader) and setter (writer) methods called
    `description`. Ruby takes the value of a symbol literally. The `attr_reader` and
    `attr_writer` methods create, from that name, variables and methods with matching
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols and Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common misconception that a symbol is a type of string. After all, isn’t
    the symbol `:hello` pretty similar to the string `"hello"`? In fact, symbols are
    quite unlike strings. For one thing, each string is different—so, as far as Ruby
    is concerned, `"hello"`, `"hello"`, and `"hello"` are three separate objects with
    three separate `object_id`s.
  prefs: []
  type: TYPE_NORMAL
- en: '*symbol_ids.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But a symbol is unique, so `:hello`, `:hello`, and `:hello` all refer to the
    same object with the same `object_id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this respect, a symbol has more in common with an integer than with a string.
    Each occurrence of a given integer value, you may recall, refers to the same object,
    so `10`, `10`, and `10` may be considered to be the same object, and they have
    the same `object_id`. Remember that the actual IDs assigned to objects will change
    each time you run a program. The number itself is not significant. The important
    thing to note is that each separate object always has a unique ID, so when an
    ID is repeated, it indicates repeated references to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '*ints_and_symbols.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also test for equality using the `equal?` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbols_strings.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Being unique, a symbol provides an unambiguous identifier. You can pass symbols
    as arguments to methods, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A method might contain code to test the value of the incoming argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbols_1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols can also be used in `case` statements where they provide both the readability
    of strings and the uniqueness of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The scope in which a symbol is declared does not affect its uniqueness. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbol_ref.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the variables `$f1`, `$f2`, and `$f3` are assigned the symbol `:Fred`
    in three different scopes: module `One`, module `Two`, and the “main” scope. Variables
    starting with `$` are global, so once created, they can be referenced anywhere.
    I’ll have more to say on modules in [Chapter 12](ch12.html "Chapter 12. Modules
    and Mixins"). For now, just think of them as “namespaces” that define different
    scopes. And yet each variable refers to the same symbol, `:Fred`, and has the
    same `object_id`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even so, the “meaning” of the symbol changes according to its scope. In module
    `One`, `:Fred` refers to the class `Fred`; in module `Two`, it refers to the constant
    `Fred = 1`; and in the main scope, it refers to the method `Fred`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rewritten version of the previous program demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbol_ref2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'First I access the `evalFred` method inside the module named `One` using two
    colons (`::`), which is the Ruby “scope resolution operator.” I then pass `$f1`
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, `Fred` is the name of a class defined inside module `One`,
    so when the `:Fred` symbol is evaluated, the module and class names are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next I pass `$f2` to the `evalFred` method of module `Two`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, `Fred` is the name of a constant that is assigned the integer
    1, so that is what is displayed: `1`. And finally, I call a special method called
    simply `method`. This is a method of Object. It tries to find a method with the
    same name as the symbol passed to it as an argument and, if found, returns that
    method as an object that can then be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Fred` method exists in the main scope, and when called, its output is
    this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, since the variables `$f1`, `$f2`, and `$f3` reference the same symbol,
    it doesn’t matter which variable you use at any given point. Any variable to which
    a symbol is assigned, or, indeed, the symbol itself, will produce the same results.
    The following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Symbols and Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the relationship between a symbol and an identifier such as a
    variable name, take a look at the *symbols_2.rb* program. It begins by assigning
    the value 1 to a local variable, `x`. It then assigns the symbol `:x` to a local
    variable, `xsymbol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbols_2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, there is no obvious connection between the variable `x` and
    the symbol `:x`. I have declared a method that simply takes some incoming argument
    and inspects and displays it using the `p` method. I can call this method with
    the variable and the symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the data that the method prints as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the value of the `x` variable is 1, since that’s the value
    assigned to it and the value of `:x` is `:x`. But the interesting question that
    arises is this: If the value of `:x` is `:x` and this is also the symbolic name
    of the variable `x`, would it be possible to use the symbol `:x` to find the value
    of the variable `x`? Confused? I hope the next line of code will make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `id2name` is a method of the Symbol class. It returns the name or string
    corresponding to the symbol (the `to_s` method would perform the same function);
    the end result is that, when given the symbol `:x` as an argument, `id2name` returns
    the string “x.” Ruby’s `eval` method (which is defined in the Kernel class) is
    able to evaluate expressions within strings. In the present case, that means it
    finds the string “x” and tries to evaluate it as though it were executable code.
    It finds that `x` is the name of a variable and that the value of `x` is 1\. So,
    the value 1 is passed to `amethod`. You can verify this by running *symbols2.rb*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Evaluating data as code is explained in more detail in [Chapter 20](ch20.html
    "Chapter 20. Dynamic Programming").
  prefs: []
  type: TYPE_NORMAL
- en: Things can get even trickier. Remember that the variable `xsymbol` has been
    assigned the symbol `:x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that if you eval `:xsymbol`, you can obtain the name assigned to
    it—that is, the symbol `:x`. Having obtained `:x`, you can go on to evaluate this
    also, giving the value of `x`, namely, 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve seen, when used to create attribute accessors, symbols can refer
    to method names. You can make use of this by passing a method name as a symbol
    to the `method` method and then calling the specified method using the `call`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `call` method lets you pass arguments, so, just for the heck of it, you
    could pass an argument by evaluating a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If this seems complicated, take a look at a simpler example in *symbols_3.rb*.
    This begins with this assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*symbols_3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here `method(:mymethod)` looks for a method with the name specified by the symbol
    passed as an argument (`:mymethod`), and if one is found, it returns the Method
    object with the corresponding name. In my code I have a method called `mymethod`,
    and this is now assigned to the variable `this_is_a_method_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this program, you will see that the first line of output prints
    the value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the variable `this_is_a_method_name` has been assigned the
    method, `mymethod`, which is bound to the Object class (as are all methods that
    are entered as “freestanding” functions). To double-check that the variable really
    is an instance of the Method class, the next line of code prints out its class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so if it’s really and truly a method, then you should be able to call
    it, shouldn’t you? To do that, you need to use the `call` method. That is what
    the last line of code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Why Use Symbols?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some methods in the Ruby class library specify symbols as arguments. Naturally,
    if you need to call those methods, you are obliged to pass symbols to them. Other
    than in those cases, however, there is no absolute requirement to use symbols
    in your own programming. For many Ruby programmers, the “conventional” data types
    such as strings and integers are perfectly sufficient. However, many Ruby programmers
    do like to use symbols as the keys into hashes. When you look at the Rails framework
    in [Chapter 19](ch19.html "Chapter 19. Ruby on Rails"), for example, you will
    see examples similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols do have a special place in “dynamic” programming, however. For example,
    a Ruby program is able to create a new method at runtime by calling, within the
    scope of a certain class, `define_method` with a symbol representing the method
    to be defined and a block representing the code of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_method.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After the previous code executes, the Array class will have gained a method
    named `aNewMethod`. You can verify this by calling `method_defined?` with a symbol
    representing the method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, you can call the method itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove an existing method at runtime in a similar way by calling `remove_method`
    inside a class with a symbol providing the name of the method to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic programming is invaluable in applications that need to modify the behavior
    of the Ruby program while that program is still executing. Dynamic programming
    is widely used in the Rails framework, for example, and it is discussed in depth
    in the final chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are fundamental to Ruby. Here you will learn why that is so and how
    you can display all the symbols available.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Symbol?
  prefs: []
  type: TYPE_NORMAL
- en: Previously, I said that a symbol is an identifier whose value is itself. That
    describes, in a broad sense, the way that symbols behave from the point of view
    of the Ruby programmer. But it doesn’t tell you what symbols are *literally* from
    the point of view of the Ruby interpreter. A symbol is, in fact, a pointer into
    the symbol table. The symbol table is Ruby’s internal list of known identifiers—such
    as variable and method names.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to take a peek deep inside Ruby, you can display all the symbols
    that Ruby knows about like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*allsymbols.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will shows thousands of symbols including method names such as `:to_s`
    and `:reverse`, global variables such as `:$/` and `:$DEBUG`, and class names
    such as `:Array` and `:Symbol`. You may restrict the number of symbols displayed
    using array indexes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby 1.8, you can’t sort symbols since symbols are not considered to be
    inherently sequential. In Ruby 1.9, sorting is possible, and the symbol characters
    are sorted as though they were strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to display a sorted list of symbols in a way that avoids incompatibility
    problems related to Ruby versions is to convert the symbols to strings and sort
    those. In the following code, I pass all the symbols known to Ruby into a block,
    convert each symbol to a string, and collect the strings into a new array that
    is assigned to the `str_array` variable. Now I can sort this array and display
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
