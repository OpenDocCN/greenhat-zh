- en: Chapter 3. Syntax in Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。函数中的语法
- en: In this chapter, we’ll take a look at the syntax that enables you to write Haskell
    functions in a readable and sensible manner. We’ll look at how to quickly deconstruct
    values, avoid big `if else` chains, and store the results of intermediate computations
    so that you can reuse them multiple times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使您能够以可读和合理的方式编写 Haskell 函数的语法。我们将了解如何快速分解值、避免大的 `if else` 链，并将中间计算的结果存储起来，以便您可以多次重用。
- en: Pattern Matching
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '*Pattern matching* is used to specify patterns to which some data should conform
    and to deconstruct the data according to those patterns.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式匹配* 用于指定某些数据应遵守的模式，并根据这些模式分解数据。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802532.png.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802532.png.jpg)'
- en: 'When defining functions in Haskell, you can create separate function bodies
    for different patterns. This leads to simple, readable code. You can pattern match
    on pretty much any data type—numbers, characters, lists, tuples, and so on. For
    example, let’s write a simple function that checks if the number we pass to it
    is a 7:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 Haskell 中的函数时，您可以为不同的模式创建单独的函数体。这导致代码简单、易读。您几乎可以在任何数据类型上执行模式匹配——数字、字符、列表、元组等等。例如，让我们编写一个简单的函数，检查我们传递给它的数字是否是
    7：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you call `lucky`, the patterns will be checked from top to bottom. When
    the passed argument conforms to a specified pattern, the corresponding function
    body will be used. The only way a number can conform to the first pattern here
    is if it is a 7\. In that case, the function body `"LUCKY NUMBER SEVEN!"` is used.
    If it’s not a 7, it falls through to the second pattern, which matches anything
    and binds it to `x`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `lucky` 时，模式将从上到下进行检查。当传递的参数符合指定的模式时，将使用相应的函数体。这里数字符合第一个模式的情况只有它是 7。在这种情况下，将使用函数体
    `"LUCKY NUMBER SEVEN!"`。如果不是 7，它将跌入第二个模式，该模式匹配任何内容并将其绑定到 `x`。
- en: When we use a name that starts with a lowercase letter (like `x`, `y`, or `myNumber`)
    in our pattern instead of an actual value (like `7`), it will act as a catchall
    pattern. That pattern will always match the supplied value, and we will be able
    to refer to that value by the name that we used for the pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模式中使用以小写字母开头的名称（如 `x`、`y` 或 `myNumber`）而不是实际值（如 `7`）时，它将充当一个通配符模式。该模式将始终匹配提供的值，并且我们可以通过我们为模式使用的名称来引用该值。
- en: 'The sample function could have also been easily implemented by using an `if`
    expression. However, what if we wanted to write a function that takes a number
    and prints it out as a word if it’s between 1 and 5; otherwise, it prints `"Not
    between 1 and 5"`? Without pattern matching, we would need to make a pretty convoluted
    `if/then/else` tree. However, pattern matching makes this a simple function to
    write:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 样本函数也可以通过使用 `if` 表达式轻松实现。然而，如果我们想编写一个函数，该函数接受一个数字，如果它在 1 到 5 之间，则将其打印为单词；否则，打印
    `"Not between 1 and 5"`，该怎么办？没有模式匹配，我们需要构建一个相当复杂的 `if/then/else` 树。但是，模式匹配使这个函数变得简单易写：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that if we moved the last pattern (`sayMe x`) to the top, the function
    would always print `"Not between 1 and 5"`, because the numbers wouldn’t have
    a chance to fall through and be checked for any other patterns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们将最后一个模式（`sayMe x`）移到顶部，函数将始终打印 `"Not between 1 and 5"`，因为数字没有机会跌入并检查任何其他模式。
- en: 'Remember the factorial function we implemented in the previous chapter? We
    defined the factorial of a number `n` as `product [1..n]`. We can also define
    a factorial function *recursively*. A function is defined recursively if it calls
    itself inside its own definition. The factorial function is usually defined this
    way in mathematics. We start by saying that the factorial of 0 is 1\. Then we
    state that the factorial of any positive integer is that integer multiplied by
    the factorial of its predecessor. Here’s how that looks translated into Haskell
    terms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章中实现的阶乘函数吗？我们将一个数字 `n` 的阶乘定义为 `product [1..n]`。我们也可以递归地定义阶乘函数。如果一个函数在其定义内部调用自身，则该函数是递归定义的。阶乘函数通常以这种方式在数学中定义。我们首先声明
    0 的阶乘是 1。然后我们声明任何正整数的阶乘是该整数乘以其前驱的阶乘。以下是将其转换为 Haskell 术语的示例：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the first time we’ve defined a function recursively. Recursion is important
    in Haskell, and we’ll take a closer look at it in [Chapter 4](ch04.html "Chapter 4. Hello
    Recursion!").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次递归定义函数。递归在 Haskell 中很重要，我们将在第 4 章（[第 4 章](ch04.html "第 4 章。你好，递归！")）中更详细地探讨它。
- en: 'Pattern matching can also fail. For instance, we can define a function like
    this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配也可能失败。例如，我们可以定义一个函数如下：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function seems to work fine at first. However, if we try to call it with
    an input that it didn’t expect, we get an error:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数看起来一开始似乎工作得很好。然而，如果我们尝试用它没有预料到的输入调用它，我们会得到一个错误：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It complains that we have “non-exhaustive patterns,” and rightfully so. When
    making patterns, we should always include a catchall pattern at the end so our
    program doesn’t crash if we get some unexpected input.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它会抱怨我们有“非穷尽模式”，这是合理的。在创建模式时，我们应该始终在末尾包含一个通配符模式，这样我们的程序在接收到一些意外的输入时就不会崩溃。
- en: Pattern Matching with Tuples
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组模式匹配
- en: 'Pattern matching can also be used on tuples. What if we wanted to write a function
    that takes two vectors in 2D space (represented as pairs) and adds them together?
    (To add two vectors, we add their x components separately and their y components
    separately.) Here’s how we might have done this if we didn’t know about pattern
    matching:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配也可以用于对偶。如果我们想编写一个函数，该函数接受二维空间中的两个向量（表示为对偶）并将它们相加怎么办？（要加两个向量，我们分别将它们的 x 分量和
    y 分量相加。）如果我们不知道模式匹配，我们可能会这样做：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Well, that works, but there’s a better way to do it. Let’s modify the function
    so that it uses pattern matching:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这确实可行，但还有更好的方法来做这件事。让我们修改这个函数，使其使用模式匹配：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is much better. It makes it clear that the parameters are tuples, and
    increases readability by giving names to the tuple components right away. Note
    that this is already a catchall pattern. The type of `addVectors` is the same
    in both cases, so we are guaranteed to get two pairs as parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好。它清楚地表明参数是元组，并且通过立即给元组组件命名来提高可读性。注意，这已经是一个通配符模式。`addVectors`的类型在这两种情况下都是相同的，所以我们保证会得到两个对偶作为参数：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`fst` and `snd` extract the components of pairs. But what about triples? Well,
    there are no provided functions to extract the third component in a triple, but
    we can make our own:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`fst`和`snd`提取对偶的组件。但是关于三元组呢？嗯，没有提供提取三元组第三个组件的函数，但我们可以自己创建一个：'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `_` character means the same thing it does in list comprehensions. We really
    don’t care about that part, so we just use a `_` to represent a generic variable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`字符与列表推导中的含义相同。我们真的不关心那部分，所以我们只使用一个`_`来表示一个通用变量。'
- en: Pattern Matching with Lists and List Comprehensions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表和列表推导中的模式匹配
- en: 'You can also use pattern matching in list comprehensions, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在列表推导中使用模式匹配，如下所示：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If a pattern match fails, the list comprehension will just move on to the next
    element, and the element that failed won’t be included in the resulting list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式匹配失败，列表推导将简单地移动到下一个元素，并且失败的元素将不会包含在结果列表中。
- en: Regular lists can also be used in pattern matching. You can match with the empty
    list `[]` or any pattern that involves `:` and the empty list. (Remember that
    `[1,2,3]` is just syntactic sugar for `1:2:3:[]`.) A pattern like `x:xs` will
    bind the head of the list to `x` and the rest of it to `xs`. If the list has only
    a single element, then `xs` will simply be the empty list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正规列表也可以用于模式匹配。你可以匹配空列表`[]`或任何涉及`:`和空列表的模式。（记住，`[1,2,3]`只是`1:2:3:[]`的语法糖。）像`x:xs`这样的模式会将列表的头部绑定到`x`，并将其余部分绑定到`xs`。如果列表只有一个元素，那么`xs`将简单地是空列表。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Haskell programmers use the `x:xs` pattern often, especially with recursive
    functions. However, patterns that include the `:` character will match only against
    lists of length one or more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 程序员经常使用`x:xs`模式，尤其是在递归函数中。然而，包含`:`字符的模式只会匹配长度为一或更长的列表。
- en: 'Now that we’ve looked at how to pattern match against lists, let’s make our
    own implementation of the `head` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何对列表进行模式匹配，让我们自己实现`head`函数：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After loading the function, we can test it, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加载函数后，我们可以这样测试它：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that if we want to bind something to several variables (even if one of
    them is just `_`), we must surround them in parentheses so Haskell can properly
    parse them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想将某个东西绑定到多个变量（即使其中一个变量是`_`），我们必须将它们放在括号中，这样 Haskell 才能正确解析它们。
- en: Also notice the use of the `error` function. This function takes a string as
    an argument and generates a runtime error using that string. It essentially crashes
    your program, so it’s not good to use it too much. (But calling `head` on an empty
    list just doesn’t make sense!)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意 `error` 函数的使用。此函数接受一个字符串作为参数，并使用该字符串生成运行时错误。它本质上会崩溃你的程序，所以最好不要过多使用它。（但调用空列表上的
    `head` 真的没有意义！）
- en: 'As another example, let’s write a simple function that takes a list and prints
    its elements out in a wordy, inconvenient format:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，让我们编写一个简单的函数，该函数接受一个列表并以冗长、不便的方式打印其元素：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that `(x:[])` and `(x:y:[])` could be rewritten as `[x]` and `[x,y]`. However,
    we can’t rewrite `(x:y:_)` using square brackets, because it matches any list
    of length 2 or more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`(x:[])` 和 `(x:y:[])` 可以重写为 `[x]` 和 `[x,y]`。然而，我们无法使用方括号重写 `(x:y:_)`，因为它匹配长度为2或更长的任何列表。
- en: 'Here are some examples of using this function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用此函数的一些示例：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `tell` function is safe to use because it can match to the empty list, a
    singleton list, a list with two elements, and a list with more than two elements.
    It knows how to handle lists of any length, and so it will always return a useful
    value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`tell` 函数是安全的，因为它可以匹配空列表、单元素列表、双元素列表以及超过两个元素的列表。它知道如何处理任何长度的列表，因此它总是会返回一个有用的值。'
- en: 'How about if instead we defined a function that only knows how to handle lists
    with three elements? Here’s an example of such a function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们定义一个只能处理包含三个元素的列表的函数会怎样？以下是一个此类函数的示例：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s what happens when we give it a list that it doesn’t expect:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给它一个它不期望的列表时，会发生以下情况：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Yikes! Not cool! If this happened inside a compiled program instead of in GHCi,
    the program would crash.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这不好！如果这种情况发生在编译程序中而不是在 GHCi 中，程序将会崩溃。
- en: 'One final thing to note about pattern matching with lists: You can’t use the
    `++` operator in pattern matches. (Remember that the `++` operator joins two lists
    into one.) For instance, if you tried to pattern match against `(xs ++ ys)`, Haskell
    wouldn’t be able to tell what would be in the `xs` list and what would be in the
    `ys` list. Though it seems logical to match stuff against `(xs ++ [x,y,z])`, or
    even just `(xs ++ [x])`, because of the nature of lists, you can’t.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表模式匹配的最后一件事要注意的是：你无法在模式匹配中使用 `++` 操作符。（记住，`++` 操作符将两个列表连接成一个。）例如，如果你尝试对 `(xs
    ++ ys)` 进行模式匹配，Haskell 将无法确定 `xs` 列表和 `ys` 列表中会有什么。虽然将内容与 `(xs ++ [x,y,z])` 或甚至
    `(xs ++ [x])` 进行匹配看起来合乎逻辑，但由于列表的性质，你无法这样做。
- en: As-patterns
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: As-patterns
- en: There’s also a special type of pattern called an *as-pattern*. As-patterns allow
    you to break up an item according to a pattern, while still keeping a reference
    to the entire original item. To create an as-pattern, precede a regular pattern
    with a name and an `@` character.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种特殊的模式类型称为 as-pattern。As-pattern 允许你根据模式拆分一个项目，同时仍然保留对整个原始项目的引用。要创建一个
    as-pattern，请在常规模式之前加上一个名称和一个 `@` 字符。
- en: 'For instance, we can create the following as-pattern: `xs@(x:y:ys)`. This pattern
    will match exactly the same lists that `x:y:ys` would, but you can easily access
    the entire original list using `xs`, instead of needing to type out `x:y:ys` every
    time. Here’s an example of a simple function that uses an as-pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建以下 as-pattern：`xs@(x:y:ys)`。这个模式将匹配与 `x:y:ys` 完全相同的列表，但你可以轻松地使用 `xs`
    访问整个原始列表，而不必每次都输入 `x:y:ys`。以下是一个使用 as-pattern 的简单函数示例：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After loading the function, we can test it as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载函数后，我们可以按以下方式测试它：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Guards, Guards!
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guards，Guards！
- en: We use patterns to check if the values passed to our functions are constructed
    in a certain way. We use *guards* when we want our function to check if some property
    of those passed values is true or false. That sounds a lot like an `if` expression,
    and it is very similar. However, guards are a lot more readable when you have
    several conditions, and they play nicely with patterns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模式来检查传递给我们的函数的值是否以某种方式构建。当我们想要我们的函数检查传递值的某些属性是否为真或假时，我们使用 *guards*。这听起来很像一个
    `if` 表达式，而且它确实非常相似。然而，当有多个条件时，guards 的可读性会更好，并且它们与模式配合得很好。
- en: 'Let’s dive in and write a function that uses guards. This function will berate
    you in different ways depending on your body mass index (BMI). Your BMI is calculated
    by dividing your weight (in kilograms) by your height (in meters) squared. If
    your BMI is less than 18.5, you’re considered underweight. If it’s anywhere from
    18.5 to 25, you’re considered normal. A BMI of 25 to 30 is overweight, and more
    than 30 is obese. (Note that this function won’t actually calculate your BMI;
    it just takes it as an argument and then tells you off.) Here’s the function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入进去，写一个使用守卫的函数。这个函数会根据你的身体质量指数（BMI）以不同的方式责备你。你的 BMI 是通过将你的体重（以千克为单位）除以你的身高（以米为单位）的平方来计算的。如果你的
    BMI 小于 18.5，你被认为是体重过轻。如果它在 18.5 到 25 之间，你被认为是正常。BMI 为 25 到 30 是超重，超过 30 是肥胖。（请注意，这个函数实际上不会计算你的
    BMI；它只是将 BMI 作为参数，然后告诉你。）以下是该函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802534.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802534.png)'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A guard is indicated by a pipe character (`|`), followed by a Boolean expression,
    followed by the function body that will be used if that expression evaluates to
    `True`. If the expression evaluates to `False`, the function drops through to
    the next guard, and the process repeats. Guards must be indented by at least one
    space. (I like to indent them by four spaces so that the code is more readable.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫由一个管道字符 (`|`) 表示，后面跟着一个布尔表达式，然后是如果该表达式评估为 `True` 将要使用的函数体。如果表达式评估为 `False`，函数将跳转到下一个守卫，然后重复这个过程。守卫至少需要缩进一个空格。（我喜欢用四个空格缩进，这样代码更易读。）
- en: For instance, if we call this function with a BMI of 24.3, it will first check
    if that’s less than or equal to 18.5\. Because it isn’t, it falls through to the
    next guard. The check is carried out with the second guard, and because 24.3 is
    less than 25.0, the second string is returned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们用 24.3 的 BMI 值调用这个函数，它将首先检查这个值是否小于或等于 18.5。因为不是，它将跳转到下一个守卫。检查是通过第二个守卫进行的，因为
    24.3 小于 25.0，所以返回第二个字符串。
- en: Guards are very reminiscent of a big `if/else` tree in imperative languages,
    though they’re far more readable. While big `if/else` trees are usually frowned
    upon, sometimes a problem is defined in such a discrete way that you can’t get
    around them. Guards are a very nice alternative in these cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫在命令式语言中非常类似于一个大的 `if/else` 树，尽管它们读起来更清晰。虽然大的 `if/else` 树通常是不受欢迎的，但有时一个问题被定义得如此离散，以至于你无法绕过它们。在这些情况下，守卫是一个非常好的替代方案。
- en: Many times, the last guard in a function is `otherwise`, which catches everything.
    If all the guards in a function evaluate to `False`, and we haven’t provided an
    `otherwise` catchall guard, evaluation falls through to the next pattern. (This
    is how patterns and guards play nicely together.) If no suitable guards or patterns
    are found, an error is thrown.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，最后一个守卫通常是 `otherwise`，它会捕获所有内容。如果一个函数中的所有守卫都评估为 `False`，并且我们没有提供一个 `otherwise`
    捕获所有内容的守卫，评估将跳转到下一个模式。（这就是模式和守卫如何很好地一起工作。）如果没有找到合适的守卫或模式，将抛出错误。
- en: 'Of course, we can also use guards with functions that take multiple parameters.
    Let’s modify `bmiTell` so that it takes a height and weight, and calculates the
    BMI for us:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用守卫与接受多个参数的函数。让我们修改 `bmiTell`，使其接受一个身高和一个体重，并为我们计算 BMI：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s see if I’m fat:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我是否胖：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yay! I’m not fat! But Haskell just called me ugly. Whatever!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！我不胖！但 Haskell 刚才说我丑。随便吧！
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A common newbie mistake is to put an equal sign (`=`) after the function name
    and parameters, before the first guard. This will cause a syntax error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的初学者错误是在函数名和参数后面放一个等号 (`=`)，在第一个守卫之前。这将导致语法错误。
- en: 'As another simple example, let’s implement our own `max` function to compare
    two items and return the larger one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个简单的例子，让我们实现自己的 `max` 函数来比较两个项目并返回较大的一个：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also implement our own `compare` function using guards:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用守卫来实现自己的 `compare` 函数：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not only can we call functions as infix with backticks, we can also define them
    using backticks. Sometimes this makes them easier to read.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们可以用反引号作为中缀调用函数，我们还可以用反引号来定义它们。有时这使它们更容易阅读。
- en: where?!
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪里？！
- en: When programming, we usually want to avoid calculating the same value over and
    over again. It’s much easier to calculate something only once and store the result.
    In imperative programming languages, you would solve this problem by storing the
    result of a computation in a variable. In this section, you’ll learn how to use
    Haskell’s `where` keyword to store the results of intermediate computations, which
    provides similar functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程时，我们通常想要避免反复计算相同的值。只计算一次并将结果存储起来要容易得多。在命令式编程语言中，你会通过将计算结果存储在变量中来解决这个问题。在本节中，你将学习如何使用Haskell的`where`关键字来存储中间计算的结果，这提供了类似的功能。
- en: 'In the previous section, we defined a BMI calculator function like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们定义了一个BMI计算函数如下所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that we repeat the BMI calculation three times in this code. We can
    avoid this by using the `where` keyword to bind that value to a variable and then
    using that variable in place of the BMI calculation, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个代码中我们重复进行了三次BMI计算。我们可以通过使用`where`关键字将这个值绑定到一个变量上，然后使用这个变量代替BMI计算来避免这种情况，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We put the `where` keyword after the guards and then use it to define one or
    more variables or functions. These names are visible across all the guards. If
    we decide that we want to calculate BMI a bit differently, we need to change it
    only once. This technique also improves readability by giving names to things,
    and it can even make our programs faster, since our values are calculated just
    once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在守卫之后放置`where`关键字，然后使用它来定义一个或多个变量或函数。这些名称在所有守卫中都是可见的。如果我们决定想要以不同的方式计算BMI，我们只需要更改一次。这种技术通过给事物命名来提高可读性，甚至可以使我们的程序运行得更快，因为我们的值只计算一次。
- en: 'If we wanted to, we could even go a bit overboard and write our function like
    this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，甚至可以做得更多，将函数写成这样：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Notice that all the variable names are aligned in a single column. If you don’t
    align them like this, Haskell will get confused, and it won’t know that they’re
    all part of the same block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有变量名都排列在同一列中。如果你不这样对齐它们，Haskell会感到困惑，它不知道它们都是同一个块的一部分。
- en: where's Scope
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪儿是Scope
- en: The variables we define in the `where` section of a function are visible only
    to that function, so we don’t need to worry about them polluting the namespace
    of other functions. If we want to use a variable like this in several different
    functions, we must define it globally.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的`where`部分定义的变量只对该函数可见，所以我们不需要担心它们会污染其他函数的命名空间。如果我们想在几个不同的函数中使用这样的变量，我们必须在全局范围内定义它。
- en: 'Also, `where` bindings are *not* shared across function bodies of different
    patterns. For instance, suppose we want to write a function that takes a name
    and greets the person nicely if it recognizes that name, but not so nicely if
    it doesn’t. We might define it like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`where`绑定不会在不同的模式函数体之间共享。例如，假设我们想要编写一个函数，它接受一个名字，如果它识别出这个名字，就会礼貌地问候这个人，如果不认识，就不会那么礼貌。我们可能定义它如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function won’t work as written. Because `where` bindings aren’t shared
    across function bodies of different patterns, only the last function body sees
    the greetings defined by the `where` binding. To make this function work correctly,
    `badGreeting` and `niceGreeting` must be defined globally, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数按原样是无法工作的。因为`where`绑定不会在不同的模式函数体之间共享，只有最后一个函数体可以看到由`where`绑定定义的问候语。为了使这个函数正确工作，`badGreeting`和`niceGreeting`必须像这样在全局范围内定义：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pattern Matching with where
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用where进行模式匹配
- en: 'You can also use `where` bindings to pattern match. We could have written the
    `where` section of our BMI function like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`where`绑定来进行模式匹配。我们本来可以像这样编写BMI函数的`where`部分：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an example of this technique, let’s write a function that gets a first name
    and last name, and returns the initials:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种技术的例子，让我们编写一个函数，它获取一个名字和姓氏，并返回首字母缩写：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We could have also done this pattern matching directly in the function’s parameters
    (it would have been shorter and more readable), but this example shows that it’s
    possible to do it in the `where` bindings as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接在函数的参数中进行这种模式匹配（这将更短、更易读），但这个例子表明，也可以在`where`绑定中这样做。
- en: Functions in where Blocks
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在where块中的函数
- en: 'Just as we’ve defined constants in `where` blocks, we can also define functions.
    Staying true to our healthy programming theme, let’s make a function that takes
    a list of weight/height pairs and returns a list of BMIs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`where`块中定义了常量一样，我们也可以定义函数。保持我们健康编程的主题，让我们定义一个函数，它接受一个重量/身高对的列表，并返回一个BMI列表：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And that’s all there is to it! The reason we needed to introduce `bmi` as a
    function in this example is that we can’t just calculate one BMI from the function’s
    parameters. We need to examine the list passed to the function, and there’s a
    different BMI for every pair in there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们需要在这个例子中将`bmi`作为函数引入的原因是我们不能仅仅从函数的参数中计算出一个BMI。我们需要检查传递给函数的列表，并且列表中的每一对都有一个不同的BMI。
- en: let It Be
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它成为
- en: '`let` expressions are very similar to `where` bindings. `where` allows you
    bind to variables at the end of a function, and those variables are visible to
    the entire function, including all its guards. `let` expressions, on the other
    hand, allow you to bind to variables anywhere and are expressions themselves.
    However, they’re very local, and they don’t span across guards. Just like any
    Haskell construct that’s used to bind values to names, `let` expressions can be
    used in pattern matching.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`表达式与`where`绑定非常相似。`where`允许你在函数的末尾绑定变量，并且这些变量对整个函数都是可见的，包括所有的守卫。另一方面，`let`表达式允许你在任何地方绑定变量，并且它们本身就是表达式。然而，它们非常局部，并且不会跨越守卫。就像任何用于将值绑定到名称的Haskell构造一样，`let`表达式可以用于模式匹配。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802536.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802536.png.jpg)'
- en: 'Now let’s see `let` in action. The following function returns a cylinder’s
    surface area, based on its height and radius:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`let`的实际应用。以下函数根据圆柱的高度和半径返回其表面积：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`let` expressions take the form of `let <bindings> in <expression>`. The variables
    that you define with `let` are visible within the entire `let` expression.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`表达式的形式为`let <bindings> in <expression>`。你用`let`定义的变量在整个`let`表达式中都是可见的。'
- en: Yes, we could have also defined this with a `where` binding. So what’s the difference
    between the two? At first, it seems that the only difference is that `let` puts
    the bindings first and the expression later, whereas it’s the other way around
    with `where`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们也可以用`where`绑定来定义这个。那么这两个有什么区别呢？起初，看起来唯一的区别是`let`将绑定放在前面，表达式放在后面，而`where`则相反。
- en: 'Really, the main difference between the two is that `let` expressions are .
    . . well . . . expressions, whereas `where` bindings aren’t. If something is an
    expression, then it has a value. `"boo!"` is an expression, as are `3 + 5` and
    `head [1,2,3]`. This means that you can use `let` expressions almost anywhere
    in your code, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个之间的主要区别是`let`表达式是……嗯……表达式，而`where`绑定则不是。如果某物是一个表达式，那么它就有值。"boo!"是一个表达式，`3
    + 5`和`head [1,2,3]`也是。这意味着你几乎可以在代码的任何地方使用`let`表达式，如下所示：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here are a few other useful ways to use `let` expressions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些其他使用`let`表达式的有用方法：
- en: 'They can be used to introduce functions in a local scope:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来在局部作用域中引入函数：
- en: '[PRE34]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'They can be separated with semicolons, which is helpful when you want to bind
    several variables inline and can’t align them in columns:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用分号分隔，这在你想内联绑定多个变量但无法对齐列时很有帮助：
- en: '[PRE35]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Pattern matching with `let` expressions can be very useful for quickly dismantling
    a tuple into components and binding those components to names, like this:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`let`表达式进行模式匹配可以非常有助于快速将元组分解成组件并将这些组件绑定到名称，如下所示：
- en: '[PRE36]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use a `let` expression with a pattern match to deconstruct the triple
    `(1,2,3)`. We call its first component `a`, its second component `b`, and its
    third component `c`. The `in a+b+c` part says that the whole `let` expression
    will have the value of `a+b+c`. Finally, we multiply that value by `100`.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个带有模式匹配的`let`表达式来解构三元组`(1,2,3)`。我们将其第一个组件称为`a`，第二个组件称为`b`，第三个组件称为`c`。`in
    a+b+c`部分表示整个`let`表达式的值将是`a+b+c`。最后，我们将这个值乘以`100`。
- en: You can use `let` expressions inside list comprehensions. We’ll take a closer
    look at this next.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在列表推导式中使用`let`表达式。我们将在下一节中更详细地探讨这一点。
- en: If `let` expressions are so cool, why not use them all the time? Well, since
    `let` expressions are expressions, and are fairly local in their scope, they can’t
    be used across guards. Also, some people prefer `where` bindings because their
    variables are defined *after* the function they’re being used in, rather than
    before. This allows the function body to be closer to its name and type declaration,
    which can make for more readable code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`let`表达式如此酷，为什么不用它们呢？嗯，因为`let`表达式是表达式，并且它们的范围相当局部，所以不能在守卫中使用。此外，有些人更喜欢`where`绑定，因为它们的变量是在它们所使用的函数**之后**定义的，而不是之前。这使得函数体更接近其名称和类型声明，这可以使代码更易读。
- en: let in List Comprehensions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`let`在列表推导式中'
- en: 'Let’s rewrite our previous example of calculating lists of weight/height pairs,
    but we’ll use a `let` expression inside a list comprehension instead of defining
    an auxiliary function with `where`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们之前计算体重/身高对的列表的例子，但我们将使用列表推导式中的`let`表达式，而不是使用带有`where`的辅助函数：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each time the list comprehension takes a tuple from the original list and binds
    its components to `w` and `h`, the `let` expression binds `w / h ^ 2` to the name
    `bmi`. Then we just present `bmi` as the output of the list comprehension.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每次列表推导式从原始列表中取一个元组并将其组件绑定到`w`和`h`时，`let`表达式会将`w / h ^ 2`绑定到名称`bmi`。然后我们只需将`bmi`作为列表推导式的输出即可。
- en: 'We include a `let` inside a list comprehension much as we would use a predicate,
    but instead of filtering the list, it only binds values to names. The names defined
    in this `let` are visible to the output (the part before the `|`) and everything
    in the list comprehension that comes after the `let`. So, using this technique,
    we could make our function return only the BMIs of fat people, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表推导式中包含一个`let`，就像我们使用谓词一样，但不是过滤列表，而是将值绑定到名称上。在这个`let`中定义的名称对输出（`|`之前的部分）以及`let`之后的列表推导式中的所有内容都是可见的。因此，使用这种技术，我们可以使我们的函数只返回肥胖人的BMI，如下所示：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `(w, h) <- xs` part of the list comprehension is called the *generator*.
    We can’t refer to the `bmi` variable in the generator, because that is defined
    prior to the `let` binding.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的`(w, h) <- xs`部分称为**生成器**。我们无法在生成器中引用`bmi`变量，因为它是`let`绑定之前定义的。
- en: let in GHCi
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`let`在GHCi中'
- en: 'The `in` part of the binding can also be omitted when defining functions and
    constants directly in GHCi. If we do that, then the names will be visible throughout
    the entire interactive session:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定中的`in`部分在直接在GHCi中定义函数和常量时也可以省略。如果我们这样做，那么这些名称将在整个交互会话中可见：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because we omitted the `in` part in our first line, GHCi knows that we’re not
    using `zoot` in that line, so it remembers it for the rest of the session. However,
    in the second `let` expression, we included the `in` part and called `boot` immediately
    with some parameters. A `let` expression that doesn’t leave out the `in` part
    is an expression in itself and represents a value, so GHCi just printed that value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们省略了第一行的`in`部分，GHCi知道我们在这行代码中没有使用`zoot`，所以它为整个会话记住了它。然而，在第二个`let`表达式中，我们包含了`in`部分，并立即用一些参数调用`boot`。不省略`in`部分的`let`表达式本身就是一个表达式，它代表一个值，所以GHCi只是打印了那个值。
- en: case Expressions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`case`表达式'
- en: '*`case`* *expressions* allow you to execute blocks of code for specific values
    of a particular variable. Essentially, they are a way to use pattern matching
    almost anywhere in your code. Many languages (like C, C++, and Java) have some
    kind of case statement, so you may already be familiar with the concept.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*`case`* 表达式允许你为特定变量的特定值执行代码块。本质上，它们是在你的代码的几乎任何地方使用模式匹配的一种方式。许多语言（如C、C++和Java）都有某种形式的`case`语句，所以你可能已经熟悉这个概念。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802538.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802538.png.jpg)'
- en: Haskell takes that concept and one-ups it. As the name implies, `case` expressions
    are expressions, much like `if else` expressions and `let` expressions. Not only
    can we evaluate expressions based on the possible cases of the value of a variable,
    we can also do pattern matching.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell将这个概念提升了一个层次。正如其名所示，`case`表达式是表达式，就像`if else`表达式和`let`表达式一样。我们不仅可以根据变量的可能值来评估表达式，还可以进行模式匹配。
- en: 'This is very similar to performing pattern matching on parameters in function
    definitions, where you take a value, pattern match it, and evaluate pieces of
    code based on that value. In fact, that kind of pattern matching is just syntactic
    sugar for `case` expressions. For example, the following two pieces of code do
    the same thing and are interchangeable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在函数定义中对参数执行模式匹配非常相似，其中你取一个值，对它进行模式匹配，并根据该值评估代码片段。实际上，这种模式匹配只是`case`表达式的语法糖。例如，以下两段代码执行相同的功能，可以互换：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s the syntax for a `case` expression:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`case`表达式的语法：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is pretty simple. The first pattern that matches the expression is used.
    If it falls through the whole `case` expression and no suitable pattern is found,
    a runtime error occurs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。使用第一个与表达式匹配的模式。如果它通过了整个`case`表达式并且没有找到合适的模式，则会发生运行时错误。
- en: 'Pattern matching on function parameters can be done only when defining functions,
    but `case` expressions can be used anywhere. For instance, you can use them to
    perform pattern matching in the middle of an expression, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数上的模式匹配只能在定义函数时进行，但`case`表达式可以在任何地方使用。例如，你可以使用它们在表达式中进行模式匹配，如下所示：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, the `case` expression works like this: `ls` is first checked against
    the pattern of an empty list. If `ls` is empty, the whole `case` expression then
    assumes the value of `"empty"`. If `ls` is not an empty list, then it’s checked
    against the pattern of a list with a single element. If the pattern match succeeds,
    the `case` expression then has the value of `"a singleton list"`. If neither of
    those two patterns match, then the catchall pattern, `xs`, applies. Finally, the
    result of the `case` expression is joined together with the string `"The list
    is"`. Each `case` expression represents a value. That’s why we were able to use
    `++` between the string `"The list is"` and our `case` expression.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`case`表达式的工作方式是这样的：首先将`ls`与空列表的模式进行比较。如果`ls`为空，则整个`case`表达式假定值为`"empty"`。如果`ls`不是一个空列表，则将其与只有一个元素的列表的模式进行比较。如果模式匹配成功，则`case`表达式的值为`"a
    singleton list"`。如果这两个模式都不匹配，则应用通配符模式`xs`。最后，将`case`表达式的结果与字符串`"The list is"`连接起来。每个`case`表达式代表一个值。这就是为什么我们能够在字符串`"The
    list is"`和我们的`case`表达式之间使用`++`。
- en: 'Because pattern matching in function definitions is the same as using `case`
    expressions, we could have also defined the `describeList` function like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数定义中的模式匹配与使用`case`表达式相同，所以我们也可以像这样定义`describeList`函数：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function acts just like the one in the previous example, although we used
    a different syntactic construct to define it. The function `what` gets called
    with `ls`, and then the usual pattern-matching action takes place. Once this function
    returns a string, it’s joined with `"The list is"`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的行为与上一个例子中的函数相同，尽管我们使用了不同的语法结构来定义它。函数`what`被`ls`调用，然后发生常规的模式匹配操作。一旦这个函数返回一个字符串，它就会被与字符串`"The
    list is"`连接起来。
