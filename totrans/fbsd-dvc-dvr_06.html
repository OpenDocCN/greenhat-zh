<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Case Study: Virtual Null Modem"><div class="titlepage"><div><div><h1 class="title"><a id="case_study_colon_virtual_null_modem"/>Chapter 6. Case Study: Virtual Null Modem</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id6"/><div class="mediaobject"><a id="I_mediaobject6_d1e11668"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>This chapter is the first of several case studies that’ll guide you through a real-world device driver. The purpose of these case studies is to expose you to genuine driver code—warts and all—and to consolidate the information presented in earlier chapters.<a class="indexterm" id="IDX-CHP-6-0001"/><a class="indexterm" id="IDX-CHP-6-0002"/></p><p>In this chapter, we’ll go through <code class="literal">nmdm(4)</code>, the virtual null modem terminal driver. This driver creates two <code class="literal">tty(4)</code> devices that are connected by a virtual null modem cable. In other words, the output of one <code class="literal">tty(4)</code> device is the input for the other <code class="literal">tty(4)</code> device, and vice versa. I chose to profile <code class="literal">nmdm(4)</code> because it uses event handlers, callouts, and taskqueues, all of which were described, but not demonstrated, in <a class="xref" href="ch05.html" title="Chapter 5. Delaying Execution">Chapter 5</a>.</p><div class="sect1" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="prerequisites-id1"/>Prerequisites</h1></div></div></div><p>Before I can walk you through <code class="literal">nmdm(4)</code>, you’ll need to grok the following functions:<a class="indexterm" id="IDX-CHP-6-0003"/><a class="indexterm" id="IDX-CHP-6-0004"/><a class="indexterm" id="IDX-CHP-6-0005"/></p><a id="I_programlisting6_d1e11720"/><pre class="programlisting">#include &lt;sys/tty.h&gt;

struct tty *
tty_alloc_mutex(struct ttydevsw *tsw, void *softc, struct mtx *mtx);

void
tty_makedev(struct tty *tp, struct ucred *cred, const char *fmt, ...);

void *
tty_softc(struct tty *tp);</pre><p>The <code class="literal">tty_alloc_mutex</code> function creates a TTY device. The <code class="literal">tsw</code> argument expects a pointer to a TTY device switch table, which is like a character device switch table, but for TTY devices. The <code class="literal">softc</code> argument is the software context (or instance variables) for the TTY device. The <code class="literal">mtx</code> argument specifies the mutex that’ll protect the TTY device.<a class="indexterm" id="IDX-CHP-6-0006"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>At some point in the near future, the <code class="literal">tty_alloc_mutex</code> function is supposed to be deprecated and removed.</p></div><p>The <code class="literal">tty_makedev</code> function creates a TTY device node under <span class="emphasis"><em>/dev</em></span>. The <code class="literal">tp</code> argument expects a pointer to a TTY device (for example, the return value from <code class="literal">tty_alloc_mutex</code>). The cred argument is the credentials for the device node. If <code class="literal">cred</code> is <code class="literal">NULL</code>, <code class="literal">UID_ROOT</code> and <code class="literal">GID_WHEEL</code> are used. The <code class="literal">fmt</code> argument specifies the name for the device node.</p><p>The <code class="literal">tty_softc</code> function returns the software context of the TTY device <code class="literal">tp</code>.</p></div></div>
<div class="sect1" title="Code Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="code_analysis"/>Code Analysis</h1></div></div></div><p><a class="xref" href="ch06s02.html#nmdm.c" title="Example 6-1. nmdm.c">Example 6-1</a> provides a terse, source-level overview of <code class="literal">nmdm(4)</code>.</p><div class="example"><a id="nmdm.c"/><p class="title">Example 6-1. nmdm.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;

#include &lt;sys/tty.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/eventhandler.h&gt;
#include &lt;sys/limits.h&gt;
#include &lt;sys/serial.h&gt;
#include &lt;sys/malloc.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/taskqueue.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

MALLOC_DEFINE(M_NMDM, "nullmodem", "nullmodem data structures");

struct nmdm_part {
        struct tty              *np_tty;
        struct nmdm_part        *np_other;
        struct task             np_task;
        struct callout          np_callout;
        int                     np_dcd;
        int                     np_rate;
        u_long                  np_quota;
        int                     np_credits;
        u_long                  np_accumulator;

#define QS 8                    /* Quota shift. */
};

struct nmdm_softc {
        struct nmdm_part        ns_partA;
        struct nmdm_part        ns_partB;
        struct mtx              ns_mtx;
};

static tsw_outwakeup_t          nmdm_outwakeup;
static tsw_inwakeup_t           nmdm_inwakeup;
static tsw_param_t              nmdm_param;
static tsw_modem_t              nmdm_modem;

static struct ttydevsw nmdm_class = {
        .tsw_flags =            TF_NOPREFIX,
        .tsw_outwakeup =        nmdm_outwakeup,
        .tsw_inwakeup =         nmdm_inwakeup,
        .tsw_param =            nmdm_param,
        .tsw_modem =            nmdm_modem
};

static int nmdm_count = 0;

static void
nmdm_timeout(void *arg)
{
...
}

static void
nmdm_task_tty(void *arg, int pending __unused)
{
...
}

static struct nmdm_softc *
nmdm_alloc(unsigned long unit)
{
...
}

static void
nmdm_clone(void *arg, struct ucred *cred, char *name, int len,
    struct cdev **dev)
{
...
}

static void
nmdm_outwakeup(struct tty *tp)
{
...
}

static void
nmdm_inwakeup(struct tty *tp)
{
...
}

static int
bits_per_char(struct termios *t)
{
...
}

static int
nmdm_param(struct tty *tp, struct termios *t)
{
...
}

static int
nmdm_modem(struct tty *tp, int sigon, int sigoff)
{
...
}

static int
nmdm_modevent(module_t mod __unused, int event, void *arg __unused)
{
...
}

DEV_MODULE(nmdm, nmdm_modevent, NULL);</pre></div></div><p><a class="xref" href="ch06s02.html#nmdm.c" title="Example 6-1. nmdm.c">Example 6-1</a> is provided as a convenience; as I go through the code for <code class="literal">nmdm(4)</code> you can refer to it to see how <code class="literal">nmdm(4)</code>’s functions and structures are laid out.<a class="indexterm" id="IDX-CHP-6-0007"/></p><p>To make things easier to understand, I’ll detail the functions and structures in <code class="literal">nmdm(4)</code> in the order I would’ve written them (instead of in the order they appear). To that end, we’ll begin with the module event handler.</p><div class="sect2" title="nmdm_modevent Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_modevent_function"/>nmdm_modevent Function</h2></div></div></div><p>The <code class="literal">nmdm_modevent</code> function is the module event handler for <code class="literal">nmdm(4)</code>. Here is its function definition:<a class="indexterm" id="IDX-CHP-6-0008"/><a class="indexterm" id="IDX-CHP-6-0009"/><a class="indexterm" id="IDX-CHP-6-0010"/><a class="indexterm" id="IDX-CHP-6-0011"/></p><a id="I_programlisting6_d1e11839"/><pre class="programlisting">static int
nmdm_modevent(module_t mod __unused, int event, void *arg __unused)
{
        static eventhandler_tag tag;

        switch (event) {
        case MOD_LOAD:
                tag = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>EVENTHANDLER_REGISTER(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>dev_clone,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>nmdm_clone, 0,
                    1000);
                if (tag == NULL)
                        return (ENOMEM);
                break;
        case MOD_SHUTDOWN:
                break;
        case MOD_UNLOAD:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (nmdm_count != 0)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>return (EBUSY);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>EVENTHANDLER_DEREGISTER(dev_clone, tag);
                break;
        default:
                return (EOPNOTSUPP);
        }

        return (0);

}</pre><p>On module load, this function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11880"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> registers the function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11886"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">nmdm_clone</code> with the event handler <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11895"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">dev_clone</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">dev_clone</code> event handler was described in <a class="xref" href="ch05s03.html#kernel_event_handlers-id1" title="Table 5-1. Kernel Event Handlers">Table 5-1</a> in <a class="xref" href="ch05s02.html#donat_panic-id4" title="Don’t Panic">Don’t Panic</a>.</p></div><p>Recall that functions registered with <code class="literal">dev_clone</code> are called when a solicited item under <code class="literal">/dev</code> does not exist. So when a <code class="literal">nmdm(4)</code> device node is accessed for the first time, <code class="literal">nmdm_clone</code> will be called to create the device node on the fly. Interestingly, this on-the-fly device creation lets one create an unlimited number of <code class="literal">nmdm(4)</code> device nodes.</p><p>On module unload, this function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11933"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> checking the value of <code class="literal">nmdm_count</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The variable <code class="literal">nmdm_count</code> is declared near the beginning of <a class="xref" href="ch06s02.html#nmdm.c" title="Example 6-1. nmdm.c">Example 6-1</a> as an integer initialized to <code class="literal">0</code>.</p></div><p><code class="literal">nmdm_count</code> counts the number of active <code class="literal">nmdm(4)</code> device nodes. If it equals <code class="literal">0</code>, <code class="literal">nmdm_clone</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11966"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> removed from the event handler <code class="literal">dev_clone</code>; otherwise, <code class="literal">EBUSY</code> (which stands for <span class="emphasis"><em>error: device busy</em></span>) is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11982"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> returned.</p></div><div class="sect2" title="nmdm_clone Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_clone_function"/>nmdm_clone Function</h2></div></div></div><p>As mentioned in the previous section, <code class="literal">nmdm_clone</code> creates <code class="literal">nmdm(4)</code> device nodes on the fly. Note that all <code class="literal">nmdm(4)</code> device nodes are created in pairs named <code class="literal">nmdm%lu%c</code>, where <code class="literal">%lu</code> is the unit number and <code class="literal">%c</code> is either <code class="literal">A</code> or <code class="literal">B</code>. Here is the function definition for <code class="literal">nmdm_clone</code>:<a class="indexterm" id="IDX-CHP-6-0012"/><a class="indexterm" id="IDX-CHP-6-0013"/></p><a id="I_programlisting6_d1e12029"/><pre class="programlisting">static void
nmdm_clone(void *arg, struct ucred *cred, char *name, int len,
    struct cdev **dev)
{
        unsigned long unit;
        char *end;
        struct nmdm_softc *ns;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (*dev != NULL)
                return;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (strncmp(name, "nmdm", 4) != 0)
                return;

        /* Device name must be "nmdm%lu%c", where %c is "A" or "B". */
        name += 4;
        unit = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>strtoul(name, &amp;end, 10);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (unit == ULONG_MAX || name == end)
                return;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if ((end[0] != 'A' &amp;&amp; end[0] != 'B') || end[1] != '\0')
                return;

        ns = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>nmdm_alloc(unit);

        if (end[0] == 'A')
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*dev = ns-&gt;ns_partA.np_tty-&gt;t_dev;
        else
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>*dev = ns-&gt;ns_partB.np_tty-&gt;t_dev;
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12082"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks the value of <code class="literal">*dev</code> (which is a character device pointer). If <code class="literal">*dev</code> does not equal <code class="literal">NULL</code>, which implies that a device node already exists, <code class="literal">nmdm_clone</code> exits (because no nodes need to be created). Next, <code class="literal">nmdm_clone</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12104"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> ensures that the first four characters in <code class="literal">name</code> are equal to <code class="literal">nmdm</code>; otherwise it exits (because the solicited device node is for another driver). Then the fifth character in <code class="literal">name</code>, which should be a unit number, is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12119"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> converted to an unsigned long and stored in <code class="literal">unit</code>. The following <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12129"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">if</code> statement checks that the conversion was a success. Afterward, <code class="literal">nmdm_clone</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12141"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> ensures that following the unit number (in <code class="literal">name</code>) is the letter <code class="literal">A</code> or <code class="literal">B</code>; otherwise it exits. Now, having confirmed that the solicited device node is indeed for this driver, <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12157"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">nmdm_alloc</code> is called to actually create the device nodes. Finally, <code class="literal">*dev</code> is set to the solicited device node (either <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12169"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">nmdm%luA</code> or <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12179"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">nmdm%luB</code>).</p><p>Note that since <code class="literal">nmdm_clone</code> is registered with <code class="literal">dev_clone</code>, its function prototype must conform to the type expected by <code class="literal">dev_clone</code>, which is defined in <code class="literal">&lt;sys/conf.h&gt;</code>.</p></div><div class="sect2" title="nmdm_alloc Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_alloc_function"/>nmdm_alloc Function</h2></div></div></div><p>As mentioned in the previous section, <code class="literal">nmdm_alloc</code> actually creates <code class="literal">nmdm(4)</code>’s device nodes. Before I describe this function, an explanation of <code class="literal">nmdm_class</code> is needed.<a class="indexterm" id="IDX-CHP-6-0014"/><a class="indexterm" id="IDX-CHP-6-0015"/><a class="indexterm" id="IDX-CHP-6-0016"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The data structure <code class="literal">nmdm_class</code> is declared near the beginning of <a class="xref" href="ch06s02.html#nmdm.c" title="Example 6-1. nmdm.c">Example 6-1</a> as a TTY device switch table.</p></div><a id="I_programlisting6_d1e12235"/><pre class="programlisting">static struct ttydevsw nmdm_class = {
        .tsw_flags =          <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>TF_NOPREFIX,
        .tsw_outwakeup =        nmdm_outwakeup,
        .tsw_inwakeup =         nmdm_inwakeup,
        .tsw_param =            nmdm_param,
        .tsw_modem =            nmdm_modem

};</pre><p>The flag <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12245"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">TF_NOPREFIX</code> means <code class="literal">don’t prefix tty to the device name</code>. The other definitions are the operations that <code class="literal">nmdm_class</code> supports. These operations will be described as we encounter them.</p><p>Now that you’re familiar with <code class="literal">nmdm_class</code>, let’s walk through <code class="literal">nmdm_alloc</code>.</p><a id="I_programlisting6_d1e12268"/><pre class="programlisting">static struct nmdm_softc *
nmdm_alloc(unsigned long unit)
{
        struct nmdm_softc *ns;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>atomic_add_int(&amp;nmdm_count, 1);

        ns = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>malloc(sizeof(*ns), M_NMDM, M_WAITOK | M_ZERO);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>mtx_init(&amp;ns-&gt;ns_mtx, "nmdm", NULL, MTX_DEF);

        /* Connect the pairs together. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ns-&gt;ns_partA.np_other = &amp;ns-&gt;ns_partB;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>TASK_INIT(&amp;ns-&gt;ns_partA.np_task, 0, nmdm_task_tty, &amp;ns-&gt;ns_partA);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>callout_init_mtx(&amp;ns-&gt;ns_partA.np_callout, &amp;ns-&gt;ns_mtx, 0);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>ns-&gt;ns_partB.np_other = &amp;ns-&gt;ns_partA;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>TASK_INIT(&amp;ns-&gt;ns_partB.np_task, 0, nmdm_task_tty, &amp;ns-&gt;ns_partB);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>callout_init_mtx(&amp;ns-&gt;ns_partB.np_callout, &amp;ns-&gt;ns_mtx, 0);

        /* Create device nodes. */
        ns-&gt;ns_partA.np_tty = tty_alloc_mutex(&amp;nmdm_class, &amp;ns-&gt;ns_partA,
            &amp;ns-&gt;ns_mtx);
        tty_makedev(ns-&gt;ns_partA.np_tty, NULL, "nmdm%luA", unit);

        ns-&gt;ns_partB.np_tty = tty_alloc_mutex(&amp;nmdm_class, &amp;ns-&gt;ns_partB,
            &amp;ns-&gt;ns_mtx);
        tty_makedev(ns-&gt;ns_partB.np_tty, NULL, "nmdm%luB", unit);

        return (ns);

}</pre><p>This function can be split into four parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12327"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> increments <code class="literal">nmdm_count</code> by one via the <code class="literal">atomic_add_int</code> function. As its name implies, <code class="literal">atomic_add_int</code> is atomic. Consequently, we don’t need a lock to protect <code class="literal">nmdm_count</code> when we increment it.<a class="indexterm" id="IDX-CHP-6-0017"/><a class="indexterm" id="IDX-CHP-6-0018"/><a class="indexterm" id="IDX-CHP-6-0019"/><a class="indexterm" id="IDX-CHP-6-0020"/><a class="indexterm" id="IDX-CHP-6-0021"/><a class="indexterm" id="IDX-CHP-6-0022"/></p><p>The second part <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12370"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> allocates memory for a new <code class="literal">nmdm_softc</code> structure. After that, its mutex is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12379"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> initialized. Besides a mutex, <code class="literal">nmdm_softc</code> contains two additional member variables: <code class="literal">ns_partA</code> and <code class="literal">ns_partB</code>. These variables are <code class="literal">nmdm_part</code> structures and will maintain data relating to <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">st</code>ruct <code class="literal">nmdm_softc</code> is defined near the beginning of <a class="xref" href="ch06s02.html#nmdm.c" title="Example 6-1. nmdm.c">Example 6-1</a>.</p></div><p>The third part <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12416"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12422"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> connects the member variables <code class="literal">ns_partA</code> and <code class="literal">ns_partB</code>, so that given <code class="literal">ns_partA</code> we can find <code class="literal">ns_partB</code>, and vice versa. The third part also initializes <code class="literal">ns_partA</code>’s and <code class="literal">ns_partB</code>’s <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12447"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12453"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">task</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12463"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12469"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">callout</code> structures.</p><p>Finally, the fourth part creates <code class="literal">nmdm(4)</code>’s device nodes (that is, <code class="literal">nmdm%luA</code> and <code class="literal">nmdm%luB</code>).</p></div><div class="sect2" title="nmdm_outwakeup Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_outwakeup_function"/>nmdm_outwakeup Function</h2></div></div></div><p>The <code class="literal">nmdm_outwakeup</code> function is defined in <code class="literal">nmdm_class</code> as the <code class="literal">tsw_outwakeup</code> operation. It is executed when output from <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code> is available. Here is its function definition:</p><a id="I_programlisting6_d1e12510"/><pre class="programlisting">static void
nmdm_outwakeup(struct tty *tp)
{
        struct nmdm_part *np = tty_softc(tp);

        /* We can transmit again, so wake up our side. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>taskqueue_enqueue(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>taskqueue_swi, <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>&amp;np-&gt;np_task);
}</pre><p>This function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12532"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> queues <code class="literal">ns_partA</code>’s or <code class="literal">ns_partB</code>’s <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12544"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">task</code> structure on <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12554"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">taskqueue_swi</code> (that is to say, it defers processing the output from <code class="literal">nmdm%luA</code> and <code class="literal">nmdm%luB</code>).</p></div><div class="sect2" title="nmdm_task_tty Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_task_underscore_tty_func"/>nmdm_task_tty Function</h2></div></div></div><p>The <code class="literal">nmdm_task_tty</code> function transfers data from <code class="literal">nmdm%luA</code> to <code class="literal">nmdm%luB</code>, and vice versa. This function is queued on <code class="literal">taskqueue_swi</code> by <code class="literal">nmdm_outwakeup</code> (for verification, see the third argument to <code class="literal">TASK_INIT</code> in <code class="literal">nmdm_alloc</code>). Here is its function definition:</p><a id="I_programlisting6_d1e12596"/><pre class="programlisting">static void
nmdm_task_tty(void *arg, int pending __unused)
{
        struct tty *tp, *otp;
        struct nmdm_part *np = arg;
        char c;

        tp = np-&gt;np_tty;
        tty_lock(tp);

        otp = np-&gt;np_other-&gt;np_tty;
        KASSERT(otp != NULL, ("nmdm_task_tty: null otp"));
        KASSERT(otp != tp, ("nmdm_task_tty: otp == tp"));

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (np-&gt;np_other-&gt;np_dcd) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (!tty_opened(tp)) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>np-&gt;np_other-&gt;np_dcd = 0;
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ttydisc_modem(otp, 0);
                }
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>} else {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>if (tty_opened(tp)) {
                        np-&gt;np_other-&gt;np_dcd = 1;
                        ttydisc_modem(otp, 1);
                }
        }

        while (<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>ttydisc_rint_poll(otp) &gt; 0) {
                if (np-&gt;np_rate &amp;&amp; !np-&gt;np_quota)
                        break;
                if (<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ttydisc_getc(tp, &amp;c, 1) != 1)
                        break;
                np-&gt;np_quota--;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>ttydisc_rint(otp, c, 0);
        }
        ttydisc_rint_done(otp);

        tty_unlock(tp);
}</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In this function’s explanation, “our TTY” refers to the TTY device (that is, <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code>) that queued this function on <code class="literal">taskqueue_swi</code>.</p></div><p>This function is composed of two parts. The first changes the connection state between the two TTYs to match the status of our TTY. If our TTY is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12667"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> closed and the other TTY’s Data Carrier Detect (DCD) flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12673"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> on, we <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12679"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> turn off that flag and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12685"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> switch off their carrier signal. On the other hand, if our TTY has been <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12691"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> opened and the other TTY’s DCD flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12698"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> off, we turn on that flag and switch on their carrier signal. In short, this part ensures that if our TTY is closed (that is, there is no data to transfer), the other TTY will not have a carrier signal, and if our TTY has been opened (that is, there is data to transfer), the other TTY will have a carrier signal. A carrier signal indicates a connection. In other words, loss of the carrier equates to termination of the connection.<a class="indexterm" id="IDX-CHP-6-0023"/></p><p>The second part transfers data from our TTY’s output queue to the other TTY’s input queue. This part first <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12709"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> polls the other TTY to determine whether it can accept data. Then one character is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12715"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> removed from our TTY’s output queue and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12721"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> placed in the other TTY’s input queue. These steps are repeated until the transfer is complete.</p></div><div class="sect2" title="nmdm_inwakeup Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_inwakeup_function"/>nmdm_inwakeup Function</h2></div></div></div><p>The <code class="literal">nmdm_inwakeup</code> function is defined in <code class="literal">nmdm_class</code> as the <code class="literal">tsw_inwakeup</code> operation. It is called when input for <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code> can be received again. That is, when <code class="literal">nmdm%luA</code>’s or <code class="literal">nmdm%luB</code>’s input queue is full and then space becomes available, this function is executed. Here is its function definition:<a class="indexterm" id="IDX-CHP-6-0024"/><a class="indexterm" id="IDX-CHP-6-0025"/><a class="indexterm" id="IDX-CHP-6-0026"/><a class="indexterm" id="IDX-CHP-6-0027"/></p><a id="I_programlisting6_d1e12770"/><pre class="programlisting">static void
nmdm_inwakeup(struct tty *tp)
{
        struct nmdm_part *np = tty_softc(tp);

        /* We can receive again, so wake up the other side. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>taskqueue_enqueue(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>taskqueue_swi,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>&amp;np-&gt;np_other-&gt;np_task);
}</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In this function’s explanation, “our TTY” refers to the TTY device (that is, <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code>) that executed this function.</p></div><p>This function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12801"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> queues the other TTY’s <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12807"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> task structure on <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12813"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">taskqueue_swi</code>. In other words, when input for our TTY can be received again, our TTY tells the other TTY to transfer data to it.</p></div><div class="sect2" title="nmdm_modem Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_modem_function"/>nmdm_modem Function</h2></div></div></div><p>The <code class="literal">nmdm_modem</code> function is defined in <code class="literal">nmdm_class</code> as the <code class="literal">tsw_modem</code> operation. This function sets or gets the modem control line state. Here is its function definition:</p><a id="I_programlisting6_d1e12837"/><pre class="programlisting">static int
nmdm_modem(struct tty *tp, int sigon, int sigoff)
{
        struct nmdm_part *np = tty_softc(tp);
        int i = 0;

        /* Set modem control lines. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sigon || sigoff) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (sigon &amp; SER_DTR)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>np-&gt;np_other-&gt;np_dcd = 1;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (sigoff &amp; SER_DTR)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>np-&gt;np_other-&gt;np_dcd = 0;

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>ttydisc_modem(np-&gt;np_other-&gt;np_tty, np-&gt;np_other-&gt;np_dcd);

                return (0);
        /* Get state of modem control lines. */
        } else {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>if (np-&gt;np_dcd)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>i |= SER_DCD;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>if (np-&gt;np_other-&gt;np_dcd)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>i |= SER_DTR;

                return (i);
        }

}</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In this function’s explanation, “our TTY” refers to the TTY device (that is, <code class="literal">nmdm%luA</code> or <code class="literal">nmdm%luB</code>) that executed this function.<a class="indexterm" id="IDX-CHP-6-0028"/><a class="indexterm" id="IDX-CHP-6-0029"/><a class="indexterm" id="IDX-CHP-6-0030"/><a class="indexterm" id="IDX-CHP-6-0031"/></p></div><p>This function sets the modem control lines when the <code class="literal">sigon</code> (signal on) or the <code class="literal">sigoff</code> (signal off) argument is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12931"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> nonzero. If <code class="literal">sigon</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12940"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> contains the Data Terminal Ready (DTR) flag, the other TTY’s DCD flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12947"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> turned on. If <code class="literal">sigoff</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12956"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> contains the DTR flag, the other TTY’s DCD flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12962"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> turned off. The other TTY’s carrier signal is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12968"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> turned on or off alongside its DCD flag.</p><p>If the preceding discussion didn’t make any sense to you, this should help: A null modem connects the DTR output of each serial port to the DCD input of the other. The DTR output is kept off until a program accesses the serial port and turns it on; the other serial port will sense this as its DCD input turning on. Thus, the DCD input is used to detect the readiness of the other side. This is why when our TTY’s DTR is sigon’d or <code class="literal">sigoff</code>’d, the other TTY’s DCD flag and carrier signal are also turned on or off.</p><p>This function gets the modem control line state when sigon and sigoff are 0. If our TTY’s DCD flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12981"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> on, <code class="literal">SER_DCD</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12990"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> returned. If the other TTY’s DCD flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12996"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> on, indicating that our TTY’s DTR flag is on, <code class="literal">SER_DTR</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13006"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> returned.</p></div><div class="sect2" title="nmdm_param Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_param_function"/>nmdm_param Function</h2></div></div></div><p>The <code class="literal">nmdm_param</code> function is defined in <code class="literal">nmdm_class</code> as the <code class="literal">tsw_param</code> operation. This function sets up <code class="literal">nmdm_task_tty</code> to be executed at regular intervals. That is, it sets <code class="literal">nmdm%luA</code> to periodically transfer data to <code class="literal">nmdm%luB</code>, and vice versa. This periodic data transfer requires flow control to prevent one side from overrunning the other with data. Flow control works by halting the sender when the receiver can’t keep up.</p><p>Here is the function definition for <code class="literal">nmdm_param</code>:</p><a id="I_programlisting6_d1e13041"/><pre class="programlisting">static int
nmdm_param(struct tty *tp, struct termios *t)
{
        struct nmdm_part *np = tty_softc(tp);
        struct tty *otp;
        int bpc, rate, speed, i;

        otp = np-&gt;np_other-&gt;np_tty;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (!((t-&gt;c_cflag | otp-&gt;t_termios.c_cflag) &amp; CDSR_OFLOW)) {
                np-&gt;np_rate = 0;
                np-&gt;np_other-&gt;np_rate = 0;
                return (0);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>bpc = imax(bits_per_char(t), bits_per_char(&amp;otp-&gt;t_termios));

        for (i = 0; i &lt; 2; i++) {
                /* Use the slower of their transmit or our receive rate. */
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>speed = imin(otp-&gt;t_termios.c_ospeed, t-&gt;c_ispeed);
                if (speed == 0) {
                        np-&gt;np_rate = 0;
                        np-&gt;np_other-&gt;np_rate = 0;
                        return (0);
                }

                speed &lt;&lt;= QS;                  /* bits per second, scaled. */
                speed /= bpc;                  /* char per second, scaled. */
                rate = (hz &lt;&lt; QS) / speed;     /* hz per callout. */
                if (rate == 0)
                        rate = 1;

                speed *= rate;
                speed /= hz;                   /* (char/sec)/tick, scaled. */

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>np-&gt;np_credits = speed;
                np-&gt;np_rate = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>rate;
                callout_reset(&amp;np-&gt;np_callout, <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>rate,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>nmdm_timeout, np);

                /* Swap pointers for second pass--to update the other end. */
                np = np-&gt;np_other;
                t = &amp;otp-&gt;t_termios;
                otp = tp;
        }

        return (0);
}</pre><p>This function can be split into three parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13088"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> determines whether flow control is disabled. If it is, <code class="literal">ns_partA</code>’s and <code class="literal">ns_partB</code>’s <code class="literal">np_rate</code> variable is zeroed and <code class="literal">nmdm_param</code> exits. The <code class="literal">np_rate</code> variable is the rate at which <code class="literal">nmdm_task_tty</code> will be executed. This rate can differ for <code class="literal">nmdm%luA</code> and <code class="literal">nmdm%luB</code>.<a class="indexterm" id="IDX-CHP-6-0032"/><a class="indexterm" id="IDX-CHP-6-0033"/></p><p>The second part calculates the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13127"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> value for <code class="literal">np_rate</code>. This calculation takes into consideration the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13136"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> speed of <code class="literal">nmdm%luA</code> and <code class="literal">nmdm%luB</code> and the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13149"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> number of bits per character. The second part also determines the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13155"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> maximum number of characters to transfer per execution of <code class="literal">nmdm_task_tty</code>.</p><p>Lastly, the third part causes <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13166"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">nmdm_timeout</code> to execute one time after <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13175"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">rate</code> / <code class="literal">hz</code> seconds. The <code class="literal">nmdm_timeout</code> function queues <code class="literal">nmdm_task_tty</code> on <code class="literal">taskqueue_swi</code>.</p><p>The second and third parts are executed twice, once for <code class="literal">nmdm%luA</code> and once for <code class="literal">nmdm%luB</code>.</p></div><div class="sect2" title="nmdm_timeout Function"><div class="titlepage"><div><div><h2 class="title"><a id="nmdm_underscore_timeout_function"/>nmdm_timeout Function</h2></div></div></div><p>As indicated in the previous section, the <code class="literal">nmdm_timeout</code> function queues <code class="literal">nmdm_task_tty</code> on <code class="literal">taskqueue_swi</code> at regular intervals. Here is its function definition:<a class="indexterm" id="IDX-CHP-6-0034"/><a class="indexterm" id="IDX-CHP-6-0035"/><a class="indexterm" id="IDX-CHP-6-0036"/><a class="indexterm" id="IDX-CHP-6-0037"/><a class="indexterm" id="IDX-CHP-6-0038"/></p><a id="I_programlisting6_d1e13239"/><pre class="programlisting">static void
nmdm_timeout(void *arg)
{
        struct nmdm_part *np = arg;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (np-&gt;np_rate == 0)
                return;

        /*
         * Do a simple Floyd-Steinberg dither to avoid FP math.
         * Wipe out unused quota from last tick.
         */
        np-&gt;np_accumulator += np-&gt;np_credits;
        np-&gt;np_quota = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>np-&gt;np_accumulator &gt;&gt; QS;
        np-&gt;np_accumulator &amp;= ((1 &lt;&lt; QS) - 1);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>taskqueue_enqueue(<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>taskqueue_swi, &amp;np-&gt;np_task);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>callout_reset(&amp;np-&gt;np_callout, <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>np-&gt;np_rate,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>nmdm_timeout, np);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13286"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks the value of <code class="literal">np_rate</code>. If it equals 0, <code class="literal">nmdm_timeout</code> exits. Next, <code class="literal">ns_partA</code>’s or <code class="literal">ns_partB</code>’s <code class="literal">np_quota</code> variable is assigned the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13308"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> maximum number of characters to transfer (if you return to <a class="xref" href="ch06s02.html#nmdm_underscore_task_underscore_tty_func" title="nmdm_task_tty Function">nmdm_task_tty Function</a> in <a class="xref" href="ch06s02.html#nmdm_underscore_outwakeup_function" title="nmdm_outwakeup Function">nmdm_outwakeup Function</a>, it should be obvious how <code class="literal">np_quota</code> is used). Once this is done, <code class="literal">nmdm_task_tty</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13325"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> queued on <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13331"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">taskqueue_swi</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13340"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">nmdm_timeout</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13349"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> rescheduled to execute after <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13356"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">np_rate</code> / <code class="literal">hz</code> seconds.</p><p>The <code class="literal">nmdm_param</code> and <code class="literal">nmdm_timeout</code> functions are used to emulate the TTYs’ baud rate. Without these two functions, data transfers would be slower.</p></div><div class="sect2" title="bits_per_char Function"><div class="titlepage"><div><div><h2 class="title"><a id="bits_underscore_per_underscore_char_func"/>bits_per_char Function</h2></div></div></div><p>The <code class="literal">bits_per_char</code> function returns the number of bits used to represent a single character for a given TTY. This function is used only in <code class="literal">nmdm_param</code>. Here is its function definition:</p><a id="I_programlisting6_d1e13387"/><pre class="programlisting">static int
bits_per_char(struct termios *t)
{
        int bits;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>bits = 1;               /* start bit. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>switch (t-&gt;c_cflag &amp; CSIZE) {
        case CS5:
                bits += 5;
                break;
        case CS6:
                bits += 6;
                break;
        case CS7:
                bits += 7;
                break;
        case CS8:
                bits += 8;
                break;
        }
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>bits++;                 /* stop bit. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (t-&gt;c_cflag &amp; PARENB)
                bits++;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if (t-&gt;c_cflag &amp; CSTOPB)
                bits++;

        return (<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>bits);
}</pre><p>Notice that the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13428"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> return value takes into account the <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13434"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> variable character size, <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13440"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> start bit, <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13446"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> stop bit, <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13452"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> parity enabled bit, and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13459"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> second stop bit.<a class="indexterm" id="IDX-CHP-6-0039"/></p></div><div class="sect2" title="Don’t Panic"><div class="titlepage"><div><div><h2 class="title"><a id="donat_panic-id5"/>Don’t Panic</h2></div></div></div><p>Now that we’ve walked through <code class="literal">nmdm(4)</code>, let’s give it a try:</p><a id="I_programlisting6_d1e13478"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./nmdm.ko</code></strong>
$ <strong class="userinput"><code>sudo /usr/libexec/getty std.9600 nmdm0A &amp;</code></strong>
[1] 936
$ <strong class="userinput"><code>sudo cu -l /dev/nmdm0B</code></strong>
Connected

FreeBSD/i386 (wintermute.phub.net.cable.rogers.com) (nmdm0A)
login:</pre><p>Excellent. We’re able to connect to <code class="literal">nmdm0A</code>, which is running <code class="literal">getty(8)</code>, from <code class="literal">nmdm0B</code>.</p></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id5"/>Conclusion</h1></div></div></div><p>This chapter described the entire code base of <code class="literal">nmdm(4)</code>, the virtual null modem terminal driver. If you noticed the complete lack of locking in this driver and are alarmed, don’t be. The <code class="literal">ns_mtx</code> mutex, which gets initialized in <code class="literal">nmdm_alloc</code>, is implicitly acquired by the TTY subsystem before <code class="literal">nmdm_outwakeup</code>, <code class="literal">nmdm_inwakeup</code>, <code class="literal">nmdm_modem</code>, and <code class="literal">nmdm_param</code> are called. In short, every operation between <code class="literal">nmdm%luA</code> and <code class="literal">nmdm%luB</code> is serialized.</p></div></body></html>