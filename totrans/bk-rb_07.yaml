- en: Chapter 7. Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ve used numerous methods throughout this book. On the whole, they aren’t
    particularly complicated things, so you may wonder why this chapter, which is
    all about methods, is so long. As you will discover, there is much more to methods
    than meets the eye.
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods you’ve been using so far have been *instance methods*. An instance
    method belongs to a specific instance of a class—in other words, to an individual
    object. It is also possible to write *class methods*. (Some other languages refer
    to this kind of method as a static method.) A class method belongs to the class
    itself. To define a class method, you must precede the method name with the class
    name and a full stop.
  prefs: []
  type: TYPE_NORMAL
- en: '*class_methods1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should use the class name when calling a class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A specific object cannot call a class method. Nor can a class call an instance
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What Are Class Methods For?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But why, you may reasonably ask, would you ever want to create a class method
    rather than the more usual instance method? There are two main reasons: First,
    a class method can be used as a “ready-to-run function” without having to go to
    the bother of creating an object just to use it, and second, it can be used on
    those occasions when you need to run a method before an object has been created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a few examples of using methods as “ready-to-run functions,” consider Ruby’s
    File class. Many of its methods are class methods. This is because most of the
    time you will be using them to do something to, or return information about, an
    existing file. You don’t need to create a new File object to do that; instead,
    you pass the filename as an argument to the File class methods. You’ll look more
    closely at the File class in [Chapter 13](ch13.html "Chapter 13. Files and IO").
    Here are examples of a few of its class methods in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other occasion when a class method is vital is when you need to use a method
    before an object has been created. The most important example of this is the `new`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You call the `new` method every time you create an object. Until the object
    has been created, you clearly cannot call one of its instance methods—because
    you can call instance methods only from an object that already exists. When you
    use `new`, you are calling a method of the class itself and telling the class
    to create a new instance of itself.
  prefs: []
  type: TYPE_NORMAL
- en: Class Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class methods may remind you of the class variables you used previously (that
    is, variables whose names begin with `@@`). You may recall that you used class
    variables in a simple adventure game (see *2adventure.rb* in [Attribute Readers
    and Writers](ch02s04.html "Attribute Readers and Writers")) to keep a tally of
    the total number of objects in the game; each time a new Thing object was created,
    1 was added to the `@@num_things` class variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike an instance variable (that is, a variable that belongs to a specific
    object created from a class), a class variable must be given a value when it is
    first declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Initialization of either instance or class variables within the body of the
    class affects only the values stored by the class itself. Class variables are
    available both to the class itself and to the objects created from that class.
    However, each instance variable is unique; each object has its own copy of any
    instance variables—*and the class itself may also have its own instance variables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class Variables, Instance Variables, and Methods: Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance variables begin with `@`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Class variables begin with `@@`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instance methods are defined by `def` *`MethodName`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Class methods are defined by `def` *`ClassName`*.*`MethodName`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how a class may have instance variables, refer to the *class_methods2.rb*
    program. This defines a class containing one class method and one instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*class_methods2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that it declares and initializes a class variable and an instance variable,
    `@@classvar` and `@instvar`, respectively. Its class method, `classMethod`, increments
    both these variables by 10, while its instance method, `instanceMethod`, increments
    both variables by 1\. Notice that I have assigned values to both the class variable
    and the instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I said earlier that initial values are not normally assigned to instance variables
    in this way. The exception to the rule is when you assign a value to an instance
    variable *of the class itself* rather than to an object derived from that class.
    The distinction should become clearer shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve written a few lines of code that create three instances of MyClass (the
    `ob` variable is initialized with a new instance on each turn through the loop)
    and then call both the class and instance methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The class method, `MyClass.showVars`, and the instance method, `showVars`,
    display the values of `@instvar` and `@@classvar` at each turn through the loop.
    When you run the code, these are the values displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to look at these results carefully in order to see what is going
    on here. In summary, this is what is happening: The code in both the class method,
    `MyClass.classMethod`, and the instance method, `instanceMethod`, increments both
    the class and instance variables, `@@classvar` and `@instvar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see clearly that the class variable is incremented by both these methods
    (the class method adds 10 to `@@classvar` whenever a new object is created, while
    the instance method adds 1 to it). However, whenever a new object is created,
    its instance variable is initialized to 1 by the `instanceMethod`. This is the
    expected behavior since each object has its own copy of an instance variable,
    but all objects share a unique class variable. Perhaps less obvious is that the
    class itself also has its own instance variable, `@instvar`. This is because,
    in Ruby, a class is an object and therefore can contain instance variables, just
    like any other object. The MyClass variable, `@instvar`, is incremented by the
    class method `MyClass.classMethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the instance method, `showVars`, prints the value of `@instvar`, it prints
    the value stored in a specific object, `ob`; the value of `ob`’s `@instvar` is
    initially `nil` (*not* the value 1,000 with which the MyClass variable `@instvar`
    was initialized), and this value is incremented by 1 in `instanceMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: When the class method, `MyClass.showVars`, prints the value of `@instvar`, it
    prints the value stored in the class itself (in other words, MyClass’s `@instvar`
    *is a different variable* from `ob`’s `@instvar`). But when either method prints
    the value of the class variable, `@@classvar`, the value is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember that there is only ever one copy of a class variable, but there
    may be many copies of instance variables. If this is still confusing, take a look
    at the *inst_vars.rb* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*inst_vars.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of creating a new object instance at each turn through the
    loop, you create a single instance (`ob`) at the outset. When the `ob.instanceMethod`
    is called, `@instvar` is incremented by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I’ve used a little trick to look inside the class and method and retrieve
    the value of `@instvar` using Ruby’s `instance_variable_get` method (I’ll return
    to this when I cover dynamic programming in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you only ever increment the `@instvar` that belongs to the object `ob`,
    the value of its `@instvar` goes up from 1 to 3 as the `for` loop executes. But
    the `@instvar` that belongs to the MyClass class is never incremented; it remains
    at its initial value of 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But now let’s uncomment this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This calls a class method that increments `@instvar` by 10\. This time when
    you run the program, you see that, as before, the `@instvar` variable of `ob`
    is incremented by 1 on each turn through the loop, while the `@instvar` variable
    of MyClass is incremented by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A Class Is an Object
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand instance variables of classes, just remember that a class is
    an object (actually, it’s an instance of the `Class` class!). The MyClass “class
    object” has its own instance variable (`@instvar`) just as the `ob` object has
    its own instance variable (which here also happens to be called `@instvar`). In
    spite of the same names, these are two different variables: One belongs to the
    class itself; the other belongs inside each object created from the class. Instance
    variables are always unique to an object instance, so no two objects (not even
    an object like MyClass, which also happens to be a class!) can ever share a single
    instance variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby Constructors: new or initialize?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I gave a brief explanation of `new` and `initialize` in [Chapter 1](ch01.html
    "Chapter 1. Strings, Numbers, Classes, and Objects"). At that stage, you had not
    examined the differences between Ruby’s class and instance methods and variables,
    so it was not possible to give a full discussion of how `new` and `initialize`
    work together. Because these are such important methods, you’ll look at them in
    more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: The method responsible for bringing an object into being is called the *constructor*.
    In Ruby, the constructor method is called `new`. The `new` method is a class method
    that, once it has created an object, will run an instance method named `initialize`
    if such a method exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief then, the `new` method is the constructor, and the `initialize` method
    is used to initialize the values of any variables immediately after an object
    is created. But why can’t you just write your own `new` method and initialize
    variables in it? Well, let’s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*new.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’ve written a `MyClass.new` method that begins with the `super` keyword
    to invoke the `new` method of its superclass. Then I’ve created a string instance
    variable, `@anewvar`. So what do I end up with? Not, as you might suppose, a new
    MyClass object containing a string variable. Remember that the last expression
    evaluated by a method in Ruby is the value returned by that method. The last expression
    evaluated by the `new` method here is a string. I evaluate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And I display the newly created `ob` object and its class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This proves that `MyClass.new` returns a string, and it is this string (*not*
    a MyClass object) that is assigned to the variable `ob`. If you find this confusing,
    don’t panic. The moral of the story is that overriding `new` *is* confusing and
    is generally a bad idea. Unless you have a very good reason for doing so, you
    should avoid trying to override the `new` method.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A singleton method is a method that belongs to a single object rather than
    to an entire class. Many of the methods in the Ruby class library are singleton
    methods. This is because, as mentioned earlier, each class is an object of the
    type Class. Or, to put it simply, the class of every class is Class. This is true
    of all classes—both those you define yourself and those provided by the Ruby class
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '*class_classes.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, some classes also have class methods—that is, methods that belong to the
    Class object itself. In that sense, these are singleton methods of the Class object.
    Indeed, if you evaluate the following, you will be shown an array of method names
    that match the names of IO class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained earlier, when you write your own class methods, you do so by prefacing
    the method name with the name of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that you can use a similar syntax when creating singleton classes
    for specific objects. This time you preface the method name with the name of the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finding an Object’s Ancestor Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately all classes descend from the Object class. In Ruby 1.9, the Object
    class itself descends from the BasicObject class (see [Chapter 2](ch02.html "Chapter 2. Class
    Hierarchies, Attributes, and Class Variables")). This is true even for the `Class`
    class! To prove this, try the *class_hierarchy.rb* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass a class name to this method to track back up its family tree of ancestor
    classes. For example, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby 1.9, this displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*class_hierarchy.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a concrete example. Suppose you have a program containing Creature
    objects of many different species (maybe you are a veterinarian, the head keeper
    at a zoo, or, like the author of this book, an enthusiastic player of adventure
    games); each creature has a method called `talk` that displays the vocal noise
    each creature usually makes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my Creature class and a few creature objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_meth1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then you suddenly realize that one of those creatures, and one alone, has additional
    special behavior. On the night of a full moon, the werewolf not only talks (“growl”)
    but also howls (“How-oo-oo-oo-oo!”). It really needs a `howl` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could go back and add such a method to the Creature class, but then you’d
    end up with howling dogs, cats, and budgies too—which is not what you want. You
    could create a new Werewolf class that descends from Creature, but you will only
    ever have one werewolf (they are, alas, an endangered species), so why do you
    want a whole class for just that? Wouldn’t it make more sense to have a werewolf
    *object* that is the same as every other creature object except that it also has
    a `howl` method? Okay, let’s do that by giving the werewolf its very own singleton
    method. Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Heck, you can do better than that! It howls only on a full moon, so let’s make
    sure that, if asked to howl when the moon is new, it just growls. Here’s my finished
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, even though this method has been declared outside the Creature
    class, it is able to call the instance method `talk`. That’s because the `howl`
    method now lives “inside” the werewolf object so has the same scope within that
    object as the `talk` method. It does not, however, live inside any of the werewolf’s
    fellow creatures; the `howl` method belongs to him and him alone. Try to make
    the `budgie.howl`, and Ruby will inform you that `howl` is an undefined method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you are debugging your code for your own use, having your program blow
    up thanks to an undefined method may be acceptable; however, if your program does
    so out in the big, bad world of the “end user,” it is definitely *not* acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think undefined methods are likely to be a problem, you can take avoidance
    measures by testing whether a singleton method exists before trying to use it.
    The Object class has a `singleton_methods` method that returns an array of singleton
    method names. You can test a method name for inclusion using the Array class’s
    `include?` method. In *singleton_meth2.rb*, for example, I’ve programmed an “open
    the box” game, which has a number of Box objects, only one of which, when opened,
    contains the star prize. I’ve named this special Box object `starprize` and given
    it a singleton method called `congratulate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_meth2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `congratulate` method should be called when the `starprize` box is opened.
    This bit of code (in which `item` is a Box object) ensures that this method (which
    does not exist in any other object) is not called when some other box is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way of checking the validity of a method would be to pass that
    method name as a symbol (an identifier preceded by a colon) to the Object class’s
    `respond_to?` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll see another way of handling nonexistent methods in [Chapter 20](ch20.html
    "Chapter 20. Dynamic Programming").
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singleton method is a method that belongs to a single object. A singleton
    class, on the other hand, is a class that defines a single object. Confused? Me
    too. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose you create a few dozen objects, each of which is an instance of
    the Object class. Naturally they all have access to inherited methods such as
    `inspect` and `class`. But now you decide that you want just one special object
    (for the sake of variety, let’s call him `ob`), which has one special method (let’s
    call it `blather`).
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to define a whole new class for this one object since you will
    never again create any more objects with the `blather` method. So, you create
    a class especially for little `ob`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to name this class. You just tell it to attach itself to `ob`
    by putting a `<<` between the keyword `class` and the name of the object. Then
    you add code to the class in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_class.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `ob`, and only `ob`, has not only all the usual methods of the Object class;
    it also has the methods (here just the `blather` method, but there could, in principle,
    be many more) of its own special anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’ve been paying close attention, you might have noticed that the singleton
    class seems to be doing something rather similar to a singleton method. With a
    singleton class, I can create an object and then add extra methods packaged up
    inside an anonymous class. With singleton methods, I can create an object and
    then add methods one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_class2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, I could rewrite the “star prize” program. In the previous version
    I added a singleton method, `congratulate`, to an object named `starprize`. I
    could just as easily have created a singleton class containing the `congratulate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the similarity is more than skin deep. The end result of the previous
    code is that `congratulate` becomes a singleton method of `starprize`. I can verify
    this by checking whether the array of singleton methods available for the `item`
    object contains the name `congratulate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby 1.9, the `singleton_methods` method returns an array of symbols representing
    the method names. This is why I have used the symbol `:congratulate` in the previous
    code. However, in Ruby 1.8, `singleton_methods` returns an array of strings. So,
    if you are using Ruby 1.8, you should be sure to use the following test using
    the string argument `"congratulate"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s the difference between a singleton method and a singleton class? The
    short answer is, not a lot. These two syntaxes provide different ways of adding
    methods to a specific object rather than building those methods into its defining
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you may want to redefine a method that already exists in some class.
    You’ve done this before when, for example, you created classes with their own
    `to_s` methods to return a string representation. Every Ruby class, from Object
    downward, has a `to_s` method. The `to_s` method of the Object class returns the
    class name and a hexadecimal representation of the object’s unique identifier.
    However, many Ruby classes have their own special versions of `to_s`. For example,
    `Array.to_s` concatenates and returns the values in the array.
  prefs: []
  type: TYPE_NORMAL
- en: When a method in one class replaces a method of the same name in an ancestor
    class, it is said to *override* that method. You can override methods that are
    defined in the standard class library such as `to_s` as well as methods defined
    in your own classes. If you need to add new behavior to an existing method, remember
    to call the superclass’s method using the `super` keyword at the start of the
    overridden method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*override.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Public, Protected, and Private Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you may want to restrict the “visibility” of your methods to
    ensure that they cannot be called by code outside the class in which the methods
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: This may be useful when your class defines various “utility” methods that it
    requires in order to perform certain functions that it does not intend for public
    consumption. By imposing access restrictions on those methods, you can prevent
    programmers from using them for their own nefarious purposes. This means you will
    be able to change the implementation of those methods at a later stage without
    having to worry you are going to break somebody else’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby provides three levels of method accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name suggests, public methods are the most accessible, and private methods
    are the least accessible. All your methods are public unless you specify otherwise.
    When a method is public, it is available to be used by the world outside the object
    in whose class it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is private, it can be used only by other methods inside the object
    in whose class it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'A protected method generally works in the same way as a private method with
    one tiny but important difference: In addition to being visible to the methods
    of the current object, a protected method is also visible to objects of the same
    type when the second object is within the scope of the first object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction between private and protected methods will probably be easier
    to understand when you see a working example. Consider this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pub_prot_priv.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: I’ve declared three methods, one for each level of accessibility. These levels
    are set by putting `private`, `protected`, or `public` prior to one or more methods.
    The specified accessibility level remains in force for all subsequent methods
    until some other access level is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`public`, `private`, and `protected` may look like keywords. But they are,
    in fact, methods of the Module class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, my class has a public method, `useOb`, which takes a `MyOb` object
    as an argument and calls the three methods `pub`, `prot`, and `priv` of that object.
    Now, let’s see how a `MyClass` object can be used. First, I’ll create two instances
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I try to call each of the three methods in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous, it would seem that the public method is (as expected) visible
    from the world outside the object to which it applies. But both the private and
    the protected methods are invisible. This being so, what is the protected method
    for? Another example should help clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, I am calling the public method `useOb` of the `myob` object, and
    I am passing to it a second object, `myob2`, as an argument. The important thing
    to note is that `myob` and `myob2` are instances of the same class. Now, recall
    what I said earlier: *In addition to being visible to the methods of the current
    object, a protected method is also visible to objects of the same type when the
    second object is within the scope of the first object*.'
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like gobbledygook. Let’s see if I can make some sense out of
    it. In the program, the first MyClass object (here `myob`) has a second MyClass
    object within its scope when `myob2` is passed as an argument to a method of `myob`.
    When this happens, you can think of `myob2` as being present “inside” `myob`.
    Now `myob2` shares the scope of the “containing” object, `myob`. In this special
    circumstance—when two objects of the same class are within the scope defined by
    that class—the protected methods of any objects of this class become visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the present case, the protected method `prot` of the object `myob2` (or,
    at any rate, of the argument that “receives” `myob2`, here called `anob`) becomes
    visible and can be executed. Its private arguments, however, are not visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Here you will learn more about the visibility of code inside methods and another
    way of defining singleton methods.
  prefs: []
  type: TYPE_NORMAL
- en: Protected and Private Methods in Descendant Classes
  prefs: []
  type: TYPE_NORMAL
- en: The same access rules described in this chapter also apply when calling the
    methods of ancestor and descendant objects. That is, when you pass an object to
    a method (as an argument) that has the same class as the receiver object (in other
    words, the object to which the method belongs), the argument object can call the
    public and protected methods of the class but not its private methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of this, take a look at the *protected.rb* program. Here I have
    created a MyClass object called `myob` and a MyOtherClass object, `myotherob`,
    where MyOtherClass descends from MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: '*protected.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'I now create objects from each of these three classes, and I try to pass `myotherob`
    as an argument to the `myob` public method, `shout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you load this program from the code archive, you will see that it contains
    a number of lines of code in which these three objects attempt to execute the
    `shout` and `exclaim` methods. Many of these attempts are doomed to failure and
    so have been commented out. However, when testing the code, you may want to uncomment
    each method call one by one to see the results. This is my first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `shout` method calls the private method `priv` on the argument object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This won’t work! Ruby complains that the `priv` method is private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, were I to do it the other way around—that is, by passing the ancestor
    object `myob` as the argument and invoking the method `shout` on the descendant
    object—I would encounter the same error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The MyClass class also has another public method, `exclaim`. This one calls
    a protected method, `prot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I can pass either the MyClass object, `myob`, or the MyOtherClass object,
    `myotherob`, as an argument to the `exclaim` method, and no error will occur when
    the protected method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, this works only when the two objects (the receiver object to
    the left of the dot and the argument passed to the method) share the same line
    of descent. If you send an unrelated object as an argument, you would not be able
    to call methods of the receiver class, no matter what their protection levels.
  prefs: []
  type: TYPE_NORMAL
- en: Invading the Privacy of Private Methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole point of a private method is that it cannot be called from outside
    the scope of the object to which it belongs. So, this won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '*send.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: However, it turns out that Ruby provides a “get out clause” (or maybe I should
    say a “get in” clause?) in the form of a method called `send`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `send` method invokes the method whose name matches that of a symbol (an
    identifier beginning with a colon such as `:priv`), which is passed as the first
    argument to `send` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Any arguments supplied after the symbol (like the string “hello”) are passed
    in the normal way to the specified method.
  prefs: []
  type: TYPE_NORMAL
- en: Using `send` to gain public access to a private method is not generally a good
    idea. After all, if you need access to a certain method, why make it private in
    the first place? Use this technique with caution or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Class Methods
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I created class methods by appending a method name to the name of
    the class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a “shortcut” syntax for doing this. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*class_methods3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `methodA`, `methodB`, and `methodC` are all class methods of MyClass;
    `methodA` is declared using the syntax used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'But `methodB` and `methodC` are declared using the syntax of instance methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'So, why do they end up as class methods? It’s all because the method declarations
    have been placed inside this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This may remind you of the syntax used for declaring singleton classes. For
    example, in the *singleton_class.rb* program, you may recall that I first created
    an object named `ob` and then gave it its very own method, `blather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `blather` method here is a singleton method of the `ob` object. Similarly,
    in the *class_methods3.rb* program, the `methodB` and `methodC` methods are singleton
    methods of `self`—and `self` happens to be the MyClass class. You can similarly
    add singleton methods from outside the class definition by using `<<` followed
    by the class name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the code checks that all four methods really are singleton methods
    by first printing the names of all available singleton methods and then calling
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Nested Methods
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest methods; that is, you can write methods that contain other methods.
    This gives you a way of dividing a long method into reusable chunks. So, for example,
    if method `x` needs to do calculation `y` at several different points, you can
    put the `y` method inside the `x` method (the methods in the following example
    are called `outer_x`, `nested_y`, and `nested_z` for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '*nested_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested methods are not initially visible outside the scope in which they are
    defined. So, in the previous example, although `nested_y` and `nested_z` may be
    called from inside `outer_x`, they may not be called by any other code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If, instead of `ob.outer_x` in the previous code, you were to call `ob.nested_y`
    or `ob.nested_z`, you would see an error message since the `nested_y` and `nested_z`
    methods would not, at this stage, be visible. However, when you run a method that
    encloses nested methods, those nested methods *will* be brought into scope outside
    that method!
  prefs: []
  type: TYPE_NORMAL
- en: '*nested_methods2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To see another example of this, try running the *nested_methods.rb* code again,
    but this time uncomment all three method calls. This time, when the `outer_x`
    method executes, it brings `nested_y` and `nested_z` into scope so the calls to
    the two nested methods now succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Method Names
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final point, it’s worth mentioning that method names in Ruby almost always
    begin with a lowercase character like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that is a *convention*, not an *obligation*. It is also permissible
    to begin method names with capital letters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Fred` method looks like a constant (it starts with a capital letter),
    you would need to tell Ruby that it is a method when calling it by adding parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '*method_names.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: On the whole, it is better to stick to the convention of using method names
    that begin with a lowercase character.
  prefs: []
  type: TYPE_NORMAL
