- en: Chapter 7. Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。方法
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: You’ve used numerous methods throughout this book. On the whole, they aren’t
    particularly complicated things, so you may wonder why this chapter, which is
    all about methods, is so long. As you will discover, there is much more to methods
    than meets the eye.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中使用了无数的方法。总的来说，它们并不特别复杂，所以你可能想知道为什么关于方法的这一章这么长。正如你将发现的，方法远比表面看起来要复杂得多。
- en: Class Methods
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: The methods you’ve been using so far have been *instance methods*. An instance
    method belongs to a specific instance of a class—in other words, to an individual
    object. It is also possible to write *class methods*. (Some other languages refer
    to this kind of method as a static method.) A class method belongs to the class
    itself. To define a class method, you must precede the method name with the class
    name and a full stop.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止使用的方法都是 *实例方法*。实例方法属于类的特定实例——换句话说，属于单个对象。你也可以编写 *类方法*。（其他一些语言将这种方法称为静态方法。）类方法属于类本身。要定义类方法，必须在方法名前加上类名和句点。
- en: '*class_methods1.rb*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_methods1.rb*'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should use the class name when calling a class method:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用类方法时，你应该使用类名：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A specific object cannot call a class method. Nor can a class call an instance
    method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的对象不能调用类方法。同样，类也不能调用实例方法：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What Are Class Methods For?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法的作用是什么？
- en: 'But why, you may reasonably ask, would you ever want to create a class method
    rather than the more usual instance method? There are two main reasons: First,
    a class method can be used as a “ready-to-run function” without having to go to
    the bother of creating an object just to use it, and second, it can be used on
    those occasions when you need to run a method before an object has been created.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可能会合理地问，为什么你想要创建一个类方法而不是更常见的实例方法？主要有两个原因：首先，类方法可以用作“即用函数”而无需麻烦地创建一个对象来使用，其次，它可以在需要在使用对象之前就运行方法的情况下使用。
- en: 'For a few examples of using methods as “ready-to-run functions,” consider Ruby’s
    File class. Many of its methods are class methods. This is because most of the
    time you will be using them to do something to, or return information about, an
    existing file. You don’t need to create a new File object to do that; instead,
    you pass the filename as an argument to the File class methods. You’ll look more
    closely at the File class in [Chapter 13](ch13.html "Chapter 13. Files and IO").
    Here are examples of a few of its class methods in use:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 举几个将方法作为“即用函数”使用的例子，可以考虑 Ruby 的 File 类。它的大多数方法都是类方法。这是因为大多数时候，你会使用它们对现有文件进行操作或返回有关文件的信息。你不需要创建一个新的
    File 对象来做这件事；相反，你将文件名作为参数传递给 File 类的方法。你将在第 13 章（[第 13 章。文件和 IO](ch13.html "第
    13 章。文件和 IO")）中更详细地了解 File 类。以下是它的一些类方法使用示例：
- en: '*file_methods.rb*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_methods.rb*'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This outputs something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出类似以下的内容：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other occasion when a class method is vital is when you need to use a method
    before an object has been created. The most important example of this is the `new`
    method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要在使用对象之前就使用一个方法时，类方法至关重要。这个例子中最重要的是 `new` 方法。
- en: You call the `new` method every time you create an object. Until the object
    has been created, you clearly cannot call one of its instance methods—because
    you can call instance methods only from an object that already exists. When you
    use `new`, you are calling a method of the class itself and telling the class
    to create a new instance of itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你每次创建对象时都会调用 `new` 方法。在对象被创建之前，显然你不能调用其实例方法——因为只能从已经存在的对象中调用实例方法。当你使用 `new`
    时，你是在调用类本身的方法，并告诉类创建一个新的实例。
- en: Class Variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类变量
- en: 'Class methods may remind you of the class variables you used previously (that
    is, variables whose names begin with `@@`). You may recall that you used class
    variables in a simple adventure game (see *2adventure.rb* in [Attribute Readers
    and Writers](ch02s04.html "Attribute Readers and Writers")) to keep a tally of
    the total number of objects in the game; each time a new Thing object was created,
    1 was added to the `@@num_things` class variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法可能会让你想起之前使用的类变量（即，以 `@@` 开头的变量）。你可能记得，你曾在简单的冒险游戏中使用类变量（见 [属性读取器和写入器](ch02s04.html
    "属性读取器和写入器") 中的 *2adventure.rb*）来统计游戏中对象的总数；每次创建一个新的 Thing 对象时，`@@num_things`
    类变量就增加 1：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unlike an instance variable (that is, a variable that belongs to a specific
    object created from a class), a class variable must be given a value when it is
    first declared:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例变量（即属于从类创建的特定对象的变量）不同，类变量在首次声明时必须赋予一个值：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Initialization of either instance or class variables within the body of the
    class affects only the values stored by the class itself. Class variables are
    available both to the class itself and to the objects created from that class.
    However, each instance variable is unique; each object has its own copy of any
    instance variables—*and the class itself may also have its own instance variables*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在类体内部初始化实例或类变量只会影响类本身存储的值。类变量对类本身以及从该类创建的对象都是可用的。然而，每个实例变量都是唯一的；每个对象都有其自己的任何实例变量的副本——*类本身也可能有自己的实例变量*。
- en: 'Class Variables, Instance Variables, and Methods: Summary'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量、实例变量和方法：总结
- en: 'Instance variables begin with `@`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量以 `@` 开头：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Class variables begin with `@@`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量以 `@@` 开头：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instance methods are defined by `def` *`MethodName`*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法通过 `def` *`MethodName`* 定义：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Class methods are defined by `def` *`ClassName`*.*`MethodName`*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法通过 `def` *`ClassName`*.*`MethodName`* 定义：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To understand how a class may have instance variables, refer to the *class_methods2.rb*
    program. This defines a class containing one class method and one instance method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解一个类可能有哪些实例变量，请参考 *class_methods2.rb* 程序。该程序定义了一个包含一个类方法和一个实例方法的类：
- en: '*class_methods2.rb*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_methods2.rb*'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that it declares and initializes a class variable and an instance variable,
    `@@classvar` and `@instvar`, respectively. Its class method, `classMethod`, increments
    both these variables by 10, while its instance method, `instanceMethod`, increments
    both variables by 1\. Notice that I have assigned values to both the class variable
    and the instance variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它分别声明并初始化了一个类变量和一个实例变量，`@@classvar` 和 `@instvar`。它的类方法 `classMethod` 将这两个变量都增加10，而它的实例方法
    `instanceMethod` 将这两个变量各增加1。注意，我已经为类变量和实例变量都赋值了：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I said earlier that initial values are not normally assigned to instance variables
    in this way. The exception to the rule is when you assign a value to an instance
    variable *of the class itself* rather than to an object derived from that class.
    The distinction should become clearer shortly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，通常不会以这种方式为实例变量分配初始值。这个规则的例外是当你为类的实例变量而不是从该类派生的对象分配一个值时。这个区别很快就会变得清楚。
- en: 'I’ve written a few lines of code that create three instances of MyClass (the
    `ob` variable is initialized with a new instance on each turn through the loop)
    and then call both the class and instance methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一些代码，创建了 MyClass 的三个实例（`ob` 变量在循环的每次迭代中初始化为一个新的实例），然后调用了类方法和实例方法：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The class method, `MyClass.showVars`, and the instance method, `showVars`,
    display the values of `@instvar` and `@@classvar` at each turn through the loop.
    When you run the code, these are the values displayed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `MyClass.showVars` 和实例方法 `showVars` 在每次循环迭代中显示 `@instvar` 和 `@@classvar`
    的值。当你运行代码时，显示的值如下：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may need to look at these results carefully in order to see what is going
    on here. In summary, this is what is happening: The code in both the class method,
    `MyClass.classMethod`, and the instance method, `instanceMethod`, increments both
    the class and instance variables, `@@classvar` and `@instvar`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要仔细查看这些结果，以便了解这里发生了什么。总结来说，这是正在发生的事情：在类方法 `MyClass.classMethod` 和实例方法 `instanceMethod`
    中的代码都会增加类变量和实例变量 `@@classvar` 和 `@instvar` 的值。
- en: 'You can see clearly that the class variable is incremented by both these methods
    (the class method adds 10 to `@@classvar` whenever a new object is created, while
    the instance method adds 1 to it). However, whenever a new object is created,
    its instance variable is initialized to 1 by the `instanceMethod`. This is the
    expected behavior since each object has its own copy of an instance variable,
    but all objects share a unique class variable. Perhaps less obvious is that the
    class itself also has its own instance variable, `@instvar`. This is because,
    in Ruby, a class is an object and therefore can contain instance variables, just
    like any other object. The MyClass variable, `@instvar`, is incremented by the
    class method `MyClass.classMethod`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，这两个方法（类方法在创建新对象时将10加到`@@classvar`上，而实例方法将其加1）都会增加类变量。然而，每当创建一个新对象时，它的实例变量都会由`instanceMethod`初始化为1。这是预期的行为，因为每个对象都有自己的实例变量副本，但所有对象共享一个唯一的类变量。可能不那么明显的是，类本身也有自己的实例变量，`@instvar`。这是因为，在Ruby中，类是一个对象，因此可以包含实例变量，就像任何其他对象一样。`MyClass`变量`@instvar`是由类方法`MyClass.classMethod`增加的：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the instance method, `showVars`, prints the value of `@instvar`, it prints
    the value stored in a specific object, `ob`; the value of `ob`’s `@instvar` is
    initially `nil` (*not* the value 1,000 with which the MyClass variable `@instvar`
    was initialized), and this value is incremented by 1 in `instanceMethod`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例方法`showVars`打印`@instvar`的值时，它打印的是存储在特定对象`ob`中的值；`ob`的`@instvar`的初始值是`nil`（不是`MyClass`变量`@instvar`初始化时的1,000），这个值在`instanceMethod`中被增加1。
- en: When the class method, `MyClass.showVars`, prints the value of `@instvar`, it
    prints the value stored in the class itself (in other words, MyClass’s `@instvar`
    *is a different variable* from `ob`’s `@instvar`). But when either method prints
    the value of the class variable, `@@classvar`, the value is the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当类方法`MyClass.showVars`打印`@instvar`的值时，它打印的是存储在类本身中的值（换句话说，MyClass的`@instvar`与`ob`的`@instvar`是不同的变量）。但当任一方法打印类变量`@@classvar`的值时，值是相同的。
- en: 'Just remember that there is only ever one copy of a class variable, but there
    may be many copies of instance variables. If this is still confusing, take a look
    at the *inst_vars.rb* program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，类变量只有一个副本，但实例变量可能有多个副本。如果这仍然让你感到困惑，请查看`*inst_vars.rb*`程序：
- en: '*inst_vars.rb*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*inst_vars.rb*'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, instead of creating a new object instance at each turn through the
    loop, you create a single instance (`ob`) at the outset. When the `ob.instanceMethod`
    is called, `@instvar` is incremented by 1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你不再在循环的每次迭代中创建新的对象实例，而是在一开始就创建一个单独的实例(`ob`)。当调用`ob.instanceMethod`时，`@instvar`增加1。
- en: 'Here I’ve used a little trick to look inside the class and method and retrieve
    the value of `@instvar` using Ruby’s `instance_variable_get` method (I’ll return
    to this when I cover dynamic programming in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了一个小技巧来查看类和方法内部，并使用Ruby的`instance_variable_get`方法检索`@instvar`的值（当我介绍动态规划时，我会回到这个话题[第20章](ch20.html
    "第20章。动态规划"))：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because you only ever increment the `@instvar` that belongs to the object `ob`,
    the value of its `@instvar` goes up from 1 to 3 as the `for` loop executes. But
    the `@instvar` that belongs to the MyClass class is never incremented; it remains
    at its initial value of 1,000:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有当你增加属于对象`ob`的`@instvar`时，它的`@instvar`值才会从1增加到3，这是`for`循环执行的结果。但属于`MyClass`类的`@instvar`永远不会增加；它保持在初始值1,000：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But now let’s uncomment this line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们取消注释这一行：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This calls a class method that increments `@instvar` by 10\. This time when
    you run the program, you see that, as before, the `@instvar` variable of `ob`
    is incremented by 1 on each turn through the loop, while the `@instvar` variable
    of MyClass is incremented by 10:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了一个类方法，该方法将`@instvar`增加10。这次当你运行程序时，你会看到，就像之前一样，`ob`的`@instvar`变量在每次循环迭代时增加1，而`MyClass`的`@instvar`变量增加10：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A Class Is an Object
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个对象
- en: 'To understand instance variables of classes, just remember that a class is
    an object (actually, it’s an instance of the `Class` class!). The MyClass “class
    object” has its own instance variable (`@instvar`) just as the `ob` object has
    its own instance variable (which here also happens to be called `@instvar`). In
    spite of the same names, these are two different variables: One belongs to the
    class itself; the other belongs inside each object created from the class. Instance
    variables are always unique to an object instance, so no two objects (not even
    an object like MyClass, which also happens to be a class!) can ever share a single
    instance variable.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解类的实例变量，只需记住一个类是一个对象（实际上，它是 `Class` 类的一个实例！）MyClass “类对象”有自己的实例变量（`@instvar`），就像
    `ob` 对象有自己的实例变量一样（这里也恰好也叫做 `@instvar`）。尽管名字相同，但这两个变量是不同的：一个属于类本身；另一个属于从该类创建的每个对象内部。实例变量始终是对象实例独有的，因此没有任何两个对象（甚至是一个像
    MyClass 这样的对象，它也恰好是一个类！）可以共享单个实例变量。
- en: 'Ruby Constructors: new or initialize?'
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 构造器：new 还是 initialize？
- en: I gave a brief explanation of `new` and `initialize` in [Chapter 1](ch01.html
    "Chapter 1. Strings, Numbers, Classes, and Objects"). At that stage, you had not
    examined the differences between Ruby’s class and instance methods and variables,
    so it was not possible to give a full discussion of how `new` and `initialize`
    work together. Because these are such important methods, you’ll look at them in
    more detail now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第一章](ch01.html "第一章。字符串、数字、类和对象") 中，我对 `new` 和 `initialize` 方法进行了简要的解释。在那个阶段，你还没有检查
    Ruby 的类方法和实例方法以及变量的区别，因此无法全面讨论 `new` 和 `initialize` 如何协同工作。因为这些方法非常重要，所以现在我们将更详细地研究它们。
- en: The method responsible for bringing an object into being is called the *constructor*.
    In Ruby, the constructor method is called `new`. The `new` method is a class method
    that, once it has created an object, will run an instance method named `initialize`
    if such a method exists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 负责创建对象的那个方法被称为 *构造器*。在 Ruby 中，构造器方法叫做 `new`。`new` 方法是一个类方法，一旦它创建了一个对象，如果存在这样的方法，它将运行一个名为
    `initialize` 的实例方法。
- en: 'In brief then, the `new` method is the constructor, and the `initialize` method
    is used to initialize the values of any variables immediately after an object
    is created. But why can’t you just write your own `new` method and initialize
    variables in it? Well, let’s try that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`new` 方法是构造器，而 `initialize` 方法用于在对象创建后立即初始化任何变量的值。但为什么你不能只是编写自己的 `new`
    方法并在其中初始化变量呢？好吧，让我们试试：
- en: '*new.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*new.rb*'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, I’ve written a `MyClass.new` method that begins with the `super` keyword
    to invoke the `new` method of its superclass. Then I’ve created a string instance
    variable, `@anewvar`. So what do I end up with? Not, as you might suppose, a new
    MyClass object containing a string variable. Remember that the last expression
    evaluated by a method in Ruby is the value returned by that method. The last expression
    evaluated by the `new` method here is a string. I evaluate this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我编写了一个以 `super` 关键字开始的 `MyClass.new` 方法，以调用其超类的 `new` 方法。然后我创建了一个字符串实例变量，`@anewvar`。那么我最终得到了什么？不是，正如你可能想象的那样，一个包含字符串变量的新
    MyClass 对象。记住，在 Ruby 中，方法最后评估的表达式是该方法的返回值。这里 `new` 方法最后评估的表达式是一个字符串。我评估这个：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And I display the newly created `ob` object and its class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了新创建的 `ob` 对象及其类：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出结果：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This proves that `MyClass.new` returns a string, and it is this string (*not*
    a MyClass object) that is assigned to the variable `ob`. If you find this confusing,
    don’t panic. The moral of the story is that overriding `new` *is* confusing and
    is generally a bad idea. Unless you have a very good reason for doing so, you
    should avoid trying to override the `new` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了 `MyClass.new` 返回一个字符串，并且这个字符串（*而不是* MyClass 对象）被分配给了变量 `ob`。如果你觉得这很困惑，不要慌张。这个故事的意义在于，覆盖
    `new` *确实* 是令人困惑的，通常不是一个好主意。除非你有非常充分的理由这样做，否则你应该避免尝试覆盖 `new` 方法。
- en: Singleton Methods
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例方法
- en: 'A singleton method is a method that belongs to a single object rather than
    to an entire class. Many of the methods in the Ruby class library are singleton
    methods. This is because, as mentioned earlier, each class is an object of the
    type Class. Or, to put it simply, the class of every class is Class. This is true
    of all classes—both those you define yourself and those provided by the Ruby class
    library:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单例方法是一个属于单个对象而不是整个类的方法。Ruby类库中的许多方法都是单例方法。这是因为，如前所述，每个类都是Class类型的一个对象。或者，简单地说，每个类的类是Class。这对所有类都适用——无论是你自己定义的还是Ruby类库提供的：
- en: '*class_classes.rb*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_classes.rb*'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, some classes also have class methods—that is, methods that belong to the
    Class object itself. In that sense, these are singleton methods of the Class object.
    Indeed, if you evaluate the following, you will be shown an array of method names
    that match the names of IO class methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些类也有类方法——即属于Class对象本身的方法。从某种意义上说，这些是Class对象的单例方法。确实，如果你评估以下内容，你会看到一个与IO类方法名称匹配的方法名称数组：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This displays the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As explained earlier, when you write your own class methods, you do so by prefacing
    the method name with the name of the class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你编写自己的类方法时，你通过在方法名前加上类的名称来这样做：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It turns out that you can use a similar syntax when creating singleton classes
    for specific objects. This time you preface the method name with the name of the
    object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在创建特定对象的单例类时，你可以使用类似的语法。这次，你需要在方法名前加上对象名：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finding an Object’s Ancestor Classes
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查找对象的祖先类
- en: 'Ultimately all classes descend from the Object class. In Ruby 1.9, the Object
    class itself descends from the BasicObject class (see [Chapter 2](ch02.html "Chapter 2. Class
    Hierarchies, Attributes, and Class Variables")). This is true even for the `Class`
    class! To prove this, try the *class_hierarchy.rb* program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，所有类都从Object类派生。在Ruby 1.9中，Object类本身是从BasicObject类派生的（参见[第2章](ch02.html "第2章。类层次结构、属性和类变量")）。即使是`Class`类也是如此！为了证明这一点，尝试运行*class_hierarchy.rb*程序：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Pass a class name to this method to track back up its family tree of ancestor
    classes. For example, try this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将类名传递给此方法以追踪其祖先类的家族树。例如，尝试这样做：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In Ruby 1.9, this displays the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby 1.9中，这将显示以下内容：
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*class_hierarchy.rb*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_hierarchy.rb*'
- en: Let’s look at a concrete example. Suppose you have a program containing Creature
    objects of many different species (maybe you are a veterinarian, the head keeper
    at a zoo, or, like the author of this book, an enthusiastic player of adventure
    games); each creature has a method called `talk` that displays the vocal noise
    each creature usually makes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子。假设你有一个包含许多不同物种的Creature对象的程序（也许你是一位兽医，动物园的负责人，或者像本书的作者一样，是一位热情的冒险游戏玩家）；每个生物都有一个名为`talk`的方法，用于显示每个生物通常发出的声音。
- en: 'Here’s my Creature class and a few creature objects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的Creature类和一些生物对象：
- en: '*singleton_meth1.rb*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_meth1.rb*'
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then you suddenly realize that one of those creatures, and one alone, has additional
    special behavior. On the night of a full moon, the werewolf not only talks (“growl”)
    but also howls (“How-oo-oo-oo-oo!”). It really needs a `howl` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，你意识到这些生物中只有一个具有额外的特殊行为。在满月之夜，狼人不仅会说话（“咆哮”），还会嗥叫（“How-oo-oo-oo-oo！”）。它真的需要一个`howl`方法。
- en: 'You could go back and add such a method to the Creature class, but then you’d
    end up with howling dogs, cats, and budgies too—which is not what you want. You
    could create a new Werewolf class that descends from Creature, but you will only
    ever have one werewolf (they are, alas, an endangered species), so why do you
    want a whole class for just that? Wouldn’t it make more sense to have a werewolf
    *object* that is the same as every other creature object except that it also has
    a `howl` method? Okay, let’s do that by giving the werewolf its very own singleton
    method. Here goes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这样的方法添加到Creature类中，但最终你会得到嗥叫的狗、猫和鹦鹉——这并不是你想要的。你可以创建一个新的从Creature派生的Werewolf类，但你将永远只有一个狼人（遗憾的是，它们是一种濒危物种），所以为什么你需要一个整个类来代表它呢？难道不是更有意义有一个与所有其他生物对象相同的狼人*对象*，除了它还有一个`howl`方法吗？好吧，让我们通过给狼人一个它自己的单例方法来实现这一点。下面是操作步骤：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Heck, you can do better than that! It howls only on a full moon, so let’s make
    sure that, if asked to howl when the moon is new, it just growls. Here’s my finished
    method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，你可以做得更好！它只在满月时嗥叫，所以让我们确保，如果月亮是新的，它只是咆哮。这是我的完成方法：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that, even though this method has been declared outside the Creature
    class, it is able to call the instance method `talk`. That’s because the `howl`
    method now lives “inside” the werewolf object so has the same scope within that
    object as the `talk` method. It does not, however, live inside any of the werewolf’s
    fellow creatures; the `howl` method belongs to him and him alone. Try to make
    the `budgie.howl`, and Ruby will inform you that `howl` is an undefined method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这个方法是在Creature类外部声明的，但它仍然能够调用实例方法`talk`。这是因为`howl`方法现在“位于”狼人对象内部，因此在那个对象内部与`talk`方法具有相同的范围。然而，它并不位于狼人同伴的任何地方；`howl`方法只属于他一个人。尝试调用`budgie.howl`，Ruby会告诉你`howl`是一个未定义的方法。
- en: Now, if you are debugging your code for your own use, having your program blow
    up thanks to an undefined method may be acceptable; however, if your program does
    so out in the big, bad world of the “end user,” it is definitely *not* acceptable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你正在为自己的代码进行调试，由于未定义的方法而导致程序崩溃可能是可以接受的；然而，如果你的程序在“最终用户”的广阔、恶劣的世界中这样做，这绝对是不可以接受的。
- en: 'If you think undefined methods are likely to be a problem, you can take avoidance
    measures by testing whether a singleton method exists before trying to use it.
    The Object class has a `singleton_methods` method that returns an array of singleton
    method names. You can test a method name for inclusion using the Array class’s
    `include?` method. In *singleton_meth2.rb*, for example, I’ve programmed an “open
    the box” game, which has a number of Box objects, only one of which, when opened,
    contains the star prize. I’ve named this special Box object `starprize` and given
    it a singleton method called `congratulate`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为未定义的方法可能会成为问题，你可以在尝试使用它之前通过测试单例方法是否存在来采取避免措施。Object类有一个`singleton_methods`方法，它返回一个包含单例方法名称的数组。你可以使用Array类的`include?`方法测试一个方法名称是否包含。例如，在*singleton_meth2.rb*中，我编写了一个“打开盒子”游戏，其中包含多个Box对象，只有一个盒子打开时包含奖品。我给这个特殊盒子对象命名为`starprize`，并给它添加了一个名为`congratulate`的单例方法：
- en: '*singleton_meth2.rb*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_meth2.rb*'
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `congratulate` method should be called when the `starprize` box is opened.
    This bit of code (in which `item` is a Box object) ensures that this method (which
    does not exist in any other object) is not called when some other box is opened:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当`starprize`盒子被打开时，应该调用`congratulate`方法。这段代码（其中`item`是一个Box对象）确保当打开其他盒子时，不会调用这个方法（它不存在于任何其他对象中）：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An alternative way of checking the validity of a method would be to pass that
    method name as a symbol (an identifier preceded by a colon) to the Object class’s
    `respond_to?` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检查方法有效性的另一种方式是将该方法名称作为符号（一个以冒号开头的标识符）传递给Object类的`respond_to?`方法：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see another way of handling nonexistent methods in [Chapter 20](ch20.html
    "Chapter 20. Dynamic Programming").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第20章](ch20.html "第20章。动态规划")中看到处理不存在方法的另一种方法。
- en: Singleton Classes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例类
- en: A singleton method is a method that belongs to a single object. A singleton
    class, on the other hand, is a class that defines a single object. Confused? Me
    too. Let’s take a closer look.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单例方法是一个属于单个对象的方法。另一方面，单例类是一个定义单个对象的类。困惑？我也是。让我们更仔细地看看。
- en: Let’s suppose you create a few dozen objects, each of which is an instance of
    the Object class. Naturally they all have access to inherited methods such as
    `inspect` and `class`. But now you decide that you want just one special object
    (for the sake of variety, let’s call him `ob`), which has one special method (let’s
    call it `blather`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了数十个对象，每个对象都是Object类的一个实例。自然地，它们都可以访问继承的方法，例如`inspect`和`class`。但现在你决定你只想有一个特殊对象（为了多样性，让我们称他为`ob`），它有一个特殊的方法（让我们称它为`blather`）。
- en: You don’t want to define a whole new class for this one object since you will
    never again create any more objects with the `blather` method. So, you create
    a class especially for little `ob`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想为这个单一对象定义一个全新的类，因为你永远不会再次创建任何具有`blather`方法的更多对象。所以，你创建了一个专门为小`ob`设计的类。
- en: 'You don’t need to name this class. You just tell it to attach itself to `ob`
    by putting a `<<` between the keyword `class` and the name of the object. Then
    you add code to the class in the usual way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要给这个类命名。你只需通过在`class`关键字和对象名称之间放置一个`<<`来告诉它将自己附加到`ob`上。然后你以通常的方式向这个类中添加代码：
- en: '*singleton_class.rb*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_class.rb*'
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now `ob`, and only `ob`, has not only all the usual methods of the Object class;
    it also has the methods (here just the `blather` method, but there could, in principle,
    be many more) of its own special anonymous class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ob`，只有 `ob`，不仅具有 Object 类的所有常规方法；它还具有它自己的特殊匿名类的方法（这里只是 `blather` 方法，原则上可以有更多）：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you’ve been paying close attention, you might have noticed that the singleton
    class seems to be doing something rather similar to a singleton method. With a
    singleton class, I can create an object and then add extra methods packaged up
    inside an anonymous class. With singleton methods, I can create an object and
    then add methods one by one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直很注意，你可能已经注意到单例类似乎在做与单例方法非常相似的事情。使用单例类，我可以创建一个对象，然后添加封装在匿名类中的额外方法。使用单例方法，我可以创建一个对象，然后逐个添加方法：
- en: '*singleton_class2.rb*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_class2.rb*'
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, I could rewrite the “star prize” program. In the previous version
    I added a singleton method, `congratulate`, to an object named `starprize`. I
    could just as easily have created a singleton class containing the `congratulate`
    method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我可以重写“star prize”程序。在前一个版本中，我为名为 `starprize` 的对象添加了一个单例方法 `congratulate`。我同样可以创建一个包含
    `congratulate` 方法的单例类：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In fact, the similarity is more than skin deep. The end result of the previous
    code is that `congratulate` becomes a singleton method of `starprize`. I can verify
    this by checking whether the array of singleton methods available for the `item`
    object contains the name `congratulate`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种相似性远不止表面。前述代码的最终结果是 `congratulate` 成为了 `starprize` 的单例方法。我可以通过检查 `item`
    对象可用的单例方法数组是否包含名称 `congratulate` 来验证这一点：
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Ruby 1.9, the `singleton_methods` method returns an array of symbols representing
    the method names. This is why I have used the symbol `:congratulate` in the previous
    code. However, in Ruby 1.8, `singleton_methods` returns an array of strings. So,
    if you are using Ruby 1.8, you should be sure to use the following test using
    the string argument `"congratulate"`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 中，`singleton_methods` 方法返回一个表示方法名的符号数组。这就是为什么我在前面的代码中使用符号 `:congratulate`。然而，在
    Ruby 1.8 中，`singleton_methods` 返回一个字符串数组。所以，如果你使用 Ruby 1.8，你应该确保使用以下使用字符串参数 `"congratulate"`
    的测试：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What’s the difference between a singleton method and a singleton class? The
    short answer is, not a lot. These two syntaxes provide different ways of adding
    methods to a specific object rather than building those methods into its defining
    class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单例方法和单例类之间的区别是什么？简短的回答是，没有太多区别。这两个语法提供了向特定对象添加方法的不同方式，而不是将这些方法构建到其定义类中。
- en: Overriding Methods
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写方法
- en: Sometimes you may want to redefine a method that already exists in some class.
    You’ve done this before when, for example, you created classes with their own
    `to_s` methods to return a string representation. Every Ruby class, from Object
    downward, has a `to_s` method. The `to_s` method of the Object class returns the
    class name and a hexadecimal representation of the object’s unique identifier.
    However, many Ruby classes have their own special versions of `to_s`. For example,
    `Array.to_s` concatenates and returns the values in the array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想重新定义某个类中已经存在的方法。你之前已经这样做过了，例如，当你创建了具有自己的 `to_s` 方法的类以返回字符串表示时。从 Object
    类向下，每个 Ruby 类都有一个 `to_s` 方法。Object 类的 `to_s` 方法返回类名和对象的唯一标识符的十六进制表示。然而，许多 Ruby
    类都有自己的特殊版本的 `to_s`。例如，`Array.to_s` 连接并返回数组中的值。
- en: When a method in one class replaces a method of the same name in an ancestor
    class, it is said to *override* that method. You can override methods that are
    defined in the standard class library such as `to_s` as well as methods defined
    in your own classes. If you need to add new behavior to an existing method, remember
    to call the superclass’s method using the `super` keyword at the start of the
    overridden method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类中的方法替换了祖先类中同名的那个方法时，我们称其为*重写*该方法。你可以重写标准类库中定义的方法，如`to_s`，以及你自己的类中定义的方法。如果你需要向现有方法添加新行为，记得在重写方法的开头使用`super`关键字调用超类的方法。
- en: 'Here is an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '*override.rb*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*override.rb*'
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Public, Protected, and Private Methods
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共、受保护和私有方法
- en: In some cases, you may want to restrict the “visibility” of your methods to
    ensure that they cannot be called by code outside the class in which the methods
    occur.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想限制你方法的“可见性”，以确保它们不能被出现在方法中的类外部的代码调用。
- en: This may be useful when your class defines various “utility” methods that it
    requires in order to perform certain functions that it does not intend for public
    consumption. By imposing access restrictions on those methods, you can prevent
    programmers from using them for their own nefarious purposes. This means you will
    be able to change the implementation of those methods at a later stage without
    having to worry you are going to break somebody else’s code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在你定义的类需要执行某些不打算公开消费的功能时很有用。通过限制这些方法的访问权限，你可以防止程序员为了自己的恶意目的使用它们。这意味着你可以在以后阶段更改这些方法的实现，而不用担心会破坏其他人的代码。
- en: 'Ruby provides three levels of method accessibility:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 提供了三种方法可访问级别：
- en: public
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: public
- en: protected
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: protected
- en: private
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: private
- en: As the name suggests, public methods are the most accessible, and private methods
    are the least accessible. All your methods are public unless you specify otherwise.
    When a method is public, it is available to be used by the world outside the object
    in whose class it is defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，公共方法是可访问性最高的，而私有方法是可访问性最低的。除非你明确指定，否则所有方法都是公共的。当一个方法是公共的，它就可以被定义其类的对象之外的世界使用。
- en: When a method is private, it can be used only by other methods inside the object
    in whose class it is defined.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法是私有的，它只能由定义其类的对象内部的其他方法使用。
- en: 'A protected method generally works in the same way as a private method with
    one tiny but important difference: In addition to being visible to the methods
    of the current object, a protected method is also visible to objects of the same
    type when the second object is within the scope of the first object.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的方法通常与私有方法以相同的方式工作，但有一个微小但重要的区别：除了对当前对象的方法可见外，当第二个对象在第一个对象的作用域内时，受保护的方法对同一类型的对象也是可见的。
- en: 'The distinction between private and protected methods will probably be easier
    to understand when you see a working example. Consider this class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到工作示例时，私有和受保护方法之间的区别可能更容易理解。考虑这个类：
- en: '*pub_prot_priv.rb*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*pub_prot_priv.rb*'
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I’ve declared three methods, one for each level of accessibility. These levels
    are set by putting `private`, `protected`, or `public` prior to one or more methods.
    The specified accessibility level remains in force for all subsequent methods
    until some other access level is specified.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我声明了三个方法，每个可访问级别一个。这些级别是通过在 `private`、`protected` 或 `public` 前放置一个或多个方法来设置的。指定的可访问级别对所有后续方法都有效，直到指定了另一个访问级别。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`public`, `private`, and `protected` may look like keywords. But they are,
    in fact, methods of the Module class.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`、`private` 和 `protected` 可能看起来像关键字。但实际上，它们是 Module 类的方法。'
- en: 'Finally, my class has a public method, `useOb`, which takes a `MyOb` object
    as an argument and calls the three methods `pub`, `prot`, and `priv` of that object.
    Now, let’s see how a `MyClass` object can be used. First, I’ll create two instances
    of the class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我的类有一个公共方法 `useOb`，它接受一个 `MyOb` 对象作为参数，并调用该对象的三个方法 `pub`、`prot` 和 `priv`。现在，让我们看看如何使用
    `MyClass` 对象。首先，我将创建该类的两个实例：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, I try to call each of the three methods in turn:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我尝试依次调用这三个方法：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From the previous, it would seem that the public method is (as expected) visible
    from the world outside the object to which it applies. But both the private and
    the protected methods are invisible. This being so, what is the protected method
    for? Another example should help clarify this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，看起来公共方法（正如预期的那样）可以从对象外部看到。但私有和受保护的方法都是不可见的。既然如此，受保护的方法有什么用？另一个例子应该有助于澄清这一点：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time, I am calling the public method `useOb` of the `myob` object, and
    I am passing to it a second object, `myob2`, as an argument. The important thing
    to note is that `myob` and `myob2` are instances of the same class. Now, recall
    what I said earlier: *In addition to being visible to the methods of the current
    object, a protected method is also visible to objects of the same type when the
    second object is within the scope of the first object*.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我正在调用 `myob` 对象的公共方法 `useOb`，并将第二个对象 `myob2` 作为参数传递给它。需要注意的是，`myob` 和 `myob2`
    是同一类的实例。现在，回想一下我之前说过的话：*除了对当前对象的方法可见外，当第二个对象在第一个对象的作用域内时，受保护的方法对同一类型的对象也是可见的*。
- en: This may sound like gobbledygook. Let’s see if I can make some sense out of
    it. In the program, the first MyClass object (here `myob`) has a second MyClass
    object within its scope when `myob2` is passed as an argument to a method of `myob`.
    When this happens, you can think of `myob2` as being present “inside” `myob`.
    Now `myob2` shares the scope of the “containing” object, `myob`. In this special
    circumstance—when two objects of the same class are within the scope defined by
    that class—the protected methods of any objects of this class become visible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是胡言乱语。让我们看看我是否能从中找出一些道理。在程序中，当 `myob2` 作为参数传递给 `myob` 的一个方法时，第一个 MyClass
    对象（这里 `myob`）在其作用域内有一个第二个 MyClass 对象。当这种情况发生时，你可以将 `myob2` 视为存在于 `myob` “内部”。现在
    `myob2` 与“包含”对象 `myob` 共享作用域。在这种情况下——当两个相同类的对象位于该类定义的作用域内时——该类中任何对象的受保护方法都变得可见。
- en: 'In the present case, the protected method `prot` of the object `myob2` (or,
    at any rate, of the argument that “receives” `myob2`, here called `anob`) becomes
    visible and can be executed. Its private arguments, however, are not visible:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，对象 `myob2` 的受保护方法 `prot`（或者至少是“接收”`myob2` 的参数，这里称为 `anob`）变得可见并可执行。然而，它的私有参数是不可见的：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Digging Deeper
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Here you will learn more about the visibility of code inside methods and another
    way of defining singleton methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习更多关于方法内部代码的可见性以及定义单例方法的另一种方式。
- en: Protected and Private Methods in Descendant Classes
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 后代类中的受保护和私有方法
- en: The same access rules described in this chapter also apply when calling the
    methods of ancestor and descendant objects. That is, when you pass an object to
    a method (as an argument) that has the same class as the receiver object (in other
    words, the object to which the method belongs), the argument object can call the
    public and protected methods of the class but not its private methods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的相同访问规则也适用于调用祖先和后代对象的方法。也就是说，当你将一个对象传递给一个方法（作为参数）时，该方法的接收对象（换句话说，方法所属的对象）与参数对象具有相同的类，参数对象可以调用该类的公共和受保护方法，但不能调用其私有方法。
- en: 'For an example of this, take a look at the *protected.rb* program. Here I have
    created a MyClass object called `myob` and a MyOtherClass object, `myotherob`,
    where MyOtherClass descends from MyClass:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看 *protected.rb* 程序。在这里，我创建了一个名为 `myob` 的 MyClass 对象和一个名为 `myotherob` 的
    MyOtherClass 对象，其中 MyOtherClass 继承自 MyClass：
- en: '*protected.rb*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*protected.rb*'
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I now create objects from each of these three classes, and I try to pass `myotherob`
    as an argument to the `myob` public method, `shout`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我创建了这三个类中的每一个对象，并尝试将 `myotherob` 作为参数传递给 `myob` 的公共方法 `shout`：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you load this program from the code archive, you will see that it contains
    a number of lines of code in which these three objects attempt to execute the
    `shout` and `exclaim` methods. Many of these attempts are doomed to failure and
    so have been commented out. However, when testing the code, you may want to uncomment
    each method call one by one to see the results. This is my first attempt:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从代码存档中加载此程序，你会看到其中包含许多行代码，这些代码中的三个对象试图执行 `shout` 和 `exclaim` 方法。其中许多尝试注定会失败，因此已被注释掉。然而，在测试代码时，你可能希望逐个取消注释每个方法调用以查看结果。这是我的第一次尝试：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here the `shout` method calls the private method `priv` on the argument object:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`shout` 方法在参数对象上调用私有方法 `priv`：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This won’t work! Ruby complains that the `priv` method is private.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不起作用！Ruby 抱怨 `priv` 方法是私有的。
- en: 'Similarly, were I to do it the other way around—that is, by passing the ancestor
    object `myob` as the argument and invoking the method `shout` on the descendant
    object—I would encounter the same error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我将顺序反过来——也就是说，通过传递祖先对象 `myob` 作为参数并在后代对象上调用 `shout` 方法——我也会遇到相同的错误：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The MyClass class also has another public method, `exclaim`. This one calls
    a protected method, `prot`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass 类还有一个公共方法，`exclaim`。这个方法调用受保护的方法，`prot`：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, I can pass either the MyClass object, `myob`, or the MyOtherClass object,
    `myotherob`, as an argument to the `exclaim` method, and no error will occur when
    the protected method is called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以将 MyClass 对象 `myob` 或 MyOtherClass 对象 `myotherob` 作为参数传递给 `exclaim` 方法，当调用受保护的方法时不会发生错误：
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Needless to say, this works only when the two objects (the receiver object to
    the left of the dot and the argument passed to the method) share the same line
    of descent. If you send an unrelated object as an argument, you would not be able
    to call methods of the receiver class, no matter what their protection levels.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这只有在两个对象（点左侧的接收对象和传递给方法的参数）共享相同的继承线时才有效。如果你传递一个无关的对象作为参数，无论它们的保护级别如何，你都无法调用接收类的任何方法。
- en: Invading the Privacy of Private Methods
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 侵犯私有方法的隐私
- en: 'The whole point of a private method is that it cannot be called from outside
    the scope of the object to which it belongs. So, this won’t work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法整个点在于它不能从属于它的对象的作用域之外被调用。所以，这不会起作用：
- en: '*send.rb*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*send.rb*'
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, it turns out that Ruby provides a “get out clause” (or maybe I should
    say a “get in” clause?) in the form of a method called `send`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结果证明，Ruby 提供了一种“退出条款”（或者我或许应该说“进入条款”）的形式，即名为 `send` 的方法。
- en: 'The `send` method invokes the method whose name matches that of a symbol (an
    identifier beginning with a colon such as `:priv`), which is passed as the first
    argument to `send` like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 方法调用与符号（以冒号开始的标识符，如 `:priv`）名称匹配的方法，该符号作为第一个参数传递给 `send`，如下所示：'
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Any arguments supplied after the symbol (like the string “hello”) are passed
    in the normal way to the specified method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号（如字符串“hello”）之后提供的任何参数都按正常方式传递给指定的方法。
- en: Using `send` to gain public access to a private method is not generally a good
    idea. After all, if you need access to a certain method, why make it private in
    the first place? Use this technique with caution or not at all.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `send` 来获取对私有方法的公共访问通常不是一个好主意。毕竟，如果你需要访问某个方法，为什么一开始要将其设置为私有呢？谨慎使用此技术或根本不使用。
- en: Singleton Class Methods
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类方法
- en: 'Earlier, I created class methods by appending a method name to the name of
    the class like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我通过将方法名附加到类名上来创建类方法，如下所示：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There is a “shortcut” syntax for doing this. Here is an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种“快捷”语法来做这件事。以下是一个示例：
- en: '*class_methods3.rb*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_methods3.rb*'
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, `methodA`, `methodB`, and `methodC` are all class methods of MyClass;
    `methodA` is declared using the syntax used previously:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`methodA`、`methodB` 和 `methodC` 都是 MyClass 的类方法；`methodA` 是使用之前的方法声明的语法：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But `methodB` and `methodC` are declared using the syntax of instance methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `methodB` 和 `methodC` 是使用实例方法的语法声明的：
- en: '[PRE63]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So, why do they end up as class methods? It’s all because the method declarations
    have been placed inside this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为什么它们最终成为类方法呢？这完全是因为方法声明被放置在这个代码中：
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This may remind you of the syntax used for declaring singleton classes. For
    example, in the *singleton_class.rb* program, you may recall that I first created
    an object named `ob` and then gave it its very own method, `blather`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你想起声明单例类所使用的语法。例如，在 *singleton_class.rb* 程序中，你可能还记得我首先创建了一个名为 `ob` 的对象，然后给它添加了一个名为
    `blather` 的方法：
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `blather` method here is a singleton method of the `ob` object. Similarly,
    in the *class_methods3.rb* program, the `methodB` and `methodC` methods are singleton
    methods of `self`—and `self` happens to be the MyClass class. You can similarly
    add singleton methods from outside the class definition by using `<<` followed
    by the class name, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `blather` 方法是 `ob` 对象的单例方法。同样，在 *class_methods3.rb* 程序中，`methodB` 和 `methodC`
    方法是 `self` 的单例方法——而 `self` 正好是 MyClass 类。你可以通过使用 `<<` 后跟类名，从类定义外部添加单例方法，如下所示：
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, the code checks that all four methods really are singleton methods
    by first printing the names of all available singleton methods and then calling
    them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码通过首先打印所有可用的单例方法名称，然后调用它们来检查所有四个方法确实都是单例方法：
- en: '[PRE67]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This displays the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示以下内容：
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Nested Methods
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套方法
- en: 'You can nest methods; that is, you can write methods that contain other methods.
    This gives you a way of dividing a long method into reusable chunks. So, for example,
    if method `x` needs to do calculation `y` at several different points, you can
    put the `y` method inside the `x` method (the methods in the following example
    are called `outer_x`, `nested_y`, and `nested_z` for clarity):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套方法；也就是说，你可以编写包含其他方法的方法。这为你提供了一种将长方法分成可重用块的方法。例如，如果方法 `x` 需要在几个不同的点执行计算
    `y`，你可以在 `x` 方法（以下示例中的方法称为 `outer_x`、`nested_y` 和 `nested_z` 以便清晰）中放置 `y` 方法：
- en: '*nested_methods.rb*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*nested_methods.rb*'
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Nested methods are not initially visible outside the scope in which they are
    defined. So, in the previous example, although `nested_y` and `nested_z` may be
    called from inside `outer_x`, they may not be called by any other code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套方法最初在它们定义的作用域之外是不可见的。所以，在上面的例子中，尽管`nested_y`和`nested_z`可以从`outer_x`内部调用，但它们可能无法被任何其他代码调用：
- en: '[PRE70]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If, instead of `ob.outer_x` in the previous code, you were to call `ob.nested_y`
    or `ob.nested_z`, you would see an error message since the `nested_y` and `nested_z`
    methods would not, at this stage, be visible. However, when you run a method that
    encloses nested methods, those nested methods *will* be brought into scope outside
    that method!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在之前的代码中，你调用的是`ob.outer_x`而不是`ob.nested_y`或`ob.nested_z`，你会看到一个错误信息，因为在这个阶段`nested_y`和`nested_z`方法将不可见。然而，当你运行一个包含嵌套方法的方法时，那些嵌套方法*将会*被带到该方法的外部作用域中！
- en: '*nested_methods2.rb*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*nested_methods2.rb*'
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To see another example of this, try running the *nested_methods.rb* code again,
    but this time uncomment all three method calls. This time, when the `outer_x`
    method executes, it brings `nested_y` and `nested_z` into scope so the calls to
    the two nested methods now succeed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个的另一个例子，尝试再次运行*nested_methods.rb*代码，但这次取消注释所有三个方法调用。这次，当`outer_x`方法执行时，它会将`nested_y`和`nested_z`带到作用域中，因此对这两个嵌套方法的调用现在成功了：
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Method Names
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名
- en: 'As a final point, it’s worth mentioning that method names in Ruby almost always
    begin with a lowercase character like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，值得提一下的是，Ruby中的方法名几乎总是以小写字母开头，就像这样：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'However, that is a *convention*, not an *obligation*. It is also permissible
    to begin method names with capital letters, like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个*约定*，并不是*义务*。也可以以大写字母开头命名方法名，就像这样：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since the `Fred` method looks like a constant (it starts with a capital letter),
    you would need to tell Ruby that it is a method when calling it by adding parentheses:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Fred`方法看起来像是一个常量（它以大写字母开头），在调用它时你需要通过添加括号来告诉Ruby它是一个方法：
- en: '*method_names.rb*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*method_names.rb*'
- en: '[PRE75]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: On the whole, it is better to stick to the convention of using method names
    that begin with a lowercase character.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，坚持使用以小写字母开头的方法名约定会更好。
