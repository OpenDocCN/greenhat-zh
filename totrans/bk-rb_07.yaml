- en: Chapter 7. Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: You’ve used numerous methods throughout this book. On the whole, they aren’t
    particularly complicated things, so you may wonder why this chapter, which is
    all about methods, is so long. As you will discover, there is much more to methods
    than meets the eye.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods you’ve been using so far have been *instance methods*. An instance
    method belongs to a specific instance of a class—in other words, to an individual
    object. It is also possible to write *class methods*. (Some other languages refer
    to this kind of method as a static method.) A class method belongs to the class
    itself. To define a class method, you must precede the method name with the class
    name and a full stop.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '*class_methods1.rb*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should use the class name when calling a class method:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A specific object cannot call a class method. Nor can a class call an instance
    method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What Are Class Methods For?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But why, you may reasonably ask, would you ever want to create a class method
    rather than the more usual instance method? There are two main reasons: First,
    a class method can be used as a “ready-to-run function” without having to go to
    the bother of creating an object just to use it, and second, it can be used on
    those occasions when you need to run a method before an object has been created.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'For a few examples of using methods as “ready-to-run functions,” consider Ruby’s
    File class. Many of its methods are class methods. This is because most of the
    time you will be using them to do something to, or return information about, an
    existing file. You don’t need to create a new File object to do that; instead,
    you pass the filename as an argument to the File class methods. You’ll look more
    closely at the File class in [Chapter 13](ch13.html "Chapter 13. Files and IO").
    Here are examples of a few of its class methods in use:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '*file_methods.rb*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This outputs something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other occasion when a class method is vital is when you need to use a method
    before an object has been created. The most important example of this is the `new`
    method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You call the `new` method every time you create an object. Until the object
    has been created, you clearly cannot call one of its instance methods—because
    you can call instance methods only from an object that already exists. When you
    use `new`, you are calling a method of the class itself and telling the class
    to create a new instance of itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Class Variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class methods may remind you of the class variables you used previously (that
    is, variables whose names begin with `@@`). You may recall that you used class
    variables in a simple adventure game (see *2adventure.rb* in [Attribute Readers
    and Writers](ch02s04.html "Attribute Readers and Writers")) to keep a tally of
    the total number of objects in the game; each time a new Thing object was created,
    1 was added to the `@@num_things` class variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unlike an instance variable (that is, a variable that belongs to a specific
    object created from a class), a class variable must be given a value when it is
    first declared:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例变量（即属于从类创建的特定对象的变量）不同，类变量在首次声明时必须赋予一个值：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Initialization of either instance or class variables within the body of the
    class affects only the values stored by the class itself. Class variables are
    available both to the class itself and to the objects created from that class.
    However, each instance variable is unique; each object has its own copy of any
    instance variables—*and the class itself may also have its own instance variables*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在类体内部初始化实例或类变量只会影响类本身存储的值。类变量对类本身以及从该类创建的对象都是可用的。然而，每个实例变量都是唯一的；每个对象都有其自己的任何实例变量的副本——*类本身也可能有自己的实例变量*。
- en: 'Class Variables, Instance Variables, and Methods: Summary'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量、实例变量和方法：总结
- en: 'Instance variables begin with `@`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量以 `@` 开头：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Class variables begin with `@@`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量以 `@@` 开头：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instance methods are defined by `def` *`MethodName`*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法通过 `def` *`MethodName`* 定义：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Class methods are defined by `def` *`ClassName`*.*`MethodName`*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法通过 `def` *`ClassName`*.*`MethodName`* 定义：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To understand how a class may have instance variables, refer to the *class_methods2.rb*
    program. This defines a class containing one class method and one instance method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解一个类可能有哪些实例变量，请参考 *class_methods2.rb* 程序。该程序定义了一个包含一个类方法和一个实例方法的类：
- en: '*class_methods2.rb*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*class_methods2.rb*'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that it declares and initializes a class variable and an instance variable,
    `@@classvar` and `@instvar`, respectively. Its class method, `classMethod`, increments
    both these variables by 10, while its instance method, `instanceMethod`, increments
    both variables by 1\. Notice that I have assigned values to both the class variable
    and the instance variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它分别声明并初始化了一个类变量和一个实例变量，`@@classvar` 和 `@instvar`。它的类方法 `classMethod` 将这两个变量都增加10，而它的实例方法
    `instanceMethod` 将这两个变量各增加1。注意，我已经为类变量和实例变量都赋值了：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I said earlier that initial values are not normally assigned to instance variables
    in this way. The exception to the rule is when you assign a value to an instance
    variable *of the class itself* rather than to an object derived from that class.
    The distinction should become clearer shortly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，通常不会以这种方式为实例变量分配初始值。这个规则的例外是当你为类的实例变量而不是从该类派生的对象分配一个值时。这个区别很快就会变得清楚。
- en: 'I’ve written a few lines of code that create three instances of MyClass (the
    `ob` variable is initialized with a new instance on each turn through the loop)
    and then call both the class and instance methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一些代码，创建了 MyClass 的三个实例（`ob` 变量在循环的每次迭代中初始化为一个新的实例），然后调用了类方法和实例方法：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The class method, `MyClass.showVars`, and the instance method, `showVars`,
    display the values of `@instvar` and `@@classvar` at each turn through the loop.
    When you run the code, these are the values displayed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `MyClass.showVars` 和实例方法 `showVars` 在每次循环迭代中显示 `@instvar` 和 `@@classvar`
    的值。当你运行代码时，显示的值如下：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may need to look at these results carefully in order to see what is going
    on here. In summary, this is what is happening: The code in both the class method,
    `MyClass.classMethod`, and the instance method, `instanceMethod`, increments both
    the class and instance variables, `@@classvar` and `@instvar`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要仔细查看这些结果，以便了解这里发生了什么。总结来说，这是正在发生的事情：在类方法 `MyClass.classMethod` 和实例方法 `instanceMethod`
    中的代码都会增加类变量和实例变量 `@@classvar` 和 `@instvar` 的值。
- en: 'You can see clearly that the class variable is incremented by both these methods
    (the class method adds 10 to `@@classvar` whenever a new object is created, while
    the instance method adds 1 to it). However, whenever a new object is created,
    its instance variable is initialized to 1 by the `instanceMethod`. This is the
    expected behavior since each object has its own copy of an instance variable,
    but all objects share a unique class variable. Perhaps less obvious is that the
    class itself also has its own instance variable, `@instvar`. This is because,
    in Ruby, a class is an object and therefore can contain instance variables, just
    like any other object. The MyClass variable, `@instvar`, is incremented by the
    class method `MyClass.classMethod`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the instance method, `showVars`, prints the value of `@instvar`, it prints
    the value stored in a specific object, `ob`; the value of `ob`’s `@instvar` is
    initially `nil` (*not* the value 1,000 with which the MyClass variable `@instvar`
    was initialized), and this value is incremented by 1 in `instanceMethod`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: When the class method, `MyClass.showVars`, prints the value of `@instvar`, it
    prints the value stored in the class itself (in other words, MyClass’s `@instvar`
    *is a different variable* from `ob`’s `@instvar`). But when either method prints
    the value of the class variable, `@@classvar`, the value is the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember that there is only ever one copy of a class variable, but there
    may be many copies of instance variables. If this is still confusing, take a look
    at the *inst_vars.rb* program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*inst_vars.rb*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, instead of creating a new object instance at each turn through the
    loop, you create a single instance (`ob`) at the outset. When the `ob.instanceMethod`
    is called, `@instvar` is incremented by 1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I’ve used a little trick to look inside the class and method and retrieve
    the value of `@instvar` using Ruby’s `instance_variable_get` method (I’ll return
    to this when I cover dynamic programming in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because you only ever increment the `@instvar` that belongs to the object `ob`,
    the value of its `@instvar` goes up from 1 to 3 as the `for` loop executes. But
    the `@instvar` that belongs to the MyClass class is never incremented; it remains
    at its initial value of 1,000:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But now let’s uncomment this line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This calls a class method that increments `@instvar` by 10\. This time when
    you run the program, you see that, as before, the `@instvar` variable of `ob`
    is incremented by 1 on each turn through the loop, while the `@instvar` variable
    of MyClass is incremented by 10:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A Class Is an Object
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand instance variables of classes, just remember that a class is
    an object (actually, it’s an instance of the `Class` class!). The MyClass “class
    object” has its own instance variable (`@instvar`) just as the `ob` object has
    its own instance variable (which here also happens to be called `@instvar`). In
    spite of the same names, these are two different variables: One belongs to the
    class itself; the other belongs inside each object created from the class. Instance
    variables are always unique to an object instance, so no two objects (not even
    an object like MyClass, which also happens to be a class!) can ever share a single
    instance variable.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby Constructors: new or initialize?'
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I gave a brief explanation of `new` and `initialize` in [Chapter 1](ch01.html
    "Chapter 1. Strings, Numbers, Classes, and Objects"). At that stage, you had not
    examined the differences between Ruby’s class and instance methods and variables,
    so it was not possible to give a full discussion of how `new` and `initialize`
    work together. Because these are such important methods, you’ll look at them in
    more detail now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The method responsible for bringing an object into being is called the *constructor*.
    In Ruby, the constructor method is called `new`. The `new` method is a class method
    that, once it has created an object, will run an instance method named `initialize`
    if such a method exists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief then, the `new` method is the constructor, and the `initialize` method
    is used to initialize the values of any variables immediately after an object
    is created. But why can’t you just write your own `new` method and initialize
    variables in it? Well, let’s try that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '*new.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, I’ve written a `MyClass.new` method that begins with the `super` keyword
    to invoke the `new` method of its superclass. Then I’ve created a string instance
    variable, `@anewvar`. So what do I end up with? Not, as you might suppose, a new
    MyClass object containing a string variable. Remember that the last expression
    evaluated by a method in Ruby is the value returned by that method. The last expression
    evaluated by the `new` method here is a string. I evaluate this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And I display the newly created `ob` object and its class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This proves that `MyClass.new` returns a string, and it is this string (*not*
    a MyClass object) that is assigned to the variable `ob`. If you find this confusing,
    don’t panic. The moral of the story is that overriding `new` *is* confusing and
    is generally a bad idea. Unless you have a very good reason for doing so, you
    should avoid trying to override the `new` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Methods
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A singleton method is a method that belongs to a single object rather than
    to an entire class. Many of the methods in the Ruby class library are singleton
    methods. This is because, as mentioned earlier, each class is an object of the
    type Class. Or, to put it simply, the class of every class is Class. This is true
    of all classes—both those you define yourself and those provided by the Ruby class
    library:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*class_classes.rb*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, some classes also have class methods—that is, methods that belong to the
    Class object itself. In that sense, these are singleton methods of the Class object.
    Indeed, if you evaluate the following, you will be shown an array of method names
    that match the names of IO class methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This displays the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As explained earlier, when you write your own class methods, you do so by prefacing
    the method name with the name of the class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It turns out that you can use a similar syntax when creating singleton classes
    for specific objects. This time you preface the method name with the name of the
    object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finding an Object’s Ancestor Classes
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately all classes descend from the Object class. In Ruby 1.9, the Object
    class itself descends from the BasicObject class (see [Chapter 2](ch02.html "Chapter 2. Class
    Hierarchies, Attributes, and Class Variables")). This is true even for the `Class`
    class! To prove this, try the *class_hierarchy.rb* program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Pass a class name to this method to track back up its family tree of ancestor
    classes. For example, try this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In Ruby 1.9, this displays the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*class_hierarchy.rb*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a concrete example. Suppose you have a program containing Creature
    objects of many different species (maybe you are a veterinarian, the head keeper
    at a zoo, or, like the author of this book, an enthusiastic player of adventure
    games); each creature has a method called `talk` that displays the vocal noise
    each creature usually makes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my Creature class and a few creature objects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_meth1.rb*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then you suddenly realize that one of those creatures, and one alone, has additional
    special behavior. On the night of a full moon, the werewolf not only talks (“growl”)
    but also howls (“How-oo-oo-oo-oo!”). It really needs a `howl` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'You could go back and add such a method to the Creature class, but then you’d
    end up with howling dogs, cats, and budgies too—which is not what you want. You
    could create a new Werewolf class that descends from Creature, but you will only
    ever have one werewolf (they are, alas, an endangered species), so why do you
    want a whole class for just that? Wouldn’t it make more sense to have a werewolf
    *object* that is the same as every other creature object except that it also has
    a `howl` method? Okay, let’s do that by giving the werewolf its very own singleton
    method. Here goes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Heck, you can do better than that! It howls only on a full moon, so let’s make
    sure that, if asked to howl when the moon is new, it just growls. Here’s my finished
    method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that, even though this method has been declared outside the Creature
    class, it is able to call the instance method `talk`. That’s because the `howl`
    method now lives “inside” the werewolf object so has the same scope within that
    object as the `talk` method. It does not, however, live inside any of the werewolf’s
    fellow creatures; the `howl` method belongs to him and him alone. Try to make
    the `budgie.howl`, and Ruby will inform you that `howl` is an undefined method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you are debugging your code for your own use, having your program blow
    up thanks to an undefined method may be acceptable; however, if your program does
    so out in the big, bad world of the “end user,” it is definitely *not* acceptable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think undefined methods are likely to be a problem, you can take avoidance
    measures by testing whether a singleton method exists before trying to use it.
    The Object class has a `singleton_methods` method that returns an array of singleton
    method names. You can test a method name for inclusion using the Array class’s
    `include?` method. In *singleton_meth2.rb*, for example, I’ve programmed an “open
    the box” game, which has a number of Box objects, only one of which, when opened,
    contains the star prize. I’ve named this special Box object `starprize` and given
    it a singleton method called `congratulate`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_meth2.rb*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `congratulate` method should be called when the `starprize` box is opened.
    This bit of code (in which `item` is a Box object) ensures that this method (which
    does not exist in any other object) is not called when some other box is opened:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An alternative way of checking the validity of a method would be to pass that
    method name as a symbol (an identifier preceded by a colon) to the Object class’s
    `respond_to?` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll see another way of handling nonexistent methods in [Chapter 20](ch20.html
    "Chapter 20. Dynamic Programming").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Classes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singleton method is a method that belongs to a single object. A singleton
    class, on the other hand, is a class that defines a single object. Confused? Me
    too. Let’s take a closer look.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose you create a few dozen objects, each of which is an instance of
    the Object class. Naturally they all have access to inherited methods such as
    `inspect` and `class`. But now you decide that you want just one special object
    (for the sake of variety, let’s call him `ob`), which has one special method (let’s
    call it `blather`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to define a whole new class for this one object since you will
    never again create any more objects with the `blather` method. So, you create
    a class especially for little `ob`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to name this class. You just tell it to attach itself to `ob`
    by putting a `<<` between the keyword `class` and the name of the object. Then
    you add code to the class in the usual way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_class.rb*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now `ob`, and only `ob`, has not only all the usual methods of the Object class;
    it also has the methods (here just the `blather` method, but there could, in principle,
    be many more) of its own special anonymous class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you’ve been paying close attention, you might have noticed that the singleton
    class seems to be doing something rather similar to a singleton method. With a
    singleton class, I can create an object and then add extra methods packaged up
    inside an anonymous class. With singleton methods, I can create an object and
    then add methods one by one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*singleton_class2.rb*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, I could rewrite the “star prize” program. In the previous version
    I added a singleton method, `congratulate`, to an object named `starprize`. I
    could just as easily have created a singleton class containing the `congratulate`
    method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In fact, the similarity is more than skin deep. The end result of the previous
    code is that `congratulate` becomes a singleton method of `starprize`. I can verify
    this by checking whether the array of singleton methods available for the `item`
    object contains the name `congratulate`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Ruby 1.9, the `singleton_methods` method returns an array of symbols representing
    the method names. This is why I have used the symbol `:congratulate` in the previous
    code. However, in Ruby 1.8, `singleton_methods` returns an array of strings. So,
    if you are using Ruby 1.8, you should be sure to use the following test using
    the string argument `"congratulate"`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s the difference between a singleton method and a singleton class? The
    short answer is, not a lot. These two syntaxes provide different ways of adding
    methods to a specific object rather than building those methods into its defining
    class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Methods
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you may want to redefine a method that already exists in some class.
    You’ve done this before when, for example, you created classes with their own
    `to_s` methods to return a string representation. Every Ruby class, from Object
    downward, has a `to_s` method. The `to_s` method of the Object class returns the
    class name and a hexadecimal representation of the object’s unique identifier.
    However, many Ruby classes have their own special versions of `to_s`. For example,
    `Array.to_s` concatenates and returns the values in the array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: When a method in one class replaces a method of the same name in an ancestor
    class, it is said to *override* that method. You can override methods that are
    defined in the standard class library such as `to_s` as well as methods defined
    in your own classes. If you need to add new behavior to an existing method, remember
    to call the superclass’s method using the `super` keyword at the start of the
    overridden method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*override.rb*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Public, Protected, and Private Methods
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you may want to restrict the “visibility” of your methods to
    ensure that they cannot be called by code outside the class in which the methods
    occur.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This may be useful when your class defines various “utility” methods that it
    requires in order to perform certain functions that it does not intend for public
    consumption. By imposing access restrictions on those methods, you can prevent
    programmers from using them for their own nefarious purposes. This means you will
    be able to change the implementation of those methods at a later stage without
    having to worry you are going to break somebody else’s code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby provides three levels of method accessibility:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: protected
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name suggests, public methods are the most accessible, and private methods
    are the least accessible. All your methods are public unless you specify otherwise.
    When a method is public, it is available to be used by the world outside the object
    in whose class it is defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When a method is private, it can be used only by other methods inside the object
    in whose class it is defined.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'A protected method generally works in the same way as a private method with
    one tiny but important difference: In addition to being visible to the methods
    of the current object, a protected method is also visible to objects of the same
    type when the second object is within the scope of the first object.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction between private and protected methods will probably be easier
    to understand when you see a working example. Consider this class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '*pub_prot_priv.rb*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I’ve declared three methods, one for each level of accessibility. These levels
    are set by putting `private`, `protected`, or `public` prior to one or more methods.
    The specified accessibility level remains in force for all subsequent methods
    until some other access level is specified.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`public`, `private`, and `protected` may look like keywords. But they are,
    in fact, methods of the Module class.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, my class has a public method, `useOb`, which takes a `MyOb` object
    as an argument and calls the three methods `pub`, `prot`, and `priv` of that object.
    Now, let’s see how a `MyClass` object can be used. First, I’ll create two instances
    of the class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, I try to call each of the three methods in turn:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From the previous, it would seem that the public method is (as expected) visible
    from the world outside the object to which it applies. But both the private and
    the protected methods are invisible. This being so, what is the protected method
    for? Another example should help clarify this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time, I am calling the public method `useOb` of the `myob` object, and
    I am passing to it a second object, `myob2`, as an argument. The important thing
    to note is that `myob` and `myob2` are instances of the same class. Now, recall
    what I said earlier: *In addition to being visible to the methods of the current
    object, a protected method is also visible to objects of the same type when the
    second object is within the scope of the first object*.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like gobbledygook. Let’s see if I can make some sense out of
    it. In the program, the first MyClass object (here `myob`) has a second MyClass
    object within its scope when `myob2` is passed as an argument to a method of `myob`.
    When this happens, you can think of `myob2` as being present “inside” `myob`.
    Now `myob2` shares the scope of the “containing” object, `myob`. In this special
    circumstance—when two objects of the same class are within the scope defined by
    that class—the protected methods of any objects of this class become visible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In the present case, the protected method `prot` of the object `myob2` (or,
    at any rate, of the argument that “receives” `myob2`, here called `anob`) becomes
    visible and can be executed. Its private arguments, however, are not visible:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Digging Deeper
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Here you will learn more about the visibility of code inside methods and another
    way of defining singleton methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Protected and Private Methods in Descendant Classes
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The same access rules described in this chapter also apply when calling the
    methods of ancestor and descendant objects. That is, when you pass an object to
    a method (as an argument) that has the same class as the receiver object (in other
    words, the object to which the method belongs), the argument object can call the
    public and protected methods of the class but not its private methods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of this, take a look at the *protected.rb* program. Here I have
    created a MyClass object called `myob` and a MyOtherClass object, `myotherob`,
    where MyOtherClass descends from MyClass:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '*protected.rb*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I now create objects from each of these three classes, and I try to pass `myotherob`
    as an argument to the `myob` public method, `shout`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you load this program from the code archive, you will see that it contains
    a number of lines of code in which these three objects attempt to execute the
    `shout` and `exclaim` methods. Many of these attempts are doomed to failure and
    so have been commented out. However, when testing the code, you may want to uncomment
    each method call one by one to see the results. This is my first attempt:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here the `shout` method calls the private method `priv` on the argument object:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This won’t work! Ruby complains that the `priv` method is private.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, were I to do it the other way around—that is, by passing the ancestor
    object `myob` as the argument and invoking the method `shout` on the descendant
    object—I would encounter the same error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The MyClass class also has another public method, `exclaim`. This one calls
    a protected method, `prot`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, I can pass either the MyClass object, `myob`, or the MyOtherClass object,
    `myotherob`, as an argument to the `exclaim` method, and no error will occur when
    the protected method is called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Needless to say, this works only when the two objects (the receiver object to
    the left of the dot and the argument passed to the method) share the same line
    of descent. If you send an unrelated object as an argument, you would not be able
    to call methods of the receiver class, no matter what their protection levels.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Invading the Privacy of Private Methods
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole point of a private method is that it cannot be called from outside
    the scope of the object to which it belongs. So, this won’t work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '*send.rb*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, it turns out that Ruby provides a “get out clause” (or maybe I should
    say a “get in” clause?) in the form of a method called `send`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The `send` method invokes the method whose name matches that of a symbol (an
    identifier beginning with a colon such as `:priv`), which is passed as the first
    argument to `send` like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Any arguments supplied after the symbol (like the string “hello”) are passed
    in the normal way to the specified method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Using `send` to gain public access to a private method is not generally a good
    idea. After all, if you need access to a certain method, why make it private in
    the first place? Use this technique with caution or not at all.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Class Methods
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I created class methods by appending a method name to the name of
    the class like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There is a “shortcut” syntax for doing this. Here is an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*class_methods3.rb*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, `methodA`, `methodB`, and `methodC` are all class methods of MyClass;
    `methodA` is declared using the syntax used previously:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But `methodB` and `methodC` are declared using the syntax of instance methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So, why do they end up as class methods? It’s all because the method declarations
    have been placed inside this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This may remind you of the syntax used for declaring singleton classes. For
    example, in the *singleton_class.rb* program, you may recall that I first created
    an object named `ob` and then gave it its very own method, `blather`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `blather` method here is a singleton method of the `ob` object. Similarly,
    in the *class_methods3.rb* program, the `methodB` and `methodC` methods are singleton
    methods of `self`—and `self` happens to be the MyClass class. You can similarly
    add singleton methods from outside the class definition by using `<<` followed
    by the class name, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, the code checks that all four methods really are singleton methods
    by first printing the names of all available singleton methods and then calling
    them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This displays the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Nested Methods
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest methods; that is, you can write methods that contain other methods.
    This gives you a way of dividing a long method into reusable chunks. So, for example,
    if method `x` needs to do calculation `y` at several different points, you can
    put the `y` method inside the `x` method (the methods in the following example
    are called `outer_x`, `nested_y`, and `nested_z` for clarity):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*nested_methods.rb*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Nested methods are not initially visible outside the scope in which they are
    defined. So, in the previous example, although `nested_y` and `nested_z` may be
    called from inside `outer_x`, they may not be called by any other code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套方法最初在它们定义的作用域之外是不可见的。所以，在上面的例子中，尽管`nested_y`和`nested_z`可以从`outer_x`内部调用，但它们可能无法被任何其他代码调用：
- en: '[PRE70]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If, instead of `ob.outer_x` in the previous code, you were to call `ob.nested_y`
    or `ob.nested_z`, you would see an error message since the `nested_y` and `nested_z`
    methods would not, at this stage, be visible. However, when you run a method that
    encloses nested methods, those nested methods *will* be brought into scope outside
    that method!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在之前的代码中，你调用的是`ob.outer_x`而不是`ob.nested_y`或`ob.nested_z`，你会看到一个错误信息，因为在这个阶段`nested_y`和`nested_z`方法将不可见。然而，当你运行一个包含嵌套方法的方法时，那些嵌套方法*将会*被带到该方法的外部作用域中！
- en: '*nested_methods2.rb*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*nested_methods2.rb*'
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To see another example of this, try running the *nested_methods.rb* code again,
    but this time uncomment all three method calls. This time, when the `outer_x`
    method executes, it brings `nested_y` and `nested_z` into scope so the calls to
    the two nested methods now succeed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个的另一个例子，尝试再次运行*nested_methods.rb*代码，但这次取消注释所有三个方法调用。这次，当`outer_x`方法执行时，它会将`nested_y`和`nested_z`带到作用域中，因此对这两个嵌套方法的调用现在成功了：
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Method Names
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名
- en: 'As a final point, it’s worth mentioning that method names in Ruby almost always
    begin with a lowercase character like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，值得提一下的是，Ruby中的方法名几乎总是以小写字母开头，就像这样：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'However, that is a *convention*, not an *obligation*. It is also permissible
    to begin method names with capital letters, like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个*约定*，并不是*义务*。也可以以大写字母开头命名方法名，就像这样：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since the `Fred` method looks like a constant (it starts with a capital letter),
    you would need to tell Ruby that it is a method when calling it by adding parentheses:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Fred`方法看起来像是一个常量（它以大写字母开头），在调用它时你需要通过添加括号来告诉Ruby它是一个方法：
- en: '*method_names.rb*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*method_names.rb*'
- en: '[PRE75]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: On the whole, it is better to stick to the convention of using method names
    that begin with a lowercase character.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，坚持使用以小写字母开头的方法名约定会更好。
