- en: Chapter 1. INTRODUCTION TO NETWORKING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![INTRODUCTION TO NETWORKING](tagoreillycom20090210nostarchimages255004.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Broadband wireless networks are one more step toward the Internet's ultimate
    destiny of interconnecting everything in the known universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'A wireless network combines two kinds of communication technology: data networks
    that make it possible to share information among two or more computers, and radio
    (or wireless) communication that uses electromagnetic radiation to move information
    from one place to another.'
  prefs: []
  type: TYPE_NORMAL
- en: The earliest Wi-Fi systems provided a convenient way to connect a laptop computer
    to an office network and to connect computers to a home network without stringing
    cables between rooms. Today, Wi-Fi and other broadband services allow millions
    of users to connect to the Internet when they're away from their homes or offices,
    as wireless signals cover entire metropolitan areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variety of products and services use different methods to accomplish essentially
    the same objective: wirelessly exchanging network data using radio signals. Each
    service has a somewhat different set of features, and each uses a slightly different
    technology. The three most widely used systems are Wi-Fi, WiMAX, and 3G cellular
    service.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains how these three broadband wireless networks work.
    But before we go into detail about specific wireless data network services, it
    will be helpful to understand networks in more general terms.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Data Around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's review the general structure of computer data and the methods
    that networks use to move data from one place to another. This is very basic stuff
    that might already be familiar to you, but bear with me for a few pages. This
    really will help you to understand how a wireless network operates.
  prefs: []
  type: TYPE_NORMAL
- en: Bits and Bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you probably know, the processing unit of a computer can recognize only
    two information states: either a signal is present or not present at the input
    to the processor. These two conditions are usually described as 1 and 0, on and
    off, or mark and space. Each instance of a 1 or a 0 is a *bit*.'
  prefs: []
  type: TYPE_NORMAL
- en: The form that each 1 or 0 takes varies in different types of communication channels.
    It can be a light, a sound, or an electrical charge that is either on or off,
    a series of long and short sounds or light flashes, two different audio tones,
    or two different radio frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Individual bits are not particularly useful, but when you string 8 of them together
    into a *byte*, you can have 256 different combinations. That's enough to assign
    different sequences to all the letters in the alphabet (both upper- and lowercase),
    the 10 digits from 0 to 9, spaces between words, and other symbols such as punctuation
    marks and letters used in foreign alphabets. A modern computer recognizes and
    processes several 8-bit bytes at the same time. When processing is complete, the
    computer transmits the same stream of bits at its output. The output might be
    connected to a printer, a video display, or a data communication channel. Or it
    might be something else entirely, such as a series of flashing lights. [Figure 1-1](ch01.html#these_bits_form_the_sequence_of_a_010000
    "Figure 1-1. These bits form the sequence of A (01000001) and n (01101110).")
    is an example of a sequence of bits.
  prefs: []
  type: TYPE_NORMAL
- en: '![These bits form the sequence of A (01000001) and n (01101110).](tagoreillycom20090210nostarchimages254039.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1-1. These bits form the sequence of A (01000001) and n (01101110).**'
  prefs: []
  type: TYPE_NORMAL
- en: The inputs and outputs that we're concerned about here are the ones that form
    a communication circuit. Like the computer processor, a data channel can recognize
    only one bit at a time. Either there's a signal on the line or there isn't.
  prefs: []
  type: TYPE_NORMAL
- en: However, over short distances, it's possible to send the data through a cable
    that carries eight (or some multiple of eight) signals in *parallel* through eight
    separate wires. Obviously, a parallel connection can be eight times faster than
    sending one bit through a single wire, but those eight wires cost eight times
    as much as a single wire. That added cost is insignificant when the wires are
    only a foot or two long, but when you're trying to send the data over a long distance,
    that additional cost can be prohibitive. And when you're using existing circuits,
    such as telephone lines, you don't have any choice; you must find a way to send
    all eight bits through the existing pair of wires (or other media). The solution
    is to transmit one bit at a time with some additional bits and pauses that identify
    the beginning of each new byte. This is a *serial* data communication channel,
    which means that you're sending bits one after another. At this stage, it doesn't
    matter what medium you use to transmit those bits—it could be electrical impulses
    on a wire, two different audio tones, a series of flashing lights, or even a lot
    of notes attached to the legs of carrier pigeons—but you must have a method for
    converting the output of the computer to the signals used by the transmission
    medium and converting it back again at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Error Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a perfect transmission circuit, the signal that goes in at one end will be
    absolutely identical to the one that comes out at the other end. But in the real
    world, there's almost always some kind of noise that can interfere with our original
    pure signal. *Noise* is defined as anything that is added to the original signal;
    it could be caused by a lightning strike, interference from another communication
    channel, or dirt on an electrical contact someplace in the circuit (or in the
    case of those carrier pigeons, an attack by a marauding hawk). Whatever the source,
    noise in the channel can interrupt the flow of data. In a modern communication
    system, those bits are pouring through the circuit extremely quickly—millions
    of them every second—so a noise hit for even a fraction of a second can obliterate
    enough bits to turn your data into digital gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you must include a process called *error checking* in your data stream.
    Error checking is accomplished by adding some kind of standard information to
    each byte. In a simple computer data network, the handshaking information (described
    in the next section) is called the *parity bit*, which tells the device receiving
    each byte whether the sum of the ones and zeroes inside the byte is odd or even.
    If the receiving device discovers that the parity bit is not what it expected,
    it instructs the transmitter to send the same byte again. This value is called
    a *checksum*. More complex networks, including wireless systems, include additional
    error checking handshaking data with each string of data.
  prefs: []
  type: TYPE_NORMAL
- en: Handshaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, the computer that originates a message or a stream of data can't
    just jump online and start sending bytes. First it has to warn the device at the
    other end that it is ready to send data and make sure that the intended recipient
    is ready to accept data. To accomplish this, a series of *handshaking* requests
    and answers must surround the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of requests goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Origin: "Hey destination! I have some data for you." |'
  prefs: []
  type: TYPE_TB
- en: '| Destination: "Okay, origin, go ahead. I''m ready." |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: "Here comes the data." |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: Data data data data … checksum |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: "That''s the message. Did you get it?" |'
  prefs: []
  type: TYPE_TB
- en: '| Destination: "I got something, but it appears to be damaged." |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: "Here it is again." |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: Data data data data … checksum |'
  prefs: []
  type: TYPE_TB
- en: '| Origin: "Did you get it that time?" |'
  prefs: []
  type: TYPE_TB
- en: '| Destination: "Yup, I got it. I''m ready for more data." |'
  prefs: []
  type: TYPE_TB
- en: We can leave the specific contents of the handshaking information to the network
    designers and engineers, but it's important to understand that every bit that
    moves through a computer data network is not part of the original information
    that arrived at the input computer. In a complex network, such as a wireless data
    channel, as much as 40 percent or more of the transmitted data is handshaking
    and other overhead. It's all essential, but every one of those bits increases
    the amount of time that the message needs to move through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Destination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication over a direct physical connection (e.g., a wired connection) between
    the origin and destination doesn't need to include any kind of address or routing
    information as part of the message. You might have to set up the connection first
    (by placing a telephone call or plugging cables into a switchboard), but after
    you're connected, the link remains in place until you instruct the system to disconnect.
    This kind of connection is great for voice and simple data links, but it's not
    efficient for digital data on a complex network that serves many origins and destinations
    because a single connection ties up the circuit all the time, even when no data
    is moving through the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is to send your message to a switching center that will hold
    it until a link to the destination becomes available. This is known as a *store
    and forward* system. If the network has been properly designed for the type of
    data and the amount of traffic in the system, the waiting time will be insignificant.
    If the communication network covers a lot of territory, you can forward the message
    to one or more intermediate switching centers before it reaches its ultimate destination.
    The great advantage of this approach is that many messages can share the same
    circuits on an as-available basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the network even more efficient, you can divide messages that are longer
    than some arbitrary limit into separate pieces called *packets*. Packets from
    more than one message can travel together on the same circuit, reassemble themselves
    into the original messages at the destination, and combine with packets that contain
    other messages as they travel between switching centers. Each data packet must
    also contain another set of information: the address of the packet''s destination,
    the sequence of the packet relative to other packets in the original transmission,
    and so forth. Some of this information instructs the switching centers where to
    forward each packet, and other information tells the destination device how to
    reassemble the data in the packet back into the original message.'
  prefs: []
  type: TYPE_NORMAL
- en: That same pattern is repeated every time you add another layer of activity to
    a communication system. Each layer can attach additional information to the original
    message and strip off that information after it has done whatever the added information
    instructed it to do. By the time a message travels from a laptop computer on a
    wireless network through a local area network (LAN) and an Internet gateway to
    a distant computer that is connected to another LAN, a dozen or more information
    attachments might be added and removed before the recipient reads the original
    text. A package of data that includes address and control information ahead of
    the bits that contain the content of the message, followed by an error-checking
    sequence, is called a *frame*. Both wired and wireless networks divide the data
    stream into frames that contain various forms of handshaking information along
    with the original data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be helpful to think of these bits, bytes, packets, and frames as the
    digital version of a letter that you send through a complicated mail delivery
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: You write a letter and put it into an envelope. The name and address of the
    recipient is on the outside of the envelope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You take the letter to the mail room, where a clerk puts your envelope into
    a bigger Express Mail envelope. The big envelope has the name and address of the
    office where the recipient works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mail room clerk takes the big envelope to the post office where another
    clerk puts it into a mail sack. The post office attaches a tag to the sack, marked
    with the location of the post office that serves the recipient's office.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mail sack travels on a truck to the airport, where it is loaded into a shipping
    container along with other sacks going to the same destination city. The shipping
    container has a label that tells the freight handlers there's mail inside.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The freight handlers place the container inside an airplane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, your letter is inside your envelope, which is inside the Express
    Mail envelope, which is inside a mail sack, inside a container, inside an airplane.
    The airplane flies to another airport near the destination city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the destination airport, the ground crew unloads the container from the airplane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The freight handlers remove the sack from the shipping container and put it
    on another truck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The truck takes the sack to a post office near the recipient's office.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the post office, another mail clerk takes the big envelope out of the sack
    and gives it to a letter carrier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The letter carrier delivers the big Express Mail envelope to the recipient's
    office.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The receptionist in the office takes your envelope out of the Express Mail envelope
    and gives it to the recipient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recipient opens your envelope and reads the letter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At each step, the information on the outside of the package tells somebody how
    to handle it, but that person doesn't care what's inside. Neither you nor the
    person who ultimately reads your letter ever sees the big Express Mail envelope,
    the mail sack, the truck, the container, or the airplane, but every one of those
    containers plays an important part in moving your letter from here to there.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of envelopes, sacks, containers, and airplanes, an electronic message
    uses strings of data at the beginning or end of each packet to tell the system
    how and where to handle your message, but the end result is just about the same.
    In the OSI network model (described in the next section), each mode of transportation
    is a separate layer.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the network software adds and removes all of the preambles, addresses,
    checksums, and other information automatically so you and the person receiving
    your message never see them.
  prefs: []
  type: TYPE_NORMAL
- en: However, each item added to the original data increases the size of the packet,
    frame, or other package, and therefore increases the amount of time necessary
    to transmit the data through the network. Because the nominal data transfer speed
    includes all the overhead information along with the data in your original message,
    the actual data transfer speed through a wireless network is a lot slower than
    the nominal speed. In other words, even if your network connects at 11Mbps, your
    actual file transfer speed might only be about 6 or 7Mbps or even less. That sounds
    like a huge slowdown, but it really doesn't matter in a Wi-Fi network that's connected
    to the Internet through a 1.5Mbps DSL line or even a 5Mbps cable modem; your wireless
    link is still able to handle data transfer more quickly than the DSL or cable
    modem can provide it. On the other hand, if you're using Wi-Fi with an ultra-fast
    fiber optic connection to the Internet, or if you want to move very large audio,
    video, or CAD files around your own local network, you will want to use one of
    the faster Wi-Fi versions, either 802.11g or (when it becomes available) 802.11n.
  prefs: []
  type: TYPE_NORMAL
- en: The ISO OSI Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the package delivery example demonstrates, the information itself is only
    part of the process. When information moves across a network, it's essential that
    all of the parties involved—the originator, the ultimate recipient, and everything
    in between—agree that they will use the same formatting, timing, and routing rules
    and specifications. These rules (also called *protocols*) define the network's
    internal "plumbing" and the form of the information that moves through it.
  prefs: []
  type: TYPE_NORMAL
- en: As network communication has become more complex, the community of network designers
    has accepted the International Organization for Standardization's (ISO) Open Systems
    Interconnection (OSI) model to identify the individual elements of a network link.
    The OSI model applies to just about any kind of data communication system, including
    the broadband wireless network that will be described in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Because everybody in the communication industry uses the OSI model, it encourages
    hardware and software designers to create systems and services that can exchange
    information with similar products from other manufacturers. Without the OSI model
    or something like it, it would not be possible to expect equipment from more than
    one source to work together.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model also allows a designer to change just one element of the network
    without the need to design everything else from scratch. For example, a wireless
    network uses radio signals instead of cables at the physical layer and adds routing
    information at the data link layer, but it keeps the existing protocols and specifications
    for everything else. A complex network (such as the Internet) can use wired connections
    for one part of the signal path and wireless connections for another.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model is usually portrayed as a stack of seven layers with each layer
    acting as a foundation for the layer directly above it as shown in [Figure 1-2](ch01s02.html#the_osi_network_model_has_seven_layers
    "Figure 1-2. The OSI network model has seven layers.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The OSI network model has seven layers.](tagoreillycom20090210nostarchimages254842.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1-2. The OSI network model has seven layers.**'
  prefs: []
  type: TYPE_NORMAL
- en: Starting at the bottom, the seven layers of the OSI model are described in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Physical Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, the *physical layer* defines the physical media or hardware
    that carries signals between the end points of a network connection. The physical
    layer might be a coaxial cable, a pair of telephone wires, flashing lights, or
    radio waves.
  prefs: []
  type: TYPE_NORMAL
- en: The specifications of a network's physical layer might include the shape of
    the shell and the pin numbers in a cable connector, the voltages that define the
    0 and 1 (on and off) values, the durations of individual data bits, and the radio
    frequencies and modulation methods used by a radio transmitter and receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Link Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *data link layer* handles transmission of data across the link defined by
    the physical layer. It specifies the format of each data packet that moves across
    the network, including the destination of each packet, the physical structure
    of the network, the sequence of packets (to make sure that the packets arrive
    in the correct order), and the type of flow control (to make sure that the transmitter
    doesn't send data faster than the receiver can handle it). Each packet also includes
    a checksum that the receiver uses to confirm that the data was not corrupted during
    transmission, as well as the string of bits and bytes that contains the actual
    data inside the packet. Therefore, it contains the software that creates and interprets
    the signals that move through the physical layer.
  prefs: []
  type: TYPE_NORMAL
- en: In both wired and wireless Ethernet, every physical device that is connected
    to the network has a unique 48-bit media access control (MAC) address that identifies
    it to the network. The header (the first part of the data string inside of a packet)
    includes the MAC addresses of both the origin and destination of that packet.
  prefs: []
  type: TYPE_NORMAL
- en: The Network Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *network layer* specifies the route that a signal uses to move from the
    source to the destination independently of the physical media. At the network
    level, it doesn't matter whether the data moves through a cable, radio waves,
    or if it uses some combination of both because that's all handled at a lower level.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Internet, the exchange of data between LANs, wide area networks (WANs),
    and the core Internet trunk circuits occurs at the network layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Transport Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting at the transport layer, the OSI model is concerned with communication
    between programs on two different computers rather than the process of moving
    data from point A to point B. For example, when you view a web page on the Internet,
    the connection between the browser on your computer (such as Internet Explorer
    or Firefox) and the webserver that contains that page occurs at the *transport
    layer* (but the commands you send to the server occur at the application layer).
  prefs: []
  type: TYPE_NORMAL
- en: The Session Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *session layer* defines the format that the programs connected through the
    transport layer use to exchange data. If the programs use passwords or other authentication
    to assure that the program at the distant end of the connection is allowed to
    use a local program, that authentication happens in the session layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Presentation Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *presentation layer* controls the way each computer handles text, audio,
    video, and other data formats. For example, if a distant computer sends a picture
    in JPEG format, the software that converts the data string to a picture on a monitor
    or a printer operates at the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *application layer* handles the commands and data that move through the
    network. For example, when you send an email message, the content of your message
    (but not the address or the formatting information) is in the application layer.
    Most of the words, pictures, sounds, and other forms of information that you send
    through a network enter the system through the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, data networks have evolved over the last 100 years from very simple
    (and relatively slow) telegraph services to today's complex high-speed communication
    systems. One of the most important improvements in networking has been to replace
    many of the wires and cables that connect individual users to the worldwide network
    grid (also known as the Internet) with radio signals. [Chapter 2](ch02.html "Chapter 2. INTRODUCTION
    TO WIRELESS NETWORKS") explains how to combine traditional network services with
    wireless signaling.
  prefs: []
  type: TYPE_NORMAL
