["```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/bus.h>\n  #include <sys/condvar.h>\n  #include <sys/eventhandler.h>\n  #include <sys/selinfo.h>\n\n  #include <machine/bus.h>\n  #include <sys/rman.h>\n  #include <machine/resource.h>\n\n  #include <dev/pci/pcireg.h>\n  #include <dev/pci/pcivar.h>\n\n  #include <dev/ipmi/ipmivars.h>\n\n  static struct ipmi_ident {\n          u_int16_t       vendor;\n          u_int16_t       device;\n          char            *description;\n  } ipmi_identifiers[] = {\n          { 0x1028, 0x000d, \"Dell PE2650 SMIC interface\" },\n          { 0, 0, 0 }\n  };\n\n  const char *\n  ipmi_pci_match(uint16_t vendor, uint16_t device)\n  {\n  ...\n  }\n\n  static int\n  ipmi_pci_probe(device_t dev)\n  {\n  ...\n  }\n\n  static int\n  ipmi_pci_attach(device_t dev)\n  {\n  ...\n  }\n\n  static device_method_t ipmi_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_probe,         ipmi_pci_probe),\n          DEVMETHOD(device_attach,        ipmi_pci_attach),\n          DEVMETHOD(device_detach,        ipmi_detach),\n          { 0, 0 }\n  };\n\n  static driver_t ipmi_pci_driver = {\n          \"ipmi\",\n          ipmi_methods,\n          sizeof(struct ipmi_softc)\n  };\n\n DRIVER_MODULE(ipmi_pci, pci, ipmi_pci_driver, ipmi_devclass, 0, 0);\n\n  static int\n  ipmi2_pci_probe(device_t dev)\n  {\n  ...\n  }\n\n  static int\n  ipmi2_pci_attach(device_t dev)\n  {\n  ...\n  }\n\n  static device_method_t ipmi2_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_probe,         ipmi2_pci_probe),\n          DEVMETHOD(device_attach,        ipmi2_pci_attach),\n          DEVMETHOD(device_detach,        ipmi_detach),\n          { 0, 0 }\n  };\n\n  static driver_t ipmi2_pci_driver = {\n          \"ipmi\",\n          ipmi2_methods,\n          sizeof(struct ipmi_softc)\n  };\n\n DRIVER_MODULE(ipmi2_pci, pci, ipmi2_pci_driver, ipmi_devclass, 0, 0);\n```", "```\nstatic int\nipmi_pci_probe(device_t dev)\n{\n        const char *desc;\n\n      if (ipmi_attached)\n              return (ENXIO);\n\n        desc = ipmi_pci_match(pci_get_vendor(dev), pci_get_device(dev));\n        if (desc != NULL) {\n                device_set_desc(dev, desc);\n                return (BUS_PROBE_DEFAULT);\n        }\n\n        return (ENXIO);\n}\n```", "```\nstatic struct ipmi_ident {\n        u_int16_t       vendor;\n        u_int16_t       device;\n        char            *description;\n} ipmi_identifiers[] = {\n        { 0x1028, 0x000d, \"Dell PE2650 SMIC interface\" },\n        { 0, 0, 0 }\n};\n```", "```\nconst char *\nipmi_pci_match(uint16_t vendor, uint16_t device)\n{\n        struct ipmi_ident *m;\n\n      for (m = ipmi_identifiers; m->vendor != 0; m++)\n                if (m->vendor == vendor && m->device == device)\n                        return (m->description);\n\n        return (NULL);\n}\n```", "```\nstatic int\nipmi_pci_attach(device_t dev)\n{\n        struct ipmi_softc *sc = device_get_softc(dev);\n        struct ipmi_get_info info;\n        const char *mode;\n        int error, type;\n\n      if (!ipmi_smbios_identify(&info))\n                return (ENXIO);\n\n        sc->ipmi_dev = dev;\n\n      switch (info.iface_type) {\n        case KCS_MODE:\n                mode = \"KCS\";\n                break;\n        case SMIC_MODE:\n                mode = \"SMIC\";\n                break;\n        case BT_MODE:\n                device_printf(dev, \"BT mode is unsupported\\n\");\n                return (ENXIO);\n        default:\n                device_printf(dev, \"No IPMI interface found\\n\");\n                return (ENXIO);\n        }\n\n        device_printf(dev,\n            \"%s mode found at %s 0x%jx alignment 0x%x on %s\\n\",\n            mode,\n            info.io_mode ? \"I/O port\" : \"I/O memory\",\n            (uintmax_t)info.address,\n            info.offset,\n            device_get_name(device_get_parent(dev)));\n\n        if (info.io_mode)\n              type = SYS_RES_IOPORT;\n        else\n              type = SYS_RES_MEMORY;\n\n        sc->ipmi_io_rid = PCIR_BAR(0);\n        sc->ipmi_io_res[0] = bus_alloc_resource_any(dev, type,\n          &sc->ipmi_io_rid, RF_ACTIVE);\n        sc->ipmi_io_type = type;\n        sc->ipmi_io_spacing = info.offset;\n\n        if (sc->ipmi_io_res[0] == NULL) {\n                device_printf(dev, \"could not configure PCI I/O resource\\n\");\n                return (ENXIO);\n        }\n\n        sc->ipmi_irq_rid = 0;\n        sc->ipmi_irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ,\n            &sc->ipmi_irq_rid, RF_SHAREABLE | RF_ACTIVE);\n\n        switch (info.iface_type) {\n        case KCS_MODE:\n                error = ipmi_kcs_attach(sc);\n                if (error)\n                        goto bad;\n                break;\n        case SMIC_MODE:\n                error = ipmi_smic_attach(sc);\n                if (error)\n                        goto bad;\n                break;\n        }\n\n        error = ipmi_attach(dev);\n        if (error)\n                goto bad;\n\n        return (0);\n\nbad:\n        ipmi_release_resources(dev);\n        return (error);\n}\n```", "```\nstatic int\nipmi2_pci_probe(device_t dev)\n{\n        if (pci_get_class(dev) == PCIC_SERIALBUS &&\n            pci_get_subclass(dev) == PCIS_SERIALBUS_IPMI) {\n                device_set_desc(dev, \"IPMI System Interface\");\n                return (BUS_PROBE_GENERIC);\n        }\n\n        return (ENXIO);\n}\n```", "```\nstatic int\nipmi2_pci_attach(device_t dev)\n{\n        struct ipmi_softc *sc = device_get_softc(dev);\n        int error, iface, type;\n\n        sc->ipmi_dev = dev;\n\n      switch (pci_get_progif(dev)) {\n        case PCIP_SERIALBUS_IPMI_SMIC:\n                iface = SMIC_MODE;\n                break;\n        case PCIP_SERIALBUS_IPMI_KCS:\n                iface = KCS_MODE;\n                break;\n        case PCIP_SERIALBUS_IPMI_BT:\n                device_printf(dev, \"BT interface is unsupported\\n\");\n                return (ENXIO);\n        default:\n                device_printf(dev, \"unsupported interface: %d\\n\",\n                    pci_get_progif(dev));\n                return (ENXIO);\n        }\n\n        sc->ipmi_io_rid = PCIR_BAR(0);\n      if (PCI_BAR_IO(pci_read_config(dev, PCIR_BAR(0), 4)))\n              type = SYS_RES_IOPORT;\n        else\n              type = SYS_RES_MEMORY;\n        sc->ipmi_io_type = type;\n        sc->ipmi_io_spacing = 1;\n        sc->ipmi_io_res[0] = bus_alloc_resource_any(dev, type,\n            &sc->ipmi_io_rid, RF_ACTIVE);\n        if (sc->ipmi_io_res[0] == NULL) {\n                device_printf(dev, \"could not configure PCI I/O resource\\n\");\n                return (ENXIO);\n        }\n\n        sc->ipmi_irq_rid = 0;\n        sc->ipmi_irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ,\n            &sc->ipmi_irq_rid, RF_SHAREABLE | RF_ACTIVE);\n\n        switch (iface) {\n        case KCS_MODE:\n                device_printf(dev, \"using KCS interface\\n\");\n\n                if (!ipmi_kcs_probe_align(sc)) {\n                        device_printf(dev,\n                            \"unable to determine alignment\\n\");\n                        error = ENXIO;\n                        goto bad;\n                }\n\n                error = ipmi_kcs_attach(sc);\n                if (error)\n                        goto bad;\n                break;\n        case SMIC_MODE:\n                device_printf(dev, \"using SMIC interface\\n\");\n\n                error = ipmi_smic_attach(sc);\n                if (error)\n                        goto bad;\n                break;\n        }\n\n        error = ipmi_attach(dev);\n        if (error)\n                goto bad;\n\n        return (0);\n\nbad:\n        ipmi_release_resources(dev);\n        return (error);\n}\n```"]