["```\n    int   cat   = 1;\n    int   dog   = 2;\n    char *mouse = \"small and furry\";\n\n    ```", "```\n    feedLion(mouse)\n    feedLion( hamster )\n    feedLion (motherInLaw)\n\n    ```", "```\n    int *mole;\n    int* badger;\n    int * toad;\n\n    ```", "```\n    for (...) { ostrich++;\n                buryHead(ostrich);\n               }\n\n    ```", "```\n    if (weAreAllDoomed) startPanicking();\n\n    ```", "```\n    char *end;\n    for (end = str; *end; ++end);\n\n    ```", "```\n`/* Returns whether num is prime.*/`\nbool\nisPrime( int num ) {\n    for ( int x = 2; x < num; ++x ) {\n        if ( !( num % x ) ) return false;\n    }\n    return true;\n}\n\n`/* This function calculates the 'n'th prime number.*/`\nint\nprime( int pos ) {\n    if ( pos ) {\n        int x = prime( pos-1 ) + 1;\n        while ( !isPrime( x ) ) {\n            ++x;\n        }\n        return x;\n    } else {\n        return 1;\n    }\n}\n\n```", "```\nFoo &getFoo();\nvoid setFoo(const Foo &) const;\n\n```", "```\nFoo &foo();\nvoid setFoo(const Foo &) const;\n\n```", "```\nFoo &foo();\nvoid foo(const Foo &) const;\n\n```", "```\n`void bsrt(int a[], int n) {     for (int i = 0; i < n-1; i++)         for (int j = n-1; j > i; j--)             if (a[j-1] > a[j])             {                 int tmp = a[j-1];                 a[j-1]  = a[j];                 a[j]    = tmp;             } }`\n\n```", "```\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\nvoid bubblesort(int items[], int size)\n{\n    for (int pos1 = 0; pos1 < size-1; pos1++)\n        for (int pos2 = size-1; pos2 > pos1; pos2â€”)\n            if (items[pos2-1] > items[pos2])\n                swap(&items[pos2-1], &items[pos2]);\n}\n\n```", "```\n`/* Declare the return type */`\nstruct return_float\n{\n    int reason_code;\n    float value;\n};\n\n`/* A function using it ... */`\nreturn_float myFunction() { ... }\n\n```", "```\nassert(greatest_common_divisor(10,  100) == 10);\nassert(greatest_common_divisor(100, 10)  == 10);\nassert(greatest_common_divisor(733, 449) == 0);\n... more tests ...\n\n```", "```\nint greatest_common_divisor(int a, int b)\n{\n    a = std::abs(a);\n    b = std::abs(b);\n    for (int div = std::min(a,b); div > 0; --div)\n    {\n        if ((a % div == 0) && (b % div == 0))\n           return div;\n    }\n    return 0;\n}\n\n```", "```\n%.o: %.c\n    compiler -object %.o `-dep %.d` %.c\n\n```", "```\n include *.d\n\n```", "```\n`# Define the source files`\nSRC_FILES = main.c func1.c func2.c\n\n`# Default build type (if none specified)`\nBUILD_TYPE ?= release\n\n`# Synthesize the object filenames # (This is a magic GNU Make incantation that swaps # the .c file suffix for .o)`\nOBJ_FILES = $(SRC_FILES:.c=.o)\n\n`# Now the clever bit: add the build-type directory # prefix to object filenames (more GNU Make magic)`\nOBJ_FILES = $(addprefix $(BUILD_TYPE)/, $(OBJ_FILES))\n\n```", "```\n$(BUILD_TYPE):\n    mkdir -p $(BUILD_TYPE)\n\n```", "```\nBUILD_TYPE=release make all\nBUILD_TYPE=debug make all\n\n```"]