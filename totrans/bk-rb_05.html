<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Loops and Iterators"><div class="titlepage"><div><div><h1 class="title"><a id="loops_and_iterators"/>Chapter 5. Loops and Iterators</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id7"/><div class="mediaobject"><a id="I_mediaobject5_d1e5588"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Much of programming is concerned with repetition. Maybe you want your program to beep 10 times, read lines from a file as long as there are more lines to read, or display a warning until the user presses a key. Ruby provides a number of ways of performing this kind of repetition.<a id="IDX-CHP-5-0001" class="indexterm"/></p><div class="sect1" title="for Loops"><div class="titlepage"><div><div><h1 class="title"><a id="for_loops"/>for Loops</h1></div></div></div><p>In many programming languages, when you want to run a bit of code a certain number of times, you can just put it inside a <code class="literal">for</code> loop. In most languages, you give a <code class="literal">for</code> loop a variable initialized with a starting value that is incremented by 1 on each turn through the loop until it meets some specific ending value. When the ending value is met, the <code class="literal">for</code> loop stops running.</p><p>Here’s a version of this traditional type of <code class="literal">for</code> loop written in Pascal:<a id="IDX-CHP-5-0002" class="indexterm"/><a id="IDX-CHP-5-0003" class="indexterm"/><a id="IDX-CHP-5-0004" class="indexterm"/></p><a id="I_programlisting5_d1e5630"/><pre class="programlisting">(* This is Pascal code, not Ruby! *)
for i := 1 to 3 do
   writeln( i );</pre><p>You may recall from the previous chapter that Ruby’s <code class="literal">for</code> loop doesn’t work like this at all! Instead of giving it starting and ending values, you give the <code class="literal">for</code> loop a list of items, and it iterates over them, one by one, assigning each value in turn to a loop variable until it gets to the end of the list.<a id="IDX-CHP-5-0005" class="indexterm"/></p><p>For example, here is a <code class="literal">for</code> loop that iterates over the items in an array, displaying each in turn:</p><p><span class="emphasis"><em>for_loop.rb</em></span></p><a id="I_programlisting5_d1e5651"/><pre class="programlisting"># This is Ruby code...
for i in [1,2,3] do
   puts( i )
end</pre><p>The <code class="literal">for</code> loop is more like the “for each” iterator provided by some other programming languages. The items over which the loop iterates don’t have to be integers. This works just as well:</p><a id="I_programlisting5_d1e5658"/><pre class="programlisting">for s in ['one','two','three'] do
   puts( s )
end</pre><p>The author of Ruby describes <code class="literal">for</code> as “syntax sugar” for the <code class="literal">each</code> method, which is implemented by collection types such as Arrays, Sets, Hashes, and Strings (a String being, in effect, a collection of characters). For the sake of comparison, this is one of the <code class="literal">for</code> loops shown earlier rewritten using the <code class="literal">each</code> method:</p><p><span class="emphasis"><em>each_loop.rb</em></span></p><a id="I_programlisting5_d1e5678"/><pre class="programlisting">[1,2,3].each  do |i|
   puts( i )
end</pre><p>As you can see, there isn’t really all that much difference. To convert the <code class="literal">for</code> loop to an <code class="literal">each</code> iterator, all I’ve had to do is delete <code class="literal">for</code> and <code class="literal">in</code> and append <code class="literal">.each</code> to the array. Then I’ve put the iterator variable, <code class="literal">i</code>, between a pair of upright bars after <code class="literal">do</code>. Compare these other examples to see just how similar <code class="literal">for</code> loops are to <code class="literal">each</code> iterators.</p><p><span class="emphasis"><em>for_each.rb</em></span></p><a id="I_programlisting5_d1e5713"/><pre class="programlisting"># --- Example 1 ---
# i) for
for s in ['one','two','three'] do
   puts( s )
end

# ii) each
['one','two','three'].each do |s|
   puts( s )
end

# --- Example 2 ---
# i) for
for x in [1, "two", [3,4,5] ] do puts( x ) end

# ii) each
[1, "two", [3,4,5] ].each do |x| puts( x ) end</pre><p>Note, incidentally, that the <code class="literal">do</code> keyword is optional in a <code class="literal">for</code> loop that spans multiple lines, but it is obligatory when it is written on a single line:<a id="IDX-CHP-5-0006" class="indexterm"/><a id="IDX-CHP-5-0007" class="indexterm"/></p><a id="I_programlisting5_d1e5731"/><pre class="programlisting"># Here the 'do' keyword can be omitted
for s in ['one','two','three']
   puts( s )
end

# But here it is required
for s in ['one','two','three'] do puts( s ) end</pre><p>This example shows how both <code class="literal">for</code> and <code class="literal">each</code> can be used to iterate over the values in a range:</p><p><span class="emphasis"><em>for_each2.rb</em></span></p><a id="I_programlisting5_d1e5744"/><pre class="programlisting"># for
for s in 1..3
   puts( s )
end

# each
(1..3).each do |s|
   puts(s)
end</pre><div class="sidebar"><a id="how_to_write_a_lnormalr_for_loop"/><p class="title">How to Write a “Normal” for Loop</p><p>If you miss the traditional type of <code class="literal">for</code> loop, you can always fake it in Ruby by using a <code class="literal">for</code> loop to iterate over the values in a range. For example, this is how to use a <code class="literal">for</code> loop variable to count up from 1 to 10, displaying its value at each turn through the loop:</p><a id="I_programlisting5_d1e5760"/><pre class="programlisting">for i in (1..10) do
   puts( i )
end</pre></div><p><span class="emphasis"><em>for_to.rb</em></span></p><p>Note, incidentally, that a range expression such as <code class="literal">1..3</code> must be enclosed between parentheses when used with the <code class="literal">each</code> method, or Ruby assumes you are attempting to use <code class="literal">each</code> as a method of the final integer (a Fixnum) rather than of the entire expression (a Range). The parentheses are optional when a range is used in a <code class="literal">for</code> loop.<a id="IDX-CHP-5-0008" class="indexterm"/></p></div></div>
<div class="sect1" title="Blocks and Block Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_and_block_parameters"/>Blocks and Block Parameters</h1></div></div></div><p>In Ruby, the body of an iterator is called a <span class="emphasis"><em>block</em></span>, and any variables declared between upright bars at the top of a block are called <span class="emphasis"><em>block parameters</em></span>. In a way, a block works like a function, and the block parameters work like a function’s argument list. The <code class="literal">each</code> method runs the code inside the block and passes to it the arguments supplied by a collection (such as the array, <code class="literal">multiarr</code>). In the example from the previous section, the <code class="literal">each</code> method repeatedly passes an array of four elements to the block, and those elements initialize the four block parameters, <code class="literal">a, b, c, d</code>. Blocks can be used for other things, in addition to iterating over collections.<a id="IDX-CHP-5-0009" class="indexterm"/><a id="IDX-CHP-5-0010" class="indexterm"/><a id="IDX-CHP-5-0011" class="indexterm"/></p><p>Ruby also has an alternative syntax for delimiting blocks. Instead of using <code class="literal">do..end</code>, you can use curly brackets <code class="literal">{..}</code> like this:<a id="IDX-CHP-5-0012" class="indexterm"/></p><p><span class="emphasis"><em>block_syntax.rb</em></span></p><a id="I_programlisting5_d1e5836"/><pre class="programlisting"># do..end
[[1,2,3],[3,4,5],[6,7,8]].each do
   |a,b,c|
     puts( "#{a}, #{b}, #{c}" )
end

# curly brackets {..}
[[1,2,3],[3,4,5],[6,7,8]].each{
   |a,b,c|
     puts( "#{a}, #{b}, #{c}" )
}</pre><p>No matter which block delimiters you use, you must ensure that the opening delimiter, <code class="literal">{</code> or <code class="literal">do</code>, is placed on the same line as the <code class="literal">each</code> method. Inserting a line break between <code class="literal">each</code> and the opening block delimiter is a syntax error. I’ll have more to say on blocks in <a class="xref" href="ch10.html" title="Chapter 10. Blocks, Procs, and Lambdas">Chapter 10</a>.</p></div>
<div class="sect1" title="Iterating upto and downto"><div class="titlepage"><div><div><h1 class="title"><a id="iterating_upto_and_downto"/>Iterating upto and downto</h1></div></div></div><p>If you need to count from a specific low value up to a high value, you may use the <code class="literal">upto()</code> method of an integer. A block argument may optionally be used if you want to display the value at each iteration:<a id="IDX-CHP-5-0013" class="indexterm"/></p><p><span class="emphasis"><em>upto_downto.rb</em></span><a id="IDX-CHP-5-0014" class="indexterm"/></p><a id="I_programlisting5_d1e5871"/><pre class="programlisting">0.upto(10) do
    | i |
    puts( i )
end</pre><p>The previous code displays the integers 0 to 10. You may also count down from a high to a low value using the <code class="literal">downto()</code> method:<a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/></p><a id="I_programlisting5_d1e5888"/><pre class="programlisting">10.downto(0) do
    | i |
    puts( i )
end</pre><p>As you can probably guess, this code displays 10 to 0.</p></div>
<div class="sect1" title="Multiple Iterator Arguments"><div class="titlepage"><div><div><h1 class="title"><a id="multiple_iterator_arguments"/>Multiple Iterator Arguments</h1></div></div></div><p>In the previous chapter, you used a <code class="literal">for</code> loop with more than one loop variable to iterate over a multidimensional array. On each turn through the <code class="literal">for</code> loop, a variable was assigned one row (that is, one “subarray”) from the outer array:</p><p><span class="emphasis"><em>multi_array.rb</em></span></p><a id="I_programlisting5_d1e5906"/><pre class="programlisting"># Here multiarr is an array containing two 'rows'
# (subarrays) at index 0 and 1
multiarr = [    ['one','two','three','four'],
                [1,2,3,4]
           ]
# This for loop runs twice (once for each 'row' of multiarr)
for (a,b,c,d) in multiarr
   print("a=#{a}, b=#{b}, c=#{c}, d=#{d}\n" )
end</pre><p>The previous loop prints this:</p><a id="I_programlisting5_d1e5910"/><pre class="programlisting">a=one, b=two, c=three, d=four
a=1, b=2, c=3, d=4</pre><p>However, you could also use the <code class="literal">each</code> method to iterate over this four-item array by passing four block parameters—<code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, <code class="literal">d</code>—into the block delimited by <code class="literal">do</code> and <code class="literal">end</code> at each iteration:</p><a id="I_programlisting5_d1e5936"/><pre class="programlisting">multiarr.each do |a,b,c,d|
   print("a=#{a}, b=#{b}, c=#{c}, d=#{d}\n" )
end</pre><p>And, of course, the alternative block syntax, delimited by curly brackets, works just as well:</p><a id="I_programlisting5_d1e5940"/><pre class="programlisting">multiarr.each{  |a,b,c,d|
    print("a=#{a}, b=#{b}, c=#{c}, d=#{d}\n" )
}</pre><p>Both of the previous examples pass the two elements from the <code class="literal">multiarr</code> array into the iterator block. The first element is itself an array of four strings: <code class="literal">['one','two','three','four']</code>. Since the block has four parameters declared between a pair of upright bars, <code class="literal">|a,b,c,d|</code>, the four strings are assigned to the matching parameters, which are then printed with the <code class="literal">print</code> statement. Then the <code class="literal">each</code> method passes the second element of <code class="literal">multiarr</code> into the block. This is another four-element array, this time containing integers: <code class="literal">[1,2,3,4]</code>. These are again assigned to the block parameters, <code class="literal">|a,b,c,d|</code>, and the <code class="literal">print</code> statement displays them. Note that the output is identical as when you used the <code class="literal">for</code> loop:<a id="IDX-CHP-5-0017" class="indexterm"/><a id="IDX-CHP-5-0018" class="indexterm"/></p><a id="I_programlisting5_d1e5983"/><pre class="programlisting">a=one, b=two, c=three, d=four
a=1, b=2, c=3, d=4</pre></div>
<div class="sect1" title="while Loops"><div class="titlepage"><div><div><h1 class="title"><a id="while_loops"/>while Loops</h1></div></div></div><p>Ruby has a few other loop constructs too. This is how to do a <code class="literal">while</code> loop:<a id="IDX-CHP-5-0019" class="indexterm"/></p><a id="I_programlisting5_d1e5998"/><pre class="programlisting">while tired
   sleep
end</pre><p>Or, here’s another way to put it:</p><a id="I_programlisting5_d1e6002"/><pre class="programlisting">sleep while tired</pre><p>Even though the syntax of these two examples is different, they perform the same function. In the first example, the code between <code class="literal">while</code> and <code class="literal">end</code> (here a call to a method named <code class="literal">sleep</code>) executes just as long as the Boolean condition (which, in this case, is the value returned by a method called <code class="literal">tired</code>) evaluates to true. As in <code class="literal">for</code> loops, the keyword <code class="literal">do</code> may optionally be placed between the test condition and the code to be executed when these appear on separate lines; the <code class="literal">do</code> keyword is obligatory when the test condition and the code to be executed appear on the same line.</p><div class="sect2" title="while Modifiers"><div class="titlepage"><div><div><h2 class="title"><a id="while_modifiers"/>while Modifiers</h2></div></div></div><p>In the second version of the loop (<code class="literal">sleep while tired</code>), the code to be executed (<code class="literal">sleep</code>) precedes the test condition (<code class="literal">while tired</code>). This syntax is called a <span class="emphasis"><em>while modifier</em></span>. When you want to execute several expressions using this syntax, you can put them between the <code class="literal">begin</code> and <code class="literal">end</code> keywords:</p><a id="I_programlisting5_d1e6052"/><pre class="programlisting">begin
   sleep
   snore
end while tired</pre><p>Here is an example showing the various alternative syntaxes:<a id="IDX-CHP-5-0020" class="indexterm"/><a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/></p><p><span class="emphasis"><em>1loops.rb</em></span><a id="IDX-CHP-5-0023" class="indexterm"/></p><a id="I_programlisting5_d1e6075"/><pre class="programlisting">$hours_asleep = 0

def tired
    if $hours_asleep &gt;= 8 then
       $hours_asleep = 0
      return false
    else
        $hours_asleep += 1
        return true
    end
end

def snore
    puts('snore....')
end

def sleep
    puts("z" * $hours_asleep )
end

while tired do sleep end    # a single-line while loop

while tired                 # a multiline while loop
    sleep
end

sleep while tired           # single-line while modifier

begin                       # multiline while modifier
    sleep
    snore
end while tired</pre><p>The last example in the previous code (the multiline <code class="literal">while</code> modifier) needs close consideration because it introduces some important new behavior. When a block of code delimited by <code class="literal">begin</code> and <code class="literal">end</code> precedes the <code class="literal">while</code> test, that code always executes at least once. In the other types of <code class="literal">while</code> loop, the code may never execute at all if the Boolean condition initially evaluates to false.</p></div><div class="sect2" title="Ensuring a while Loop Executes at Least Once"><div class="titlepage"><div><div><h2 class="title"><a id="ensuring_a_while_loop_executes_at_least"/>Ensuring a while Loop Executes at Least Once</h2></div></div></div><p>Usually a <code class="literal">while</code> loops executes zero or more times since the Boolean test is evaluated before the loop executes; if the test returns false at the outset, the code inside the loop never runs. However, when the <code class="literal">while</code> test follows a block of code enclosed between <code class="literal">begin</code> and <code class="literal">end</code>, the loop executes one or more times as the Boolean expression is evaluated after the code inside the loop executes.</p><p>These examples should help clarify:<a id="IDX-CHP-5-0024" class="indexterm"/><a id="IDX-CHP-5-0025" class="indexterm"/></p><p><span class="emphasis"><em>2loops.rb</em></span></p><a id="I_programlisting5_d1e6124"/><pre class="programlisting">x = 100

    # The code in this loop never runs
while (x &lt; 100) do puts('x &lt; 100') end

    # The code in this loop never runs
puts('x &lt; 100') while (x &lt; 100)

    # But the code in loop runs once
begin puts('x &lt; 100') end while (x &lt; 100)</pre></div></div>
<div class="sect1" title="until Loops"><div class="titlepage"><div><div><h1 class="title"><a id="until_loops"/>until Loops</h1></div></div></div><p>Ruby also has an <code class="literal">until</code> loop, which can be thought of as a <span class="emphasis"><em>while not</em></span> loop. Its syntax and options are the same as those applying to <code class="literal">while</code>—that is, the test condition and the code to be executed can be placed on a single line (in which case the <code class="literal">do</code> keyword is obligatory) or can be placed on separate lines (in which case <code class="literal">do</code> is optional). There is also an <code class="literal">until</code> modifier that lets you put the code before the test condition and an option to enclose the code between <code class="literal">begin</code> and <code class="literal">end</code> in order to ensure that the code block is run at least once.<a id="IDX-CHP-5-0026" class="indexterm"/></p><p>Here are some simple examples of <code class="literal">until</code> loops:</p><p><span class="emphasis"><em>until.rb</em></span></p><a id="I_programlisting5_d1e6169"/><pre class="programlisting">i = 10

until i == 10 do puts(i) end     # never executes

until i == 10                    # never executes
    puts(i)
    i += 1
end

puts(i) until i == 10            # never executes

begin                            # executes once
    puts(i)
end until i == 10</pre><p>Both <code class="literal">while</code> and <code class="literal">until</code> loops can, just like a <code class="literal">for</code> loop, be used to iterate over arrays and other collections. For example, the following code shows two ways of iterating over all the elements in an array:</p><p><span class="emphasis"><em>array_iterate.rb</em></span></p><a id="I_programlisting5_d1e6185"/><pre class="programlisting">arr= [1,2,3,4,5]
i = 0

while i &lt; arr.length
    puts(arr[i])
    i += 1
end

i=0
until i == arr.length
    puts(arr[i])
    i +=1
end</pre></div>
<div class="sect1" title="loop"><div class="titlepage"><div><div><h1 class="title"><a id="loop"/>loop</h1></div></div></div><p>Unlike <code class="literal">for</code> and <code class="literal">while</code>, the <code class="literal">loop</code> command does not evaluate a test condition to determine whether to continue looping. To break out of the loop, you have to explicitly use the <code class="literal">break</code> keyword, as you can see in the following examples:<a id="IDX-CHP-5-0027" class="indexterm"/><a id="IDX-CHP-5-0028" class="indexterm"/><a id="IDX-CHP-5-0029" class="indexterm"/></p><p><span class="emphasis"><em>3loops.rb</em></span></p><a id="I_programlisting5_d1e6217"/><pre class="programlisting">i=0
loop do
    puts(arr[i])
    i+=1
    if (i == arr.length) then
       break
    end
end

loop {
    puts(arr[i])
    i+=1
    if (i == arr.length) then
       break
    end
}</pre><p>These use the <code class="literal">loop</code> method repeatedly to execute the block of code that follows. These blocks are just like the iterator blocks you used earlier with the <code class="literal">each</code> method. Once again, you have a choice of block delimiters, either curly brackets or <code class="literal">do</code> and <code class="literal">end</code>.</p><p>In each case, the code iterates through the array, <code class="literal">arr</code>, by incrementing a counter variable, <code class="literal">i</code>, and breaking out of the loop when the <code class="literal">(i == arr.length)</code> condition evaluates to true. Note that without a <code class="literal">break</code>, these would loop forever.</p><div class="sidebar"><a id="digging_deeper-id4"/><p class="title">Digging Deeper</p><p>Ruby provides a number of ways of iterating over items in structures such as arrays and ranges. Here we discover the inner details of the enumerations and comparisons.<a id="IDX-CHP-5-0030" class="indexterm"/></p><p><span class="bolditalic">The Enumerable Module</span></p><p>Hashes, Arrays, Ranges, and Sets all include a Ruby module called <code class="literal">Enumerable</code>. It provides these data structures with a number of useful methods such as <code class="literal">include?</code>, which returns true if a specific value is found; <code class="literal">min</code>, which returns the smallest value; <code class="literal">max</code>, which returns the largest; and <code class="literal">collect</code>, which creates a new structure made up of values returned from a block. In the following code, you can see some of these functions being used on an array:<a id="IDX-CHP-5-0031" class="indexterm"/><a id="IDX-CHP-5-0032" class="indexterm"/><a id="IDX-CHP-5-0033" class="indexterm"/><a id="IDX-CHP-5-0034" class="indexterm"/><a id="IDX-CHP-5-0035" class="indexterm"/><a id="IDX-CHP-5-0036" class="indexterm"/><a id="IDX-CHP-5-0037" class="indexterm"/><a id="IDX-CHP-5-0038" class="indexterm"/><a id="IDX-CHP-5-0039" class="indexterm"/><a id="IDX-CHP-5-0040" class="indexterm"/></p><p><span class="emphasis"><em>enum.rb</em></span></p><a id="I_programlisting5_d1e6321"/><pre class="programlisting">x = (1..5).collect{ |i| i }
p( x )                        #=&gt; [1, 2, 3, 4, 5]

arr = [1,2,3,4,5]
y = arr.collect{ |i| i }
p( y )                        #=&gt; [1, 2, 3, 4, 5]
z = arr.collect{ |i| i * i }
p( z )                        #=&gt; [1, 4, 9, 16, 25]

p( arr.include?( 3 ) )        #=&gt; true
p( arr.include?( 6 ) )        #=&gt; false
p( arr.min )                  #=&gt; 1
p( arr.max )                  #=&gt; 5</pre><p>These same methods are available to other collection classes too, as long as those classes include <code class="literal">Enumerable</code>. Here’s an example using the Hash class:</p><p><span class="emphasis"><em>enum2.rb</em></span></p><a id="I_programlisting5_d1e6331"/><pre class="programlisting">h = {'one'=&gt;'for sorrow',
    'two'=&gt;'for joy',
    'three'=&gt;'for a girl',
    'four'=&gt;'for a boy'}

y = h.collect{ |i| i }
p( y )</pre><p>This code outputs the following:</p><a id="I_programlisting5_d1e6335"/><pre class="programlisting">[["one", "for sorrow"], ["two", "for joy"], ["three", "for a
 girl"], ["four", "for a boy"]]</pre><p>Note that because of changes in the way hashes are stored, the order of the items displayed when this code runs differs in Ruby 1.8 and Ruby 1.9. Remember too that the items in a Hash are not indexed in sequential order, so when you use the <code class="literal">min</code> and <code class="literal">max</code> methods, these return the items that are lowest and highest according to their numerical value—here the items are strings, and the numerical value is determined by the ASCII codes of the characters in the key.<a id="IDX-CHP-5-0041" class="indexterm"/><a id="IDX-CHP-5-0042" class="indexterm"/></p><a id="I_programlisting5_d1e6352"/><pre class="programlisting">p( h.min )    #=&gt; ["one", "for sorrow"]
p( h.max )    #=&gt; ["two", "for joy"]</pre><p><span class="bolditalic">Custom Comparisons</span></p><p>What if you want <code class="literal">min</code> and <code class="literal">max</code> to return items based on some other criterion (say the length of a string)? The easiest way to do this would be to define the nature of the comparison inside a block. This is done in a similar manner to the sorting blocks I defined in <a class="xref" href="ch04.html" title="Chapter 4. Arrays and Hashes">Chapter 4</a>. You may recall that you sorted a hash (here the variable <code class="literal">h</code>) by passing a block to the <code class="literal">sort</code> method like this:<a id="IDX-CHP-5-0043" class="indexterm"/></p><a id="I_programlisting5_d1e6377"/><pre class="programlisting">h.sort{ |a,b| a.to_s &lt;=&gt; b.to_s  }</pre><p>The two parameters, <code class="literal">a</code> and <code class="literal">b</code>, represent two items from the hash that are compared using the <code class="literal">&lt;=&gt;</code> comparison method. You can similarly pass blocks to the <code class="literal">max</code> and <code class="literal">min</code> methods:</p><a id="I_programlisting5_d1e6396"/><pre class="programlisting">h.min{ |a,b| a[0].length &lt;=&gt; b[0].length }
h.max{|a,b| a[0].length &lt;=&gt; b[0].length }</pre><p>When a hash passes items into a block, it does so in the form of arrays, each of which contains a key-value pair. So, if a hash contains items like this:</p><a id="I_programlisting5_d1e6400"/><pre class="programlisting">{'one'=&gt;'for sorrow', 'two'=&gt;'for joy'}</pre><p>then the two block arguments, <code class="literal">a</code> and <code class="literal">b</code>, would be initialized to two arrays:</p><a id="I_programlisting5_d1e6410"/><pre class="programlisting">a = ['one', 'for sorrow']
b = ['two', 'for joy']</pre><p>This explains why the two blocks in which I have defined custom comparisons for the <code class="literal">max</code> and <code class="literal">min</code> methods specifically compare the first elements, at index 0, of the two block parameters:<a id="IDX-CHP-5-0044" class="indexterm"/></p><a id="I_programlisting5_d1e6424"/><pre class="programlisting">a[0].length &lt;=&gt; b[0].length</pre><p>This ensures that the comparisons are based on the <span class="emphasis"><em>keys</em></span> in the hash. There is a potential pitfall here, however. As explained in the previous chapter, the default ordering of hashes is different in Ruby 1.8 and Ruby 1.9. This means that if you sort by the length of the key, as I did with my custom comparator earlier, and more than one key has the same length, the first match returned will be different in different versions of Ruby. For example, in my hash, the first two keys (“one” and “two”) have the same length. So when I use <code class="literal">min</code> with a comparison based on the key length, the result will be different in Ruby versions 1.8 and 1.9:<a id="IDX-CHP-5-0045" class="indexterm"/><a id="IDX-CHP-5-0046" class="indexterm"/></p><a id="I_programlisting5_d1e6444"/><pre class="programlisting">p( h.min{|a,b| a[0].length &lt;=&gt; b[0].length } )</pre><p>Ruby 1.8 displays the following:</p><a id="I_programlisting5_d1e6448"/><pre class="programlisting">["two", "for joy"]</pre><p>Ruby 1.9 displays the following:</p><a id="I_programlisting5_d1e6452"/><pre class="programlisting">["one", "for sorrow"]</pre><p>This is another illustration of why it is always safer to make no assumptions of the ordering of the elements in a hash. Now let’s assume you want to compare the <span class="emphasis"><em>values</em></span> rather than the keys. In the previous example, you could do this quite simply by changing the array indexes from 0 to 1:</p><p><span class="emphasis"><em>enum3.rb</em></span></p><a id="I_programlisting5_d1e6462"/><pre class="programlisting">p( h.min{|a,b| a[1].length &lt;=&gt; b[1].length } )
p( h.max{|a,b| a[1].length &lt;=&gt; b[1].length } )</pre><p>The value with the lowest length is “for joy” and the value with the highest length is “for a secret never to be told,” so the previous code displays the following:</p><a id="I_programlisting5_d1e6467"/><pre class="programlisting">["two", "for joy"]
["seven", "for a secret never to be told"]</pre><p>You could, of course, define other types of custom comparisons in your blocks. Let’s suppose, for example, that you want the strings “one,” “two,” “three,” and so on, to be evaluated in the order in which you would speak them. One way of doing this would be to create an ordered array of strings:</p><a id="I_programlisting5_d1e6471"/><pre class="programlisting">str_arr=['one','two','three','four','five','six','seven']</pre><p>Now, if a hash, <code class="literal">h</code>, contains these strings as keys, a block can use <code class="literal">str_array</code> as a reference in order to determine the minimum and maximum values. This also assures that we obtain the same results no matter which version of Ruby is used:</p><a id="I_programlisting5_d1e6481"/><pre class="programlisting">h.min{|a,b| str_arr.index(a[0]) &lt;=&gt; str_arr.index(b[0])}
h.max{|a,b| str_arr.index(a[0]) &lt;=&gt; str_arr.index(b[0])}</pre><p>This displays the following:<a id="IDX-CHP-5-0047" class="indexterm"/></p><a id="I_programlisting5_d1e6490"/><pre class="programlisting">["one", "for sorrow"]
["seven", "for a secret never to be told"]</pre><p>All the previous examples use the <code class="literal">min</code> and <code class="literal">max</code> methods of the Array and Hash classes. Remember that these methods are provided to those classes by the <code class="literal">Enumerable</code> module, which is “included” in the Array and Hash classes.</p><p>There may be occasions when it would be useful to be able to apply <code class="literal">Enumerable</code> methods such as <code class="literal">max</code>, <code class="literal">min</code>, and <code class="literal">collect</code> to classes that do not descend from existing classes (such as Array) that implement those methods. You can do that by including the <code class="literal">Enumerable</code> module in your class and then writing an iterator method called <code class="literal">each</code> like this:<a id="IDX-CHP-5-0048" class="indexterm"/></p><p><span class="emphasis"><em>include_enum1.rb</em></span></p><a id="I_programlisting5_d1e6531"/><pre class="programlisting">class MyCollection
   include Enumerable

   def initialize( someItems )
     @items = someItems
   end

   def each
     @items.each{ |i|
       yield( i )
     }
   end
end</pre><p>Here you initialize a MyCollection object with an array, which will be stored in the instance variable, <code class="literal">@items</code>. When you call one of the methods provided by the <code class="literal">Enumerable</code> module (such as <code class="literal">min</code>, <code class="literal">max</code>, or <code class="literal">collect</code>), this will call the <code class="literal">each</code> method to obtain each piece of data one at a time. So, here the <code class="literal">each</code> method passes each value from the <code class="literal">@items</code> array into the block where that item is assigned to the block parameter <code class="literal">i</code>. The keyword <code class="literal">yield</code> is a special bit of Ruby magic that runs a block of code that was passed to the <code class="literal">each</code> method. You’ll look at this in much more depth when I discuss Ruby blocks in <a class="xref" href="ch10.html" title="Chapter 10. Blocks, Procs, and Lambdas">Chapter 10</a>.</p><p>Now you can use the <code class="literal">Enumerable</code> methods with your MyCollection objects:</p><p><span class="emphasis"><em>include_enum2.rb</em></span></p><a id="I_programlisting5_d1e6580"/><pre class="programlisting">things = MyCollection.new(['x','yz','defgh','ij','klmno'])

p( things.min )        #=&gt; "defgh"
p( things.max )        #=&gt; "yz"
p( things.collect{ |i| i.upcase } )
                       #=&gt; ["X", "YZ", "DEFGH", "IJ", "KLMNO"]</pre><p>You could similarly use your MyCollection class to process arrays such as the keys or values of hashes. Currently the <code class="literal">min</code> and <code class="literal">max</code> methods adopt the default behavior: They perform comparisons based on numerical values. This means that “xy” is considered to have a “higher” value than “abcd” on the basis of the characters’ ASCII values. If you want to perform some other type of comparison—say, by string length, so that “abcd” would be deemed to be higher than “xz”—you can override the <code class="literal">min</code> and <code class="literal">max</code> methods:<a id="IDX-CHP-5-0049" class="indexterm"/></p><a id="I_programlisting5_d1e6601"/><pre class="programlisting">def min
  @items.to_a.min{|a,b| a.length &lt;=&gt; b.length }
end

def max
  @items.to_a.max{|a,b| a.length &lt;=&gt; b.length }
end</pre><p>Here is the complete class definition with its versions of <code class="literal">each</code>, <code class="literal">min</code>, and <code class="literal">max</code>:</p><p><span class="emphasis"><em>include_enum3.rb</em></span></p><a id="I_programlisting5_d1e6617"/><pre class="programlisting">class MyCollection
  include Enumerable

    def initialize( someItems )
        @items = someItems
    end

    def each
        @items.each{ |i| yield i }
    end

    def min
        @items.to_a.min{|a,b| a.length &lt;=&gt; b.length }
    end

    def max
        @items.to_a.max{|a,b| a.length &lt;=&gt; b.length }
    end
end</pre><p>A MyCollection object can now be created, and its overridden methods can be used in this way:</p><a id="I_programlisting5_d1e6622"/><pre class="programlisting">things = MyCollection.new(['z','xy','defgh','ij','abc','klmnopqr'])
x = things.collect{ |i| i }
p( x ) #=&gt; ["z", "xy", "defgh", "ij", "abc", "klmnopqr"]
y = things.max
p( y ) #=&gt; "klmnopqr"
z = things.min
p( z ) #=&gt; "z"</pre><p><span class="bolditalic">each and yield</span></p><p>So what is really going on when a method from the <code class="literal">Enumerable</code> module uses the <code class="literal">each</code> method that you’ve written? It turns out that the <code class="literal">Enumerable</code> methods (<code class="literal">min</code>, <code class="literal">max</code>, <code class="literal">collect</code> and so forth) pass to the <code class="literal">each</code> method a block of code. This block of code expects to receive one piece of data at a time (namely, each item from a collection of some sort). Your <code class="literal">each</code> method supplies it with that item in the form of a block parameter, such as the parameter <code class="literal">i</code> here:<a id="IDX-CHP-5-0050" class="indexterm"/><a id="IDX-CHP-5-0051" class="indexterm"/><a id="IDX-CHP-5-0052" class="indexterm"/></p><a id="I_programlisting5_d1e6670"/><pre class="programlisting">def each
   @items.each{ |i|
       yield( i )
   }
end</pre><p>As mentioned earlier, the keyword <code class="literal">yield</code> tells the code to run the block that was passed to the <code class="literal">each</code> method—that is, to run the code supplied by the <code class="literal">Enumerable</code> module’s <code class="literal">min</code>, <code class="literal">max</code>, or <code class="literal">collect</code> methods. This means that the code of those methods can be used with all kinds of different types of collections. All you have to do is include the <code class="literal">Enumerable</code> module into your class and write an <code class="literal">each</code> method that determines which values will be used by the <code class="literal">Enumerable</code> methods.<a id="IDX-CHP-5-0053" class="indexterm"/></p></div></div></body></html>