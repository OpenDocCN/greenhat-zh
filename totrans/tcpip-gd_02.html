<html><head></head><body><div class="part" title="Part&#xA0;I-2.&#xA0;THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL"><div class="titlepage"><div><div><h1 class="title"><a id="the_open_systems_interconnection_osi_reference_model"/>Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL</h1></div></div></div><div class="partintro" id="id3188209" title="THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL"><div/><p><a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a></p><p><a class="xref" href="ch06.html" title="Chapter 6. OSI REFERENCE MODEL LAYERS">Chapter 6</a></p><p><a class="xref" href="ch07.html" title="Chapter 7. OSI REFERENCE MODEL SUMMARY">Chapter 7</a></p><p>Models are useful because they help us understand difficult concepts and complicated systems. When it comes to networking, there are several models that are used to explain the roles played by various technologies and how they interact. Of these, the most popular and commonly used is the Open Systems Interconnection (OSI) Reference Model. The OSI Reference Model makes it easier for networks to be analyzed, designed, built, and rearranged, by allowing them to be considered as modular pieces that interact in predictable ways, rather than enormous, complex monoliths.</p><p>You'll find that it's nearly impossible to read a lot about networking without encountering discussions that presume at least some knowledge of how the OSI Reference Model works. This is why I strongly advise that if you are new to the OSI Reference Model, you read this part carefully. While it is all arguably background material, this information will give you a foundation for understanding networks, as well as make the rest of the book easier to follow. If you are quite familiar with the OSI Reference Model, you may wish to skip this part or just skim through it.</p><p>This part is geared to a discussion of networks and internetworks in general, and not specifically to the TCP/IP protocol suite. Therefore, not all of the material in this section is directly relevant to learning about TCP/IP, although much of it is. You may also wish to refer to <a class="xref" href="pt03.html" title="Part I-3. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Part I-3</a>, which includes a discussion of how the TCP/IP and OSI models compare.</p><p>In this part, I describe the OSI Reference Model in detail. I begin with a discussion of some general concepts related to the OSI Reference Model and networking models overall. I then describe each of the seven layers of the OSI Reference Model. I conclude with a summary chapter that includes a useful analogy to help you understand how the reference model works to explain the interaction of networks on multiple levels. That chapter also presents a reference table of the layers and their respective functions.</p></div></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="general_osi_reference_model_issues_and_c"/>Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e6478"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The idea behind the OSI Reference Model is to provide a framework for both designing networking systems and explaining how they work. As you read about networking, you will frequently find references to the various levels, or layers, of the OSI Reference Model. However, before I can properly discuss the actual OSI model <span class="emphasis"><em>layers</em></span>, you need to understand the model as a whole.</p><p>In this chapter, I introduce the OSI Reference Model and provide some useful background information to help you understand it. I begin with a brief history of the model, including a look at its development and goals. I then introduce networking models in general terms, describing why they are beneficial and how they can best be used. The bulk of the chapter contains important OSI model concepts, which will help you begin to really understand the way model works, the terminology used to describe it, and how it can be of value in explaining the operation of networking technologies.</p><div class="sect1" title="History of the OSI Reference Model"><div class="titlepage"><div><div><h1 class="title"><a id="history_of_the_osi_reference_model"/>History of the OSI Reference Model</h1></div></div></div><p>A look at the origins of the <a class="indexterm" id="idx-CHP-5-0302"/>OSI Reference Model takes us back to several issues related to standards and standards organizations that were discussed in <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>. The idea behind the creation of networking standards is to define widely accepted ways of setting up networks and connecting them together. The <a class="indexterm" id="idx-CHP-5-0303"/>OSI Reference Model represented an early attempt to get all of the various hardware and software manufacturers to agree on a framework for developing various networking technologies.</p><p>In the late 1970s, two projects began independently with the same goal: to define a unifying standard for the architecture of networking systems. One was administered by the <span class="emphasis"><em>International Organization for Standardization (ISO)</em></span>, while the other was undertaken by the <span class="emphasis"><em>International Telegraph and Telephone Consultative Committee</em></span>, or <span class="emphasis"><em>CCITT</em></span> (the abbreviation is from the French version of the name). These two international standards bodies each developed a document that defined similar networking models.</p><p>In 1983, these two documents were merged to form a standard called <span class="emphasis"><em>The Basic Reference Model for Open Systems Interconnection</em></span>. That's a mouthful, so the standard is usually referred to as the <span class="emphasis"><em>Open Systems Interconnection Reference Model</em></span>, the <span class="emphasis"><em>OSI Reference Model</em></span>, or even just the <span class="emphasis"><em>OSI model</em></span>. It was published in 1984 by both the ISO, as standard ISO 7498, and the renamed CCITT (now called the <span class="emphasis"><em>Telecommunications Standardization Sector of the International Telecommunication Union</em></span> or <span class="emphasis"><em>ITU-T</em></span>) as standard X.200. (Incidentally, isn't the new name for the CCITT <span class="emphasis"><em>much</em></span> catchier than the old one? Just rolls off the old tongue, doesn't it?)<a class="indexterm" id="idx-CHP-5-0304"/></p><p>One interesting aspect of the <a class="indexterm" id="idx-CHP-5-0305"/>history of the OSI Reference Model is that the original objective was <span class="emphasis"><em>not</em></span> to create a model primarily for educational purposes, even though many people today think that this was the case. It was intended to serve as the foundation for the establishment of a widely adopted suite of protocols that would be used by international internetworks—basically, what the Internet became. This was called, unsurprisingly, the <a class="indexterm" id="idx-CHP-5-0306"/>OSI protocol suite.</p><p>However, things didn't quite work out as planned. The rise in popularity of the Internet and its TCP/IP protocols met the <a class="indexterm" id="idx-CHP-5-0307"/>OSI protocol suite head on, and in a nutshell, TCP/IP won. Some of the OSI protocols were implemented, but as a whole, the OSI protocols lost out to TCP/IP when the Internet started to grow.</p><p>The OSI model itself, however, found a home as a device for explaining the operation of not just the OSI protocols, but networking in general. It's used widely as an educational tool—much as I use it myself—and it's also used to help describe interactions between the components of other protocol suites and even hardware devices. Although most technologies were not designed specifically to meet the dictates of the OSI model, many are described in terms of how they fit into its layers. This includes networking protocols, software applications, and even different types of hardware devices, such as switches and routers. The model is also useful to those who develop software and hardware products because it clarifies the roles performed by each of the components in a networking system.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-34"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Open Systems Interconnection Reference Model</em></span> (<span class="emphasis"><em>OSI Reference Model</em></span> or <span class="emphasis"><em>OSI model</em></span>) was originally created as the basis for designing a universal set of protocols called the <span class="emphasis"><em>OSI protocol suite</em></span>. This suite never achieved widespread success, but the model became a very useful tool for both education and development. The model defines a set of layers and a number of concepts for their use that make understanding networks easier.</p></div></div></div>
<div class="sect1" title="General Reference Model Issues"><div class="titlepage"><div><div><h1 class="title"><a id="general_reference_model_issues"/>General Reference Model Issues</h1></div></div></div><p>Let's discuss some of the basic issues related to reference <a class="indexterm" id="idx-CHP-5-0308"/>models. In part, I want to explain why I place so much emphasis on the OSI model, even going so far as to build much of this book's organization around this model and its layers. I also want you to understand why the model is important, and how it benefits networking not only on a conceptual level, but in reality.</p><p>In the topics that follow, I describe several issues that relate to reference models in general terms, and of course, to the OSI Reference Model specifically. I begin with an overview of why networking models are beneficial and why it is important for you to understand how the OSI model works. I then talk about how best to use the model and contrast it with some "real-world" network architectures and protocol stacks.</p><div class="sect2" title="The Benefits of Networking Models"><div class="titlepage"><div><div><h2 class="title"><a id="the_benefits_of_networking_models"/>The Benefits of Networking Models</h2></div></div></div><p>Networking is complicated, and special pains must be taken to try to <span class="emphasis"><em>simplify</em></span> it. One of the ways in which networking technology is made easier to understand is by splitting it into pieces, each of which plays a particular role or is responsible for a specific job or function.</p><p>However, if this is to be done, you must have a way of ensuring that these various pieces can interoperate; that is, each must know what is expected of it and also what it can expect from the other pieces. This is one of the important roles of networking models. They split the multitude of tasks required to implement modern networks into smaller chunks that can be more easily managed. Just as importantly, they establish "walls" between those pieces and rules for passing information over those walls.</p><p>A good analogy of a networking model is that of an assembly line at a manufacturer. No company attempts to have one person build an entire car; even if the company did, it wouldn't expect that individual to be able to learn how to do it all at once. The division of labor offers several advantages to a company that builds a complex product, such as an automobile. Generally speaking, these include the following:</p><p><span class="strong"><strong>Training and Documentation</strong></span> It is easier to explain how to build a complex system by breaking the process into smaller parts. Training can be done for a specific job without everyone needing to know how everything else works.</p><p><span class="strong"><strong>Specialization</strong></span> If everyone is responsible for doing every job, no one gets enough experience to become an expert at anything. Through specialization, certain individuals develop expertise at particular jobs.</p><p><span class="strong"><strong>Easier Design Modification and Enhancement</strong></span> By separating the automobile into systems as well as the particular jobs required to build those systems, you can make changes in the future more easily. Without such divisions, it would be much more difficult to determine what the impact might be <a class="indexterm" id="idx-CHP-5-0309"/>of a change, which would serve as a disincentive for innovation.</p><p><span class="strong"><strong>Modularity</strong></span> This is related to each of the previous items. If the automobile's systems and manufacturing steps are broken down according to a sensible architecture or model, it becomes easier to interchange parts and procedures between vehicles. This saves time and money.</p><p>Networking models yield very similar benefits to the networking world. They represent a framework for dividing up the tasks needed to implement a network by splitting the work into different levels, or <span class="emphasis"><em>layers</em></span>. Hardware and software running on each layer are responsible for interacting with corresponding hardware and software that are running on other devices on the same layer. The responsibilities of each hardware or software element are defined in part by specifically dividing lines between the layers.</p><p>As a result, you get all of the benefits listed in the previous points: easier training, specialized capabilities at each layer, improved capabilities for modification, and modularity. Modularity is particularly important, because it allows you to interchange technologies that run at different layers. While no one would try to build a vehicle that is partly a compact sedan, partly an SUV, and partly a motorcycle, there are situations in networking for which you may want to do something surprisingly similar to this. Networking models help make this possible.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-35"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Networking models such as the <span class="emphasis"><em>OSI Reference Model</em></span> provide a framework for breaking down complex internetworks into components that can more easily be understood and utilized. The model defines networking functions not as a large, complicated whole, but as a set of layered, modular components, each of which is responsible for a particular function. The result is better comprehension of network operations, improved performance and functionality, easier design and development, and the ability to combine different components in a way that's best suited to the needs of the network.</p></div></div><div class="sect2" title="Why Understanding the OSI Reference Model Is Important to You"><div class="titlepage"><div><div><h2 class="title"><a id="why_understanding_the_osi_reference_mode"/>Why Understanding the OSI Reference Model Is Important to You</h2></div></div></div><p>A lot of networking books and other resources gloss over the OSI Reference Model or relegate it to the back pages of a hard-to-find appendix. The reason usually stated for this is that the OSI model is "too theoretical" and "doesn't apply to modern networking protocols like TCP/IP."</p><p>This is a misguided notion. While it is certainly true that the OSI model is primarily theoretical, and that networking protocols aren't always designed to fit strictly within the confines of their layers, it's <span class="emphasis"><em>not</em></span> true that the OSI model has little applicability to the real world. In fact, it is difficult to read about networking technology today without seeing references to the OSI model and its layers, because the model's structure helps to frame discussions of protocols and contrast various technologies.</p><p>For example, the OSI Reference Model provides the basis for understanding how technologies like Ethernet and HomePNA are similar; it explains how a PC can communicate using any of several different sets of protocols, even simultaneously; it is an important part of understanding the differences between interconnection devices such as repeaters, hubs, bridges, switches, and routers; and it also explains how many WAN technologies interoperate.</p><p>Far from being obsolete, the OSI model layers are now showing up more than ever in discussions of technology. In fact, some protocols are even <span class="emphasis"><em>named</em></span> specifically in terms of their place in the OSI Reference Model! For an example, consider the Layer Two Tunneling Protocol. Also, switches are now commonly categorized as layer 2, layer 3, or even higher-layer switches.</p><p>In theoretical discussions, the OSI Reference Model helps you to understand how networks and network protocols function in the real world. It also helps you to figure out which protocols and devices can interact with each other. So I encourage you to read on. It's time well spent.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-36"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> While many people scoff at the notion of studying the OSI Reference Model, understanding it is very helpful in making sense of networking protocols and technologies. The model is theoretical, but its concepts are employed regularly to describe the operation of real-world networks.</p></div></div><div class="sect2" title="How to Use the OSI Reference Model"><div class="titlepage"><div><div><h2 class="title"><a id="how_to_use_the_osi_reference_model"/>How to Use the OSI Reference Model</h2></div></div></div><p>Although some people tend to downplay the OSI model too much, others go to the opposite extreme. They use it too much, overanalyzing and trying to use it in a way that was never intended.</p><p>The most common mistake is made when attempting to try to "make everything fit" into the layered structure of the OSI model. I must confess to falling into this trap myself on occasion. When I first started laying out the structure of this book, I wanted to organize <span class="emphasis"><em>everything</em></span> based on where it fell in terms of OSI model layers. I quickly discovered that this was like attempting to put pegs of various shapes into a board containing only round holes. I had to change my approach. I ended up organizing it based on the OSI layers where it made sense and using a different structure where it did not.</p><p>Learn from my experience. A simple rule of thumb is this: Refer to the OSI Reference Model if it helps you make sense of technologies and understand how they work; <span class="emphasis"><em>don't</em></span> use it if it makes things more complicated. In particular, bear the following in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It can be very hard to figure out where some technologies fall within the model. Many protocols were designed without the OSI model in mind, and they may not fall neatly into one layer or another. Some overlap two or more layers; other protocol suites may have two protocols that share a layer.</p></li><li class="listitem"><p>The boundaries between the upper layers (session, presentation, and application) get particularly fuzzy. Some protocols are clearly designed to fit on one of these layers, while others may overlap all three. This is one reason why I do not categorize higher-level protocols by layer. (The OSI Reference Model was designed to account for the fact that differentiating between these layers might not make sense.)</p></li><li class="listitem"><p>The OSI Reference Model was designed primarily with LANs in mind. <a class="indexterm" id="idx-CHP-5-0310"/>WAN technologies often fit very poorly into the model, with a lot of overlapping and partial layer coverage. However, it's still useful in most cases to look at these protocols in terms of their approximate fit in the OSI model, since parts of WAN technologies are sometimes interchanged.</p></li><li class="listitem"><p>The people who design products don't generally worry about ensuring that their latest inventions implement only specific layers of the model. Thus, sometimes new products come out that break the rules and implement functions across more than one layer, which used to be done by multiple devices at the individual layers. This is usually progress—a good thing!</p></li></ul></div><p>Finally, an observation: I have noticed that people learning about networking—especially those trying to memorize easy answers to difficult questions so they can pass exams—often ask, "At what layer does this piece of hardware operate?" The problem here is not the answer but rather the question, which is simplistic. With the exception of simple physical devices such as connectors and cables, pretty much <span class="emphasis"><em>all</em></span> networking devices operate at many layers. While a router, for example, is usually associated with layer 3, it has two or more device interfaces that implement layers 2 and 1. A better question is what is the <span class="emphasis"><em>highest</em></span> layer at which a device functions?</p><p>The bottom line is that the OSI Reference Model is a tool. If you use it wisely, it can be immensely helpful to you. Just remember not to be too inflexible in how you apply it, and you'll be fine.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-37"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> It is just as much a mistake to assign too much importance to the OSI Reference Model as too little. While the model defines a framework for understanding networks, not all networking components, protocols, and technologies will necessarily fall into the model's strict layering architecture. There are cases in which trying to use the model to describe certain concepts can lead to less clarity rather than more. You should remember that the OSI model is a <span class="emphasis"><em>tool</em></span> and should be used accordingly.</p></div></div><div class="sect2" title="Other Network Architectures and Protocol Stacks"><div class="titlepage"><div><div><h2 class="title"><a id="other_network_architectures_and_protocol"/>Other Network Architectures and Protocol Stacks</h2></div></div></div><p>The OSI Reference Model is not the only model used to describe the structure of networks; several other models and systems are used to describe various sets of networking technologies that work together. These don't generally describe theoretical models, but rather groupings of protocols that are actively used in actual networks. They are, therefore, more often called <span class="emphasis"><em>networking architectures</em></span> and <span class="emphasis"><em>protocol suites</em></span> than models.<a class="indexterm" id="idx-CHP-5-0311"/></p><p>As you just saw, many technologies and protocols don't "fit" well into the specific layers used in the OSI model. Similarly, most of the protocol suites used in the real world don't fit the OSI model exactly. This happens, of course, because they were developed independently of the OSI model. Still, most of these architectures and suites still use layers—they are just different from the ones that the OSI model uses.</p><p>Since the OSI model is referenced so often, it can be very helpful in making sense of other architectures and even comparing them. Regardless of what the individual layers and technologies are called, networking protocol suites all try to accomplish the same goals in implementing a network. Thus, even though the layers are not the same, they are often comparable.</p><p>In the case of TCP/IP, a special model called the <a class="indexterm" id="idx-CHP-5-0312"/>DoD (Department of Defense) model or TCP/IP model is usually used in discussions of the suite (see <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>). This model has many similarities to the OSI model, but also some important differences. In other areas in the field of networking, still other models are used, such as the IEEE 802 <a class="indexterm" id="idx-CHP-5-0313"/>networking architecture model. These, too, are similar in some ways to the OSI model, but they have their own unique characteristics.</p><p>Even within the scope of some individual specific technologies, you can see a layered structure of related protocols. There are technologies that are generally considered to implement a single level of the OSI model, even though they actually have portions that overlap several OSI layers; examples include Ethernet and Asynchronous Transfer Mode (ATM). In fact, some protocols even have <span class="emphasis"><em>subprotocols</em></span> that are layered within the confines of what is considered a single layer under OSI. A good example is the TCP/IP Point-to-Point Protocol (PPP), which, despite the name, is not a single protocol but a protocol suite unto itself (see <a class="xref" href="pt04.html" title="Part II-1. TCP/IP NETWORK INTERFACE LAYER PROTOCOLS">Part II-1</a>).<a class="indexterm" id="idx-CHP-5-0314"/></p></div></div>
<div class="sect1" title="Key OSI Reference Model Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="key_osi_reference_model_concepts"/>Key OSI Reference Model Concepts</h1></div></div></div><p>The OSI Reference Model is valuable as a tool for explaining how networks function, and for describing the relationships between different networking technologies and protocols. To accomplish this, the model relies on a number of important concepts and terms, which I'll discuss in the following sections.<a class="indexterm" id="idx-CHP-5-0315"/></p><p>I'll begin with a discussion of how the model uses layers. This is perhaps the single most important of all model concepts. I then talk about some of the notation and jargon you are likely to see in general discussions of the model. I define in more detail what <span class="emphasis"><em>interfaces</em></span> and <span class="emphasis"><em>protocols</em></span> are in the context of the model. I then explain the important concept of data encapsulation and the terminology used to refer to messages in the OSI Reference Model: protocol data units (PDUs) and service data units (SDUs). Finally, I connect most of the preceding issues by describing how the various layers work to handle the routing of messages on a theoretical basis.</p><div class="sect2" title="OSI Reference Model Networking Layers, Sublayers, and Layer Groupings"><div class="titlepage"><div><div><h2 class="title"><a id="osi_reference_model_networking_layers_su"/>OSI Reference Model Networking Layers, Sublayers, and Layer Groupings</h2></div></div></div><p>The most important OSI Reference Model concept is that of networking <span class="emphasis"><em>layers</em></span>. It's not an exaggeration to say that layers are really the heart of the OSI model—the entire point of the model is to separate networking into distinct functions that operate at different levels. Each layer is responsible for performing a specific task or set of tasks and dealing with the layers above and below it.</p><p>The OSI Reference Model is composed of seven conceptual layers, each of which is assigned a number from 1 to 7. The layer number represents the position of the layer in the model as a whole, and indicates how close the layer is to the actual hardware used to implement a network. The first and lowest layer is the <span class="emphasis"><em>physical layer</em></span>, which is where low-level signaling and hardware are implemented. The seventh and highest layer is the <span class="emphasis"><em>application layer</em></span>, which deals with high-level applications employed by users: both end users and the operating system software.</p><p>You can see that as you proceed from the first layer to the seventh, you move up the <span class="emphasis"><em>layer stack</em></span> and, in so doing, increase your level of <span class="emphasis"><em>abstraction</em></span>. This means that the higher a layer is in the <a class="indexterm" id="idx-CHP-5-0316"/>stack, the more it deals with logical concepts and software, and the less it deals with the hardware of a network and the nuts and bolts of making it work. The first layer is the most concrete, because it deals with the actual hardware of networks and the specific methods of sending bits from one device to another. It is the domain of hardware engineers and signaling experts. The second layer is a bit more abstract but still deals with signaling and hardware. As you proceed through the third, fourth, and subsequent <a class="indexterm" id="idx-CHP-5-0317"/>layers, the technologies at those layers become increasingly abstract. By the time you reach the seventh layer, you are no longer dealing with hardware or even operating system concepts very much; you are in the realm of the user and high-level programs that rely on lower levels to do the "heavy lifting" for them.<a class="indexterm" id="idx-CHP-5-0318"/><a class="indexterm" id="idx-CHP-5-0319"/></p><p>The OSI Reference Model does not formally assign any relationship between groups of adjacent layers. However, to help explain how the layers work, it is common to categorize them into two <span class="emphasis"><em>layer groupings</em></span>:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-5-0320"/>Lower Layers (Layers 1, 2, 3, and 4)</strong></span> As shown in <a class="xref" href="ch05s03.html#osi_reference_model_layers_the_osi_refer" title="Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking functions into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes divided into two layer groupings—the lower layers and the upper layers.">Figure 5-1</a>, the lower layers of the model—<span class="emphasis"><em>physical, data link, network,</em></span> and <span class="emphasis"><em>transport</em></span>—are primarily concerned with the formatting, encoding, and transmission of data over the network. They don't care that much about what the data is or what it is being used for; instead, they just want to know about moving it around. They are implemented in both hardware and software, with the transition from hardware to software occurring as you proceed up from layer 1 to layer 4.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-5-0321"/>Upper Layers (Layers 5, 6, and 7)</strong></span> The higher layers of the model—<span class="emphasis"><em>session, presentation</em></span>, and <span class="emphasis"><em>application</em></span>—are concerned primarily with interacting with the user and implementing the applications that run over the network. The protocols that run at higher layers are less concerned with the low-level details of how data gets sent from one place to another; they rely on the lower layers to deliver the data. These layers are almost always implemented as software running on a computer or other hardware device.</p><p>There are some people who would not necessarily agree with how I have chosen to divide the layers in <a class="xref" href="ch05s03.html#osi_reference_model_layers_the_osi_refer" title="Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking functions into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes divided into two layer groupings—the lower layers and the upper layers.">Figure 5-1</a>. In particular, valid arguments can be made for including the transport layer in the upper layer group, since it is usually implemented as software and is fairly abstract. I place it in the lower layer group because its primary job is still providing services to higher layers for moving data. Really, layer 4 is somewhat of a transition zone and is hard to categorize. <a class="xref" href="ch05s03.html#osi_reference_model_layers_the_osi_refer" title="Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking functions into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes divided into two layer groupings—the lower layers and the upper layers.">Figure 5-1</a> indicates the special position of layer 4 in the <a class="indexterm" id="idx-CHP-5-0322"/>stack.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-38"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The most fundamental concept in the OSI Reference Model is the division of networking functions into a set of <span class="emphasis"><em>layers</em></span>, from layer 1 at the bottom to layer 7 at the top. As you go up the layer stack, you move away from concrete, hardware-specific functions to ones that are increasingly abstract, until you reach the realm of user applications at layer 7. The seven layers are sometimes divided into groupings: the lower layers (1 through 3) and the upper layers (4 through 7). There is some disagreement on whether layer 4 is a lower or upper layer.</p></div><div class="figure"><a id="osi_reference_model_layers_the_osi_refer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e6888"/><img alt="OSI Reference Model layers The OSI Reference Model divides networking functions into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes divided into two layer groupings—the lower layers and the upper layers." src="httpatomoreillycomsourcenostarchimages287703.png.jpg"/></div></div><p class="title">Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking functions into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes divided into two layer groupings—the lower layers and the upper layers.</p></div><p>There are also <a class="indexterm" id="idx-CHP-5-0323"/>certain OSI layers that have natural relationships to each other. The physical and data link layers, in particular, are closely related. For example, most people talk about Ethernet as a layer 2 technology, but Ethernet specifications really deal with both layer 2 and layer 1. Similarly, layers 3 and 4 are often related; protocol suites are often designed so that layer 3 and 4 protocols work together. Good examples are TCP and IP in the TCP/IP protocol suite, and IPX and SPX in the Novell suite.</p><p>In some areas, the layers are so closely related that the lines between them become <span class="emphasis"><em>blurry</em></span>. This is particularly the case when looking at the higher layers; many technologies implement two or even all three of these layers, which is another reason why I feel they best belong in a group together. One important reason why the distinctions between layers 5 through 7 are blurry is that the TCP/IP protocols are based on the TCP/IP model (covered in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>), which combines the functions of layers 5 through 7 in a single, thick layer.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-39"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The four lower layers of the OSI model are most often discussed individually, because the boundaries between them are reasonably clear-cut. In contrast, the lines between the session, presentation, and application layers are somewhat blurry. As a result, sometimes protocols span two or even all three of these layers; this is especially true of TCP/IP application protocols, since the TCP/IP model treats layers 5 through 7 as a single layer.</p></div><p>Finally, note that some OSI Reference Model layers are further divided into <span class="emphasis"><em>sublayers</em></span> to help define more precisely the internal details of protocols and technologies at those layers. This is commonly done at the lower layers, especially at the physical layer and the data link layer.<a class="indexterm" id="idx-CHP-5-0324"/></p></div><div class="sect2" title="&quot;N&quot; Notation and Other OSI Model Layer Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="n_notation_and_other_osi_model_layer_ter"/>"N" Notation and Other OSI Model Layer Terminology</h2></div></div></div><p>As a theoretical model, the OSI Reference Model comes complete with a set of <a class="indexterm" id="idx-CHP-5-0325"/>terminology that is used to describe it and its constituent parts. This is sort of both good news and bad news. The good news is that if you understand this terminology, it can help you comprehend how technologies relate to the model as well as most OSI model discussions in general. The bad news is that the terminology can also increase confusion—especially since it isn't always used consistently.<a class="indexterm" id="idx-CHP-5-0326"/></p><p>Here are a few terminology concepts you will often see used to refer to the OSI Reference Model:</p><p><span class="strong"><strong>Layer Names and Numbers</strong></span> The various layers of the OSI Reference Model are referred to in a variety of ways. They may have their names spelled out in full, or they may be abbreviated. They are also often simply referenced by their layer number. So, for example, all of these refer to the same thing: data link layer, Data Link Layer, DLL, L2, layer two, and layer 2. Similarly, you will often see layer names being used as adjectives to describe protocols and technologies. For example, a layer 3 technology is one that operates primarily at the network layer.</p><p><span class="strong"><strong>N Notation</strong></span> The letter <span class="emphasis"><em>N</em></span> is often used to generically refer to a number within the computer world. With respect to the OSI model, it's common to see this letter used in discussions that relate generically to individual layers without mentioning a specific layer. You will hear terms like <span class="emphasis"><em>N-functions</em></span> and <span class="emphasis"><em>N-services</em></span>, which just refer to the functions and services provided within a particular layer. As another example, you might hear someone say that a particular technology "provides a useful service to the N+1 layer." This just means it provides a function to the layer above the one at which it operates. Conceptually, every layer but the first and seventh have an N-1 layer, an N+1 layer, and so on. If you are looking at the network layer (layer 3), then the N+2 layer is the session layer (layer 5).</p><p><span class="strong"><strong>Protocols and Interfaces</strong></span> These words have special meaning within the context of the OSI model. A <span class="emphasis"><em>protocol</em></span> represents communication between logical or physical devices at the same layer of the model. An <span class="emphasis"><em>interface</em></span> represents information moving between adjacent layers within the same device. Thus, in N notation, protocols represent communication between layer N on one device and layer N on another device, while interfaces deal with communication between layer N and N+1 or layer N and N-1 on the same device.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-5-0327"/>Network Stacks</strong></span> What do you get when you take a bunch of layers and pile them up on top of each other? You get a <span class="emphasis"><em>stack</em></span>. This term is used to refer to the entire set of layers in a model or suite of technologies, or a partial set. Since each layer has protocols associated with it, this is also sometimes called the <span class="emphasis"><em>protocol stack</em></span>.<a class="indexterm" id="idx-CHP-5-0328"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-5-0329"/>Entities, Functions, Facilities, and Services</strong></span> These often interchanged, somewhat vague terms refer to specific tasks or jobs performed at various layers in the model. An <span class="emphasis"><em>N-entity</em></span> is a term that refers to a specific operation or job done at layer N. A <span class="emphasis"><em>function</em></span> is basically the same thing. <span class="emphasis"><em>Facilities</em></span> and <span class="emphasis"><em>services</em></span> are what a layer provides to the layers above it. This is often expressed in N-notation as well: the N+1 layer often uses a set of N services or N facilities provided by the N layer.</p><p><a class="xref" href="ch05s03.html#osi_reference_model_layer_relationships_" title="Figure 5-2. OSI Reference Model layer relationships and terminology Each layer has a relationship with the layer above and below it; here, if the network layer is layer N, it provides services to the transport layer (layer N+1) and uses services of the data link layer (layer N-1).">Figure 5-2</a> serves as a summary of the previous information by showing the relationships between OSI model layers and the terminology used to refer to adjacent layers in the context of any particular layer. Each layer (except layer 7) provides services to the layer above it; each layer (other than layer 1) uses services provided by the layer below it. Another way of saying this is that each layer N provides services to layer N+1 and uses the services of layer N-1. Taking the example of layer 3, the network layer, you see that it provides services to layer 4 and uses services of layer 2. From the standpoint of the network layer, the transport layer is layer N+1 and the data link layer is N-1.</p><div class="figure"><a id="osi_reference_model_layer_relationships_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7012"/><img alt="OSI Reference Model layer relationships and terminology Each layer has a relationship with the layer above and below it; here, if the network layer is layer N, it provides services to the transport layer (layer N+1) and uses services of the data link layer (layer N-1)." src="httpatomoreillycomsourcenostarchimages287705.png.jpg"/></div></div><p class="title">Figure 5-2. OSI Reference Model layer relationships and terminology Each layer has a relationship with the layer above and below it; here, if the network layer is layer N, it provides services to the transport layer (layer N+1) and uses services of the data link layer (layer N-1).</p></div><p>You may have just read all of that and said to yourself, "Why do they bother making this so <span class="emphasis"><em>complicated</em></span> anyway?" Good question. Remember, I <span class="emphasis"><em>did</em></span> say there was bad news here! Now that you know what all of this stuff is about, if you run into it, you won't be <span class="emphasis"><em>too</em></span> confused.</p><p>Fortunately, the use of the previous buzzwords is somewhat limited. Most references are to specific layer names or numbers, and in particular, the N-1 and N+1 stuff is rarely used in discussions of real-world technologies. However, it can be very useful in explaining the model itself, as you will see in some of these terms when you read the rest of this chapter.</p></div><div class="sect2" title="Interfaces: Vertical (Adjacent Layer) Communication"><div class="titlepage"><div><div><h2 class="title"><a id="interfaces_vertical_adjacent_layer_commu"/>Interfaces: Vertical (Adjacent Layer) Communication</h2></div></div></div><p>The seven layers of the OSI Reference Model are used to divide the various functions that are required to implement a networking system. On any given device in a network, different software and hardware routines and devices may be functioning on any or all of these layers simultaneously. Because, in general, all of these are supposed to be working together to implement networking functions, there is a need for layers to communicate <span class="emphasis"><em>vertically</em></span> between the layers within a particular host.<a class="indexterm" id="idx-CHP-5-0330"/><a class="indexterm" id="idx-CHP-5-0331"/><a class="indexterm" id="idx-CHP-5-0332"/></p><p>In OSI Reference Model parlance, the mechanism for communication between adjacent layers in the model is called an <span class="emphasis"><em>interface</em></span>. Of course, the term <span class="emphasis"><em>interface</em></span> is also used widely in other contexts in the computer and networking worlds, since its generic meaning refers to connecting just about <span class="emphasis"><em>anything</em></span> together. However, when someone talks about an interface between OSI model layers, that person typically refers to the process by which data is passed between layer N of the model and layer N-1 or layer N+1. These <a class="indexterm" id="idx-CHP-5-0333"/>relationships are demonstrated in <a class="xref" href="ch05s03.html#osi_reference_model_interfaces_for_verti" title="Figure 5-3. OSI Reference Model interfaces for vertical communication In OSI model terminology, an interface is a conduit for communication between adjacent layers in the layer stack.">Figure 5-3</a>. For example, the <span class="emphasis"><em>layer 2/3 interface</em></span> is used by a layer 2 and layer 3 protocol to pass data and control information; the <span class="emphasis"><em>layer 3/4 interface</em></span> connects layers 3 and 4 together.</p><div class="figure"><a id="osi_reference_model_interfaces_for_verti"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7081"/><img alt="OSI Reference Model interfaces for vertical communication In OSI model terminology, an interface is a conduit for communication between adjacent layers in the layer stack." src="httpatomoreillycomsourcenostarchimages287707.png.jpg"/></div></div><p class="title">Figure 5-3. OSI Reference Model interfaces for vertical communication In OSI model terminology, an interface is a conduit for communication between adjacent layers in the layer stack.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-25"/>Note</h3><p><span class="emphasis"><em>Remember that not all layers may be implemented in every system or protocol stack in the real world. So it's possible that a process that is technically running at layer 7 might communicate with one running at layer 5. However, I am talking about the theoretical model here</em></span>.<a class="indexterm" id="idx-CHP-5-0334"/></p></div><p>Vertical communication is done up and down the protocol stack every time anything is sent across the network, and of course, whenever anything is received. This occurs because the higher levels are implemented as logical functions in software; there is no actual physical connection. The higher layers package data and send it down to the lower layers for it to be sent across the network. At the very lowest level, the data is sent over the network. On the receiving end, the process is reversed, with the data traveling back up to the higher layers on the receiving device. I'll discuss this logical interaction between corresponding layers momentarily.</p><p>One of the primary goals of the OSI Reference Model is to allow the interconnection of different implementations of various layers. Thus, the intention is to have somewhat autonomous individual layers that you can mix and match—to a point. The only way to make this work is to have well-defined ways that the layers connect together, and that brings me back to the matter of <a class="indexterm" id="idx-CHP-5-0335"/>interfaces. Each layer must present a consistent, well-documented interface to the layers above it so that any upper layer implementation can use the lower layer properly.</p><p>I'll provide an example from the world of TCP/IP to illustrate what I mean. The heart of the TCP/IP protocol suite is the Internet Protocol (IP). Whenever you use any application on the Internet—email, websites, FTP, chat rooms, and so on—you are indirectly using IP.</p><p>However, you never use IP directly—you generally use one of two transport layer (layer 4) protocols: the Transmission Control Protocol (TCP) or the User Datagram Protocol (UDP) (see <a class="xref" href="pt11.html" title="Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS">Part II-8</a>). A standard interface exists between the network layer and the transport layer in the TCP/IP protocol stack, which defines how IP is to be used by upper layer <a class="indexterm" id="idx-CHP-5-0336"/>protocols; this enables TCP and UDP to interface to it. Similarly, both TCP and UDP present a particular interface to the hundreds of higher-layer protocols and applications that use them at higher layers.</p><p>Many different types of <a class="indexterm" id="idx-CHP-5-0337"/>communication actually take place between layers. Control information is passed to enable the higher layers to utilize the lower ones, and for the lower ones to pass status and results information back to the higher ones. Data is also passed in both directions across the interface. For transmission, it flows down to the lower layer, which normally results in data encapsulation. Upon reception, the process is reversed, with data being sent back up across the interface from a lower to higher layer.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-40"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the <a class="indexterm" id="idx-CHP-5-0338"/>OSI Reference Model, an <span class="emphasis"><em>interface</em></span> defines the mechanism for vertical communication between adjacent layers. The existence of well-defined interfaces between layers is what permits a higher layer to use the services of any of a number of lower layers, without requiring knowledge of how those layers are implemented.</p></div></div><div class="sect2" title="Protocols: Horizontal (Corresponding Layer) Communication"><div class="titlepage"><div><div><h2 class="title"><a id="protocols_horizontal_corresponding_layer"/>Protocols: Horizontal (Corresponding Layer) Communication</h2></div></div></div><p>Each layer in the OSI Reference Model has a particular role (or roles)—a set of general tasks for which it is responsible. On each system on the network, hardware and software are running at many of the different levels in the model. The routines doing a particular job on Machine A are designed to communicate with similar or complementary ones that are running on Machine B. This <span class="emphasis"><em>horizontal communication</em></span> is the very heart of what networking is about. It is what enables web browsers and web servers to talk, email applications to exchange messages, and so much more.<a class="indexterm" id="idx-CHP-5-0339"/></p><p>Of course, all communication types function only if everyone agrees to the same methods of accomplishing it. Each set of rules describing one type of communication is called a <span class="emphasis"><em>protocol</em></span>. You can think of a protocol as a language or a set of instructions. Each function or service of a network has its own language; like human languages, some are similar to each other while others are quite unique.</p><p>If you've done any reading at all about networks, you have probably seen the term <span class="emphasis"><em>protocol</em></span> many, many times. Like the word <span class="emphasis"><em>interface</em></span>, the word <span class="emphasis"><em>protocol</em></span> can have many meanings. In fact, it is so fundamental to networking, and used in so many different ways, that I have a discussion devoted to it in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a>.</p><p>All that aside, you must remember that the OSI Reference Model is intended to be a formal way of describing networks. As such, the term <span class="emphasis"><em>protocol</em></span> has a formal meaning in the context of the model. It refers specifically to a set of communication rules, instructions, and procedures that describe communication between specific software or hardware elements running <span class="emphasis"><em>at the same layer</em></span> on different machines within a network.</p><p>Let's consider how these corresponding layers communicate using protocols. First, you'll recall that every layer in the model, except the bottom (physical) layer, is really a program or algorithm running on a computer. There is no way for, say, a web browser and a web server to actually connect together directly—they are just software programs, after all. Instead, the software running at various layers communicates <span class="emphasis"><em>logically</em></span>. That is to say, through the use of software and procedures, a process running at layer 5 on one machine can accomplish <span class="emphasis"><em>logical communication</em></span> with a similar process running at layer 5 on another machine.</p><p>Since machines are only physically connected at layer 1, the data on the sending machine must pass down the data through the layers between layer 5 and layer 1 in order for a protocol at layer 5 to function. The data is then transmitted over the physical connection to layer 1 of the other machine and passed up on the protocol stack of the receiving machine to layer 5. This is how the two machines are logically linked at layer 5, even though they have no physical connection at that layer.</p><p>Thus, with the exception of the actual physical connection at layer 1, all horizontal communication also requires vertical communication—down the stack on one machine, and then back up the stack on the other. (The communication doesn't always go all the way back up the stack for each connection, however, as in the case of routing, as discussed in the "Indirect Device Connection and Message Routing" section at the end of this chapter.)</p><p><a class="xref" href="ch05s03.html#osi_reference_model_protocols_horizontal" title="Figure 5-4. OSI Reference Model protocols: horizontal communication The term protocol has many meanings; in the context of the OSI Reference Model, it refers specifically to software or hardware elements that accomplish communication between corresponding layers on two or more devices.">Figure 5-4</a> illustrates how horizontal communication works. As an example, IP is said to be a layer 3 protocol because each device uses IP software to communicate at layer 3. The actual transmission and reception of data occurs only at the lowest, physical layer; higher-layer <a class="indexterm" id="idx-CHP-5-0340"/>protocols communicate <span class="emphasis"><em>logically</em></span> by passing data down interfaces until it reaches layer 1, transmitting at layer 1, and then passing the data back up to the appropriate layer at the recipient.</p><div class="figure"><a id="osi_reference_model_protocols_horizontal"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7200"/><img alt="OSI Reference Model protocols: horizontal communication The term protocol has many meanings; in the context of the OSI Reference Model, it refers specifically to software or hardware elements that accomplish communication between corresponding layers on two or more devices." src="httpatomoreillycomsourcenostarchimages287709.png.jpg"/></div></div><p class="title">Figure 5-4. OSI Reference Model protocols: horizontal communication The term protocol has many meanings; in the context of the OSI Reference Model, it refers specifically to software or hardware elements that accomplish communication between corresponding layers on two or more devices.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-41"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the OSI Reference Model, a <span class="emphasis"><em>protocol</em></span> refers specifically to a set of rules or procedures that define communication between software or hardware elements running at the same layer on network devices. Physical layer protocols are responsible for the actual transmission and reception of data at layer 1. Protocols at higher layers pass data down through the layers below them to layer 1 for transmission, then across the network and back up to the corresponding entity at the same layer on the receiving device. The result is that software processes running at say, layer 4 on each of two devices can communicate <span class="emphasis"><em>logically</em></span> as if they were directly connected at layer 4, even though they are not.</p></div></div><div class="sect2" title="Data Encapsulation, Protocol Data Units (PDUs), and Service Data Units (SDUs)"><div class="titlepage"><div><div><h2 class="title"><a id="data_encapsulation_protocol_data_units_p"/>Data Encapsulation, Protocol Data Units (PDUs), and Service Data Units (SDUs)</h2></div></div></div><p>Protocols are what describe the rules that control horizontal communication, that is, conversations between processes that run at corresponding layers within the OSI Reference Model. At every layer (except layer 1), these communications ultimately take the form of some sort of message that is sent between corresponding software elements on two or more devices. Since these messages are the mechanism for communicating information between protocols, they are most generally called <span class="emphasis"><em>protocol data units (PDUs)</em></span>. Each PDU has a specific format that implements the features and requirements of the protocol.<a class="indexterm" id="idx-CHP-5-0341"/><a class="indexterm" id="idx-CHP-5-0342"/></p><p>As discussed in the previous section, the communication between layers higher than layer 1 is <span class="emphasis"><em>logical</em></span>; the only hardware connection is at the physical layer. Thus, in order for a protocol to communicate, it must pass down its PDU to the next lower layer for transmission. You've also already seen that, using OSI terminology, lower layers are said to provide <span class="emphasis"><em>services</em></span> to the layers immediately above them. One of the services each layer provides is this function: to handle and manage data received from the layer above.</p><p>At any particular layer N, a PDU is a complete message that implements the protocol at that layer. However, when this layer N PDU is passed down to layer N-1, it becomes the <span class="emphasis"><em>data</em></span> that the layer N-1 protocol is supposed to <span class="emphasis"><em>service</em></span>. Thus, the layer N protocol data unit (PDU) is called the layer N-1 <span class="emphasis"><em>service data unit (SDU)</em></span>. The job of layer N-1 is to transport this SDU, which it does by placing the layer N SDU into its own PDU format, preceding the SDU with its own headers and appending footers as necessary. This process is called <span class="emphasis"><em>data encapsulation</em></span>, because the entire contents of the higher-layer message are encapsulated as the data payload of the message at the lower layer.<a class="indexterm" id="idx-CHP-5-0343"/></p><p>What does layer N-1 do with its PDU? It passes it down to the next lower layer, where it is treated as a layer N-2 SDU. Layer N-2 creates a layer N-2 PDU containing the layer N-1 SDU and layer N-2's headers and footers. And so the process continues, all the way down to the physical layer. In the theoretical model, what you end up with is a message at layer 1 that consists of application-layer data that is encapsulated with headers and footers from layers 7 through 2.</p><p><a class="xref" href="ch05s03.html#osi_reference_model_data_encapsulation_e" title="Figure 5-5. OSI Reference Model data encapsulation Each protocol creates a protocol data unit (PDU) for transmission, each of which includes headers required by that protocol and data to be transmitted. This data becomes the service data unit (SDU) of the next layer below it.">Figure 5-5</a> shows a layer 7 PDU consisting of a layer 7 header (labeled L7H) and application data. When this is passed to layer 6, it becomes a layer 6 SDU. The layer 6 protocol prepends to it a layer 6 header (labeled L6H) to create a layer 6 PDU, which is passed to layer 5. The encapsulation process continues all the way down to layer 2, which creates a layer 2 PDU—in this case, shown with both a header and a footer—that is converted to bits and sent at layer 1.</p><div class="figure"><a id="osi_reference_model_data_encapsulation_e"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7267"/><img alt="OSI Reference Model data encapsulation Each protocol creates a protocol data unit (PDU) for transmission, each of which includes headers required by that protocol and data to be transmitted. This data becomes the service data unit (SDU) of the next layer below it." src="httpatomoreillycomsourcenostarchimages287711.png.jpg"/></div></div><p class="title">Figure 5-5. OSI Reference Model data encapsulation Each protocol creates a protocol data unit (PDU) for transmission, each of which includes headers required by that protocol and data to be transmitted. This data becomes the service data unit (SDU) of the next layer below it.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-42"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The message used to communicate information for a particular protocol is called its <span class="emphasis"><em>protocol data unit (PDU)</em></span> in OSI model terminology. That PDU is passed down to the next lower layer for transmission; since that layer is providing the service of handling that PDU, it is called the lower layer's <span class="emphasis"><em>service data unit (SDU)</em></span>. The SDU is encapsulated into that layer's own PDU and, in turn, sent to the next lower layer in the stack, proceeding until the physical layer is reached. The process is reversed on the recipient device. In summary, a layer N PDU is a layer N-1 SDU, which is <span class="emphasis"><em>encapsulated</em></span> into a layer N-1 PDU.<a class="indexterm" id="idx-CHP-5-0344"/></p></div><p>The "N-1, N-2" stuff makes this seem more difficult than it really is, so let's use a real-world (simplified) example instead. TCP operates at layer 4 of the OSI model. It transmits messages called <span class="emphasis"><em>segments</em></span> that contain data encapsulated from higher-layer protocols. The layer below TCP is IP at layer 3. It receives data from TCP and encapsulates it for transmission.</p><p>So, in the formal language of the OSI Reference Model, TCP segments are created as layer 4 PDUs. When passed to IP, they are treated as layer 3 SDUs. The IP software packages these SDUs into messages called <span class="emphasis"><em>IP packets</em></span> or <span class="emphasis"><em>IP datagrams</em></span>, which are layer 3 PDUs. These are passed down to a layer 2 protocol, say Ethernet, which treats IP datagrams as layer 2 SDUs, and packages them into layer 2 PDUs (Ethernet frames), which are sent on to layer 1. (Actually, in some technologies, further encapsulation even occurs at layer 1 prior to transmission.)</p><p>On the receiving device, the process of <a class="indexterm" id="idx-CHP-5-0345"/>encapsulation is reversed. The Ethernet software inspects the layer 2 PDU (Ethernet frame) and removes from it the layer 2 SDU (IP datagram), which it passes up to IP as a layer 3 PDU. The IP layer removes the layer 3 SDU (TCP segment) and passes it to TCP as a layer 4 PDU. TCP continues the process, going back up the protocol layer stack.</p><p><a class="xref" href="ch05s03.html#osi_reference_model_pdu_and_sdu_encapsul" title="Figure 5-6. OSI Reference Model PDU and SDU encapsulation Each PDU at one layer of the OSI model becomes an SDU at the next lower layer and is encapsulated into that layer's PDU.">Figure 5-6</a> shows in more detail how OSI PDUs and SDUs are created and encapsulated. A TCP segment (layer 4 PDU) becomes a layer 3 SDU, which is encapsulated into a layer 3 PDU through the addition of an IP header. This becomes the payload of an Ethernet frame, which is a layer 2 PDU containing an Ethernet header, a layer 2 SDU (the IP datagram), and an Ethernet footer. The receiving device extracts the IP datagram from the Ethernet header and passes it to layer 3; the IP software extracts the TCP segment and passes it up to the TCP software.</p><p>This whole matter of encapsulation, passing data up and down the protocol stack, and so on may seem needlessly complex. It also may appear to be rather inefficient; why send a message with so many headers and footers? However, the notion of data encapsulation is critical to creating modular, flexible networks.</p><div class="figure"><a id="osi_reference_model_pdu_and_sdu_encapsul"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7319"/><img alt="OSI Reference Model PDU and SDU encapsulation Each PDU at one layer of the OSI model becomes an SDU at the next lower layer and is encapsulated into that layer's PDU." src="httpatomoreillycomsourcenostarchimages287713.png.jpg"/></div></div><p class="title">Figure 5-6. OSI Reference Model PDU and SDU encapsulation Each PDU at one layer of the OSI model becomes an SDU at the next lower layer and is encapsulated into that layer's PDU.</p></div><p>The term <span class="emphasis"><em>protocol data unit</em></span> or PDU is rather formal. You will see it used in standards and sometimes in discussions, but more often than not, you'll encounter the message terms, such as <span class="emphasis"><em>frame</em></span> and <span class="emphasis"><em>datagram</em></span>, as discussed in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a>. Similarly, data encapsulated by these messages is not normally called a <span class="emphasis"><em>service data unit</em></span> or SDU, but rather simply the <span class="emphasis"><em>message body</em></span> or <span class="emphasis"><em>payload</em></span>, as you saw when you looked at message formatting in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a>. There are cases, however, for which knowing the difference between an SDU and a PDU is important to understanding the technology. One example is the IEEE 802.11 physical layer—the 802.11 standards talk about SDUs and PDUs constantly!<a class="indexterm" id="idx-CHP-5-0346"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-43"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> See the <a class="indexterm" id="idx-CHP-5-0347"/>OSI Reference Model analogy in the "The Benefits of Networking Models" section earlier in this chapter for an example that compares networking encapsulation to something done in a real-world, nonnetworking context.</p></div></div><div class="sect2" title="Indirect Device Connection and Message Routing"><div class="titlepage"><div><div><h2 class="title"><a id="indirect_device_connection_and_message_r"/>Indirect Device Connection and Message Routing</h2></div></div></div><p>Most of the explanations that I have provided in the other sections of this chapter have discussed the mechanisms by which machines connect to each other over a network <span class="emphasis"><em>directly</em></span>. However, one of the most powerful aspects of networking is that it is possible to create internetworks—networks of networks—that allow devices to be connected <span class="emphasis"><em>indirectly</em></span>. For example, Machine A may send a message to Machine B without really even knowing where it is on the network.<a class="indexterm" id="idx-CHP-5-0348"/></p><p>If a message is being sent between devices that are not on the same network, then it must be passed between directly connected networks until it reaches its final destination. The process of transmitting a message from one network to another is called <span class="emphasis"><em>forwarding</em></span>, and the collective process of forwarding from one device to another is <span class="emphasis"><em>routing</em></span>. These concepts are fundamental to all internetworking, including the Internet itself. Every time you access an Internet resource such as a website, you are sending messages that get routed to that site, and the responses you receive get routed back.<a class="indexterm" id="idx-CHP-5-0349"/><a class="indexterm" id="idx-CHP-5-0350"/></p><div class="note" title="Note"><h3 class="title"><a id="note-26"/>Note</h3><p><span class="emphasis"><em>Even though the technically correct term for moving a message from one network to an adjacent network is</em></span> forwarding, <span class="emphasis"><em>over time, the term</em></span> routing <span class="emphasis"><em>has come to be used both for a single network-to-network transfer, as well as the overall process of transmitting a message from one device to another</em></span>.</p></div><p>In the context of the OSI Reference Model, routing is an activity that generally takes place at the network layer, layer 3. You'll recall that data encapsulation causes a higher-layer message to be surrounded by headers and footers at the lower layers. When a message is routed, here's what happens:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A high-level application on a machine decides to send a datagram to a distant computer. The datagram is packaged, and then passed down vertically through the protocol stack on the originating machine. Each layer encapsulates the data, as described in the previous section. The datagram is addressed to the final destination device. When the message gets to the lower layers, however, it is not packaged for local delivery directly to its ultimate destination, but rather passed to an <span class="emphasis"><em>intermediate device</em></span>. This is the device that is responsible for routing to that destination network. The message is passed down to the data link and physical layers for transmission to that intermediate device.</p></li><li class="listitem"><p>The intermediate device (often called a <span class="emphasis"><em>router</em></span>) receives the message at the physical layer. It is passed up to the data link layer, where it is processed, checked for errors and so on, and the data link layer headers are removed. The resulting packet is passed up to the network layer. There, the intermediate device determines if the destination machine is on its local network, or if it needs to be forwarded to another intermediate device. It then repackages the message and passes it back <span class="emphasis"><em>down</em></span> to the data link layer to be sent on the next leg of its journey.</p></li><li class="listitem"><p>After several potential intermediate devices handle the message, it eventually reaches its destination. Here, it travels back up the protocol stack until it reaches the same layer as the one from the application that generated the message on the originating machine.</p></li></ul></div><p>The key to this description is that in the intermediate devices, the message travels back up the OSI layers <span class="emphasis"><em>only to the network layer</em></span>. It is then repackaged and sent back along its way. The higher layers are involved only on the source and destination devices. The protocol used at layer 3 must be common across the internetwork, but each individual network can be different. This demonstrates some of the power of layering by enabling even rather dissimilar physical networks to be connected together.<a class="indexterm" id="idx-CHP-5-0351"/></p><p><a class="xref" href="ch05s03.html#message_routing_in_the_osi_reference_mod" title="Figure 5-7. Message routing in the OSI Reference Model Routing in the OSI model is accomplished using an intermediate device that connects networks at layer 3. Data passes up to layer 3 in that device on one network and then passes back down to layer 1 on another.">Figure 5-7</a> shows how <a class="indexterm" id="idx-CHP-5-0352"/>routing is accomplished conceptually in the OSI model. The intermediate device connects the networks of the message transmitter and recipient. When data is sent, it is passed up to the network layer on the intermediate device, where it is repackaged and sent back down the stack for the next leg of its transmission. Note that the intermediate device actually has two different layer 1 and 2 implementations—one for the interface to each network. Also note that while the layer 3 protocol must be the same across the internetwork, each network can use different technologies at layers 1 and 2.</p><div class="figure"><a id="message_routing_in_the_osi_reference_mod"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e7447"/><img alt="Message routing in the OSI Reference Model Routing in the OSI model is accomplished using an intermediate device that connects networks at layer 3. Data passes up to layer 3 in that device on one network and then passes back down to layer 1 on another." src="httpatomoreillycomsourcenostarchimages287715.png.jpg"/></div></div><p class="title">Figure 5-7. Message routing in the OSI Reference Model Routing in the OSI model is accomplished using an intermediate device that connects networks at layer 3. Data passes up to layer 3 in that device on one network and then passes back down to layer 1 on another.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-44"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the OSI model, the process of <span class="emphasis"><em>routing</em></span> occurs when data is sent not directly from transmitter to ultimate recipient, but indirectly through the use of an intermediate system. That device, normally called a <span class="emphasis"><em>router</em></span>, connects to two or more physical networks, and thus has multiple interfaces to layer 2. When it receives data, the data passes up only to the network layer, where it is repackaged and then sent on the next leg of its journey over the appropriate layer 2 interface.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;OSI REFERENCE MODEL LAYERS"><div class="titlepage"><div><div><h1 class="title"><a id="osi_reference_model_layers"/>Chapter 6. OSI REFERENCE MODEL LAYERS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e7468"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> In this chapter, we look at the individual <a class="indexterm" id="idx-CHP-6-0353"/>layers of the OSI Reference Model. Each layer in the OSI model has certain characteristics that define it, and also various protocols normally associated with it. I'll describe how each layer functions in the OSI layer stack, outline the specific types of activities for which each is normally responsible, and provide some examples of the technologies and protocols that reside at each layer. Understanding the nuances of each layer will help you understand all the technologies that use them.</p><p>Keep in mind, however, that the descriptions in this section are <span class="emphasis"><em>generic</em></span>. To really comprehend the details of the various layers and how they are used, read the details of the individual protocols that function at each layer later in this book.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-45"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em><a class="xref" href="ch07.html" title="Chapter 7. OSI REFERENCE MODEL SUMMARY">Chapter 7</a> contains summary information that may be helpful to you in understanding the OSI model layers. This includes some common mnemonics for remembering the order of the layers and a summary chart for quickly comparing the layers' key characteristics</em></span>.</p></div><div class="sect1" title="Physical Layer (Layer 1)"><div class="titlepage"><div><div><h1 class="title"><a id="physical_layer_layer_1"/>Physical Layer (Layer 1)</h1></div></div></div><p>The lowest layer of the OSI Reference Model is <a class="indexterm" id="idx-CHP-6-0354"/>layer 1, the <span class="emphasis"><em>physical layer</em></span>; it is commonly abbreviated PHY. This layer is the only one where data is physically moved across the network interface. All other layers perform functions to create messages that implement various protocols, but these messages must all be transmitted down the protocol stack to the <a class="indexterm" id="idx-CHP-6-0355"/>physical layer, and they are eventually sent out over the network.<a class="indexterm" id="idx-CHP-6-0356"/></p><p>First, a bit of clarification. The name <span class="emphasis"><em>physical layer</em></span> can be a bit problematic because it suggests that this layer relates only to the actual network hardware, which is not the case. While some people say that the physical layer is the network interface cards and cables, this is not actually true. The physical layer defines a number of network functions in addition to interfaces with hardware cables and cards.</p><p>People also suggest that all network hardware belongs to the physical layer. Again, this isn't strictly accurate. All hardware must have <span class="emphasis"><em>some</em></span> relation to the physical layer in order to send data over the network, but hardware devices generally implement multiple layers of the OSI model in addition to the physical layer. For example, an Ethernet network interface card performs functions at both the physical layer and the data link layer.</p><p>The physical layer technologies deal with the actual ones and zeros that are sent over the network. For example, repeaters, conventional hubs, and transceivers all operate at the physical layer. These devices have no knowledge of the contents of a message; they simply take input bits and send them as output. The physical layer is responsible for the following:</p><p><span class="strong"><strong>Hardware Specifications Definition</strong></span> The details of operation of cables, connectors, wireless radio transceivers, network interface cards, and other hardware devices are generally a function of the physical layer (although also partially the data link layer, layer 2).</p><p><span class="strong"><strong>Encoding and Signaling</strong></span> The physical layer is responsible for various encoding and signaling functions that transform the data from bits that reside within a computer or another device into signals that can be sent over the network.</p><p><span class="strong"><strong>Data Transmission and Reception</strong></span> After encoding the data appropriately, the physical layer actually transmits the data, and of course, receives it. (This applies equally to wired and wireless networks, even if there is no tangible cable in a wireless network.)</p><p><span class="strong"><strong>Topology and Physical Network Design</strong></span> The physical layer is also considered the domain of many hardware-related network design issues, such as local area network (LAN) and wide area network (WAN) topology.</p><p>While the physical layer of a network primarily defines the hardware it uses, it is also closely related to the data link layer. Thus, it is not generally possible to define hardware at the physical layer independently from the technology being used at the data link layer. For example, Ethernet is a technology that describes specific types of cables and network hardware, but the physical layer of Ethernet can be isolated from its data link layer aspects only to a point. Though Ethernet cables are the <a class="indexterm" id="idx-CHP-6-0357"/>physical layer, the cables' maximum length is related closely to message format rules that exist at the data link layer.</p><p>Furthermore, some technologies perform functions at the physical layer that are normally more closely associated with the data link layer. For example, it is common to have the physical layer perform low-level (bit-level) repackaging of data link layer frames for transmission. Error detection and correction may also be done at layer 1 in some cases, though most people would consider these <a class="indexterm" id="idx-CHP-6-0358"/>layer 2 functions.</p><p>In many technologies, a number of physical layers can be used with a data link layer. The classic example is Ethernet, for which dozens of different physical layer implementations exist. Each implementation uses the same data link layer (possibly with slight variations).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-46"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The lowest layer in the OSI Reference Model is the <span class="emphasis"><em>physical layer</em></span>. It is the realm of networking hardware specifications, and is the place where technologies that perform data encoding, signaling, transmission, and reception functions reside. The physical layer is closely related to the data link layer.</p></div><p>Many technologies further subdivide the physical layer into <span class="emphasis"><em>sublayers</em></span> in order to allow different network media to be supported by the same technology, while sharing other functions at the physical layer that are common between the various media. A good example of this is the physical layer architecture used for Fast Ethernet, Gigabit Ethernet, and 10-Gigabit Ethernet.<a class="indexterm" id="idx-CHP-6-0359"/></p><div class="note" title="Note"><h3 class="title"><a id="note-27"/>Note</h3><p><span class="emphasis"><em>In some contexts, the physical layer technology that's used to convey bits across a network or communications line is called a</em></span> transport method <span class="emphasis"><em>(not to be confused with the OSI transport layer, layer 4)</em></span>.</p></div></div></div>
<div class="sect1" title="Data Link Layer (Layer 2)"><div class="titlepage"><div><div><h1 class="title"><a id="data_link_layer_layer_2"/>Data Link Layer (Layer 2)</h1></div></div></div><p>The second-lowest layer (layer 2) in the OSI Reference Model stack is the <span class="emphasis"><em>data link layer</em></span>, often called simply the <span class="emphasis"><em>link layer</em></span>, or abbreviated DLL. The data link layer is where many wired and wireless LAN technologies primarily function. For example, Ethernet, Token Ring, FDDI, and 802.11 (wireless Ethernet or Wi-Fi) are all sometimes called data link layer technologies. The set of devices connected at the data link layer is commonly considered a simple network (as opposed to an internetwork, which is a collection of networks connected at layer 3).<a class="indexterm" id="idx-CHP-6-0360"/></p><p>The data link layer is often conceptually divided into two sublayers: <span class="emphasis"><em>logical link control (LLC)</em></span> and <span class="emphasis"><em>media access control (MAC)</em></span>. This split is based on the architecture used in the IEEE 802 <a class="indexterm" id="idx-CHP-6-0361"/>Project, which is the IEEE working group responsible for creating the standards that define many networking technologies. By separating LLC and MAC functions, interoperability of different network technologies is made easier, as explained in the discussion of networking models in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>.</p><p>The following are the key tasks performed at the data link layer:</p><p><span class="strong"><strong>Logical Link Control (LLC)</strong></span> Logical link control refers to the functions required for the establishment and control of logical links between local devices on a network. This is usually considered a sublayer; it provides services to the network layer above it and hides the rest of the details of the data link layer, which allows different technologies to work seamlessly with the higher layers. Most LAN technologies use the IEEE 802.2 LLC protocol to implement this part of the data link layer.</p><p><span class="strong"><strong>Media Access Control (MAC)</strong></span> This refers to the procedures used by devices to control access to the network medium. Since many networks use a shared medium (such as a single network cable, or a series of cables that are electrically connected into a single virtual medium), it is necessary to have rules for managing the medium to avoid conflicts. For example, Ethernet uses the CSMA/CD method of media access control, while Token Ring uses token passing.</p><p><span class="strong"><strong>Data Framing</strong></span> The data link layer is responsible for data framing, which is the final encapsulation of higher-level messages into <span class="emphasis"><em>frames</em></span> that are sent over the network at the physical layer.</p><p><span class="strong"><strong>Addressing</strong></span> The data link layer is the lowest layer in the OSI model that is concerned with addressing. It labels information with a particular destination location. Each device on a network has a unique number that is used by the data link layer protocol to ensure that data intended for a specific machine gets to it properly. This is usually called a <span class="emphasis"><em>hardware address</em></span> (since it is intimately related with low-level hardware) or a <span class="emphasis"><em>MAC address</em></span> (after the MAC function described earlier).<a class="indexterm" id="idx-CHP-6-0362"/><a class="indexterm" id="idx-CHP-6-0363"/></p><p><span class="strong"><strong>Error Detection and Handling</strong></span> The data link layer handles errors that occur at the lower levels of the network stack. For example, a cyclic redundancy check (CRC) field is often calculated based on the frame's contents and then included in it. This can be employed to allow the station receiving data to detect if it was received correctly.</p><p><span class="strong"><strong>Physical Layer Standards</strong></span> The physical layer and the data link layer are very closely related. The requirements for the physical layer of a network are often part of the data link layer standard that describes a particular technology. Certain physical-layer hardware and encoding aspects are specified by the data link layer technology being used. The best example of this is the Ethernet standard, IEEE 802.3, which specifies not just how Ethernet works at the data link layer, but also its various physical layers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-47"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The second OSI Reference Model layer is the <span class="emphasis"><em>data link layer</em></span>. This is where most LAN and wireless LAN technologies are defined. Layer 2 is responsible for <span class="emphasis"><em>logical link control (LLC), media access control (MAC)</em></span>, hardware addressing, error detection and handling, and defining physical layer standards. It is often divided into the LLC and MAC sublayers based on the IEEE 802 Project that uses that architecture.</p></div><p>Many types of hardware are associated with the data link layer. Network interface cards typically implement a specific data link layer technology, so they are often called Ethernet cards, Token Ring cards, and so on. There are also a number of network interconnection devices that are said to operate at layer 2 in whole or in part because they make decisions about what to do with data they receive by looking at data link layer frames. These devices include most bridges, switches, and brouters, though the latter two also encompass functions performed by layer 3.</p><p>Some of the most popular technologies and protocols generally associated with layer 2 are Ethernet, Token Ring, FDDI (plus CDDI), HomePNA, IEEE 802.11, Asynchronous Transfer Mode (ATM), TCP/IP's Serial Line Interface Protocol (SLIP), and TCP/IP's Point-to-Point Protocol (PPP).</p></div>
<div class="sect1" title="Network Layer (Layer 3)"><div class="titlepage"><div><div><h1 class="title"><a id="network_layer_layer_3"/>Network Layer (Layer 3)</h1></div></div></div><p>The third-lowest layer of the OSI Reference Model is the <span class="emphasis"><em>network layer</em></span>. If the data link layer defines the boundaries of what is considered a network, the network layer defines how <span class="emphasis"><em>internetworks</em></span> (interconnected networks) function. The network layer is the lowest one in the OSI model that is concerned with actually getting data from one computer to another even if it is on a remote network; in contrast, the data link layer only deals with devices that are local to each other.<a class="indexterm" id="idx-CHP-6-0364"/><a class="indexterm" id="idx-CHP-6-0365"/><a class="indexterm" id="idx-CHP-6-0366"/></p><p>While layers 2 through 6 all act as fences between the layers above and below them, the network layer is particularly important in terms of separating higher and lower-layer functions. It is here that the transition really begins from the more abstract functions of the higher layers—which don't concern themselves as much with data delivery—into the specific tasks required to get data to its destination. (The transport layer continues this abstraction transition as you go up the OSI protocol stack.)</p><p>Some of the specific jobs normally performed by the network layer include the following:</p><p><span class="strong"><strong>Logical Addressing</strong></span> Every device that communicates over a network has a logical address associated with it, which identifies the device regardless of its particular location. This is sometimes called a <span class="emphasis"><em>layer 3</em></span> address. For example, on the Internet, the Internet Protocol (IP) is the network layer protocol and every machine has an IP address. Logical addresses are independent of particular hardware and must be unique across an entire internetwork.</p><div class="note" title="Note"><h3 class="title"><a id="note-28"/>Note</h3><p><span class="emphasis"><em>Addressing is done at the data link layer as well, but those addresses refer to local physical devices</em></span>.</p></div><p><span class="strong"><strong>Routing</strong></span> The defining function of the network layer is routing—moving data across a series of interconnected networks. It is the job of the devices and software routines that function at the network layer to handle incoming packets from various sources, determine their final destination, and then figure out where they need to be sent to get them where they are supposed to go. (You'll find a more complete discussion of routing in the OSI model in the section covering indirect device connection in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>.)</p><p><span class="strong"><strong>Datagram Encapsulation</strong></span> The network layer normally <span class="emphasis"><em>encapsulates</em></span> messages received from higher layers by placing them into <span class="emphasis"><em>datagrams</em></span> (also called <span class="emphasis"><em>packets</em></span>) with a network layer header (the previous chapter discusses encapsulation).</p><p><span class="strong"><strong>Fragmentation and Reassembly</strong></span> The network layer must send messages down to the data link layer for transmission. Some data link layer technologies limit the length of any message that can be sent. If the packet that the network layer wants to send is too large, the network layer must split the packet up (fragment it), send each piece to the data link layer, and then have the pieces reassembled once they arrive at the network layer on the destination machine. The IP is the best-known example of a protocol that performs these functions; see <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a> for a discussion of IP datagram fragmentation.</p><p><span class="strong"><strong>Error Handling and Diagnostics</strong></span> The network layer uses special protocols to allow devices that are logically connected (or that are trying to route traffic) to exchange information about the status of hosts on the network or the devices themselves.</p><p>Network layer protocols offer either connection-oriented or connectionless services for delivering packets across the network. Connectionless ones are far more common at the network layer. In many protocol suites, the network layer protocol is connectionless, and connection-oriented services are provided by the transport layer. For example, in TCP/IP, IP is connectionless, while the <a class="indexterm" id="idx-CHP-6-0367"/>layer 4 Transmission Control Protocol (TCP) is connection-oriented. Connection-oriented and connectionless protocols are discussed thoroughly in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a>.</p><p>The most common network layer protocol is IP, which is why I have already mentioned it a couple of times. IP is the backbone of the Internet and the foundation of the entire TCP/IP protocol suite. There are also several protocols directly related to IP that work with it at the network layer, such as IPsec, IP NAT, and Mobile IP. The Internet Control Message Protocol (ICMP) is the main error-handling and control protocol that is used along with IP. Another notable network layer protocol outside the TCP/IP world is the Novell Internetworking Packet Exchange (IPX) protocol.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-48"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <a class="indexterm" id="idx-CHP-6-0368"/>OSI Reference Model's third layer is the <span class="emphasis"><em>network layer</em></span>. This is one of the most important layers in the model; it is responsible for the tasks that link together individual networks into <span class="emphasis"><em>internetworks</em></span>. Network layer functions include internetwork-level addressing, routing, datagram encapsulation, fragmentation and reassembly, and certain types of error handling and diagnostics. The network layer and transport layer are closely related to each other.</p></div><p>The network interconnection devices that operate at the network layer are usually called <span class="emphasis"><em>routers</em></span>. They are responsible for the routing functions I have mentioned, because they receive packets as they are sent along each "hop" of a route and send them on the next leg of their trip. They communicate with each other using routing protocols in order to determine the best routes for sending traffic efficiently. So-called brouters also reside, at least in part, at the network layer, as do the rather obviously named layer 3 switches.</p></div>
<div class="sect1" title="Transport Layer (Layer 4)"><div class="titlepage"><div><div><h1 class="title"><a id="transport_layer_layer_4"/>Transport Layer (Layer 4)</h1></div></div></div><p>The fourth layer of the OSI Reference Model protocol stack is the <span class="emphasis"><em>transport layer</em></span>, also called the <span class="emphasis"><em>middle layer</em></span>. The transport layer is in some ways part of both the lower and upper groups of layers in the OSI model. It is more often associated with the lower layers, because it concerns itself with the <span class="emphasis"><em>transport</em></span> of data, but its functions are also somewhat high level, resulting in its having a fair bit in common with layers 5 through 7 as well.<a class="indexterm" id="idx-CHP-6-0369"/></p><p>You'll recall that layers 1 through 3 are concerned with the actual packaging, addressing, routing, and delivery of data. The physical layer handles the bits, the data link layer deals with local networks, and the network layer handles routing between networks. The <a class="indexterm" id="idx-CHP-6-0370"/>transport layer, in contrast, is sufficiently conceptual that it no longer concerns itself with these nuts-and-bolts matters. It relies on the lower layers to move data between devices.</p><p>The transport layer acts as a liaison of sorts between the abstract world of applications at the higher layers and the concrete functions of layers 1 to 3. Its overall job is to provide the necessary functions to enable communication between software application processes on different computers, which encompasses a number of different but related duties.</p><p>Because modern computers are multitasking, many different software applications may be trying to send and receive data to the same machine at any given point. The transport layer is charged with providing a means by which these applications can all send and receive data using the same lower-layer protocol implementation. Thus, it is sometimes said to be responsible for <span class="emphasis"><em>end-to-end</em></span> or <span class="emphasis"><em>host-to-host</em></span> transport (in fact, the equivalent layer in the TCP/IP model is called the <a class="indexterm" id="idx-CHP-6-0371"/>host-to-host transport layer).</p><p>To accomplish this communication between processes, the transport layer must perform several different but related jobs. For transmission, it must track the data from each application, then combine it into a single flow of data to send to the lower layers. The device receiving information must reverse these operations, fragment the data, and funnel it to the appropriate recipient processes. The transport layer is also responsible for defining the means by which potentially large amounts of application data are fragmented for transmission.</p><p>The transport layer is also responsible for providing <span class="emphasis"><em>connection services</em></span> for the protocols and applications that run at the levels above it. These can be categorized as either connection-oriented services or connectionless services, and each has its uses. While connection-oriented services can be handled at the network layer, they are more often seen in the transport layer in the real world. (Some protocol suites, such as TCP/IP, provide both a connection-oriented and a connectionless transport layer protocol that suits the needs of different applications.)</p><p>The transport layer is also where functions are normally included for adding features to end-to-end data transport. Whereas network layer protocols are normally concerned with just "best-effort" communications for which delivery is not guaranteed, transport layer protocols are given intelligence in the form of algorithms that ensure the reliable and efficient communication between devices. This intelligence encompasses several related jobs, including lost transmission detection and handling, and managing the rate at which data is sent in order to ensure that the receiving device is not overwhelmed.</p><p>Transmission quality—ensuring that transmissions are received as sent—is so important that some networking books define the transport layer on the basis of reliability and flow-control functions. However, not all transport layer protocols provide these services. Just as a protocol suite may have a connection-oriented and a connectionless transport layer protocol, it may also have one transport layer protocol that provides reliability and data management services, and one that doesn't. Again, this is the case with TCP/IP: There is one main transport layer protocol, TCP, that includes reliability and flow-control features, and a second, User Datagram Protocol (UDP), that doesn't.</p><p>Let's look at the specific functions often performed at the transport layer in more detail:</p><p><span class="strong"><strong>Process-Level Addressing</strong></span> Addressing at the transport layer is used to differentiate between software programs. This is part of what enables many different software programs to use a network layer protocol simultaneously. The best example of transport-layer process-level addressing is the TCP and UDP port mechanism that's used in TCP/IP, which allows applications to be individually referenced on any TCP/IP device.</p><p><span class="strong"><strong>Multiplexing and Demultiplexing</strong></span> Using the process-level addresses, transport layer protocols on a sending device <span class="emphasis"><em>multiplex</em></span> the data received from many application programs for transport, combining them into a single stream of data to be sent. The same protocols receive data and then <span class="emphasis"><em>demultiplex</em></span> it from the incoming stream of datagrams, and direct each one to the appropriate recipient application processes.</p><p><span class="strong"><strong>Segmentation, Packaging, and Reassembly</strong></span> The transport layer segments the large amounts of data it sends over the network into smaller pieces on the source machine, and then reassembles them on the destination machine. This function is similar to the fragmentation function of the network layer. Just as the network layer fragments messages to fit the limits of the data link layer, the transport layer segments messages to suit the requirements of the underlying network layer.</p><p><span class="strong"><strong>Connection Establishment, Management, and Termination</strong></span> Transport layer connection-oriented protocols are responsible for the series of communications required to establish a connection, maintain it as data is sent over it, and then terminate the connection when it is no longer required.</p><p><span class="strong"><strong>Acknowledgments and Retransmissions</strong></span> As mentioned earlier, the transport layer is where many protocols that guarantee reliable delivery of data are implemented. This is done using a variety of techniques, most commonly by combining <span class="emphasis"><em>acknowledgment</em></span> and <span class="emphasis"><em>retransmission timers</em></span>. The sending device starts a timer on each occasion that data is sent; if the data is received, the recipient sends back an acknowledgment to the sender to indicate successful transmission. If no acknowledgment is returned before the timer expires, the data is retransmitted. Other algorithms and techniques are usually required to support this basic process.</p><p><span class="strong"><strong>Flow Control</strong></span> Transport layer protocols that offer reliable delivery also often implement <span class="emphasis"><em>flow-control</em></span> features. These features allow one device in a communication to specify to another that it must throttle back the rate at which it is sending data. This will prevent the receiver from being bogged down with data. These features allow mismatches in speed between sender and receiver to be detected and handled.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-49"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The fourth and middle OSI Reference Model layer is the <span class="emphasis"><em>transport layer</em></span>. This layer represents the transition point between the lower layers that deal with data delivery issues, and the higher ones that work with application software. The transport layer is responsible for enabling <span class="emphasis"><em>end-to-end communication</em></span> between application processes, which it accomplishes in part through the use of process-level addressing and multiplexing or demultiplexing. Transport layer protocols are responsible for segmenting application data into blocks for transmission and may be either connection-oriented or connectionless. Protocols at this layer also often provide data delivery management services such as reliability and flow control.</p></div><p>In theory, the transport and network layers are distinct, but in practice, they are often very closely related to each other. You can see this easily just by looking at the names of common protocol stacks. They are often named after the layer 3 and 4 protocols in the <a class="indexterm" id="idx-CHP-6-0372"/>suite, thereby implying their close relationship. For example, the name TCP/IP comes from the suite's most commonly used transport layer protocol (TCP) and network layer protocol (IP). Similarly, the Novell NetWare suite is often called <a class="indexterm" id="idx-CHP-6-0373"/>IPX/SPX for its layer 3 (IPX) and layer 4 (Sequenced Packet Exchange, or SPX) protocols.</p><p>Typically, specific transport layer protocols use the network layers in the same family. You won't often find a network using the transport layer protocol from one suite and the network layer protocol from another. The most commonly used transport layer protocols are TCP and UDP in the TCP/IP suite, SPX in the NetWare protocol suite, and NetBEUI in the <a class="indexterm" id="idx-CHP-6-0374"/>NetBIOS/NetBEUI/NBF suite (though NetBEUI is more difficult to categorize).</p></div>
<div class="sect1" title="Session Layer (Layer 5)"><div class="titlepage"><div><div><h1 class="title"><a id="session_layer_layer_5"/>Session Layer (Layer 5)</h1></div></div></div><p>The fifth layer in the OSI Reference Model is the <span class="emphasis"><em>session layer</em></span>. As you proceed up the OSI layer stack from the bottom, the session layer is the first one where essentially all practical matters related to the addressing, packaging, and delivery of data are left behind; they are functions of layers 4 and below. The session layer is the lowest of the three upper layers, which, as a group, are concerned mainly with software application issues and not with the details of network and internetwork implementation.<a class="indexterm" id="idx-CHP-6-0375"/><a class="indexterm" id="idx-CHP-6-0376"/></p><p>The name session layer is telling: It is designed to allow devices to establish and manage <span class="emphasis"><em>sessions</em></span>. In general terms, a session is a persistent logical linking of two software application processes that allows them to exchange data over time. In some discussions, these sessions are called <span class="emphasis"><em>dialogs</em></span>, and, in fact, they are roughly analogous to a telephone call made between two people.</p><p>Session layer protocols primarily provide the necessary means for setting up, managing, and ending sessions. In fact, in some ways, session-layer software products resemble sets of tools more than specific protocols. These session-layer tools are normally provided to higher-layer protocols through command sets that are often called <span class="emphasis"><em>application program interfaces</em></span> or <span class="emphasis"><em>APIs.</em></span><a class="indexterm" id="idx-CHP-6-0377"/></p><p>Common APIs include NetBIOS, TCP/IP <a class="indexterm" id="idx-CHP-6-0378"/>Sockets, and <a class="indexterm" id="idx-CHP-6-0379"/>Remote Procedure Calls (RPCs). APIs allow an application to easily accomplish certain high-level communications over the network by using a standardized set of services. Most of these session-layer tools are of primary interest to the developers of application software. The programmers use the APIs to write software that is able to communicate using TCP/IP without developers having to know the implementation details of how TCP/IP works.</p><p>For example, the Sockets interface lies conceptually at layer 5 and is used by TCP/IP application programmers to create sessions between software programs over the Internet on the UNIX operating system. Windows Sockets similarly lets programmers create Windows software that is Internet capable and able to interact easily with other software that uses that interface. (Strictly speaking, Sockets is not a protocol, but rather a programming method.)</p><div class="note" title="Note"><h3 class="title"><a id="note-29"/>Note</h3><p><span class="emphasis"><em>The boundaries between layers start to blur once you get to the session layer. This makes it hard to categorize what exactly belongs at layer 5, and some technologies really span layers 5 through 7. In the world of TCP/IP in particular, it is not common to identify protocols that are specific to the OSI session layer</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-50"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The fifth layer in the OSI Reference Model layer is the <span class="emphasis"><em>session layer</em></span>. As its name suggests, it is the layer intended to provide functions for establishing and managing sessions between software processes. Session layer technologies are often implemented as sets of software tools called <span class="emphasis"><em>application program interfaces (APIs)</em></span>, which provide a consistent set of services that allow programmers to develop networking applications without needing to worry about lower-level details of transport, addressing, and delivery.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-30"/>Note</h3><p><span class="emphasis"><em>The term "session" is somewhat vague, which means that there is sometimes disagreement on the specific functions that belong at the session layer, or about whether certain protocols belong at the session layer or not. To add to this potential confusion, there is the matter of differentiating between a connection and a session. Connections are normally the province of layer 4 and layer 3, yet a TCP connection, for example, can persist for a long time. The longevity of TCP connections makes them hard to distinguish from sessions (and there are some people who feel that the TCP/IP host-to-host transport layer really straddles OSI layers 4 and 5)</em></span>.</p></div></div>
<div class="sect1" title="Presentation Layer (Layer 6)"><div class="titlepage"><div><div><h1 class="title"><a id="presentation_layer_layer_6"/>Presentation Layer (Layer 6)</h1></div></div></div><p>The <span class="emphasis"><em>presentation layer</em></span> is the sixth layer of the OSI Reference Model protocol stack and second from the top. It differs from the other layers in two key respects. First, it has a much more limited and specific function than the other layers. Second, it is used much less often than the other layers and is not required by many types of communications.<a class="indexterm" id="idx-CHP-6-0380"/><a class="indexterm" id="idx-CHP-6-0381"/></p><p>This layer deals with the <span class="emphasis"><em>presentation</em></span> of data. More specifically, it is charged with taking care of any issues that might arise when data sent from one system needs to be viewed in a different way by the receiving system. The presentation layer also handles any special processing that must be done to data from the time an application tries to send it until the time it is sent over the network.</p><p>Here are some of the specific types of data-handling issues that the presentation layer handles:</p><p><span class="strong"><strong>Translation</strong></span> Many different types of computers can exist on the same network, such as PCs, Macs, UNIX systems, AS/400 servers, and mainframes. Each has many distinct characteristics and represents data in different ways (with different character sets, for example). The presentation layer hides the differences between machines.</p><p><span class="strong"><strong>Compression</strong></span> Compression (and decompression) may be done at the presentation layer to improve the throughput of data.</p><p><span class="strong"><strong>Encryption</strong></span> Some types of encryption (and decryption) are performed at the presentation layer to ensure the security of the data as it travels down the protocol stack. For example, one of the most popular encryption schemes usually associated with the presentation layer is the <a class="indexterm" id="idx-CHP-6-0382"/>Secure Sockets Layer (SSL) protocol. (Some encryption is done at lower layers in the protocol stack in technologies such as IPsec.)</p><p>The presentation layer is not always used in network communications because these functions mentioned are simply not always needed. Compression and encryption are usually considered optional, and translation features are needed only in certain circumstances. Also, the presentation layer's functions may be performed at the application layer.</p><div class="note" title="Note"><h3 class="title"><a id="note-31"/>Note</h3><p><span class="emphasis"><em>Since its translation job isn't always needed, the presentation layer is commonly skipped by actual protocol stack implementations; in such implementations protocols at layer 7 may talk directly with those at layer 5. This is part of the reason why all of the functions at layers 5 through 7 may be included in the same software package, as described in the overview of layers and layer groupings in the previous chapter</em></span>.<a class="indexterm" id="idx-CHP-6-0383"/></p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-51"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The sixth OSI model layer is the <span class="emphasis"><em>presentation layer</em></span>. Protocols at this layer take care of manipulation tasks that transform data from one representation to another, such as translation, compression, and encryption. In many cases, no such functions are required in a particular networking stack; if so, there may not be any protocol active at layer 6, so layer 7 may deal with layer 5.</p></div></div>
<div class="sect1" title="Application Layer (Layer 7)"><div class="titlepage"><div><div><h1 class="title"><a id="application_layer_layer_7"/>Application Layer (Layer 7)</h1></div></div></div><p>At the very top of the <a class="indexterm" id="idx-CHP-6-0384"/>OSI Reference Model stack of layers, you find layer 7, the <span class="emphasis"><em>application layer</em></span>. Continuing the trend that you saw in layers 5 and 6, this one is also named very appropriately. The application layer is the one that is used by network applications. These programs are what actually implement the functions performed by users to accomplish various tasks over the network.<a class="indexterm" id="idx-CHP-6-0385"/></p><p>It's important to understand that what the OSI model calls an application is not exactly the same as what you normally think of as an application. In the OSI model, the application layer provides services for user applications to employ.</p><p>For example, when you use your web browser, that actual software is an application running on your PC. It doesn't really reside at the application layer. Rather, it makes use of the services offered by a protocol that operates at the application layer, which is called the Hypertext Transfer Protocol (HTTP). The distinction between the browser and HTTP is subtle but important.</p><p>Not all user applications use the network's application layer in the same way. Sure, your web browser, email client, and Usenet newsreader do, but if you open a file over the network with a text editor, that editor is not using the application layer—it just sees a file addressed with a name that has been mapped to a network somewhere else. The operating system redirects what the editor does, over the network.</p><p>Similarly, not all uses of the application layer are by applications. The operating system itself can (and does) use services directly at the application layer.</p><p>That caveat aside, under normal circumstances, whenever you interact with a program on your computer that is designed specifically for use on a network, you are dealing directly with the application layer. For example, sending an email message, firing up a web browser, and using a chat program involve protocols that reside at the application layer.</p><div class="note" title="Note"><h3 class="title"><a id="note-32"/>Note</h3><p><span class="emphasis"><em>There are dozens of different application layer protocols. Some of the most popular ones include HTTP, FTP, SMTP, DHCP, NFS, Telnet, SNMP, POP3, NNTP, and IRC. I describe all of these and more in Section III</em></span>.</p></div><p>As the top-of-the-stack layer, the application layer is the only one that does not provide any services to the layer above it in the stack—there isn't one! Instead, it provides services to programs that want to use the network, and to you, the user. So the responsibilities at this layer are simply to implement the functions that are needed by users of the network and to issue the appropriate commands to make use of the services provided by the lower layers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-52"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>application layer</em></span> is the seventh and highest layer in the OSI Reference Model. Application protocols that implement specific user applications and other high-level functions are defined at this layer. Since they are at the top of the stack, application protocols are the only ones that do not provide services to a higher layer; they use services provided by the layers below.</p></div><p>As you've seen, the distinctions between the top three layers in the OSI Model are not very clear. In the case of TCP/IP, this is exacerbated by the decision not to separate out the session, presentation, and application layer functions. All of the protocols mentioned earlier are from the TCP/IP protocol family, and some may cover all three of the top three OSI layers, two of them, or one; in the TCP/IP model, they are all just considered applications.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;OSI REFERENCE MODEL SUMMARY"><div class="titlepage"><div><div><h1 class="title"><a id="osi_reference_model_summary"/>Chapter 7. OSI REFERENCE MODEL SUMMARY</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e8071"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Many students of networking find the OSI Reference Model challenging to deal with. One main reason for this is that the model is somewhat <span class="emphasis"><em>abstract</em></span>, making it hard to understand and even more difficult to apply to real networking situations. For this reason, I have included in this chapter a set of three tools that I hope will help you better understand and remember the OSI Reference Model's and concepts: an <a class="indexterm" id="idx-CHP-7-0386"/>analogy, a set of mnemonics, and a summary table of OSI model layers.</p><div class="sect1" title="Understanding the OSI Model: An Analogy"><div class="titlepage"><div><div><h1 class="title"><a id="understanding_the_osi_model_an_analogy"/>Understanding the OSI Model: An Analogy</h1></div></div></div><p>I have attempted in this discussion of the OSI Reference Model to provide as much a plain English explanation of how it works as possible. However, there are situations in which a good analogy can accomplish what lots of descriptions cannot. So I am going to illustrate the key OSI model concepts by way of a real-life analogy. You can be the judge of whether it is a <span class="emphasis"><em>good</em></span> analogy or not. Just remember that no analogy is perfect!</p><p>Our scenario seems relatively simple and common: The CEO of a Fortune 500 company needs to send a letter to the CEO of another company. Simple, right? Just like firing up your web browser and connecting to your favorite website is simple. However, in both cases, a lot goes on behind the scenes to make the communication happen. In the <a class="indexterm" id="idx-CHP-7-0387"/>analogy shown in <a class="xref" href="ch07.html#osi_reference_model_real-world_analogy" title="Table 7-1. OSI Reference Model Real-World Analogy">Table 7-1</a>, I compare these real-world and cyber-world communications.</p><div class="table"><a id="osi_reference_model_real-world_analogy"/><p class="title">Table 7-1. OSI Reference Model Real-World Analogy</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSI Reference Model Real-World Analogy"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Phase</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>OSI Layer</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CEO Letter</p></th><th style="border-bottom: 0.5pt solid ; "><p>Website Connection (Simplified)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transmission</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The CEO of a company in Phoenix decides he needs to send a letter to a peer in Albany. He dictates the letter to his administrative assistant.</p></td><td style="border-bottom: 0.5pt solid ; "><p>You decide you want to connect to the web server at IP address 10.0.12.34, which is within your organization but not on your local network. You type the address into your browser.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The administrative assistant transcribes the dictation into writing.</p></td><td style="border-bottom: 0.5pt solid ; "><p>With a website connection, nothing usually happens here. Format translation may be done in some cases.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The administrative assistant puts the letter in an envelope and gives it to the mail room. The assistant doesn't actually know how the letter will be sent, but knows it is urgent, so he says, "Get this to its destination quickly."</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request is sent via a call to an API, which issues the command necessary to contact the server at that address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The mail room must decide how to get the letter where it needs to go. Since it is a rush, the people in the mail room decide to give the envelope to a courier company to send.</p></td><td style="border-bottom: 0.5pt solid ; "><p>TCP is used to create a segment that will be sent to IP address 10.0.12.34.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The courier company receives the envelope, but it needs to add its own handling information, so it places the smaller envelope in a courier envelope (encapsulation). The courier then consults its airplane route information and determines that to get this envelope to Albany, it must be flown through its hub in Chicago. It hands this envelope to the workers who load packages on its planes.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Your computer creates an IP datagram encapsulating the TCP datagram created earlier. It then addresses the packet to 10.0.12.34, but discovers that it is not on its local network. Instead, it realizes it needs to send the message to its designated routing device at IP address 10.0.43.21. It hands the packet to the driver for your Ethernet card (the software that interfaces to the Ethernet hardware).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Routing</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The workers take the courier envelope and put a tag on it with the code for Chicago. They then put it in a handling box and load it on the plane to Chicago.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Ethernet card driver forms a frame containing the IP datagram and prepares it to be sent over the network. It packages the message and puts the address 10.0.43.21 (for the router) in the frame.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The plane flies to Chicago.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The frame is sent over the twisted-pair cable that connects your local area network. (I'm ignoring overhead, collisions, and so on, here, but then I also ignored the possibility of collisions with the plane.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>In Chicago, the box is unloaded, and the courier envelope is removed from it and given to the people who handle routing in Chicago.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Ethernet card at the machine with IP address 10.0.43.21 receives the frame, strips off the frame headers, and hands it up to the network layer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The tag marked "Chicago" is removed from the outside of the courier envelope. The envelope is then given back to the airplane workers to be sent to Albany.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP datagram is processed by the router, which realizes the destination (10.0.12.34) can be reached directly. It passes the datagram back down to the Ethernet driver.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The envelope is given a new tag with the code for Albany, placed in another box, and loaded on the plane to Albany.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Ethernet driver creates a new frame and prepares to send it to the device that uses IP address 10.0.12.34.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The plane flies to Albany.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The frame is sent over the network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The box is unloaded, and the courier envelope is removed from the box. It is given to the Albany routing office.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Ethernet card at the device with IP address 10.0.12.34 receives the frame, strips off the headers, and passes it up the stack.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reception</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The courier company in Albany sees that the destination is in Albany and delivers the envelope to the destination CEO's company.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP headers are removed from the datagram, and the TCP segments are handed up to TCP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The mail room removes the inner envelope from the courier envelope and delivers it to the destination CEO's assistant.</p></td><td style="border-bottom: 0.5pt solid ; "><p>TCP removes its headers and hands the data up to the drivers on the destination machine.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The assistant takes the letter out of the envelope.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request is sent to the web-server software for processing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The assistant reads the letter and decides whether to give the letter to the CEO, transcribe it to email, call the CEO on her cell phone, or whatever.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Again, in this example nothing probably happens at the presentation layer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; "><p>The second CEO receives the message that was sent by the first one.</p></td><td style=""><p>The web server receives and processes the request.</p></td></tr></tbody></table></div></div><p>As you can see, the processes have a fair bit in common. The vertical communication and encapsulation are pretty obvious, as is the routing. Also implied is the horizontal communication that occurs logically—the two CEOs seem to be "connected" despite all that happens to enable this to occur. Similarly, in a way, the two assistants are logically connected as well, even though they never actually converse. Of course, this example is highly simplified in just about every way imaginable, so please don't use it as a way of trying to learn about how TCP/IP works—or courier services, for that matter!</p></div></div>
<div class="sect1" title="Remembering the OSI Model Layers: Some Mnemonics"><div class="titlepage"><div><div><h1 class="title"><a id="remembering_the_osi_model_layers_some_mn"/>Remembering the OSI Model Layers: Some Mnemonics</h1></div></div></div><p>If you spend any amount of time at all dealing with networking design or implementation issues, or learning about how the various protocols operate, the names and numbers of the various layers will eventually become second nature.</p><p>Many people, however, especially those just learning about networks, find it difficult to recall the names of all the layers, and especially, their exact order. For these people, a number of <a class="indexterm" id="idx-CHP-7-0388"/>mnemonics have been created as memory aids. You probably remember <a class="indexterm" id="idx-CHP-7-0389"/>mnemonics from elementary school. These are cute phrases in which each word starts with the first letter of an OSI model layer, arranged in the correct order. Some of these go in ascending layer number order, and some go in the other direction.</p><p>These two go from physical layer to application layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Please Do Not Throw Sausage Pizza Away</p></li><li class="listitem"><p>Please Do Not Touch Steve's Pet Alligator</p></li></ul></div><p>And these go the other direction, from application to physical:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>All People Seem To Need Data Processing (a popular one)</p></li><li class="listitem"><p>All People Standing Totally Naked Don't Perspire (hmm, that's interesting!)</p></li></ul></div><p>For your convenience, I have illustrated all four of these in <a class="xref" href="ch07s02.html#osi_reference_model_mnemonics_these_mnem" title="Figure 7-1. OSI Reference Model mnemonics These mnemonics may help you to remember the order of the OSI Reference Model layers.">Figure 7-1</a>.</p><div class="figure"><a id="osi_reference_model_mnemonics_these_mnem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e8365"/><img alt="OSI Reference Model mnemonics These mnemonics may help you to remember the order of the OSI Reference Model layers." src="httpatomoreillycomsourcenostarchimages287717.png"/></div></div><p class="title">Figure 7-1. OSI Reference Model mnemonics These mnemonics may help you to remember the order of the OSI Reference Model layers.</p></div><p>Or try my own creation: All People Should Teach Networking Daily Please.<a class="indexterm" id="idx-CHP-7-0390"/></p></div>
<div class="sect1" title="Summarizing the OSI Model Layers: A Summary Chart"><div class="titlepage"><div><div><h1 class="title"><a id="summarizing_the_osi_model_layers_a_summa"/>Summarizing the OSI Model Layers: A Summary Chart</h1></div></div></div><p>To assist you in quickly comparing the layers of the <a class="indexterm" id="idx-CHP-7-0391"/>OSI Reference Model, and understanding where they are different and how they relate to each other, I'm offering you the summary chart shown in <a class="xref" href="ch07s03.html#osi_reference_model_layer_summary" title="Table 7-2. OSI Reference Model Layer Summary">Table 7-2</a>. It shows each layer's name and number, describes its key responsibilities, talks about what type of data is generally handled at each layer, and also describes the scope of each layer in approximate terms. I also show some of the more common protocols that are associated with each layer.</p><p>The standard disclaimers still apply to this table. Namely, the layers aren't always hard-fast; I haven't listed every single protocol here, so some may really fit into more than one layer, and so on. In particular, note that many of the technologies listed as being in the data link layer are there because that is the layer where their primary functionality resides. In reality, most of these technologies include components in other layers, especially the physical layer.</p><div class="table"><a id="osi_reference_model_layer_summary"/><p class="title">Table 7-2. OSI Reference Model Layer Summary</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSI Reference Model Layer Summary"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Group</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>#</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Layer Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Key Responsibilities</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data Type Handled</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Scope</p></th><th style="border-bottom: 0.5pt solid ; "><p>Common Protocols and Technologies</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lower Layers</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Physical</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encoding and signaling; physical data transmission; hardware specifications; topology and design</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bits</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Electrical or light signals sent between local devices</p></td><td style="border-bottom: 0.5pt solid ; "><p>Physical layers of most of the technologies listed for the data link layer</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data Link</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Logical link control; media access control; data framing; addressing; error detection and handling; defining requirements of physical layer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Frames</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Low-level data messages between local devices</p></td><td style="border-bottom: 0.5pt solid ; "><p>IEEE 802.2 LLC, Ethernet family; Token Ring; FDDI and CDDI; IEEE 802.11 (WLAN, Wi-Fi); HomePNA; HomeRF; ATM; SLIP and PPP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Logical addressing; routing; datagram encapsulation; fragmentation and reassembly; error handling and diagnostics</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagrams/packets</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Messages between local or remote devices</p></td><td style="border-bottom: 0.5pt solid ; "><p>IP; IPv6; IP NAT; IPsec; Mobile IP; ICMP; IPX; DLC; PLP; routing protocols such as RIP and BGP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transport</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Process-level addressing; multiplexing/demultiplexing; connections; segmentation and reassembly; acknowledgments and retransmissions; flow control</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagrams/segments</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Communication between software processes</p></td><td style="border-bottom: 0.5pt solid ; "><p>TCP and UDP; SPX; NetBEUI/NBF</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Upper Layers</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Session</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Session establishment, management, and termination</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sessions</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sessions between local or remote devices</p></td><td style="border-bottom: 0.5pt solid ; "><p>NetBIOS, Sockets, named pipes, RPC</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Presentation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data translation; compression and encryption</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encoded user data</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Application data representations</p></td><td style="border-bottom: 0.5pt solid ; "><p>SSL; shells and redirectors; MIME</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; "><p>Application</p></td><td style="border-right: 0.5pt solid ; "><p>User application services</p></td><td style="border-right: 0.5pt solid ; "><p>User data</p></td><td style="border-right: 0.5pt solid ; "><p>Application data</p></td><td style=""><p>DNS; NFS; BOOTP; DHCP; SNMP; RMON; FTP; TFTP; SMTP; POP3; IMAP; NNTP; HTTP; Telnet</p></td></tr></tbody></table></div></div></div></body></html>