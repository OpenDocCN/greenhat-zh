- en: Chapter 11. CGI and the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ruby has gotten a lot of attention as a language particularly well suited for
    web programming, especially in the context of the Rails development framework.
    Some people even go so far as to categorize Ruby as a web language, suggesting
    that it is not a full-fledged general-purpose programming language. I hope that
    the previous chapters have played at least a modest role in convincing readers
    that this assertion is false.
  prefs: []
  type: TYPE_NORMAL
- en: That said, Ruby is very useful for web work, and it does have some characteristics
    that make it better suited for web programming than (for example) video game programming.
    Ruby operates at a very high level of abstraction, giving programmers a large
    toolset to work with, and it executes code at a slower speed than some other languages.
    These characteristics make Ruby well suited for web work, since development speed
    is often critical, but program execution speed is often less critical than in
    other types of programs, such as real-time action video games.
  prefs: []
  type: TYPE_NORMAL
- en: The Rails development framework has been instrumental in bringing Ruby to the
    attention of an ever-larger audience. Some say it’s Ruby’s “killer app,” analogous
    to Perl’s CPAN or the GNU project’s gcc. This is a general Ruby book, not a Rails
    book, but Rails is important enough that it gets its own chapter. (Since we’ll
    be using RubyGems, Ruby’s package-management system, to install Rails, this book
    also has a chapter devoted to RubyGems.)
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have to wait two chapters for Rails. Aside from knowing how to install
    it with RubyGems, by then you should also know something about web programs in
    general—that’s what this chapter is for. If you’re a web app veteran, feel free
    to skip this chapter, although you may find some of the specific scripts novel
    and interesting, even if you already know how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Common Gateway Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common approach to web programming is the Common Gateway Interface
    (CGI). *CGI* is not a programming language; it’s a set of rules for programs to
    follow when they run on the Web, regardless of the particular language in which
    each program might be written. CGI enables friendly cooperation among multiple
    files that could even be written in distinct programming languages but all exist
    together within a larger web application.
  prefs: []
  type: TYPE_NORMAL
- en: Using more than one language for a single web application is fairly common.
    I mentioned that Ruby’s high level of abstraction makes it suitable for web programming.
    However, sometimes you might really want to use a library someone has already
    written in another language—like Python, for instance—in a web program. If you
    use CGI, you could write part of your web application in Python in order to use
    that library. You might also have a section of your web application that is highly
    speed critical, so you could write that part in C for execution speed, and the
    rest in Ruby for development speed. This is exactly the reason that Paul Graham
    and his colleagues chose to use a combination of Lisp and C for their company
    Viaweb, which eventually became Yahoo! Stores. They were able to do so because
    the CGI specification holds across multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation and Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get going with Ruby and CGI, we’ve got to do a little work to get
    our webserver ready. For the purposes of this chapter, I’ll be focusing on getting
    CGI working for the Apache webserver running on a Unix-like environment. Apache
    is the most popular webserver, and Unix-like operating systems are the most common
    (and most stable) server operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a copy of the Apache webserver at [http://httpd.apache.org](http://httpd.apache.org),
    or you can use a package manager to install it. (Mac OS X comes with Apache pre-installed.)
    I used `apt-get` on my Ubuntu system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I answered `Y`. You can see that I chose the `apache2` version of the Apache
    webserver. After installing Apache, you’ll also want to install packages for `mod_ruby`,
    which allows Ruby programs to be run within the webserver. I’ll explain the benefits
    of this when we get to the script that shows `mod_ruby` being used. You can install
    `mod_ruby` by typing `apt-get install libapache2-mod-ruby liberuby` on a Debian-based
    system. Now that the installation is done, let’s start with our first simple CGI
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '#41 A Simple CGI Script (simple_cgi.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is fairly quick and dirty, but it shows the basics of how to use
    Ruby for CGI and introduces Ruby’s aptly named `cgi` library. You’ll need to put
    this script in your system’s cgi-bin directory. It’s `/usr/lib/cgi-bin/` on my
    system, although your system’s location may be different. You can then browse
    to http://localhost/cgi-bin/simple_cgi.rb, because your webserver will provide
    access to the contents of your cgi-bin directory via http://localhost/cgi-bin/.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You’ll also need to give `simple_cgi.rb 755` permissions, meaning that its
    owner can do anything with it and everyone else can read and execute it, but not
    write (change) it. For more information, see *`man chmod`**.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we even get started with the script, you should also browse to http://localhost/.
    If you see either a page telling you that Apache is installed correctly or a listing
    of files in a directory, your webserver is probably working. If you don’t see
    either of these things, consult the Apache documentation (available at http://httpd.apache.org/docs)
    to diagnose the problem. If your webserver is working, you can proceed to the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we do in the script is `require` the `cgi` library at ❶. Then
    we define a class called `Simple_CGI` at ❷ and the Constants `EMPTY_STRING` and
    `TITLE` at ❸. Next, within the `display` method (at ❹), we create an instance
    of `CGI` called `cgi`, defining it in terms of `html4`, which is one of the versions
    of HTML that `CGI` is aware of. We’ll use `cgi` to create an HTML document that
    `simple_cgi.rb` will output.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of `CGI` have several methods that take blocks, whose names are the
    same as the tags they will create. Every HTML document needs an `<html>` tag,
    so we include that at ❺. For reasons I’ll explain shortly, I want to store the
    contents of the `<html>` tag in a temporary local variable called `output`. We
    can go through the HTML document we want to create, opening new tags with the
    appropriate method of `cgi` (like `head, title, h1`, etc.). Hierarchical nesting
    is accomplished using blocks, as you can see, and tags that are at the same level
    (*siblings*) are concatenated with the `+` method.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that within `cgi.body`, which creates the `<body>` tag within
    our resulting output, I have used a method at ❻ called `show_def_list` (defined
    at ❿). This is mainly to avoid multiple levels of block nesting for the methods
    of `cgi`, but it also performs other tasks. Let’s examine it at ❿. It outputs
    a definition list as you’d expect using `cgi.dl` with a block. To do so, it pulls
    both `terms` and their `definitions` from a Hash called `items`, wrapping them
    in `<dt>` and `<dd>` tags, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `items` Hash is defined by the output of `get_items_hash` (❽) merged with
    `cgi.params`. The `cgi.params` Hash represents the query string, so if you browse
    to http://localhost/cgi-bin/simple_cgi.rb?key1=value1&key2=value2, `cgi.params`
    would be `{ ‘key1’ => ‘value1’, ‘key2’, ‘value2’ }`. The `get_items_hash` method
    returns a Hash representing some values that I thought might be worth demonstrating,
    such as the script name, the server, and so on. In general, the script simply
    reads from the machine’s environment, using values of the `ENV` Hash. At ❾, the
    value for `‘server’` in the Hash is slightly more complex than the others. It
    tries to read from `ENV` like the others, falling back to a system execution of
    the `hostname` command, and finally falling back to the `EMPTY_STRING`, if necessary.
    This resulting Hash is then returned implicitly, because it’s the last evaluated
    expression in the method.
  prefs: []
  type: TYPE_NORMAL
- en: Back at ❼, we call `cgi.out`, giving it a block with a slight massaging of the
    `output` variable using `gsub`. I’ll be the first to admit that this is a little
    unusual. Normally, you call `cgi.out` with a block that includes `cgi.html` and
    all the other methods I used to fill the `output` variable. Why did I do it this
    way? There are two related reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first reason is that `cgi.out` is not purely functional: It doesn’t return
    a value to be printed using `puts`. Instead, it does the outputting by itself.
    The second reason is that `cgi`’s methods don’t introduce line breaks between
    tags. This is good for speed optimization, in that each new character, even just
    a line break, is slightly more content to transfer. However, it doesn’t make the
    resulting HTML source very readable. I like readable HTML source, so I use `gsub`
    at ❼ to introduce line breaks between adjacent tags. If you don’t mind your HTML
    all strung together in a single line, by all means, put your `cgi.html` and similar
    calls within the block for `cgi.out`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything we have discussed so far has been within the `display` method. We
    call it on the last line of the script, directly on an anonymous new instance
    of `Simple_CGI`. There’s no real need to instantiate it into a variable, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, if you’re more comfortable doing that, there’s also no reason not to.
    Let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On your system, browse to http://localhost/cgi-bin/simple_cgi.rb and see what
    you get. It should be something more or less like [Figure 11-1](ch11s03.html#the_output_of_ltliteralgtsimple_cgirbltl
    "Figure 11-1. The output of simple_cgi.rb").
  prefs: []
  type: TYPE_NORMAL
- en: Note that the software value will probably differ, unless you’re also using
    a fairly stock Ubuntu system, and the time will obviously differ a great deal.
    You can see that the tab shows the page title, which is *A simple CGI script*
    (the same as the large bold header). Values that should not differ are the script
    and server, unless you’ve intentionally changed the filename from `simple_cgi.rb`
    to something else or browsed to a hostname other than `localhost`. Astute readers
    will also see that I had another tab open to the Apache website.
  prefs: []
  type: TYPE_NORMAL
- en: '![The output of simple_cgi.rb](httpatomoreillycomsourcenostarchimages686188.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1. The output of `simple_cgi.rb`
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try changing the query string a bit, with http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby.
    I won’t bother showing a new screenshot, but you should now see five entries in
    the definition list instead of four. The new one is the key `lang`, which has
    a value of `Ruby`. This appears because `cgi.params` is a part of the items Hash
    within `show_def_list` at ❿, and when we use the query string `lang=Ruby, cgi.params`
    is `{ ‘lang’ => ‘Ruby’ }`, which is then one of the pairs in `items`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try giving an explicit value within the query string to one of the
    keys that already appears in items, with the URL http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby&server=some_other_server_name.
    You should still see the key `lang` with a value `Ruby`, but in addition, the
    value for `server` is no longer `localhost`, but is instead `some_other_server_name`.
    The reason this happens is that `cgi.params` is the argument to `merge`, and it
    overrides any conflicting pair already in the Hash on which `merge` is called.
    Therefore, anything in `cgi.params` takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is just a simple script showing the basics of CGI. You could modify and
    extend it in countless ways. One suggestion would be to incorporate part of `currency_converter2.rb`.
    For example, you could display the time, just as this script already does, and
    take arguments for the currencies to convert from and to as well as the amount
    of money to convert. Many people also use CGI to execute system calls on a machine
    and display the results, showing the processes running on the machine, how much
    disk space is used, and other information of interest to system administrators.
  prefs: []
  type: TYPE_NORMAL
- en: '#42 Mod Ruby (mod_ruby_demo.rhtml and mod_ruby_demo.conf)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CGI is great for many applications. However, sometimes you may want to have
    files that are mainly HTML, with only subsections that need to be executed by
    your programming language, Ruby or otherwise. Wouldn’t it be great if you had
    an HTML tag that meant *Start Ruby code now*, after which you could add some Ruby
    code, and then use another tag that meant *Done with Ruby code, go back to plain
    old HTML*?
  prefs: []
  type: TYPE_NORMAL
- en: There is such a system, for many languages. It’s the default behavior for the
    PHP language, and similar systems are available for Perl and Python, among others.
    One of the systems that does this for Ruby is `eRuby`, which will be embedded
    directly within the webserver via the `mod_ruby` software.
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems with CGI is speed. When someone makes a web request that
    needs dynamic CGI execution, that request spawns a new Ruby interpreter;^([[32](#ftn.CHP-11-FNOTE-1)])
    that interpreter then evaluates the CGI program, returns its value to the webserver
    process, and closes down. For the next CGI request, the whole process start all
    over again. All of this takes time. What `mod_ruby` and similar systems do is
    have a Ruby interpreter always running in the background, ready to evaluate scripts
    and return their results to the webserver, but without the overhead of spawning
    and shutting down a distinct `ruby` process for each script. This makes the webserver
    start up a bit slower, because it needs to do more, but it saves a lot of machine
    overhead after just a few requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, you’ll see `<%` and `%>`, the opening and closing tags that mean
    *Interpret my contents in Ruby, not as HTML*. But first we need to set up Apache
    so that it knows how to handle `mod_ruby`. We’ve already installed the `mod_ruby`
    packages, but we need a configuration file. That’s `mod_ruby_demo.conf` below.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: mod_ruby_demo.conf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This file isn’t Ruby code—it uses Apache’s configuration file format. Put this
    file in `/etc/apache2/mods-available/`, with a symlink in `/etc/apache2/mod-enabled/`.^([[33](#ftn.CHP-11-FNOTE-2)])
    If you’re using Apache version 1.X (such as 1.3, which is still popular), you’ll
    add the contents of this file within your `/etc/apache/httpd.conf` file. As I
    noted for the `cgi-bin` directory, these specific file and directory locations
    are accurate for my system, but yours might be different.
  prefs: []
  type: TYPE_NORMAL
- en: mod_ruby_demo.rhtml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file should be more recognizable as a weird hybrid of HTML and Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Put this file somewhere browsable via the Web. I’ll assume it’s in http://localhost/mod_ruby/,
    making it accessible as http://localhost/mod_ruby/mod_ruby_demo.rhtml.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, `mod_ruby_demo.conf` will be completely opaque. I’m kidding, of course,
    but it’s not critical at this point if you don’t understand everything about this
    file. It’s great to know about Apache configuration files, and you can certainly
    learn a great deal from the Apache website ([http://www.apache.org](http://www.apache.org))
    or the various Apache-related books out there, but what’s important for our purposes
    are points ❶ and ❷. At ❶, we declare that files having the .rcss extension are
    to be interpreted as Ruby files. At ❷, we make the same declaration about files
    having the .rhtml extension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why these extensions? It’s a fairly common practice to define filename extensions
    for dynamically interpreted files with the normal extension and an additional
    preceding letter representing the programming language used. For example*, .rhtml
    *is used for Ruby files that generate HTML output*, .rcss *is used for Ruby files
    that generate CSS stylesheets, and so on. You may also sometimes see .phtml files
    that integrate Perl or PHP, or even .mhtml files that use the software Mason,
    written in Perl*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for `mod_ruby_demo.conf`. In `mod_ruby_demo.rhtml`, we have some
    additional points of interest. It should look like standard HTML until ❸. At that
    point, we see this line: `<q><% print “Hello, world!” %></q>`. The `<%` and `%>`
    are the *Interpret my contents as* Ruby tags I mentioned earlier, so anything
    within those tags will be interpreted as Ruby code. In this case, we’re asking
    Ruby to print `‘Hello, world!’`, which it does, incorporating the printed output
    within the eventual HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll probably expect that we often want to print output that will be incorporated
    into the HTML. It would be tedious to keep using `print` statements, so there’s
    a shortcut, which you can see at ❹. If you use an initial code tag of `<%=`, Ruby
    assumes that you want the evaluated expression to be printed. At ❹, we incorporate
    the value of `ENV[‘SERVER_NAME’]` within an `<em>` tag. Just to show that what
    falls between `<%=` and `%>` can be any expression, at ❺, we concatenate two Strings,
    only caring about the result.
  prefs: []
  type: TYPE_NORMAL
- en: The printed output doesn’t have to be a simple literal expression, either. At
    ❻, I show the value of a method call, which in this case results in the current
    local time. Finally, at ❼, we define a completely new method within our .rhtml
    file called `function_within_mod_ruby`, which is then available anytime afterward
    for use, as you can see in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I call this script via my own webserver, I get the results shown in [Figure 11-2](ch11s04.html#the_output_from_ltliteralgtmod_rubyltlit
    "Figure 11-2. The output from mod_ruby").
  prefs: []
  type: TYPE_NORMAL
- en: '![The output from mod_ruby](httpatomoreillycomsourcenostarchimages686172.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2. The output from `mod_ruby`
  prefs: []
  type: TYPE_NORMAL
- en: The time will obviously be different in your result, but that should be the
    only difference, unless you specifically browse to your machine by a name other
    than `localhost`, or you placed `mod_ruby_demo.rhtml` under a different directory
    or gave it a different name.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script is a modification playground. You can put any Ruby expressions you
    want within those `<%` or `<%=` tags. Try using `require`, either with files that
    you know are part of the standard library (like `cgi`) or your own files. This
    technique lets you define all your real “things” as classes in .rb library files,
    reserving your .rhtml files for display.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#CHP-11-FNOTE-1)]) Or an interpreter for whichever language the CGI
    program uses.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[33](#CHP-11-FNOTE-2)]) You can create a symlink with the command `ln -s`
    in a Unix shell.
  prefs: []
  type: TYPE_NORMAL
- en: '#43 CSS Stylesheets, Part I (stylesheet.rcss)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having .rhtml files is great—they allow you to dynamically generate whatever
    visible HTML you want. But you can use `mod_ruby` for more than that. A major
    portion of any well-designed modern website will be its stylesheets. One of the
    frustrations that web designers have to deal with is incomplete or incompatible
    CSS support among the various browsers. There are lots of potential solutions
    for those frustrations, which you can find at sites like [http://www.richinstyle.com](http://www.richinstyle.com)
    or [http://alistapart.com](http://alistapart.com). One obvious solution for programmers
    is to determine exactly which browser someone is using (via `ENV[‘USER_AGENT’]`)
    and serve that user a stylesheet customized for his or her specific browser.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a great solution, put into practice countless times all over the Web.
    There is another solution, however. Why not make the stylesheet itself a dynamic
    .rcss file? With this approach, the stylesheet becomes polymorphic, to use a term
    from object-oriented programming. Every browser would refer to the same stylesheet
    by name and would then receive specific content that works just right for that
    browser. Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like `mod_ruby_demo.rhtml`, this is mainly a file with some other format
    (in this case a CSS stylesheet) that happens to have a little Ruby interspersed
    within it. We define a new function called `alpha_width` at ❶ that determines
    the value of a local variable called `width`, finally returning it within a bit
    of text that follows CSS formatting at ❷. Note that this function takes advantage
    of the fact that even `if` statements in Ruby return a value, in this case, assigning
    that value into `width`. We do something similar with `beta_width` at ❸, which
    returns its own CSS-formatted output at ❹. Finally, we define `margin_left` at
    ❺, which returns CSS at ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Why those particular functions? I found that the CSS support variations that
    frustrated me the most were the differences involving margins and padding and
    left margins for list items, so those are the functions I made. People who know
    more about CSS than I do have probably found more elegant solutions, but sometimes
    a pretty good solution now is better than a perfect solution when it’s too late.
    The point of this script is also to demonstrate that the polymorphic stylesheet
    technique* can *be done, but this isn’t precisely* how *it should be done. If
    you care a great deal about CSS, you can use this technique to accomplish much
    bigger things*.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the output of `margin_left` within a CSS declaration for a list
    element at ❼. The stylesheet also defines two IDs called `#navAlpha` and `#navBeta`,
    which are just identifiers for column divs. Within `#navAlpha` at ❽, we use the
    output of `alpha_width` for the width of `#navAlpha`, and at ❾, we do something
    analogous for `#navBeta`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the output of `stylesheet.rcss` when I browse to it using Mozilla Firefox
    on an Ubuntu system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the appropriate values are interpolated within the `li` and
    `width` CSS declarations. Your results may differ, since the whole point of this
    file is to provide different output for different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many hacking options for this script. One is our next script, `stylesheet2.rcss`.
  prefs: []
  type: TYPE_NORMAL
- en: '#44 CSS Stylesheets, Part II (stylesheet2.rcss)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many ways, this script is just a glorified hack of `stylesheet.rcss`. I separated
    it mainly to allow for comparison. The major difference between the two files
    is that `stylesheet2.rcss` generalizes the `width` values into a single function.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At ❶, we define the general `width` function, which you’ll see now takes two
    arguments: the user agent as before, but also the `type` of column we’re generating
    `width` for. We then have separate Hashes for `small` (❷), `large` (❸), and `palm`
    (❹). Palm devices always use their own Hash, while other browsers use either the
    `small` or `large` Hash, depending on the specific user agent. Then at ❺, we determine
    the `width`.^([[34](#ftn.CHP-11-FNOTE-3)]) The `type` is simply the key for whichever
    Hash has already been decided on. Everything else is identical to `stylesheet.rcss`,
    except that calls to either `alpha_width` or `beta_width` are now calls to `width`,
    as described already.'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, here’s the output with my setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This output is basically the same as that for `stylesheet.rcss`, except for
    the preliminary comments.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I already noted, someone with a better grasp of CSS could really customize
    this script to do some marvelous things. There are undoubtedly better ways to
    accomplish what this script does, but its point was to show the technique in broad
    strokes. I hope you found it useful.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#CHP-11-FNOTE-3)]) Don’t be confused by the fact that there is both
    a function called `width` and a local variable inside it also called `width`.
    Anything outside the function can’t get at the variable, and the function knows
    to check whether or not there’s a variable by that name before automatically making
    a recursive call to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Using Ruby for CGI scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cgi` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cgi.params`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod_ruby`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .rhtml and .rcss files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter scratches the surface of CGI programming, with Ruby or other languages.
    Its purpose was to get you comfortable with using Ruby to interact with a webserver
    and browser. Most web-based coding in Ruby makes use of the Rails framework, which
    we’ll get to soon. But first, we’ll be installing Rails with the RubyGems system,
    so that is the subject of our next chapter.
  prefs: []
  type: TYPE_NORMAL
