- en: Part III. Out in the Wild
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分. 野外
- en: '*Once you are on the Internet, it gets dirty*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你上网，就会变得复杂*'
- en: —
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: Chapter 9. Foreign Accent
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 外国口音
- en: '*Passive fingerprinting: subtle differences in how we behave can help others
    tell who we are*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*被动指纹识别：我们行为中的微妙差异可以帮助他人识别我们*'
- en: —
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: On the Internet, the network of networks, information sent to a remote party
    is beyond the sender’s control and supervision. Unlike on a local Ethernet, which
    is usually a safe harbor for packets until a stranger wanders in, once data is
    out in the wild it is no longer possible to estimate and effectively manage threats
    that it is likely to face, as no single person can control the data’s path or
    determine the intentions of all parties involved in communications, let alone
    determine how they approach security. On such a complex network, the likelihood
    of a middle party becoming malicious is neither negligible nor easy to assess.
    In fact, even the person with whom you are establishing legitimate communications
    may have a hidden agenda or simply be a bit curious.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网，这个网络的网络中，发送给远程方的信息超出了发送者的控制和监督。与通常是一个安全港，直到陌生人闯入的本地以太网不同，一旦数据进入野外，就不再可能估计和有效管理它可能面临的威胁，因为没有单一个人可以控制数据的路径或确定所有参与通信方的意图，更不用说确定他们如何处理安全问题。在这样的复杂网络中，中间方变得恶意既不是微不足道的，也不是容易评估的。事实上，甚至与你建立合法通信的人也可能有隐藏的议程，或者只是有点好奇。
- en: 'Unsolicited data acquisition attempts, so to speak, are also different when
    carried out over the Internet for a couple other reasons. Most important, they
    do not have to be targeted, and they are not limited to a specific segment of
    physical infrastructure. Because they require so little effort on the part of
    an attacker, they become a viable route for acquiring potentially interesting
    data even prior to determining a precise way to profit or otherwise benefit from
    this knowledge. Too, the line between good and bad becomes even more fuzzy: the
    attacker can be your best friend. The profitability of general espionage and surveillance
    for the purposes of marketing reconnaissance and profiling is too tempting for
    many to resist; the world of service provisioning is not black and white, and
    flexible ethics is simply a viable business model for many people.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 未经请求的数据获取尝试，换句话说，在互联网上进行时，由于其他几个原因，也有所不同。最重要的是，它们不需要有针对性，并且不限于特定的物理基础设施部分。由于它们对攻击者来说需要付出如此少的努力，因此它们成为在确定如何从这种知识中获利或以其他方式从中受益的确切方法之前获取可能有趣的数据的可行途径。此外，好与坏之间的界限变得更加模糊：攻击者可以是你最好的朋友。为了市场侦察和配置文件目的的一般间谍活动和监控的盈利性对许多人来说太诱人了，以至于难以抗拒；服务提供的世界不是非黑即白，灵活的道德观对许多人来说只是一个可行的商业模式。
- en: This part of the book focuses on the threats inherent in the open design of
    the Internet and on the ability of others to obtain way more information about
    you than you might expect—and more than would ever be needed in order for them
    to provide you a service such as an interesting website or an enjoyable network-based
    game. Once on the Internet, the enemy is no longer a lone madman sitting across
    the street, watching LEDs on the switch through a high-tech telezoom lens. The
    exposures covered here make it possible to carry out massive profiling, tracking,
    information gathering, industrial espionage, network reconnaissance, and preattack
    analysis—and are far more real than the scenarios described previously.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的书主要关注互联网开放设计固有的威胁，以及他人获取比你预期的更多关于你的信息的能力——而且比他们为了提供像有趣网站或令人愉快的基于网络的电子游戏这样的服务所需的更多。一旦上网，敌人就不再是坐在街对面的孤独的疯子，通过高科技望远镜镜头观察交换机的LED灯。这里涵盖的暴露使得进行大规模的配置文件、跟踪、信息收集、工业间谍活动、网络侦察和攻击前分析成为可能——而且比之前描述的场景更加真实。
- en: You need to understand the threats in order to maintain an informed level of
    privacy protection or perhaps to deploy effective monitoring whether of your users
    or of complete strangers, as they approach your systems. Understanding is also
    the key to maintaining sanity in a world where the line between being concerned
    about privacy and becoming clinically paranoid is fairly thin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持对隐私保护的知情水平，或者为了部署有效的监控，无论是针对你的用户还是完全陌生的人，当他们接近你的系统时，你需要了解这些威胁。了解也是在一个隐私关注与临床偏执之间的界限相当微薄的世界中保持理智的关键。
- en: I’ll begin with an examination of a set of core network protocols used over
    the Internet and their privacy implications. Shall we?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从检查一组在互联网上使用的核心网络协议及其隐私影响开始。我们开始吧？
- en: The Language of the Internet
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网的语言
- en: The official language of the Internet is called the *Internet Protocol*, and
    the most popular dialect is labeled version 4\. The protocol, specified in RFC793,^([[74](apb.html#ftn.CHP-9-BIB-1)])
    provides a way to implement a standardized method for transmitting data over vast
    distances and a variety of networks with as little effort as possible. IP packets
    constitute the third layer in the OSI model discussed previously and consist of
    a header that contains the information necessary to deliver a portion of data
    to its ultimate destination—the *remote endpoint*—and a payload constructed of
    higher-layer information that immediately follows the header data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的官方语言被称为*互联网协议*，最流行的方言被标记为版本4。该协议，在RFC793中指定，^([[74](apb.html#ftn.CHP-9-BIB-1)])提供了一种以尽可能少的努力在广阔的距离和各种网络上传输数据的标准方法。IP数据包构成了之前讨论的OSI模型的第三层，包含一个包含将数据的一部分发送到其最终目的地——*远程端点*——所需信息的报头，以及紧随报头数据之后构建的更高层信息有效载荷。
- en: The routing information furnished by the sender within the IP packet prior to
    sending it out consists of the source and destination address and a set of parameters
    that simplifies the process of data transfer or improves its reliability and performance.
    When a machine on the local network wants to communicate with a remote party that
    is not directly reachable over the wire—at least not according to the host’s knowledge—it
    forwards an IP packet with the ultimate recipient’s destination address, encapsulated
    in a lower-layer frame addressed to a local machine that is believed to be a gateway
    to and of the network the sender resides at. The gateway machine is nothing more
    than a multihomed device—one that has a presence in more than one network, serving
    as a connection point between them. The gateway is expected to know how to route
    the packet to the outside world, what to do with the packet, and who should get
    the data next if there must be more parties involved before the data reaches the
    recipient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者在发送IP数据包之前在数据包内提供的路由信息包括源地址和目标地址以及一组简化数据传输过程或提高其可靠性和性能的参数。当本地网络上的计算机想要与一个通过网络无法直接到达的远程方进行通信——至少根据主机的知识是这样的——它将一个带有最终接收者目标地址的IP数据包转发出去，该数据包封装在一个指向本地机器的更低层帧中，该机器被认为是从发送者所在网络到外界的网关。网关机器不过是一个多宿主设备——它在多个网络中都有存在，作为它们之间的连接点。网关预计知道如何将数据包路由到外界，对数据包做什么，以及如果数据在到达接收者之前必须涉及更多方，下一个应该接收数据的人是谁。
- en: Systems involved in routing traffic, from the local gateway through to the destination
    network, read the information provided on the IP layer to decide how to relay
    the data farther down its path, based on their knowledge of how to reach certain
    networks. (In this context, a network is defined as a pool of network addresses
    residing at a specific location.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及路由流量的系统，从本地网关到目标网络，读取IP层提供的信息，以决定如何将数据进一步沿其路径中继，基于它们对如何到达某些网络的了解。（在这个上下文中，网络被定义为位于特定位置的地址池。）
- en: Naive Routing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天真的路由
- en: In its basic form, a router uses a fixed routing table with which it distinguishes
    between a set of local networks (to which it can deliver traffic directly) and
    the outside world, which is unknown. Thus, all traffic destined for outside the
    local network must be relayed to a higher-order router that presumably has a better
    idea of where to deliver the data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，路由器使用一个固定的路由表，通过它区分一组本地网络（它可以直接向其发送流量）和外界，后者是未知的。因此，所有目的地在本地网络之外的数据流量都必须被转发到一个更高阶的路由器，该路由器可能对数据发送的目的地有更好的了解。
- en: '[Figure 9-1](ch09.html#a_naive_wide_area_network_routing_scheme "Figure 9-1. A
    naive wide area network routing scheme") shows an example routing structure. The
    sender (shown at left) attempts to send a packet to a system whose address belongs
    to network C, a network that the sender knows nothing about. To facilitate delivery,
    the guy sends the traffic to the local gateway, hoping that it will know where
    to look for the recipient. However, this system, router 1, can only reach the
    sender’s own network and network A, another network that has nothing to do with
    C. Because the target is not on their local network, the router decides it would
    be best to just send the packet to a higher-rank WAN router (router 2), which
    it happens to be able to reach locally.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](ch09.html#a_naive_wide_area_network_routing_scheme "图9-1.一个简单的广域网路由方案")展示了示例路由结构。发送者（如图左侧所示）试图向一个地址属于网络C的系统发送数据包，而发送者对此一无所知。为了便于交付，这个人将流量发送到本地网关，希望它知道在哪里寻找接收者。然而，这个系统，即路由器1，只能到达发送者自己的网络和网络A，另一个与C无关的网络。因为目标不在它们的本地网络中，路由器决定最好是将数据包发送到更高等级的WAN路由器（路由器2），它恰好能够本地到达。'
- en: '![A naive wide area network routing scheme](httpatomoreillycomsourcenostarchimages1138052.png.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的广域网路由方案](httpatomoreillycomsourcenostarchimages1138052.png.jpg)'
- en: Figure 9-1. A naive wide area network routing scheme
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1.一个简单的广域网路由方案
- en: This device also has no immediate connection with network C; it can only directly
    reach hosts on networks B and D. However, it knows that router 3 is serving the
    destination address and thus would surely know what to do. Therefore, the packet
    is forwarded there, and router 3 can now deliver the traffic locally to the ultimate
    recipient, at which point all can rejoice and celebrate another success.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此设备与网络C没有直接连接；它只能直接到达网络B和D上的主机。然而，它知道路由器3正在服务目标地址，因此肯定知道该怎么做。因此，数据包被转发到那里，路由器3现在可以本地交付流量给最终接收者，此时所有人都可以欢欣鼓舞，庆祝另一个成功的实现。
- en: Routing in the Real World
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的路由
- en: In practice, networks are often highly redundant and do not have a strictly
    linear architecture. They have a complex treelike structure that makes selecting
    the optimal and most economical path difficult if we were to use a static configuration.
    (Never mind the challenge of staying up-to-date with all the infrastructure changes
    as the network grows.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，网络通常是高度冗余的，并且没有严格的线性架构。它们具有复杂的树状结构，如果我们使用静态配置，选择最优和最经济的路径将变得困难。（更不用说随着网络的扩展，保持所有基础设施变化同步的挑战了。）
- en: As such, a more reasonable routing strategy is implemented once the traffic
    reaches a *backbone router*. Run by a network operator, a backbone router is a
    dedicated WAN device that binds many networks controlled by a particular provider
    into a complex being called an *autonomous system*. Back-bone routers are typically
    equipped with interfaces to other large routers and use an advanced path-discovery
    algorithm and a sizable “phone book” of network blocks and their whereabouts,
    controlled dynamically by a Boundary Gateway Protocol, to find the best way to
    route the data to the destination system, without blindly handing out the job
    of delivering the traffic to some system in hopes that it will be able to relay
    it properly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦流量到达骨干路由器，就实施了一种更合理的路由策略。由网络运营商运营的骨干路由器是一种专用WAN设备，将特定提供商控制的多个网络绑定成一个称为自主系统的复杂实体。骨干路由器通常配备与其他大型路由器的接口，并使用高级路径发现算法和大量的“电话簿”式网络块及其位置信息，这些信息由边界网关协议动态控制，以找到将数据路由到目标系统的最佳路径，而不会盲目地将交付流量的任务交给某个系统，希望它能够正确中继。
- en: The Address Space
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址空间
- en: This process would, of course, be quite impractical if destination networks
    consisted simply of a set of addresses arbitrarily assigned to devices around
    the world. A definition of an autonomous system would have to list all the addresses
    and might easily grow to enormous size. To solve this problem, continuous blocks
    of address space are assigned to backbone service providers instead; providers
    later lease smaller blocks to end users or lesser service providers. Routing to
    the provider’s network is based on a lookup of the destination IP within the address
    ranges assigned to this entity and then within the network based on additional
    lookup in more detailed routing tables. An autonomous system can thus be defined
    as a range of IPv4 addresses (or a set of such ranges), using a netmask method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标网络仅由分配给世界各地设备的任意地址集组成，这个过程当然会非常不切实际。自治系统的定义将不得不列出所有地址，并且可能轻易地增长到巨大的规模。为了解决这个问题，连续的地址空间块被分配给骨干服务提供商；提供商随后将较小的块租给最终用户或较小的服务提供商。向提供商网络的路由基于在分配给该实体的地址范围内查找目标IP，然后在基于更详细的路由表的额外查找中基于该网络。因此，自治系统可以被定义为IPv4地址的范围（或一组这样的范围），使用子网掩码方法。
- en: The single IPv4 address used to uniquely identify an endpoint system in all
    Internet Protocol communications has a fairly simple structure, consisting of
    32 bits, divided for convenience into 4 bytes, a total of 4,294,967,296 possible
    addresses. The address is traditionally written as four 8-bit values between 0
    and 255, with each value separated by dots. For example, 195.117.3.59 corresponds
    to a 32-bit integer value of 3241036664.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在所有互联网协议通信中唯一标识端点系统的单个IPv4地址具有相当简单的结构，由32位组成，为了方便起见分为4个字节，共有4,294,967,296个可能的地址。地址传统上写作四个介于0到255之间的8位值，每个值之间用点分隔。例如，195.117.3.59对应于32位整数值3241036664。
- en: Continuous IP address blocks are the basis for packet routing. They are defined
    on top of IPv4 addressing by defining the part of the IP address that is fixed
    and constant for all systems belonging to an autonomous system, as well as the
    part of the address that will be set to various values by the owner of a network
    in order to give computers unique identifiers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 持续的IP地址块是数据包路由的基础。它们是在IPv4地址的基础上定义的，通过定义属于自治系统所有系统的IP地址中固定且恒定的部分，以及由网络所有者设置为各种值以赋予计算机唯一标识符的地址部分。
- en: When defining a network, a set of more significant bits of an IP—theoretically,
    anywhere from 1 to 31; practically, 8 to 24—is reserved as a *network address*.
    The fixed part of this address is shared by all addresses belonging to (and presumably
    routed to) this particular network. The less significant remainder bits can be
    set at will to assign addresses to systems within the network.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义网络时，IP地址的一组更高位——理论上从1到31位；实际上从8到24位——被保留作为*网络地址*。这个地址的固定部分为属于（并且可能路由到）这个特定网络的地址所共享。较低位的剩余位可以随意设置，以分配网络内系统的地址。
- en: Historically (per RFC796^([[75](apb.html#ftn.CHP-9-BIB-2)])), the size of a
    network or the number of significant locked bits was a function of the address
    and could be determined from the network address itself. Based on the most important
    bits of each address alone, addresses were grouped to constitute class A networks
    (in which the 8 most significant bits are fixed, yielding more than 16 million
    possible user addresses), class B networks (in which 16 bits are fixed, yielding
    more than 65,000 hosts), or class C networks (with 24 bits fixed, and 256 possible
    hosts). Therefore, if your system has an IP address beginning with the number
    1, you can tell that yours is a class A network and that all other systems with
    this prefix are next to your box.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上（根据RFC796^([[75](apb.html#ftn.CHP-9-BIB-2)]))，网络的大小或重要锁定位的数量是地址的函数，可以从网络地址本身确定。仅根据每个地址的最重要位，地址被分组构成A类网络（其中8个最高位是固定的，提供超过1600万个可能的用户地址）、B类网络（其中16位是固定的，提供超过65000个主机）或C类网络（24位固定，有256个可能的主机）。因此，如果你的系统IP地址以数字1开头，你可以判断你的系统是A类网络，并且所有具有此前缀的其他系统都紧挨着你的设备。
- en: Although this seemed handy at the time, the IPv4 address space shrank significantly
    once the initial implementers (the U.S. Army, Xerox, IBM, and other behemoths)
    were assigned a handful of class A network addresses in the early days of the
    Internet, and seemed not to be very keen on giving them up, despite not using
    even a fraction of the space they got for public infra-structure. Too, once the
    Internet became commercial, and IP addresses became a resource that users had
    to pay for, users demanded chunks of address space that would better fit their
    requirements; some folks only wanted four addresses, whereas others wanted a continuous
    space of 8,000\. Users began to resell or otherwise partition their Internet space.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当时这似乎很方便，但随着互联网的最初实施者（美国陆军、施乐、IBM和其他巨头）在互联网早期被分配了一小撮A类网络地址，并且似乎并不急于放弃它们，尽管他们甚至没有使用他们得到的公共基础设施空间的一小部分。此外，一旦互联网商业化，IP地址成为用户必须付费的资源，用户就要求更适合他们需求的地址空间块；有些人只需要四个地址，而其他人则需要连续的8000个地址。用户开始转售或以其他方式划分他们的互联网空间。
- en: The result is that the current address space is partitioned in bizarre ways,
    often with tiny bits of address space excluded and rerouted from larger, otherwise
    continuous blocks, with general disregard for the original partitioning scheme.
    Each network address is now accompanied by a net-mask specification, because it
    is no longer possible to tell which network a system is on based merely by the
    IP itself. The netmask has its bits set at positions that should be fixed in the
    network address and zeroed for positions that can be freely manipulated within
    a network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当前的地址空间以奇特的方式划分，通常排除了小块地址空间，并将它们从更大的、本应连续的块中重新路由，而对此原始划分方案不予考虑。现在，每个网络地址都伴随着一个子网掩码规范，因为仅凭IP本身已无法确定系统所在的网络。子网掩码的位被设置在应该在网络地址中固定的位置，并在可以自由操作于网络内的位置置零。
- en: As shown in [Figure 9-2](ch09.html#network_addressing_rules "Figure 9-2. Network
    addressing rules"), by fixing 24 bits on 195.117.3.0 network, we end up with 8
    trailing bits that can be changed. This allows us to create 256 addresses between
    195.117.3.0 and 195.117.3.255 that belong to this network (albeit some implementations
    would force the first and the last address to be reserved for special purposes,
    leaving only 254 possible hosts). With such a relatively simple specification
    of a network of addresses, it is easy to determine which addresses belong to this
    network and thus which should be delivered to a system that is its gateway (and
    which should not).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9-2](ch09.html#network_addressing_rules "图9-2. 网络寻址规则")所示，通过在195.117.3.0网络中固定24位，我们最终得到8位可变的尾端位。这使我们能够在195.117.3.0和195.117.3.255之间创建256个地址，这些地址属于此网络（尽管某些实现可能会强制保留第一个和最后一个地址用于特殊目的，从而只剩下254个可能的宿主）。通过这样相对简单的地址网络规范，很容易确定哪些地址属于此网络，因此哪些应该被发送到作为其网关的系统（以及哪些不应该）。
- en: 'Although this addressing scheme may appear confusing and needlessly complicated,
    it is successful: it lets us associate pools of addresses with specific systems
    and differentiate between systems with minimum computational effort. The Internet,
    in all its complexity, usually succeeds in finding a system in a really short
    period of time, without much maintenance.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种寻址方案可能看起来令人困惑且过于复杂，但它却取得了成功：它使我们能够将地址池与特定的系统关联起来，并以最小的计算努力区分系统。互联网在其所有复杂性中，通常能够在非常短的时间内找到系统，而无需太多维护。
- en: '![Network addressing rules](httpatomoreillycomsourcenostarchimages1138054.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![网络寻址规则](httpatomoreillycomsourcenostarchimages1138054.png.jpg)'
- en: Figure 9-2. Network addressing rules
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2. 网络寻址规则
- en: Fingerprints on the Envelope
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信封上的指纹
- en: We know how the data makes it from point A to point B—but what happens on the
    way is more interesting than how the path is determined. Let’s then look more
    closely at what is being exchanged between the routers and our endpoint systems.
    Although you might think that the actual data payload inside the packets sent
    over the Internet contains the most interesting information (considering all the
    private email and bizarre contents being exchanged around the world every second),
    there is more than meets the eye.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道数据是如何从A点传输到B点的——但沿途发生的事情比确定路径本身更有趣。那么，让我们更仔细地看看路由器与我们的端点系统之间交换的内容。尽管你可能认为在互联网上发送的包内的实际数据负载包含最有趣的信息（考虑到每秒钟都在全球范围内交换的私人电子邮件和奇怪的内容），但事实远不止如此。
- en: The format of IP packets used for routing the data, and the layer four information
    used to encapsulate the actual application-level data, is defined by the RFCs
    fairly strictly and with surprisingly little ambiguity. However, even with a competent
    TCP stack implementation, the underlying information can provide considerably
    and consistently more value to the recipient than the actual payload data it receives.
    The disclosure on this level is inadvertent and unexpected, but to learn more
    about it we need to take a closer look at the design of the underlying protocols.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用于路由数据的IP数据包格式和用于封装实际应用层数据的第四层信息，由RFCs相当严格且出人意料地没有歧义地定义。然而，即使有合格的TCP堆栈实现，底层信息也能为接收者提供相当多且一致的价值，比它实际接收到的有效载荷数据还要多。在这一层面上的披露是不经意的和意外的，但为了了解更多关于它，我们需要更仔细地查看底层协议的设计。
- en: Internet Protocol
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议
- en: First, the foundations. The Internet Protocol provides a universal long-distance
    delivery mechanism on the third layer of the OSI model. It contains a set of parameters
    that were meant to be interpreted and eventually modified by intermediate systems.
    The header is shown in [Figure 9-3](ch09s02.html#the_ip_header_structure "Figure 9-3. The
    IP header structure").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，基础。互联网协议在OSI模型的第三层提供了一个通用的长途传输机制。它包含一组参数，这些参数旨在被中间系统解释和最终修改。头部在[图9-3](ch09s02.html#the_ip_header_structure
    "图9-3. IP头部结构")中显示。
- en: '![The IP header structure](httpatomoreillycomsourcenostarchimages1138056.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![IP头结构](httpatomoreillycomsourcenostarchimages1138056.png.jpg)'
- en: Figure 9-3. The IP header structure
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3. IP头部结构
- en: Protocol Version
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议版本
- en: This is a four-bit value that is fixed to 4 (0100) in all IPv4 packets. IPv4
    is the standard (and, in many cases, the only supported) layer three protocol
    over the Internet. Attempts to move toward a more advanced implementation, IPv6,
    have not been particularly successful so far—the author is willing to speculate
    this is perhaps because the new, extended IP address format is much more difficult
    for a typical system administrator to memorize.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个固定为4（0100）的四位值，在所有IPv4数据包中都是如此。IPv4是互联网上的标准（并且在许多情况下，是唯一支持的）三层协议。向更高级的实现，IPv6，迈进的努力到目前为止并不特别成功——作者愿意猜测这可能是因为新的、扩展的IP地址格式对典型的系统管理员来说要难以记住。
- en: The Header Length Field
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部长度字段
- en: This is a four-bit value that specifies the total length of the IP header itself,
    expressed as a count of 4-byte blocks (making it possible to express lengths from
    0 to 60 bytes using the 16 values of field). This parameter tells the implementation
    where to stop parsing the IP header (which may have a variable length due to extra
    “options” that can be appended at the end of the header and immediately before
    any higher layer contents). It also makes it possible to skip some of the IP header
    without having to look at the options or understand them completely, and go directly
    to the data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个四位的值，用于指定IP头本身的长度总和，以4字节块的数量表示（这使得可以使用字段中的16个值来表示从0到60字节的长度）。此参数告诉实现程序在哪里停止解析IP头（由于可以在头部末尾附加额外的“选项”，并且紧接在更高层内容之前，IP头的长度可能是可变的）。它还使得在不查看选项或完全理解它们的情况下跳过IP头的一部分成为可能，并直接跳到数据部分。
- en: Because IP options aren’t commonly used for anything other than diagnostics
    (they do things like make it possible to force a particular packet route and not
    much more), almost all IP packets seen in the wild are 20 bytes long (meaning
    this field is set to 5), which is the length of the fixed part of the header.
    Values less than 20 are, naturally, erroneous, and such a packet is not honored
    by a sane implementation. (Sanity, however, is not a rule of thumb.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP选项通常不用于除诊断之外的其他任何目的（它们可以做到像强制特定的数据包路由这样的功能，但不多），在野外观察到的几乎所有IP数据包都是20字节长（这意味着此字段设置为5），这是头部固定部分的长度。小于20的值自然是错误的，这样的数据包不会被理智的实现所认可。（然而，理智并不是一个规则。）
- en: The Type of Service Field (Eight Bits)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型字段（八位）
- en: The significance of this field is usually fairly marginal. It provides an honor-based
    routing priority description in which the sender is trusted to act in good faith
    and allowed to specify whether this traffic is of particular importance or otherwise
    requires special treatment. This value is sometimes used in local installations,
    where this level of trust can be exercised, but it is often ignored over the open
    Internet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该领域的意义通常相当边缘化。它提供了一个基于荣誉的路由优先级描述，其中发送者被信任以诚信行事，并允许指定此流量是否特别重要或需要特殊处理。此值有时用于本地安装中，在这些安装中可以行使这种信任水平，但在开放的互联网上通常被忽略。
- en: 'This field consists of three segments:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段由三个部分组成：
- en: The first three bits specify the priority.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三位指定优先级。
- en: The next four denote the desired routing method (using abstract concepts such
    as “high reliability” or “low latency” and letting the router interpret this).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的四个表示所需的路由方法（使用诸如“高可靠性”或“低延迟”等抽象概念，并让路由器进行解释）。
- en: The last part, a single bit, is reserved and shall be set to 0 (yeah, right).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的部分，一个单独的位，是保留的，应当设置为0（是的，没错）。
- en: The Total Packet Length (16 Bits)
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总包长度（16位）
- en: This 2-byte field specifies the total length of this IP packet, including its
    payload. Although the highest possible value is 65,535, the maximum size of a
    packet is often limited to a much smaller value by the restraints of the lower-level
    protocol. For example, Ethernet has a maximum transmission unit (MTU) of 1,500
    bytes; as such, a system connected to Ethernet will not send packets larger than
    this limit. MTUs greater than approximately 16 to 18 kilobytes are practically
    unheard of; values between 576 and 1,500 bytes are the most common.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个2字节字段指定了此IP数据包的总长度，包括其有效载荷。尽管可能的最大值是65,535，但数据包的最大大小通常由底层协议的限制限制在一个更小的值。例如，以太网的最大传输单元（MTU）为1,500字节；因此，连接到以太网的系统不会发送超过此限制的数据包。超过大约16到18千字节MTU的情况实际上很少见；576到1,500字节之间的值是最常见的。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Fun fact: The size limit of an IP packet, N bytes (resulting of the MTU parameter),
    also imposes the minimum bandwidth overhead limit for any IP traffic: there will
    always be at least 20 bytes of header added per N-20 bytes to be sent on a higher
    level.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：IP数据包的大小限制，N字节（由MTU参数产生），也强加了任何IP流量的最小带宽开销限制：在更高层发送的N-20字节数据中，将始终至少添加20字节的头部。
- en: The Source Address
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源地址
- en: This 32-bit value—an IP address in the format discussed in the previous section—should
    represent the originating endpoint of the communications. Because the IP packet
    is prepared by the sender, and there is very little incentive for anyone to check
    the correctness of this parameter at the perimeter of the originating network,
    this value alone cannot really be trusted. It does provide a good hint as to who
    to talk back to, though—and if we have a reason to trust this hint, we can use
    it to talk back to the sender. The act of forging this value intentionally is
    commonly referred to as *IP spoofing*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个32位值——一个格式如前所述的IP地址——应该代表通信的起始端点。因为IP数据包是由发送者准备的，而且几乎没有动力让任何人在起始网络的边缘检查此参数的正确性，因此这个值本身并不能真正被信任。尽管如此，它确实提供了一个很好的线索，告诉我们应该与谁进行通信——如果我们有理由信任这个线索，我们可以用它来与发送者进行通信。故意伪造此值的行为通常被称为*IP欺骗*。
- en: The Destination Address
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的地址
- en: This 32-bit value specifies the ultimate destination of the traffic. Like all
    other IP parameters, it is chosen at the sender’s discretion and used by intermediate
    systems to direct the packet appropriately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个32位值指定了流量的最终目的地。像所有其他IP参数一样，它由发送者自行选择，并由中间系统用来适当地引导数据包。
- en: The Fourth Layer Protocol Identifier
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四层协议标识符
- en: This is an eight-bit value that specifies what is carried as a payload of the
    IP packet—TCP, UDP, ICMP, or more exotic options we will talk about in more detail
    in a moment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个8位值，指定了IP数据包的有效载荷中携带的内容——TCP、UDP、ICMP或我们将在稍后更详细讨论的更奇特选项。
- en: Time to Live (TTL)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存活时间（TTL）
- en: TTL is an eight-bit “kill counter” for IP traffic. To avoid endless loops when
    something goes horribly awry with routing tables, the counter is decreased by
    one every time it passes an interim system, or stays in the transmit queue for
    a period of time. When the counter reaches zero, the packet is discarded, and
    the sender may be mercifully notified via an ICMP packet. The TTL value, like
    all others, is chosen at the sender’s discretion, but, by virtue of its bit width,
    cannot be more than 255.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TTL 是一个用于 IP 流量的 8 位“终止计数器”。为了避免路由表出现严重问题时陷入无限循环，每当它通过一个中间系统或停留在传输队列中一段时间，计数器就会减一。当计数器达到零时，数据包就会被丢弃，发送者可能会通过一个
    ICMP 数据包得到通知。TTL 值，像所有其它值一样，由发送者自行选择，但由于其位宽，不能超过 255。
- en: 'An interesting side effect of the TTL counter is that it can be used to map
    the route to a remote system: A message with a TTL of 1 expires on the first router
    it encounters on its way to the specified destination (and the sender receives
    an ICMP message from the router); a message with TTL set to 2 expires on the next
    hop, and so on. By sending packets with gradually increasing TTLs and monitoring
    the origin of ICMP “time-to-live exceeded” responses, it is possible to map the
    set of routers and other IP-enabled devices en route to the destination. The technique
    is called *traceroute* and is a common method for diagnosing routing problems
    and performing preattack analysis.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TTL 计数器的有趣副作用是它可以用来绘制远程系统的路由图：一个 TTL 值为 1 的消息在其前往指定目的地途中遇到的第一台路由器上就会过期（并且发送者会收到来自路由器的
    ICMP 消息）；一个 TTL 设置为 2 的消息会在下一个跳转点过期，依此类推。通过发送逐渐增加 TTL 值的数据包并监控 ICMP “生存时间超时”响应的来源，可以绘制出前往目的地的路由器和其它
    IP 兼容设备的集合。这种技术被称为 *traceroute*，是诊断路由问题以及进行攻击前分析的一种常用方法。
- en: 'The usefulness to the attacker lies in the fact that some effects can be achieved
    without actually compromising the intended victim: to compromise [www.microsoft.com](http://www.microsoft.com)
    you might instead target the router of the network that hosts this server, or
    routers of their ISPs, hoping to intercept all its traffic and return forged responses.
    This would effectively cut off the actual server and, by impersonating it, make
    it appear to the outside world as if the site at [www.microsoft.com](http://www.microsoft.com)
    had been changed. Naturally, this is just an example.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对攻击者来说，有用之处在于，可以在不实际损害目标受害者的情况下实现某些效果：要损害 [www.microsoft.com](http://www.microsoft.com)，你可能会选择攻击托管此服务器的网络的路由器，或者他们的
    ISP 的路由器，希望拦截所有流量并返回伪造的响应。这将有效地切断实际服务器，并通过伪装，使外界看起来像 [www.microsoft.com](http://www.microsoft.com)
    网站已被更改。当然，这只是一个例子。
- en: Flags and Offset Parameters
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志和偏移参数
- en: These 16-bit values control an interesting—and perhaps most flawed—aspect of
    IP packet routing. These parameters are used whenever a large packet must be forwarded
    by an intermediate system over a link with an MTU lower than the size of the packet.
    In such a case, the packet does not “fit” into the medium as is.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 16 位值控制着 IP 数据包路由的一个有趣——也许是最有缺陷——方面。当一个大数据包必须通过一个中间系统在 MTU 小于数据包大小的链路上转发时，会使用这些参数。在这种情况下，数据包不会以原样“适应”介质。
- en: 'As an arbitrary example, a sender connected to Ethernet can send a packet up
    to 1,500 bytes in size and often will do so. However, if the first router the
    packet hits bridges the local LAN with a DSL modem, a problem arises: A common
    MTU for a DSL link (itself usually a bizarre combination of encapsulations over
    other protocols) is 1,492\. As such, a 1,500-byte packet will simply not fit.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个任意为例，一个连接到以太网的发送者可以发送大小最多为 1,500 字节的数据包，通常也会这样做。然而，如果一个数据包遇到的第一台路由器将本地局域网与
    DSL 调制解调器桥接，就会出现问题：DSL 链路的一个常见 MTU（它本身通常是一个在其他协议封装上的奇怪组合）是 1,492。因此，一个 1,500 字节的数据包将无法适应。
- en: Given the large variety of links that make the Internet work, this is a serious
    problem. It is dealt with by splitting *(fragmenting)* the IP packet or, more
    precisely, its payload into several separate IP packets and adding information
    that makes it possible for the recipient to reassemble the payload before passing
    it to higher layers. The result is a new set of packets that fit over this particular
    link. An offset specified on each fragment indicates how each part of the payload
    should be inserted when the ultimate recipient attempts to reassemble the original
    packet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到构成互联网的链接种类繁多，这是一个严重的问题。它通过将IP包或更确切地说，其有效负载分成几个独立的IP包，并添加使接收者能够在将其传递到更高层之前重新组装有效负载的信息来解决。结果是形成了一组适合该特定链路的新包。每个分片上指定的偏移量指示当最终接收者尝试重新组装原始包时，每个有效负载部分应该如何插入。
- en: All fragments but the last also have a special more fragments (MF) flag set
    in their headers. When the destination system receives a packet with an MF flag,
    or a packet with chunk offset set but no MF flag (which indicates the last chunk
    of a split packet), the destination system knows to allocate a scratch memory
    area to facilitate the reassembly of the original packet and to wait for all other
    remaining chunks before processing the packet any further.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一个分片之外，所有分片在其头部都设置了特殊的更多分片（MF）标志。当目标系统接收到一个带有MF标志的包，或者一个设置了块偏移但没有MF标志的包（这表示分割包的最后一个块）时，目标系统就知道需要分配一个临时内存区域来促进原始包的重新组装，并在处理包之前等待所有其他剩余的块。
- en: '[Figure 9-4](ch09s02.html#the_packet_fragmentation_and_reassembly "Figure 9-4. The
    packet fragmentation and reassembly process") shows the process of fragmentation
    and reassembly, in which an oversized packet is first split into two chunks and
    then completely reassembled by the recipient, despite chunks arriving out of order.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-4](ch09s02.html#the_packet_fragmentation_and_reassembly "图9-4. 数据包分片和重组过程")展示了分片和重组的过程，其中一个大包首先被分成两个块，然后由接收者完全重新组装，尽管块是按顺序到达的。'
- en: Although this process works, it is somewhat inefficient. It takes time for the
    systems to fragment and reassemble the traffic, and the trailing chunks often
    carry little payload—only the few bytes that do not fit over a different type
    of a link. It is better, of course, for the sender to be able to determine the
    lowest MTU between their location and the destination (also called path MTU, or
    PMTU for short) and construct their packets accordingly. Unfortunately, IP does
    not offer a flexible and clean way to implement this, but this has not stopped
    researchers from coming up with a clever hack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个过程是可行的，但它有些低效。系统需要时间来分片和重组流量，并且尾部块通常携带很少的有效负载——只有那些不适合通过不同类型链路的几个字节。当然，如果发送者能够确定它们的位置和目的地之间的最低MTU（也称为路径MTU或简称PMTU）并据此构建它们的包，那就更好了。不幸的是，IP并没有提供一种灵活且干净的方式来实施这一点，但这并没有阻止研究人员想出一种巧妙的解决方案。
- en: According to this hack, a system that implements PMTU discovery sets a special
    flag, DF (don’t fragment), on all outgoing traffic. If a router cannot forward
    a DF packet without fragmenting it, it should drop it instead and send an appropriate
    ICMP message that reads “fragmentation required, but DF set.” The sender, upon
    receipt of such a message, can adjust their expectations accordingly, cache the
    finding, and continue with more appropriate packet sizes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个解决方案，实现PMTU发现的系统会在所有发出的流量上设置一个特殊的标志，DF（不要分片）。如果一个路由器无法在不分片的情况下转发DF包，它应该将其丢弃，并发送一个适当的ICMP消息，内容为“需要分片，但设置了DF”。发送者在收到这样的消息后，可以相应地调整他们的期望，缓存这个发现，并继续使用更合适的包大小。
- en: '![The packet fragmentation and reassembly process](httpatomoreillycomsourcenostarchimages1138058.png.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![数据包分片和重组过程](httpatomoreillycomsourcenostarchimages1138058.png.jpg)'
- en: Figure 9-4. The packet fragmentation and reassembly process
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4. 数据包分片和重组过程
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This practice, specified in RFC1191,^([[76](apb.html#ftn.CHP-9-BIB-3)]) assumes
    that the single expense of resending the dropped packet is better than the constant
    performance loss caused by the need for fragmentation. The technique, however,
    is also quite controversial, because not all devices send proper ICMP notifications
    and, historically, there was no such requirement. Hence, enabling PMTUD (PMTU
    discovery) can result in a sender being unable to talk to some sites or in stalled
    file transfers that are extremely difficult to diagnose.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法，在RFC1191中指定，^([[76](apb.html#ftn.CHP-9-BIB-3)])认为重新发送丢失的数据包的单次开销比由于需要分片而造成的持续性能损失更好。然而，这项技术也相当有争议，因为并非所有设备都发送适当的ICMP通知，并且从历史上看，没有这样的要求。因此，启用PMTUD（PMTU发现）可能导致发送者无法与某些站点通信，或者导致停滞不前的文件传输，这些文件传输非常难以诊断。
- en: Identification Number
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别号
- en: The identification number (ID) is a 16-bit value that differentiates IP packets
    when fragmentation occurs. Without IP IDs, if two packets are fragmented at once,
    reassembly would severely mangle, interchange, or otherwise damage fragments of
    two packets that were fragmented simultaneously.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 识别号（ID）是一个16位值，当发生分片时用于区分IP数据包。如果没有IP IDs，如果两个数据包同时分片，重组将严重扭曲、交换或以其他方式损坏同时分片的两个数据包的片段。
- en: IP IDs uniquely identify several reassembly buffers for different packets. The
    value used for this purpose is often chosen simply by incrementing a counter with
    every packet sent; the first packet sent by a system has an IP ID of 0, the second
    an Internet Protocol of ID 1, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IP IDs唯一标识了不同数据包的几个重组缓冲区。用于此目的的值通常简单地通过每发送一个数据包就递增一个计数器来选择；系统发送的第一个数据包的IP ID为0，第二个为ID
    1，依此类推。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On systems with PMTUD enabled, unique IPIDs are not needed, because in theory
    fragmentation does not occur, and the value is often set to 0 (although, arguably,
    not particularly wisely, because some fairly popular devices tend to ignore the
    DF flag).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用PMTUD的系统上，不需要唯一的IPIDs，因为在理论上不会发生分片，该值通常设置为0（尽管，可以说，并不特别明智，因为一些相当流行的设备倾向于忽略DF标志）。
- en: Checksum
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 校验和
- en: The checksum is a 16-bit number that provides a trivial error detection method.
    The checksum must be recomputed on every hop (because parameters such as TTL change)
    and is thus designed to use a fast algorithm, which is not particularly reliable.
    Although in today’s world, “checksum” is a sum only by name (using algorithms
    such as CRC32 or cryptographically safe shortcut functions), the IP checksum is
    in fact a sum, or a variant thereof, with a couple of bitwise negations^([[15](#ftn.CHP-9-FN-1)])
    thrown in to confuse opponents (and, on a more serious note, to make it less likely
    for checksum to remain correct when common transmission errors occur).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和是一个16位数字，提供了一种简单的错误检测方法。校验和必须在每个跳数上重新计算（因为如TTL之类的参数会发生变化），因此设计为使用快速算法，这并不特别可靠。尽管在当今世界，“校验和”只是名称上的总和（使用如CRC32或密码学安全的快捷函数之类的算法），但IP校验和实际上是一个总和，或其变体，其中加入了一些位取反操作^([[15](#ftn.CHP-9-FN-1)])以混淆对手（并且，更严重的是，在常见的传输错误发生时，使校验和保持正确性更不可能）。
- en: '* * *'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](#CHP-9-FN-1)]) Technically speaking, although it bears no particular
    importance for the discussion, IP check-sum is based on 16-bit 1’s complement
    of a sum of 1’s complements of the checksummed data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#CHP-9-FN-1)]) 从技术上来说，尽管它对讨论没有特别的重要性，IP校验和是基于校验和数据的1的补码的总和的16位1的补码。
- en: Beyond Internet Protocol
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议之外
- en: One consequence of many of the design decisions made when devising IPv4 is the
    lack of a reasonable reliability guarantee, even if the network itself is behaving
    reliably. Although IP ID numbers are intended to minimize the risk of reassembly
    collisions, their relatively small 16-bit size (which allows for 65,536 possible
    values) permits problems to arise occasionally when two packets with identical
    IP IDs are reassembled at the same time. Also, IP header checksums are simply
    insufficient to provide reliable integrity protection; although unlikely, a random
    change in a packet could still give an identical checksum. Too, if the network
    actually failed, there is no way to find out what data has gone missing, even
    if the failure is due to something as straightforward as a brief overload of a
    single network component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计IPv4时做出的许多设计决策的一个后果是，即使网络本身运行可靠，也无法提供合理的可靠性保证。尽管IP ID号码旨在最小化重组冲突的风险，但它们相对较小的16位大小（允许65,536个可能的值）使得当两个具有相同IP
    ID的数据包同时重组时，偶尔会出现问题。此外，IP头部校验和不足以提供可靠的完整性保护；尽管不太可能，但数据包中随机的变化仍然可能给出相同的校验和。同样，如果网络实际上失败了，也没有办法找出哪些数据丢失了，即使失败的原因是单个网络组件短暂的过载这样简单的原因。
- en: Finally, the Internet Protocol does not provide any way to verify the sender
    of a message, simply trusting that the real sender is the one listed in the IP
    header. It is left to higher-level protocols to provide some of the integrity
    and reliability assurance functionality as necessary—and more often than not,
    this is necessary. As such, higher-level protocols on top of IP are needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，互联网协议不提供任何验证消息发送者的方式，只是简单地相信真正的发送者是IP头部中列出的那个人。这留给了更高层的协议在必要时提供一些完整性和可靠性保证功能——而且通常情况下，这是必要的。因此，需要IP之上的更高层协议。
- en: TCP, and to a lesser extent, UDP, not only provide much-needed protection for
    traffic, but also enable the user to specify the recipient (or sender) on a level
    beyond pointing at a certain system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TCP，以及在一定程度上UDP，不仅为流量提供了必要的保护，还使用户能够在比指向某个特定系统更高的层面上指定接收者（或发送者）。
- en: 'Whereas the IP header simply contains enough information to route traffic between
    two systems, and not enough to decide to which application the information should
    be delivered, UDP and TCP take things a step further: they move in the realm of
    the endpoint system, telling the recipient to which application they should direct
    incoming data.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与IP头部仅包含足够的信息来在两个系统之间路由流量，但不足以决定信息应该发送到哪个应用程序相比，UDP和TCP更进一步：它们进入了端点系统的领域，告诉接收者应该将传入的数据发送到哪个应用程序。
- en: User Datagram Protocol
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: As defined in RFC768,^([[77](apb.html#ftn.CHP-9-BIB-4)]) UDP provides a minimal
    superset of IP functionality. UDP adds a mechanism for the local delivery of data,
    but keeps close to the level of unreliability of the underlying layer (as well
    as its low overhead). The use of UDP for communications can be likened to a phone
    service in which words sometimes get swapped or are dropped out of sentences,
    and there is no reliable caller ID—but the cost of a call is low, and your calls
    are answered quickly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如RFC768所定义，^([[77](apb.html#ftn.CHP-9-BIB-4)]) UDP提供了IP功能的最小超集。UDP添加了本地交付数据的机制，但仍然接近底层的不可靠性水平（以及其低开销）。使用UDP进行通信可以比作一种电话服务，其中有时单词会被交换或从句子中删除，而且没有可靠的来电显示——但通话成本低，而且你的电话会被迅速接听。
- en: The UDP header ([Figure 9-5](ch09s04.html#the_udp_header_structure "Figure 9-5. The
    UDP header structure")) has a minimal set of features and is relatively simple.
    It introduces a small set of parameters that can be interpreted by the destination
    system and used to route a packet to a specific application or to verify that
    packet payload was not mangled down the road.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头部([图9-5](ch09s04.html#the_udp_header_structure "图9-5. UDP头部结构"))具有最小的一组功能，相对简单。它引入了一组可以由目标系统解释的参数，并可用于将数据包路由到特定的应用程序或验证数据包有效载荷在传输过程中没有被破坏。
- en: '![The UDP header structure](httpatomoreillycomsourcenostarchimages1138060.png.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![UDP头部结构](httpatomoreillycomsourcenostarchimages1138060.png.jpg)'
- en: Figure 9-5. The UDP header structure
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5. UDP头部结构
- en: UDP is used for single queries, in other situations in which maintaining state
    information is unnecessary, and when performance and low overhead are more important
    than reliability. For example, UDP is commonly used for domain name system (DNS)
    name resolution, trivial network boot and autoconfiguration protocols (BOOTP),
    streaming media technologies, network file system sharing, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: UDP用于单次查询，在其他不需要维护状态信息的情况下，以及当性能和低开销比可靠性更重要时。例如，UDP通常用于域名系统（DNS）名称解析、简单的网络引导和自动配置协议（BOOTP）、流媒体技术、网络文件系统共享等。
- en: Introduction to Port Addressing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口寻址简介
- en: UDP introduces the notion of source and destination ports in addition to source
    and destination addresses, a concept that it shares with TCP (a more advanced
    layer four protocol that I will cover next). A *port* is a certain 16-bit number,
    either chosen by an endpoint application willing to send or receive data or assigned
    to it by the operating system (called an *ephemeral port*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UDP引入了源端口和目的端口的概念，除了源地址和目的地址之外，它与TCP（一个更高级的四层协议，我将在下一章介绍）共享这一概念。*端口*是一个特定的16位数字，要么由愿意发送或接收数据的端点应用程序选择，要么由操作系统分配给它（称为*临时端口*）。
- en: A port serves as a means to route data to a specific application or service
    on a multitasking system so that simultaneous communications can occur between
    programs. For example, a name server process can decide to listen on port 53 for
    incoming queries, whereas a system logger facility can listen to traffic addressed
    to port 514\. Ports make it possible for clients to talk to these processes at
    the same time. Too, when the implementation supports a proper separation of source
    and destination port pairs, it is possible for two clients using different ephemeral
    source ports to talk to the same service (say, port 514) at once, without causing
    major confusion as to which client application should get which response from
    the remote service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '端口作为将数据路由到多任务系统上的特定应用程序或服务的一种手段，以便程序之间可以发生同时通信。例如，一个名称服务器进程可以决定在端口53上监听传入的查询，而一个系统日志服务可以监听指向端口514的流量。端口使得客户端可以同时与这些进程进行通信。此外，当实现支持适当的源端口和目的端口对的分离时，使用不同临时源端口的两个客户端可以同时与同一服务（例如，端口514）通信，而不会造成关于哪个客户端应用程序应该从远程服务获得哪个响应的混淆。 '
- en: In order for the destination system to differentiate between communications
    addressed to a particular application and deliver them as expected, the sender
    must specify the destination port number in all their traffic. The sender specifies
    a different source port for every client application so that once the server replies,
    the answer is delivered to the correct component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使目的系统能够区分针对特定应用程序的通信并将其按预期交付，发送者必须在所有流量中指定目的端口号。发送者为每个客户端应用程序指定不同的源端口，以便一旦服务器回复，答案就会发送到正确的组件。
- en: In this port addressing scheme, a quadruplet of values—source host, source port,
    destination host, and destination port—is used to ensure proper traffic separation
    and session management for simultaneous connections originating or terminating
    at a specific system. The design means that as many as 65,535^([[16](#ftn.CHP-9-FN-2)])
    clients from a single IP address can connect to the outside world and that no
    more than 65,535 services can listen on a single IP address at any one time; that
    is, without some clever hacks. (We are not likely to suffer terrible consequences
    of this limitation any time soon.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种端口寻址方案中，使用四个值——源主机、源端口、目的主机和目的端口——以确保在特定系统上同时发起或终止的连接能够正确地进行流量分离和会话管理。这种设计意味着单个IP地址最多可以有65,535个客户端连接到外部世界，并且任何时刻最多只能有65,535个服务监听单个IP地址；也就是说，没有一些巧妙的黑客手段的话。（我们不太可能很快就会遭受这种限制带来的严重后果。）
- en: UDP Header Summary
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP头部摘要
- en: 'The UDP header shown in [Figure 9-5](ch09s04.html#the_udp_header_structure
    "Figure 9-5. The UDP header structure") earlier follows the IP header and precedes
    the actual user-space data in UDP packets. It consists of few fields: source and
    destination ports (16 bits each), packet length, and a 16-bit checksum for the
    purpose of additional integrity verification.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在[图9-5](ch09s04.html#the_udp_header_structure "图9-5. UDP头部结构")中显示的UDP头部遵循IP头部，并位于UDP数据包中的实际用户空间数据之前。它包含少量字段：源端口和目的端口（每个16位），数据包长度，以及一个16位的校验和，用于额外的完整性验证。
- en: And now, for something completely different, it’s . . .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来点完全不同的内容，是……
- en: '* * *'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[16](#CHP-9-FN-2)]) Technically, that’s 65,536; port number 0 should not
    be used, however. The operating system and its applications may allow this, naturally,
    and be in violation of the standard.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#CHP-9-FN-2)]) 技术上，这是65,536；然而，端口号0不应被使用。操作系统及其应用程序自然可能允许这样做，但这可能违反了标准。
- en: Transmission Control Protocol Packets
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输控制协议数据包
- en: TCP (RFC793^([[78](apb.html#ftn.CHP-9-BIB-5)])), the header of which is shown
    in [Figure 9-6](ch09s05.html#the_tcp_header_structure "Figure 9-6. The TCP header
    structure"), aims to provide a reliable, stream-based method for establishing
    a meaningful conversation between two systems. TCP is more suitable than UDP for
    use with all applications except those that must exchange more than simple, short
    messages and single shouts.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TCP（RFC793^([[78](apb.html#ftn.CHP-9-BIB-5)]))，其头部结构如图[图9-6](ch09s05.html#the_tcp_header_structure
    "图9-6. TCP头部结构")所示，旨在提供一种可靠、基于流的通信方法，以在两个系统之间建立有意义的对话。TCP比UDP更适合用于所有应用程序，除了那些必须交换比简单、短消息和单个呼喊更多的应用程序。
- en: Although technically implemented using separate IP datagrams traversing the
    network, the established TCP connection—a virtual channel, from an application’s
    perspective—allows for a communications mode much like a regular phone conversation.
    Unlike with UDP traffic, when using TCP you can be sure that the recipient always
    receives the data as sent (or that, if error recovery is not possible, the conversation
    is dropped entirely). Under normal conditions, you can also be sure of the caller’s
    identity, but this convenience comes at a higher price and with lower performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上是通过在网络中穿越的单独的IP数据报实现的，但已建立的TCP连接——从应用程序的角度来看是一个虚拟通道——允许通信模式类似于常规的电话对话。与UDP流量不同，使用TCP时，你可以确信接收方总是以发送的方式接收数据（或者如果错误恢复不可能，整个对话将被丢弃）。在正常情况下，你也可以确信呼叫者的身份，但这种便利性是以更高的成本和较低的性能为代价的。
- en: '![The TCP header structure](httpatomoreillycomsourcenostarchimages1138062.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![TCP头部结构](httpatomoreillycomsourcenostarchimages1138062.png.jpg)'
- en: Figure 9-6. The TCP header structure
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6. TCP头部结构
- en: In TCP, two endpoints first initiate a connection using a so-called three-way
    handshake algorithm. Using special, as a general rule, empty packets (ones with
    only headers and no actual data payload), the parties agree on the intent, confirm
    each other’s identity, and agree on initial sequence and acknowledgment numbers.
    These numbers (a set of 32-bit values) ensure reliable and seamless transmission
    because they are increased as the data is sent. This, in turn, allows the recipient
    to queue incoming packets in the correct order and to determine whether any portion
    of the data is missing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP协议中，两个端点首先使用所谓的三次握手算法建立一个连接。通常情况下，使用特殊的空包（只有头部没有实际数据负载的包），双方就意图达成一致，确认彼此的身份，并就初始序列号和确认号达成一致。这些数字（一组32位值）确保了可靠且无缝的传输，因为随着数据的发送，这些数字会递增。这反过来又允许接收方按正确顺序排队等待接收到的数据包，并确定数据中是否有任何部分缺失。
- en: 'Control Flags: The TCP Handshake'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制标志：TCP握手
- en: A TCP session begins when a remote system expresses a desire to connect to a
    specific port on a destination machine. The remote system sends the destination
    an empty packet with a SYN flag (meaning a designated bit is set in the header)
    and an initial sequence number set in the headers. Following receipt of this packet,
    any response to a packet must quote the sequence number in order to be honored.
    If the destination machine does not send the correct response in a reasonable
    time frame, the packet is sent again, until either the delivery succeeds or the
    sender concludes that enough time has passed and drops the connection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个远程系统表达出连接到目标机器上特定端口的愿望时，TCP会话就开始了。远程系统向目标发送一个带有SYN标志（意味着在头部设置了指定的位）和设置在头部中的初始序列号的空包。在接收到这个包之后，任何对包的响应都必须引用序列号才能得到认可。如果目标机器在合理的时间内没有发送正确的响应，该包将被重新发送，直到交付成功或发送方认为已经过去了足够的时间并断开连接。
- en: The sequence number ensures that the response to the packet is from the actual
    recipient, not from an outsider who knows that a communication will be occurring
    and who intends to capture it. The sequence number also ensures that the response
    is not a lost, misguided packet from a previous session that finally made its
    way home, but a response to this particular request from the sender. (With 32-bit
    numbers and 4,294,967,296 possible values, the likelihood of a collision is considerably
    less than with 16 bits used in IP IDs, making both an accidental mishap and a
    successful guess by an outsider quite unlikely.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号确保对数据包的响应来自实际的接收方，而不是一个知道将要发生通信并打算捕获它的外部人员。序列号还确保响应不是一个丢失的、误导的、来自之前会话的数据包，它最终回到了这里，而是对发送方这个特定请求的响应。（使用32位数字和4,294,967,296个可能的值，碰撞的可能性远小于在IP
    ID中使用的16位，使得意外事故和外部人员的成功猜测都极不可能。）
- en: The recipient is expected to respond to a SYN request with a similar packet
    addressed to the sender and source port they used. This packet should have an
    RST flag set (again, another bit in the headers) to indicate that they are not
    willing to establish a session. (No program is ready to answer connections on
    this endpoint.) This packet must also quote the original sequence number along
    with the response. Alternatively, in the unusual case that the recipient is actually
    willing to establish a connection and chat with the stranger, they should reply
    with a similarly constructed response, but with both SYN and ACK flags set, indicating
    acceptance of the request. They should also include the sequence number they expect
    from now on in all responses pertaining to this session.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 预期接收方会对一个SYN请求用一个类似的、针对发送方和所使用的源端口的包进行响应。这个包应该设置RST标志（再次，头部中的另一个位）来表示他们不愿意建立会话。（没有程序准备好在这个端点上回答连接。）这个包还必须引用原始序列号以及响应。或者，在不太可能的情况下，如果接收方实际上愿意建立连接并与陌生人聊天，他们应该用一个类似的结构进行响应，但设置SYN和ACK标志，表示接受请求。他们还应该包括他们期望在所有与这个会话相关的响应中使用的序列号。
- en: As the last part of the handshake, the sender exchanges a single ACK packet
    just to make sure that both parties know each other’s sequence and acknowledgment
    numbers exchanged earlier, and that they are on the same page in regard to the
    transaction. Assuming that their communication has reached this point, both endpoints
    can assume, with reasonable certainty, that both sender and receiver are who they
    claim to be. Why? Because each can observe the traffic addressed to their address.
    Otherwise, if one endpoint were just spoofing its IP address to establish a bogus
    connection in the name of somebody else, it would have no idea what number to
    include in its response to the other party. (And the other party would be quite
    surprised to find someone attempting to send them unsolicited SYN+ACK or ACK packets.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为握手的最后一部分，发送方交换一个单独的ACK数据包，只是为了确保双方都知道之前交换的序列号和确认号，并且他们在交易方面处于同一页面上。假设他们的通信已经达到这一点，两个端点可以合理地假设发送方和接收方都是他们所声称的身份。为什么？因为每个都可以观察到发送到其地址的流量。否则，如果有一个端点只是伪造其IP地址，以他人的名义建立虚假连接，它将不知道在对其另一方的响应中包含什么数字。（并且另一方会对有人试图发送未经请求的SYN+ACK或ACK数据包感到非常惊讶。）
- en: This handshake protocol eliminates the chance of an outsider simply spoofing
    the traffic, but does not eliminate the possibility of a hostile privileged party
    on a legitimate path between the systems (though such an incident is unlikely,
    compared with the blind spoofing scenario).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个握手协议消除了外部人员简单地伪造流量的可能性，但并没有消除在系统之间合法路径上的敌对特权方发起攻击的可能性（尽管与盲目的伪造场景相比，这种事件不太可能发生）。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Needless to say, although the problem of using initial sequence numbers that
    are difficult to predict was not considered a problem, and many systems used designs
    such as a simple incremental generator, the possibility of either blindly establishing
    a session by spoofing a TCP handshake from a particular source or injecting data
    into alreadyestablished connections by an outsider has become a bit problematic
    with time.^([[17](#ftn.CHP-9-FN-3)]) Careful selection of TCP initial sequence
    numbers so that a bystander cannot predict what your system is going to reply
    with in response to a forthcoming packet is now considered a necessity, and several
    approaches have been devised to address this issue.^([[79](apb.html#ftn.CHP-9-BIB-6)])
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，尽管使用难以预测的初始序列号的问题并未被视为问题，许多系统使用了如简单递增生成器等设计，但随着时间的推移，通过欺骗特定源的TCP握手盲目建立会话或由外部人员注入已建立连接的数据的可能性已经变得有些问题。[17](#ftn.CHP-9-FN-3)]
    现在仔细选择TCP初始序列号，以确保旁观者无法预测你的系统将如何对即将到来的数据包做出响应，被认为是必要的，并且已经设计出几种方法来解决这个问题。[79](apb.html#ftn.CHP-9-BIB-6)]
- en: Once a handshake is completed, the parties can exchange data, mutually acknowledging
    their sequence numbers each time; packets on which a mismatch of sequence numbers
    larger than an allowed “window” occurs are simply ignored. These numbers are from
    now on also steadily increased to reflect the amount of data sent up to that point,
    which makes it possible to process packets in the correct order at the destination,
    even if they arrive out of order. To ensure reliability, if a portion of data
    is not acknowledged within a reasonable time frame, a retransmission of the packet
    (or packets) must occur.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成握手，各方可以交换数据，每次互相确认它们的序列号；序列号发生大于允许“窗口”的错配的包将被简单地忽略。从现在起，这些数字也将稳步增加，以反映到该点发送的数据量，这使得即使在它们到达顺序错误的情况下，也能在目的地正确处理数据包。为了确保可靠性，如果在合理的时间内没有确认部分数据，则必须重新传输该数据包（或数据包）。
- en: The termination of a session occurs when a FIN packet with a proper acknowledgment
    number is received by any of the parties. If, at any point, one of the systems
    gets quite agitated and wants to abruptly terminate the session (perhaps because,
    from their perspective, there is nothing to talk about, the session timed out,
    or their party severely violated the convention), an RST packet is sent.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何一方收到带有适当确认号的FIN数据包时，会话终止。如果在任何时候，其中一个系统变得非常激动并希望突然终止会话（可能是因为从他们的角度来看，没有什么可说的，会话超时，或者他们的方严重违反了约定），则会发送一个RST数据包。
- en: A successful legitimate TCP handshake is shown in [Figure 9-7](ch09s05.html#a_complete_tcp_handshake_and_a_failure_o
    "Figure 9-7. A complete TCP handshake and a failure of a common spoofing attempt")
    (on the left). A failure of a typical IP spoofing attack intended to create a
    session in the name of an innocent bystander who does not intend to exchange any
    data with the target is shown on the right. The attacker cannot see or predict
    the response sent to the system it tries to act on behalf of and thus cannot complete
    the handshake, let alone perform any actual data exchange within the TCP session.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的合法TCP握手过程如图[图9-7](ch09s05.html#a_complete_tcp_handshake_and_a_failure_o
    "图9-7. 完整的TCP握手过程及常见的欺骗尝试失败")（在左侧所示）。右侧展示了针对无辜旁观者（无意与目标交换任何数据）创建会话的典型IP欺骗攻击失败情况。攻击者无法看到或预测其试图代表系统发送的响应，因此无法完成握手，更不用说在TCP会话中进行任何实际的数据交换了。
- en: As suggested, TCP provides reasonable protection against network reliability
    problems and is more suitable for ordered session-based communications. But the
    price is extra overhead that comes from the need to complete a handshake, as well
    as for both endpoints to maintain control information for the connection. Maintenance
    of this state exacts a heavy toll because it becomes necessary for every connection
    to track sequence numbers and current status of the stream (handshake stages,
    data exchange stage, closing stages), keep a copy of all sent but not yet acknowledged
    data in case it needs to be re-sent, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所建议的，TCP提供了对网络可靠性问题的合理保护，并且更适合有序的基于会话的通信。但代价是额外的开销，这来自于完成握手的需求，以及两端维护连接控制信息的需求。维护这种状态需要付出沉重的代价，因为每个连接都必须跟踪序列号和流的当前状态（握手阶段、数据交换阶段、关闭阶段），保留所有已发送但尚未确认的数据的副本，以防需要重新发送，等等。
- en: Because of their memory and performance costs, TCP stack implemen-tations are
    a common denial-of-service attack vector.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的内存和性能成本，TCP堆栈实现是常见的拒绝服务攻击向量。
- en: '![A complete TCP handshake and a failure of a common spoofing attempt](httpatomoreillycomsourcenostarchimages1138064.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![完整的TCP握手和常见的欺骗尝试失败](httpatomoreillycomsourcenostarchimages1138064.png.jpg)'
- en: Figure 9-7. A complete TCP handshake and a failure of a common spoofing attempt
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7. 完整的TCP握手和常见的欺骗尝试失败
- en: Other TCP Header Parameters
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他TCP头部参数
- en: Other TCP header parameters also control important aspects of packet interpretation
    and delivery. These will come in handy later when we attempt to gain information
    about the sender by just looking at the packet data they provide. [Figure 9-6](ch09s05.html#the_tcp_header_structure
    "Figure 9-6. The TCP header structure"), shown earlier in this chapter, provides
    a complete listing of the TCP fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其他TCP头部参数也控制了数据包解释和交付的重要方面。当我们试图仅通过查看他们提供的数据包数据来获取发送者的信息时，这些信息将非常有用。[图9-6](ch09s05.html#the_tcp_header_structure
    "图9-6. TCP头部结构")，在本章前面已展示，提供了TCP字段的完整列表。
- en: '**Source and destination ports**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**源和目标端口**'
- en: These 16-bit values identify the logical origin and endpoint on source and destination
    machines. They are similar to the source and destination port parameters used
    in UDP, although the UDP and TCP port space is kept separate on the system level—meaning
    one application can listen on UDP port 1234, and another application can listen
    on the same port number in the TCP space. The traffic is directed according to
    the protocol specification in the IP headers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些16位值标识了源和目标机器上的逻辑起点和终点。它们类似于UDP中使用的源和目标端口参数，尽管在系统级别上UDP和TCP端口空间是分开的——这意味着一个应用程序可以监听UDP端口1234，而另一个应用程序可以在TCP空间中监听相同的端口号。流量是根据IP头中的协议规范来定向的。
- en: '**Sequence and acknowledgment numbers**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列号和确认号**'
- en: These 32-bit values ensure session integrity. A sequence number is the value
    the sender expects to have echoed back. An acknowledgment number is the value
    echoed back to the sender and will only be meaningful if the ACK flag is set.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些32位值确保会话完整性。序列号是发送者期望回显的值。确认号是回显给发送者的值，只有在ACK标志被设置的情况下才有意义。
- en: '**Data offset (not to be confused with IP fragment offset parameter)**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据偏移（不要与IP分片偏移参数混淆）**'
- en: The information in this field indicates where in the packet the header ends
    and the payload starts. As with IP headers, the length of the TCP header can vary
    if certain variable-length settings were appended at its end. This information
    makes it easy to just skip to the actual data, without having to go through all
    the header information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段中的信息指示了数据包中头部结束和有效负载开始的位置。与IP头部一样，如果在其末尾附加了某些可变长度设置，TCP头部的长度可能会变化。这些信息使得只需跳到实际数据，而无需遍历所有头部信息变得容易。
- en: '**Flags**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**标志**'
- en: These eight-bit values define special properties of a packet. Each of the designated
    bits of this field represents a unique flag and can be turned on or off independently;
    as such, TCP flags can be recombined arbitrarily. *Primary flags* (SYN, ACK, RST,
    and FIN) define the way the packet should be interpreted in terms of a TCP session,
    as discussed earlier; *secondary flags* control certain aspects of payload delivery
    and other extended features, such as congestion notification, but are not used
    to change the state of a connection itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些8位值定义了数据包的特殊属性。此字段中指定的每个位代表一个独特的标志，可以独立打开或关闭；因此，TCP标志可以任意重新组合。"主要标志"（SYN、ACK、RST和FIN）定义了如何根据前面讨论的方式解释数据包，作为TCP会话的一部分；"次要标志"控制有效负载交付的某些方面和其他扩展功能，如拥塞通知，但不用于改变连接本身的状态。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although flags can be combined as you please, many possible combinations are
    simply illegal or bogus. (For example, SYN+RST has no meaning and is, formally
    speaking, not allowed.) Only some combinations are meaningful for the handshake
    and normal data processing. Various systems respond in different ways to illegal
    flag combinations, and so sending bogus packets with unusual flags is a popular
    active operating system detection mechanism.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以随意组合标志，但许多可能的组合都是非法的或无效的。（例如，SYN+RST没有意义，从正式的角度来说，是不允许的。）只有一些组合对于握手和正常数据处理是有意义的。不同的系统对非法标志组合的反应不同，因此发送带有不寻常标志的无效数据包是一种流行的操作系统检测机制。
- en: '**Window size**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口大小**'
- en: This 16-bit value controls the maximum amount of data that can be sent without
    waiting for an acknowledgment packet. A higher value allows more data to be sent
    at once, without having to wait for an acknowledgment receipt, but can penalize
    performance if a portion of the data is lost in transfer or is not acknowledged
    and has to be resent.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 16 位值控制了在不等待确认数据包的情况下可以发送的最大数据量。更高的值允许一次性发送更多数据，而无需等待确认接收，但如果数据在传输中丢失或未确认并需要重发，可能会对性能造成惩罚。
- en: '**Checksum**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**校验和**'
- en: This trivial 16-bit method protects the integrity of the layer four data, similar
    to the packet checksumming mechanism used in UDP and IP headers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的 16 位方法保护了第四层数据的完整性，类似于 UDP 和 IP 头部中使用的数据包校验和机制。
- en: '**Urgent pointer**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧急指针**'
- en: This field is interpreted only by the recipient when one of the secondary flags,
    URG, is set in a packet. If URG is not set, the value specified in this region
    of the header is simply disregarded. This flag indicates that the sender is asking
    the recipient to relay a certain message to the application processing the traffic,
    presumably due to an “urgent” situation, so that the packet is inserted in the
    logical stream at a position earlier than it would otherwise belong to; the exact
    offset is controlled by the urgent pointer value. This mechanism is seldom used
    in normal communications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包中设置了次要标志之一 URG 时，该字段仅由接收者解释。如果未设置 URG，则在此头部区域中指定的值将被简单地忽略。此标志表示发送者要求接收者将特定消息转发给处理流量的应用程序，这可能是由于“紧急”情况，因此数据包将被插入到逻辑流中比其原本应属于的位置更早的位置；确切的偏移量由紧急指针值控制。此机制在正常通信中很少使用。
- en: TCP Options
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 选项
- en: The variable-length options block at the end of the header can specify additional
    settings or parameters for the packet. In some cases, it will be empty (zero length),
    but it is more commonly used to implement additional extensions for the protocol
    that were designed later on, without disrupting old implementations that cannot
    understand them. The options block is designed so that systems that do not recognize
    a specific option can safely ignore it. The most popular options include the following.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 头部末尾的变长选项块可以指定数据包的附加设置或参数。在某些情况下，它将是空的（长度为零），但它更常用于实现后来设计的协议的附加扩展，而不会破坏无法理解它们的旧实现。选项块的设计使得无法识别特定选项的系统可以安全地忽略它。最流行的选项包括以下内容。
- en: '**Maximum Segment Size (MSS)**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大分段大小 (MSS)**'
- en: This 16-bit value equals the maximum transfer unit on the sender’s network,
    minus the size of lower-layer headers. It represents the maximum packet length
    that can be sent back to the recipient without causing fragmentation en route.
    The sender uses the MSS setting to ensure optimal performance whenever the recipient
    returns large portions of data that would otherwise require fragmentation and
    associated bandwidth overhead. Unfortunately, the MSS option is set by the endpoint
    system according to its best knowledge of the size of the packets their immediate
    network neighborhood can handle; it does nothing to avoid a common problem of
    midway fragmentation that occurs on intermediate systems (and hence the need to
    implement PMTU discovery on IP level, as discussed previously).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 16 位值等于发送者网络上的最大传输单元减去低层头部的尺寸。它表示可以在不引起途中分片的情况下发送给接收者的最大数据包长度。发送者使用 MSS 设置来确保在接收者返回大量数据时始终获得最佳性能，这些数据如果不进行分片，将需要额外的带宽开销。不幸的是，MSS
    选项由端点系统根据其对直接网络邻居可以处理的数据包大小的最佳知识来设置；它无法避免在中间系统上发生的常见问题，即中途分片（因此需要在 IP 层上实现 PMTU
    发现，如前所述）。
- en: '**Window scaling**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口缩放**'
- en: This eight-bit value described in RFC1232^([[80](apb.html#ftn.CHP-9-BIB-7)])
    extends the range of the window size field originally specified in the TCP header.
    With experience we have seen that acknowledging every 64 kilobytes of data (the
    maximum value expressed by the 16-bit window size parameter) can create a performance
    bottleneck when transferring large amounts of data, such as multimedia files,
    over high-bandwidth but high-latency links. Window scaling is a method to extend
    window size to allow more data to be sent without waiting for an acknowledgment.
    This speeds up data transfer but can also require more data to be retransmitted
    when a single packet is missing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RFC1232中描述的此8位值扩展了TCP头部中最初指定的窗口大小字段的范围。根据经验，我们发现，在传输大量数据（如多媒体文件）时，每64千字节的数据（16位窗口大小参数表示的最大值）可以创建性能瓶颈，尤其是在高带宽但高延迟的链路上。窗口缩放是一种扩展窗口大小的方法，允许发送更多数据而无需等待确认。这加快了数据传输，但当一个数据包丢失时，也可能需要重新传输更多数据。
- en: '**Selective acknowledgment options (RFC2018^([[81](apb.html#ftn.CHP-9-BIB-8)]))**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择性确认选项（RFC2018**）'
- en: When using larger window sizes, losing a single packet requires retransmitting
    the entire group of data not yet acknowledged, a terrible waste of bandwidth.
    To prevent this, a mechanism for selective acknowledgment of chunks of data was
    devised. Endpoints first declare their ability and willingness to implement this
    functionality by specifying a Selective ACK Permitted option and then, eventually,
    acknowledge noncontinuous blocks of data using the actual Selective Acknowledgment
    option in the headers. Implementing this technique can significantly boost performance,
    but at the cost of certain memory and data processing overhead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用更大的窗口大小时，丢失单个数据包需要重新传输整个尚未确认的数据组，这是一种带宽的巨大浪费。为了防止这种情况，设计了一种机制，用于对数据块进行选择性确认。端点首先通过指定选择性确认允许选项来声明其能力和意愿实现此功能，然后最终使用头部中的实际选择性确认选项来确认非连续的数据块。实施此技术可以显著提高性能，但代价是增加一定的内存和数据处理开销。
- en: '**The time-stamp option (two 32-bit values)**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间戳选项（两个32位值**）'
- en: This is another high-performance extension suggested in RFC1232\. This mechanism
    for sending and echoing back time stamps (which are typically chosen to correspond
    to system time or uptime in one way or another) provides a method for each endpoint
    to estimate round-trip times for the traffic. The main advantage of this option
    is that the sender can measure the typical time a packet needs to reach its destination
    and proceed with a TCP retransmission sooner if there is no response. An additional
    application of the time-stamp option is preventing sequence number collisions
    (PAWS, Protection Against Wrapped Sequence [Numbers]), for example, when a long-gone
    packet makes its way to the destination after several gigabytes of data have been
    exchanged and after the sequence number counter has wrapped around.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在RFC1232中建议的另一个高性能扩展。这种发送和回显时间戳（通常以某种方式对应于系统时间或运行时间）的机制为每个端点提供了一种估计流量往返时间的方法。此选项的主要优点是发送者可以测量数据包到达目的地所需的时间，并在没有响应的情况下更早地进行TCP重传。时间戳选项的另一个应用是防止序列号冲突（PAWS，防止序列号[号码]回绕），例如，当在交换了几吉字节的数据之后，序列号计数器回绕之后，一个早已消失的数据包到达目的地时。
- en: '**EOL**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**EOL**'
- en: This option should be interpreted as the end of options; it tells the recipient
    not to process any trailing data as a part of the header. Because the TCP header
    size is defined in units longer than a single byte, some unused space can remain
    after placing all relevant options before the beginning of the data, but before
    the payload data begins (which is only possible on a full four-byte boundary).
    The EOL option can be used to prevent the recipient from attempting to analyze
    this data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项应解释为选项的结束；它告诉接收者不要将任何尾随数据作为头部的一部分进行处理。因为TCP头部大小是以超过单个字节的单位定义的，所以在将所有相关选项放置在数据开始之前，但在有效载荷数据开始之前（这仅在完整的四字节边界上才可能）之后，可能会留下一些未使用的空间。EOL选项可以用来防止接收者尝试分析这些数据。
- en: '**The NOP option**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOP选项**'
- en: This option means “do nothing,” and is quite simply ignored by the recipient.
    The sender may and should use NOPs in a packet to pad it to ensure proper alignment
    of some multibyte options (which must be aligned due to performance and architecture
    constraints on some processors^([[18](#ftn.CHP-9-FN-4)])).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项意味着“什么也不做”，并且简单地被接收方忽略。发送者可以使用NOPs（无操作）在数据包中填充，以确保某些多字节选项的正确对齐（由于性能和某些处理器的架构限制，这些选项必须对齐^([[18](#ftn.CHP-9-FN-4)]))。
- en: '**T/TCP (Transactional TCP)**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**T/TCP (事务性TCP**)'
- en: This esoteric extension provides support for separate virtual sessions (transactions)
    within an established TCP session. This makes it possible to avoid the overhead
    caused by the need to complete a handshake every time you want to perform a specific
    operation with one-shot services—an approach that is more common if an application
    wants to process a number of separate transactions with a server. This extension
    is rarely used, and it is most useful for certain database systems (see RFC1644^([[82](apb.html#ftn.CHP-9-BIB-9)])).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种神秘的扩展为在已建立的TCP会话内提供独立的虚拟会话（事务）支持。这使得在每次想要与一次性服务执行特定操作时，可以避免因完成握手而产生的开销——如果应用程序想要与服务器处理多个单独的事务，这种方法更为常见。这个扩展很少使用，并且对于某些数据库系统非常有用（参见RFC1644^([[82](apb.html#ftn.CHP-9-BIB-9)])）。
- en: '* * *'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#CHP-9-FN-3)]) Kevin Mitnick, one of the most famous and controversial
    black hat hackers, compromised Tsutomu Shimomura’s computer by impersonating one
    of their trusted workstations using TCP spoofing—an act that quite upset Mr. Tsutomu
    and, according to most accounts, did not really help Kevin in the long run.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-9-FN-3)]) 凯文·米特尼克，最著名且最具争议的黑帽黑客之一，通过使用TCP欺骗冒充他们的一个受信任工作站，破坏了Tsutomu
    Shimomura的计算机——这一行为让Tsutomu先生非常不安，据大多数说法，这对凯文长期来说并没有真正帮助。
- en: ^([[18](#CHP-9-FN-4)]) “Must” as in “are required to be in order to ensure proper
    handling.” Some processors have significant performance penalties when accessing
    multibyte data structures that are not aligned to 32 or 64 bits; others simply
    require them to be aligned this way or else cause a fatal exception (execution
    trap) and refuse to perform an operation. Naturally, a naughty sender can purposefully
    place misaligned data in the buffer and hope that recipient’s system will go down
    in flames upon receiving such a packet. Of course, a sane operating system checks
    for this first or attempts to copy the option data to a properly aligned region
    before processing it. The sanity of a system need not to be taken for granted,
    though.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#CHP-9-FN-4)]) “必须”指的是“为了确保适当处理而必须具备的条件。”一些处理器在访问未对齐32或64位的多字节数据结构时会有显著的性能损失；而另一些处理器则要求它们必须以这种方式对齐，否则会引发致命异常（执行陷阱）并拒绝执行操作。当然，一个淘气的发送者可能会故意在缓冲区中放置未对齐的数据，并希望接收方的系统在接收到这样的数据包时崩溃。当然，一个理智的操作系统会首先检查这一点，或者在处理之前尝试将选项数据复制到一个正确对齐的区域。然而，系统的理智并不应该被理所当然地接受。
- en: Internet Control Message Protocol Packets
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网控制消息协议数据包
- en: ICMP packets (see RFC792^([[83](apb.html#ftn.CHP-9-BIB-10)])) are used to send
    diagnostic information and notifications for other protocol types. Logically considered
    part of layer three, ICMP packets are carried as a payload of IP packets and,
    as such, are no different from the layer four payload. ICMP does not carry any
    new user-space data between endpoints and provides a trivial signaling method
    for IP instead. [Figure 9-8](ch09s06.html#the_icmp_header_structure "Figure 9-8. The
    ICMP header structure") shows the ICMP header structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP数据包（参见RFC792^([[83](apb.html#ftn.CHP-9-BIB-10)]))用于发送其他协议类型的诊断信息和通知。从逻辑上讲，ICMP数据包是第三层的组成部分，作为IP数据包的有效负载传输，因此与第四层有效负载没有区别。ICMP不携带任何新的用户空间数据，而是为IP提供了一种简单的信号方法。[图9-8](ch09s06.html#the_icmp_header_structure
    "图9-8. ICMP头部结构")显示了ICMP头部结构。
- en: '![The ICMP header structure](httpatomoreillycomsourcenostarchimages1138066.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![ICMP头部结构](httpatomoreillycomsourcenostarchimages1138066.png.jpg)'
- en: Figure 9-8. The ICMP header structure
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8. ICMP头部结构
- en: A variety of messages are sent using ICMP in response to TCP or UDP traffic,
    usually indicating that a particular packet cannot be delivered, expired in transfer,
    or was rejected for some reason. Several types of ICMP can be sent spontaneously,
    such as router advertisements, echo requests (ping), and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ICMP发送了各种消息，以响应TCP或UDP流量，通常表示某个特定的数据包无法投递、在传输中过期或由于某些原因被拒绝。可以自发地发送几种类型的ICMP，例如路由器广告、回显请求（ping）等。
- en: As with UDP packets, the ICMP header is simple. It consists of the following
    fields.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP数据包一样，ICMP头部很简单。它由以下字段组成。
- en: '**Message type**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息类型**'
- en: This eight-bit field lists a general category of the event that caused this
    packet to be sent (such as “destination unreachable”). This field can also carry
    a stand-alone message, though that use is infrequent.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个八位字段列出了导致发送此数据包的事件的一般类别（例如“目标不可达”）。此字段还可以携带独立的消息，尽管这种用法不常见。
- en: '**Message code**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息代码**'
- en: This eight-bit value describes the exact problem, if applicable. It depends
    on the message type and might describe the condition in more detail (“network
    unreachable,” “host unreachable,” “port unreachable,” “communication administratively
    prohibited”). The distinction between the level of detail that should be included
    in the message type field versus what should be left to the message code is unclear.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，这个八位值描述了确切的问题。它取决于消息类型，可能更详细地描述条件（“网络不可达”、“主机不可达”、“端口不可达”、“通信被管理禁止”）。在消息类型字段中应包含的详细程度与应留给消息代码的内容之间的区别尚不明确。
- en: '**A checksum of the packet**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据包校验和**'
- en: This field verifies that the packet was not damaged (as with UDP and TCP).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段验证数据包未被损坏（类似于UDP和TCP）。
- en: The header of an ICMP packet is fairly simple and itself does not provide enough
    information to successfully troubleshoot the issue it attempts to report on or
    to identify what kind of traffic generated this message. This information is conveyed
    in the packet payload instead and immediately follows the header of a packet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP数据包的头部相当简单，本身并不提供足够的信息来成功解决它试图报告的问题，或识别生成此消息的流量类型。这些信息在数据包的有效负载中传达，并紧随数据包头部之后。
- en: Although the payload of an ICMP packet depends on the message, it typically
    quotes the beginning of the packet that triggered the response. This makes it
    possible for the recipient to determine the communications to which the message
    applies and which application should be notified of the problem. It can also be
    used to ensure that the sender of the ICMP packet is actually somewhere on the
    legitimate network route between the two machines, rather than outside them. Otherwise,
    the sender would not be able to see the actual data being exchanged. (In particular,
    they would not be able to determine the exact sequence number in TCP packets.)
    This prevents malicious bystanders from sending bogus messages announcing connectivity
    problems and forcing one of the endpoints to drop a connection—or at least in
    theory. Naturally, it can be quite difficult to tell the good from the bad since
    some systems are notorious for mangling or misquoting the original data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ICMP数据包的有效负载取决于消息类型，但它通常引用触发响应的数据包的开始部分。这使得接收者能够确定消息适用的通信以及应该通知哪个应用程序出现的问题。它还可以用来确保ICMP数据包的发送者实际上位于两台机器之间的合法网络路由上，而不是它们的外部。否则，发送者将无法看到实际交换的数据。（特别是，他们无法确定TCP数据包的确切序列号。）这阻止了恶意旁观者发送虚假消息宣布连接问题，并迫使端点之一断开连接——至少在理论上是如此。当然，由于一些系统臭名昭著地篡改或误引原始数据，区分好与坏可能相当困难。
- en: Enter Passive Fingerprinting
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入被动指纹识别
- en: 'How does the design of this protocol relate to user privacy? The answer is
    a bit bizarre: although the design of IP, TCP, UDP, and ICMP packets is generally
    fairly strict, and the information transmitted in these headers is not particularly
    verbose, differences in the way various operating systems add information to these
    packets makes it possible to tell not only the type of operating system in use
    but even the specific version of an instance of a machine. The differences are
    particularly evident when dealing with traffic that is not clearly and appropriately
    discussed in the specification or that is not analyzed during normal quality assurance
    routines (say, an incoming packets with an illegal combination of flags such as
    SYN+RST).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议的设计如何与用户隐私相关？答案是有点奇怪：尽管IP、TCP、UDP和ICMP数据包的设计通常相当严格，并且这些头部中传输的信息并不特别冗长，但各种操作系统向这些数据包添加信息的方式的不同使得可以判断出正在使用的操作系统类型，甚至可以判断出机器实例的具体版本。当处理在规范中未明确讨论或未在正常质量保证程序中分析（例如，带有非法标志组合的传入数据包，如SYN+RST）的流量时，这些差异尤其明显。
- en: Intensive research into differentiating systems by stress-testing their implementations
    has shown that it is safe to conclude that no two IP suite implementations in
    operating systems are the same. It is often possible to use sophisticated analysis
    to distinguish between the same system running on slightly different platforms
    or between slightly different versions of a system. Active analysis tools such
    as Fyodor’s NMAP, a TCP/UDP fingerprinter and port scanner, and Ofir Arkin’s Xprobe,
    an ICMP fingerprinter, exploit the flaws or oddities in every system and identify
    operating system genre and version by sending various types of malformed or unusual
    packets and then measuring and analyzing the responses they trigger.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对系统实现进行压力测试的深入研究，已经表明可以安全地得出结论，操作系统中的任何两个IP套件实现都是不同的。通常，可以使用复杂分析来区分在略微不同的平台上运行的相同系统，或者区分系统略微不同的版本。像Fyodor的NMAP这样的活跃分析工具，一个TCP/UDP指纹识别器和端口扫描器，以及Ofir
    Arkin的Xprobe，一个ICMP指纹识别器，通过发送各种类型的不规则或异常数据包来利用每个系统的缺陷或异常，并通过测量和分析这些数据包引发的响应来识别操作系统类型和版本。
- en: 'Examining IP Packets: The Early Days'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查IP数据包：早期阶段
- en: But the techniques of system fingerprinting do not stop here. In fact, poking
    the remote system by sending suspicious and easily detectable data is perhaps
    the least subtle way to approach this problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但系统指纹识别的技术并没有停止在这里。实际上，通过发送可疑且易于检测的数据来远程系统“戳探”可能是处理这个问题的最不微妙的方法。
- en: In early 2000, two folks at Subterrain Security Group, identified only by the
    nicknames *bind* and *aempirei*, demonstrated that it is often possible to get
    information about a distant entity on a network without conducting any intrusive
    communications with the remote party or, for that matter, without initiating any
    communications at all. (Their code and findings were first presented at DefCON
    8, a slightly overrated hacker trade show of sorts, back in 2000.) Their technique,
    today called *passive fingerprinting*, involves passively (duh) observing casual
    legitimate traffic originating from a remote system. Although the metrics this
    technique uses are much more subtle and limited than those deployed by Fyodor
    and his predecessors, a good dose of research (to which I am proud to have made
    several contributions) has provided enough observations to achieve a fairly amazing
    level of precision.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年初，Subterrain安全小组的两名成员，分别以昵称*bind*和*aempirei*著称，证明了在没有与远程方进行任何侵入性通信，甚至没有发起任何通信的情况下，通常可以获取网络上远程实体的信息。（他们的代码和发现最初在2000年的DefCON
    8上展出，这是一个略过誉的黑客交易会。）他们的技术，现在被称为*被动指纹识别*，涉及被动地（duh）观察来自远程系统的合法流量。尽管这种技术使用的指标比Fyodor和他的前辈们使用的指标更为微妙和有限，但大量的研究（我很自豪地贡献了其中的一些）已经提供了足够的观察结果，达到了相当惊人的精确度。
- en: To better understand what can be told from a single packet received over the
    network, let’s take a look at the metrics upon which we can base passive fingerprinting
    and examine what they can tell us about the other party. This exploration is based
    on dissecting the most popular type of traffic on the Internet—a legitimate TCP
    packet in IP wrapping.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解从网络上接收到的单个数据包可以告诉我们什么，让我们来看看我们可以基于被动指纹识别的指标，并检查它们可以告诉我们关于另一方的什么信息。这次探索基于分析互联网上最受欢迎的流量类型——IP封装中的合法TCP数据包。
- en: Initial Time to Live (IP Layer)
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始生存时间（IP层）
- en: Recall that the TTL field controls the number of systems through which a packet
    can pass before being discarded as undeliverable. The packet’s TTL value is decreased
    each time it passes a router, until TTL reaches zero, at which point the packet
    is discarded.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，TTL字段控制着数据包在被丢弃为不可投递之前可以经过多少个系统。每当数据包通过一个路由器时，它的TTL值就会减少，直到TTL达到零，此时数据包就会被丢弃。
- en: Because there is no strict requirement as to how this field should be set by
    the sender, many IP stack developers just roll the dice when determining the default
    for their pet system. Although a passive bystander cannot determine the packet’s
    exact initial value without additional tests (because the packet would have surely
    crossed several routers before being observed), they know that its initial value
    must have been higher than the actual observed state. Too, the average distance
    to a remote computer on the Internet usually does not exceed 15 hops, and it is
    unusual for two systems to be more than 30 hops apart. As such, you can safely
    assume that the original value lies somewhere between the observed TTL and the
    observed TTL + 30 (but is less than 256, of course).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有严格的要求说明发送者应该如何设置此字段，许多IP堆栈开发者在确定他们宠爱的系统的默认值时只是掷骰子。尽管没有额外的测试，旁观者无法确定包的确切初始值（因为包在观察之前肯定已经穿越了几个路由器），但他们知道其初始值必须高于实际观察到的状态。此外，到互联网上远程计算机的平均距离通常不超过15跳，两个系统之间超过30跳的情况很少见。因此，你可以安全地假设原始值位于观察到的TTL和观察到的TTL
    + 30之间（但当然小于256）。
- en: Because we know the initial values used by popular operating systems, we can
    hone in on the operating system genre the sender is likely running. (Linux and
    BSD-derived systems usually stick with 64; Windows developers use 128, and some
    true Unix descendants use 255.) Then, once we determine the operating system that
    sent the packet, based on this and other factors, we might also be able to determine
    how far the sender is from the observation point by subtracting the observed TTL
    from the value known to be used initially. By correlating this value with the
    actual previously observed or otherwise known distance to his network, we might
    then be able to draw some conclusions about the organization of the sender’s internal
    network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道流行操作系统的初始值，我们可以专注于发送者可能运行的操作系统类型。（Linux和BSD衍生系统通常坚持使用64；Windows开发者使用128，而一些真正的Unix后裔使用255。）然后，一旦我们确定了发送包的操作系统，基于这一点和其他因素，我们可能还能够通过从已知的初始值中减去观察到的TTL来确定发送者距离观察点的距离。通过将此值与之前观察到的或已知的网络距离相关联，我们可能然后能够对发送者内部网络的组织得出一些结论。
- en: The Don’t Fragment Flag (IP Layer)
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不分片标志（IP层）
- en: 'The DF flag says, “If this packet does not fit over a specific network link,
    don’t fragment it; just discard it.” By observing whether this flag is set, we
    can determine whether the system uses the PMTUD mechanism described previously,
    which gives us yet another hint as to the operating system in use. This also distinguishes
    between two sizable groups of systems: only newer IP implementations use this
    technique, and all others have no interest in enabling this flag in packets they
    send out.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DF标志表示，“如果这个包不适合特定的网络链路，不要分片它；只需丢弃它。”通过观察这个标志是否被设置，我们可以确定系统是否使用之前描述的PMTUD机制，这又给我们提供了关于正在使用的操作系统的另一个线索。这也区分了两个庞大的系统群体：只有较新的IP实现使用这种技术，而所有其他系统对在它们发送的包中启用此标志都没有兴趣。
- en: The IP ID Number (IP Layer)
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP ID号（IP层）
- en: As mentioned earlier (in the discussion of the shortcomings of packet fragmentation),
    certain PMTUD-enabled systems set the IP ID number to zero on some (or all) outgoing
    traffic, because they assume that the traffic will not be fragmented and because
    of security concerns about displaying IP ID numbers (as you’ll see in [Chapter 13](ch13.html
    "Chapter 13. Smoke and Mirrors")). Consequently, we can identify those systems
    by examining whether incoming packets have the IP ID number set to zero.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述（在讨论分片不足的讨论中），某些启用PMTUD的系统在某些（或所有）出站流量中将IP ID号设置为零，因为他们假设流量不会分片，并且出于对显示IP
    ID号的安全担忧（正如你在[第13章](ch13.html "第13章。烟雾和镜子")中看到的）。因此，我们可以通过检查传入的包是否将IP ID号设置为零来识别这些系统。
- en: However, there is a catch. Although some PMTUD-enabled operating systems always
    set the IP ID to zero, some other systems can also set IP IDs to zero at some
    point, simply because there aren’t that many IP ID possibilities to choose from.
    In other words, if you see a packet with an IP ID that is nonzero, it is safe
    to assume this is not a system that uses zero values for all outgoing communications.
    However, if you see a zero value in a packet, you might be seeing a particular
    species of PMTUD-enabled system, but you could also be seeing a “regular” system
    that has simply chosen zero for this packet, by chance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个陷阱。尽管一些启用PMTUD（路径最大传输单元发现）的操作系统总是将IP ID设置为零，但一些其他系统在某些时候也可以将IP ID设置为零，仅仅是因为可供选择的IP
    ID可能性并不多。换句话说，如果你看到一个IP ID非零的数据包，可以安全地假设这不是一个对所有出站通信都使用零值的系统。然而，如果你看到一个数据包中的IP
    ID为零，你可能看到的是一个特定的启用PMTUD的系统，但你也可能看到的是一个“普通”系统，它只是偶然选择了零值来标记这个数据包。
- en: Although the probability of this occurring is low, it is not quite negligible
    either. You might either want to take zero IP ID cases with a grain of salt (and
    only use nonzero IP ID observations to narrow down the set of possible operating
    systems) or to conduct several observations for the same source to confirm that
    zero values are always used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况发生的概率很低，但也不是完全可以忽略不计。你可能要么对零IP ID的情况持保留态度（并且只使用非零IP ID观察结果来缩小可能的操作系统范围），要么对同一源进行多次观察以确认零值总是被使用。
- en: Type of Service (IP Layer)
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型（IP层）
- en: By design, this field should be chosen to correspond to the priority and type
    of the traffic in order to give interim systems a hint as to how to handle the
    packet, but it almost never is. Most operating systems set this field to an arbitrary
    fixed value because developers can set the value as they want without, in practice,
    affecting the operations of TCP networking. Depending on the developer’s ego,
    they may merely default this parameter to zero or consider it appropriate to tag
    all communications originating from their system as “low latency,” “high reliability,”
    or some other setting using a combination of bits in this field.^([[19](#ftn.CHP-9-FN-5)])
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，这个字段应该被选择以对应于流量优先级和类型，以便给中间系统提供关于如何处理数据包的提示，但它几乎从未这样做。大多数操作系统将此字段设置为任意固定值，因为开发者可以随意设置值，而实际上不会影响TCP网络的操作。根据开发者的自尊心，他们可能只是将此参数默认设置为零，或者认为将来自他们系统的所有通信标记为“低延迟”、“高可靠性”或其他设置（使用此字段中的位组合）是合适的。[^[[19](#ftn.CHP-9-FN-5)]]
- en: This should give us an advantage—by knowing the default values for particular
    systems, we can once again narrow down the number of possible systems the sender
    might be using. To add to the confusion, however, the value of this field is sometimes
    changed for all outgoing traffic by certain naughty DSL operators and other ISPs.
    Their hope is that some remote routers on the other side of the globe will fall
    for the trick, trust that their traffic, tagged as “high priority,” deserves expedited
    handling, and prioritize it over other connections, thus providing this ISP’s
    clients with faster browsing (doubtfully so).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们带来优势——通过了解特定系统的默认值，我们再次可以缩小发送者可能使用的系统数量。然而，由于某些不守规矩的DSL运营商和其他ISP可能会更改此字段的值以应用于所有出站流量，这增加了混乱。他们的希望是，地球另一端的某些远程路由器会被这个伎俩欺骗，相信标记为“高优先级”的流量值得优先处理，并将其优先于其他连接，从而为该ISP的客户提供更快的浏览速度（这令人怀疑）。
- en: As is the case with operating systems, the ISP’s choice of Type of Service parameters
    is rather arbitrary. (For example, one Swedish provider uses a fairly unique and
    interesting combination of priority bits set to a value of 3 and uses Type of
    Service bits set to “high throughput.”) This practice, in turn, makes it quite
    easy to detect traffic originating from particular ISPs by spotting their unique
    selection of Type of Service bits, without the need to perform active analysis
    such as WHOIS Registry lookups for the source IP.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像操作系统一样，ISP选择服务类型参数的选择相当随意。（例如，一家瑞典提供商使用了一个相当独特且有趣的优先级位组合，将值设置为3，并使用服务类型位设置为“高吞吐量”。）这种做法反过来使得通过观察它们独特的服务类型位选择来检测来自特定ISP的流量变得相当容易，而无需执行如WHOIS注册查询源IP的主动分析。
- en: Nonzero Unused and Must Be Zero Fields (IP and TCP Layers)
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非零未使用和必须为零的字段（IP和TCP层）
- en: The specification for IP and TCP calls for a number of fields to be reserved
    for future use. All current systems should set these fields to zero so that a
    special meaning can be assigned to nonzero values at these positions in a packet
    in the future.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: IP和TCP规范要求为未来使用保留一定数量的字段。所有当前系统都应该将这些字段设置为0，以便将来在数据包中的这些位置分配非零值具有特殊含义。
- en: Needless to say, these are not zeroed in some implementations prior to sending,
    as they ought to be. This problem is not likely to be caught in the quality assurance
    stage because it causes no noticeable problems—other systems assume it is better
    safe than sorry and do not reject packets just because of this nuisance—and as
    such, this flaw can persist for ages (perhaps until those bits are actually used
    as a part of some TCP extension, causing it to fail spectacularly while talking
    to those broken systems). Once again, the ability to examine those values is a
    precious source of information that can lead us to a more accurate identification
    of the sender operating system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，在发送之前，这些字段在某些实现中并未被清零，正如它们应该的那样。这个问题在质量保证阶段可能不会被捕捉到，因为它不会引起任何明显的问题——其他系统认为“安全第一”更好，并且不会仅仅因为这种麻烦而拒绝数据包——因此，这种缺陷可能持续很长时间（也许直到这些位实际上被用作某些TCP扩展的一部分，导致在与这些损坏的系统通信时失败得非常明显）。再次强调，检查这些值的能力是宝贵的信息来源，可以引导我们更准确地识别发送者的操作系统。
- en: Source Port (TCP Layer)
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源端口（TCP层）
- en: The source port identifies the party to a connection on the sender’s side. Each
    system has a different policy for assigning so-called ephemeral (originating)
    ports for outgoing connections, and by examining the observed port number, it
    is often possible to determine the source operating system. Moreover, systems
    that perform masquerading commonly use a fairly specific range of ports for this
    purpose. (Masquerading, or many-to-one network address translation, involves rewriting
    outgoing traffic from a private network so that all connections appear to originate
    from the masquerading system and all responses are translated back and delivered
    to the actual sender when received by the system.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 源端口标识发送方连接的参与者。每个系统都有不同的策略来分配所谓的临时（起源）端口用于出站连接，通过检查观察到的端口号，通常可以确定源操作系统。此外，执行伪装的系统通常为此目的使用相当具体的端口范围。（伪装，或多对一的网络地址转换，涉及重写来自私有网络的出站流量，使得所有连接看起来都起源于伪装系统，并且所有响应在系统接收到时都转换回并交付给实际的发送者。）
- en: Masquerading is commonly used by both corporate and home networks in order to
    preserve address space. The internal network can use a large pool of addresses
    that, technically speaking, are not assigned to them and that are not routed there
    (or anywhere else) from the Internet. However, systems using those addresses can
    still access the Internet by forwarding their outgoing connections through an
    agent box that uses its own, legitimate public address to reach the remote system
    in the name of the initiator. This approach also protects internal systems, making
    it impossible for an outsider to initiate a direct unsolicited connection to the
    system, while allowing only insiders to connect to the outside.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 伪装在企业和家庭网络中都被广泛使用，以保留地址空间。内部网络可以使用大量地址，从技术上讲，这些地址并未分配给他们，并且从互联网（或任何其他地方）也没有路由到那里。然而，使用这些地址的系统仍然可以通过将它们的出站连接转发到使用其自己的、合法的公共地址的代理盒，以发起者的名义到达远程系统，从而访问互联网。这种方法还可以保护内部系统，使得外部人士无法直接发起未经请求的连接到系统，同时只允许内部人士连接到外部。
- en: Examining the range of source ports chosen by the other party makes it possible
    to both make a better guess at the operating system the sender is using and (once
    the range is correlated with other observations) determine whether the sender
    is in a private network using address translation (in which case, source port
    ranges expected for the system and actually observed would most likely not match).
    If the sender’s network is using address translation, it is also possible to draw
    certain conclusions as to the type of the address translation device, because
    various products use distinct ranges.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对方选择的源端口范围，可以使我们更好地猜测发送者所使用的操作系统，并且（一旦该范围与其他观察结果相关联）确定发送者是否在使用地址转换的私有网络中（在这种情况下，系统预期的源端口范围和实际观察到的范围很可能不匹配）。如果发送者的网络正在使用地址转换，还可以根据不同产品使用的不同范围，推断出地址转换设备的类型。
- en: Window Size (TCP Layer)
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口大小（TCP层）
- en: Recall that the window size setting determines the amount of data that can be
    sent without acknowledgment. The specific setting is often chosen according to
    the developer’s personal voodoo rules and other religious beliefs. The two most
    popular approaches say the value should be either a multiple of the MTU minus
    protocol headers (a value referred to as Maximum Segment Size, or MSS) or simply
    something sufficiently high and “round.” Older versions of Linux (2.0) used values
    that were powers of 2 (for example, 16,384). Linux 2.2 switched to a multiple
    of MSS (11 or 22 times MSS, for some reason), and newer versions of Linux commonly
    use 2 to 4 times MSS. The Sega Dreamcast, a network-enabled console, uses a value
    of 4,096, and Windows often uses 64,512.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，窗口大小设置决定了在不确认的情况下可以发送的数据量。具体的设置通常根据开发者的个人神秘规则和其他宗教信仰来选择。两种最流行的方法认为该值应该是MTU减去协议头部的倍数（称为最大分段大小，或MSS），或者简单地足够高且“圆滑”。Linux的旧版本（2.0）使用2的幂次方值（例如，16384）。Linux
    2.2改为使用MSS的倍数（11或22倍的MSS，原因不明），而Linux的新版本通常使用2到4倍的MSS。网络连接的家用游戏机Sega Dreamcast使用4096的值，而Windows通常使用64512。
- en: An application can sometimes change the window size value set by the operating
    system in order to boost performance, but it seldom is. (The presence of a value
    that does not match the default value that we would expect for an operating system
    is a good way to detect a specific application; one of the few examples of such
    applications is Opera, a moderately popular web browser.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有时可以更改操作系统设置的窗口大小值以提升性能，但这很少发生。（存在一个与我们预期操作系统的默认值不匹配的值，是检测特定应用程序的好方法；这类应用程序的少数例子之一是Opera，一个中等受欢迎的网页浏览器。）
- en: Urgent Pointer and Acknowledgment Number Values (TCP Layer)
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧急指针和确认号值（TCP层）
- en: 'The values specified in the urgent pointer (16 bits) and acknowledgment number
    (32 bits) fields are used only when a corresponding TCP flag—URG or ACK—is set
    in the packet. If these flags are not set, the values should be zeroed, but they
    often are not. Some systems simply initialize them to something nonzero, which
    causes no real problem: because the values will not be interpreted if an appropriate
    flag is not set, they simply serve to identify a particular system.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧急指针（16位）和确认号（32位）字段中指定的值仅在数据包中设置了相应的TCP标志（URG或ACK）时使用。如果没有设置这些标志，则这些值应该为零，但它们通常不是。一些系统只是将它们初始化为非零值，这不会引起真正的问题：因为如果没有设置适当的标志，这些值将不会被解释，它们只是用来识别特定系统。
- en: 'In some cases, however, these values are not initialized at all and are simply
    copied from whatever is found in the buffer being used to construct the TCP packet
    at the moment. I observed this behavior with Windows 2000 and XP stack implementations
    while working on passive operating system fingerprinting: whenever two TCP sessions
    occurred at once, these values leaked some of the information from a previous
    session to the current one (a case we will return to in [Chapter 11](ch11.html
    "Chapter 11. In Recognition of Anomalies")). This tells you that the person is
    doing something else in the background and discloses some of the information transferred
    to another party. Hallelujah!'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，这些值根本未初始化，而是简单地从正在用于构建TCP数据包的缓冲区中复制。我在进行被动操作系统指纹识别工作时观察到Windows 2000和XP堆栈实现的行为：每当同时发生两个TCP会话时，这些值会将前一个会话的一些信息泄露给当前会话（我们将在[第11章](ch11.html
    "第11章。识别异常")中再次讨论的情况）。这表明该人在后台做其他事情，并泄露了一些传输给另一方的信息。哈利路亚！
- en: Options Order and Settings (TCP Layer)
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项顺序和设置（TCP层）
- en: The exact ordering and selection of options in a packet is unique to each system.
    Because there are no rules governing how options should be ordered in a packet,
    there are certain “signature” combinations. For example, Windows uses a characteristic
    sequence of “MSS, NOP, NOP, Selective ACK Permitted” options on SYN packets; Linux
    usually sticks with “MSS, Selective ACK Permitted, Timestamp, NOP, Window scale.”
    Naturally, this once again serves as an excellent way of telling systems apart.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包中选项的确切顺序和选择是每个系统的独特之处。因为没有规则规定选项在数据包中的顺序，所以存在某些“签名”组合。例如，Windows在SYN数据包上使用一个特征序列的“MSS,
    NOP, NOP, Selective ACK Permitted”选项；Linux通常坚持使用“MSS, Selective ACK Permitted,
    Timestamp, NOP, Window scale。”自然地，这又是一次区分系统的绝佳方式。
- en: Window Scale (TCP Layer, Option)
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口缩放（TCP层，选项）
- en: A scaling factor for the window size is usually set to zero. However, some systems
    either default to a higher value or permanently increase the parameter for a specific
    type of traffic when they conclude that it is reasonable to do so, for example,
    if the user just fetched a pirated movie from a P2P network or completed an extensive
    download of a different kind (the latter is naturally a bit less likely).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口大小的缩放因子通常设置为零。然而，一些系统在得出这样做合理的结论时，要么默认为更高的值，要么永久性地增加特定类型流量的参数，例如，如果用户刚刚从P2P网络下载了盗版电影或完成了大量不同类型的下载（后者自然不太可能）。
- en: Maximum Segment Size (TCP Layer, Option)
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大分段大小（TCP层，选项）
- en: This field is fixed to a specific value on some systems; on others, it indicates
    the type of direct network hookup of the device. Different network types have
    different MTUs, making it possible to tell whether a person uses a high-speed
    DSL link or a puny modem line.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，此字段固定为特定值；在其他系统中，它表示设备的直接网络连接类型。不同类型的网络有不同的MTU，这使得可以判断一个人是否使用高速DSL链路或微弱的调制解调器线路。
- en: Time-Stamp Data (TCP Layer, Option)
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳数据（TCP层，选项）
- en: 'Since this value often corresponds to system uptime, it is often possible to
    determine it by observing the time-stamp option. Furthermore, given a set of operating
    systems, it is possible to differentiate them and track each one by checking time-stamp
    variations in incoming traffic: different systems will have different uptimes
    (and are quite unlikely to have identical boot-up times), whereas the same computer
    would maintain a continuously increasing time-stamp parameter value.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此值通常对应于系统运行时间，因此通常可以通过观察时间戳选项来确定它。此外，给定一组操作系统，可以通过检查传入流量中的时间戳变化来区分它们并跟踪每个系统：不同的系统将有不同的运行时间（并且不太可能有相同的启动时间），而同一台计算机将保持持续增加的时间戳参数值。
- en: This comes in quite handy in two situations. The first is when a set of systems
    acts under a single IP, as with masquerading. In such a case, a curious webmaster
    can determine how many unique users from corporation X visited their page and
    the whereabouts of each visitor to the websites they operate, even if all requests
    originate from one address and appear to be indistinguishable at first.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两种情况下非常有用。第一种情况是一组系统在单个IP下运行，就像伪装一样。在这种情况下，好奇的网站管理员可以确定来自公司X有多少独特用户访问了他们的页面，以及每个访问者访问他们运营的网站的位置，即使所有请求都来自一个地址，并且最初看起来无法区分。
- en: The other application is for tracking a single user who, for whatever reason,
    hops IP addresses. Why would one bother, and why would the other party want to
    determine if the user is doing it? For example, they might be switching between
    a pool of dynamic IP addresses assigned to a dial-up line (by disconnecting and
    connecting again), in hopes that their attack attempts will appear to be a set
    of meaningless, uncorrelated activities, rather than a well-planned, extensive
    probe. Or they might want to bypass interaction restrictions on a web forum, in
    an online poll or voting contest (with some old-fashioned ballot stuffing), and
    so on. All are common pastimes of the new generation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用是追踪单个用户，无论出于什么原因，他们可能会跳转IP地址。为什么要费这个功夫，对方为什么又想确定用户是否在这样做呢？例如，他们可能在动态IP地址池（通过断开再连接）之间切换，希望他们的攻击尝试看起来像是一系列无意义、不相关的活动，而不是一个精心策划、广泛的探测。或者他们可能想要绕过在线论坛、在线调查或投票竞赛（使用一些老式的票箱填充）的限制，等等。这些都是新一代的常见娱乐活动。
- en: The time-stamp option’s measurement of time is usually precise, because it is
    based on a clock that most commonly ticks at 100 or 1,000 Hz (although some systems
    use 64 or 1,024 Hz, and values in between). This precision is enough to differentiate
    even similar boxes that were all booted up nearly at once after a power failure,
    and thus it provides extreme accuracy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳选项的时间测量通常非常精确，因为它基于一个最常见的时钟，每秒滴答声为100或1,000赫兹（尽管一些系统使用64或1,024赫兹，以及介于两者之间的值）。这种精度足以区分即使在电源故障后几乎同时启动的相似盒子，因此它提供了极高的准确性。
- en: Other Passive Fingerprinting Venues
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他被动指纹识别场所
- en: In this chapter, we have looked at the most common metrics used to determine
    the operating system of a remote host (and to track its users) without their ever
    knowing. But many exciting, yet lesser explored aspects of communications beyond
    these basics can be used to achieve the same ends, and more.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了用于确定远程主机操作系统（以及跟踪其用户）的最常用指标，而这些指标的使用完全在用户不知情的情况下。但是，许多激动人心且尚未充分探索的通信方面，可以用来达到相同的目的，甚至更多。
- en: For example, an interesting variant of fingerprinting is related not to examining
    the packets themselves, but to measuring the timing and response rates for certain
    ICMP messages, TCP retransmissions, and similar features. The values used for
    all the time-out and retransmission count settings provide a good way to precisely
    and uniquely fingerprint a system. A CRONOS project, based on the research by
    Franck Veysset, Olivier Courtay, and Olivier Heen of the Intranode Research Team,
    aims at providing an active fingerprinting tool based on this set of metrics,
    but passive fingerprinting applications are just as tempting.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指纹识别的一个有趣变体与检查数据包本身无关，而是测量某些ICMP消息、TCP重传和类似特性的时序和响应速率。所有超时和重传计数设置所使用的值提供了一个精确且独特地识别系统的良好方法。一个基于Franck
    Veysset、Olivier Courtay和Olivier Heen（Intranode研究团队）的研究的CRONOS项目旨在提供一个基于这些指标的主动指纹识别工具，但被动指纹识别应用同样具有吸引力。
- en: Another promising lead is the effort to combine and measure many other anomalies
    or uncommon settings, such as a sender’s use of specific time-stamp values, sequence
    numbers identical to acknowledgment numbers, or unusual flags, as well as data
    payload in control packets, the use of the EOL option, and so on. These characteristics
    can also be used to differentiate between operating systems, although these characteristics
    are often specific to a small set of implementations. (The algorithm used for
    choosing initial sequence numbers is often a valuable source of information, as
    you will see in the next chapter.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有希望的线索是尝试结合和测量许多其他异常或不常见的设置，例如发送者使用特定的时间戳值、序列号与确认号相同，或非同寻常的标志，以及控制包中的数据负载、使用EOL选项等。这些特征也可以用来区分操作系统，尽管这些特征通常只针对一小部分实现。（选择初始序列号的算法通常是宝贵的信息来源，您将在下一章中看到。）
- en: '* * *'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[19](#CHP-9-FN-5)]) Some developers even choose to set the Must Be Zero bit
    of this parameter—which should never be set in a legitimate application—presumably
    just to make a style statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#CHP-9-FN-5)]) 一些开发者甚至选择设置此参数的“必须为零”位——这在合法应用程序中永远不会设置——可能只是为了做出一种风格声明。
- en: Passive Fingerprinting in Practice
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的被动指纹识别
- en: These metrics make it possible to precisely identify operating systems and their
    configuration as well as network parameters and to track users efficiently and
    silently. Although it may seem difficult to believe that this is possible, a tool
    I have authored, p0f, implements most of the techniques to gather and analyze
    the information based on the analysis of SYN, SYN+ACK, and RST packets in a completely
    passive manner, with a high rate of success.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标使得精确识别操作系统及其配置、网络参数以及高效且无声地跟踪用户成为可能。尽管这可能看起来难以置信，但我开发的一个工具p0f实现了大多数基于分析SYN、SYN+ACK和RST数据包的完全被动方式收集和分析信息的技术，成功率很高。
- en: Let’s look at an example packet to see the effectiveness of this approach. Following
    is a set of important parameters extracted from an actual TCP packet captured
    on the network. What can this tell us about the sender’s operating system?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例数据包来看看这种方法的有效性。以下是从实际捕获的TCP数据包中提取的一组重要参数。这能告诉我们发送者的操作系统是什么？
- en: '| **Internet Protocol (Version 4)** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **互联网协议（版本4）** |'
- en: '| Source host | nimue (10.3.0.1) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 源主机 | nimue (10.3.0.1) |'
- en: '| Destination host | nightside (10.3.0.3) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 目的主机 | nightside (10.3.0.3) |'
- en: '| Flags | DF |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | DF |'
- en: '| Time to live | 57 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 生存时间 | 57 |'
- en: '| Identification number | 4428 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 标识号 | 4428 |'
- en: '| No IP options (packet size = 20) |   |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 无IP选项（数据包大小 = 20） |   |'
- en: '| **Transmission Control Protocol** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **传输控制协议** |'
- en: '| Source port | 3803 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 源端口 | 3803 |'
- en: '| Destination port | 80 (HTTP) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 目标端口 | 80 (HTTP) |'
- en: '| Flags | SYN |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | SYN |'
- en: '| Sequence number | 1418000073 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 1418000073 |'
- en: '| Acknowledgment number | 0 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 确认号 | 0 |'
- en: '| Window size | 32120 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 窗口大小 | 32120 |'
- en: '| **TCP Options** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **TCP选项** |'
- en: '| #1 Maximum Segment Size | 1460 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| #1 最大分段大小 | 1460 |'
- en: '| #2 Selective ACK Permitted |   |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| #2 允许选择性确认 |   |'
- en: '| #3 Timestamp | 170330930 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| #3 时间戳 | 170330930 |'
- en: '| #4 Window scale | 0 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| #4 窗口缩放 | 0 |'
- en: 'A lot. Here’s what we can infer from these observations:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 很多。以下是我们可以从这些观察中推断出的内容：
- en: Because the DF flag in IP headers is set, the system must use path MTU discovery.
    Matching systems that use path MTU discovery are newer versions of Linux, FreeBSD,
    OpenBSD, Solaris, and Windows. We can rule out IRIX, AIX, many commercial firewalls,^([[20](#ftn.CHP-9-FN-6)])
    and other systems that do not implement PMTUD for reliability reasons.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为IP头中的DF标志被设置，系统必须使用路径MTU发现。使用路径MTU发现的匹配系统是Linux的新版本、FreeBSD、OpenBSD、Solaris和Windows。我们可以排除IRIX、AIX、许多商业防火墙^([[20](#ftn.CHP-9-FN-6)])以及其他出于可靠性原因不实现PMTUD的系统。
- en: The time to live of the packet is 57\. We know that the initial TTL value could
    not have been lower because it might only be decreased in transit, and it is unlikely
    that the value exceeds 87 (that would be a system really far away). We can match
    this with many Unixes (all of which use an initial TTL of 64) but we rule out
    Windows (with an initial TTL 128), versions of Solaris prior to 8 (255), and several
    network appliances (32).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包的生存时间（TTL）为57。我们知道初始TTL值不可能更低，因为它在传输过程中可能会降低，而且不太可能超过87（这将是一个非常远的系统）。我们可以将此与许多Unix系统（所有这些系统都使用初始TTL为64）相匹配，但我们排除了Windows（初始TTL为128）、Solaris
    8之前的版本（255）和几个网络设备（32）。
- en: The identification number of the packet is nonzero. This rules out Linux 2.4
    and newer versions, as well as several recent releases of other popular operating
    systems.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包的标识号不为零。这排除了Linux 2.4及更高版本，以及其他一些流行操作系统的最新版本。
- en: The source port falls in the most commonly used range (1,024 to 4,095). Although
    this alone doesn’t help us to exclude any systems, we can safely assume that the
    system had established more than 2,700 connections before this one and is unlikely
    to be behind a masquerade.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源端口位于最常用的范围内（1,024到4,095）。虽然这本身并不能帮助我们排除任何系统，但我们可以安全地假设，在这个连接之前，该系统已经建立了超过2,700个连接，并且不太可能隐藏在伪装背后。
- en: The option selection and ordering (MSS, Selective ACK, Timestamp, Window scaling)
    is specific to Linux 2.2 and newer.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项选择和排序（MSS、选择性ACK、时间戳、窗口缩放）是Linux 2.2及更高版本特有的。
- en: The window size is a multiple of MSS, that is MSS*22\. The only system that
    matches this is Linux 2.2.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口大小是MSS的倍数，即MSS*22。唯一符合这一条件的系统是Linux 2.2。
- en: There are no observed anomalies, RFC violations, or other quirks in the packet,
    which confirms the hypothesis that Linux is the system being run.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据包中没有观察到异常、RFC违规或其他怪异现象，这证实了Linux是正在运行的系统的假设。
- en: The Maximum Segment Size indicates an Ethernet or modem PPP connection (MTU
    of 1,500).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大分段大小指示以太网或调制解调器PPP连接（MTU为1,500）。
- en: The system’s uptime is approximately 19 days, and it is located 7 systems away.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的运行时间大约为19天，并且它位于7个系统之外。
- en: Certainly, single metrics can be modified by applications or user tweaks. (For
    example, users tend to modify TTL or enable or disable certain settings after
    reading network optimization guides or running “system doctor” applications.)
    However, by drawing a series of conclusions based on our observations we come
    up with a reliable way to determine the machine’s operating system by identifying
    the system that appears to be the best match in most categories.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单个指标可以被应用程序或用户调整所修改。（例如，用户倾向于在阅读网络优化指南或运行“系统医生”应用程序后修改TTL或启用或禁用某些设置。）然而，通过基于我们的观察得出一系列结论，我们找到了一种可靠的方法，通过识别在大多数类别中似乎是最匹配的系统来确定机器的操作系统。
- en: In this case, we have good reasons to believe that the system in question is
    Linux 2.2 and that the sender is connected to the Internet via Ethernet or dial-up
    modem. Based on this assumption, we can also conclude that the system is 7 hops
    away (64–57, where 64 is the initial TTL for Linux systems) and that its uptime
    is close to 20 days. If more users are hiding behind this particular IP, we can
    easily count them and differentiate their sessions based on their system characteristics
    and time-stamp data, if available.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有充分的理由相信所讨论的系统是Linux 2.2，并且发送者通过以太网或拨号调制解调器连接到互联网。基于这个假设，我们还可以得出结论，该系统距离7跳（64-57，其中64是Linux系统的初始TTL）并且其运行时间接近20天。如果更多用户隐藏在这个特定的IP后面，我们可以轻松地计数它们，并根据它们的系统特征和时间戳数据（如果有的话）区分它们的会话。
- en: '* * *'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[20](#CHP-9-FN-6)]) A firewall is essentially a filtering router, often also
    capable of understanding and making decisions based on higher-layer traffic characteristics.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#CHP-9-FN-6))) 防火墙本质上是一个过滤路由器，通常也具备理解和基于高层流量特征做出决策的能力。
- en: Exploring Passive-Fingerprinting Applications
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索被动指纹识别的应用
- en: When observed by either the recipient or a bystander (such as an ISP between
    the sender and the recipient), network traffic can provide information beyond
    the actual data exchanged, including certain parameters of the sender’s system.
    As suggested previously, the exposure is important and quite interesting because,
    unlike the data transmitted by applications, it is not necessarily obvious, and
    the disclosure is often beyond any user’s control. Although users can change their
    browser settings and those of other applications in order to prevent being monitored,
    identified, and tracked, the disclosure that occurs on the lower IP or TCP layer
    can easily undermine this effort by revealing to the observer just as much about
    the victim as the victim is trying to hide. It can also carry data of more fundamental
    significance to the security of the infrastructure, including some useful hints
    about how the victim’s network is constructed and protected.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当被接收者或旁观者（例如发送者和接收者之间的ISP）观察时，网络流量可以提供超出实际交换数据的信息，包括发送者系统的一些参数。正如之前所建议的，这种暴露很重要，也非常有趣，因为与应用程序传输的数据不同，它并不一定明显，而且披露往往超出了任何用户的控制。尽管用户可以更改浏览器设置和其他应用程序的设置，以防止被监控、识别和追踪，但较低IP或TCP层发生的披露很容易破坏这种努力，向观察者透露的信息与受害者试图隐藏的信息一样多。它还可以携带对基础设施安全具有更基本意义的数据，包括一些关于受害者网络结构和保护的有用提示。
- en: That said, short of privacy invasion, passive fingerprinting can also be useful
    for quite legitimate reconnaissance tasks. The set of practical (and commonly
    deployed) applications of passive fingerprinting extends through the entire ethical
    spectrum, from malice to rightful defense.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在没有侵犯隐私的情况下，被动指纹识别也可以用于相当合法的侦察任务。被动指纹识别的实用（和常见部署）应用范围涵盖了整个道德光谱，从恶意到正当防御。
- en: Collecting Statistical Data and Incident Logging
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集统计数据和事件记录
- en: One of the more legitimate uses for passive fingerprinting is that of monitoring
    the network to perform noninvasive and objective analysis of the platforms and
    network environments used, to ensure that users receive service that is optimized
    for their software, and to guarantee that no sizable group of users is neglected
    in some way. Too, gathering data about potential attackers or other unauthorized
    activity can be greatly enhanced by the use of passive fingerprinting. Indeed,
    passive fingerprinting is particularly popular in the field of honeypot research.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 被动指纹识别的一个更合法的用途是监控网络，以执行对平台和网络环境的非侵入性和客观分析，以确保用户获得针对其软件优化的服务，并保证没有大规模的用户群体以某种方式被忽视。此外，通过使用被动指纹识别，收集有关潜在攻击者或其他未授权活动的数据可以大大增强。事实上，被动指纹识别在蜜罐研究领域特别受欢迎。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Honeypots are a concept aggressively promoted and researched by Lance Spitzner
    of Sun Microsystems.^([[84](apb.html#ftn.CHP-9-BIB-11)]) The goal is to let the
    owner learn about their opponents and their goals, using devices (honeypots) whose
    value lies in their unauthorized and illicit use and that have no actual significance
    for the infrastructure, although they are designed to appear as if they do.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜罐是Sun Microsystems的Lance Spitzner积极推广和研究的一个概念。[^([[84](apb.html#ftn.CHP-9-BIB-11))]]
    目标是让所有者了解他们的对手及其目标，使用（蜜罐）这种设备的价值在于其未经授权和非法使用，并且对基础设施没有任何实际意义，尽管它们被设计成看起来好像有。
- en: Content Optimization
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容优化
- en: 'One active application for passive fingerprinting relies on providing services
    optimized for a specific recipient based on an immediate analysis of the setup
    they are using to access the server. I consider it my duty to include a shameless
    plug here for one of my aforementioned tools, p0f. p0f offers a method for querying
    it about the parameters of recent incoming connections from other applications,
    which makes the task of content optimization much easier: a web script does not
    have to know a lot about TCP and IP, can simply ask p0f, “Hey, who is that guy
    I am talking with?” and then get a useful response.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 被动指纹识别的一个活跃应用是基于对客户端使用来访问服务器的设置进行即时分析，提供针对特定接收者的优化服务。我认为我有责任在这里无耻地推荐我之前提到的一个工具，p0f。p0f提供了一种查询其关于来自其他应用程序的最近传入连接参数的方法，这使得内容优化的任务变得容易得多：一个网络脚本不需要了解很多TCP和IP，只需简单地问p0f，“嘿，我和谁在说话？”然后就会得到一个有用的响应。
- en: Policy Enforcement
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略执行
- en: The detection and eventual blocking of obsolete or noncompliant systems (say,
    devices that violate a corporate policy or pose a security risk) or infestations
    of unauthorized network hookups is another interesting application for passive
    fingerprinting. Since version 3.4, OpenBSD has provided a method for routing and
    redirecting traffic based on the operating system detection results, hence making
    policy enforcement based on remote operating system characteristics quite viable.
    The same functionality is now provided as a part of Linux netfilter patch-o-matic
    code. Both implementations are closely inspired by or based on p0f.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 检测和最终阻止过时或不合规的系统（例如，违反企业政策或构成安全风险的设备）或未经授权的网络连接的侵扰是被动指纹识别的另一个有趣应用。自3.4版本以来，OpenBSD提供了一种基于操作系统检测结果进行路由和重定向流量的方法，因此基于远程操作系统特性的策略执行变得相当可行。现在，同样的功能作为Linux
    netfilter patch-o-matic代码的一部分提供。这两个实现都受到了p0f的密切启发或基于p0f。
- en: Poor Man’s Security
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贫民窟式安全
- en: Passive fingerprinting can also be used to minimize certain types of exposure.
    Although with some effort it is possible to fool the fingerprinting technique,
    fingerprinting might be used to prevent certain types of clients (such as Windows
    systems, a platform most commonly infested with spyware, backdoors, and worms
    and often used for unsolicited mass email distribution or attack hops) from using
    certain underlying services on the network, while allowing “less suspect” entities
    to access them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 被动指纹识别也可以用来最小化某些类型的暴露。尽管经过一些努力可以欺骗指纹识别技术，但指纹识别可能被用来阻止某些类型的客户端（例如Windows系统，这是一个最常被间谍软件、后门和蠕虫感染的平台，通常被用于未经请求的大规模电子邮件分发或攻击跳转）使用网络上的某些底层服务，同时允许“不太可疑”的实体访问它们。
- en: Security Testing and Preattack Assessment
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全测试和预先攻击评估
- en: Active fingerprinting is often stopped in its tracks by firewalls and other
    solutions that carefully filter and analyze IP traffic. Passive fingerprinting,
    however, can examine even aggressively protected systems and can map networks
    without triggering any alerts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 活动指纹识别通常会被防火墙和其他仔细过滤和分析IP流量的解决方案阻止。然而，被动指纹识别可以检查甚至受到积极保护的系统，并且可以在不触发任何警报的情况下绘制网络图。
- en: The approach to security testing and assessment using passive fingerprinting
    is twofold. First, it can be used to analyze incoming traffic. Although the observer
    must wait for the remote party to connect to their systems, such a connection
    can be quite easily induced without triggering suspicion. In fact, it is often
    sufficient to send a specific email or a link to a website to the victim behind
    even the most sophisticated packet-filtering solution. Second, passive fingerprinting
    can be used to analyze the responses to legitimate traffic to an available service
    in order to determine the remote party’s parameters. If a black-hat hacker knows
    how to compromise an internal network, but wants to know more about its internals
    in order to minimize the risk of being detected prematurely, passive fingerprinting
    can come in handy. The same can be said about legitimate security testing for
    which one is paid by the entity that undergoes the test.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用被动指纹技术进行安全测试和评估的方法有两个方面。首先，它可以用来分析传入流量。尽管观察者必须等待远程方连接到他们的系统，但这种连接可以非常容易地诱导而不会引起怀疑。事实上，通常只需向受害者发送一封特定的电子邮件或一个指向网站的链接，即使是最复杂的包过滤解决方案也无法检测到。其次，被动指纹技术可以用来分析对可用服务的合法流量的响应，以确定远程方的参数。如果一个黑帽黑客知道如何破坏内部网络，但想了解更多关于其内部的信息，以最大限度地减少被过早检测到的风险，那么被动指纹技术可能会派上用场。同样，这也可以适用于为进行测试的实体付费的合法安全测试。
- en: Customer Profiling and Privacy Invasion
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户配置文件和隐私侵犯
- en: Many companies go to great lengths to gather and sell valuable information about
    people’s habits, preferences, and behavior. Although this information is usually
    used for marketing purposes, it could—in theory—be used against a specific person.
    The ability to track users by correlating fingerprinting results from several
    locations that they have visited, whether to map internal networks and software
    used, track individuals, or gather other valuable statistical data, can be a source
    of information that might either have considerable value by itself or be used
    to enhance the attractiveness of other not-quite-ethical offerings.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司不遗余力地收集和出售有关人们习惯、偏好和行为的有价值信息。尽管这些信息通常用于营销目的，但理论上可以用来针对特定个人。通过关联他们在多个地点访问的指纹识别结果来跟踪用户的能力，无论是为了绘制内部网络和使用的软件、追踪个人还是收集其他有价值的数据，这可能是一种信息来源，它本身可能具有相当大的价值，或者可以用来增强其他不太道德的提供的吸引力。
- en: Espionage and Covert Reconnaissance
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间谍活动和秘密侦察
- en: The ability to gather additional information about a competitor’s network architecture
    and user behavior and preferences is often quite tempting. Though this may sound
    like bad science-fiction, it is simply a more targeted type of the profiling discussed
    above.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 收集有关竞争对手网络架构和用户行为及偏好的额外信息通常非常有吸引力。尽管这听起来可能像糟糕的科幻小说，但这实际上只是上述讨论的配置文件类型的一种更精确的形式。
- en: Prevention of Fingerprinting
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止指纹识别
- en: Given the complexity of a typical IP stack, it is extremely difficult to prevent
    fingerprinting in general, but it is possible to address specific issues and disable
    specific types of known fingerprinting software by determining what parameter
    it relies on most and then changing it. For example, certain packet-filtering
    solutions, such as `pf` in OpenBSD, provide a packet normalization service that
    ensures that all outgoing traffic “looks the same.” Although this might prevent
    some aspects of fingerprinting to some degree or might simply make finger-printing
    more difficult by rendering some popular programs less accurate, it does not solve
    the problem completely.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于典型IP堆栈的复杂性，通常很难防止指纹识别，但可以通过确定它最依赖的参数并对其进行更改，来解决特定问题并禁用已知指纹识别软件的特定类型。例如，某些包过滤解决方案，如OpenBSD中的`pf`，提供了一种包标准化服务，确保所有传出流量“看起来相同”。尽管这可能在一定程度上防止了指纹识别的一些方面，或者可能只是通过使一些流行的程序不够准确而使指纹识别更加困难，但它并没有完全解决问题。
- en: Although the thorough and seemingly exhaustive manual or automated modification
    of certain operating system settings or TCP parameters can make system identification
    more difficult, certain behaviors are buried deep in the kernel and are not customizable.
    For example, it is fairly difficult to change the option ordering in a packet.
    Moreover, when users make manual modifications, they risk introducing unique characteristics
    into packets originating from their system, which only further affects their privacy
    and anonymity.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管彻底和看似详尽的操作系统设置或TCP参数的修改或自动化修改可能会使系统识别变得更加困难，但某些行为深深埋藏在内核中，并且不可定制。例如，改变数据包中的选项顺序相当困难。此外，当用户进行手动修改时，他们可能会将独特的特征引入来自他们系统的数据包中，这只会进一步影响他们的隐私和匿名性。
- en: Fortunately, certain solutions do address specific types of testing. For example,
    IP Personality by Gael Roualland and Jean-Marc Saffroy alters the TCP stack so
    that it appears to specific tools as if it comes from a different operating system.
    If you fancy, you can use IP Personality to make NMAP think that your system is
    a Hewlett-Packard laser printer. However, some problems arise. For one, it is
    easy to actually weaken a system’s TCP stack by attempting to impersonate a device
    that uses a weak stack to begin with. For example, if, in order to comply with
    a printer’s particular characteristics, you use trivial sequence numbers on all
    connections, someone will sooner or later take advantage of this to easily disrupt
    or tamper with your traffic. Too, software such as IP Personality will only work
    against the most popular, well-known, and well-documented tools, but it offers
    no guarantee of success against the rest, because the characteristics examined
    by each tool and the way these characteristics are interpreted are different from
    place to place. You can only hope to fool the least determined, most naive, “mainstream”
    attackers who use tools you know about.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，某些解决方案确实解决了特定类型的测试。例如，Gael Roualland和Jean-Marc Saffroy的IP Personality通过修改TCP堆栈，使其对特定工具看起来像来自不同的操作系统。如果你喜欢，你可以使用IP
    Personality让NMAP认为你的系统是一个惠普激光打印机。然而，也会出现一些问题。首先，试图模仿使用弱堆栈的设备实际上可能会削弱系统的TCP堆栈。例如，如果你为了符合打印机的特定特性，在所有连接上使用简单的序列号，那么有人迟早会利用这一点来轻易地干扰或篡改你的流量。此外，像IP
    Personality这样的软件只能针对最流行、最知名、最文档化的工具，但它对其他工具的成功没有保证，因为每个工具检查的特征以及这些特征的解释方式在不同地方是不同的。你只能希望愚弄那些最不坚定、最天真、使用你已知工具的“主流”攻击者。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike masquerading agents, proxy-type firewalls and other proxy devices do
    not forward packets, but intercept connections instead and initiate new ones using
    their own IP stack. These are the only complete solution to third and fourth OSI
    layer finger-printing, but they have a serious impact on performance and are more
    prone to problems due to introducing vastly increased complexity. Besides, a higher-level
    fin-gerprinting of the application itself is still possible.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与伪装代理不同，代理类型防火墙和其他代理设备不会转发数据包，而是拦截连接并使用它们自己的IP堆栈启动新的连接。这些是解决第三和第四OSI层指纹的唯一完整解决方案，但它们对性能有严重影响，并且由于引入了极大的复杂性，更容易出现问题。此外，对应用程序本身的更高层指纹识别仍然是可能的。
- en: 'Food for Thought: The Fatal Flaw of IP Fragmentation'
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考：IP分片致命缺陷
- en: While discussing the defining features of the Internet Protocol, I casually
    mentioned that the process of packet fragmentation and reassembly is fatally flawed.
    This notion comes primarily from a fairly interesting observation I had while
    writing this book. Although the concept is related to an active and noticeable
    attack performed by an openly rogue entity (although it is not easily traceable
    back to that entity), it is a unique and interesting flaw inherent in the design
    of the Internet Protocol. It is not the result of a clearly defined mistake, but
    more a collision of paradigms on different design layers, both, curiously, specified
    by Jon Postel, one of the fathers of IP suite. I have decided to include it here
    to close this chapter, as food for thought for those interested in the pathology
    of computer flaws.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论互联网协议的标志性特征时，我随意地提到，数据包分片和重组的过程存在致命的缺陷。这个观点主要来源于我在撰写本书时一个相当有趣的观察。尽管这个概念与一个活跃且明显的攻击有关，该攻击由一个公开的恶意实体执行（尽管很难追溯到该实体），但它却是互联网协议设计中固有的独特且有趣的缺陷。这并非一个明确定义的错误的结果，而更多是不同设计层上范式冲突的结果，这两者都由IP套件的创始人之一乔恩·波斯特尔（Jon
    Postel）奇特地指定。我决定将其包含在这里，作为对那些对计算机缺陷病理感兴趣的人的思考材料。
- en: First, let’s look at the state of affairs today, or perhaps yesterday, as we
    are dusting off a fairly old attack technique, mentioned previously in the TCP
    discussion. The technique in question, *blind spoofing*, was first described by
    Robert T. Morris in the mid ’80s.^([[85](apb.html#ftn.CHP-9-BIB-12)]) It had its
    golden age a decade later, but its significance has decreased ever since. We’ll
    focus on a specific example of blind spoofing, that of injecting certain data
    into an existing session, to disrupt it, to convince the server that its user
    has issued a specific command, or to convince the user that they are getting a
    specific response from the server. This technique is often referred to as *connection
    hijacking*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看今天的状况，或者可能是昨天，因为我们正在回顾一个相当古老的攻击技术，在之前的TCP讨论中已经提到。这个技术，即*盲注攻击*，最初由罗伯特·T·莫里斯（Robert
    T. Morris）在20世纪80年代中期描述。[^([85](apb.html#ftn.CHP-9-BIB-12))] 它在其十年后的黄金时代达到了顶峰，但自那以后其重要性已经降低。我们将关注盲注攻击的一个具体例子，即将某些数据注入现有会话中，以破坏它，让服务器相信其用户已发出特定命令，或者让用户相信他们正在从服务器获得特定响应。这种技术通常被称为*连接劫持*。
- en: Under normal circumstances, a malicious bystander, wanting to insert data into
    an existing TCP stream, first needs to determine the sequence numbers used by
    at least one of the parties. Even though such an attack is highly time sensitive
    and must be targeted against a specific, existing connection, it can be (and has
    been, many times) performed successfully when the sequence numbers are predictable.
    In fact, in the late 1990s, many tools were used to disrupt Windows TCP sessions
    to Internet Relay Chat (IRC) networks (for amusement or other), exploiting the
    Windows weak initial sequence number (ISN) selection algorithm; it was trivial
    to inject a single RST packet here and there, kicking a person off the chat server.
    This is what we called fun back then.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，一个恶意旁观者想要将数据注入现有的TCP流中，首先需要确定至少一方使用的序列号。尽管这种攻击高度时间敏感，并且必须针对特定的现有连接进行，但当序列号可预测时，它可以（并且已经被多次成功执行）执行。事实上，在20世纪90年代末，许多工具被用来干扰Windows
    TCP会话到互联网中继聊天（IRC）网络（为了娱乐或其他目的），利用Windows脆弱的初始序列号（ISN）选择算法；在这里注入单个RST数据包是微不足道的，这会将一个人从聊天服务器上踢出去。这就是我们当时所说的乐趣。
- en: Today, the situation is a bit different. Thanks to the efforts of many researchers
    (including the most humble author of these words), developers have worked hard
    to make initial sequence numbers in TCP connections more difficult to predict.
    Many attempts to improve the quality and strength of sequence number generators
    in popular operating systems have, in the end, rendered ISN prediction attacks
    harder, with few rather unnoteworthy exceptions. Systems that use sequential ISN
    numbers are largely extinct; an attacker, unable to determine the numbers used
    in a conversation with another party, is forced to search the entire 32-bit space
    of possible values in order to perform a precise data insertion attack (fewer
    if they only want to abort or irrecoverably mangle the session). That’s some 4,294,967,296
    combinations, and an attack like this requires the attacker to send an average
    of about 80 GB of data in order for it to succeed. Needless to say, this is not
    considered particularly feasible.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，情况略有不同。多亏了许多研究者的努力（包括这些文字最谦卑的作者），开发人员努力使TCP连接的初始序列号更难以预测。许多尝试改进流行操作系统中序列号生成器质量和强度的尝试，最终使得ISN预测攻击变得更加困难，只有少数相当不引人注目的例外。使用顺序ISN号的系统在很大程度上已经灭绝；攻击者无法确定与另一方对话中使用的数字，被迫在整个32位可能值空间中搜索，以便执行精确的数据插入攻击（如果他们只想终止或永久损坏会话，则更少）。这大约有4,294,967,296种组合，这种攻击要求攻击者平均发送大约80
    GB的数据才能成功。不用说，这并不被认为特别可行。
- en: However, as to the actual benefits you can gain from a successful data injection
    attack, little has changed. Even though an increasing amount of communication
    is exchanged over channels that support encryption, the relevance of this type
    of attack has not decreased significantly; plenty of fruitful attack scenarios
    persist. Here are some examples.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于从成功的数据注入攻击中可以获得的实际好处，几乎没有变化。尽管越来越多的通信是在支持加密的通道中进行的，但此类攻击的相关性并没有显著下降；许多有成果的攻击场景仍然存在。以下是一些例子。
- en: Data can be inserted into unencrypted server-to-server or router-to-router traffic,
    such as an email exchange, DNS zone transfers, BGP communications, and so on.
    Much of the server-to-server traffic can be generated by the attacker and yet
    contain sensitive or trusted information, which makes a targeted and timed attack
    more feasible.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以被插入到未加密的服务器到服务器或路由器到路由器流量中，例如电子邮件交换、DNS区域传输、BGP通信等。大量服务器到服务器的流量可以由攻击者生成，同时包含敏感或受信任的信息，这使得有针对性的定时攻击更加可行。
- en: Data can be inserted into unencrypted client-to-server traffic, such as File
    Transfer Protocol (FTP) file downloads or HyperText Transfer Protocol (HTTP) responses.
    This attack can be used allow malicious, incriminating, or derogatory content
    to be provided to a visitor to a high-profile server or to make it appear as if
    a compromise attempt originates from an innocent visitor.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以被插入到未加密的客户端到服务器流量中，例如文件传输协议（FTP）文件下载或超文本传输协议（HTTP）响应。这种攻击可以用来向知名服务器的访问者提供恶意、有罪或贬低的内容，或者使其看起来像妥协尝试来自无辜的访问者。
- en: Data can be inserted into an existing session to exploit a vulnerability in
    the service at a stage that is not available to a nonauthenticated user. This
    applies both to encrypted and unencrypted traffic. For example, a service such
    as POP3 (point of presence, a remote mailbox access protocol) can accept various
    commands only if the user previously successfully logged in. Prior to logging
    in, the only commands available are those that directly pertain to the authentication
    process (`USER` and `PASS` directives). Without a valid password, the attacker
    cannot exploit a flaw in one of the commands available later (such as `RETR`,
    a command used to fetch a specific message from a mailbox). However, if the attacker
    manages to inject a malicious RETR request into an existing session of an already
    authenticated user, they win.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以被插入到现有的会话中，以利用服务在非认证用户无法访问的阶段存在的漏洞。这既适用于加密流量，也适用于未加密流量。例如，像POP3（存在点，远程邮箱访问协议）这样的服务只能接受各种命令，前提是用户之前成功登录。在登录之前，可用的唯一命令是直接与认证过程相关的命令（如`USER`和`PASS`指令）。如果没有有效的密码，攻击者无法利用后来可用的某个命令（如用于从邮箱中检索特定消息的`RETR`命令）中的漏洞。然而，如果攻击者能够将恶意的RETR请求注入到已认证用户的现有会话中，他们就会获胜。
- en: Even a secure and encrypted, integrity-protected stream is susceptible to a
    denial of service attack when a session is disrupted or terminated by a single,
    carefully crafted packet.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是安全且加密的、完整性受保护的数据流，在会话被单个精心制作的包中断或终止时，也容易受到拒绝服务攻击。
- en: As such, it is tempting to be able to inject data with little effort, without
    having to go through the entire spectrum of possible sequence numbers. And this
    is where fragmentation comes in quite handy.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够轻松注入数据，而无需遍历所有可能的序列号范围，这很诱人。而这就是碎片化大有用武之地。
- en: Breaking TCP into Fragments
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将TCP拆分为碎片
- en: When an IP packet carrying a TCP payload is fragmented (arguably, a common occurrence
    during file transfers, and one that is not always prevented simply by setting
    the DF flag as some systems do), the data is traveling the network in multiple
    chunks and is reassembled only when it arrives at the recipient. A clever attacker,
    in anticipation of this fragmentation, can send a specially crafted, illegitimate
    IP fragment, masquerading as one from the expected sender. Upon receiving this
    fragment, the recipient might, with some luck (a matter of precise timing), end
    up using it instead of the real fragment in the reassembly of the original packet.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当携带TCP有效负载的IP数据包被拆分（可以说，在文件传输中这是一个常见的情况，而且仅仅通过设置DF标志并不能总是防止这种情况，就像一些系统所做的那样），数据就会在网络中以多个块的形式传输，并且只有在到达接收方时才会重新组装。一个聪明的攻击者，在预料到这种拆分的情况下，可以发送一个特别定制的、非法的IP碎片，伪装成来自预期发送者的碎片。在接收到这个碎片后，接收方可能会（如果运气好的话，这是一个精确时间的问题），最终使用它而不是真正的碎片来重新组装原始数据包。
- en: In this attack scenario, the first fragment (containing the full TCP headers,
    including exact ports, sequence numbers, and so on) is merged with a malicious
    payload spoofed by the attacker. As a result, the attacker need not know sequence
    numbers or other session parameters to insert their data into the frame, thus
    effectively undermining the entire ISN-generation effort. Once the attack is complete,
    the final packet processed by the recipient consists of valid header data copied
    from a legitimate fragment and a malicious payload injected by the attacker.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个攻击场景中，第一个碎片（包含完整的TCP头部，包括确切的端口、序列号等）与攻击者伪造的恶意有效负载合并。因此，攻击者不需要知道序列号或其他会话参数，就可以将他们的数据插入帧中，从而有效地破坏整个ISN生成过程。一旦攻击完成，接收方最终处理的数据包由从合法碎片复制来的有效头部数据和攻击者注入的恶意有效负载组成。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The attacker can replace any part of the payload in the first fragment by specifying
    a slight overlap between the fragments; many systems honor overlaps between fragments
    and overwrite previously received data with a newer copy. In an extreme case,
    the attacker can successfully replace all the data within a TCP packet except
    for the sequence number.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过在碎片之间指定轻微的重叠来替换第一个碎片中的任何部分；许多系统都尊重碎片之间的重叠，并用较新的副本覆盖之前接收到的数据。在极端情况下，攻击者可以成功替换TCP数据包中的所有数据，除了序列号。
- en: 'Naturally, some pieces of the puzzle are still missing. But, other than the
    need for precise timing and a knowledge of when the transmission is occurring,^([[21](#ftn.CHP-9-FN-7)])
    the attacker in this scenario must overcome only two obstacles:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，拼图中的一些部分仍然缺失。但是，除了需要精确的时间和了解传输发生的时间之外^([[21](#ftn.CHP-9-FN-7)))，在这个场景中的攻击者必须克服仅有的两个障碍：
- en: The fragment must have a correct IP ID number in order for it to be merged in.
    Thankfully, on many systems, this is not a problem, because IP identifiers are
    chosen sequentially. As such, the number likely to be used at the moment can be
    deduced simply by attempting a test connection. Some systems, most notably OpenBSD,
    FreeBSD, and Solaris, offer randomized ID numbers, which might make the attack
    more difficult but will still not prevent it. The attacker simply has to check
    thousands (not billions) of combinations, because the IP ID field is fairly small
    (only two bytes).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碎片必须有一个正确的IP ID号才能被合并。幸运的是，在许多系统中，这并不是一个问题，因为IP标识符是按顺序选择的。因此，当前可能使用的数字可以通过尝试测试连接来简单地推断出来。一些系统，特别是OpenBSD、FreeBSD和Solaris，提供随机化的ID号，这可能会使攻击更加困难，但仍然不能阻止它。攻击者只需检查数千（而不是数十亿）种组合，因为IP
    ID字段相当小（只有两个字节）。
- en: The TCP header contains a checksum that is verified after reassembly, and the
    checksum of the data modified by the attacker must be the same as that of the
    original payload. However, because the design of a TCP checksum is trivial (simply
    a variation of a straight 16-bit sum), you can craft a payload that does not alter
    the packet’s checksum, as long as the original section to be replaced is known
    to the attacker. (This is most often the case, particularly during file transfers
    when the attacker wants to insert malicious code or contents in a publicly available
    portion of data.)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 头部包含一个校验和，在重组后进行验证，攻击者修改的数据的校验和必须与原始有效载荷的校验和相同。然而，由于 TCP 校验和的设计非常简单（只是一个直接的
    16 位和的变体），你可以构建一个不改变数据包校验和的有效载荷，只要攻击者知道要替换的原始部分。这种情况最常见，尤其是在文件传输期间，攻击者想在公开可用的数据部分插入恶意代码或内容。
- en: 'The following simplified checksum of a packet that consists of header words
    H1 and H2 and of payload words P1, P2, and P3 illustrates:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个由头部单词 H1 和 H2 以及有效载荷单词 P1、P2 和 P3 组成的数据包的简化校验和示例：
- en: '| C = H1 + H2 ... + P1 + P2 + P3 ... |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| C = H1 + H2 ... + P1 + P2 + P3 ... |'
- en: H1, H2, and C are not known to the attacker. (Headers contain sequence numbers,
    and the checksum is affected by this data.) The attacker has no way to actually
    examine this packet, but knows that the victim performs a specific (predictable)
    transaction on the application level (for example, checks their mail, downloads
    a web page, chats with friends, and so on). The attacker can deduce the payload
    data P1, P2, and P3 and wants to replace it with their own malicious words N1
    and N2, using a third word for checksum compensation (CC) so that the packet still
    validates.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: H1、H2 和 C 对攻击者来说是未知的。（头部包含序列号，校验和受此数据影响。）攻击者实际上无法检查这个数据包，但知道受害者会在应用层执行特定的（可预测的）交易（例如，检查他们的邮件，下载网页，与朋友聊天等）。攻击者可以推断出有效载荷数据
    P1、P2 和 P3，并希望用他们自己的恶意单词 N1 和 N2 来替换它，使用第三个单词作为校验和补偿（CC），以便数据包仍然有效。
- en: '| C = H1 + H2 ... + N1 + N2 + CC ... |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| C = H1 + H2 ... + N1 + N2 + CC ... |'
- en: Solving these equations for CC, we conclude that the checksum must be compensated
    with CC = (P1 + P2 + P3 - N1 - N2). The attacker can then modify the packet so
    that the checksum remains the same without knowing the entire packet; they simply
    need the replaced bit. This is enough to calculate the compensation bit correctly
    and to preserve the checksum.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 解这些方程式以得到 CC，我们得出结论，校验和必须通过 CC = (P1 + P2 + P3 - N1 - N2) 来补偿。攻击者可以修改数据包，使校验和保持不变，而无需知道整个数据包；他们只需要替换的位。这足以正确计算补偿位并保留校验和。
- en: '* * *'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[21](#CHP-9-FN-7)]) Timing itself is not as much of a problem as it might
    appear at first. The attacker can choose to send their malicious second fragment
    slightly in advance; the recipient then creates a reassembly buffer and waits
    for the remaining parts to arrive within a certain period of time. Once the first
    legitimate fragment arrives, the buffer contents are considered fully reconstructed,
    without waiting for the real second chunk to arrive.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-9-FN-7)]) 计时本身并不像最初看起来那样成问题。攻击者可以选择提前发送他们的恶意第二个片段；接收者随后创建一个重组缓冲区，并等待剩余部分在一定时间内到达。一旦第一个合法片段到达，缓冲区内容就被认为是完全重建的，无需等待真正的第二个块到达。
- en: Chapter 10. Advanced Sheep-Counting Strategies
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。高级羊计数策略
- en: '*Where we dissect the ancient art of determining network architecture and computer’s
    whereabouts*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里我们剖析确定网络架构和计算机位置的古艺术*'
- en: —
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: Network reconnaissance and mapping is the art of exploiting a set of information
    disclosure vectors inherent in the Internet’s core communications protocols in
    order to recognize systems and networks or to identify and track potential offenders,
    users, customers, or competitors. It is perhaps the most developed, most widely
    deployed, and most significant and immediately useful application of passive data
    analysis to date, but it has its share of problems that affect both its accuracy
    and usability in certain scenarios. This is particularly true for known and tested
    TCP/IP passive fingerprinting techniques.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 网络侦察和映射是利用互联网核心通信协议中固有的信息泄露向量来识别系统和网络或识别和追踪潜在违法者、用户、客户或竞争对手的艺术。这可能是迄今为止最发达、最广泛部署、最具有意义和最直接有用的被动数据分析应用，但它也存在一些问题，这些问题影响了其在某些场景下的准确性和可用性。这对于已知和测试过的
    TCP/IP 被动指纹识别技术尤其如此。
- en: Benefits and Liabilities of Traditional Passive Fingerprinting
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统被动指纹识别的利弊
- en: Use of the passive fingerprinting metrics discussed in the previous chapter
    will let you easily identify some characteristics of an originating system and
    network. Too, in some cases, these techniques will make it possible to trace individuals
    as they change their address or share it with other users of a single network.
    You can employ these techniques without interacting with the remote party as long
    as you can persuade the observed earthling to interact with a specific network
    or for as long as their network communications passes through a specific set of
    systems controlled by a sufficiently curious person. Thus, passive fingerprinting,
    among other uses, enables a server owner or a specific ISP to acquire massive
    and completely stealthy information rather easily.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章中讨论的被动指纹识别度量标准将使你能够轻松地识别源系统和网络的一些特征。此外，在某些情况下，这些技术将使追踪个人在更改地址或与其他单个网络用户共享地址时成为可能。只要你能够说服被观察的地球人（地球人）与特定网络互动，或者只要他们的网络通信通过一个足够好奇的人控制的特定系统集，你就可以使用这些技术而无需与远程方互动。因此，除了其他用途之外，被动指纹识别使服务器所有者或特定的ISP能够轻易地获取大量且完全隐蔽的信息。
- en: Passive fingerprinting provides such a remote party with a two-edged sword.
    You can deploy it to obtain useful data about the internal structure of a network,
    in order to make an attack easier or to learn more about the networking technologies
    used (even in a fairly complex environment, as shown in [Figure 10-1](ch10.html#you_can_use_passive_fingerprinting_to_ma
    "Figure 10-1. You can use passive fingerprinting to map a complex and even inaccessible
    network simply by observing traffic from some of the nodes (the most important
    being measuring operating system characteristics, TTL, and MSS values on packets)
    and then deducing the presence of other components to match the observed characteristics
    variances. It is left to the reader to determine how this network could be conclusively
    mapped out by merely observing traffic on the outside.")). You can also use it
    (quite rightfully) to monitor your own network for policy violations (such as
    illegal connections or access points that connect an internal network with the
    outside world) or to track attackers.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 被动指纹识别为第三方提供了一把双刃剑。你可以部署它来获取有关网络内部结构的有用数据，以便使攻击更容易或更深入地了解所使用的网络技术（即使是在相当复杂的环境中，如[图10-1](ch10.html#you_can_use_passive_fingerprinting_to_ma
    "图10-1. 你可以通过观察某些节点（最重要的是测量数据包上的操作系统特征、TTL和MSS值）的流量，然后推断其他组件的存在以匹配观察到的特征差异，从而简单地映射一个复杂甚至无法访问的网络。剩下的工作留给读者去确定仅通过观察外部流量如何最终映射出这个网络。"))，以便使攻击更容易或更深入地了解所使用的网络技术。你也可以（完全有理由）用它来监控自己的网络以发现违规行为（如非法连接或连接内部网络与外部世界的接入点）或追踪攻击者。
- en: The resulting privacy loss for a single user is generally negligible, unless
    the ability to link casual activities performed by a user with the additional
    data acquired by fingerprinting, or the ability to track a single user across
    domains, is a particular problem (this is most likely true only when the user’s
    behavior is questionable to begin with). But the cumulative loss of privacy for
    all users could be quite worrisome, and the information gathered through fingerprinting
    or fingerprinting-assisted tracking can pose a noticeable market value. (Your
    personal data can be sold for much more to advertisers if it is combined with
    information about your preferences and interests, for example.) Too, the exposure
    of the technical inner workings of a network can indeed be undesirable for corporations
    and other portions of sensitive infrastructure.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个用户而言，由此产生的隐私损失通常是可以忽略不计的，除非将用户偶然进行的活动与通过指纹识别获得的附加数据联系起来，或者追踪单个用户跨域的能力是一个特定问题（这很可能只有在用户的行为一开始就值得怀疑的情况下才是真的）。但是，所有用户隐私的累积损失可能会非常令人担忧，通过指纹识别或辅助跟踪收集的信息可能会具有明显的市场价值。（如果你的个人数据与你的偏好和兴趣信息相结合，它可以卖给广告商的价格会更高。）此外，暴露网络的内部技术运作确实可能对公司和敏感基础设施的其他部分来说是不受欢迎的。
- en: Nevertheless, not all is lost just yet. As indicated previously, there are some
    problems with using passive fingerprinting to obtain accurate results. The reliability
    problem with traditional passive operating system finger-printing technique stems
    from how easy it is to fool the observer by carefully tweaking some or all the
    network settings used by a system that is subject to observation. Even if completely
    altering all settings is not particularly easy, a partial modification might be
    enough to thwart certain automated analysis attempts (hooray!) or mislead a researcher
    investigating a malicious incident (oops). Although not a large-scale problem,
    and thus not a concern for statistical analysis, the reliability issue can cause
    concern in individual cases.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，目前还没有完全失去希望。正如之前所指出的，使用被动指纹识别来获得准确结果存在一些问题。传统被动操作系统指纹识别技术的可靠性问题源于通过仔细调整受观察系统使用的某些或所有网络设置来欺骗观察者的容易程度。即使完全更改所有设置并不特别容易，部分修改可能足以阻止某些自动化分析尝试（万岁！）或误导调查恶意事件的研究人员（哎呀）。尽管这不是一个大规模问题，因此不是统计分析的担忧，但可靠性问题可能在个别情况下引起关注。
- en: Moreover, the user tracking and counting capabilities of the finger-printing
    approach we painfully dissected in [Chapter 9](ch09.html "Chapter 9. Foreign Accent")
    rely almost entirely on the availability of parameters such as the time-stamp
    information in TCP/IP packets. All other characteristics are either standardized
    or have too few possible options to provide a unique positive identification of
    a single computer, except in the most unusual cases. If such data is unavailable
    because this particular performance extension is disabled (as with most Windows
    systems, for example), the precise identification of a system is not possible.
    This lowers the potential value of the data both to members of an overzealous,
    evil conspiracy cabal (that, as we all know, is after our most precious secrets),
    as well as to security testers or incident analysts (computer forensics experts).
    Without this time stamp–based identification capability, it can be impossible
    to differentiate several identical systems running behind a masquerade or to identify
    an individual whose IP was changed once they reconnected their modem.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在第9章（[第9章. 外国口音](ch09.html "Chapter 9. Foreign Accent"））中痛苦地剖析的指纹识别方法的用户跟踪和计数能力几乎完全依赖于TCP/IP数据包中时间戳信息等参数的可用性。所有其他特征要么是标准化的，要么可选的选项太少，无法为单个计算机提供唯一的正确定义，除非在非常罕见的情况下。如果由于这种特定的性能扩展被禁用（例如，在大多数Windows系统中），则无法精确识别系统。这降低了数据对过度热情、邪恶阴谋集团成员（正如我们所知，他们正在追捕我们最珍贵的秘密）以及安全测试人员或事件分析师（计算机取证专家）的潜在价值。如果没有基于时间戳的识别能力，可能无法区分在伪装背后运行的几个相同系统，或者在他们重新连接调制解调器后识别IP已更改的个体。
- en: '![You can use passive fingerprinting to map a complex and even inaccessible
    network simply by observing traffic from some of the nodes (the most important
    being measuring operating system characteristics, TTL, and MSS values on packets)
    and then deducing the presence of other components to match the observed characteristics
    variances. It is left to the reader to determine how this network could be conclusively
    mapped out by merely observing traffic on the outside.](httpatomoreillycomsourcenostarchimages1138068.png.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![您可以使用被动指纹识别通过观察某些节点（最重要的是测量操作系统特征、TTL和MSS值）的流量来映射一个复杂甚至无法访问的网络，然后推断其他组件的存在以匹配观察到的特征差异。留给读者去确定如何仅通过观察外部的流量来最终绘制出这个网络。](httpatomoreillycomsourcenostarchimages1138068.png.jpg)'
- en: Figure 10-1. You can use passive fingerprinting to map a complex and even inaccessible
    network simply by observing traffic from some of the nodes (the most important
    being measuring operating system characteristics, TTL, and MSS values on packets)
    and then deducing the presence of other components to match the observed characteristics
    variances. It is left to the reader to determine how this network could be conclusively
    mapped out by merely observing traffic on the outside.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1. 您可以使用被动指纹识别通过观察某些节点（最重要的是测量操作系统特征、TTL和MSS值）的流量来映射一个复杂甚至无法访问的网络，然后推断其他组件的存在以匹配观察到的特征差异。留给读者去确定如何仅通过观察外部的流量来最终绘制出这个网络。
- en: Another, perhaps more interesting, promising, and challenging passive fingerprinting
    method, however, easily addresses the shortcomings of passive fingerprinting.
    This new approach makes it extremely difficult to mislead a remote observer and
    is almost universally suitable for tracking systems. Perhaps more interestingly,
    the technique makes it possible to differentiate between instances of exactly
    the same system in exactly the same configuration, taking masquerade detection
    to a whole new level. This technique uses the properties of sequence number generation
    mechanism within TCP/IP, and it can produce some pretty pictures, too.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一种可能更有趣、有希望且具有挑战性的被动指纹识别方法，却很容易解决被动指纹识别的不足。这种新的方法使得误导远程观察者变得极其困难，并且几乎适用于所有跟踪系统。更有趣的是，这项技术使得区分在完全相同的配置下完全相同的系统实例成为可能，将伪装检测提升到了全新的水平。这项技术利用了TCP/IP中序列号生成机制的属性，并且还能生成一些相当漂亮的图片。
- en: A Brief History of Sequence Numbers
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列号简史
- en: Recall from the previous chapter that initial sequence numbers are a mechanism
    used within TCP to ensure session integrity, and—de facto—to guarantee its most
    basic security resilience.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一章的内容，初始序列号是TCP内部使用的一种机制，用于确保会话完整性，并且实际上可以保证其最基本的安全弹性。
- en: The only truly universal way to protect a plain-text TCP/IP session against
    data injection, hijacking, or fakery by a complete stranger is to ensure that
    the initial sequence numbers are selected in a manner that is unpredictable to
    the attacker. This reduces their chances of making a correct blind guess (and
    spoofing a packet that will be accepted as a legitimate part of someone else’s
    session) to a point where this risk is of little concern in the real world, even
    if the attacker takes the system by storm, sending thousands of packets in hopes
    that at least one will have a roughly matching sequence number.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正保护纯文本TCP/IP会话免受完全陌生人的数据注入、劫持或伪造，唯一真正通用的方法就是确保初始序列号的选择方式对攻击者来说是不可预测的。这降低了他们正确猜测（并伪造一个将被接受为他人会话合法部分的包）的机会，以至于在现实世界中这种风险几乎可以忽略不计，即使攻击者控制了系统，发送成千上万的包，希望至少有一个与序列号大致匹配。
- en: 'In the early ’80s, the security aspects of TCP-based communications did not
    seem to be a problem worth worrying about: the Internet was a fairly small, self-contained,
    and perhaps a bit elitist environment used by scientists and the like. As such,
    the RFC specification of the TCP protocol did not specify a requirement for initial
    sequence number selection, and almost all early (and some not quite so early)
    TCP/IP stack implementations used trivial, time-, or counter-based algorithms
    that returned subsequent numbers for subsequent connections. At the time, the
    idea of randomizing these numbers seemed a needless waste of precious computing
    power. Too, in doing so, the likelihood of a sequence number collision would be
    needlessly increased. (Collision is a situation in which two ISNs chosen for subsequent
    connections to a host are too similar, thus creating the possibility that old
    packets arriving in an untimely manner could be interpreted in the context of
    a wrong connection. Naturally, picking numbers randomly is more likely in the
    short run to produce collisions than picking sequentially increasing numbers.)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代初，基于TCP的通信的安全性似乎并不是一个值得担忧的问题：互联网是一个相当小、自成一体的，也许有点精英主义的由科学家等使用的环境。因此，TCP协议的RFC规范没有指定初始序列号选择的要求，几乎所有早期的（以及一些不那么早期的）TCP/IP堆栈实现都使用了简单、基于时间或计数器的算法，这些算法为后续连接返回后续数字。当时，随机化这些数字的想法似乎是一种不必要的浪费宝贵的计算能力。此外，这样做，会增加序列号碰撞的可能性。（碰撞是指为后续连接到主机的两个ISN选择得太相似，从而产生旧数据包在不当时间到达时可能被解释为错误连接的上下文的可能性。显然，在短期内随机选择数字比选择顺序递增的数字更有可能产生碰撞。）
- en: 'The Internet has advanced a lot since the 1980s, of course, with its increased
    availability and rapidly changing and growing user base; as more and more important
    data was sent over the wires, the security issues became more relevant. Unfortunately,
    popular and reliable integrity and privacy protection mechanisms have yet to catch
    up with the Internet’s expansion: not all services support encryption, not all
    users know when to use it, and, more important, most users do not know how to
    properly validate crypto-graphic certificates provided by remote parties.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪80年代以来，互联网已经取得了很大的进步，当然，其可用性增加，用户基础快速变化和增长；随着越来越多的重要数据通过电线发送，安全问题变得更加相关。不幸的是，流行的可靠完整性和隐私保护机制尚未跟上互联网的扩张：并非所有服务都支持加密，并非所有用户都知道何时使用它，更重要的是，大多数用户不知道如何正确验证远程方提供的加密证书。
- en: Over time, and particularly with the widespread practical abuse of the weak
    ISN-generation mechanism in the mid ’90s (although mostly limited to online chat
    services and so forth), it became obvious that it was necessary to provide rudimentary
    integrity protection for TCP/IP streams. This was even important for the marginal
    fraction of all traffic that is actually crypto-graphically protected, because
    a disruption of the carrier layer by injecting junk data or RST packets is just
    as undesirable, even if the impact is only limited to disconnection (denial of
    service), as opposed to data injection.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，尤其是在20世纪90年代中期弱ISN生成机制的广泛滥用（尽管主要限于在线聊天服务等等），很明显，有必要为TCP/IP流提供基本的完整性保护。这对于所有流量中实际加密保护的那一小部分来说也很重要，因为通过注入垃圾数据或RST数据包来破坏传输层同样不受欢迎，即使影响仅限于断开连接（拒绝服务），而不是数据注入。
- en: Because the only way to fix things (without a major overhaul of just about every
    TCP-based communication scheme known to man) was to keep the protocol difficult
    to attack by itself, many developers undertook efforts to move away from the obsolete
    and dangerous trivial one-increment ISN-generation mechanisms. Although these
    efforts did indeed help to improve connection resilience to blind spoofing, they
    also opened several interesting information-gathering vectors that allow for more
    advanced fingerprinting of systems and networks, be it for security assessment
    or a planned attack.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因为修复问题的唯一方法（无需对人类已知的大多数基于TCP的通信方案进行重大改造）就是使协议本身难以被攻击，许多开发者开始努力摆脱过时且危险的简单递增ISN生成机制。尽管这些努力确实有助于提高连接对盲伪造攻击的弹性，但也开启了几个有趣的信息收集途径，允许对系统和网络进行更高级别的指纹识别，无论是为了安全评估还是计划中的攻击。
- en: Getting More Out of Sequence Numbers
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从序列号中获得更多
- en: Naturally, it is important to be able to tell the good ISN-generator implementations
    from the bad, both for quality assurance and for security testing. Until recently,
    the usual approach to assessing the quality of generated initial sequence numbers
    relied either on source-code analysis or on certain one-dimensional tests of the
    bit stream of subsequent ISNs to estimate the entropy carried by each bit of the
    output. The former is often complex and costly, is prone to errors, and is not
    always possible (in the absence of publicly available source code for a specific
    system). The latter lacked the ability to capture more subtle sequence dependencies
    and other characteristics of a generator in a reliable and readable way, focusing
    instead on more statistical imperfections than on the correlation between values
    returned for subsequent connections. Obviously, proving that an implementation
    is secure by observing only its output is just about impossible, but it is easy
    to check for certain common problems and to ensure that the underlying algorithm
    is reasonably robust. And yet, even there, the methods we used to check for this
    were rather weak at best.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，能够区分好的ISN生成实现和差的实现，对于质量保证和安全测试都很重要。直到最近，评估生成初始序列号质量的传统方法要么依赖于源代码分析，要么依赖于对后续ISN比特流的某些一维测试，以估计输出中每个比特携带的熵。前者通常复杂且成本高昂，容易出错，并且并不总是可行（在没有特定系统公开可用的源代码的情况下）。后者缺乏以可靠和可读的方式捕捉更细微的序列依赖性和生成器的其他特性的能力，而是更多地关注统计上的不完美，而不是后续连接返回值之间的相关性。显然，仅通过观察输出来证明实现的安全性几乎是不可能的，但检查某些常见问题并确保底层算法足够稳健是容易的。然而，即使在这里，我们用来检查这些的方法在最好情况下也是相当薄弱的。
- en: Both the original, insecure ISN-generator designs and some of today’s solutions
    are based on additive, iterative arithmetic systems that calculate new values
    based on their previous output; only the complexity of the recalculation algorithm
    and the amount of practical unpredictability introduced in the process seem to
    vary. The only secure designs that are not based on traditional arithmetic are
    some newer ones that use relatively slower but cryptographically secure shortcut
    functions to implement iterative systems. In all cases, though, it would be interesting
    to look for a nontrivial correlation between subsequent results produced by the
    generator for new connections to detect possible flaws in the algorithm design.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的不安全ISN生成器设计和一些今天的解决方案都是基于基于加法、迭代的算术系统，它们根据之前的输出计算新值；只有重新计算算法的复杂性和在过程中引入的实际不可预测性的数量似乎有所不同。唯一不基于传统算术的可靠设计是一些使用相对较慢但加密安全的快捷函数来实现迭代系统的较新设计。然而，在所有情况下，寻找生成器为新连接产生的后续结果之间的非平凡相关性，以检测算法设计中的可能缺陷，将是有趣的。
- en: Clearly, if an apparent dependency between ISN-generator output at time *t*
    and one at *t+x* can be observed, the attacker can choose to connect in advance
    of the connection they hope to interfere with or fake altogether, just to obtain
    the ISN output at *t*. Based on their observation of the returned sequence number,
    they can then determine the response that will be generated by the other party
    in the future (*t+x*). Hence, the attacker can spoof a valid packet for that new
    connection despite not being able to directly observe the ISN being used.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果观察到ISN生成器在时间 *t* 和时间 *t+x* 的输出之间存在明显的依赖关系，攻击者可以选择在希望干扰或伪造的连接之前连接，只是为了获得时间
    *t* 的ISN输出。基于他们对返回序列号的观察，他们可以确定未来(*t+x*)另一方将生成的响应。因此，攻击者可以在无法直接观察到所使用的ISN的情况下，伪造一个针对新连接的有效数据包。
- en: With this in mind, in 2001 I performed some research that would provide a unified
    method of examining less obvious time dependencies in sequences of ISNs acquired
    from remote systems. My work resulted in a paper that examined some of the ISN-generation
    algorithms in more detail, providing a way to detect subtleties that go beyond
    the detection of the most obvious patterns and flaws we had been aware of. The
    paper, titled “Strange Attractors and TCP/IP Sequence Number Analysis,”^([[86](apb.html#ftn.CHP-10-BIB-1)])
    used an approach well known in the world of applied mathematics, but quite novel
    for networking.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种想法的指导下，2001年我进行了一些研究，旨在为从远程系统获取的ISN序列中不太明显的时间依赖性提供一种统一的方法。我的工作产生了一篇论文，详细研究了ISN生成算法的一些方面，提供了一种方法来检测超出我们已知的最明显模式和缺陷的细微之处。这篇题为“奇异吸引子和TCP/IP序列号分析”的论文^([[86](apb.html#ftn.CHP-10-BIB-1)])采用了在应用数学领域广为人知的方法，但在网络领域却相当新颖。
- en: 'Delayed Coordinates: Taking Pictures of Time Sequences'
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟坐标：捕捉时间序列的图像
- en: When dealing with a black-box ISN generator in one of today’s closed-source
    systems, you see only its output, a sequence of 32-bit values carried by TCP/IP
    packets, not the underlying algorithm. For many operating systems, the code is
    proprietary and well guarded, quite beyond the reach of mere mortals. Even in
    an open-source system, the sources can be tricky and misleading, and you can end
    up following the same mistakes as the original developer.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理今天某些封闭源代码系统中的一个黑盒ISN生成器时，你只能看到它的输出，即由TCP/IP数据包携带的32位值序列，而不是底层的算法。对于许多操作系统，代码是专有的并且受到严格保护，普通人是无法触及的。即使在开源系统中，源代码也可能很复杂且具有误导性，你可能会重复原始开发者的错误。
- en: 'The typical input we would have to evaluate would likely look similar to this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要评估的典型输入可能看起来像这样：
- en: '[PRE0]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Is the dependency in these numbers immediately obvious? And if so, is there
    is a relatively universal method for the computer to follow this and more complex
    schemes?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字之间的依赖关系是否立即显而易见？如果是的话，是否存在一种相对通用的方法供计算机遵循这一依赖关系以及更复杂的方案？
- en: 'An elegant solution seemed far off. I hoped to develop a method to identify
    some universal properties of the ISN’s underlying algorithm based on the observation
    of output alone. But before doing that, and in order to make the analysis easier,
    it was desirable and quite convenient to assume that, because many implementations
    are based on reiterating certain arithmetic operations, it is better to observe
    the changes between subsequent results than to observe absolute values. Watching
    changes is advantageous for such algorithms, and would not do much harm to the
    rest of the possible generators. To achieve this, we must calculate a discrete
    derivative of the input sequence: the increments between elements of *S*. The
    resulting sequence of deltas, *D*, obviously starting at *t = 1*, is given by
    the following equation:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优雅的解决方案似乎遥不可及。我希望开发一种方法，仅基于对输出的观察来识别ISN底层算法的一些通用属性。但在做这件事之前，为了使分析更容易，假设许多实现基于重复某些算术操作，观察后续结果之间的变化比观察绝对值更好是可取的，并且相当方便。观察变化对这类算法有利，并且不会对其他可能的生成器造成太大伤害。为了实现这一点，我们必须计算输入序列的离散导数：*S*中元素之间的增量。结果序列*Δ*，显然从*t
    = 1*开始，由以下方程给出：
- en: '| *D[t]* = *S[t]* − *S*[*t* − 1] |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| *D[t]* = *S[t]* − *S*[*t* − 1] |'
- en: 'In this example, the resulting sequence of deltas is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，结果序列*Δ*如下：
- en: '[PRE1]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By disregarding the actual values and looking only at the dynamics of ISNs,
    the underlying dependency becomes more apparent and will generally remain so for
    all implementations that rely on this type of arithmetics. (For systems not based
    on trivial iterative arithmetics, this has virtually no relevance whatsoever and
    will not significantly affect the quality of the data for the purpose of this
    analysis.)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过忽略实际值，只观察ISN的动态，潜在的依赖关系变得更加明显，并且对于所有依赖于此类算术的实现通常都会如此。（对于不基于简单迭代算术的系统，这几乎没有任何相关性，并且不会显著影响分析目的的数据质量。）
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A particularly pedantic researcher would also compensate for timing irregularities
    during sample acquisition; here, we assume that a fixed amount of time, a base
    unit of 1, always occurs between acquisitions. In high-speed acquisition, however,
    network performance and other events may significantly impact timings. To ensure
    that these timing differences will not influence the algorithms that use clock
    input as a part of the ISN- generation process, it might be safer to use the following
    equation instead (in which T[t] expresses the delay between acquiring S[t-1] and
    S[t]): D[t] = (S[t] − S[t−1])/T[t].'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别挑剔的研究者还会补偿样本采集过程中的时间不规则性；在这里，我们假设在采集之间始终存在固定的时间量，一个基数为1的时间单位。然而，在高速采集过程中，网络性能和其他事件可能会显著影响时间。为了确保这些时间差异不会影响使用时钟输入作为ISN生成过程一部分的算法，可能更安全地使用以下方程（其中T[t]表示采集S[t-1]和S[t]之间的延迟）：D[t]
    = (S[t] − S[t−1])/T[t]。
- en: 'The advantage of this approach as applied to iterative arithmetics systems
    is fairly obvious. Trivial cases aside, however, this method alone is hardly sufficient:
    we simply move from one flat sequence of data that is fairly difficult to analyze
    to another.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应用于迭代算术系统时的优势相当明显。然而，除了简单情况之外，这种方法本身几乎是不够的：我们只是从一个相当难以分析的数据平面序列移动到另一个。
- en: The next thing I chose to do was to convert the sequence of deltas into a form
    that could be easily examined by a human or a machine for types of correlation
    perhaps less obvious than the previous example. Nothing works better than a three-dimensional
    model of the system dynamics for the first group of the intended audience of the
    data. Unfortunately, with ISNs we only have enough information to draw pictures
    in one dimension, on a single axis. So how do we turn our information into a neat
    three-dimensional shape?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我选择将delta序列转换为一种可以由人类或机器轻松检查的形式，以检查可能比前一个例子不那么明显的相关类型。对于数据的第一组预期受众，没有比系统动态的三维模型更好的方法了。不幸的是，对于ISN，我们只有足够的信息在单轴上绘制一维图。那么我们如何将我们的信息转换成整洁的三维形状呢？
- en: The solution is to extend the data set by applying a coordinate reconstruction
    strategy called *time-delayed coordinates*. We use a method that extends every
    sample by constructing virtual coordinates based on the previous samples in sequence.
    If the existing sample is considered the *x* coordinate value, we can use this
    technique to assign *y* and *z* values to every existing sample, thus constructing
    a triplet of coordinates—*x*, *y*, and *z*—sufficient to map every sample to a
    single point (here, pixel) in a three-dimensional space. (The technique is not
    limited to three dimensions. However, for the dual purposes of visualization and
    data analysis, it seemed impractical to choose a higher number. At any rate, most
    human beings do not cope with more dimensions too well, at least when sober.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是通过应用一种称为 *延迟坐标* 的坐标重建策略来扩展数据集。我们使用的方法是通过构建基于先前样本的虚拟坐标来扩展每个样本。如果现有的样本被认为是
    *x* 坐标值，我们可以使用这项技术为每个现有样本分配 *y* 和 *z* 值，从而构建一个坐标三元组—*x*，*y*，和 *z*—足以将每个样本映射到三维空间中的单个点（在这里，像素）。（这项技术不仅限于三维。然而，出于可视化和数据分析的双重目的，选择更高的维度似乎不切实际。无论如何，大多数人在清醒状态下并不擅长处理更多的维度。）
- en: 'Time-delayed coordinates are calculated so that the second coordinate is constructed
    using the value sampled at *t−1*, the third coordinate corresponds to the value
    observed *t−2*, and so on. In this particular application, coordinates for data
    at time *t* are given by the following set of equations:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟坐标的计算是为了构建第二个坐标，使用的是在 *t−1* 时刻采样的值，第三个坐标对应于在 *t−2* 时刻观察到的值，以此类推。在这个特定的应用中，时间
    *t* 的数据坐标由以下一组方程给出：
- en: '| *x[t]* = *D[t]* = *S*[*t*] − S[t − 1] |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| *x[t]* = *D[t]* = *S*[*t*] − S[t − 1] |'
- en: '| *y[t]* = *D*[*t* − 1] = *S*[*t* − 1] − *S*[*t* − 2] |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| *y[t]* = *D*[*t* − 1] = *S*[*t* − 1] − *S*[*t* − 2] |'
- en: '| *z[t]* = *D*[*t* − 2] = *S*[*t* − 2] − *S*[*t* − 3] |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| *z[t]* = *D*[*t* − 2] = *S*[*t* − 2] − *S*[*t* − 3] |'
- en: Given a sequence of newly constructed (*x,y,z*) triplets for a system that is
    being tested for time dependencies, it is possible to plot the behavior of an
    ISN-generation system in three-dimensional space. Because the location of a pixel
    representing a given sample depends both on the “current” value and on a number
    of previous results, many even fairly complex dependencies result in abstract
    but noticeable, irregular density patterns in the phase space, thus creating a
    unique portrait of the underlying algorithm. (When used in reference to such portraits,
    the term *attractor* denotes a shape that maps out the dynamics of a system. The
    shape (set, space) represents a “trail” of states through which the system cycles
    or evolves when left on its own.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个正在测试时间依赖性的系统，给定一系列新构建的 (*x,y,z*) 三元组，可以在三维空间中绘制 ISN 生成系统的行为。因为表示给定样本的像素位置既取决于“当前”值，也取决于多个先前结果，许多甚至相当复杂的依赖关系在相空间中产生了抽象但可观察的不规则密度模式，从而为底层算法创造了一个独特的轮廓。（当用于这样的轮廓时，术语
    *吸引子* 表示映射系统动态的形状。这个形状（集合，空间）代表系统在独立运行时循环或演变的“轨迹”。）
- en: '[Figure 10-2](ch10s04.html#a_three-dimensional_rendition_of_the_dat "Figure 10-2. A
    three-dimensional rendition of the data set described in the text") is a rendition
    of a set of data that originally looked as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-2](ch10s04.html#a_three-dimensional_rendition_of_the_dat "图 10-2. 文本中描述的数据集的三维表示")
    是一组数据的表示，原始看起来如下：'
- en: '[PRE2]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![A three-dimensional rendition of the data set described in the text](httpatomoreillycomsourcenostarchimages1138070.png.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![文本中描述的数据集的三维表示](httpatomoreillycomsourcenostarchimages1138070.png.jpg)'
- en: Figure 10-2. A three-dimensional rendition of the data set described in the
    text
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2. 文本中描述的数据集的三维表示
- en: '[Figure 10-3](ch10s04.html#a_three-dimensional_rendition_of_a_data "Figure 10-3. A
    three-dimensional rendition of a data set acquired from a complex but insecure
    random number generator function") through [Figure 10-5](ch10s05.html#a_common_time_dependency_pattern_comma_a
    "Figure 10-5. A common time dependency pattern, as observed in imperfect testing
    conditions") illustrate several other common yet not necessarily obvious dependency
    patterns.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](ch10s04.html#a_three-dimensional_rendition_of_a_data "图 10-3. 从复杂但不可靠的随机数生成函数获取的数据集的三维表示")
    到 [图 10-5](ch10s05.html#a_common_time_dependency_pattern_comma_a "图 10-5. 在不完美的测试条件下观察到的常见时间依赖模式")
    展示了其他一些常见但并不一定明显的依赖模式。'
- en: '![A three-dimensional rendition of a data set acquired from a complex but insecure
    random number generator function](httpatomoreillycomsourcenostarchimages1138072.png.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![从复杂但不可靠的随机数生成函数获取的数据集的三维呈现](httpatomoreillycomsourcenostarchimages1138072.png.jpg)'
- en: Figure 10-3. A three-dimensional rendition of a data set acquired from a complex
    but insecure random number generator function
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3. 从复杂但不可靠的随机数生成函数获取的数据集的三维呈现
- en: '![Rendition for PRNG with no strong correlation but noticeable statistical
    biases](httpatomoreillycomsourcenostarchimages1138074.png.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![没有强烈相关性但有可察觉的统计偏差的PRNG呈现](httpatomoreillycomsourcenostarchimages1138074.png.jpg)'
- en: Figure 10-4. Rendition for PRNG with no strong correlation but noticeable statistical
    biases
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4. 没有强烈相关性但有可察觉的统计偏差的PRNG呈现
- en: 'Pretty Pictures: TCP/IP Stack Gallery'
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 美丽的图片：TCP/IP堆栈图库
- en: The visualization method seemed to work like a charm, producing unique and often
    instinctively worrying, charming patterns for many implementations that had been
    believed to be reasonably secure; many of these pictures can be found scattered
    on the next pages. But can these pictures do more than give us a visual representation
    of hard-to-quantify parameters and characteristics of a generator? Could an attacker
    use these mysterious three-dimensional shapes in meaningful ways, or could a computer
    examine them somehow to give us a clear answer about what is wrong and what is
    right? Is a sunflower-shaped generator easier to crack than a brick-shaped one?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '可视化方法似乎效果神奇，为许多被认为相对安全的实现产生了独特且往往本能上令人担忧的迷人模式；许多这些图片可以在下一页上找到。但这些图片能做的不仅仅是给我们一个难以量化的参数和特性的视觉表示吗？攻击者能否以有意义的方式使用这些神秘的三维形状，或者计算机能否以某种方式检查它们，给我们一个关于什么是对的、什么是错的明确答案？一个向日葵形状的生成器是否比一个砖块形状的生成器更容易破解？ '
- en: Before answering this question, allow me to interrupt myself and include a short
    gallery of some of the more interesting results acquired in the process of writing
    the original paper. This should help to demonstrate the wide variety and beauty
    of some of the observed patterns, following the ancient rule that a three-dimensional
    plot is worth a thousand words. [Figure 10-6](ch10s05.html#windows_98._the_set_shown_here_has_a_dia
    "Figure 10-6. Windows 98\. The set shown here has a diameter of approximately
    128, which indicates that subsequent ISNs are increased by a number carrying about
    7 bits of “randomness.” Within the set, there is a strong frequency pattern similar
    to one of the examples discussed in the previous section, perhaps suggesting a
    trivial time dependency in all results. The size of the attractor is worryingly
    small.") through [Figure 10-14](ch10s05.html#openvms_7.2_open_parenthesis_default_tcp
    "Figure 10-14. OpenVMS 7.2 (default TCP/IP stack). A 32-bit-wide structure with
    little randomness, showing strong but fairly unusual correlation patterns indicative
    of a broken PRNG design") show PRNG portraits for several operating systems.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，请允许我打断自己，并展示一些在撰写原始论文过程中获得的一些更有趣的结果的简要图库。这应该有助于展示一些观察到的模式的广泛多样性和美丽，遵循古老的规则，即三维图比千言万语更有价值。[图10-6](ch10s05.html#windows_98._the_set_shown_here_has_a_dia
    "图10-6. Windows 98。这里显示的集合直径约为128，这表明后续的ISN增加了大约7位“随机性”的数值。在集合中，存在一个与上一节中讨论的示例相似的强烈频率模式，这可能表明所有结果都存在微小的时序依赖性。吸引子的尺寸令人担忧地小。")通过[图10-14](ch10s05.html#openvms_7.2_open_parenthesis_default_tcp
    "图10-14. OpenVMS 7.2（默认TCP/IP堆栈）。一个32位宽的结构，几乎没有随机性，显示出强烈但相当不寻常的相关模式，表明PRNG设计有缺陷")展示了几个操作系统的PRNG轮廓。
- en: Not all plots are drawn to the same scale; some shapes are considerably smaller
    than others. The scale and other parameters can be read from the top line of every
    plot, as shown in [Figure 10-6](ch10s05.html#windows_98._the_set_shown_here_has_a_dia
    "Figure 10-6. Windows 98\. The set shown here has a diameter of approximately
    128, which indicates that subsequent ISNs are increased by a number carrying about
    7 bits of “randomness.” Within the set, there is a strong frequency pattern similar
    to one of the examples discussed in the previous section, perhaps suggesting a
    trivial time dependency in all results. The size of the attractor is worryingly
    small.").
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有图表都绘制在相同的比例上；一些形状比其他形状小得多。比例和其他参数可以从每个图表的顶部行中读取，如图[图10-6](ch10s05.html#windows_98._the_set_shown_here_has_a_dia
    "图10-6. Windows 98\. 这里显示的集合直径约为128，这表明后续的ISN通过一个包含大约7位“随机性”的数字增加。在集合内，存在一个与上一节中讨论的示例相似的强烈频率模式，可能表明所有结果中存在微小的时序依赖性。吸引子的大小令人担忧地小。")所示。
- en: '![A common time dependency pattern, as observed in imperfect testing conditions](httpatomoreillycomsourcenostarchimages1138076.png.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![一个常见的时间依赖性模式，如在测试条件不完美的情况下观察到的那样](httpatomoreillycomsourcenostarchimages1138076.png.jpg)'
- en: Figure 10-5. A common time dependency pattern, as observed in imperfect testing
    conditions
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5. 在测试条件不完美的情况下观察到的常见时间依赖性模式
- en: '![Windows 98\. The set shown here has a diameter of approximately 128, which
    indicates that subsequent ISNs are increased by a number carrying about 7 bits
    of “randomness.” Within the set, there is a strong frequency pattern similar to
    one of the examples discussed in the previous section, perhaps suggesting a trivial
    time dependency in all results. The size of the attractor is worryingly small.](httpatomoreillycomsourcenostarchimages1138078.png.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![Windows 98\. 这里显示的集合直径约为128，这表明后续的ISN通过一个包含大约7位“随机性”的数字增加。在集合内，存在一个与上一节中讨论的示例相似的强烈频率模式，可能表明所有结果中存在微小的时序依赖性。吸引子的大小令人担忧地小。](httpatomoreillycomsourcenostarchimages1138078.png.jpg)'
- en: Figure 10-6. Windows 98\. The set shown here has a diameter of approximately
    128, which indicates that subsequent ISNs are increased by a number carrying about
    7 bits of “randomness.” Within the set, there is a strong frequency pattern similar
    to one of the examples discussed in the previous section, perhaps suggesting a
    trivial time dependency in all results. The size of the attractor is worryingly
    small.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6. Windows 98\. 这里显示的集合直径约为128，这表明后续的ISN通过一个包含大约7位“随机性”的数字增加。在集合内，存在一个与上一节中讨论的示例相似的强烈频率模式，可能表明所有结果中存在微小的时序依赖性。吸引子的大小令人担忧地小。
- en: '![FreeBSD 4.2\. A 16-bit-wide uniform cube, likely a sign of small but truly
    random increments in every step](httpatomoreillycomsourcenostarchimages1138080.png.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![FreeBSD 4.2\. 一个16位宽的均匀立方体，可能是每一步真正随机增加的小量迹象](httpatomoreillycomsourcenostarchimages1138080.png.jpg)'
- en: Figure 10-7. FreeBSD 4.2\. A 16-bit-wide uniform cube, likely a sign of small
    but truly random increments in every step
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-7. FreeBSD 4.2\. 一个16位宽的均匀立方体，可能是每一步真正随机增加的小量迹象
- en: '![HP/UX 11\. A strange x-wing structure, 18 bits wide but obviously irregular,
    likely a sign of high-correlation levels of a flawed PRNG](httpatomoreillycomsourcenostarchimages1138082.png.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![HP/UX 11\. 一个奇怪的X形结构，宽度为18位但显然不规则，可能是存在缺陷的伪随机数生成器高相关性水平的迹象](httpatomoreillycomsourcenostarchimages1138082.png.jpg)'
- en: Figure 10-8. HP/UX 11\. A strange x-wing structure, 18 bits wide but obviously
    irregular, likely a sign of high-correlation levels of a flawed PRNG
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-8. HP/UX 11\. 一个奇怪的X形结构，宽度为18位但显然不规则，可能是存在缺陷的伪随机数生成器高相关性水平的迹象
- en: '![Mac OS 9\. A similar but slightly different 17-bit structure](httpatomoreillycomsourcenostarchimages1138084.png.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS 9\. 一个类似但略有不同的17位结构](httpatomoreillycomsourcenostarchimages1138084.png.jpg)'
- en: Figure 10-9. Mac OS 9\. A similar but slightly different 17-bit structure
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-9. Mac OS 9\. 一个类似但略有不同的17位结构
- en: '![Windows NT 4.0 SP3\. Again, a strong attraction pattern and a tiny 8-bit-wide
    attractor](httpatomoreillycomsourcenostarchimages1138086.png.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![Windows NT 4.0 SP3\. 再次，一个强烈的吸引模式和一个微小的8位宽吸引子](httpatomoreillycomsourcenostarchimages1138086.png.jpg)'
- en: Figure 10-10. Windows NT 4.0 SP3\. Again, a strong attraction pattern and a
    tiny 8-bit-wide attractor
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-10. Windows NT 4.0 SP3\. 再次，一个强烈的吸引模式和一个微小的8位宽吸引子
- en: '![IRIX 6.5\. A 16-to-18-bit-wide highly irregular random cloud; likely a flawed
    algorithm](httpatomoreillycomsourcenostarchimages1138088.png.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![IRIX 6.5\. 一个16到18位宽的高度不规则随机云；可能是存在缺陷的算法](httpatomoreillycomsourcenostarchimages1138088.png.jpg)'
- en: Figure 10-11. *IRIX* 6.5\. A 16-to-18-bit-wide highly irregular random cloud;
    likely a flawed algorithm
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-11. *IRIX* 6.5\. 一个16到18位宽的高度不规则随机云；可能是一个有缺陷的算法
- en: '![NetWare 6\. A seemingly random system, with a 32-bit-wide attractor cloud,
    but consisting of a large number of high-density spots and not uniform](httpatomoreillycomsourcenostarchimages1138090.png.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![NetWare 6\. 一个看似随机的系统，具有32位宽的吸引子云，但由大量高密度点组成，并不均匀](httpatomoreillycomsourcenostarchimages1138090.png.jpg)'
- en: Figure 10-12. NetWare 6\. A seemingly random system, with a 32-bit-wide attractor
    cloud, but consisting of a large number of high-density spots and not uniform
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-12. NetWare 6\. 一个看似随机的系统，具有32位宽的吸引子云，但由大量高密度点组成，并不均匀
- en: '![UNICOS 10.0.0.8\. A strange, 17-bit-wide cloud with irregular stretches of
    higher hit probabilities](httpatomoreillycomsourcenostarchimages1138092.png.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![UNICOS 10.0.0.8\. 一个17位宽的奇怪云，具有不规则的较高命中概率段](httpatomoreillycomsourcenostarchimages1138092.png.jpg)'
- en: Figure 10-13. UNICOS 10.0.0.8\. A strange, 17-bit-wide cloud with irregular
    stretches of higher hit probabilities
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-13. UNICOS 10.0.0.8\. 一个17位宽的奇怪云，具有不规则的较高命中概率段
- en: '![OpenVMS 7.2 (default TCP/IP stack). A 32-bit-wide structure with little randomness,
    showing strong but fairly unusual correlation patterns indicative of a broken
    PRNG design](httpatomoreillycomsourcenostarchimages1138094.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![OpenVMS 7.2（默认TCP/IP堆栈）。一个32位宽的结构，几乎无随机性，显示出强烈的但相当不寻常的相关模式，表明PRNG设计有缺陷](httpatomoreillycomsourcenostarchimages1138094.png)'
- en: Figure 10-14. OpenVMS 7.2 (default TCP/IP stack). A 32-bit-wide structure with
    little randomness, showing strong but fairly unusual correlation patterns indicative
    of a broken PRNG design
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-14. OpenVMS 7.2（默认TCP/IP堆栈）。一个32位宽的结构，几乎无随机性，显示出强烈的但相当不寻常的相关模式，表明PRNG设计有缺陷
- en: Attacking with Attractors
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用吸引子进行攻击
- en: Now, back to the question of sunflowers versus bricks. Yes, the relevance of
    the pretty pictures goes beyond visual delight for hard-core computer geeks. As
    it turns out, the attractor structure captured for each system creates a matrix
    of possible ISN behavior patterns, with densities that correspond to probabilities
    of a specific type of time dependency or statistical pattern appearing over time.
    Higher-density regions within the attractor correspond to historical correlations,
    which are also more likely to occur in the future; less populated areas are less
    likely to be visited. As such, once the approximate attractor for a specific system
    is mapped out, the attacker can guess at future results. But how, precisely, do
    those shapes map back to exact ISN values?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到向日葵与砖块的问题。是的，这些漂亮图片的相关性不仅超越了视觉上的愉悦，对于硬核计算机爱好者来说也是如此。事实证明，为每个系统捕获的吸引子结构创建了一个可能的ISN行为模式矩阵，其密度对应于在一段时间内出现特定类型的时间依赖性或统计模式的概率。吸引子中的高密度区域对应于历史相关性，也更有可能在将来发生；人口较少的区域不太可能被访问。因此，一旦绘制出特定系统的近似吸引子，攻击者就可以猜测未来的结果。但是，这些形状究竟如何映射到确切的ISN值呢？
- en: The key to a successful attack is recognizing that the *x* coordinate of every
    point in the attractor depends on the value of *D[t]*—that is, on the sequence
    numbers observed at time *t* and *t-1* (because *D[t]* = *S[t]*- *S[t-1]*). The
    *y* coordinate, on the other hand, depends on *D[t-1]* (ISNs at *t-1* and *t-2*),
    and *z* depends on *D[t-2]* (ISNs at *t-2* and *t-3*).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 成功攻击的关键在于认识到吸引子中每个点的 *x* 坐标取决于 *D[t]* 的值——即时间 *t* 和 *t-1* 观察到的序列号（因为 *D[t]*
    = *S[t]*- *S[t-1]*）。另一方面，*y* 坐标取决于 *D[t-1]*（*t-1* 和 *t-2* 时的ISN），而 *z* 坐标取决于 *D[t-2]*（*t-2*
    和 *t-3* 时的ISN）。
- en: Let’s assume an attacker has sent three probes to a remote system, for whose
    operating system the attractor structure has been mapped. The probes correspond
    to times *t−3*, *t−2*, and *t−1* and—naturally—are sufficient to reconstruct the
    *y* and *z* coordinates of the point that would mark the behavior of the system
    at this particular time on the attractor structure.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者向一个远程系统发送了三个探测，该系统的操作系统已经绘制了吸引子结构图。这些探测对应于时间 *t−3*、*t−2* 和 *t−1*，并且——自然地——足以重建在吸引子结构上标记系统在此特定时间行为的点的
    *y* 和 *z* 坐标。
- en: The attacker can use this information to deduce values of *x* for known *y*
    and *z* that are more likely to occur than others, based on the observation of
    the irregularities in the attractor structure noticed thus far. The *y* and *z*
    coordinates correspond to a single line in the attractor space, perpendicular
    to the *x* plane (as shown in [Figure 10-15](ch10s06.html#an_lattack_liner_intersecting_the_attrac
    "Figure 10-15. An “attack line” intersecting the attractor"))—the collection of
    points with all possible *x* values, but known remaining coordinates. The collection
    of points at which the line intersects with or nears the high-density areas of
    the attractor forms a set of most likely values for the *x* coordinate. The areas
    of lowest density are, obviously, least likely to correspond to the correct value
    of *x*; after all, the attractor points did not show up there during previous
    measurements.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以利用这些信息，根据迄今为止观察到的吸引子结构中的不规则性，推断出比其他值更有可能发生的 *x* 对于已知的 *y* 和 *z* 的值。*y*
    和 *z* 坐标对应于吸引子空间中的一条直线，垂直于 *x* 平面（如图 [图 10-15](ch10s06.html#an_lattack_liner_intersecting_the_attrac
    "图 10-15. 一条“攻击线”与吸引子相交" 所示）——所有可能的 *x* 值的点集合，但剩余坐标已知。该线与或接近吸引子高密度区域的点集合形成一组最有可能的
    *x* 坐标值。显然，密度最低的区域最不可能对应于正确的 *x* 值；毕竟，在之前的测量中，吸引子点并没有出现在那里。
- en: 'The ability to construct a set of candidates for the *x* value for known *y*
    and *z* is a major step toward a successful attack: knowing *S[t-1]* (which, you
    will recall, was previously acquired by the attacker), the attacker can easily
    calculate *S[t]* for every candidate *x* (*D[t]*) value, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一组候选的 *x* 值，对于已知的 *y* 和 *z*，是成功攻击的重要一步：知道 *S[t-1]*（你将记得，这是攻击者之前获得的），攻击者可以轻松地计算每个候选
    *x* (*D[t]*) 值，如下所示：
- en: '| *S[t]* = *x + S*[*t* − 1] |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| *S[t]* = *x + S*[*t* − 1] |'
- en: Having sampled three previous sequence numbers, *S[t-3]*, *S[t-2]*, and *S[t-1]*,
    the attacker can thus determine a set of likely candidates for the next sequence
    number, *S[t]*, which will likely be chosen for the next connection by the attacked
    system—the one the attacker did not initiate, but which he hopes to interfere
    with. The attacker can then execute an attack by sending TCP/IP packets with the
    candidate sequence numbers; he does not have to get it right from the beginning
    because all wrong guesses will simply be disregarded by the remote implementation.
    However, as soon as the value of any of the spoofed packets agrees with the expected
    number, within the expected window size, the traffic will be accepted, thereby
    defeating the session integrity protection offered by TCP/IP.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样了三个先前的序列号 *S[t-3]*、*S[t-2]* 和 *S[t-1]* 之后，攻击者可以确定一组可能的候选序列号 *S[t]*，这很可能会被攻击系统（攻击者没有发起，但他希望干扰的系统）选择用于下一个连接。攻击者可以通过发送带有候选序列号的
    TCP/IP 数据包来执行攻击；他不需要一开始就做对，因为所有错误的猜测都将被远程实现简单地忽略。然而，一旦任何伪造的数据包的值与预期的数字在预期的窗口大小内一致，流量就会被接受，从而破坏了
    TCP/IP 提供的会话完整性保护。
- en: '![An “attack line” intersecting the attractor](httpatomoreillycomsourcenostarchimages1138096.png.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![一条“攻击线”与吸引子相交](httpatomoreillycomsourcenostarchimages1138096.png.jpg)'
- en: Figure 10-15. An “attack line” intersecting the attractor
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-15. 一条“攻击线”与吸引子相交
- en: 'The attack has some caveats, of course:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，攻击也有一些注意事项：
- en: Their observed dynamics might be local to the observation conditions or source
    itself—though judging from the achieved success ratio when this technique is deployed
    against common implementations, this is unlikely.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们观察到的动态可能仅限于观察条件或来源本身——尽管从这种技术针对常见实现取得的成功比率来看，这似乎不太可能。
- en: If the candidate set is particularly large—as with algorithms that produce uniform
    attractor clouds with no clear irregularities—the technique becomes fairly impractical
    because it requires too many attempts to make a correct guess.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果候选集特别大——例如，对于产生没有明显不规则性的均匀吸引子云的算法——这种技术就相当不实用，因为它需要太多的尝试来做出正确的猜测。
- en: 'Because it is often impractical to sample the entire sequence of values generated
    by an ISN implementation in a system (some systems have long or even unlimited
    cycles), it is impossible to construct a complete attractor. To counter this,
    you must use an approximate approach: the value is chosen as a candidate if a
    point is present within a given radius from a specific point on the (*y,z*) line,
    thus compensating for the fact that even fairly dense areas of the attractor can
    still contain gaps.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在系统中采样ISN实现生成的整个值序列通常不切实际（一些系统有长周期甚至无限周期），因此无法构建完整的吸引子。为了解决这个问题，必须使用近似方法：如果在一个特定的(*y,z*)线上的一个特定点周围给定半径内存在一个点，则选择该值作为候选值，从而补偿吸引子中即使相当密集的区域也可能存在空隙的事实。
- en: To keep the results meaningful and to establish a method for comparative assessment
    of the quality of a ISN generator, I decided to empirically estimate the success
    ratio with a limited number of tries. Specifically, I wanted to determine the
    likelihood of hitting the correct number given 5,000 attempts, based on the assumption
    that an attacker using a low- to mid-end network connection could send at most
    5,000 packets in a short period of time.^([[22](#ftn.CHP-10-FN-1)])
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使结果有意义，并建立一个用于比较评估ISN生成器质量的方法，我决定通过有限的尝试次数来经验性地估计成功率。具体来说，我想确定在5,000次尝试中击中正确数字的可能性，基于假设一个使用低端到中端网络连接的攻击者可能在短时间内最多发送5,000个数据包.^([[22](#ftn.CHP-10-FN-1)])
- en: 'To test the validity of the approach, I chose to estimate the probability of
    success by dividing the input data acquired from remote systems into two parts:
    one part to construct the attractor and the other to perform actual tests. The
    test read four subsequent sequence numbers at once and then fed three of them
    to an implementation that, based on the attractor data, had to then generate a
    set of as many as 5,000 values. Finally, the output was compared with the fourth
    number acquired from the test data set. The test was repeated hundreds of times
    for subsequent ISN quadruplets for every attractor to determine an approximate
    successful guess percentage, which, in practice, denotes how likely the attacker
    is to succeed using this approach.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试该方法的有效性，我选择将来自远程系统的输入数据分为两部分：一部分用于构建吸引子，另一部分用于执行实际测试。测试一次读取四个连续的序列号，然后将其中三个输入到一个基于吸引子数据生成最多5,000个值的实现中。最后，将输出与从测试数据集中获取的第四个数字进行比较。对于每个吸引子，重复数百次测试以确定ISN四元组的近似成功猜测百分比，这在实践中表示攻击者使用这种方法成功的可能性。
- en: 'Following are some of the results for the systems in the attractor gallery:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是吸引子画廊中系统的部分结果：
- en: '| Operating System | Attack Feasibility |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 攻击可行性 |'
- en: '| --- | --- |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| IRIX 6.5.15 | 25% (25 out of 100 attempts) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| IRIX 6.5.15 | 25%（100次尝试中的25次）|'
- en: '| OpenVMS 7.2 | 15.00% |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| OpenVMS 7.2 | 15.00% |'
- en: '| Windows NT 4.0 SP3 | 97.00% |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| Windows NT 4.0 SP3 | 97.00% |'
- en: '| Windows 98 | 100.00% |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| Windows 98 | 100.00% |'
- en: '| FreeBSD 4.2 | 1% |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD 4.2 | 1% |'
- en: '| HP/UX 11 | 100.00% |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| HP/UX 11 | 100.00% |'
- en: '| Mac OS 9 | 89.00% |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS 9 | 89.00% |'
- en: This approach was obviously fairly effective^([[23](#ftn.CHP-10-FN-2)]) and
    prompted many vendors to redesign their algorithms or revisit their claims about
    algorithm security. (Follow-up research that I published one year later (2002)
    reviewed some of these changes, of which not all were satisfactory.)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显然相当有效^([[23](#ftn.CHP-10-FN-2)])，促使许多供应商重新设计他们的算法或重新审视他们对算法安全性的声明。（我一年后（2002年）发表的后继研究回顾了这些变化中的一些，其中并非所有都令人满意。）
- en: But the real question is, What does this have to do with passive operating system
    fingerprinting?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正的问题是，这与被动操作系统指纹识别有什么关系？
- en: '* * *'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[22](#CHP-10-FN-1)]) The smallest SYN packet has 40 bytes; hence, sending
    5,000 SYN packets consumes at least 200 kilobytes of bandwidth. This amount of
    data can be successfully sent out over a modem line with V42.bis modem compression
    in a matter of 10–20 seconds. The choice of this threshold is quite arbitrary,
    but seems reasonable.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-10-FN-1)]) 最小的SYN数据包有40字节；因此，发送5,000个SYN数据包至少需要200千字节的带宽。这么多数据可以在10-20秒内通过V42.bis调制解调器压缩在调制解调器线上成功发送。这个阈值的选取相当随意，但似乎合理。
- en: ^([[23](#CHP-10-FN-2)]) These results apply to scenarios in which a precise
    data injection or spoofing is necessary. If less precision is required or if the
    only goal of an attacker is to cause a disruption, the remote party is not only
    going to accept packets with the exact sequence number, but also those that fit
    within the window size, as specified in TCP/IP parameters (see [Chapter 9](ch09.html
    "Chapter 9. Foreign Accent")). In other words, DoS attacks will be even more successful.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-10-FN-2)]) 这些结果适用于需要精确数据注入或欺骗的场景。如果所需的精度较低，或者攻击者的唯一目标是造成干扰，远程方不仅会接受具有确切序列号的包，还会接受那些在TCP/IP参数指定的窗口大小范围内的包（参见[第9章](ch09.html
    "第9章. 外国口音"））。换句话说，DoS攻击将更加成功。
- en: Back to System Fingerprinting
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到系统指纹识别
- en: Indeed, a couple of truly fascinating consequences result from our ability to
    map out the dynamics of a sequence number generator in a particular system and
    from the fact that most implementations exhibit certain more or less unique phase-space
    patterns. The most obvious trick is the application of ISN probing to old-school
    system fingerprinting.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由于我们能够绘制出特定系统中序列号生成器的动态，以及大多数实现都表现出某些或多或少独特的相空间模式，这导致了一些真正令人着迷的后果。最明显的技巧是将ISN探测应用于传统的系统指纹识别。
- en: By observing a couple of sequence numbers acquired from a remote system (for
    example, when a party attempts to establish several connections to a server) you
    can attempt to find an attractor to which this data fits best, by comparing the
    observed sample against a library of known attractors. (The numbers don’t need
    to be predictable using the attack technique described; the attractor for a system
    need only be distinct.)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察从远程系统获取的几个序列号（例如，当一方尝试与服务器建立多个连接时），你可以尝试找到一个吸引子，该数据最适合这个吸引子，通过将观察到的样本与已知吸引子的库进行比较。（这些数字不需要使用攻击技术来预测；系统的吸引子只需要是独特的。）
- en: When compared with traditional, passive fingerprinting, this method usually
    provides us with less detailed insight into the system’s configuration, but it
    is also nearly foolproof. To thwart the technique, you would have to modify the
    way sequence numbers are generated, but it is usually impossible to significantly
    tweak ISN-generation settings from the user space, and a modification of the kernel
    without degrading security usually requires a good dose of knowledge and skill
    (not to mention, access to the sources).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的被动指纹识别相比，这种方法通常给我们提供对系统配置的较少细节洞察，但它也几乎是万无一失的。要挫败这种技术，你必须修改序列号生成的方式，但通常无法从用户空间显著调整ISN生成设置，而且在不降低安全性的情况下修改内核通常需要丰富的知识和技能（更不用说，还需要访问源代码）。
- en: But, is that all? Of course not!
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这仅仅是开始！
- en: ISNProber—Theory in Action
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ISNProber——理论付诸实践
- en: Pictures and theory aside, it would be good to see how an ISN sampling works
    in the real world and how can it help to assess the configuration of a remote
    system or identify its instances. Fortunately for me, there is a program worth
    mentioning.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开图片和理论，看看ISN采样在现实世界中的工作方式以及它如何帮助评估远程系统的配置或识别其实例，将会很有帮助。幸运的是，有一个值得提到的程序。
- en: After reading my TCP/IP ISN analysis paper, Toni Vandepoel wrote a great tool
    called ISNProber. ISNProber uses sequence number analysis to differentiate among
    several instances of the same system, based on the observation that two distinct
    systems are likely to be at different locations in the attractor.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了我的TCP/IP ISN分析论文后，Toni Vandepoel编写了一个名为ISNProber的出色工具。ISNProber使用序列号分析来区分同一系统的多个实例，基于观察到的两个不同的系统很可能在吸引子中的不同位置。
- en: 'At its most trivial, ISNProber can tell that two systems are hiding behind
    a shared address, based on the appearance of observed ISNs. For the sake of simplicity,
    let’s assume that system Y uses an increase-by-one ISN-generator design. We approach
    an IP address of a website [www.example.com](http://www.example.com) and want
    to determine how many systems there are. We first identify [www.example.com](http://www.example.com)
    as system Y, establish several subsequent connections, and then observe ISNs as
    follows: 10, 11, 534, 13, 540, 19.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，ISNProber可以根据观察到的ISN出现情况，判断两个系统是否隐藏在同一个地址后面。为了简化问题，我们假设系统Y使用的是自增ISN生成器设计。我们访问一个网站的IP地址[www.example.com](http://www.example.com)，并想确定该网站有多少个系统。我们首先将[www.example.com](http://www.example.com)识别为系统Y，建立几个后续连接，然后观察到的ISN如下：10，11，534，13，540，19。
- en: It should be obvious that the lower numbers form a sequence originating from
    a computer that either handled less traffic or has a lower uptime (10, 11, 13,
    19), whereas the higher numbers correspond to the other system. Hence, two computers
    are “co-serving” the same public IP, perhaps behind a load balancer. Furthermore,
    by varying sampling intervals, we can carefully examine the type of load balancer,
    its request distribution policy, and the traffic it receives.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，较低的数字形成了一个序列，这个序列来自处理较少流量或运行时间较短的计算机（10, 11, 13, 19），而较高的数字则对应于另一个系统。因此，两台计算机可能在同一个公共IP地址后“共同服务”，可能位于负载均衡器后面。此外，通过改变采样间隔，我们可以仔细检查负载均衡器的类型、其请求分配策略以及它接收到的流量。
- en: This approach can not only differentiate systems hiding behind a common address,
    but also track users of system Y as they hop from one IP to another, for as long
    as they do not reboot their machine (and hence reset the ISN counter). For systems
    that offer ISN-generation schemes more sophisticated than the one in our example,
    the distinction can be more difficult, but it is certainly possible, as long as
    the ISNs are not purely random on all 32 bits. (If they are, collision-related
    concerns arise.)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅可以区分隐藏在常用地址背后的系统，还可以跟踪系统Y的用户，当他们从一个IP跳转到另一个IP时，只要他们不重启机器（因此重置ISN计数器）。对于提供比我们示例中更复杂ISN生成方案的系统，区分可能更困难，但只要ISN不是在所有32位上都是纯随机的，这肯定是可能的。（如果是，就会引发与碰撞相关的问题。）
- en: The approach used here simply requires that a dose of predictability be present
    in the ISN-generation algorithm. As such, TCP/IP initial sequence analysis seems
    to be a promising alternative or addition to traditional passive fingerprinting—and
    can, quite regrettably, serve as a useful tool for privacy invasion and user tracking,
    too.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法仅仅要求ISN生成算法中存在一定的可预测性。因此，TCP/IP初始序列号分析似乎是一个有希望的替代方案或补充，可以用于传统的被动指纹识别——并且遗憾的是，也可以作为侵犯隐私和用户跟踪的有用工具。
- en: Preventing Passive Analysis
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止被动分析
- en: Defending against sequence-number prediction is fairly trivial, and good solutions,
    such as Steven M. Bellovin’s RFC1948^([[87](apb.html#ftn.CHP-10-BIB-2)]) specification,
    have been available for a long time. However, preventing passive analysis of the
    numbers is quite difficult, because the problem results not only from the weakness
    of the algorithms, but also from the diversity of the algorithms used, which causes
    few systems to share the same ISN footprint. Even among systems that implement
    RFC1948 or that use other cryptograph-ically secure, external entropy-based generators,
    behavioral patterns may vary significantly, depending on the subtleties of the
    algorithm and the implementor’s assumptions as to the values that would be sufficient
    to thwart an attack.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 防御序列号预测相对简单，像Steven M. Bellovin的RFC1948^([[87](apb.html#ftn.CHP-10-BIB-2)])规范这样的良好解决方案已经存在很长时间了。然而，防止对数字进行被动分析相当困难，因为问题不仅源于算法的弱点，还源于使用的算法多样性，这导致很少有系统共享相同的ISN足迹。即使在实现RFC1948或使用其他基于密码学安全、外部熵的生成器的系统中，行为模式也可能因算法的微妙差异和实施者对足以阻止攻击的值的假设而显著不同。
- en: A degree of prevention can be achieved by deploying a stateful packet firewall
    that rewrites all sequence numbers in outgoing packets^([[24](#ftn.CHP-10-FN-3)]);
    this makes all systems within a protected network appear roughly the same. Unfortunately,
    only some offer this functionality, and only some can benefit from it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署一个重写所有出站数据包序列号的状态包防火墙，可以实现对一定程度的预防[[24](#ftn.CHP-10-FN-3)]；这使得受保护网络内的所有系统看起来大致相同。不幸的是，只有一些防火墙提供这种功能，也只有一些可以从这种功能中受益。
- en: '* * *'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[24](#CHP-10-FN-3)]) Solar Designer points out that, technically, this can
    also be implemented as a clever hack in a stateless firewall. The firewall may
    combine (through XOR, for example) the original sequence number with a secure
    hash of a secret key, combined with a quadruplet of addresses and ports that uniquely
    identify a connection. Returning packets could then have the hash removed (by
    subsequent XORing), making the packet match the internal host’s idea of the connection
    upon delivery, but existing only in an unpredictable, random 32-bit form while
    outside the firewall. This would work for all but the most broken (frequently
    repeating and collision-prone) ISN implementations.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-10-FN-3)]) Solar Designer 指出，从技术上讲，这也可以作为一个巧妙的黑客攻击在无状态防火墙中实现。防火墙可以通过
    XOR 等操作将原始序列号与一个秘密密钥的安全哈希值相结合，再加上一个唯一标识连接的地址和端口号的四元组。返回的数据包可以移除哈希值（通过后续的 XOR 操作），使得数据包在交付时与内部主机的连接想法相匹配，但在防火墙外部仅以不可预测的随机
    32 位形式存在。这对于除了最不稳定的（频繁重复且容易发生冲突）ISN 实现之外的所有情况都适用。
- en: Food for Thought
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考题
- en: The technique of phase-space analysis is useful in fields that go far beyond
    sequence-number generation. Other parameters that are chosen pseudo-randomly or
    according to some internal scheme—such as IP packet ID fields, DNS request identifiers
    (as shown in [Figure 10-16](ch10s09.html#an_interesting_attractor_pattern_for_lin
    "Figure 10-16. An interesting attractor pattern for Linux name-resolver implementation")),
    application-generated “secret” cookies that identify user sessions, and so on—can
    be analyzed successfully, either to find flaws in a design or to identify an implementation
    and simplify further analysis or facilitate an attack.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 相空间分析方法在远超序列号生成领域的领域中很有用。其他一些参数，如伪随机选择或根据某些内部方案选择的参数——例如 IP 数据包 ID 字段、DNS 请求标识符（如图
    10-16 所示 [Figure 10-16](ch10s09.html#an_interesting_attractor_pattern_for_lin
    "Figure 10-16. An interesting attractor pattern for Linux name-resolver implementation"))、由应用程序生成的“秘密”cookie，用于标识用户会话等——可以成功分析，无论是为了发现设计中的缺陷，还是为了识别实现并简化进一步分析或便于攻击。
- en: '![An interesting attractor pattern for Linux name-resolver implementation](httpatomoreillycomsourcenostarchimages1138098.png.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![Linux 名称解析实现的一个有趣的吸引子模式](httpatomoreillycomsourcenostarchimages1138098.png.jpg)'
- en: Figure 10-16. An interesting attractor pattern for Linux name-resolver implementation
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-16. Linux 名称解析实现的一个有趣的吸引子模式
- en: Some work in this direction had been done or is under way; in a paper partly
    related to my original research, Joe Steward provides insight into some of the
    DNS system problems^([[88](apb.html#ftn.CHP-10-BIB-3)]) that arise with the advancement
    of sequence number-prediction mechanisms. He notes that not only a UDP-based DNS
    protocol offers request verification methods that are simply not enough to withstand
    even “low-budget” spoofing attacks, but also the low quality of unique request
    identifiers generated by various implementations further weaken the scheme to
    make it trivially vulnerable to malicious data injection. Given that DNS is one
    of core services of the Internet, and that the perspective of spoofing a DNS response
    for a popular site to redirect all users of a specific network to a different
    web page is not exactly not tempting, DNS poisoning tops my list of downplayed
    threats on the Internet.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方向上的一些工作已经完成或正在进行中；在一篇与我原始研究部分相关的论文中，Joe Steward 对 DNS 系统中随着序列号预测机制的发展而出现的一些问题提供了见解^([[88](apb.html#ftn.CHP-10-BIB-3)])。他指出，不仅基于
    UDP 的 DNS 协议提供的请求验证方法不足以抵御甚至“低成本”的欺骗攻击，而且各种实现生成的唯一请求标识符的低质量进一步削弱了该方案，使其轻易地受到恶意数据注入的攻击。鉴于
    DNS 是互联网的核心服务之一，以及欺骗一个知名网站的 DNS 响应以将特定网络的所有用户重定向到不同的网页并不是完全没有诱惑力，DNS 污染是我列出的互联网中被低估的威胁之一。
- en: Dan Kaminsky provides some interesting, more advanced visualizations of supposedly
    random data at [http://www.doxpara.com/pics/index.php?album=phentropy](http://www.doxpara.com/pics/index.php?album=phentropy)
    ([Figure 10-17](ch10s09.html#danas_rendition_of_bsd_kernel_randomness "Figure 10-17. Dan’s
    rendition of BSD kernel randomness (courtesy of www.doxpara.com)")), definitely
    a worthy read.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Dan Kaminsky 在 [http://www.doxpara.com/pics/index.php?album=phentropy](http://www.doxpara.com/pics/index.php?album=phentropy)
    ([Figure 10-17](ch10s09.html#danas_rendition_of_bsd_kernel_randomness "Figure 10-17. Dan’s
    rendition of BSD kernel randomness (courtesy of www.doxpara.com)")) 提供了一些有趣的、更高级的随机数据的可视化，绝对值得一读。
- en: '![Dan’s rendition of BSD kernel randomness (courtesy of www.doxpara.com)](httpatomoreillycomsourcenostarchimages1138100.png.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![Dan的BSD内核随机性再现（由www.doxpara.com提供）](http://atomoreilly.com/source/nostarch/images/1138100.png.jpg)'
- en: Figure 10-17. Dan’s rendition of BSD kernel randomness (courtesy of [www.doxpara.com](http://www.doxpara.com))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-17. Dan的BSD内核随机性再现（由[www.doxpara.com](http://www.doxpara.com)提供）
- en: Chapter 11. In Recognition of Anomalies
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 异常识别
- en: '*Or what can be learned from subtle imperfections of network traffic*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者可以从网络流量的微妙不完美中学习到什么*'
- en: —
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: In the previous chapters, I dissected and analyzed a number of ways to extract
    chunks of potentially and likely valuable information from seemingly irrelevant,
    “technical” parameters supplied along with every message transmitted by a suspect
    over the network. As I hope you have seen, we can obtain a considerable amount
    of data on the sender that the sender is surely unaware of providing (or, at the
    very least, not very happy about often being unable to opt out of providing that
    data). Using a wide array of packet and stream analysis tricks, in a perfect and
    happy world we can measure many characteristics of the remote party and can map
    their behavior to a specific system’s signature and network configuration.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我剖析并分析了从嫌疑人通过网络传输的每条消息中附带看似无关的、“技术”参数中提取可能和很可能有价值信息的方法。正如我希望你看到的，我们可以获得大量关于发送者的数据，而这些数据发送者肯定不知道自己提供了（或者至少，不太愿意经常无法选择不提供这些数据）。通过使用一系列的包和流分析技巧，在一个完美和快乐的世界里，我们可以测量远程方的许多特征，并将他们的行为映射到特定系统的签名和网络配置。
- en: 'However, the reality is a bit different: some of the observed parameters deviate
    at least slightly from the expected set of values normally associated with a specific
    device or network configuration that the suspect is using. Although you may simply
    ignore these seemingly senseless and accidental discrepancies and still successfully
    identify the originating system or track its users, it is not necessarily wise
    to do so. We learn to pay no attention to seemingly meaningless annoyances like
    this, but nothing in the world of computing happens without a good reason (given
    a fairly lax definition of “good,” at least), and exploring the mechanism behind
    these apparently random anomalies and minority patterns, rather than ignoring
    them, can provide valuable information about the previously unseen specifics of
    network configuration.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实情况略有不同：一些观察到的参数至少在一定程度上偏离了与嫌疑人使用的特定设备或网络配置通常相关的一组预期值。尽管你可能简单地忽略这些看似无意义的偶然差异，并仍然成功地识别出原始系统或追踪其用户，但这样做并不一定明智。我们学会了不对这种看似无意义的烦恼给予关注，但世界上没有一件事情发生是没有好理由的（至少在“好”的定义相当宽松的情况下），探索这些看似随机的异常和少数模式背后的机制，而不是忽略它们，可以提供有关网络配置先前未见具体细节的有价值信息。
- en: In this chapter I take a closer look at some of the processes that can affect
    the observed characteristics of a system. I explain the underlying reason for,
    the purpose of (or lack thereof), and the consequences of the technologies that
    prompt such behavior.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我更深入地研究了可能影响系统观察特征的一些过程。我解释了这些技术导致这种行为的根本原因、目的（或缺乏目的），以及这些技术的后果。
- en: 'Needless to say, most of the reproducible modifications to IP packets discussed
    here originate from more advanced types of IP-aware intermediate systems. Therefore,
    I’ll begin with a consideration of two long-neglected subjects: firewalls in general,
    and network address translation (NAT) in particular.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这里讨论的大多数可复制的IP数据包修改都源自更高级的IP感知中间系统。因此，我将从两个长期被忽视的主题开始考虑：一般性的防火墙，特别是网络地址转换（NAT）。
- en: Firewalls are intended to remain stealthy bastions, and the less that is known
    about what the other guy uses, the better for him. Yet, despite rigorous firewall
    policies and settings, as these devices increase in complexity and become better
    suited to handle today’s security challenges, they also become easier to examine
    using indirect or passive probe techniques.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙旨在保持隐秘的堡垒，对其他人使用的了解越少，对他来说越好。然而，尽管有严格的防火墙策略和设置，随着这些设备复杂性的增加和它们更好地适应处理今天的网络安全挑战，它们也变得更容易使用间接或被动探测技术进行检查。
- en: Packet Firewall Basics
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包防火墙基础
- en: Popular firewalls^([[89](apb.html#ftn.CHP-11-BIB-1)]) are, in essence, a class
    of intermediate router devices engineered to violate the fundamental design of
    an intermediate router device. As opposed to routers proper, systems that are
    expected to make nondiscriminatory routing decisions based on the information
    encoded on the third OSI layer, firewalls usually interpret, act upon, or even
    modify information on higher layers (such as TCP or even HTTP). Firewall technology,
    although fairly recent, provides a well-established and well-understood set of
    solutions and can be found in home networks and in large corporations. Firewalls
    are configured to reject, allow, or redirect specific types of traffic addressed
    to specific services and are (not surprisingly) used to limit access to certain
    functions and resources for all traffic traveling across such a device. Hence,
    they provide a powerful, albeit sometimes overhyped and overly relied upon, security
    and network management solution.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 流行防火墙^([[89](apb.html#ftn.CHP-11-BIB-1)])在本质上是一类中间路由器设备，其设计目的是违反中间路由器设备的基本设计。与真正的路由器不同，那些预期基于第三层OSI编码的信息做出非歧视性路由决策的系统，防火墙通常会在更高层（如TCP甚至HTTP）上解释、执行或甚至修改信息。尽管防火墙技术相对较新，但它提供了一套成熟且易于理解的解决方案，可以在家庭网络和大型企业中找到。防火墙被配置为拒绝、允许或重定向针对特定服务的特定类型流量，并且（不出所料）被用来限制所有通过此类设备的流量对某些功能和资源的访问。因此，它们提供了一种强大、尽管有时被过度炒作和过度依赖的安全和网络管理解决方案。
- en: The key to the success of firewalls in all network environments is that they
    protect an array of complex systems using a single and comparatively more robust
    component and provide a fail-safe security measure if a configuration problem
    exposes a vulnerable service or function on a protected server. (In extreme cases,
    firewalls are used simply to cover for poor configuration and lack of maintenance
    of a protected system, usually with disastrous results.)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙在所有网络环境中取得成功的关键在于，它们使用单一且相对更健壮的组件来保护一系列复杂的系统，并在配置问题暴露受保护服务器上的易受攻击的服务或功能时提供一种安全措施。在极端情况下，防火墙被用来掩盖受保护系统的配置不当和维护不足，通常会导致灾难性的后果。
- en: Stateless Filtering and Fragmentation
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态过滤和分段
- en: Basic firewalls are stateless packet filters. They simply inspect certain features
    of every packet, such as the destination port on Transmission Control Protocol
    SYN connection attempts. They then decide, based on these characteristics alone,
    whether to allow the packet to go through. The stateless design is extremely simple,
    reliable, and memory and resource efficient. For example, a stateless firewall
    can limit incoming connections to a mail server to only those addressed to port
    25 (SMTP) by dropping all SYN packets but those addressed to this port. Because
    no connection can be established without this initial SYN packet, the attacker
    cannot interact with applications on other ports in a meaningful manner. To achieve
    this, the firewall does not have to be nearly as fast and complex as the mail
    server itself, because it does not need to keep a record of currently established
    connections and their exact state.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 基本防火墙是无状态数据包过滤器。它们只是检查每个数据包的某些特征，例如传输控制协议SYN连接尝试的目标端口。然后，它们仅基于这些特征来决定是否允许数据包通过。无状态设计极其简单、可靠，且内存和资源效率高。例如，无状态防火墙可以通过丢弃所有非目标端口25（SMTP）的SYN数据包，仅允许针对该端口的SYN数据包，来限制对邮件服务器的入站连接。因为没有任何连接可以在没有这个初始SYN数据包的情况下建立，攻击者无法以有意义的方式与其他端口上的应用程序交互。为了实现这一点，防火墙不需要像邮件服务器本身那样既快又复杂，因为它不需要记录当前建立的连接及其确切状态。
- en: The problem with this type of completely transparent protection is that the
    firewall and the final recipient might understand some of the parameters differently.
    For example, say an attacker convinces the firewall that it is connecting to an
    allowed port, but crafts its traffic so that the final recipient reads it differently
    and establishes a connection to a port that the firewall is supposed to be protecting.
    An attacker can thus access a vulnerable service or an administrative interface,
    and we are in trouble.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这种完全透明的保护类型的问题在于，防火墙和最终接收者可能对某些参数有不同的理解。例如，假设攻击者说服防火墙它正在连接到一个允许的端口，但构建了其流量，使得最终接收者以不同的方式读取它，并建立了与防火墙本应保护端口的连接。因此，攻击者可以访问易受攻击的服务或管理接口，我们就会陷入麻烦。
- en: Although causing such a misunderstanding might sound unlikely, it turned out
    to be fairly easy to achieve with the help of our old friend, packet fragmentation,
    using an approach commonly referred to as the “overlapping fragment attack”^([[90](apb.html#ftn.CHP-11-BIB-2)])
    (described in 1995 by RFC1858). In this situation, the attacker sends an initial
    packet, containing the beginning of the Transmission Control Protocol SYN request,
    to a port that is allowed by the victim’s firewall (such as the aforementioned
    port 25). The packet is missing only a tiny bit at the end and has a “more fragments”
    flag set in its IP header, but why should the firewall bother about the trailing
    data in a packet?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然造成这种误解听起来不太可能，但借助我们老朋友数据包碎片化，使用通常被称为“重叠碎片攻击”的方法（由RFC1858在1995年描述），实际上实现起来相当容易（^[[90](apb.html#ftn.CHP-11-BIB-2)])。在这种情况下，攻击者向一个由受害者防火墙允许的端口（例如上述端口25）发送一个初始数据包，该数据包包含传输控制协议SYN请求的开始部分。数据包在末尾缺少一小部分，并且在其IP头部中设置了“更多碎片”标志，但为什么防火墙要关心数据包末尾的数据呢？
- en: The firewall examines the packet, and because it is a SYN packet, its destination
    port is also examined and found acceptable. The packet is passed through, but
    the recipient does not interpret it immediately (remember the reassembly process
    discussed in [Chapter 9](ch09.html "Chapter 9. Foreign Accent")?). Instead, the
    packet is kept, pending the successful completion of defragmentation, which will
    not occur until the last trailing chunk of the packet arrives.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙检查数据包，由于这是一个SYN数据包，因此它的目标端口也被检查，并发现是可接受的。数据包被通过，但接收者不会立即解释它（还记得在第9章中讨论的重组过程吗？[第9章](ch09.html
    "第9章. 外国口音")？）。相反，数据包被保留，等待碎片重组成功完成，而这不会发生在最后一个尾部数据块到达之前。
- en: Next, the attacker sends a second packet fragment. This second packet is created
    to overlap with the original packet just enough so that it overwrites the destination
    port (one of the fields of the TCP header) at its location in the reassembly buffer.
    The fragment is crafted so that it starts at a nonzero offset and lacks most of
    the TCP header, except for the overwritten bit.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，攻击者发送第二个数据包碎片。这个第二个数据包被创建出来，足以与原始数据包重叠，从而在重组缓冲区中的位置覆盖目标端口（TCP头部的一个字段）。这个碎片被精心制作，以从非零偏移量开始，并且缺少大部分TCP头部，除了被覆盖的位。
- en: Because of this (and because it lacks the information needed to examine the
    flags of a TCP packet or other vital parameters the firewall could use to determine
    whether to allow or block this traffic), the second fragment is usually relayed
    as is by a stateless firewall. When combined with the first packet by the recipient,
    this second packet overwrites the original destination port to a more naughty
    value chosen by the attacker and actually opens a connection to a port that should
    be protected by the firewall.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因（以及因为它缺少检查TCP数据包标志或其他防火墙可能用来确定是否允许或阻止此流量的关键参数所需的信息），第二个碎片通常会被无状态防火墙原样转发。当接收者将其与第一个数据包结合时，这个第二个数据包会覆盖原始目标端口，改为攻击者选择的更恶意的值，实际上打开了一个应该由防火墙保护的端口。
- en: Whoops.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。
- en: Note
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To protect against this attack, a well-designed stateless firewall performs
    initial defragmentation before analyzing packets. This, however, makes it somewhat
    less “stateless,” and less transparent.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种攻击，一个设计良好的无状态防火墙在分析数据包之前先进行初始的碎片重组。然而，这使其在一定程度上失去了“无状态”的特性，并且变得不那么透明。
- en: Stateless Filtering and Out-of-Sync Traffic
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态过滤和不同步流量
- en: Another problem with stateless packet filters is that they are not nearly as
    tight as we might hope. The filtering can only be carried out when a single packet
    contains all the information necessary for the filter to make an informed decision
    on how to handle it. Because, following the initial handshake, a TCP connection
    is largely symmetrical, with both parties having equal rights and using the same
    type of traffic (ACK packets) to exchange data, it is not easy to apply meaningful
    filters to anything other than the initial phase of a connection. There is no
    way to determine who (if anyone) initiated the connection through which ACK packets
    are being swapped without actually tracking and recording connections. Thus, it
    is a bit hard to define in a meaningful way the filtering policy that the firewall
    should attempt to apply to traffic such as ACK and other midway packets such as
    FIN or RST.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态包过滤器的另一个问题是，它们并不像我们希望的那样严格。过滤只能在单个数据包包含所有必要信息，以便过滤器能够做出明智的决定来处理该数据包时进行。因为，在初始握手之后，TCP连接在很大程度上是对称的，双方拥有平等的权利，并使用相同类型的流量（ACK数据包）来交换数据，因此很难对连接的初始阶段以外的任何内容应用有意义的过滤器。没有方法可以确定（如果有的话）谁通过交换ACK数据包发起了连接，而不需要实际跟踪和记录连接。因此，很难以有意义的方式定义防火墙应尝试应用于ACK和其他中途数据包（如FIN或RST）的过滤策略。
- en: 'The inability to filter past SYN is not normally a problem. After all, if an
    attacker cannot deliver the initial SYN packets, they cannot establish a connection.
    But there’s a catch: how systems handle non-SYN traffic to a specific port depends
    on whether a port is closed or the system is listening on that port. For example,
    some operating systems reply with RST to stray FIN packets and generate no reply
    on ports that are in open (listening) state.^([[25](#ftn.CHP-11-FN-1)])'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 无法过滤SYN通常不是问题。毕竟，如果攻击者无法发送初始SYN数据包，他们就无法建立连接。但是有一个问题：系统如何处理特定端口上的非SYN流量取决于端口是否关闭或系统是否在该端口上监听。例如，一些操作系统会对漂流的FIN数据包回复RST，而在开启（监听）状态的端口上不产生任何回复.^([[25](#ftn.CHP-11-FN-1)])
- en: Techniques such as a FIN or ACK scan (the latter initially described by Uriel
    Maimon^([[91](apb.html#ftn.CHP-11-BIB-3)]) in *Phrack Magazine*), as well as NUL
    and Xmas scans (scans with illegal packets with no flags set and all flags set,
    respectively) can thus be used against stateless packet filters to gather preattack
    evidence about which ports are open on a remote system or to map out what traffic
    is being dropped by the firewall. The ability to learn that a specific port is
    open without the ability to establish a proper connection to it is not an immediate
    threat by itself. However, a scan of this nature often discloses extremely valuable
    information about network internals (such as the operating system and services
    being run), which can be used to facilitate a better, more efficient, and more-difficult-to-detect
    attack once the first line of defense is compromised or bypassed. Thus, this is
    perceived as a potential weakness of a stateless firewall.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 技术如FIN扫描或ACK扫描（后者最初由Uriel Maimon^([[91](apb.html#ftn.CHP-11-BIB-3)])在*Phrack杂志*中描述），以及NUL扫描和Xmas扫描（分别使用没有设置标志的非法数据包和所有标志都设置的数据包进行扫描）可以用来对抗无状态包过滤器，以收集关于远程系统上哪些端口是开启的攻击前证据，或者绘制防火墙丢弃的流量图。在没有能力建立到特定端口的正确连接的情况下，了解特定端口是开启的本身并不是一个直接的威胁。然而，这种类型的扫描通常会泄露关于网络内部（如正在运行的操作系统和服务）的极其有价值的信息，这些信息可以在第一道防线被攻破或绕过后，帮助实施更好、更高效且更难检测的攻击。因此，这被视为无状态防火墙的潜在弱点。
- en: Perhaps a more grave threat is associated with the mechanism of SYN cookies
    when combined with stateless filtering. SYN cookies are used to protect operating
    systems against resource starvation attacks, in which the attacker sends a very
    large number of spoofed connection requests to the host (not itself a difficult
    operation to perform). This forces the recipient to send bogus SYN+ACK replies,
    and additionally to allocate memory and consume other resources when adding this
    connection-to-be to its TCP state tables. Most systems under such an attack would
    either consume excess resources and slow to a crawl or deny service to all clients
    at some point until those bogus connections time out.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 可能与SYN cookies的机制结合使用时，更严重的安全威胁相关。SYN cookies用于保护操作系统免受资源耗尽攻击，在这种攻击中，攻击者向主机发送大量伪造的连接请求（这本身并不是一个难以执行的操作）。这迫使接收方发送虚假的SYN+ACK响应，并在将即将建立的连接添加到其TCP状态表时分配内存和消耗其他资源。在这种攻击下，大多数系统最终会消耗过多的资源而变得缓慢，或者在某些时候拒绝为所有客户端提供服务，直到那些虚假的连接超时。
- en: To deal with this potential problem, SYN cookies use a cryptographical signature
    (a shortcut, actually, identifying the connection uniquely) in all SYN+ACK responses
    inside the ISN field, and then forget about the connection altogether. Only once
    the ACK response arrives from the host, and only if the acknowledgement number
    validates against the cryptographic procedure, will the connection be added to
    the state table.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个潜在的问题，SYN cookies在ISN字段内的所有SYN+ACK响应中使用一个加密签名（实际上是一个快捷方式，用于唯一标识连接），然后完全忘记这个连接。只有当来自主机的ACK响应到达，并且只有当确认号通过加密过程验证后，连接才会被添加到状态表。
- en: The problem with SYN cookies, however, is that, in such a design, there is the
    possibility that SYN (and SYN+ACK response) was never sent in the first place.
    If the attacker can create an ISN cookie that validates against the host’s SYN
    cookie algorithm (perhaps because the attacker has enough bandwidth, or because
    the algorithm is weak), he can send an ACK packet that would trigger the remote
    host to add a new connection to its state table despite, as mentioned, not ever
    sending SYN and receiving SYN+ACK. A stateless firewall would have no way of knowing
    that a connection has just been established, because it never received the opening
    request in the first place! Because there is no initial SYN packet, the destination
    IP and port could not be checked by the firewall and either approved or rejected,
    and yet, a connection is all of a sudden established.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SYN cookies的问题在于，在这种设计中，存在一种可能性，即SYN（以及SYN+ACK响应）从未被发送过。如果攻击者可以创建一个能够验证主机SYN
    cookie算法的ISN cookie（可能是因为攻击者有足够的带宽，或者因为算法较弱），他可以发送一个ACK数据包，这将触发远程主机向其状态表添加一个新的连接，尽管如前所述，从未发送过SYN和接收过SYN+ACK。无状态防火墙将无法知道连接刚刚建立，因为它从未收到过打开请求！因为没有初始的SYN数据包，目标IP和端口无法被防火墙检查并批准或拒绝，然而，连接突然就建立了。
- en: That’s really bad.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很糟糕。
- en: Stateful Packet Filters
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态包过滤器
- en: To solve the problems of stateless filters, we need to store some of the information
    about previous traffic and the state of established streams on the firewall. This
    is the only way to transparently predict the outcome of defragmentation or to
    obtain the context for midconnection packets and decide whether they are illegitimate
    and should be discarded or are expected by the recipient and should be delivered.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决无状态过滤器的这些问题，我们需要在防火墙上存储一些关于先前流量和已建立流的状态信息。这是唯一一种可以透明地预测解碎片化结果或获取中间连接数据包的上下文，并决定它们是否是不合法的应该被丢弃，还是预期的应该被传递的方法。
- en: With the increase of affordable high-performance computing, it has become possible
    to devise firewall systems that are much more complex and advanced than we could
    ever imagine. Thus, we have progressed to stateful connection tracking, a situation
    in which the firewall not only examines single packets, but remembers the context
    of a connection and validates every packet against this data. This allows the
    firewall to seal the network tightly and to disregard undesirable or unexpected
    traffic without relying on the recipient’s ability to always tell good traffic
    from bad. Stateful packet filters try to track connections and allow only the
    traffic that belongs to one of the active sessions; as a result, they provide
    better protection and logging capabilities.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 随着可负担的高性能计算的增加，设计出比我们想象的更复杂和先进的防火墙系统成为可能。因此，我们已经发展到状态连接跟踪，在这种情况下，防火墙不仅检查单个数据包，还记住连接的上下文，并验证每个数据包是否与这些数据匹配。这使得防火墙能够紧密地封闭网络，并在不依赖接收方始终能够区分好流量和坏流量的能力的情况下，忽略不希望或意外的流量。状态数据包过滤器试图跟踪连接，并只允许属于活动会话之一的流量；因此，它们提供了更好的保护和日志记录功能。
- en: The task of stateful filtering is, of course, more challenging than stateless
    filtering and consumes considerably more resources, especially when a sizable
    network is protected by such a device. When protecting a large network, the firewall
    suddenly requires plenty of memory and a fast processor to store and look up the
    information about what is happening on the wire.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 状态过滤的任务当然比无状态过滤更具挑战性，并且消耗的资源要多得多，尤其是在一个大型网络被此类设备保护时。当保护一个大型网络时，防火墙突然需要大量的内存和快速的处理器来存储和查找有关线路上发生的事情的信息。
- en: Stateful analysis is also more likely to cause problems or confusion. Issues
    ensue as soon as the understanding of the current state of a given TCP/IP session
    differs between the firewall and the endpoints; a situation that is not unlikely
    given the ambiguity of specifications and the variety of stacks used. For example,
    upon receiving an RST packet that is not within sequence number limits accepted
    by the recipient, a firewall that applies sequence number inspection less stringently
    than the final recipient does might conclude that a connection is closed, whereas
    the recipient might conclude the session is still open and be willing to accept
    further communications pertaining to this connection, and vice versa. In the end,
    stateful inspection comes at a price.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 状态分析也更容易引起问题或混淆。一旦防火墙和端点对给定TCP/IP会话当前状态的理解不同，就会产生问题；鉴于规范的不确定性和使用的堆栈的多样性，这种情况并不罕见。例如，当接收到一个不在接收方接受的序列号限制范围内的RST数据包时，一个比最终接收方更宽松地应用序列号检查的防火墙可能会得出连接已关闭的结论，而接收方可能会得出会话仍然开放的结论，并愿意接受与此连接相关的进一步通信，反之亦然。最终，状态检查是有代价的。
- en: Packet Rewriting and NAT
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包重写和NAT
- en: The solution to improving packet interpretation, and to providing better protection
    against attacks such as those that use packet fragmentation to bypass firewall
    rules, was to give firewalls the ability to not only forward, but also rewrite
    portions of the traffic transmitted. For example, one approach attempts to resolve
    ambiguity by performing a mandatory packet defrag-mentation (reassembly) before
    comparing the packet against any access rules configured by the network administrator.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 提高数据包解释能力，以及提供更好的保护以抵御如使用数据包分片绕过防火墙规则之类的攻击的解决方案，是赋予防火墙不仅能够转发，还能重写传输流量部分的能力。例如，一种方法试图通过在将数据包与网络管理员配置的任何访问规则进行比较之前执行强制数据包分片（重组）来消除歧义。
- en: With the development of more sophisticated solutions, it became obvious that
    packet rewriting would not only benefit the network, but also provide a quantum
    leap for network security and functionality by deploying extremely useful technologies
    such as NAT. NAT is the practice of mapping certain IP addresses to a different
    set of IPs prior to forwarding them and demangling the responses sent back by
    a protected system. A stateful NAT mechanism can be used, among other applications,
    to implement fault-tolerant setups in which a single, publicly accessible IP address
    is served by more than one internal server. Or to save address space and improve
    security, NAT can be implemented to allow the internal network to use a pool of
    private, not publicly accessible, addresses, while enabling hosts on the network
    to communicate with the Internet by “masquerading” as a single public IP machine.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更复杂解决方案的发展，很明显，数据包重写不仅会惠及网络，而且通过部署诸如NAT（网络地址转换）等极其有用的技术，还能为网络安全和功能带来质的飞跃。NAT是在转发之前将某些IP地址映射到另一组IP地址，并对受保护系统发送回来的响应进行解包的实践。状态NAT机制可以用于多种应用，例如实现容错设置，其中单个公开可访问的IP地址由多个内部服务器提供服务。或者为了节省地址空间并提高安全性，可以实现NAT，允许内部网络使用一组私有、非公开可访问的地址，同时使网络上的主机能够通过“伪装”为单个公共IP机器来与互联网通信。
- en: In the first scenario, NAT rewrites destination addresses on incoming packets
    to a number of private systems behind the firewall. This provides a fault-tolerant
    load-balancing setup, in which subsequent requests to a popular website ([http://www.microsoft.com](http://www.microsoft.com),
    perhaps) or other critical service can be distributed among an array of systems,
    and if any one fails, other systems can take over. The task is sometimes achieved
    with dedicated devices (not surprisingly called *load balancers*), but often also
    supported by NAT-enabled firewalls.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，NAT将传入数据包的目标地址重写到防火墙后面的多个私有系统中。这提供了一种容错负载均衡设置，其中对热门网站（例如[http://www.microsoft.com](http://www.microsoft.com)，或许）或其他关键服务的后续请求可以在一系列系统中分配，如果任何一个系统失败，其他系统可以接管。这项任务有时是通过专用设备（不出所料地被称为*负载均衡器*）完成的，但通常也由启用NAT的防火墙支持。
- en: The latter scenario, commonly referred to as *masquerading*, relies on rewriting
    source addresses on outgoing packets so that a number of private, protected systems
    (that might be using private addresses not routed to this network from the Internet,
    such as 10.0.0.0) can connect to the external world by having their outgoing connections
    intercepted and rewritten by the firewall. The systems are hidden behind a firewall,
    and their actions appear to recipients outside the NAT-protected network as originating
    from the firewall. The connection is mapped to a specific public IP address and
    a specific port, and then the traffic is pushed out. All traffic returning from
    the destination to this IP and port is rewritten to point back to the private
    system that initiated the connection and forwarded to the internal network. This
    allows the entire private network of workstations that are not intended to offer
    any services to the Internet to remain not directly reachable from the external
    world, thus greatly increasing the network’s security, concealing some of its
    structure, and preserving expensive public IP address space that would otherwise
    have to be purchased to accommodate every system. Using this system, a party that
    has only one public IP routed to them can still construct a network of hundreds
    or thousands of computers and provide them with Internet access.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种情况，通常被称为*伪装*，依赖于重写传出数据包的源地址，这样多个私有、受保护的系统（可能使用的是从互联网路由到该网络的私有地址，例如10.0.0.0）可以通过防火墙拦截和重写它们的传出连接来连接到外部世界。这些系统隐藏在防火墙后面，它们的行为在外部NAT保护网络的外部接收者看来似乎是从防火墙发起的。连接被映射到特定的公共IP地址和特定的端口，然后流量被推出去。所有从目标返回到该IP和端口的流量都会被重写，指向发起连接的私有系统，并转发到内部网络。这使得整个不打算向互联网提供任何服务的私有工作站网络不会直接从外部世界访问，从而大大提高了网络的安全性，隐藏了其部分结构，并保留了本应购买以容纳每个系统的昂贵公共IP地址空间。使用这个系统，即使只有一个公共IP路由到他们，一个实体也可以构建一个由数百或数千台计算机组成的网络，并为它们提供互联网接入。
- en: Lost in Translation
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译中的迷失
- en: 'Once again, address translation is more complex than it might sound: some higher-level
    protocols are not as straightforward as just connecting to a remote system and
    sending a bunch of commands. For example, the ancient but wildly popular File
    Transfer Protocol^([[92](apb.html#ftn.CHP-11-BIB-4)]) (FTP), in its most basic
    and most widely supported mode, relies on establishing a return (reverse direction)
    connection from the server back to the client for the purpose of transferring
    the requested data; the initial connection initiated by the client is used only
    to issue commands. Many other protocols—most notably some chat pro-tocols, peer-to-peer
    collaboration or data-sharing tools, media broadcast services, and so forth—also
    use weird or unusual designs that call for reverse connections and port hopping
    or allowing specific session-less traffic (such as User Datagram Protocol [UDP]
    packets) back to the workstation.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，地址转换比听起来更复杂：一些高级协议并不像仅仅是连接到远程系统并发送一系列命令那样直接。例如，古老但广受欢迎的文件传输协议（FTP）在其最基本和最广泛支持的模式中，依赖于从服务器到客户端建立返回（反向方向）连接，用于传输请求的数据；客户端发起的初始连接仅用于发出命令。许多其他协议——最值得注意的是一些聊天协议、对等协作或数据共享工具、媒体广播服务等等——也使用奇怪或非传统的设计，需要反向连接和端口跳跃或允许特定的无会话流量（如用户数据报协议[UDP]数据包）返回工作站。
- en: To address these challenges, every implementation of masquerading that does
    not aim to render these protocols useless must be equipped with a number of protocol
    helpers. These protocols inspect the application data exchanged within a connection,
    even sometimes rewriting some of it and opening temporary holes in the firewall
    to allow for a return connection.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，任何不旨在使这些协议失效的伪装实现都必须配备一系列协议助手。这些协议检查连接内交换的应用数据，有时甚至重写其中一些数据，并在防火墙中打开临时孔洞以允许返回连接。
- en: And herein lies another problem, first spotted in FTP helper by Mikael Olsson
    several years ago^([[93](apb.html#ftn.CHP-11-BIB-5)]) and later researched in
    other protocol helpers by, among others, the author of this book.^([[94](apb.html#ftn.CHP-11-BIB-6)])
    The problem is that these helpers decide to open holes in the firewall based on
    the information sent by a workstation over a specific protocol to a remote system.
    They assume that the traffic generated by the system is being transmitted on the
    user’s behalf and with the user’s knowledge. Needless to say, some programs, such
    as web browsers, can be tricked into sending certain types of network traffic,
    including traffic that “looks like” a protocol the program does not natively support,
    and can even be forced to do so automatically by crafting specific malicious content
    and sending it to the application. This spoofed traffic can fool a helper program
    into poking a hole in the firewall.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Mikael Olsson多年前在FTP助手中发现的问题一样，这是另一个问题，后来由本书作者等人对其他协议助手进行了研究。问题是，这些助手根据工作站通过特定协议发送到远程系统的信息决定在防火墙中打开孔洞。它们假设由系统产生的流量是在用户的代表和用户的知情下传输的。不用说，一些程序，如网络浏览器，可能会被欺骗发送某些类型的网络流量，包括看起来像程序不原生支持的协议的流量，甚至可以通过构建特定的恶意内容并将其发送到应用程序来强制其自动这样做。这种欺骗流量可能会欺骗助手程序在防火墙中打孔。
- en: 'A classic example of such an attack is an abuse of a generic web browser: by
    adding a reference to a web page or a web element supposedly located on an attacker’s
    system on a nonstandard HTTP port (which is, however, quite standard for FTP traffic),
    the client can be forced to connect to this resource and attempt to issue an HTTP
    request. Because the port to which the connection is established is normally used
    by FTP, the firewall’s FTP helper starts listening to the conversation, hoping
    to give a hand when necessary.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的一个经典例子是滥用通用网络浏览器：通过在非标准HTTP端口（然而，对于FTP流量来说却相当标准）上添加对攻击者系统上某个网页或网页元素的引用，客户端可以被强制连接到这个资源并尝试发出HTTP请求。因为建立的连接端口通常用于FTP，防火墙的FTP助手开始监听对话，希望在必要时提供帮助。
- en: 'The following example URL would cause the HTTP client to connect to the FTP
    port and issue what appears to be an FTP `PORT`command, which would be picked
    up by the firewall helper:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例URL会导致HTTP客户端连接到FTP端口并发出看似FTP `PORT`命令，这将由防火墙助手捕获：
- en: '[PRE3]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The request issued by the client would be just meaningless gibberish to a legitimate
    FTP service on the other end, and the service’s response would be incomprehensible
    to the web client issuing this request—but that’s not the point. What matters
    is that the attacker can control a part of the request— the file name the client
    will request from the server. This fictitious file name, chosen by the rogue,
    can contain any data the rogue wishes. By making the file name contain substrings
    normally identified with FTP requests, the attacker can trick an FTP protocol
    helper that is listening to this connection for a specific text command (`PORT`)
    into believing that the user is attempting to download a specific file. Hence,
    the remote server is temporarily allowed to connect to the victim (here, to a
    naughty sounding port 31337—122*256+105=31337). And so we let the attacker in
    without the victim knowing. Oops—again, more than we bargained for.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发出的请求对另一端的合法FTP服务来说将毫无意义，而该服务的响应对发起此请求的Web客户端来说也是无法理解的——但这不是重点。重要的是，攻击者可以控制请求的一部分——客户端将从服务器请求的文件名。这个由恶意者选择的虚构文件名可以包含恶意者希望包含的任何数据。通过使文件名包含通常与FTP请求相关联的子串，攻击者可以欺骗一个正在监听此连接以特定文本命令（`PORT`）的FTP协议助手，使其相信用户正在尝试下载特定文件。因此，远程服务器暂时被允许连接到受害者（在这里，到一个听起来很调皮的端口31337——122*256+105=31337）。因此，我们让攻击者进入，而受害者却不知道。哎呀——又超过了我们的预期。
- en: '* * *'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^([[25](#CHP-11-FN-1)]) Some aspects of this behavior (the tendency to reply
    with RST to stray and unexpected packets to closed ports and simply disregarding
    the same traffic addressed to ports on which a service listens for connections)
    is mandated by RFC793, and some is just a practice chosen by a specific group
    of implementors.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-11-FN-1)]) 此行为的一些方面（对关闭端口上的意外和未预期的数据包回复RST，以及对监听连接端口的相同流量简单忽略）是由RFC793规定的，而另一些则是特定实施者群体选择的做法。
- en: The Consequences of Masquerading
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪装的后果
- en: All of the aforementioned scenarios are related to masquerading abuse, but the
    mere presence of masquerading itself can provide us with interesting information
    about another party.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有场景都与伪装滥用有关，但伪装本身的存在可以为我们提供有关另一方的有趣信息。
- en: 'As noted earlier, masquerading is not nonintrusive. Its basic operating principle
    is to alter the outgoing traffic by rewriting portions of it. In so doing, it
    goes beyond merely tweaking the address and not only makes it possible to conclude
    that masquerading is taking place, but also enables a careful observer to identify
    the particular firewall system in use. Specifically, when using masquerading,
    we may encounter some of the following changes:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，伪装不是非侵入性的。其基本操作原理是通过重写部分流量来改变出站流量。在这个过程中，它不仅超越了仅仅调整地址，而且不仅使得可以得出伪装正在进行的结论，而且还使仔细的观察者能够识别正在使用的特定防火墙系统。具体来说，当使用伪装时，我们可能会遇到以下一些变化：
- en: There will be an observed discrepancy between the TTL on arriving packets and
    the expected or measured distance to the destination network. Traffic that originated
    behind a masquerade is at least one hop “older” than a packet originating from
    a system that gets its IP address for outgoing connections directly from a protected
    network.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到达数据包的TTL（时间到寿命）与预期或测量的目标网络距离之间将存在观察到的差异。在伪装背后发起的流量至少比直接从受保护网络获取IP地址用于出站连接的系统发起的包“老”一个跳数。
- en: In most cases, various operating systems or slightly different system configurations
    (or uptimes) can be found in the originating network. These systems have slightly
    different TCP/IP characteristics, as discussed in [Chapter 9](ch09.html "Chapter 9. Foreign
    Accent") and [Chapter 10](ch10.html "Chapter 10. Advanced Sheep-Counting Strategies").
    If we observe various TCP/IP fingerprints in connections seemingly originating
    from the same IP, we can get a strong hint as to whether NAT is present at a particular
    machine with an internal network behind it.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，原始网络中可以找到各种操作系统或略有不同的系统配置（或运行时间）。这些系统具有略微不同的TCP/IP特性，如第9章[“外国口音”](ch09.html
    "Chapter 9. Foreign Accent")和第10章[“高级羊计数策略”](ch10.html "Chapter 10. Advanced Sheep-Counting
    Strategies")中所述。如果我们观察到从同一IP地址看似发起的连接中存在各种TCP/IP指纹，我们可以得到一个强有力的提示，即在其内部网络背后的特定机器上是否存在NAT。
- en: Finally, a remote observer is likely to notice *source port shift*. This is
    an other-wise unusual occurrence that arises because connections coming from the
    network are using ephemeral source ports that are not in the particular operating
    system’s normal range.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，远程观察者可能会注意到*源端口偏移*。这是一种不寻常的异常情况，因为它是由来自网络的连接使用临时源端口引起的，而这些端口不在特定操作系统的正常范围内。
- en: Every operating system reserves a specific range of source ports for establishing
    a local endpoint identifier for all outgoing connections. However, a firewall
    often uses a different range of ports for mapping masqueraded connections that
    is specific to the NAT device’s operating system. In this case, if the observed
    ranges differ from what is expected for the detected operating system (for example,
    if Linux, which normally operates in the range of 1024 to 4999, appears to be
    using very high port numbers instead), it is possible to deduce the presence of
    address translation and sometimes even determine the type of firewall in use.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都为所有出站连接保留了一组特定的源端口，以建立本地端点标识符。然而，防火墙通常使用不同的端口范围来映射伪装连接，这取决于NAT设备的操作系统。在这种情况下，如果观察到的范围与检测到的操作系统预期的范围不符（例如，如果Linux通常在1024到4999的范围内运行，但看起来正在使用非常高的端口号），则可以推断出存在地址转换，有时甚至可以确定正在使用的防火墙类型。
- en: These techniques are commonly used and form the basis for masquerade detection
    and masqueraded network reconnaissance. But several other means of detecting packet
    rewriting are also available.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术通常被使用，并构成了伪装检测和伪装网络侦察的基础。但还有其他几种检测数据包重写的方法。
- en: Segment Size Roulette
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分段大小轮盘赌
- en: One of the less obvious and hence less popular ways to detect packet rewriting
    devices and learn more about network configuration is analyzing the maximum segment
    size field in incoming traffic.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 检测数据包重写设备和了解更多关于网络配置的较不明显且因此不太受欢迎的方法之一是分析传入流量中的最大分段大小字段。
- en: Because IP packet fragmentation adds noticeable overhead to the fragmented traffic,
    it is often perceived as a performance nightmare, and many implementers try to
    prevent it. On the other hand, as discussed earlier, fragmentation is difficult
    to eliminate, as it seems to be nearly impossible to accurately, quickly, and
    reliably determine the maximum transmission unit (MTU) over a path in advance
    of actual communications. Even the best method available, path MTU discovery,
    is far from perfect and still impacts performance when triggered. In order for
    it to detect the correct MTU setting by trial and error, some packets that do
    not fit might have to be discarded and be resent.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP数据包分片会给分片流量增加明显的开销，因此它通常被视为性能噩梦，许多实施者试图防止它。另一方面，如前所述，由于似乎几乎不可能在通信之前准确、快速、可靠地确定路径上的最大传输单元（MTU），因此分片难以消除。即使是最好的方法，路径MTU发现，也远非完美，并且在触发时仍然会影响性能。为了通过试错来检测正确的MTU设置，可能需要丢弃一些不合适的包并重新发送。
- en: To prevent the performance and reliability impact of path MTU discovery and
    reduce the overhead of fragmentation, many NAT firewalls that rewrite certain
    parameters of outgoing traffic also change the declared Maximum Segment Size (MSS)
    parameter in TCP headers on connections originating from the private network to
    one more suitable for the external link from the network. This new setting is
    likely to be slightly narrower (have a lower MTU) than that of the LAN. This modification
    ensures that the receiving party does not attempt to send data that would not
    fit over the link if that link is across the particular part of the infrastructure
    with the lowest MTU, thus making fragmentation less likely to occur. (This assumes
    that any MTU incompatibility is most likely to occur near the sender or recipient
    system on the so-called last mile, where various types of low MTU links, such
    as DSL connections or wireless lines, are often found, and packets might need
    to be “downsized” to fit through those pipes.)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止路径MTU发现对性能和可靠性的影响，并减少分片的开销，许多重写出站流量某些参数的NAT防火墙也会更改从私有网络发起的连接上的TCP头部中的声明的最大分段大小（MSS）参数，使其更适合网络的对外链路。这个新设置可能比局域网的设置略窄（MTU更低）。这种修改确保接收方不会尝试发送无法通过该链路传输的数据，如果该链路跨越具有最低MTU的特定基础设施部分，从而降低分片发生的可能性。（这假设任何MTU不兼容性最有可能发生在所谓的最后一英里处的发送方或接收方系统上，在那里经常可以发现各种类型的低MTU链路，如DSL连接或无线线路，数据包可能需要“缩小”以通过这些管道。）
- en: 'This reduction in the MSS alone is not particularly easy to detect. In fact,
    it is impossible to tell whether the MSS was set to a given value by the sender
    or modified somewhere down the road. That is, except for one minor thing. Recall
    from [Chapter 9](ch09.html "Chapter 9. Foreign Accent") that there is something
    special about the window size selection algorithm on many of today’s systems:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 仅MSS的这种减少并不容易检测。事实上，无法确定MSS是否被发送方设置为特定值，或者在某些地方被修改。也就是说，除了一个微小的细节。回想一下[第9章](ch09.html
    "第9章. 外国口音")中提到的，许多今天系统的窗口大小选择算法有一些特殊之处：
- en: The window size setting determines the amount of data that can be sent without
    acknowledgment. The specific setting is often chosen according to the developer’s
    personal voodoo rules and other religious beliefs. The two most popular approaches
    say the value should be either a multiple of the MTU minus protocol headers (a
    value referred to as Maximum Segment Size, or MSS) or simply something sufficiently
    high and “round.” Older versions of Linux (2.0) used values that were powers of
    2 (for example, 16,384). Linux 2.2 switched to a multiple of MSS (11 or 22 times
    MSS, for some reason), and newer versions of Linux commonly use 2 to 4 times MSS.
    The Sega Dreamcast, a network-enabled console, uses a value of 4,096, and Windows
    often uses 6,4512.
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 窗口大小设置决定了可以发送而不需要确认的数据量。具体的设置通常根据开发者的个人神秘规则和其他宗教信仰来选择。两种最流行的方法认为该值应该是MTU减去协议头部的倍数（称为最大分段大小，或MSS）或者简单地足够高且“圆整”。Linux的旧版本（2.0）使用的是2的幂次方（例如，16384）。Linux
    2.2版本改为MSS的倍数（11或22倍MSS，原因不明），而Linux的新版本通常使用2到4倍的MSS。网络功能齐全的Sega Dreamcast使用4,096的值，而Windows通常使用6,4512。
- en: An ever-increasing number of today’s systems (including newer versions of Linux
    and Solaris, certain versions of Windows, and SCO UnixWare) uses a window size
    setting that is a multiple of the MSS. Thus, it’s easy to tell when the MSS setting
    in a packet has been tampered with because the window size on the resulting packet
    will no longer be a specific multiple of MSS. In fact, it’s likely that it will
    no longer divide by MSS at all.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 今天越来越多的系统（包括Linux和Solaris的新版本，某些版本的Windows和SCO UnixWare）使用的是MSS的倍数作为窗口大小设置。因此，当数据包中的MSS设置被篡改时，很容易就能发现，因为结果数据包的窗口大小将不再是MSS的特定倍数。实际上，它可能根本不再能被MSS整除。
- en: By comparing the MSS to window size, you can reliably detect the presence of
    a group of firewalls that support MSS *clamping* (readjusting to match the link)
    on a variety of systems. Although clamping is optional on Linux and FreeBSD, it
    is often performed automatically on home firewalls and on smart DSL routers or
    other home networks. Hence, the presence of an anomalous MSS setting indicates
    not only a packet-rewriting device, but an association also with NAT capability,
    which can be taken as an indicator of the sender’s network connection.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较MSS和窗口大小，你可以可靠地检测到支持MSS *clamp*（调整以匹配链路）的一组防火墙存在于各种系统中。尽管在Linux和FreeBSD上clamp是可选的，但家庭防火墙、智能DSL路由器或其他家庭网络通常会自动执行。因此，异常的MSS设置不仅表明存在一个包重写设备，而且还与NAT功能相关联，这可以被视为发送者网络连接的指标。
- en: Stateful Tracking and Unexpected Responses
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态跟踪和意外响应
- en: Another important consequence of stateful connection tracking and packet rewriting
    is that some RFC-mandated responses are generated by the firewall, not the sender.
    This enables an attacker to discover and probe such a device quite efficiently.
    When a connection is dropped from the NAT state table (whether due to a time-out
    or to a termination by one of the endpoints with an RST packet that did not reach
    the other end), further traffic in this session will not be forwarded to the recipient,
    as it would with stateless packet filters. It is handled directly by the firewall,
    instead.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 状态连接跟踪和包重写的一个重要后果是，一些由RFC规定的响应是由防火墙而不是发送者生成的。这使得攻击者能够相当高效地发现和探测这样的设备。当一个连接从NAT状态表中删除（无论是由于超时还是由于一个端点发送了RST包，而这个RST包没有到达另一端）时，本会话中的进一步流量将不会转发给接收者，就像无状态包过滤器那样。相反，它将由防火墙直接处理。
- en: The TCP/IP specification mandates that a recipient reply to all unexpected ACK
    packets with RST, to inform the sender that the session they are attempting to
    continue is no longer honored by the recipient or never was. Some firewalls might
    violate the RFC and refuse to reply to this traffic at all, simply dropping packets
    that do not seem to belong to an existing session. (This is not always wise, because
    it can cause unnecessary delays when a legitimate connection is dropped due to
    intermittent network problems.)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP规范要求接收者对所有意外的ACK包回复RST，以告知发送者，他们试图继续的会话不再被接收者尊重或从未被尊重。一些防火墙可能会违反RFC，拒绝回复此类流量，简单地丢弃看起来不属于现有会话的包。（这并不总是明智的，因为它可以在合法连接由于间歇性网络问题而断开时造成不必要的延迟。）
- en: Numerous devices, however, reply with a legitimate and expected RST packet.
    This opens yet another avenue for the detection and careful finger-printing of
    the firewall device. Because the packet is created from scratch by the firewall,
    its parameters relate to the firewall, not to what the firewall is protecting.
    This allows the traditional fingerprinting techniques discussed in [Chapter 9](ch09.html
    "Chapter 9. Foreign Accent") (such as examining DF flags, TTL, window size, option
    types, values and ordering, and so on) to be used to identify the firewall.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多设备会回复一个合法且预期的RST包。这为检测和仔细指纹识别防火墙设备开辟了另一条途径。因为数据包是由防火墙从头创建的，所以其参数与防火墙相关，而不是与防火墙所保护的内容相关。这使得可以在[第9章](ch09.html
    "第9章. 外国口音")中讨论的传统指纹识别技术（例如检查DF标志、TTL、窗口大小、选项类型、值和顺序等）被用来识别防火墙。
- en: There is also another possibility, per RFC1122:^([[95](apb.html#ftn.CHP-11-BIB-7)])
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC1122，还存在另一种可能性：^([[95](apb.html#ftn.CHP-11-BIB-7)])
- en: '4.2.2.12 RST Segment: RFC-793 Section 3.4'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.2.2.12 RST段：RFC-793第3.4节
- en: A TCP SHOULD allow a received RST segment to include data.
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TCP应该允许接收到的RST段包含数据。
- en: 'DISCUSSION: It has been suggested that an RST segment could contain ASCII text
    that encoded and explained the cause of the RST. No standard has yet been established
    for such data.'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 讨论内容：有人建议RST段可以包含ASCII文本，该文本编码并解释了RST的原因。但目前还没有为这类数据建立标准。
- en: And indeed, even though no standard had been established, some systems choose
    to reply with verbose (albeit often cryptic) RST messages upon encountering a
    stray ACK, hoping that the other party will find comfort in knowing what went
    wrong. These replies often include internal keywords or, it would seem, attempts
    at some strange genre of geek humor that may be operating system specific, such
    as `no tcp, reset`; `tcp_close, during connect` (Mac OS); `tcp_fin_wait_2_timeout;
    No TCP` (HP/UX); `new data when detached; tcp_lift_anchor, can't wait` (SunOS).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尽管没有建立标准，一些系统在遇到意外的ACK时选择以冗长的（尽管通常是晦涩的）RST消息回复，希望对方能够从知道出了什么问题中得到安慰。这些回复通常包括内部关键字，或者看起来像是某种奇怪的极客幽默尝试，可能是特定于操作系统的，例如`no
    tcp, reset`；`tcp_close, during connect`（Mac OS）；`tcp_fin_wait_2_timeout; No TCP`（HP/UX）；`new
    data when detached; tcp_lift_anchor, can't wait`（SunOS）。
- en: Whenever we see such a verbose RST packet in response to network problems or
    unexpected traffic sent to the host, and we otherwise know that the remote system
    from which it originated does not use such verbose messages, we get a hint. We
    can deduce that there is a device between us and the recipient, likely a stateful
    firewall, and we can tell its operating system by matching the response against
    known messages produced by common and not-so-common operating systems.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们看到在网络问题或意外发送到主机的流量中响应的这种冗长的RST数据包，并且我们知道它起源于的远程系统不使用这种冗长的消息时，我们就会得到一个提示。我们可以推断出在我们和接收者之间有一个设备，很可能是一个有状态防火墙，我们可以通过将响应与已知消息进行匹配来识别其操作系统，这些消息是由常见的和不太常见的操作系统产生的。
- en: These two fingerprinting techniques prove to be extremely effective in detecting
    the presence of stateful packet filters whenever network traffic can be observed
    during short-term network problems. These techniques can also be used for active
    fingerprinting without targeting the firewall device itself by sending a stray
    ACK packet to a target to differentiate stateless and stateful filters. Based
    on the target’s response to the packet, the attacker can then devise the best
    method to approach the firewall (or use the knowledge gained in other ways).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种指纹技术被证明在短期网络问题期间可以观察到网络流量时，在检测状态包过滤器的存在方面极为有效。这些技术还可以通过向目标发送意外的ACK数据包来用于主动指纹，而不针对防火墙设备本身，以区分无状态和有状态过滤器。根据目标对数据包的响应，攻击者可以制定最佳方法来接近防火墙（或以其他方式使用获得的知识）。
- en: 'Reliability or Performance: The DF Bit Controversy'
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性或性能：DF位的争议
- en: Path MTU discovery (PMTUD) is a fingerprinting venue that is closely related
    to the IP fragmentation avoidance scheme described in [Chapter 9](ch09.html "Chapter 9. Foreign
    Accent").
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 路径MTU发现（PMTUD）是一个与第9章中描述的IP分片避免方案密切相关的指纹场所[第9章](ch09.html "第9章. 外国口音")。
- en: Recent versions of the Linux kernel (2.2, 2.4, 2.6) and of Windows (2000 and
    XP) implement and enable PMTUD by default. Thus, unless this setting is changed,
    all traffic originating from them has a don’t fragment (DF) bit set. Again, the
    path discovery algorithm tends to cause issues in some rare but not entirely unheard
    of situations.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的最近版本（2.2、2.4、2.6）和Windows（2000和XP）默认实现并启用PMTUD。因此，除非更改此设置，否则从它们起源的所有流量都将设置不进行分片（DF）位。再次强调，路径发现算法在罕见但并非完全未听闻的情况中往往会引起问题。
- en: Path MTU Discovery Failure Scenarios
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径MTU发现失败场景
- en: The problem with PMTUD is that it depends on the ability for the sender of a
    packet to receive the ICMP error message *“*fragmentation required but DF set*”*
    and to determine the optimal settings for a connection. The packet that triggered
    the message is discarded before reaching the destination and has to be resized
    and sent again.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: PMTUD（路径最大传输单元发现）的问题在于，它依赖于数据包发送者接收ICMP错误消息“*需要分片但设置了DF位*”的能力，并确定连接的最佳设置。触发该消息的数据包在到达目的地之前被丢弃，并需要重新调整大小后再次发送。
- en: If the sender does not receive this message, they remain unaware that their
    packet did not get through. This prompts a delay at best or an indefinite lockup
    of the connection at worst, since retransmissions are also not likely to get through
    a link for which the maximum allowed size of a packet is smaller than what the
    sender is trying to push through.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送者没有收到这条消息，他们就会对自己的数据包没有通过保持无知。这最多会导致延迟，在最坏的情况下会导致连接无限期地锁定，因为重传也不太可能通过一个最大允许数据包大小小于发送者试图推送的数据包大小的链路。
- en: The ICMP message generated when a packet is too large for a link is not guaranteed
    to reach the sender, however. In some networks, as a result of an ill-conceived
    attempt to improve security, all ICMP messages are simply dropped. Finally, even
    if a device sends one, it might not be delivered.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包对于链路来说太大时生成的ICMP消息并不保证能到达发送者。在某些网络中，由于一个旨在提高安全性的不切实际的尝试，所有ICMP消息都被简单地丢弃。最后，即使设备发送了这样的消息，它也可能无法送达。
- en: 'Why would ICMP messages be dropped? Because historically, many such messages
    were known to cause security problems: certain oversized or fragmented ICMP packets
    corrupted the kernel memory in many systems (also called the “ping of death”).
    ICMP messages sent to broadcast addresses were also used to trigger a storm of
    responses to a spoofed source address in an attack named “Smurf,” as well as to
    carry out DoS attacks. Too, incorrectly configured systems often interpreted a
    specific type of ICMP broadcasts, a router advertisement message,^([[26](#ftn.CHP-11-FN-2)])
    as a command to modify their network settings. Because they would accept it, regardless
    of whether those messages could be trusted, this opened yet another interesting
    attack route. And so, ICMP is feared and blocked by many.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会丢弃ICMP消息呢？因为历史上，许多此类消息都已知会导致安全问题：某些过大的或分片后的ICMP数据包在许多系统中损坏了内核内存（也称为“死亡之ping”）。发送到广播地址的ICMP消息也被用于触发名为“Smurf”的攻击中对伪造源地址的响应风暴，以及执行DoS攻击。此外，配置不当的系统通常将特定类型的ICMP广播，即路由器通告消息^([[26](#ftn.CHP-11-FN-2)])解释为修改其网络设置的命令。由于它们会接受这些消息，无论这些消息是否可信，这又开辟了另一个有趣的攻击途径。因此，ICMP被许多人所恐惧并被阻止。
- en: Note
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A suggestion to reject all ICMP traffic can often be found in naive security
    guides, and some system administrators follow it. I have even seen it in a professional
    pen-test recommendation from an acclaimed auditor, whose name I regrettably cannot
    reveal here.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些简单的安全指南中，经常会建议拒绝所有ICMP流量，并且一些系统管理员会遵循这一建议。我甚至在一个著名审计员的职业渗透测试建议中看到过这一点，遗憾的是，我无法在此透露他的名字。
- en: Another issue that can make PMTUD unreliable is that some received error messages
    come from devices that use private address space. Sometimes, in order to preserve
    limited public IP address space (which is usually expensive), interfaces on the
    cable that connect the router and the firewall of a remote network are chosen
    from a pool of addresses reserved for private, local use, instead of from ones
    actually routed to the particular network from the outside world.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题可能会使PMTUD变得不可靠，那就是一些接收到的错误消息来自使用私有地址空间的设备。有时，为了保留有限的公共IP地址空间（这通常很昂贵），连接远程网络的路由器和防火墙的电缆接口是从为私有、本地使用保留的地址池中选择，而不是从实际上从外部世界路由到特定网络的地址中选择。
- en: Unfortunately, the use of private address space can break PMTUD. Why? Because
    if a packet coming from the external world is too big to be forwarded by the recipient’s
    firewall to the destination, the firewall sends an ICMP error message with a source
    address of the firewall itself, which belongs to the private pool. The firewall
    of the sender of the original packet can then reject such a response packet, because
    it appears to come from the external world, but with an IP address from a private
    pool (perhaps even from the same pool as the sender’s private LAN). The firewall
    rejects this traffic because it is usually a sign of a spoofing attempt intended
    to impersonate a trusted, internal host. However, in this case, this decision
    breaks a relatively recent PMTU discovery mechanism and leaves the original sender
    unaware that their packet did not get through.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用私有地址空间可能会破坏PMTUD。为什么？因为如果来自外部世界的数据包太大，无法由接收方的防火墙转发到目的地，防火墙会发送一个带有防火墙自身源地址的ICMP错误消息，该地址属于私有地址池。原始数据包发送方的防火墙随后可以拒绝这样的响应数据包，因为它看起来来自外部世界，但带有来自私有地址池的IP地址（可能甚至来自与发送方私有LAN相同的池）。防火墙拒绝这种流量，因为它通常是一个试图冒充受信任内部主机的欺骗尝试的迹象。然而，在这种情况下，这个决定破坏了一个相对较新的PMTU发现机制，并使原始发送者无法意识到他们的数据包没有通过。
- en: To make things worse, even if all conditions are right, and the packet reaches
    its destination, many of today’s devices limit ICMP response rates and will not
    send more than a given number of messages during a particular time period. This,
    too, has been implemented as a security measure. Because ICMP messages were designed
    for informational purposes only and were not critical to communication before
    the introduction of PMTUD algorithms, rate limiting seemed like a sensible way
    to fend off certain types of DoS or bandwidth starvation attacks.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，即使所有条件都恰到好处，并且数据包到达了目的地，许多现代设备也会限制ICMP响应速率，并在特定时间段内不会发送超过一定数量的消息。这也被实施作为一种安全措施。由于ICMP消息最初是为了信息目的而设计的，并且在PMTUD算法引入之前并不对通信至关重要，因此速率限制似乎是一种合理的防御某些类型的DoS或带宽饥饿攻击的方法。
- en: The Fight against PMTUD, and Its Fallout
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与PMTUD的斗争及其后果
- en: In light of the foregoing, some regard PMTUD as a fairly bad design. It offers
    a slight performance improvement but at the price of infrequent but persistent
    and usually hard-to-diagnose problems that can prevent users from accessing specific
    servers or cause their connections to stall unexpectedly. Although many “black-hole
    detection” algorithms were devised to detect hosts or networks for which PMTUD
    should be disabled (and these work with varying success), this does not fully
    solve the problem and can introduce additional delays—usually when least desirable.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述情况，有些人认为PMTUD是一个相当糟糕的设计。它带来了一点点性能提升，但代价是偶尔出现但持续且通常难以诊断的问题，这些问题可能会阻止用户访问特定的服务器或导致他们的连接意外中断。尽管已经设计了多种“黑洞检测”算法来检测应该禁用PMTUD的主机或网络（并且这些算法的效果各不相同），但这并没有完全解决问题，并且可能会引入额外的延迟——通常在不太希望的时候。
- en: 'To solve these problems and avoid complaints, some commercial firewall vendors
    configure their solutions to perform a dirty trick: They clear the DF flag on
    all outgoing traffic. This is a subtle and often appreciated modification, but
    it is also a great way to identify the presence of a packet-filtering and rewriting
    device. If the characteristics of PMTUD-enabled systems are observed at a given
    address or a given network, but the incoming packets lack a DF flag as expected,
    the careful observer can deduce the presence and type of a firewall, thus obtaining
    another tiny bit of data without any interaction with the victim.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题并避免投诉，一些商业防火墙供应商配置他们的解决方案执行一个肮脏的伎俩：他们在所有出站流量上清除DF标志。这是一个微妙且通常受到赞赏的修改，但也是一个很好的方法来识别存在数据包过滤和重写设备。如果在某个地址或某个网络观察到启用了PMTUD系统的特征，但预期的入站数据包缺少DF标志，那么细心的观察者可以推断出防火墙的存在和类型，从而获得另一小块数据，而无需与受害者有任何交互。
- en: '* * *'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^([[26](#CHP-11-FN-2)]) Router advertisements were intended to allow the autoconfiguration
    of network hosts without the need to enter any settings by hand. The router periodically—or
    on request—broadcast a message saying, “Here I am. Use me.” By default, some systems
    accepted unsolicited advertisements without much hesitation—a bad idea.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-11-FN-2)]) 路由器广告的目的是允许网络主机自动配置，而无需手动输入任何设置。路由器定期或根据请求广播一条消息，内容是：“我在这里。使用我。”默认情况下，一些系统在几乎没有犹豫的情况下接受未经请求的广告——这是一个糟糕的想法。
- en: Food for Thought
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考材料
- en: This concludes my little story about how making firewalls better and more powerful
    to prevent infiltration and direct reconnaissance also made them easier to examine
    with indirect assessment. But allow me this brief digression.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于如何通过使防火墙更好、更强大以防止渗透和直接侦察，同时也使它们更容易通过间接评估来检查的简短故事。但请允许我简要地偏离一下。
- en: Perhaps the most bizarre and interesting discovery is one I encountered somewhere
    back in 1999\. Although not directly related to the design of firewalls, it still
    provides interesting food for thought for anyone interested in the problem of
    passively fingerprinting interim systems.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最奇特且有趣的发现之一是我1999年左右在某个地方遇到的。尽管这与防火墙的设计没有直接关系，但它仍然为对被动指纹识别临时系统问题感兴趣的人提供了有趣的思考材料。
- en: Jacek P. Szymanski, with whom I worked briefly and with whom I later had the
    pleasure of discussing certain unusual and suspicious network traffic patterns,^([[27](#ftn.CHP-11-FN-3)])
    noted a sudden increase in badly broken TCP/IP packets coming to port 21536 (and,
    to a lesser extent, to ports such as 18477 or 19535). The broken packets always
    originated from ports such as 18245, 21331, or 17736 and came from a large number
    of systems in the dial-up address space operated by `Poland`’s national telco,
    Telekomunikacja Polska.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾短暂地与Jacek P. Szymanski共事，后来我有幸与他讨论了一些不寻常和可疑的网络流量模式^([[27](#ftn.CHP-11-FN-3)])，他注意到端口21536（以及在一定程度上，如端口18477或19535）接收到的严重损坏的TCP/IP数据包突然增加。这些损坏的数据包总是来自端口18245、21331或17736，并且来自由波兰国家电信运营商Telekomunikacja
    Polska运营的大量拨号地址空间中的系统。
- en: Once a couple of those packets were captured, the traffic was badly and strangely
    mangled. The packets arrived with IP headers in place (with protocol type set
    to TCP), but the headers were immediately followed with TCP payload—the TCP headers
    were simply gone. The observed port combinations resulted from interpreting the
    first four bytes of the payload as a pair of numbers (which, had there been a
    TCP header there instead, would correspond to the source and destination port
    combination). The pair 18245 and 21536 was merely a representation of the text
    string “GET ”—four characters that open most HTTP requests transferred over the
    network. Similarly, 18477 and 21331 stood for SSH-, an opening phrase of every
    Secure Shell session. And 19535 and 17736 represented EHLO, a command that opens
    all ESMTP (Extended SMTP) sessions.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦捕获了几次这些数据包，流量就变得严重且奇怪地扭曲。数据包到达时IP头部完好（协议类型设置为TCP），但紧接着就是TCP有效载荷——TCP头部消失了。观察到的端口组合是由将有效载荷的前四个字节解释为一对数字（如果那里有TCP头部，则对应源端口和目的端口组合）得出的。这对18245和21536仅是文本字符串“GET
    ”的表示——这四个字符是大多数通过网络传输的HTTP请求的开头。同样，18477和21331代表SSH-，这是每个Secure Shell会话的开头短语。而19535和17736代表EHLO，这是一个打开所有ESMTP（扩展SMTP）会话的命令。
- en: But the reason this type of traffic suddenly began to appear remained a mystery.
    Too, why did it come only from this particular network? And why did this type
    of packet mangling not result in connectivity problems or other inconvenience
    for the users, if some network equipment did indeed produce it?
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种类型的流量突然出现的原因仍然是个谜。同样，为什么它只来自这个特定的网络？而且，如果某些网络设备确实产生了这种类型的包损坏，为什么这种类型的包损坏不会导致用户连接问题或其他不便？
- en: The answer soon followed. As it turned out, all the observed traffic originated
    from Nortel CVX devices, a modem access system that this telco had begun to use.
    The problem occurred only sporadically, under heavy load. Consequently, only a
    small percentage of incomplete packets were sent, and only this small number reached
    the recipients (to their utmost surprise). The most likely reason was improper
    queue locking or buffer management, a problem that could be noticed only when
    numerous sessions were processed nearly simultaneously. In such cases, certain
    packets seemed to be sent out too early, while still “under construction,” or
    were otherwise mangled by the implementation.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很快就来了。结果证明，所有观察到的流量都来自Nortel CVX设备，这是一种调制解调器接入系统，该电信运营商已经开始使用。问题仅在负载过重时偶尔发生。因此，只有一小部分不完整的数据包被发送，而且只有这么少的数据包到达了接收者（令他们非常惊讶）。最可能的原因是不正确的队列锁定或缓冲区管理，只有在大量会话几乎同时处理时才能注意到这个问题。在这种情况下，某些数据包似乎发送得太早，还在“建设中”，或者被实现方式扭曲了。
- en: The company fixed their TCP/IP implementation shortly after the deployment in
    Poland, and all lived happily ever after. But, as you can imagine, they were not
    the first and not the last to accidentally leave a unique footprint of their systems
    in packets they trafficked.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司在波兰部署后不久就修复了他们的TCP/IP实现，从此之后一切顺利。但正如你可以想象的那样，他们并不是第一个也不是最后一个在传输的数据包中无意中留下系统独特印记的公司。
- en: The moral of this story is that it is once again naive to disregard what we
    typically ignore. In today’s networking world subtle hints and unusual or unexpected
    and unexplained observations are extremely valuable. They are easy to find, but
    difficult to analyze.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义在于，忽视我们通常忽略的东西再次显得过于天真。在当今的联网世界中，细微的暗示、不寻常或出乎意料且未解释的观察结果极其宝贵。它们很容易找到，但很难分析。
- en: 'Perhaps food for thought and a field worth further exploration are the various
    methods deployed to thwart system fingerprinting. Various firewall vendors have
    attempted to incorporate antifingerprinting measures that alter some packet characteristics
    by tweaking various TCP/IP parameters (such as Internet Protocol IDs, TCP sequence
    numbers, and so on). Needless to say, such a solution actually helps the attacker
    and produces an outcome precisely opposite to what they hoped for: unless all
    characteristics susceptible to fingerprinting are changed and homogenized (including
    sequence numbers, retransmission timings, time-stamp values, and so on), it is
    not only possible to detect the underlying operating system, but also the firewall
    being used to protect the network.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 也许值得思考并进一步探索的领域是各种用来阻止系统指纹识别的方法。各种防火墙供应商都试图通过调整各种TCP/IP参数（如互联网协议ID、TCP序列号等）来整合抗指纹识别措施，以改变一些数据包的特征。不用说，这种解决方案实际上帮助了攻击者，并产生了与预期完全相反的结果：除非所有易受指纹识别的特征都改变并统一（包括序列号、重传时间、时间戳值等），否则不仅可能检测到底层操作系统，还可以检测到用于保护网络的防火墙。
- en: C’est la vie.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: C’est la vie.
- en: '* * *'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[27](#CHP-11-FN-3)]) A cooperation that, at some point, resulted in the creation
    of a loosely knit group of Polish researchers who worked through 1999 and 2000
    to correlate, track, and seek to explain many bizarre types of unexpected traffic
    patterns across the network.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-11-FN-3)]) 在某个时候，这种合作导致了一个松散的波兰研究小组的创建，该小组在1999年和2000年期间通过网络关联、跟踪和试图解释许多奇怪的意外流量模式。
- en: Chapter 12. Stack Data Leaks
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。堆栈数据泄露
- en: '*Yet another short story on where to find what we did not intend to send out
    at all*'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '*又一个关于如何找到我们根本不想发送出去的东西的短篇故事*'
- en: —
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: Sometimes, all it takes to find subtle but fascinating and helpful hints about
    your co-Netizens and their whereabouts is some luck. At least that was the case
    with a fairly interesting and extremely elusive information disclosure vector
    that I discovered in 2003, after several weeks of a daunting hunt.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，找到关于你的网络同胞和他们所在之处的微妙但引人入胜且有用的提示，只需要一点运气。至少，这对我来说是如此，我在2003年发现了一个相当有趣且极其难以捉摸的信息披露向量，那是在几周令人沮丧的搜索之后。
- en: Kristjan’s Server
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克里斯蒂安的服务器
- en: First things first. Several years ago, I asked a friend of mine, Kristjan, to
    let me use some disk space on one of his machines so that I could host a bunch
    of my projects on a reliable and fast system. He agreed, and soon after, I began
    to gradually move most of my programs and papers to their new home. Among the
    projects I transferred was a new version of p0f, my passive operating system fingerprinting
    tool (which you may remember from [Chapter 9](ch09.html "Chapter 9. Foreign Accent")).
    This humble tool implemented some interesting passive analysis techniques, but
    to be truly powerful, it needed to ship with a strong and current database of
    operating system signatures. Maintaining it manually was difficult, and I soon
    ran out of obscure systems to fingerprint and add to it.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 首先。几年前，我请求我的一个朋友，克里斯蒂安，让我在他的机器上使用一些磁盘空间，这样我就可以在一个可靠且快速的系统上托管我的几个项目。他同意了，不久之后，我开始逐渐将我的大部分程序和论文转移到它们的新家。在我转移的项目中，有一个是我被动操作系统指纹识别工具p0f的新版本（你可能还记得第9章中的[“Chapter
    9. 外国口音”](ch09.html "Chapter 9. 外国口音")）。这个不起眼的小工具实现了一些有趣的被动分析技术，但要真正强大，它需要附带一个强大且最新的操作系统签名数据库。手动维护它很困难，我很快就没有了可以指纹识别并添加到其中的神秘系统。
- en: Fortunately, whereas gathering signatures for active fingerprinting software
    required often objectionable interaction with the target (stirring controversy
    and straining the network link and sometimes crashing particularly poorly implemented
    TCP/IP stacks), passive fingerprinting required no such action and could be performed
    effortlessly on all systems that connected to Kristjan’s system to fetch my page.
    To encourage submissions, I set up a subpage where any user could immediately
    see their fingerprint and correct the way their system was being reported or add
    a new signature. This page proved to be a great way to collect signatures and
    improve the software, but this is not where the story ends.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虽然收集用于主动指纹识别软件的签名通常需要与目标进行令人反感的交互（引起争议、拉扯网络链路，有时还会导致特别糟糕实现的TCP/IP堆栈崩溃），而被动指纹识别则无需此类行动，并且可以在连接到Kristjan系统以获取我页面的所有系统上轻松执行。为了鼓励提交，我设置了一个子页面，任何用户都可以立即看到他们的指纹，并纠正系统报告的方式或添加新的签名。这个页面证明是收集签名和改进软件的绝佳方式，但这并不是故事的结局。
- en: 'In a bizarre turn of events, Kristjan decided to host a different, for-profit
    site on his system so that his system could pay its own bills. The site, as you
    might imagine, was not at all devoted to network security, gardening, or some
    other noble cause. Rather, it focused on some less prestigious, yet perhaps more
    appealing aspects of our lives: sex, nudity, and everything related. I rejoiced,
    as any self-respecting geek would, not because of the contents he served, but
    because millions of connection signatures started pouring down in a matter of
    hours, to be analyzed by the software I was developing. Hallelujah!'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个奇怪的事件转折中，Kristjan决定在他的系统上托管一个不同的、盈利性的网站，以便他的系统能够支付自己的账单。正如你可能想象的那样，该网站根本不是致力于网络安全、园艺或其他高尚事业。相反，它关注我们生活中一些不那么显赫，但可能更具吸引力的方面：性、裸露和与之相关的一切。我欣喜若狂，就像任何自重的极客一样，不是因为他所提供的内容，而是因为数百万个连接签名在几小时内开始涌入，由我正在开发的软件进行分析。阿门！
- en: Surprising Findings
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惊人的发现
- en: 'Better safe than sorry: While designing the new code for p0f, I decided to
    implement a number of sanity checks to detect even the most bizarre, unlikely,
    or unheard of patterns in incoming traffic, covering all possible illegal or meaningless
    combinations of TCP/IP settings. Although common sense suggested I should never
    encounter packets that have their parameters mangled in bizarre ways (at least
    not when communicating with popular and thus well-tested systems), there seemed
    to be no harm in implementing this functionality. Too, if a system indeed turned
    out to be sending packets that exhibited a particular type of anomaly, the ability
    to detect it would provide an excellent way to tell this particular OS from similar-looking
    implementations that do not share this flaw.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 宁可安全也不后悔：在设计p0f的新代码时，我决定实施一系列健全性检查，以检测传入流量中甚至最奇特、最不可能或闻所未闻的模式，涵盖所有可能的非法或无意义的TCP/IP设置组合。尽管常识建议我永远不应该遇到参数以奇特方式损坏的包（至少在与流行且因此经过良好测试的系统通信时不会），但实施此功能似乎并无害处。此外，如果一个系统确实被发现正在发送表现出特定类型异常的包，检测它的能力将提供一种很好的方法来区分这个特定的操作系统和外观相似但不存在这种缺陷的实现。
- en: During the merry months of this blessed signature storm, I saw the strangest
    things. I eventually managed to explain some of these and document them for p0f,
    and some remained a mystery. Most of the anomaly checks I implemented previously
    hit the spot, and I immediately located systems that indeed were sharing more
    unusual TCP/IP implementation quirks. But one thing was particularly disturbing
    and hard to believe, so I decided to pay more attention to it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个神圣的签名风暴的欢乐月份里，我看到了最奇怪的事情。我最终设法解释了一些这些事情，并为p0f记录下来，而有些则仍然是个谜。我之前实施的多数异常检查都准确无误，我立即找到了确实共享更多不寻常TCP/IP实现怪癖的系统。但有一件事特别令人不安，难以置信，所以我决定更加关注它。
- en: Two of the tests—one a check for the ACK value set in TCP/IP headers when the
    ACK flag is not set (indeed a futile action), and the other a test for the URG
    value set when the URG flag is not set—seemed relatively meaningless atfirst,
    never yielding interesting results, until I noticed something quite unusual. I
    found that some Windows 2000 and XP systems that connected to Kristjan’s server
    had, from time to time, nonzero URG or ACK values in packets that had neither
    flag set (most notably, SYN packets that open a new connection).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试——一个是在TCP/IP头部ACK标志未设置时检查ACK值（实际上是一个徒劳的行为），另一个是在URG标志未设置时检查URG值——一开始似乎相对没有意义，从未产生有趣的结果，直到我注意到一些非常不寻常的事情。我发现一些连接到Kristjan服务器的Windows
    2000和XP系统，有时在既未设置ACK标志也未设置URG标志的数据包中，URG或ACK值不为零（最值得注意的是，SYN数据包用于打开新的连接）。
- en: 'Having URG or ACK values set when a respective flag is not set is not strictly
    a problem. According to RFC793, when this is the case, the values simply lose
    all significance; for example:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当未设置相应的标志时设置URG或ACK值并不严格是一个问题。根据RFC793，在这种情况下，这些值将完全失去意义；例如：
- en: 'Urgent Pointer: 16 bits'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 紧急指针：16位
- en: This field communicates the current value of the urgent pointer as a positive
    offset from the sequence number in this segment. The urgent pointer points to
    the sequence number of the octet following the urgent data. This field is only
    be interpreted in segments with the URG control bit set.
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此字段表示当前紧急指针的值，作为从该段序列号的正偏移量。紧急指针指向紧急数据后的八位序列号。此字段仅在设置了URG控制位的段中解释。
- en: RFC793, in its very special way, tells us that this anomaly is not likely to
    cause any networking problems, and as such it might have gone unnoticed forever.
    But I took notice, simply because it was kind of odd.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: RFC793以一种非常特殊的方式告诉我们，这种异常不太可能导致任何网络问题，因此它可能永远没有被注意到。但我就注意到了，因为它有点奇怪。
- en: I initially thought that a specific piece of network equipment was to blame,
    as was the case with most of the problems described in [Chapter 11](ch11.html
    "Chapter 11. In Recognition of Anomalies"), but this was not so. The hits were
    coming from single systems, not entire networks, and they were not persistent;
    they just showed up in a couple of packets (with values either still or changing
    randomly) and then disappeared, never to show up again on subsequent connections.
    Also, the problem seemed to be exclusive to Windows; there were no minority operating
    systems represented at all in the group of systems exhibiting this issue.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初认为某个特定的网络设备是问题的原因，就像在[第11章](ch11.html "第11章。识别异常")中描述的大多数问题一样，但事实并非如此。这些击中来自单个系统，而不是整个网络，并且它们不是持续的；它们只是在几个数据包（值保持不变或随机变化）中显示，然后消失，在随后的连接中再也没有出现。此外，这个问题似乎仅限于Windows；在表现出这种问题的系统组中，根本没有任何少数操作系统。
- en: I found myself spending week after week trying to trace the problem. As part
    of my hunt, I deployed some other installations in more controlled environments;
    and, to my amazement, the problem showed up, even in local networks and even from
    the most up-to-date systems, though only for short periods of time. Users could
    not recall doing anything unusual when this type of traffic occurred from their
    systems, and I could not track down any particular type of communications or set
    of actions that would trigger it; there seemed to be no pattern.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现自己花了一周又一周的时间试图追踪这个问题。作为我的搜索的一部分，我在更受控的环境中部署了一些其他安装；令我惊讶的是，即使在本地网络中，即使在最新的系统中，这个问题也出现了，尽管只是短暂的时间。用户无法回忆起当这种类型的流量从他们的系统中发生时，他们做了任何不寻常的事情，我也无法追踪到任何特定的通信或一系列动作来触发它；似乎没有模式。
- en: Puzzling.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑。
- en: 'Revelation: Phenomenon Reproduced'
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示：现象重现
- en: I was close to giving up. I posted my observations to several public mailing
    lists (most notably VULN-DEV, a popular vulnerability discussion list hosted by
    Security Focus), seeking further analysis and feedback from other researchers,
    but this failed to yield any results. And then, only by sheer luck, I caught one
    of my own test stations generating this exact behavioral pattern while working
    on a wholly different problem. I happened to have a sniffer running in the background
    (don’t we all).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎要放弃了。我将我的观察结果发布到几个公共邮件列表（最著名的是由Security Focus主办的流行漏洞讨论列表VULN-DEV），寻求其他研究人员进一步分析和反馈，但并未得到任何结果。然后，仅凭运气，我在处理一个完全不同的问题时，捕捉到我的一个测试站正在生成这种确切的行为模式。我恰好有一个嗅探器在后台运行（我们难道不是都有吗）。
- en: 'Soon, I had a diagnosis: the problem occurred when the workstation was performing
    a background file transfer or other network-extensive operations when attempting
    to establish a connection. In almost every OS, the packet to be sent out on a
    wire was first constructed in the system’s main memory, using either a *static
    buffer* (a fixed location in memory used exclusively for this purpose) or a *dynamic
    buffer* (one allocated as needed using memory that could have been used previously
    for some other purpose). In this particular scenario, when two connections occur
    at roughly the same time, the buffer used to construct outgoing packets before
    sending them to the network card appeared to not be initialized properly prior
    to use; that is, it was not cleared of any leftover contents because the buffer
    was last used for a different purpose. The implementation code assumes that all
    contents of the buffer are zero and does not bother to touch those it does not
    need to initialize to any particular value (as is the case with ACK and URG values
    when respective flags are not set). As a result, some of the leftover contents
    are sent out on the wire.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我就有了诊断结果：当工作站在进行后台文件传输或其他网络密集型操作时尝试建立连接时，问题发生了。在几乎所有的操作系统中，要发送到线上的数据包首先在系统主内存中构建，使用的是*静态缓冲区*（内存中用于此目的的固定位置）或*动态缓冲区*（根据需要分配，可能之前用于其他目的的内存）。在这个特定场景中，当两个连接几乎同时发生时，用于在发送到网卡之前构建出站数据包的缓冲区似乎在使用前没有正确初始化；也就是说，它没有被清除任何剩余内容，因为缓冲区最后用于了不同的目的。实现代码假设缓冲区的内容都是零，并且不费心去接触那些它不需要初始化到特定值的（正如在相应的标志未设置时ACK和URG值的情况一样）。结果，一些剩余内容被发送到线上。
- en: Naturally, all other IP and TCP fields were properly initialized, as they ought
    to be; only URG and ACK were left out, as they had no relevance in this particular
    context. But this omission meant that a small portion of data that belonged to
    a different connection (or a different aspect of computer operations) was being
    sent out to another party. The problem manifested itself only during multiple
    sessions (common during web browsing, background downloads, and similar scenarios),
    but not when the system was idle.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，所有其他IP和TCP字段都已被正确初始化，正如它们应该的那样；只有URG和ACK被省略了，因为在这个特定上下文中它们没有相关性。但这个遗漏意味着一小部分属于不同连接（或计算机操作的另一个方面）的数据被发送给了另一方。这个问题仅在多个会话期间（在网页浏览、后台下载和类似场景中很常见）表现出来，而在系统空闲时则不会。
- en: 'The relevance of the information disclosed in this situation is twofold:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下披露的信息的相关性有两方面：
- en: It can be viewed as a traditional information disclosure scenario. Although
    the amount of information disclosed in every packet that does not have URG and
    ACK values initialized properly is fairly small and is not guaranteed to be meaningful
    (unless the buffer held something interesting to begin with), it may be of value
    in certain scenarios, particularly when a simultaneous session that can contain
    sensitive information, and effectively the bug itself, can be induced by an external
    entity.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以被视为一个传统的信息披露场景。尽管在每包没有正确初始化URG和ACK值的包中披露的信息量可能相当小，并且不一定具有意义（除非缓冲区一开始就包含了一些有趣的内容），但在某些情况下可能是有价值的，尤其是在一个可以包含敏感信息，甚至可以触发漏洞的外部实体同时进行的会话中。
- en: The vulnerability can be considered a convenient fingerprinting metric that
    reveals additional information about the operating system and the state it is
    in—a simple way to differentiate systems that extensively use the network from
    idle ones.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个漏洞可以被认为是一个方便的指纹识别指标，它揭示了关于操作系统及其状态的额外信息——一种简单的方法来区分大量使用网络的系统和空闲系统。
- en: That’s it. And although the significance of this discovery is perhaps easy to
    overestimate, I decided to include it here for its amusement value and to illustrate
    how easy it is to obtain even sophisticated data from a remote party without even
    asking.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。尽管这个发现的重大意义可能容易被高估，但我决定将其包含在这里，以体现其娱乐价值，并说明即使不询问，从远程方获取复杂数据是多么容易。
- en: Food for Thought
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考的食物
- en: It is easy to lay blame for this on the developers. Although the developers
    are naturally at fault for not initializing memory properly, the entire notion
    of having a separate “enabler” for a field in the header is perhaps a design flaw
    in TCP itself and might contribute to this kind of problem. Similar subtleties
    plague protocol specifications, as demonstrated in [Chapter 7](ch07.html "Chapter 7. Secure
    in Switched Networks"), in which a similar type of a vulnerability was caused
    by following a specification too closely, without giving much thought to its potential
    side effects.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将责任归咎于开发者。尽管开发者没有正确初始化内存是自然错误的，但将TCP中字段的“启用器”分开的概念可能本身就是TCP本身的设计缺陷，并可能导致这类问题。类似的微妙之处困扰着协议规范，正如在第7章（[第7章。交换网络中的安全](ch07.html
    "Chapter 7. Secure in Switched Networks")）中所示，其中类似类型的漏洞是由于过于紧密地遵循规范而造成的，没有充分考虑其潜在的副作用。
- en: Chapter 13. Smoke and Mirrors
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。烟雾与幻影
- en: '*Or how to disappear with grace*'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者如何优雅地消失*'
- en: —
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: Many of the information disclosure scenarios discussed so far require careful
    analysis of the information sent by a remote system in order to deduce certain
    facts about the sender or to intercept additional data they are not aware of sending
    in the first place. In several cases, however, only circumstantial evidence of
    the presence of some form of activity can be gathered. As discussed in [Chapter 1](ch01.html
    "Chapter 1. I Can Hear You Typing") and [Chapter 2](ch02.html "Chapter 2. Extra
    Efforts Never Go Unnoticed"), by precisely interpreting this evidence, you can
    determine the probable whereabouts of the user or an application that processes
    sensitive data, thus indirectly uncovering secrets of the victim’s machine without
    having to access the data itself.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的许多信息泄露场景都需要仔细分析远程系统发送的信息，以便推断发送者的某些事实或拦截他们最初未意识到的额外数据。然而，在几种情况下，只能收集到某些形式活动的环境证据。正如在第1章（[第1章。我能听到你在打字](ch01.html
    "Chapter 1. I Can Hear You Typing")）和第2章（[第2章。额外的努力永远不会被忽视](ch02.html "Chapter 2. Extra
    Efforts Never Go Unnoticed")）中讨论的那样，通过精确解释这些证据，你可以确定用户或处理敏感数据的应用程序的可能位置，从而间接揭露受害者的机器的秘密，而无需访问数据本身。
- en: Some features of the IP make many of its implementations susceptible to circumstantial
    evidence information disclosure vulnerabilities, quite similar to what we witnessed
    earlier with certain types of system pseudo-random number generators or variable
    complexity data-processing algorithms. Carefully observing and then deciphering
    this information can be advantageous, providing us at the very least with much-needed
    intelligence regarding our adversary’s general habits or a particular activity
    in which they are engaged.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: IP的一些特性使得许多其实施方案容易受到环境证据信息泄露漏洞的影响，这与我们之前在某种类型的系统伪随机数生成器或可变复杂度数据处理算法中看到的情况非常相似。仔细观察并解读这些信息可能是有益的，至少可以为我们提供关于对手一般习惯或他们参与的特定活动的急需情报。
- en: Until now, this part of the book has focused on IP-layer attacks that require
    direct observation of the traffic coming from a sender, though typically without
    interacting with the victim. In this chapter, however, we take a peek at a spectacularly
    active but indirect IP-based attack in which an attacker profiles their victim
    by making an educated guess about what they cannot see. They do so by interacting
    with an innocent bystander who is not the real subject of the test and without
    this party’s consent or knowledge, learning what they can about the actual victim.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，本书的这一部分主要关注需要直接观察来自发送者的流量，尽管通常不需要与受害者交互的IP层攻击。然而，在本章中，我们将窥视一种非常活跃但间接的基于IP的攻击，攻击者通过对其无法看到的内容做出明智的猜测来对其受害者进行画像。他们通过与一个无辜的旁观者互动来实现这一点，这个旁观者不是测试的真正对象，并且没有得到这一方的同意或知情，从而了解他们关于实际受害者的信息。
- en: Such an approach does not sound like the easy way to gather data. So, in the
    spirit of a geekdom, why not take the scenic, albeit a bit longer, route and look
    at it in more detail?
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法听起来并不是收集数据的简单方法。所以，本着极客精神，为什么不选择风景优美的路线，尽管可能需要更长的时间，并且更详细地研究它呢？
- en: 'Abusing IP: Advanced Port Scanning'
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滥用IP：高级端口扫描
- en: Rogue Internet users frequently use port scanning for pre-attack reconnais-sance
    and system fingerprinting. When port scanning, a would-be attacker attempts a
    short connection to every port on a system and maps out all programs that listen
    for network traffic. In this way, they can determine where to attack by finding
    any vulnerable or otherwise potentially interesting network service on the system.
    Too, in many cases, they can determine which operating system their victim is
    using, because default services are often operating-system specific.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意网络用户经常使用端口扫描进行攻击前的侦察和系统指纹识别。在端口扫描时，潜在的攻击者尝试与系统上的每个端口建立短暂的连接，并绘制出所有监听网络流量的程序。通过这种方式，他们可以确定攻击目标，通过找到系统上任何有漏洞或可能有趣的网络服务。此外，在许多情况下，他们还可以确定受害者正在使用哪种操作系统，因为默认服务通常是针对特定操作系统的。
- en: The first problem with traditional scanning is that it is quite noisy—the victim
    is likely to notice a storm or even a steady flow of connection attempts to unusual
    ports. Hiding is not easy, either; the attacker must be able to see the responses
    to their SYN packets to determine whether a port is open or closed. Open ports
    respond with SYN+ACK, closed ones with RST, and ports filtered by a firewall are
    likely to generate no response or an Internet Control Message Protocol (ICMP)
    message. Consequently, the attacker cannot simply spoof a source address on all
    outgoing packets; they must reveal their identity by providing source addresses
    that route back to the network they are listening on for incoming traffic.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 传统扫描的第一个问题是它相当嘈杂——受害者很可能会注意到对不寻常端口的连接尝试风暴或甚至持续的流动。隐藏也不容易；攻击者必须能够看到他们对SYN数据包的响应，以确定端口是打开的还是关闭的。打开的端口会响应SYN+ACK，关闭的端口会响应RST，而通过防火墙过滤的端口可能会产生没有响应或互联网控制消息协议（ICMP）消息。因此，攻击者不能简单地伪造所有传出数据包的源地址；他们必须通过提供可以路由回他们正在监听以接收传入流量的网络的源地址来揭示他们的身份。
- en: 'Tree in the Forest: Hiding Yourself'
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 森林中的树：隐藏自己
- en: Whether the party scans out of curiosity (for example, to see what operating
    system a competitor is running) or follows with an attack attempt, they usually
    want to leave as few traces as possible and avoid alerting the victim. Network
    administrators and certain authorities generally perceive host and network scans
    quite negatively. Although debate is ongoing about whether these scans should
    be considered malicious, the person doing the probing almost always loses when
    an annoyed systems administrator decides to file an abuse report or if your competitor
    identifies one of your employees as trying to probe their networks, regardless
    of the true intent and further plans of the curious tester.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是出于好奇（例如，查看竞争对手正在运行什么操作系统）还是跟随攻击尝试，他们通常都希望留下尽可能少的痕迹并避免引起受害者的警觉。网络管理员和某些当局通常对主机和网络扫描持相当负面的看法。尽管关于这些扫描是否应被视为恶意行为仍在进行辩论，但在愤怒的系统管理员决定提交滥用报告或如果你的竞争对手确定你的员工试图探测他们的网络时，好奇的测试者几乎总是输掉比赛，无论其真实意图和进一步的计划如何。
- en: One common way to camouflage port scans is to deploy a “decoy” scan, whereby
    the attacker sends SYN packets from a number of fake addresses, as well as from
    their actual IP, to each port. The victim handles these bogus packets just like
    real ones, except that the responses to bogus ones, of course, are sent out into
    the void. As a result, the victim has a much more difficult time determining who
    really is behind the scan, because to do so they have to eliminate all the decoy
    systems from the list of packet sources through either careful analysis or simple
    trial and error. Still, with some determination it is possible to locate the sender
    without help from the authorities, though the attacker hopes to discourage the
    victim by making it too time-consuming to fully resolve such a minor incident.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆端口扫描的一种常见方法是部署“诱饵”扫描，其中攻击者从多个虚假地址以及他们的实际IP地址向每个端口发送SYN数据包。受害者将这些伪造的数据包处理得就像真实数据包一样，只不过伪造数据包的响应当然会被发送到空旷无人的地方。因此，受害者很难确定真正是谁在背后进行扫描，因为他们必须通过仔细分析或简单的试错来消除所有诱饵系统从数据包源列表中。尽管如此，只要有决心，还是可以在不求助当局的情况下定位发送者，尽管攻击者希望通过使完全解决这样一个小事件变得过于耗时来阻止受害者。
- en: Idle Scanning
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲扫描
- en: The ultimate defense against being discovered came—as it often does—from a guy
    who had too much time on his hands and wasted it reading through protocol specifications
    instead of doing something productive. And so a technique called “idle” scanning
    was born. Initially devised by Salvatore “antirez” Sanfilippo in 1998, it was
    soon widely implemented and became quite popular among hackers (both the simply
    curious and the malicious).^([[96](apb.html#ftn.CHP-13-BIB-1)])
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 防止被发现的最终极手段，就像它经常做的那样，来自于一个手头时间太多并且浪费时间去阅读协议规范而不是做些有用事情的人。因此，一种叫做“空闲”扫描的技术应运而生。最初由Salvatore“antirez”Sanfilippo在1998年设计，它很快就被广泛实施，并在黑客中（无论是好奇的还是恶意的）变得相当流行。（^[[96](apb.html#ftn.CHP-13-BIB-1)]）
- en: 'Idle scanning is based on an important observation. To quote RFC793:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲扫描基于一个重要的观察。引用RFC793：
- en: As a general rule, reset (RST) must be sent whenever a segment arrives which
    apparently is not intended for the current connection. A reset must not be sent
    if it is not clear that this is the case.
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一般规则，当到达一个明显不是当前连接意图的数据段时，必须发送重置（RST）。如果情况不明确，则不应发送重置。
- en: Transmission Control Protocol RST packets are used to unconditionally terminate
    a connection and to tell the sender to cease any further attempts to communicate.
    The system, without much hesitation, sends an RST when encountering unexpected
    traffic, according to the rule in RFC793\. (Naturally, RST packets themselves,
    even when unexpected, are not replied to; if they were, an endless stream of RSTs
    would bounce back and forth upon the slightest network hiccup.)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议RST数据包用于无条件终止连接，并告诉发送方停止任何进一步的通信尝试。系统在几乎没有犹豫的情况下，根据RFC793中的规则，在遇到意外流量时发送RST。（当然，RST数据包本身，即使是不预期的，也不会被回复；如果回复了，那么在轻微的网络中断时，RST数据包会来回弹跳。）
- en: Idle scanning uses and cleverly abuses the fact that a bystander, a *witness
    host*, will handle all unexpected packets in this way. The attack enables rogue
    Netizens to scan a victim with whom they do not intend to directly communicate.
    When idle scanning, the attacker uses an unsuspecting and randomly chosen system
    on the Internet to scan a third system (the real victim), without ever revealing
    their own identity.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲扫描利用并巧妙地滥用了一个旁观者，即见证主机，会以这种方式处理所有意外数据包的事实。这种攻击使得恶意网民能够扫描他们不打算直接与之通信的受害者。当进行空闲扫描时，攻击者使用一个不知情且随机选择的互联网系统来扫描第三系统（真正的受害者），而永远不会透露他们的真实身份。
- en: 'Idle scanning works like this: The attacker spoofs a SYN packet to a given
    port they want to check on the victim’s system. This packet is addressed to the
    victim host, but with a spoofed return address of the witness system instead of
    the attacker’s system. This alone does not sound like a good way to get anything
    done, but wait just a moment.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲扫描是这样工作的：攻击者伪造一个SYN数据包到他们想要在受害系统上检查的特定端口。这个数据包是针对受害主机的，但使用的是见证系统的伪造回传地址而不是攻击者的系统。单凭这一点听起来并不是一个很好的完成任务的方法，但请稍等片刻。
- en: 'What happens next depends on whether the port is open:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么取决于端口是否开放：
- en: If the probed port on the victim system replies with RST to the witness host,
    the witness host receives it and simply ponders the RST in silence, without generating
    any traffic back to the victim.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果受害系统的被探测端口向见证主机回复了RST，见证主机会收到它，并且只是默默地思考这个RST，而不向受害系统发送任何回传流量。
- en: If the probed port is open, the victim replies with SYN+ACK. The witness, with
    utmost disbelief, concludes that it had never sent a SYN packet to begin with,
    so it sends RST to instruct the victim that they are grossly mistaken and that
    they had better stop now. The victim sheepishly accepts the response and drops
    all records for the connection it hoped to accept.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被探测的端口是开放的，受害系统会回复SYN+ACK。见证者，带着极大的怀疑，得出结论，他们一开始根本就没有发送SYN数据包，因此发送RST来指示受害方他们犯了一个严重的错误，并且最好立即停止。受害者尴尬地接受了这个响应，并丢弃了它希望接受的连接的所有记录。
- en: 'The relevance of this distinction is difficult to appreciate at first. But
    return to [Chapter 9](ch09.html "Chapter 9. Foreign Accent"), and recall the following
    information about one of the fields in an IP header:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别的相关性一开始很难理解。但回到[第9章](ch09.html "第9章。外国口音")，并回忆一下IP头中的一个字段的相关信息：
- en: The identification number (ID) is a 16-bit value that differentiates IP packets
    when fragmentation occurs. Without IP IDs, if two packets are fragmented at once,
    reassembly would severely mangle, interchange, or otherwise damage fragments of
    two packets that were fragmented simultaneously. IP IDs uniquely identify several
    reassembly buffers for different packets. The value used for this purpose is often
    chosen simply by incrementing a counter with every packet sent; the first packet
    sent by a system has an IP ID of 0, the second an Internet Protocol of ID 1, and
    so on.
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标识号（ID）是一个16位值，当发生分片时用于区分IP数据包。如果没有IP ID，如果两个数据包同时分片，重新组装将会严重扭曲、交换或以其他方式损坏同时分片的数据包的片段。IP
    ID唯一标识不同数据包的几个重新组装缓冲区。用于此目的的值通常是通过每次发送数据包时递增计数器来选择的；系统发送的第一个数据包的IP ID为0，第二个为1，依此类推。
- en: Because the attacker has chosen a witness host that indeed uses this IP ID selection
    scheme (and there are many candidates to choose from), they can now easily determine
    whether the witness host has sent an IP packet within a given time frame. They
    do so simply by sending some meaningless traffic to the witness system before
    and after the actual probe and comparing IP ID values in the responses it sends.
    If two observed IP IDs differ only by 1, no packets were sent out by the witness
    system in between. However, if the difference is more than 1, some packets were
    indeed exchanged, though we cannot be sure with whom.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 因为攻击者选择了一个确实使用这种IP ID选择方案的见证主机（可供选择的人选有很多），他们现在可以轻松地确定见证主机是否在给定时间段内发送了IP数据包。他们通过在真实探测前后向见证系统发送一些无意义的流量，并比较它发送的响应中的IP
    ID值来实现这一点。如果观察到的两个IP ID只相差1，则见证系统在这之间没有发送任何数据包。然而，如果差异超过1，确实交换了一些数据包，尽管我们无法确定是与谁交换的。
- en: The attacker can also issue a probe just before sending a spoofed packet to
    the victim and shortly thereafter. Thus, they can determine whether a port is
    open or closed based on the witness host’s replies. If the witness had an increased
    IP ID, it most likely replied with an RST to the victim, which means that the
    victim must have sent SYN+ACK in the first place in response to the spoofed packet.
    The attacker can then conclude that the port is open. If, on the other hand, the
    witness produces the next IP ID as expected, it did not receive any traffic from
    the victim, or it decided to ignore the received RST packet.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者也可以在向受害者发送伪造数据包之前和之后立即发起探测。因此，他们可以根据见证主机的回复确定端口是开启还是关闭。如果见证主机的IP ID增加了，它很可能向受害者回复了一个RST，这意味着受害者最初必须向伪造的数据包发送了SYN+ACK。然后攻击者可以得出结论，该端口是开放的。另一方面，如果见证主机产生下一个预期的IP
    ID，则它没有从受害者那里收到任何流量，或者它决定忽略接收到的RST数据包。
- en: There are, of course, some practical considerations. Most important, the witness
    host should be relatively idle during the idle scan, and the test should be repeated
    several times to eliminate false positives; otherwise, we can incorrectly interpret
    some third-party communications on the witness’s side as telling us that a specific
    port on the victim’s machine is open.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一些实际考虑因素。最重要的是，见证主机在空闲扫描期间应该相对空闲，并且测试应该重复进行几次以消除假阳性；否则，我们可能会错误地将见证方的一些第三方通信解释为告诉我们受害者的某个端口是开放的。
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Neither issue has proven to be much of a deal, however, and many advanced tools
    (beginning with idlescan in 1999, and now the ingenious NMAP) implement idle scanning
    and do it well.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个问题都没有证明是多大的问题，许多高级工具（从1999年的idlescan开始，现在还有巧妙的NMAP）实现了空闲扫描，并且做得很好。
- en: The importance of idle scanning is that it can obfuscate the origin of a scan
    not by merely trying to discourage the victim, but by actually inhibiting any
    identifiable communications from the attacker. This makes it more difficult to
    track the attacker without the help of the owner of a witness host (which itself
    can be queried by the attacker for IP IDs as a part of legitimate traffic such
    as an HTTP session and hence can have a hard time figuring out whether it was
    used as a tool for an attack at all) or from external entities (law enforcement
    and ISPs). Because law enforcement response is usually initiated only once the
    system is compromised, not merely probed (curious competitors can sleep soundly)
    and requires the victim to admit to being compromised (which is not always convenient
    for certain large corporations), the attacker feels rather safe.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲扫描的重要性在于，它可以通过实际抑制来自攻击者的任何可识别通信，而不是仅仅试图阻止受害者，来模糊扫描的来源。这使得在没有目击主机所有者（它本身可以作为合法流量的一部分，如HTTP会话，被攻击者查询IP
    ID，因此很难确定它是否被用作攻击工具）或外部实体（执法机构和ISP）的帮助下追踪攻击者变得更加困难。由于执法响应通常是在系统被入侵后而不是仅仅被探测（好奇的竞争对手可以安心睡觉）时启动的，并且需要受害者承认系统被入侵（这对某些大型公司来说并不总是方便的），因此攻击者感到相当安全。
- en: Note
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Despite at first appearing no different from a regular SYN scan in the results
    it can offer, idle scanning offers a fairly unique scanning perspective. The use
    of witness scans makes it possible to see the destination system from the viewpoint
    of a witness. If the witness has higher access privileges to the victim’s system
    (if, for example, it is a system within a protected network behind a firewall,
    or a system for which certain lax IP filtering rules are set for easier access
    to a corporate network, and so on), you can use idle scanning to discover the
    inner workings of a protected network.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最初看起来与常规的SYN扫描在提供的结果上没有不同，但空闲扫描提供了一个相当独特的扫描视角。使用目击者扫描使得从目击者的视角观察目标系统成为可能。如果目击者对受害者系统有更高的访问权限（例如，它是一个位于防火墙后面的受保护网络内的系统，或者是一个为了便于访问企业网络而设置了某些宽松的IP过滤规则的系统等），你可以使用空闲扫描来发现受保护网络的内部运作。
- en: Defense against Idle Scanning
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御空闲扫描
- en: There is at present no immediate defense against an idle scan, and no easy way
    to tell it from a regular SYN scan. However, it is quite easy to defend against
    being a witness host by using random or constant IP IDs, as discussed in [Chapter 9](ch09.html
    "Chapter 9. Foreign Accent"). Although doing so won’t make attacks against you—or
    attacks in general—any more difficult (plenty of systems will always use sequential
    identifiers), it will prevent your network from being abused for this purpose.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有针对空闲扫描的直接防御措施，也没有简单的方法来区分它和常规的SYN扫描。然而，通过使用随机或固定的IP ID，可以很容易地防御成为目击主机，正如在[第9章](ch09.html
    "第9章. 外国口音")中讨论的那样。尽管这样做不会使针对你的攻击——或者一般的攻击——变得更加困难（许多系统总是会使用连续的标识符），但它将防止你的网络被滥用。
- en: To avoid the firewall bypassing (“perspective”) attack, use common sense when
    designing access channels for external systems, and use proper ingress filtering
    on gateway systems, dropping all packets that arrive from the Internet with source
    addresses that seem to belong to a protected network. Although, as discussed previously,
    this type of filtering might break path maximum transmission unit (PMTU) discovery
    mechanisms, it usually fixes more problems than it breaks.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免防火墙绕过（“视角”）攻击，在设计外部系统的访问通道时使用常识，并在网关系统上使用适当的入口过滤，丢弃所有来自互联网且源地址似乎属于受保护网络的数据包。尽管，如前所述，这种过滤可能会破坏路径最大传输单元（PMTU）发现机制，但它通常解决的问题比它破坏的问题要多。
- en: Food for Thought
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考食物
- en: Although less feasible, it is still possible to use IP IDs for the general profiling
    of IP activity. In fact, when the victim establishes an interactive session to
    a remote system, IP IDs can even be used to time keystrokes or similar actions,
    thus turning this technique into one of the previously discussed timing attack
    scenarios. Similarly, you can enhance user-racking capabilities by measuring the
    number of packets sent by a specific host between two subsequent visits to a monitored
    network.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不太可行，但仍然可以使用IP ID来对IP活动进行一般性分析。实际上，当受害者与远程系统建立交互会话时，IP ID甚至可以用来计时按键或类似操作，从而将这种技术转变为之前讨论过的定时攻击场景之一。同样，通过测量特定主机在两次访问受监控网络之间的数据包数量，你可以增强用户跟踪能力。
- en: You can also use TCP sequence numbers on certain systems to achieve the same
    functionality as IP ID analysis, depending on the ISN-generator design. I encourage
    you to explore this idea in more detail.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在某些系统上使用TCP序列号来实现与IP ID分析相同的功能，具体取决于ISN生成器的设计。我鼓励你更详细地探索这个想法。
- en: As for tracking down the source of an idle scan (or any other spoofed attack),
    see [Chapter 17](ch17.html "Chapter 17. Topology of the Network").
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 至于追踪空闲扫描（或任何其他欺骗性攻击）的源头，请参阅[第17章](ch17.html "第17章。网络拓扑")。
- en: 'Chapter 14. Client Identification: Papers, Please!'
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。客户端识别：请出示您的证件！
- en: '*Seeing through a thin disguise may come in handy on many occasions*'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '*看穿薄薄的伪装在许多场合可能很有用*'
- en: —
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: The challenge of determining the true identity of software and its legitimacy
    can be rather easily resolved locally on the computer running the software. But
    it’s not so easy to do so over a network.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 确定软件的真实身份及其合法性的挑战，在运行该软件的计算机上可以相当容易地解决。但在网络上这样做就不那么容易了。
- en: Both system administrators and application developers often attempt to identify
    software being used at the other end of a network-based session, with varying
    degrees of success. We attempt to identify software for several reasons. For the
    WWW (World Wide Web), the most common goal is to optimize the content served to
    a client based on the rendering engine being used—whether that content is legitimate
    or malicious. The goal for client identification within numerous other communication
    schemes—instant messengers, mail clients, and so on—is to ensure policy compliance
    and to detect communications originating from possibly dangerous or otherwise
    unacceptable applications. And last but not least, programmers themselves attempt
    to identify software to prevent unapproved (or unlicensed) software from using
    a particular network service (possibly stripping them of some of their income)
    or to detect cases such occurrences and take corrective actions.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员和应用程序开发人员经常试图识别网络会话另一端的软件，成功率各不相同。我们试图识别软件有几个原因。对于万维网（World Wide Web），最常见的目标是根据所使用的渲染引擎优化提供给客户端的内容——无论该内容是合法的还是恶意的。在许多其他通信方案（如即时消息、邮件客户端等）中，识别客户端的目标是确保政策合规性，并检测来自可能危险或不可接受的应用程序的通信。最后但同样重要的是，程序员
    themselves 尝试识别软件以防止未经批准（或未经许可）的软件使用特定的网络服务（可能剥夺他们的一些收入）或检测此类情况并采取纠正措施。
- en: The most trivial and common way to identify the other party relies on examining
    the information voluntarily advertised by the remote system. This information
    can include simply noticing a “welcome” banner provided by a server, taking a
    look at protocol headers sent by a client (such as *X-Mailer* in emails, *User-Agent*
    within WWW sessions, and so forth), and analyzing textual status and error or
    warning messages used by the service in response to certain types of traffic.^([[28](#ftn.CHP-14-FN-1)])
    Unfortunately, the first method is extremely unreliable and easily sabotaged by
    users who have something to hide; the last method is intrusive and quite difficult
    to use against clients without causing problems. (Most client software is designed
    to bail out and complain upon encountering the first error condition; users who,
    as a result of an attempt to identify their software, encounter an error message
    and cannot legitimately access a service, will not be impressed.)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 识别对方的最为简单和常见的方式是检查远程系统自愿提供的信息。这些信息可能包括简单地注意到服务器提供的“欢迎”横幅，查看客户端发送的协议头部（例如电子邮件中的
    *X-Mailer*，WWW会话中的 *User-Agent* 等），以及分析服务在响应某些类型流量时使用的文本状态、错误或警告信息。[^([[28](#ftn.CHP-14-FN-1)])]不幸的是，第一种方法极其不可靠，并且很容易被试图隐藏某些信息的使用者破坏；最后一种方法侵入性很强，而且很难在不引起问题的情况下用于客户端。（大多数客户端软件在遇到第一个错误条件时会退出并抱怨；由于尝试识别他们的软件而遇到错误信息且无法合法访问服务的用户，不会留下深刻印象。）
- en: Camouflage
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪装
- en: 'Examining textual announcements produced by the client is unreliable not simply
    because users *can* camouflage their Internet software (web browsers, mail clients,
    and so forth) in order to mimic the responses of the most popular clients, but
    because they often also have a good incentive to try: either to blend in with
    the crowd or simply to fool servers that tend to know better what version of a
    program the visitor needs to be running. It’s simple to do so, either by using
    a client’s built-in functionality or by modifying a program’s sources or binaries
    with one of a multitude of freely available tools.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 检查客户端产生的文本公告并不可靠，不仅是因为用户*可以*通过伪装他们的互联网软件（网络浏览器、邮件客户端等）来模仿最流行客户端的响应，而且因为他们通常也有很好的动机去尝试：要么与大众融为一体，要么简单地欺骗那些通常更清楚访客需要运行哪个程序版本的服务器。这样做很简单，要么使用客户端内置的功能，要么使用众多免费工具之一修改程序源代码或二进制文件。
- en: Too, because many corporate environments have begun to implement more rigorous
    content filtering in order to block unwanted traffic, some coders who work on
    more questionable applications have, in response, begun to impersonate harmless
    software. Not long ago, peer-to-peer music-sharing applications, malicious Trojan
    horses, and spyware began to pretend to be the most prevalent web browser, Microsoft
    Internet Explorer, in their outgoing communications. The same was true for many
    address-gathering web crawlers used by shoddy marketing businesses around the
    globe.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于许多企业环境已经开始实施更严格的内容过滤以阻止不受欢迎的流量，一些从事更具争议性应用的程序员为了应对这种情况，开始模仿无害的软件。不久前，对等音乐共享应用、恶意木马和间谍软件开始假装成最普遍使用的网络浏览器，微软互联网浏览器，在其出站通信中。对于全球范围内许多由低劣营销业务使用的地址收集型网络爬虫来说，情况也是如此。
- en: Other protocols are also plagued by impersonators. Not surprisingly, a majority
    of much despised bulk-mailing software used by spammers and con artists pretends
    to be programs such as Microsoft Outlook, PINE, Mutt, Eudora, The Bat!, or Netscape
    Mail. The basic premise is to hide behind camouflage to sneak past network administrators
    who, were they to become aware of the software’s presence, would find it easy
    to block them. No sane spammer will announce that their emails are coming from
    “Uncle Bernie’s Notorious Mass-Mailer, Extreme Edition,” simply because it would
    be too easy for a user or spam filter to filter them out.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 其他协议也受到模仿者的困扰。不出所料，大多数被垃圾邮件发送者和骗子所憎恨的大规模邮件发送软件假装成微软 Outlook、PINE、Mutt、Eudora、The
    Bat! 或 Netscape Mail 等程序。基本前提是隐藏在伪装之下，以避开网络管理员，如果他们意识到软件的存在，会发现很容易将其阻止。没有理智的垃圾邮件发送者会宣布他们的电子邮件来自“伯尼叔叔臭名昭著的大规模邮件发送者，终极版”，因为这会很容易被用户或垃圾邮件过滤器过滤掉。
- en: Approaching the Problem
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接近问题
- en: 'Because it is trivial to modify the basic text responses and banners returned
    by a program, we need to find a better way to detect trickery than trivial textual
    response matching in order to identify client software with reasonable accuracy.
    Solutions that simply check less obvious parameters or responses are bound to
    fail at one point or another: although in almost all cases, it is possible to
    devise a single check to identify a specific type of undesirable software, three
    heads will grow back in place of the one just cut off.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 由于修改程序返回的基本文本响应和横幅非常简单，我们需要找到一种比简单的文本响应匹配更好的方法来检测欺诈行为，以便以合理的准确性识别客户端软件。仅仅检查不那么明显的参数或响应的解决方案注定会在某个时候失败：尽管在几乎所有情况下，都可以设计一个单独的检查来识别特定类型的不可取软件，但三头怪物会取代被砍掉的那一个。
- en: 'It soon becomes impractical to try to address every single incarnation of malicious
    software. In some cases, a general malicious client detection can be achieved
    by simply checking for patterns that are clearly indicative of the type of abuse
    we hope to prevent: The difference between a legitimate mail client and a spammer’s
    software is that the former is unlikely to attempt to send out 10,000,000 mails
    in one shot. Yet, this approach is very limited: while for some protocols and
    some clearly defined attacks, this may work like a charm; for WWW traffic, it
    is another story, and it is difficult to hit the right spot without ending up
    with an excessive number of false positives or missed programs.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，尝试解决恶意软件的每一个版本都变得不切实际。在某些情况下，通过简单地检查明显表明我们希望防止的滥用类型的模式，可以实现一般的恶意客户端检测：合法邮件客户端与垃圾邮件发送软件之间的区别在于，前者不太可能一次性发送1,0000,000封邮件。然而，这种方法非常有限：对于某些协议和一些明确定义的攻击，这可能像魔法一样有效；对于WWW流量，这又是另一回事，而且很难击中正确的位置，而不会导致过多的误报或漏检程序。
- en: Because it is perceived as the core of all Internet services available to end
    users, the WWW is one of few protocols that simply must be open for almost all,
    and, thus web traffic is most commonly chosen by naughty applications to masquerade
    their behavior in a system and the data they are transferring to a remote host.
    It is not uncommon for web browsers to trigger bursts of connections to various
    sites or to perform thousands of requests per hour. At the same time, it is not
    impossible to send out sensitive information to a remote host in a single, brief
    connection. Here, traffic profiling falls just short of providing an answer.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它被视为所有面向最终用户的互联网服务的核心，WWW是少数必须对几乎所有用户开放的协议之一，因此，网页流量通常被不良应用程序用来伪装其在系统中的行为以及它们传输到远程主机的数据。网页浏览器触发到各种网站的连接爆发或每小时执行数千次请求并不罕见。同时，在单个简短的连接中发送敏感信息到远程主机也不是不可能的。在这里，流量分析几乎无法提供答案。
- en: Towards a Solution
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向解决方案迈进
- en: Given all this, it would appear that differentiating spyware or a Trojan horse
    from a legitimate application can be extremely tricky. However, as it turns out,
    some good tools are available for precisely identifying this kind of software,
    thus enabling interested parties to more accurately and precisely identify client
    applications. The most promising and universal approach, generally referred to
    as *behavioral analysis* (a fancy term for old and busted “timing patterns”) aims
    to analyze the subtle internal dependencies between subsequent portions of traffic,
    as opposed to looking at the actual data exchange in a single request or in the
    sheer volume of connections over time. Because these dependencies are closely
    associated with internal algorithms and a program’s performance, they are much
    more difficult to spoof than most of the other metrics we could examine. I’ll
    discuss this approach in this chapter and propose a basic analysis toolset to
    achieve this level of accuracy and detail, using World Wide Web traffic as a convenient
    example.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一切，区分间谍软件或特洛伊木马与合法应用程序可能极其困难。然而，实际上，有一些很好的工具可以精确地识别这类软件，从而使得感兴趣的相关方能够更准确、更精确地识别客户端应用程序。最有希望且最通用的方法，通常被称为**行为分析**（一个对旧式“时间模式”的华丽说法），旨在分析后续流量部分之间微妙内部依赖关系，而不是查看单个请求中的实际数据交换或在一段时间内连接的纯粹数量。因为这些依赖关系与内部算法和程序性能紧密相关，所以它们比我们可能检查的大多数其他指标更难以伪造。我将在本章中讨论这种方法，并提出一个基本的分析工具集，以实现这种准确性和详细程度，并以万维网流量作为一个方便的例子。
- en: But before we dive into the details, we need a bit of background. Let’s take
    a quick look at the history of the WWW, the design of web clients, and the protocols
    they use to talk to servers. It all began earlier than you might think. . . .
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入细节之前，我们需要一点背景知识。让我们快速浏览一下万维网（WWW）的历史、网络客户端的设计以及它们与服务器通信所使用的协议。这一切都要早于你的想象……
- en: '* * *'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[28](#CHP-14-FN-1)]) A popular tool that uses fingerprinting to analyze responses
    is AMAP by THC; you can find out more at [http://www.thc.org/releases.php](http://www.thc.org/releases.php).
    Fyodor’s NMAP can identify services by analyzing banners.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-14-FN-1)]) 使用指纹分析响应的流行工具是THC的AMAP；你可以在[http://www.thc.org/releases.php](http://www.thc.org/releases.php)了解更多信息。Fyodor的NMAP可以通过分析横幅来识别服务。
- en: A (Very) Brief History of the Web
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络的简要历史
- en: 'The concept of the World Wide Web is not particularly difficult to grasp: the
    idea behind the Web is to give users instant access to a number of cross-referenced,
    linked documents that combine different types of information. Simple enough.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的概念并不特别难以理解：万维网背后的想法是让用户能够即时访问大量交叉引用、相互链接的文档，这些文档结合了不同类型的信息。这很简单。
- en: The Web as we know it today consists primarily of text with metadata (such as
    references to other files, formatting elements, annotations, dynamic or interactive
    elements), often enhanced with all kinds of multimedia (video, music, and various
    applications). It represents the spirit of our times and signifies a brand new
    method of communicating and finding information. But the idea of the Web is not
    new. It was born many years before technology made it possible to achieve this
    set of features for electronic documents—perhaps long before electronic documents
    were even considered a serious possibility.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所知道的万维网主要由文本和元数据（如对其他文件的引用、格式化元素、注释、动态或交互式元素）组成，通常还增强了各种多媒体（视频、音乐和各种应用程序）。它代表了我们的时代精神，标志着一种全新的沟通和信息查找方法。但万维网的想法并不新。它是在许多年前，在技术使电子文档实现这一系列功能成为可能之前就产生的——也许在电子文档甚至被认为是一个严肃的可能性之前很久。
- en: According to a timeline^([[97](apb.html#ftn.CHP-14-BIB-1)]) published by the
    World Wide Web Consortium (W3C), the concept of hyperlinking was first discussed
    in the *Atlantic Monthly*^([[98](apb.html#ftn.CHP-14-BIB-2)])back in 1945 by Vannevar
    Bush, a director of the Office of Scientific Research and Development during and
    after World War II.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 根据万维网联盟（W3C）发布的时间线^([[97](apb.html#ftn.CHP-14-BIB-1)))，超链接的概念最早是在1945年由范内瓦·布什提出的，当时他是二战期间及战后的科学研究和开发办公室的主任。他在《大西洋月刊》^([[98](apb.html#ftn.CHP-14-BIB-2)))上讨论了这个概念。
- en: Bush proposed a device called Memex, a personal, electromechanical unit that
    could, in fact, be seen as an early predecessor of today’s PDAs. Memex provided
    storage for a user’s documents and personal files and aimed to provide intuitive
    mechanisms for accessing the data. One of Memex’s features was its ability to
    create and follow links between documents stored on microfilm. For some reason,
    the idea of an insanely complex mechanical device running on microfilm did not
    really catch on back then.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 布什提出了一种名为Memex的设备，这是一个个人、机电单元，实际上可以看作是今天PDA的早期前身。Memex为用户的文档和个人文件提供存储，旨在提供直观的数据访问机制。Memex的一个特性是能够创建和跟踪存储在缩微胶片上的文档之间的链接。由于某种原因，一个运行在缩微胶片上的极其复杂的机械设备的想法当时并没有真正流行起来。
- en: The concept of hyperlinking popped up several times in later years, resulting
    in the first computer-based implementations in the 1960s. These attempts were
    not particularly successful though, largely because the computing power needed
    to make the technology appeal to users was still years in the future.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 超链接的概念在后来的几年里多次出现，导致在20世纪60年代出现了基于计算机的第一个实现。尽管这些尝试并不特别成功，但主要是因为当时所需的计算能力还需要几年时间才能让这项技术对用户有吸引力。
- en: The right time came in the late 1980s. After the microcomputer boom, and shortly
    before the frontal assault of the PC platform, a number of humble proposals made
    the rounds at Conseil Europeén pour la Recherche Nucléaire^([[29](#ftn.CHP-14-FN-2)])
    (CERN) concerning the possibilities of hyperlinking. Tim Berners-Lee, one of the
    CERN researchers, is by all accounts the one to officially blame for spawning
    HyperText Markup Language (HTML), a set of controls for embedding metadata, links,
    and media resources in text documents. (Truth be told, HTML, the core of the Web
    as we know it, is hardly an entirely new design and borrows some ideas from SGML,
    an ISO 8879 Standard Generalized Markup Language of 1986.) The first web browser
    was born shortly thereafter on what is now a barely known, but was then an innovative
    and advanced computer platform, NeXT. The browser was given the ubiquitous name
    World Wide Web.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的时间是在20世纪80年代末。在微型计算机热潮之后，以及个人电脑平台的前夕，在核子研究欧洲委员会（Conseil Européen pour la
    Recherche Nucléaire^([[29](#ftn.CHP-14-FN-2)))，即CERN）提出了一系列关于超链接可能性的谦逊建议。蒂姆·伯纳斯-李，CERN的研究员之一，据说是官方上应该负责孕育超文本标记语言（HTML）的人，这是一种在文本文档中嵌入元数据、链接和媒体资源的一套控件。（说实话，HTML，我们今天所知道的网络的基石，几乎不是一个全新的设计，它借鉴了一些来自1986年ISO
    8879标准的通用标记语言SGML的想法。）第一个网络浏览器随后在现在几乎无人知晓，但当时是一个创新且先进的计算机平台NeXT上诞生。这个浏览器被赋予了无处不在的名字——万维网。
- en: Now that we came up with a catchy name, the revolution was unstoppable. In 1992,
    Berners-Lee filed an initial specification draft^([[99](apb.html#ftn.CHP-14-BIB-3)])
    for HyperText Trans-fer Protocol (HTTP), a tool for encapsulating HTML data and
    other resources in server-to-client communications. In 1993, several web browser
    engines became available, and a handful of web servers were already serving their
    contents to curious visitors. Of course, HTTP accounted for only a smashing 0.01%
    of all backbone traffic, but it was rising!
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想出了一个吸引人的名字，革命就势不可挡了。1992年，伯纳斯-李提交了超文本传输协议（HTTP）的初始规范草案^([[99](apb.html#ftn.CHP-14-BIB-3)]），这是一个用于封装HTML数据和其他资源在服务器到客户端通信中的工具。1993年，几个网络浏览器引擎变得可用，一些网络服务器已经向好奇的访客提供内容。当然，HTTP只占所有骨干网络流量的0.01%，但它在增长！
- en: The first popular web browser, Mosaic, was developed at the National Center
    for Supercomputer Applications, at the University of Illinois. It borrowed from
    Berners-Lee’s code, but added support for contents other than text, and introduced
    fillable forms and many other features that we now take for granted. Mosaic’s
    code eventually evolved into Mozilla, which, in turn, served as the core code
    for Netscape Navigator (later to fork into the open-source project Mozilla, whose
    codebase would be then used as a foundation for subsequent generations of Netscape
    Navigator—simple, isn’t it?). At the same time, just to further confuse users,
    a company called Spyglass transformed Mosaic into the core of what was to become
    Netscape’s main competitor, Microsoft Internet Explorer.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个流行的网络浏览器Mosaic是在伊利诺伊大学的超级计算应用国家中心开发的。它借鉴了伯纳斯-李的代码，但增加了对除文本之外的内容的支持，并引入了可填写的表单和许多我们现在视为理所当然的功能。Mosaic的代码最终演变成了Mozilla，反过来，它又成为了Netscape
    Navigator的核心代码（后来分支成为开源项目Mozilla，其代码库随后被用作后续几代Netscape Navigator的基础——简单，不是吗？）。与此同时，为了进一步混淆用户，一家名为Spyglass的公司将Mosaic转变为将成为Netscape主要竞争对手的Microsoft
    Internet Explorer的核心。
- en: In 1994 the W3C, a body devised to oversee the development of the Web, was formed.
    The first official, much-improved, and extended version of the protocol was filed
    by Berners-Lee, Roy T. Fielding, and Henrik Frystyk in 1996, soon followed by
    the HTML 3.2 specifications. In subsequent years we saw newer, enhanced versions
    of HTTP and HTML, now governed by the W3C. And you all know the story’s ending;
    or is it only the beginning?
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，为了监督Web的发展而设立的W3C组织成立。伯纳斯-李、Roy T. Fielding和Henrik Frystyk在1996年提交了该协议的第一个官方、改进和扩展版本，随后很快是HTML
    3.2规范。在随后的几年里，我们看到了HTTP和HTML的新版本和增强版本，现在由W3C管理。你们都知道故事的结局；或者这只是个开始？
- en: '* * *'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#CHP-14-FN-2)]) European Laboratory for Particle Physics, Geneva, Switzerland.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-14-FN-2)]) 瑞士日内瓦欧洲粒子物理实验室。
- en: A HyperText Transfer Protocol Primer
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超文本传输协议入门
- en: 'HTTP^([[100](apb.html#ftn.CHP-14-BIB-4)]) is a surprisingly straightforward,
    text-based protocol built on top of TCP/IP. A client for this protocol connects
    to an HTTP-capable service on a remote server and makes a request, asking for
    a specific resource on the server. An HTTP request includes the following parameters
    in the first line of a query:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP^([[100](apb.html#ftn.CHP-14-BIB-4)]) 是一个令人惊讶的直接、基于文本的协议，建立在TCP/IP之上。该协议的客户端连接到远程服务器上的一个支持HTTP的服务，并发出请求，请求服务器上的特定资源。HTTP请求在查询的第一行包含以下参数：
- en: A method for accessing the resource. Most often, the client simply asks to retrieve
    a file, by issuing a GET request (though other methods exist for tasks such as
    submitting form data, performing diagnostics, storing data on a server, or executing
    certain extensions).
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问资源的方发。通常，客户端只需发出一个GET请求来请求检索一个文件（尽管存在其他方法用于提交表单数据、执行诊断、在服务器上存储数据或执行某些扩展）。
- en: A universal resource identifier (URI). This is a path to a static file or to
    a dynamic executable that is the subject of the request. If the file is a dynamic
    executable, it is also possible to pass additional, appropriately encoded parameters
    to this program as a part of the URI.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用资源标识符（URI）。这是一个指向静态文件或指向请求主题的动态可执行文件的路径。如果文件是动态可执行文件，也可以将适当编码的额外参数作为URI的一部分传递给此程序。
- en: The version of the protocol the client supports and wants to use. The server
    can choose to reply with a lower protocol version if the one used by the client
    is unsupported. (If this information is missing, the client is assumed to be using
    HTTP/0.9, an early and obsolete version of the protocol, which we won’t address
    here.)
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端支持的协议版本以及想要使用的版本。如果客户端使用的版本不受支持，服务器可以选择以较低的协议版本回复。（如果缺少此信息，则假定客户端正在使用HTTP/0.9，这是协议的一个早期和过时的版本，我们在此不予讨论。）
- en: 'For example, an HTTP request might look like this:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个HTTP请求可能看起来像这样：
- en: '[PRE4]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This request asks for a resource called `/show_plush_toys.cgi` at [www.plush-penguins.com](http://www.plush-penguins.com).
    Judging by the file’s `cgi` extension, this is a dynamically executed program
    that is invoked with two parameters (`param1` and `param2`), as listed following
    the question mark.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求要求获取一个名为 `/show_plush_toys.cgi` 的资源，位于 [www.plush-penguins.com](http://www.plush-penguins.com)。根据文件的
    `cgi` 扩展名判断，这是一个动态执行的程序，通过两个参数（`param1` 和 `param2`）调用，这些参数列在问号之后。
- en: The client request can be (and in this example indeed is) followed by a number
    of text headers, one on each line, that specify additional parameters. These can
    be anything from client identification (User-Agent field, as mentioned earlier),
    to the preferred language for the contents (here Polish and English), to the specification
    of a virtual server the client is referring to. (If several domain names point
    to a single IP address, this specification makes it possible for the server to
    determine whether the user is looking for [www.squeaky-ducks.com](http://www.squeaky-ducks.com)
    and [www.plush-penguins.com](http://www.plush-penguins.com), both of which might
    be hosted on the same system.)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求可以（在这个例子中确实如此）后面跟着多个文本头部，每个头部一行，指定额外的参数。这些可以是任何东西，从客户端识别（如前面提到的User-Agent字段），到内容的首选语言（这里为波兰语和英语），到客户端引用的虚拟服务器的规范。（如果多个域名指向单个IP地址，这个规范使得服务器能够确定用户是否正在寻找[www.squeaky-ducks.com](http://www.squeaky-ducks.com)和[www.plush-penguins.com](http://www.plush-penguins.com)，这两个网站可能托管在同一个系统上。）
- en: The protocol mandates some of these headers. The set of required headers depends
    on its version, but most servers are fairly lax and make no fuss if some are omitted.
    This aside, some headers specify features that go beyond the protocol’s specification
    itself.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 协议强制要求一些这些头部。所需头部的集合取决于其版本，但大多数服务器相当宽松，如果省略一些头部也不会大惊小怪。除此之外，一些头部指定了超出协议本身规范的功能。
- en: 'Each request must end with an empty line, denoting the end of the client headers,
    at which point, for most types of requests, the server is expected to process
    the query and produce a reply. The server usually responds with a message in a
    structure similar to the query, starting with an HTTP return code and some descriptive
    text, like this one:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都必须以一个空行结束，表示客户端头部的结束。在此之后，对于大多数类型的请求，服务器应处理查询并生成回复。服务器通常以与查询类似的结构返回消息，以HTTP返回代码和一些描述性文本开始，如下所示：
- en: '[PRE5]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The return code or message might report various conditions, such as the successful
    completion of the request, an instruction for the browser to look somewhere else,
    or an error message such as “File Not Found” or “Permission Denied.” This information
    is followed by a set of headers, similar to the format accepted for the request.
    These describe various parameters such as the server software version, the location
    the browser should proceed to next, a content type specification for the returned
    file, a setting used to differentiate images from plain-text or HTML documents
    from binary files, and so on. The actual contents follow, if available.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 返回代码或消息可能报告各种条件，例如请求的成功完成、指示浏览器查找其他位置的指令，或者“文件未找到”或“权限拒绝”之类的错误消息。这些信息后面跟着一组与请求接受的格式类似的头部。这些描述了各种参数，例如服务器软件版本、浏览器应继续前往的位置、返回文件的内容类型规范、用于区分图像与纯文本或HTML文档与二进制文件的设置等。如果有实际内容，则紧随其后。
- en: As you can see, basic HTTP is fairly simple. Although it does offer some advanced
    features, most are either slightly bizarre, or just rarely used. (I’m guessing
    that you do not see the “402 Payment Required” error message every day.) Still,
    it would be naive to trust that the basic protocol is sufficient to meet the needs
    and expectations of today’s users.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，基本的HTTP相当简单。尽管它确实提供了一些高级功能，但大多数要么有些奇怪，要么很少使用。（我猜您不会每天看到“402支付所需”的错误消息。）然而，认为基本协议足以满足当今用户的需要和期望是过于天真的。
- en: Making HTTP Better
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使HTTP变得更好
- en: The days when a typical website consisted of several kilobytes of static text
    and perhaps some minor graphic elements are long gone. As computers have become
    more powerful, and 300 bps modems have become easier to find in a museum than
    in every household, form has begun to dominate substance on the Web. Hundreds
    of kilobytes of images and subpages, subframes, and client-side scripts are commonly
    used to make sites more attractive and professional, with varying degrees of success.
    For many sites, multimedia contents have actually become the primary type of information
    served, with HTML providing only a placeholder for images, video, embedded Java
    programs, or games. The Web in general is no longer merely a way to tell others
    about your private projects or interests; the driving force behind it is the ability
    to market and sell products and services cheaper and faster than ever. And marketing
    demands the eye-catching presentation of products and services.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 那个典型的网站由几千字节静态文本和一些次要的图形元素组成的时代已经一去不复返了。随着计算机变得越来越强大，而300 bps的调制解调器在博物馆里比在每家每户中更容易找到，形式已经开始在互联网上占据实质性的位置。数百千字节的照片、子页面、子框架和客户端脚本通常被用来使网站更具吸引力和专业性，但效果各不相同。对于许多网站来说，多媒体内容实际上已经成为提供的主要信息类型，而HTML仅仅为图像、视频、嵌入的Java程序或游戏提供了一个占位符。总的来说，互联网不再仅仅是告诉别人你的私人项目或兴趣的一种方式；其背后的驱动力是能够以比以往任何时候都便宜和快速的方式营销和销售产品和服务。而营销需要产品的引人注目的展示。
- en: Web browsers, web servers, and HTTP itself have had to adapt to this changing
    reality to make it easy to deploy new technologies and follow new trends. Conveniently
    enough, many of the technologies introduced in this process have interesting security
    implications for mere mortals and can also help us identify the client on the
    other end of the wire in a transparent way. As such, we must consider the optional
    features and extensions introduced since the day the Web was born.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器、网络服务器以及HTTP本身都必须适应这种不断变化的事实，以便轻松部署新技术并跟随新趋势。方便的是，在这个过程中引入的许多技术对普通人来说具有有趣的安保影响，也可以帮助我们以透明的方式识别线另一端的客户端。因此，我们必须考虑自互联网诞生以来引入的可选功能和扩展。
- en: 'Latency Reduction: A Nasty Kludge'
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟减少：一个糟糕的修补
- en: The problem with the Web and some other current protocols is that the content
    presented to a user by a single multimedia site must be obtained from various
    sources (including wholly different domains) and then combined. Web pages have
    their text and formatting information separate from actual images and other sizable
    goodies (a practice truly to be praised by those who have a limited bandwidth
    and just want to get to the point).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网和一些其他当前协议的问题在于，由单一多媒体网站提供给用户的必须从各种来源（包括完全不同的域名）获取，然后组合。网页的文本和格式信息与实际的图像和其他大量好东西（对于那些带宽有限且只想直接到达目的地的人来说，这种做法确实值得赞扬）是分开的。
- en: 'This situation makes it necessary for clients to make several requests in order
    to render a web page. The most naive way to achieve this is by requesting each
    piece, one by one, in sequence, but this is not the best practice in the real
    world because it leads to bottlenecks: Why wait for a page to load simply because
    the banner server is running slowly? Hence, to improve the speed of content retrieval,
    the browser issues numerous requests at once.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况使得客户端必须发出多个请求才能渲染一个网页。最天真实现这一点的办法是逐个请求每一部分，按顺序进行，但在现实世界中这并不是最佳实践，因为它会导致瓶颈：为什么因为横幅服务器运行缓慢就要等待页面加载呢？因此，为了提高内容检索速度，浏览器会同时发出多个请求。
- en: 'And herein lies the first shortcoming of HTTP: it offers no native ability
    to serve simultaneous requests. Instead, requests must be issued sequentially.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 而这正是HTTP的第一个缺点：它没有提供原生能力来服务并发请求。相反，请求必须按顺序发出。
- en: The *sequential* (also called *serial*) *fetch* model results in a considerable
    performance penalty if one of the web page elements needs to be downloaded from
    a slow server or over a spotty link or if it takes a while for the server to prepare
    and deliver a particular element. If sequential fetching were the only option,
    any such slow request would prevent subsequent requests from being issued and
    served until it (the slow request) is filled.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序*（也称为*串行*）*获取*模型如果网页中的一个元素需要从慢速服务器下载，或者通过信号不稳定链接，或者服务器需要一段时间来准备和发送特定元素，那么它会导致相当大的性能损失。如果顺序获取是唯一的选择，那么任何此类慢速请求都会阻止后续请求的发出和提供，直到（慢速请求）被满足。'
- en: 'Because newer versions of HTTP have not improved this situation, most client
    software implements a kludge: the web browser simply opens a number of simultaneous,
    separate TCP/IP sessions to a server or a set of servers and attempts to issue
    many requests at once. This solution is actually quite sane when the page is requesting
    resources from several separate machines. However, it’s not a good fix when the
    requested resources are on a single system, where all requests could be made in
    a single session and reasonably managed by the server. Here’s why:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP的新版本并没有改善这种情况，大多数客户端软件实现了一个修补程序：网络浏览器简单地打开多个同时的、独立的TCP/IP会话到服务器或一组服务器，并尝试一次性发出多个请求。当页面从多个不同的机器请求资源时，这种解决方案实际上是相当合理的。然而，当请求的资源位于单个系统上时，所有请求都可以在一个会话中完成，并由服务器合理管理，这并不是一个好的解决方案。原因如下：
- en: The server has no chance to determine the best order in which to serve requests.
    (If it could, it would serve time-consuming, sizable, or simply the least relevant
    objects last.) It is simply forced to do all nearly at once, which can still cause
    the most important stuff to be needlessly delayed by increased CPU load.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器没有机会确定处理请求的最佳顺序。（如果它能，它将最后处理耗时、体积大或最不相关的对象。）它被迫几乎同时处理所有请求，这仍然可能导致最重要的内容因CPU负载增加而被无谓地延迟。
- en: If several larger resources are served at once, and the operating system scheduler
    switches between the sessions, the result can be considerable negative performance
    impact due to the need for the disk drive to seek between two possibly distant
    files repeatedly and in rapid succession.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同时提供几个较大的资源，并且操作系统调度程序在会话之间切换，那么由于需要在两个可能相距较远的文件之间反复快速地寻找，结果可能会因为磁盘驱动器需要频繁地寻找而造成相当大的性能负面影响。
- en: Considerable overhead is usually associated with completing a new TCP/IP handshake
    (though this is somewhat lessened by keep-alive capabilities in newer versions
    of HTTP). It’s more efficient to issue all requests within a single connection.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成新的TCP/IP握手通常会有相当大的开销（尽管在HTTP的新版本中，通过保持连接的能力有所减轻）。在单个连接中发出所有请求更有效率。
- en: Opening a new session and spawning a new process to serve the request involves
    overhead on the operating system level and strains devices such as stateful firewalls.
    Although modern web servers attempt to minimize this problem by keeping spare,
    persistent processes to accept requests as they arrive, the problem is seldom
    eliminated fully. A single session avoids unnecessary overhead and lets the server
    allocate only the resources absolutely needed to asynchronously serve chosen requests.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个新的会话并创建一个新的进程来处理请求，这在操作系统级别会产生开销，并给诸如状态防火墙等设备带来压力。尽管现代网络服务器试图通过保留一些备用、持久化的进程来接受到达的请求以最小化这个问题，但问题很少被完全消除。单个会话避免了不必要的开销，并让服务器仅分配绝对必要的资源来异步处理选定的请求。
- en: Last but not least, if the network, not the server, is the bottleneck, performance
    can actually deteriorate as packets are dropped as the link saturates with data
    from several sources arriving at once.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，如果瓶颈是网络而不是服务器，那么随着来自多个来源的数据同时到达，链路饱和时数据包丢失，性能实际上可能会下降。
- en: Alas, good or bad, this architecture is with us for now, and it is still better
    than serial fetch. We should acknowledge its presence and learn to take advantage
    of it.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这种架构目前仍然存在，并且它比串行获取要好。我们应该承认它的存在，并学会利用它。
- en: 'How can this very property help us to identify the software that the client
    is using? Quite simply. The significance of parallel file fetching for the purpose
    of browser fingerprinting should be fairly obvious: no two concurrent fetch algorithms
    are exactly the same, and there are good ways to measure this.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性如何帮助我们识别客户端使用的软件呢？很简单。并行文件获取对浏览器指纹识别目的的重要性应该是相当明显的：没有两个并发获取算法是完全相同的，而且有很好的方法来衡量这一点。
- en: 'But before we turn our attention to parallel fetching, we need to take a look
    at two other important pieces of the security and privacy equation for the Web:
    caches and identity management. Although seemingly unrelated, they make a logical
    whole in the end. Thus, a brief intermission.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们转向并行获取之前，我们需要看看Web安全和隐私方程中的另外两个重要组成部分：缓存和身份管理。尽管表面上看似无关，但最终它们构成了一个逻辑整体。因此，这里有一个简短的休息。
- en: Content Caching
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容缓存
- en: Keeping local caches of documents received from the server is one of the more
    important features of the Web during its rapid expansion in recent years.^([[30](#ftn.CHP-14-FN-3)])
    Without it, the cost of running this business would have been considerably higher.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，随着网络的快速扩张，保持从服务器接收到的文档的本地缓存是网络的一个重要特性.^([[30](#ftn.CHP-14-FN-3)]) 没有它，运营这项业务的成本将会显著更高。
- en: The problem with the increasing weight and complexity of a typical website is
    that it requires more and more bandwidth (which for businesses remains generally
    quite expensive), as well as better servers to serve the data at a reasonable
    speed.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 典型网站重量和复杂性的增加问题在于它需要越来越多的带宽（对于企业来说，这通常相当昂贵），以及更好的服务器以合理的速度提供服务。
- en: 'If performance is not impacted by bandwidth bottlenecks, solutions such as
    concurrent sessions (as described earlier) put additional strain on service providers
    instead. The reason might be fairly surprising: if a person on a fairly slow link
    (such as a modem) opens four subsequent sessions to fetch even a fairly simple
    page, four connections and four processes or threads need to be kept alive on
    the server, taking away those resources from those with faster connections.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能不受带宽瓶颈的影响，那么像并发会话（如前所述）这样的解决方案会给服务提供商带来额外的压力。原因可能相当令人惊讶：如果一个人在相当慢的链路上（例如调制解调器）打开四个后续会话来获取一个相当简单的页面，服务器上需要保持四个连接和四个进程或线程的活跃，从而从那些更快连接的用户那里夺取资源。
- en: Finally, to make things worse, heavier and more complex websites don’t always
    mesh with user expectations. Relatively long web page load times that were once
    considered fairly decent now seem annoying and drive users away. In fact, research
    suggests that the average web user won’t wait more than 10 seconds for a page
    to download before they move on.^([[101](apb.html#ftn.CHP-14-BIB-5)]) The result
    is that corporations and service providers need more resources and better links
    to handle the incoming traffic. In fact, had things been left the way they were
    initially designed, the demand for serverside resources would have likely exceeded
    our capacity to fulfill the demand some time ago.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，事情变得更糟，更重、更复杂的网站并不总是与用户的期望相匹配。曾经被认为相当不错的相对较长的网页加载时间现在似乎很烦人，并驱使用户离开。事实上，研究表明，平均的网页用户在页面下载前不会等待超过10秒，然后才会继续浏览.^([[101](apb.html#ftn.CHP-14-BIB-5)])
    结果是，公司和服务提供商需要更多的资源以及更好的链接来处理涌入的流量。实际上，如果事情按照最初的设计进行，对服务器端资源的需求可能早就超过了我们满足需求的能力。
- en: Of some help is that the contents served to web surfers is static or changes
    seldom, at least when compared with the rate at which a resource is retrieved
    by users. (This is especially true for large files, such as graphics, video, documents,
    executables, and so on.) By caching data closer to the end user—be it on the ISP
    level or even on the endpoint browser itself—we can dramatically decrease the
    bandwidth used for subsequent visits from users who share a common caching engine
    and make it easier on the servers handling the traffic. The ISP benefits from
    a lowered bandwidth consumption, as well, being able to serve more customers without
    having to invest in new equipment and connections. What HTTP needs, however, is
    a mechanism to keep the cache accurate and up-to-date. The author of a page (either
    human or machine) needs to be able to tell the cache engine when to fetch a newer
    version of a document.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些帮助的是，提供给网络浏览者的内容是静态的或者很少变化，至少与用户检索资源的速度相比是这样的。（这对于大型文件尤其如此，例如图形、视频、文档、可执行文件等等。）通过在更靠近最终用户的地方缓存数据——无论是在ISP层面还是在终端浏览器本身——我们可以显著减少后续访问共享相同缓存引擎的用户所使用的带宽，并减轻处理流量的服务器的负担。ISP也因此受益，降低了带宽消耗，能够在不投资新设备和新连接的情况下服务更多的客户。然而，HTTP需要的是一个机制来保持缓存准确和更新。页面作者（无论是人类还是机器）需要能够告诉缓存引擎何时获取文档的新版本。
- en: 'To implement document caching, HTTP provides two built-in features:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现文档缓存，HTTP提供了两个内置功能：
- en: A method for telling, with minimum effort, whether a portion of data has been
    modified since the most recent version held by the cache engine (the document
    recorded at the time of the last visit).
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种以最小的努力来判断数据的一部分自缓存引擎最近版本（即上次访问时记录的文档）以来是否已被修改的方法。
- en: A method for determining which portions of data should *not* be cached, whether
    for security reasons or because the data is generated dynamically every time the
    resource is requested.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种确定哪些数据部分不应缓存的机制，无论是出于安全原因还是因为数据每次请求资源时都是动态生成的。
- en: 'This functionality is in practice achieved fairly simply: The server returns
    all cacheable documents with the regular HTTP session, but with an additional
    protocol-level header, Last-Modified. To no surprise, this header represents the
    server’s idea of the time this document was last modified. Documents that cannot
    be cached are, on the other hand, marked by the server with the header Pragma:
    no-cache (Cache-Control: no-cache in HTTP/1.1).'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '在实践中，这种功能相当简单实现：服务器通过常规的HTTP会话返回所有可缓存的文档，但会额外添加一个协议级别的头部，即Last-Modified。不出所料，这个头部代表了服务器认为该文档最后修改的时间。另一方面，无法缓存的文档则由服务器通过头部Pragma:
    no-cache（在HTTP/1.1中为Cache-Control: no-cache）进行标记。'
- en: The client browser (or an intermediate cache engine run by the ISP) is supposed
    to cache a copy of every cacheable page based on the presence of an appropriate
    header, along with the last modification information. It should keep the cached
    page for as long as possible, either until the user-configured cache limit is
    exceeded or the user manually purges the cache, unless specifically instructed
    to discard it after a specific date with an Expires header.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端浏览器（或由ISP运行的中间缓存引擎）应基于适当头部的存在以及最后修改信息缓存每个可缓存的页面副本。它应尽可能长时间地保留缓存的页面，除非用户配置的缓存限制被超过或用户手动清除缓存，除非有特定的Expires头部指示在特定日期后丢弃它。
- en: Later, when the site is visited again, the client concludes that they have a
    previous instance of the page cached on the disk and follows a slightly different
    procedure when accessing it. As long as a document lives in the cache, the client
    attempts to fetch the file every time the user revisits a site, but specifies
    the If-Modified-Since header with every request, using the value previously seen
    in the Last-Modified header for <Since>. The server is expected to compare the
    Modified-Since value with its knowledge of the last modification time for a given
    resource. If the resource has not been changed since that time, the HTTP error
    message “304 Not Modified” is returned instead of the requested data. As a result,
    the actual file transfer is suppressed, thus preserving bandwidth (with only a
    couple of hundred bytes exchanged during this communication). The client (or intermediate
    cache engine) is expected to use a previously cached copy of the resource instead
    of downloading it again.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当再次访问网站时，客户端会得出结论，他们在磁盘上缓存了该页面的先前实例，并在访问它时遵循略微不同的程序。只要文档存在于缓存中，客户端就会在用户每次重新访问网站时尝试获取文件，但会使用每次请求中Last-Modified头部中看到的值作为If-Modified-Since头部的值。服务器预计会将其对给定资源的最后修改时间的了解与Modified-Since值进行比较。如果自那时起资源没有发生变化，则返回HTTP错误消息“304
    Not Modified”，而不是请求的数据。因此，实际文件传输被抑制，从而节省带宽（在此通信期间仅交换了数百字节）。客户端（或中间缓存引擎）预计会使用之前缓存的资源副本，而不是再次下载。
- en: Note
  id: totrans-705
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A more up-to-date approach, ETag and If-None-Match headers, a part of entity
    tagging functionality of HTTP/1.1, works in a similar manner but aims to resolve
    the ambiguity surrounding the interpretation of file modification times: the problems
    that stem from a file being modified several times in a short period of time (below
    the resolution of the clock used for Last-Modified data). of files being restored
    from a backup (with a modification time older than the last cached copy), and
    so on.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更现代的方法，即ETag和If-None-Match头部，是HTTP/1.1实体标签功能的一部分，其工作方式类似，但旨在解决围绕文件修改时间解释的歧义：在短时间内（低于用于Last-Modified数据的时钟分辨率）多次修改文件的问题，以及从备份中恢复文件（修改时间早于最后缓存的副本）等问题。
- en: 'Managing Sessions: Cookies'
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话管理：Cookies
- en: Another important and seemingly unrelated requirement for HTTP was that it be
    able to differentiate between sessions and track them across connections, store
    session settings and identity information. For example, some websites greatly
    benefit from the ability to adapt to one’s personal preferences and to restore
    the look and feel chosen by the user each time they visit the site. Naturally,
    a user’s identity can be established by prompting for a login and password every
    time a page is viewed, at which point the user’s personal settings can be loaded,
    but this bit of extra effort dramatically reduces the number of people who would
    be willing to do this to access the page.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP来说，另一个重要且看似无关的要求是它能够区分会话并在连接之间跟踪它们，存储会话设置和身份信息。例如，一些网站极大地受益于能够适应个人的偏好，并在用户每次访问网站时恢复用户选择的界面和感觉。自然地，用户的身份可以通过每次查看页面时提示登录名和密码来建立，此时可以加载用户的个人设置，但这种额外的努力大大减少了愿意为此访问页面的人数。
- en: A transparent and persistent way to store and retrieve certain information from
    the client’s machine was needed to ensure seamless and personalized access to
    web forums, bulletin boards, chats, and many other features that define the browsing
    experience for so many people. On the other hand, the ability for web server administrators
    to recognize and identify returning visitors by assigning them a unique tag and
    retrieving it later meant the surrender of anonymity in exchange for a little
    convenience. Such a mechanism would give companies with second-grade ethics a
    great tool to track and profile users, record their shopping and browsing preferences,
    determine their interests, and so forth. Search engines could easily correlate
    requests from the same user, and content providers that serve resources such as
    ad banners could use this information to track people even without their permission
    or the knowledge of site operators.^([[31](#ftn.CHP-14-FN-4)]) Regardless of the
    concerns, however, there seemed to be no better, sufficiently universal alternative
    for this mechanism. And so web cookies were born.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一种透明且持久的方式来存储和检索客户端机器上的某些信息，以确保无缝且个性化的访问网络论坛、公告板、聊天以及许多其他定义了许多人浏览体验的功能。另一方面，通过为返回访客分配一个唯一的标签并在之后检索它，网络服务器管理员能够识别和识别访客，这意味在换取一点便利的同时牺牲了匿名性。这样的机制会给那些道德等级较低的公司提供一个强大的工具来追踪和建立用户档案，记录他们的购物和浏览偏好，确定他们的兴趣等等。搜索引擎可以轻易地将同一用户的请求关联起来，而提供如广告横幅等资源的内容提供商可以利用这些信息来追踪人们，即使在没有他们的许可或网站运营商知情的情况下。[^([31](#ftn.CHP-14-FN-4))]
    然而，不管怎样，似乎没有更好的、足够通用的替代机制。因此，网络cookies应运而生。
- en: Cookies, as specified in RFC2109,^([[102](apb.html#ftn.CHP-14-BIB-6)]) are small
    portions of text that are issued by a server when the client connects to it. The
    server specifies a Set-Cookie header in the response to the visitor. This portion
    of text is, by its additional parameters, limited in scope to a specific domain,
    server, or resource and has a limited lifespan. Cookies are stored by cookie-enabled
    client software in a special container file or folder (often referred to as a
    *cookie jar*) and are automatically sent back to the server using a Cookie header
    whenever a connection to a specific resource is established again.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC2109的规定，[^([102](apb.html#ftn.CHP-14-BIB-6))] Cookies是由服务器在客户端连接到它时发出的小段文本。服务器在响应访客时指定一个Set-Cookie头。这部分文本通过其附加参数，其范围被限制在特定的域名、服务器或资源，并且有有限的生命周期。Cookies由启用cookie功能的客户端软件存储在特殊的容器文件或文件夹中（通常被称为“cookie
    jar”），并在再次建立到特定资源的连接时，通过Cookie头自动发送回服务器。
- en: Servers can choose to store (or push out) user settings in Set-Cookie headers
    and just read them back on subsequent visits; and here is where cookie functionality
    would end in a perfect world. Unfortunately, computers have no way of telling
    what is stored in a cookie. A server can choose to assign a unique identifier
    to a client using the Set-Cookie header and then read it back to link current
    user activity to previous actions in the system.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以选择在Set-Cookie头中存储（或推送）用户设置，并在后续访问时读取它们；在理想的世界里，这就是cookie功能结束的地方。不幸的是，计算机没有方法知道cookie中存储了什么。服务器可以选择使用Set-Cookie头为客户端分配一个唯一的标识符，然后读取它以将当前用户活动与系统中的先前操作联系起来。
- en: The mechanism is wildly regarded as having serious privacy implications. Some
    activists downright hate cookies, but the opposition to this technology is getting
    less and less vocal nowadays. Browsing the Web with cookies disabled gets increasingly
    more difficult—with some sites even refusing traffic from clients that do not
    pass a cookie check. Thankfully, many browsers offer extensive cookie acceptance,
    restriction, or rejection settings and can even prompt for every single cookie
    before accepting it (although the latter is not particularly practical). This
    makes it possible to mount a reasonable defense of your privacy, if only by defining
    who the “good guys” are and who to trust.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制普遍被认为具有严重的隐私影响。一些活动家直言不讳地讨厌Cookie，但如今对这种技术的反对声音越来越小。禁用Cookie浏览网页变得越来越困难——一些网站甚至拒绝来自未通过Cookie检查的客户端的流量。幸运的是，许多浏览器提供了广泛的Cookie接受、限制或拒绝设置，甚至可以在接受之前提示每个Cookie（尽管后者并不特别实用）。这使得您能够合理地保护您的隐私，至少可以通过定义“好人”是谁以及谁值得信赖来实现。
- en: But is our privacy in our hands then?
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的隐私真的在我们手中吗？
- en: When Cookies and Caches Mix
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当Cookie和缓存混合时
- en: The privacy of web browsing has long been considered a hot issue, and not without
    reason. Many people do not want others to snoop on their preferences and interests,
    even if their whereabouts are not particularly questionable. Why? Sometimes, you
    simply do not want a shoddy advertising company to know that you are reading about
    a specific medical condition and then be able to link this information to an account
    you have on a professional bulletin board, particularly because there is no way
    of knowing where this information will end up.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览的隐私长期以来一直被视为一个热点问题，并非没有理由。许多人不希望别人窥探他们的偏好和兴趣，即使他们的行踪并不特别可疑。为什么？有时，你只是不希望一家糟糕的广告公司知道你在阅读关于特定医疗状况的内容，然后能够将此信息与你在一个专业论坛上的账户联系起来，尤其是因为无法知道这些信息最终会去哪里。
- en: 'Cookie control makes our browsing experience reasonably comfortable, while
    keeping bad guys at bay. But even turning cookies off does not prevent information
    from being stored on one’s system to be later sent back to a server. The functionality
    needed to store and retrieve data on a victim’s machine has long been present
    in all browsers, regardless of cookie policy settings. The two necessary technologies
    work in a similar manner and differ only in terms of their intended use: cookies
    and file caching.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie控制使我们的浏览体验相对舒适，同时将坏人拒之门外。但即使关闭Cookie也无法阻止信息存储在用户的系统中，以便稍后发送回服务器。在受害者机器上存储和检索数据的所需功能早已存在于所有浏览器中，无论Cookie策略设置如何。这两种必要的技术以类似的方式工作，只是在预期用途上有所不同：Cookie和文件缓存。
- en: Somewhere back in 2000, Martin Pool posted a fairly short but insightful message^([[103](apb.html#ftn.CHP-14-BIB-7)])
    to the Bugtraq mailing list, sharing an interesting observation and supporting
    it with some actual code. He concluded that there is no significant difference
    between the Set-Cookie and Cookie functionality versus Last-Modified and If-Modified-Since,
    at least for systems that do not use centralized proxy caches and that store copies
    of already fetched documents locally on disk (as is the case with most of us mere
    mortals). A malicious website administrator can store just about any message in
    the Last-Modified header returned for a page their victim visits (or, if this
    header is sanity-checked, it might simply use a unique, arbitrary date to uniquely
    identify this visitor). The client would then send If-Modified-Since with an exact
    copy of the unique identifier stored by a rogue operator on their computer whenever
    a page is revisited. A “304 Not Modified” response ensures that this “cookie”
    is not discarded.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年左右，Martin Pool在Bugtraq邮件列表上发布了一条相当简短但富有洞察力的信息^([[103](apb.html#ftn.CHP-14-BIB-7)])，分享了一个有趣的观察，并用一些实际代码来支持它。他得出结论，对于不使用集中式代理缓存并且将已获取的文档副本存储在本地磁盘上的系统（对我们大多数人来说都是如此），Set-Cookie和Cookie功能与Last-Modified和If-Modified-Since之间没有显著差异。恶意网站管理员可以在受害者访问的页面返回的Last-Modified头中存储几乎任何信息（或者，如果这个头进行了合理性检查，它可能会简单地使用一个唯一的、任意的日期来唯一标识这个访问者）。当页面被重新访问时，客户端会发送If-Modified-Since，其中包含由恶意操作员在他们的计算机上存储的唯一标识符的精确副本。“304未修改”响应确保这个“Cookie”不会被丢弃。
- en: Preventing the Cache Cookie Attack
  id: totrans-718
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止缓存Cookie攻击
- en: 'Using your browser to slightly tweak Last-Modified data in response might seem
    like a neat way to prevent this type of exposure (while introducing some cache
    inaccuracy), but this is not the case. Another variant of this attack is to rely
    on storing data in cached documents, as opposed to using tags directly: a malicious
    operator can prepare a special page for the victim when a website is visited for
    the first time. The page contains a reference to a unique file name listed as
    an embedded resource (for example, an image). When a client revisits this page,
    the server notices the If-Modified-Since header and replies with the 304 error
    message, prompting the old copy of the page to be used. The old page contains
    a unique file reference that is then requested from the server, making it possible
    to map the client’s IP to a previous session in which that file name had been
    returned. Oops.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器稍微调整Last-Modified数据作为响应似乎是一种防止此类暴露（同时引入一些缓存不准确）的整洁方法，但这并非如此。这种攻击的另一种变体是依赖于存储在缓存文档中的数据，而不是直接使用标签：当网站首次访问时，恶意操作者可以为受害者准备一个特殊页面。该页面包含对作为嵌入资源的唯一文件名的引用（例如，一个图像）。当客户端重新访问此页面时，服务器会注意到If-Modified-Since头，并回复304错误消息，提示使用旧版本的页面。旧页面包含一个唯一的文件引用，然后从服务器请求该文件，使得将客户端的IP映射到之前返回该文件名的会话成为可能。哎呀。
- en: Naturally, the lifetime of cache-based “cookies” is limited by cache size and
    expiration settings for cached documents configured by the user. However, these
    values are generally quite generous, and information stored within metadata for
    a resource that is revisited once every couple of weeks can last for years, until
    the cache is manually purged. For companies that serve common components included
    on hundreds or thousands of sites (again, banners are a good example), this is
    a nonissue.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，基于缓存的“cookies”的寿命受缓存大小和用户配置的缓存文档过期设置的限制。然而，这些值通常相当慷慨，对于每隔几周访问一次的资源，存储在元数据中的信息可以持续数年，直到手动清除缓存。对于为数百或数千个网站提供通用组件的公司（再次以横幅为例），这并不是一个问题。
- en: The main difference with these cache cookies, compared with cookies proper,
    is not a matter of the functionality they offer, but rather the ease of controlling
    the aforementioned exposure. (Cache data must also serve other purposes and cannot
    be easily restricted without a major performance impact associated with disabling
    caching partly or completely.)
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 与真正的cookies相比，这些缓存cookies的主要区别不在于它们提供的功能，而在于控制上述暴露的容易程度。（缓存数据还必须服务于其他目的，并且在不影响性能的情况下，不能轻易限制，否则会与禁用部分或全部缓存相关联的性能影响。）
- en: In this bizarre twist, you can see how two aspects of the Web collide, effectively
    nullifying security safeguards built around one of them. Practice shows that intentions
    are not always enough, because rogues are not always willing to play by the rules
    and use the technology the way we want them to. Perhaps turning your cookies off
    does not make that much of a difference after all?
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个奇怪的转折中，你可以看到网络的两个方面如何碰撞，有效地抵消了围绕其中一个方面构建的安全保障。实践表明，意图并不总是足够的，因为恶棍们并不总是愿意按照规则行事并使用我们希望他们使用的技术。也许关闭cookies最终并没有太大的区别？
- en: But then it is about time to go back to the main subject of our discussion.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 但这时，我们讨论的主题应该回到正题。
- en: '* * *'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[30](#CHP-14-FN-3)]) Its importance is slowly decreasing, however: as more
    and more web pages are generated dynamically, and our Internet backbone becomes
    more mature and capable, caching is bound to lose its significance.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-14-FN-3)]) 然而，它的重要性正在逐渐降低：随着越来越多的网页是动态生成的，我们的互联网骨干网变得更加成熟和强大，缓存注定会失去其重要性。
- en: ^([[31](#CHP-14-FN-4)]) If an advertisement banner or any other element of a
    website is placed on a shared server, such as [http://banners.evilcompany.com](http://banners.evilcompany.com),
    the operator of [evilcompany.com](http://evilcompany.com) can issue and retrieve
    cookies whenever a person visits any legitimate website that uses banners supplied
    by them. Needless to say, most banner providers do issue cookies and track users,
    albeit primarily for market research purposes.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#CHP-14-FN-4)]) 如果广告横幅或网站的任何其他元素放置在共享服务器上，例如[http://banners.evilcompany.com](http://banners.evilcompany.com)，那么[evilcompany.com](http://evilcompany.com)的操作员可以在任何使用他们提供的横幅的合法网站被访问时发布和检索cookies。不用说，大多数横幅提供商都会发布cookies并跟踪用户，尽管主要是为了市场研究目的。
- en: Uncovering Treasons
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭露背叛
- en: The subject of detecting trickery and accurately fingerprinting client software,
    that is. I have thus far mentioned that the task of detecting deceptive clients
    is complex, but not impossible and that behavioral analysis, a careful monitoring
    of the sequence of events produced by the browsers in question is a route worth
    exploring.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 检测欺诈和准确指纹识别客户端软件的主题。我迄今为止提到，检测欺骗客户端的任务很复杂，但并非不可能，并且行为分析，即对相关浏览器产生的事件序列的仔细监控，是一条值得探索的途径。
- en: HTTP is a particularly generous subject of study, because, as we have seen,
    much of the activity occurs in parallel or nearly in parallel, and the exact queuing
    and data-processing algorithms are fairly subtle and unique for each client. By
    measuring the number of files downloaded at once, the relative time delays between
    requests, the ordering of requests, and other fine details of a session, it is
    possible to measure the unique characteristics of a system on a level that is
    much more difficult for the user to tamper with. Hence, you can distinguish impersonators
    from law-abiding citizens with no effort.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个特别适合研究的主题，因为我们已经看到，大部分活动都是并行或几乎并行的，而确切的排队和数据处理的算法对每个客户端来说都是相当微妙且独特的。通过测量一次性下载的文件数量、请求之间的相对时间延迟、请求的顺序以及其他会话的细微但明显的细节，可以测量系统的独特特征，这在用户难以干预的层面上要困难得多。因此，你可以毫不费力地区分冒名顶替者和守法公民。
- en: To provide a real-world example of this approach in the simplest possible way,
    and to stay as close to real applications as possible, I decided to see how much
    could be told from existing, fairly limited samples of data that many of you probably
    have on hand, so I reached for the standard logs of slightly more than 1 million
    requests to a relatively popular website. The data used for this analysis was
    a typical Apache web server access log, containing request completion times, requested
    URIs, advertised browser data from the User-Agent header, and other basic information
    of this nature. The page for which the log was kept consists of a set of relatively
    small pictures of comparable size and a single HTML document that calls for them
    all.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以尽可能简单的方式提供一个现实世界的例子，并且尽可能接近实际应用，我决定看看从你们中许多人可能拥有的现有、相当有限的数据样本中可以讲述多少内容，因此我拿出了超过一百万次请求的标准日志，这些请求是针对一个相对受欢迎的网站的。用于此分析的数据是典型的Apache网络服务器访问日志，包含请求完成时间、请求URI、来自User-Agent头部的广告浏览器数据以及此类基本信息的其他信息。保留日志的页面由一组相对较小的、大小相仿的图片和一个调用所有这些图片的单一HTML文档组成。
- en: A Trivial Case of Behavioral Analysis
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为分析的一个简单案例
- en: Apache’s practice of logging requests when they are completed, as opposed to
    logging them when issued, could be perceived as a problem, but is actually quite
    helpful, assuming the requested set of files is relatively homogeneous. Request
    initiation order is usually more influenced by the sequence in which resources
    are referenced within the main page, whereas completion timing is a more complex
    beast.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: Apache在请求完成后而不是在请求发出时记录请求的做法，可能会被视为一个问题，但实际上却非常有帮助，假设请求的文件集相对同质。请求发起顺序通常更多地受主页面中引用资源的顺序的影响，而完成时间则是一个更复杂的生物。
- en: Completion order probabilities depend on the number of requests, inter-request
    delays, and other parameters that subtly but noticeably vary from browser to browser.
    In particular, browsers that always keep only one connection open always issue
    requests in a known order, A-B-C-D; browsers that open three connections at once
    and issue requests rapidly are just as likely to produce B-A-C-D, C-B-A-D, C-A-B-D
    . . . and in those later cases, requesting queuing and session management matters
    most.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 完成顺序的概率取决于请求的数量、请求间的延迟以及其他参数，这些参数微妙但明显地因浏览器而异。特别是，始终只保持一个连接打开的浏览器总是以已知顺序发出请求，A-B-C-D；同时打开三个连接并快速发出请求的浏览器同样可能产生B-A-C-D、C-B-A-D、C-A-B-D……在这些后一种情况下，请求排队和会话管理最为重要。
- en: Naturally, we cannot forget that the observed sequence is also heavily affected
    by network latency and reliability and other random issues. Still, it is reasonable
    to expect that, for such a large set of samples, these non–browser-specific effects
    would either average out or affect data for all clients in a similar way. And
    when this happens, we will hopefully see subtle differences between browsers that
    lie underneath a friendly user interface.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们不能忘记观察到的顺序也受到网络延迟、可靠性和其他随机问题的影响。尽管如此，对于如此大量的样本，这些非浏览器特定的效应要么会平均化，要么以类似的方式影响所有客户端的数据。当这种情况发生时，我们希望看到浏览器之间在友好用户界面之下存在的细微差异。
- en: '[Figure 14-1](ch14s05.html#behavioral_pattern_differences_for_popul "Figure 14-1. Behavioral
    pattern differences for popular web clients") shows a statistical distribution
    of attempts to load the ten-element web page mentioned earlier for the four most
    popular web clients in the dataset. Each graph is divided into ten major segments.
    The first corresponds to the main HTML file, which is directly requested and naturally
    makes the first element of the site. The remaining nine major segments correspond
    to nine images referenced from this HTML, in the order in which they are called
    for in HTML.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-1](ch14s05.html#behavioral_pattern_differences_for_popul "图14-1. 流行网络客户端的行为模式差异")显示了之前提到的包含十个元素的网页在数据集中四个最受欢迎的网络客户端中的加载尝试的统计分布。每个图表被分为十个主要部分。第一个对应于主要的HTML文件，它被直接请求并自然成为网站的第一个元素。其余的九个主要部分对应于从该HTML引用的九个图像，按照它们在HTML中调用的顺序。'
- en: Each of the segments is further divided into ten discrete locations on the X
    axis (not explicitly shown here to avoid cluttering the chart). The height of
    the graph at the *n*th discrete location within a given segment represents the
    likelihood of this particular file being loaded as the *n*th item in sequence.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分进一步在X轴上分为十个离散位置（在此处未明确显示，以避免图表杂乱）。给定部分中第n个离散位置的图表高度代表该特定文件作为第n个顺序项被加载的可能性。
- en: '![Behavioral pattern differences for popular web clients](httpatomoreillycomsourcenostarchimages1138102.png.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![流行网络客户端的行为模式差异](httpatomoreillycomsourcenostarchimages1138102.png.jpg)'
- en: Figure 14-1. Behavioral pattern differences for popular web clients
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1. 流行网络客户端的行为模式差异
- en: To make the graph more readable, distribution probabilities are given as percentages
    between 1 and 100 (corresponding to percentages, with all values less than 1 percent
    rounded up), and discrete points are connected with lines. The graphs are then
    plotted on a logarithmic scale (log10, with major guides at 1, 10, and 100) to
    make subtle features more pronounced and easier to visually compare.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图表更易于阅读，分布概率以1到100之间的百分比形式给出（对应于百分比，所有小于1%的值向上取整），并且离散点用线条连接。然后，图表在以对数尺度（log10，主要指南在1、10和100）上绘制，以便使细微特征更加明显，并更容易进行视觉比较。
- en: 'In a perfect world, with fully sequential and predictable browsers, the first
    segment would contain only a peak at the first (leftmost) discrete location; the
    second segment would contain a peak only at the second location, and so forth.
    In practice, however, some browsers issue many requests at once, and thus the
    order is more easily shuffled: the third referenced file can end up being loaded
    before the second or after the fourth. The less pronounced a single spike is in
    each segment, the more aggressive the browser fetch algorithm appears to be—for
    the more even the probability of this file being loaded out of order is.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界中，如果浏览器完全按顺序且可预测，第一个部分将只包含第一个（最左侧）离散位置的一个峰值；第二个部分将只在第二个位置有一个峰值，以此类推。然而，在实践中，一些浏览器会同时发出许多请求，因此顺序更容易被打乱：第三个引用的文件可能先于第二个或后于第四个加载。每个部分中单个峰值越不明显，浏览器获取算法看起来就越激进——这意味着这个文件被无序加载的概率越均匀。
- en: 'The differences should be clearly visible, even between browsers historically
    based on the same engine: Mozilla and Internet Explorer. All clients appear to
    observe the order in which files were referenced in the main document, and so
    subsequent spikes move slowly from left to right across the segments. Yet, as
    you can see, Mozilla is generally considerably less impatient than Internet Explorer
    and more often finishes downloading files in the order in which they were requested.
    Opera, on the other hand, touted as the fastest browser on earth, is considerably
    less sequential (with many files having two or three nearly identically pronounced
    spikes, suggesting that a set of requests is issued so rapidly that the completion
    sequence is almost arbitrary, and most heavily influenced by network jitter).
    Wget, a popular open-source web spider, is for comparison perfectly sequential
    (a pattern common for automated crawlers), uses a single connection, and loads
    all files in the same order.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异应该清晰可见，即使在历史上基于相同引擎的浏览器之间：Mozilla 和 Internet Explorer。所有客户端似乎都观察到了在主文档中引用文件的顺序，因此后续的峰值会缓慢地从左到右穿过各个段。然而，正如你所看到的，Mozilla
    通常比 Internet Explorer 更不急躁，并且更经常按照请求的顺序完成文件的下载。另一方面，被誉为地球上最快的浏览器 Opera，其顺序性要差得多（许多文件有两个或三个几乎同样明显的峰值，这表明一组请求被迅速发出，完成顺序几乎是任意的，并且主要受网络抖动的影响）。Wget，一个流行的开源网络爬虫，用于比较，顺序性完美（这是自动化爬虫的常见模式），使用单个连接，并按相同的顺序加载所有文件。
- en: Giving Pretty Pictures Meaning
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给出漂亮的图片含义
- en: Pictures and graphs are nice, but have little or no value for automated policy
    enforcement or abuse detection. To quantify observed patterns somehow, and to
    make fingerprinting a bit more realistic, I decided to introduce a simple metric
    that gives a segment a better score (in the range of 0 to 10) when only a single
    peak is present and gives a lower score when the distribution is more arbitrary.
    This could allow for creating a simple, ten-value fingerprint for a specific piece
    of software and then match observed activity against a set of signatures to determine
    the best fit.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 图片和图表很漂亮，但对于自动化策略执行或滥用检测几乎没有价值。为了以某种方式量化观察到的模式，并使指纹识别更加现实，我决定引入一个简单的指标，当只有一个峰值时，会给段一个更好的分数（在
    0 到 10 的范围内），而当分布更加任意时，会给一个较低的分数。这可以允许为特定的软件创建一个简单的十值指纹，然后匹配观察到的活动与一系列签名，以确定最佳匹配。
- en: 'To construct a metric that expresses a relative quality (linearity) *Q* of
    observed behavior at major segment *s*, I used the following formula (*f[n]* denotes
    the probability of file appearing at position *n* in fetch sequence, expressed
    in percentage values for convenience and to upset purists):'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个表示在主要段 *s* 上观察到的行为相对质量（线性度） *Q* 的指标，我使用了以下公式（*f[n]* 表示文件出现在获取序列中位置 *n*
    的概率，为了方便和打扰纯粹主义者，用百分比表示）：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1138104.png)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages1138104.png)'
- en: This equation, although scary at first sight, is actually straightforward. I
    wanted the formula to give preference to the situation when this particular file
    is most often loaded at a fixed position in a sequence (that is, one *f* value
    is near 100 percent, and remaining probabilities are close to 0 percent) over
    those when all positions are equally likely to occur (all *f* values at 10 percent).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程，虽然乍一看令人畏惧，但实际上非常直接。我希望公式能够优先考虑这种情况：在这个特定的文件在序列中固定位置加载的情况最为常见（也就是说，一个 *f*
    值接近 100%，其余概率接近 0%）而不是所有位置都同样可能发生的情况（所有 *f* 值均为 10%）。
- en: 'Because the sum of all elements of *f* is fixed (100 percent), the easiest
    way to achieve this is to use a sum of squares: for any sequence of nonzero numbers;
    a sum of squares of those numbers is always less than a square of the sum. The
    highest and lowest results are as follows:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *f* 的所有元素之和是固定的（100%），实现这一点最简单的方法是使用平方和：对于任何非零数字序列；这些数字的平方和总是小于总和的平方。最高和最低结果如下：
- en: '| 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² = 1,000 |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² + 10² = 1,000 |'
- en: '| 100² + 0² + 0² + 0² + 0² + 0² + 0² + 0² + 0² + 0² = 10,000 |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| 100² + 0² + 0² + 0² + 0² + 0² + 0² + 0² + 0² + 0² = 10,000 |'
- en: The remaining math, besides the main sum, is used merely to map results to a
    reasonable scale of 0 to 10 (when rounded).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要总和之外，剩余的数学计算仅用于将结果映射到合理的 0 到 10 的尺度（当四舍五入时）。
- en: The results of calculating this metric for each segment of observed traffic
    for each browser are superimposed on [Figure 14-1](ch14s05.html#behavioral_pattern_differences_for_popul
    "Figure 14-1. Behavioral pattern differences for popular web clients"), as a numeric
    value describing every segment of the graph. As expected, Wget scores perfectly
    for each segment. Scores for the other browsers confirm previous visual observations
    and make them more tangible. Although Internet Explorer and the Mozilla/Netscape
    engines appear to have roughly similar graphs, strong differences can be observed
    around load charts for items 4 through 6 and to a lesser degree across the entire
    fetch sequence. Opera clearly distances itself from the bunch, with consistently
    lower scores for each segment.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个浏览器每个观察到的流量段的此指标的结果叠加在[图14-1](ch14s05.html#behavioral_pattern_differences_for_popul
    "图14-1. 流行网络客户端的行为模式差异")上，作为一个描述图表每个部分的数值。正如预期的那样，Wget在每个部分都取得了完美的分数。其他浏览器的分数证实了之前的视觉观察，并使它们更加具体。尽管Internet
    Explorer和Mozilla/Netscape引擎的图表看起来大致相似，但在第4至6项的加载图表周围以及在整个获取序列中可以观察到明显的差异。Opera明显与其他浏览器拉开距离，每个部分的分数都持续较低。
- en: As a result, by applying a fairly trivial analytic tool, we ended up with a
    framework for devising a practical method to identify browsers and detect trickery
    in a statistically significant sample of user’s HTTP traffic. You can enhance
    the model by analyzing other auto-load elements such as scripts, HTML style sheets,
    image maps, frames, and other files that exhibit even greater browser-to-browser
    variance. The Santa might find it easier this year to prepare the naughty user
    list.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过应用一个相当简单的分析工具，我们最终制定了一个实用的方法框架，用于识别浏览器并在用户HTTP流量中检测到统计上有意义的欺骗行为。你可以通过分析其他自动加载元素，如脚本、HTML样式表、图像映射、框架和其他显示更大浏览器间差异的文件来增强模型。今年圣诞老人可能更容易准备出淘气的用户名单。
- en: Beyond the Engine . . .
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除此之外……
- en: I merely hope to show how easy it is to detect hidden characteristics of an
    unknown application by observing its behavior, without making any specific assumptions
    or dissecting the internals of such a program. The above exact numbers are likely
    not directly applicable to any website other than the one I used, and so you are
    encouraged to do your homework should you find a potential use for this technique.
    Once you profile a site or a set of sites, you can use the data to efficiently
    recognize systems based on their activity patterns over time.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我仅仅希望展示通过观察其行为，而不做任何具体假设或剖析程序内部结构，如何轻松地检测未知应用程序的隐藏特性。上述确切数字可能并不直接适用于我使用的网站以外的任何网站，因此如果你发现这项技术有潜在用途，请鼓励你自己做些研究。一旦你对某个网站或一组网站进行了分析，你可以使用这些数据来高效地识别基于其随时间活动模式的变化的系统。
- en: Needless to say, the method I’ve used here is a (perhaps overly) simplistic
    approach to behavioral analysis and is based on perhaps the most trivial of all
    possible scenarios; I provide it as encouragement and to tempt you to search for
    more. In advanced cases, you can readily use the process of rendering contents
    in frames, tables, and other visual containers or fetching and rendering special
    types of files to determine which browser is being used even without performing
    statistical matching—in various highly specific aspects of browser activity, differences
    become far more striking. A clever application of differential timing is also
    promising.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，我在这里使用的方法是一种（可能过于）简化的行为分析方法，基于所有可能场景中最简单的一种；我提供它作为鼓励，并诱使你寻找更多。在复杂情况下，你可以轻松地使用在框架、表格和其他视觉容器中渲染内容的过程，或者获取和渲染特殊类型的文件，以确定正在使用的浏览器，即使不进行统计分析——在浏览器活动的各种高度具体方面，差异变得更为明显。巧妙地应用差分时间也可能很有前景。
- en: 'And consider this: You can take more thought out forms of behavioral analysis
    a step further and deploy them not to tell one rendering engine from another,
    but to tell machines from humans or even identify single users. As discussed in
    [Chapter 8](ch08.html "Chapter 8. Us versus Them"), keyboard use patterns are
    often so unique for an individual that it is possible to use them for biometrics.
    Similarly, research suggests we can use the ways users click links, make choices,
    read information, and so on to indicate who or what is behind a set of requests.^([[104](apb.html#ftn.CHP-14-BIB-8)])
    Although now closer to scientific speculation than fact, this is a wonderful field
    to explore and play with.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点：你可以将更深入的行为分析形式推进一步，并部署它们不是为了区分不同的渲染引擎，而是为了区分机器和人类，甚至识别单个用户。如第[8章](ch08.html
    "第8章。我们与他们")所述，键盘使用模式对个人来说通常是如此独特，以至于可以使用它们进行生物识别。同样，研究表明，我们可以使用用户点击链接、做出选择、阅读信息等方式来表明一组请求背后是谁或是什么。[^([104](apb.html#ftn.CHP-14-BIB-8)))
    虽然现在这更接近科学推测而不是事实，但这是一个值得探索和玩耍的奇妙领域。
- en: . . . And Beyond Identification
  id: totrans-757
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: . . . 以及超越识别
- en: Browser activity and behavioral analysis applications go beyond the detection
    of browser software—in fact, some enter the domain of user privacy and anonymity.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器活动和行为分析应用不仅限于检测浏览器软件——实际上，一些应用已经进入用户隐私和匿名性的领域。
- en: An interesting piece of research published in 2000 by Edward Felten and Michael
    Schneider^([[105](apb.html#ftn.CHP-14-BIB-9)]) makes a fascinating contribution
    to the possible applications for the technique, an ability that is closely allied
    with caching mechanisms deployed in today’s engines, bringing us to the point
    where all the elements discussed so far finally meet.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年，Edward Felten和Michael Schneider发表的一项有趣的研究^[([105](apb.html#ftn.CHP-14-BIB-9)))
    对该技术的潜在应用做出了令人着迷的贡献，这种能力与今天引擎中部署的缓存机制密切相关，将我们带到所有之前讨论的元素最终汇聚在一起的时刻。
- en: The basic premise of their research is that, by inserting a reference to a file
    on a particular site and then measuring the delay the browser encounters while
    downloading it, it is possible to tell whether the user had visited a particular
    site in recent days. Simple enough.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 他们研究的基本前提是，通过在特定网站上插入对文件的引用，然后测量浏览器下载它时遇到的延迟，可以判断用户是否在最近几天访问过该网站。这很简单。
- en: I’ll spare you a lengthy excursion into the world of theory, predictions, and
    speculations (just this once) and instead propose a nearly real-world example.
    Assume that I am running [www.rogue-severs.com](http://www.rogue-severs.com).
    I’ve decided that my main page will, for some reason, refer to a picture (such
    as a front-page logo) taken from [www.kinky-kittens.com](http://www.kinky-kittens.com);
    I make the visual element difficult to find or scale it down so that it is not
    visible, but it will be still loaded by a browser.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 我将省略对理论、预测和推测的漫长探索（就这一次），而是提出一个接近现实世界的例子。假设我正在运行[www.rogue-severs.com](http://www.rogue-severs.com)。我决定，出于某种原因，我的主页将引用一张图片（例如首页标志），这张图片来自[www.kinky-kittens.com](http://www.kinky-kittens.com)；我将这个视觉元素设置得难以找到或缩小到无法看到，但它仍然会被浏览器加载。
- en: An unsuspecting user visits my site. If they have never been to [www.kinky-kittens.com](http://www.kinky-kittens.com),
    it takes them a while to download the image I have referenced. If they are a frequent
    visitor, however, the image is already present in their cache and is fetched almost
    instantly.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未察觉的用户访问我的网站。如果他们从未访问过[www.kinky-kittens.com](http://www.kinky-kittens.com)，那么他们需要一段时间才能下载我引用的图片。然而，如果他们是常客，那么图片已经存在于他们的缓存中，几乎可以立即获取。
- en: Because the reference to the [www.kinky-kittens.com](http://www.kinky-kittens.com)
    resource is preceded and followed by requests for other visual elements I happen
    to host on my site, by deploying clever timing heuristics, it is possible to reliably
    measure whether the entire logo had been fetched or whether it was already in
    the cache. All this suffices to determine whether a newcomer to my page is indeed
    a frequent visitor to a specific website (or a particular section of a website)
    and effectively brutally invades their privacy. Although the scenario is not likely
    to be used for widely deployed routine espionage (primarily because clear evidence
    is left behind and might be noticed by the operator of the server on whose users
    we desire to snoop), targeted attacks might be quite effective.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对[www.kinky-kittens.com](http://www.kinky-kittens.com)资源的引用前后都跟着对我的网站上其他视觉元素的需求，通过部署巧妙的时机启发式算法，可以可靠地测量整个标志是否已被获取，或者它是否已经在缓存中。所有这些足以确定访问我页面的新来者是否确实是某个特定网站（或网站的一个特定部分）的常客，并且有效地粗暴地侵犯了他们的隐私。尽管这种场景不太可能被用于广泛部署的常规间谍活动（主要是因为留下了明显的证据，可能会被我们想要窥探的服务器运营商注意到），但针对性攻击可能非常有效。
- en: In the end, all pieces of the puzzle fit together, perhaps loosely, but still
    fit together. Users, programs, and habits can all be easily exposed through a
    careful abuse of modern features of a popular Internet protocol. Something not
    necessarily always comforting to the valued visitors of [www.kinky-kittens.com](http://www.kinky-kittens.com).
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有的拼图碎片都拼在了一起，也许不是很紧密，但仍然拼在了一起。用户、程序和习惯都可以通过仔细滥用流行的互联网协议的现代功能轻易地暴露出来。这对[www.kinky-kittens.com](http://www.kinky-kittens.com)的宝贵访客来说，可能并不总是令人安慰的。
- en: Prevention
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防
- en: Fully anonymizing one’s web-browsing experience appears to be a battle already
    lost. Although some practices for improving the privacy and anonymity of online
    web users are commonly accepted, these features can be easily circumvented by
    a malicious website.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 完全匿名化一个人的网络浏览体验似乎已经是一场已经输掉的战斗。尽管一些提高在线网络用户隐私和匿名性的做法被普遍接受，但这些功能可以很容易地被恶意网站规避。
- en: The problem is, unfortunately, too serious to dismiss. It is one thing to have
    an entity we have decided to trust (such as an ISP) be aware of our activity,
    but an entirely different issue when parties we’d rather not deal with routinely
    gather sensitive profiling information and probably just as routinely resell it
    to others as a part of their business model. This is enough to concern even those
    who do not wear a tinfoil hat and aluminum underwear on a daily basis.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，这个问题太严重了，不能被忽视。当我们决定信任某个实体（比如ISP）时，它知道我们的活动是另一回事，但当那些我们不愿意经常打交道的一方收集敏感的个人信息，并且可能像他们的商业模式一样，同样频繁地将其转售给他人时，这完全是一个不同的问题。即使对于那些每天不戴锡箔帽和铝制内衣的人来说，这也足以引起他们的关注。
- en: On the other hand, the relative difficulty of remaining fully anonymous or appearing
    completely harmless is important in environments where HTTP traffic must be allowed
    and yet where users should be protected and supervised without violating their
    privacy beyond bare necessity. In corporate networks, the ability to track offending
    systems without the need to manually inspect data is truly invaluable and appreciated
    both by users and system administrators alike.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在必须允许HTTP流量，同时用户应得到保护并受到监督，而不违反他们隐私的基本必要性的环境中，保持完全匿名或看起来完全无害的相对难度很重要。在企业网络中，能够在不手动检查数据的情况下跟踪违规系统，这对用户和系统管理员来说都真正宝贵且受到欢迎。
- en: Food for Thought
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考的食物
- en: No single component of HTTP is ill conceived, broken, or unwarranted. Yet, when
    we put it all together, many security and privacy features seem to cancel out,
    and the user is left quite exposed to eavesdroppers running rampant. Sadly, we
    can do little without starting over from scratch, and there is no guarantee that
    the results would work as well or provide even as much privacy as HTTP, HTML,
    and WWW clients do now.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的任何一个组成部分都没有设计不当、损坏或不合理。然而，当我们把它们放在一起时，许多安全和隐私功能似乎都相互抵消了，用户被暴露在肆无忌惮的窃听者面前。遗憾的是，我们无法在不从头开始的情况下做些什么，而且无法保证结果会像HTTP、HTML和WWW客户端现在提供的那样好，甚至提供更多的隐私。
- en: Chapter 15. The Benefits of Being a Victim
  id: totrans-771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章. 成为受害者的好处
- en: '*In which we conclude that approaching life with due optimism may help us track
    down the attacker*'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们得出结论，以适当的乐观态度生活可能有助于我们追踪到攻击者*'
- en: —
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: I have discussed a variety of problems that can have a significant cumulative
    impact on all daily communications, risks that we are not always comfortable with.
    You have seen how others can exploit the network to steal information or to get
    more than you expect or would allow them to, as well as how to use these techniques
    to gather more information about your enterprise or home network, and attackers
    that target it.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我讨论了各种可能对日常通信产生重大累积影响的问题，这些问题我们并不总是感到舒适。你已经看到其他人如何利用网络窃取信息，或者获取比你预期或允许的更多的信息，以及如何使用这些技术来收集更多关于你的企业或家庭网络的信息，以及针对这些网络进行攻击的攻击者。
- en: I hope I have offered both useful insight into how problems like these are born
    and how to avoid them whenever possible. I’ve tried to show that security and
    privacy implications are simply a part of every activity and that they cannot
    be fully eliminated simply by making the correct design decisions, installing
    the right software, or establishing and enforcing the proper policies. Information
    disclosure simply cannot be fully suppressed, and our only hope is to have enough
    information and knowledge about potential leak or attack scenarios to mitigate
    the most significant ones as much as possible in a particular application.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我已经提供了关于这类问题产生的原因以及如何尽可能避免它们的见解。我试图表明，安全和隐私的影响仅仅是每个活动的组成部分，而且仅仅通过做出正确的设计决策、安装正确的软件或建立和执行适当的政策是无法完全消除的。信息泄露根本无法完全抑制，我们唯一的希望是拥有足够的信息和知识关于潜在的泄露或攻击场景，以便在特定应用中尽可能减轻最严重的影响。
- en: This, the third part of the book, has focused on wide area networking and the
    threats that lurk there. Although this is the longest part and is only now about
    to conclude, it is the furthest from offering a complete view of all the issues
    that can arise in an open network. In fact, it would be quite difficult and largely
    pointless to discuss all variants of problems; thus I’ve chosen to cover only
    the most complex, challenging, or fascinating aspects of host-to-host communications.
    I’ve focused on discovering attack scenarios on different protocol layers and
    different abstraction levels, instead of enumerating concepts and attack vectors
    that rehash old ideas and add nothing new to the subject. I hope that the information
    provided thus far will help and encourage you to find other incarnations of these
    issues in other areas of networking and computing—and perhaps even beyond.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第三部分，主要关注广域网及其潜在威胁。尽管这部分内容最长，现在也即将结束，但它离提供一个开放网络中可能出现的所有问题的全面视角还相去甚远。实际上，讨论所有问题的变体将非常困难，而且很大程度上是徒劳的；因此，我选择只涵盖主机之间通信中最复杂、最具挑战性或最迷人的方面。我专注于发现不同协议层和不同抽象级别上的攻击场景，而不是列举那些重复旧想法且对主题没有新贡献的概念和攻击向量。我希望到目前为止提供的信息能帮助你并鼓励你在网络和计算的其他领域找到这些问题的其他表现形式——也许甚至更远。
- en: 'We make a significant paradigm shift in the next part of the book as we explore
    how careful observation of the network as a whole, rather than as single systems,
    can be used to defend ourselves or to attack others. But before we do, let’s look
    at some other possibilities in one of the more unusual areas of network surveillance:
    passive counterintelligence—that is, learning more about the attacker or their
    aims by analyzing their actions. The data gathered this way can provide a powerful
    set of investigative leads that make it easy to identify an attacker’s intentions,
    toolset, or even the attacker themself. The task of building an attacker profile,
    attempting to read their mind, and perhaps even playing a game of deception with
    them is often a thrilling experience in and of itself.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分书中，我们将进行一次重大的范式转变，探讨如何通过仔细观察整个网络（而不是单个系统）来保护自己或攻击他人。但在我们这样做之前，让我们看看网络监控中一个较为不寻常领域的其他可能性：被动反情报——即通过分析他们的行为来了解更多关于攻击者或他们的目标。以这种方式收集的数据可以提供一套强大的调查线索，使识别攻击者的意图、工具集甚至攻击者本人变得容易。构建攻击者档案、试图解读他们的想法，甚至与他们玩一场欺骗游戏，通常本身就是一种令人兴奋的经历。
- en: Defining Attacker Metrics
  id: totrans-778
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义攻击者指标
- en: As expected, you can acquire a good deal of information about a remote rogue
    party by merely applying some of the common TCP/IP traffic metrics discussed previously—such
    as passive operating system fingerprinting—to the observed traffic. You can, for
    example, identify the specific tool used to perform a port scan.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，你只需应用一些之前讨论过的常见 TCP/IP 流量指标——例如被动操作系统指纹识别——到观察到的流量中，就可以从远程恶意实体中获得大量信息。例如，你可以识别用于端口扫描的具体工具。
- en: Similarly, we can also apply behavioral analysis to characteristics of the attacker’s
    behavior such as inter-request delays and request ordering (for example, the order
    in which ports are scanned and how fast). We can use behavioral analysis with
    some success to track programs or, during a manually performed break-in or unauthorized
    assessment attempts, even to determine the individual characteristics of an attacker
    (such as their computer proficiency).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以将行为分析应用于攻击者的行为特征，例如请求间的延迟和请求顺序（例如，端口扫描的顺序和速度）。我们可以使用行为分析在一定程度上追踪程序，或者在手动进行的入侵或未经授权的评估尝试中，甚至可以确定攻击者的个人特征（例如他们的计算机技能）。
- en: One particularly interesting method we can deploy to identify the tool the attacker
    used to scan our network relies on applying one of the methods discussed in [Chapter 9](ch09.html
    "Chapter 9. Foreign Accent")—port sequence fingerprinting—to a wholly new task;
    this is based on the observation that a majority of scanners in use today either
    scan networks and systems from lowest to highest ports or addresses (sequentially)
    or randomize the order in which resources are accessed. The latter approach is
    more often used and is regarded as the better because it can balance loads and
    make scanning detection slightly more difficult. But, in a surprising twist, the
    use of randomness can fire back at the attacker in a couple of bizarre ways.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以部署的一个特别有趣的方法来识别攻击者用于扫描我们网络的工具，是应用第 9 章中讨论的方法之一——端口序列指纹识别——到一个全新的任务上；这是基于观察，目前大多数扫描器要么按顺序从最低端口或地址扫描网络和系统，要么随机化访问资源的顺序。后者更常被使用，并且被认为更好，因为它可以平衡负载并使扫描检测稍微困难一些。但出人意料的是，随机性的使用可能会以几种奇怪的方式对攻击者产生反作用。
- en: 'The problem arises because their authors do not consider network scanning tools
    mission-critical applications with high-security requirements. The most common
    (and easiest) way to implement a pseudorandom number generator in programs that
    do not require cryptographically secure output is to invoke standard system or
    built-in language facilities. The ISO standard^([[106](apb.html#ftn.CHP-15-BIB-1)])
    for the most prevalent programming language in the world, C, suggests that a simple
    linear congruent algorithm be used to implement a standard C library pseudorandom
    number generator (discussed in [Chapter 1](ch01.html "Chapter 1. I Can Hear You
    Typing")). The recipe for building and using the generator devised by the standard
    is as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，它们的作者没有将网络扫描工具视为具有高安全要求的任务关键型应用。在不要求加密安全输出的程序中实现伪随机数生成器最常见（也是最容易）的方法是调用标准系统或内置语言功能。世界上使用最广泛的编程语言
    C 的 ISO 标准^([[106](apb.html#ftn.CHP-15-BIB-1)]) 建议使用简单的线性同余算法来实现标准 C 库伪随机数生成器（在第
    1 章中讨论）。标准提出的构建和使用生成器的方案如下：
- en: The generator should be seeded with an initial 32-bit value (S[0]) by invoking
    a standard library function `srand()`. If the generator is not seeded, it will
    begin with a fixed default seed and will produce identical result sequences in
    all cases.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器应该通过调用标准库函数 `srand()` 使用一个初始的 32 位值（S[0]）来初始化。如果生成器没有被初始化，它将使用一个固定的默认种子，并在所有情况下产生相同的输出序列。
- en: 'In each call to `rand()`, the main function that is repeatedly invoked to obtain
    subsequent pseudorandom numbers for use in user applications, the seed S is recomputed
    as follows: S[t+1] = S[t] * 1103515245 + 12345\. The result is truncated to 32
    bits (modulo 4294967296).'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次调用 `rand()` 时，主函数会反复调用以获取用于用户应用程序的后续伪随机数，种子 S 会按照以下方式重新计算：S[t+1] = S[t] *
    1103515245 + 12345。结果被截断到 32 位（模 4294967296）。
- en: The return value for each `rand()` call is the more significant word of S[t+1],
    modulo 32768\. In a 32-bit variant, one of the algorithms more commonly used on
    today’s computers, the procedure in this and the previous step is repeated several
    times to calculate subsequent bit portions of the result value.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `rand()` 调用的返回值是 S[t+1] 的更重要的字，模32768。在32位变体中，这是今天计算机上更常用的算法之一，这个步骤和前一个步骤会重复多次，以计算结果值的后续位部分。
- en: All linear congruent generators, including the one described here, are susceptible
    to the general cryptanalysis methodology proposed by H. Krawczyk in the ’90s,
    as mentioned in [Chapter 1](ch01.html "Chapter 1. I Can Hear You Typing"). Based
    on the observation of a couple of subsequent (or otherwise ordered) outputs, it
    is possible to reconstruct the internal state of the generator and thus predict
    all its previous and future outputs.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线性同余生成器，包括这里描述的生成器，都容易受到20世纪90年代H. Krawczyk提出的通用密码分析方法的影响，如[第1章](ch01.html
    "第1章。我能听到你在打字")中提到的。基于对几个后续（或有序）输出的观察，有可能重建生成器的内部状态，从而预测其所有先前和未来的输出。
- en: 'Naturally, the immediate implication of this possibility—the victim’s ability
    to determine, based on a knowledge of prior attempts, in what order the attacker
    will try to target other resources on the machine or network—is not particularly
    exciting or valuable itself. Still, this possibility has two important consequences
    in the context of network probe attempts:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这种可能性的直接含义——受害者根据对先前尝试的了解，确定攻击者将按什么顺序尝试攻击机器或网络上的其他资源——本身并不特别令人兴奋或有价值。然而，在网络探测尝试的背景下，这种可能性有两个重要的后果：
- en: We might be able to determine *S*[0]. If we know or can estimate when the generator
    began its work (or, alternatively, which general properties the initial seed should
    exhibit), it is possible to reconstruct the value used to initialize the generator.
    Because S[0] is the only input to the algorithm, it must produce identical behavior
    for identical seed values—and so, we can trace the seed by observing PRNG output.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能能够确定 *S*[0]。如果我们知道或可以估计生成器开始工作的时间（或者，作为替代，初始种子应显示的一般属性），就有可能重建用于初始化生成器的值。因为S[0]是算法的唯一输入，它必须对相同的种子值产生相同的行为——因此，我们可以通过观察PRNG输出来追踪种子。
- en: We might be able to determine *t* increments. Once we reconstruct the generator
    state, it is possible to determine how many random values were requested by the
    scanner by calling `rand()` in between two calls that the scanner used to obtain
    values (port numbers or host addresses) for packets the observer captured.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能能够确定 *t* 增量。一旦我们重建了生成器状态，就有可能通过在扫描器用于获取值（端口号或主机地址）的两个调用之间调用 `rand()` 来确定扫描器请求了多少随机值。
- en: The importance of the first consequence of this design, our ability to reconstruct
    the value used to initialize the generator, might be not immediately apparent.
    But we have another bit of the puzzle to consider. One common way to initialize
    a random number generator is to use a handy 32-bit value that changes often enough
    not to risk identical PRNG behavior too frequently. The system time counter is
    often used for this purpose, and it is sometimes combined with another small number,
    such as the current process ID (PID), to decrease the likelihood that two programs
    run in a short time interval will produce similar results.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的第一种后果的重要性，即我们重建用于初始化生成器的值的能力，可能并不立即明显。但我们还有另一个谜团需要考虑。初始化随机数生成器的一种常见方法是用一个方便的32位值，这个值变化足够频繁，不会太频繁地导致相同的PRNG行为。系统时间计数器常用于此目的，有时还会与另一个小数字结合使用，例如当前进程ID（PID），以降低两个在短时间内运行的程序产生相似结果的可能性。
- en: By applying this knowledge to the calculated *S*[0], the probe victim can discover
    the attacker’s system time (GMT or local, depending on the operating system settings
    and scanner type). Knowledge of the system’s local time can give the observer
    a hint about the attacker’s origin and identity in a most trivial way. If they
    are trying to confuse us by spoofing packets from various sources, we can get
    lucky ruling out those perceived sources for which S[0] would indicate a time
    zone not matching the geographical region to which the source address belongs.
    For example, if by comparing the attacker’s estimated system time with GMT we
    determine that attacker’s time is five hours behind Greenwich Mean, we might conclude
    that they are likely on the east coast of the United States and not in China.
    Thus, by comparing our best guess of the time zone with records for various IP
    address blocks, we can tell that, of all observed “decoy” scan sources, the attacker’s
    true identity is more likely to be behind packets originating from a Boston ISP
    than ones from an ISP located in Beijing.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此知识应用于计算出的 *S*[0]，探测受害者可以揭示攻击者的系统时间（GMT或本地时间，取决于操作系统设置和扫描器类型）。了解系统的本地时间可以以最简单的方式给观察者提供关于攻击者来源和身份的线索。如果他们试图通过伪造来自各种来源的数据包来迷惑我们，我们可以通过排除那些S[0]显示的时间区域与源地址所属的地理区域不匹配的感知来源来获得幸运。例如，如果我们通过比较攻击者的估计系统时间与GMT，确定攻击者的时间比格林威治标准时间慢五小时，我们可能会得出结论，他们很可能位于美国东海岸而不是中国。因此，通过将我们对时区的最佳猜测与各种IP地址块的记录进行比较，我们可以判断，在所有观察到的“诱饵”扫描源中，攻击者的真实身份更有可能隐藏在来自波士顿ISP的数据包后面，而不是来自北京ISP的数据包后面。
- en: Additionally, once we know the attacker’s local time, we can track them by measuring
    the distance of their system clock from the real time (and, in the long run, how
    fast it drifts). Because computer clocks are usually not particularly accurate
    and tend to drift quite a bit when they are not regularly synchronized with an
    external source (as much as several minutes a day in some cases), this might be
    a good way to correlate attacks carried out by the same person. Different machines
    are likely to be systematically off by a different amount of time that would be
    changing at a distinctive ratio.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦我们知道攻击者的本地时间，我们可以通过测量他们的系统时钟与真实时间的距离（以及长期来看其漂移速度）来追踪他们。由于计算机时钟通常不太准确，并且在不定期与外部源同步时（在某些情况下，每天可能漂移几分钟），这可能是一种很好的方法来关联同一人进行的攻击。不同的机器可能系统地偏离不同的时间量，这些时间量会以独特的比率变化。
- en: Finally, when the PID is used as a part of the initialization seed along with
    system time, and the attacker’s system time is known to be within a certain range,
    the PID can be used to determine the approximate system uptime or the number of
    tasks executed between two scans. Because every new process on a machine is assigned
    a higher PID number, this dependency is rather straightforward.^([[32](#ftn.CHP-15-FN-1)])
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当PID作为初始化种子的一部分与系统时间一起使用，并且已知攻击者的系统时间在某个范围内时，PID可以用来确定大约的系统运行时间或两次扫描之间的任务执行数量。因为机器上的每个新进程都被分配一个更高的PID号，这种依赖性相当直接。[^([[32](#ftn.CHP-15-FN-1))]]
- en: By reconstructing the PRNG state, we can also see how many random numbers were
    generated between the generation of two packets received by the recipient. When
    only one system is being scanned, there should be no gaps whatsoever or only marginal
    discrepancies due to network problems. However, when more than one system is being
    scanned, these gaps (caused by packets that are being sent to different targets)
    can be easily detected. By detecting them we can determine how many systems are
    being targeted simultaneously.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重建PRNG状态，我们还可以看到在接收方接收到的两个数据包生成之间生成了多少随机数。当只有一个系统正在被扫描时，应该没有任何间隙，或者只有由于网络问题引起的微小差异。然而，当多个系统正在被扫描时，这些间隙（由发送到不同目标的数据包引起）可以很容易地被检测到。通过检测它们，我们可以确定同时被针对的系统数量。
- en: 'Furthermore, when the scanner software generates fake decoy packets that appear
    to come from random hosts, it is possible to eliminate spoofed addresses—ones
    that were made up using PRNG (and thus match its possible output) and determine
    which one does not match and hence must be real—pointing conclusively to the real
    perpetrator of an attack. For example, if our reconstructed PRNG data shows traffic
    coming from addresses such as:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当扫描软件生成看似来自随机主机的虚假诱饵数据包时，可以消除伪造的地址——那些使用伪随机数生成器（PRNG）生成的地址（因此匹配其可能的输出）并确定哪个不匹配，因此必须是真实的——从而明确指向攻击的真正肇事者。例如，如果我们的重建
    PRNG 数据显示来自以下地址的流量：
- en: '| 198.187.190.55 (decimal representation: 3334192695) |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| 198.187.190.55 (十进制表示：3334192695) |'
- en: '| 195.117.3.59 (decimal representation: 3279225659) |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '| 195.117.3.59 (十进制表示：3279225659) |'
- en: '| 207.46.245.214 (decimal representation: 3475961302) |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 207.46.245.214 (十进制表示：3475961302) |'
- en: we can determine that both 3334192695 and 3475961302 were one of the first outputs
    we would see of a generator seeded with S[0]; whereas 3279225659 does not seem
    to be any of the first outputs of a reconstructed PRNG and hence is likely a real
    address.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确定，3334192695 和 3475961302 都是使用 S[0] 作为种子生成的生成器的最初输出之一；而 3279225659 似乎不是任何重建的伪随机数生成器的最初输出，因此很可能是真实的地址。
- en: We can use all this information to determine an attacker’s intentions and the
    software they are using. We can even use it to track the system they are working
    on, correlate it with other data to determine their true identity and geographical
    location, and sometimes even determine how they are using their computer as the
    scan progresses.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用所有这些信息来确定攻击者的意图和他们使用的软件。我们甚至可以使用它来追踪他们正在工作的系统，将其与其他数据关联起来以确定他们的真实身份和地理位置，有时甚至可以确定他们随着扫描的进行是如何使用他们的计算机的。
- en: Note
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NMAP, in response to the uptime and scan history disclosure problems discussed
    above, attempts to use secure system RNG facilities (such as /dev/random, as discussed
    in [Chapter 1](ch01.html "Chapter 1. I Can Hear You Typing")) to generate random
    numbers instead of relying on standard C library tools. However, this method is
    not available on many operating systems (such as Windows), and other scanners
    have not taken similar steps to defend an attacker.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: NMAP 为了应对上述的运行时间和扫描历史披露问题，试图使用安全的系统随机数生成器设施（如 /dev/random，如第 1 章所述[第 1 章](ch01.html
    "第 1 章。我能听到你在打字"))来生成随机数，而不是依赖于标准的 C 库工具。然而，这种方法在许多操作系统（如 Windows）上不可用，其他扫描器也没有采取类似的步骤来防御攻击者。
- en: '* * *'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[32](#CHP-15-FN-1)]) Although some systems offer optional PID randomization
    for the purpose of making certain unrelated types of local attacks more difficult.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-15-FN-1)]) 尽管一些系统提供可选的 PID 随机化，目的是使某些无关类型的本地攻击更加困难。
- en: 'Protecting Yourself: Observing Observations'
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护自己：观察观察
- en: The Internet has become a giant battlefield in the last ten years. Newly connected
    machines are being instantly flooded with automated attack probes, worms, and
    other types of information that stress their security. The traditional, and now
    fairly trendy, intrusion detection and prevention movement aims to find out about
    and stop attacks, by warning the administrator when pre-attack probes are being
    carried out using specially crafted traffic analysis tools. In heterogeneous or
    simply sufficiently complex environments, these often produce more noise and false
    positives than one can handle.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年中，互联网已经成为一个巨大的战场。新连接的机器立即被自动攻击探测、蠕虫和其他类型的信息所淹没，这些信息对它们的网络安全造成压力。传统的、现在相当流行的入侵检测和预防运动旨在通过警告管理员正在使用特别定制的流量分析工具进行预攻击探测来发现和阻止攻击。在异构或简单足够复杂的环境中，这些通常会产生比一个人能够处理的更多噪音和假阳性。
- en: In some cases, however, the ability to observe attacks and the responses they
    trigger is a great way for the administrator to learn about network problems and
    attacks as they occur (even though those incidents themselves are hardly noteworthy,
    usually). For one thing, in some networks, active discovery and asset scanning
    to ensure policy compliance and system configuration is difficult to initiate
    or too troublesome to perform, whether due to policy regulations, slow turnaround
    times, rarely open network maintenance windows, and so forth. In such an environment,
    the ability to peek and determine what rogues are seeing may be an invaluable
    substitute for locally initiated active reconnaissance.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，观察攻击及其引发的响应能力是管理员了解网络问题和攻击发生情况的一种很好的方式（尽管这些事件本身通常并不引人注目）。首先，在某些网络中，由于政策规定、缓慢的周转时间、很少开放的维护窗口等原因，主动发现和资产扫描以确保政策合规和系统配置难以启动或执行起来过于麻烦。在这样的环境中，能够窥视并确定流氓看到的内容可能是一种非常有价值的替代方案，以进行本地启动的主动侦察。
- en: Too, periodic active discovery might not be fast enough to respond to certain
    threats; thus, the ability to learn that something has suddenly gone wrong by
    merely observing the results others get could be quite valuable. And, of course,
    this is a two-edged sword—a hacker who has compromised or plans to compromise
    a network, but wants to keep a low profile and plan their steps in advance, can
    watch traffic generated by other discovery attempts in order to build their knowledge
    about a particular system.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，定期的主动发现可能不足以应对某些威胁；因此，仅通过观察他人得到的结果来了解某事突然出错的能力可能非常有价值。当然，这是一把双刃剑——一个已经破坏或计划破坏网络、但希望保持低调并提前规划步骤的黑客，可以观察其他发现尝试产生的流量，以构建他们对特定系统的知识。
- en: The task of stealing knowledge acquired by an attacker appears to be simple
    only in theory; the challenge of correlating and processing results, particularly
    when analyzing large environments or when based only on partial information from
    separate attack attempts from different locations, is not trivial. Some tools
    to facilitate network and system mapping using “passive scanning” are nevertheless
    slowly showing up on the horizon—with Preston Wood’s DISCO^([[107](apb.html#ftn.CHP-15-BIB-2)])
    being a prime example.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，窃取攻击者获得的知识似乎很简单；然而，关联和处理结果，尤其是在分析大型环境或仅基于来自不同地点的单独攻击尝试的零星信息时，并非易事。尽管如此，一些用于通过“被动扫描”促进网络和系统映射的工具正逐渐出现在地平线上——Preston
    Wood的DISCO^([[107](apb.html#ftn.CHP-15-BIB-2)])就是一个典型的例子。
- en: Food for Thought
  id: totrans-810
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考的食物
- en: I find it strange that the techniques described in this chapter are often not
    supported by comprehensive research, published white papers, or readily available
    tools. With the attack tracking craze initiated by Lance Spitzner’s honeypot research,
    and only fueled by products such as intrusion detection systems, one would expect
    to see fewer efforts to identify attacks (which are usually not particularly exciting
    themselves and which typically use well-documented vectors and flaws) and more
    attempts to determine the intent and origin of an attack and to correlate events
    that are meaningless alone, but that can signal a problem when combined.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现奇怪的是，本章中描述的技术通常没有得到全面的研究、发表的白色纸张或易于获取的工具的支持。随着Lance Spitzner的蜜罐研究引发的攻击跟踪热潮，以及入侵检测系统等产品的推动，人们本应看到更少的努力去识别攻击（这些攻击通常并不特别引人注目，并且通常使用经过良好记录的向量和方法），而更多的努力去确定攻击的意图和来源，以及关联那些单独看来没有意义但结合在一起可以表明问题的活动。
- en: I can only shed some light on the tip of an iceberg, but needless to say, this
    may be one of the more exciting areas to research and contribute to.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能对冰山一角进行一些探讨，但不用说，这可能是研究和贡献的更具吸引力的领域之一。
- en: '*And now, for something completely different. . . .*'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，让我们来点完全不同的内容……*'
