["```\nghci> :t 'a'\n'a' :: Char\nghci> :t True\nTrue :: Bool\nghci> :t \"HELLO!\"\n\"HELLO!\" :: [Char]\nghci> :t (True, 'a')\n(True, 'a') :: (Bool, Char)\nghci> :t 4 == 5\n4 == 5 :: Bool\n```", "```\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n```", "```\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n```", "```\n    factorial :: Integer -> Integer\n    factorial n = product [1..n]\n    ```", "```\n    ghci> factorial 50\n    30414093201713378043612608166064768844377641568960512000000000000\n    ```", "```\n    circumference :: Float -> Float\n    circumference r = 2 * pi * r\n    ```", "```\n    ghci> circumference 4.0\n    25.132742\n    ```", "```\n    circumference' :: Double -> Double\n    circumference' r = 2 * pi * r\n    ```", "```\n    ghci> circumference' 4.0\n    25.132741228718345\n    ```", "```\nghci> :t head\nhead :: [a] -> a\n```", "```\nghci> :t fst\nfst :: (a, b) -> a\n```", "```\nghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n```", "```\nghci> 5 == 5\nTrue\nghci> 5 /= 5\nFalse\nghci> 'a' == 'a'\nTrue\nghci> \"Ho Ho\" == \"Ho Ho\"\nTrue\nghci> 3.432 == 3.432\nTrue\n```", "```\nghci> :t (>)\n(>) :: (Ord a) => a -> a -> Bool\n```", "```\nghci> \"Abrakadabra\" < \"Zebra\"\nTrue\nghci> \"Abrakadabra\" `compare` \"Zebra\"\nLT\nghci> 5 >= 2\nTrue\nghci> 5 `compare` 3\nGT\nghci> 'b' > 'a'\nTrue\n```", "```\nghci> show 3\n\"3\"\nghci> show 5.334\n\"5.334\"\nghci> show True\n\"True\"\n```", "```\nghci> read \"True\" || False\nTrue\nghci> read \"8.2\" + 3.8\n12.0\nghci> read \"5\" - 2\n3\nghci> read \"[1,2,3,4]\" ++ [3]\n[1,2,3,4,3]\n```", "```\nghci> read \"4\"\n<interactive>:1:0:\n    Ambiguous type variable 'a' in the constraint:\n      'Read a' arising from a use of 'read' at <interactive>:1:0-7\n    Probable fix: add a type signature that fixes these type variable(s)\n```", "```\nghci> :t read\nread :: (Read a) => String -> a\n```", "```\nghci> read \"5\" :: Int\n5\nghci> read \"5\" :: Float\n5.0\nghci> (read \"5\" :: Float) * 4\n20.0\nghci> read \"[1,2,3,4]\" :: [Int]\n[1,2,3,4]\nghci> read \"(3, 'a')\" :: (Int, Char)\n(3, 'a')\n```", "```\nghci> [read \"True\", False, True, False]\n[True, False, True, False]\n```", "```\nghci> ['a'..'e']\n\"abcde\"\nghci> [LT .. GT]\n[LT,EQ,GT]\nghci> [3 .. 5]\n[3,4,5]\nghci> succ 'B'\n'C'\n```", "```\nghci> minBound :: Int\n-2147483648\nghci> maxBound :: Char\n'\\1114111'\nghci> maxBound :: Bool\nTrue\nghci> minBound :: Bool\nFalse\n```", "```\nghci> maxBound :: (Bool, Int, Char)\n(True,2147483647,'\\1114111')\n```", "```\nghci> :t 20\n20 :: (Num t) => t\n```", "```\nghci> 20 :: Int\n20\nghci> 20 :: Integer\n20\nghci> 20 :: Float\n20.0\nghci> 20 :: Double\n20.0\n```", "```\nghci> :t (*)\n(*) :: (Num a) => a -> a -> a\n```", "```\nfromIntegral :: (Num b, Integral a) => a -> b\n```", "```\nlength :: [a] -> Int\n```", "```\nghci> fromIntegral (length [1,2,3,4]) + 3.2\n7.2\n```"]