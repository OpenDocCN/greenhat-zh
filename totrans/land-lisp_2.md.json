["```\n> `(if '()`\n      `'i-am-true`\n      `'i-am-false)`\n\nI-AM-FALSE\n\n> `(if '(1)`\n      `'i-am-true`\n      `'i-am-false)`\n\nI-AM-TRUE\n```", "```\n> `(defun my-length (list)`\n     `(if list`\n         `(1+ (my-length (cdr list)))`\n         `0))`\n\n> `(my-length '(list with four symbols))`\n\n4\n```", "```\n (eq '() nil)  ==> T\n (eq '() ())   ==> T\n (eq '() 'nil) ==> T\n```", "```\n> `(if (= (+ 1 2) 3)`\n      `'yup`\n      `'nope)`\n\nYUP\n\n> `(if (= (+ 1 2) 4)`\n      `'yup`\n      `'nope)`\n\nNOPE\n```", "```\n> `(if '(1)`\n      `'the-list-has-stuff-in-it`\n      `'the-list-is-empty)`\n\nTHE-LIST-HAS-STUFF-IN-IT\n\n> `(if '()`\n      `'the-list-has-stuff-in-it`\n      `'the-list-is-empty)`\n\nTHE-LIST-IS-EMPTY\n```", "```\n> `(if (oddp 5)`\n      `'odd-number`\n      `'even-number)`\n\nODD-NUMBER\n```", "```\n> `(if (oddp 5)`\n    `'odd-number`\n    `(/ 1 0))`\n\nODD-NUMBER\n```", "```\n> `(defvar *number-was-odd* nil)`\n\n> `(if (oddp 5)`\n      `(progn (setf *number-was-odd* t)`\n             `'odd-number)`\n      `'even-number)`\n\nODD-NUMBER\n\n> `*number-was-odd*`\n\nT\n```", "```\n> `(defvar *number-is-odd* nil)`\n> `(when (oddp 5)`\n        `(setf *number-is-odd* t)`\n        `'odd-number)`\n\nODD-NUMBER\n\n> `*number-is-odd*`\n\nT\n\n> `(unless (oddp 4)`\n          `(setf *number-is-odd* nil)`\n          `'even-number)`\n\nEVEN-NUMBER\n\n> `*number-is-odd*`\n\nNIL\n```", "```\n> `(defvar *arch-enemy* nil)`\n > `(defun pudding-eater (person)`\n `(cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)`\n                                   `'(curse you lisp alien - you ate my pudding))`\n               `((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)`\n                                   `'(i hope you choked on my pudding johnny))`\n               `(t                  '(why you eat my pudding stranger ?))))`\n\n  > `(pudding-eater 'johnny)`\n  (I HOPE YOU CHOKED ON MY PUDDING JOHNNY)\n  > `*arch-enemy*`\n  JOHNNY\n  > `(pudding-eater 'george-clooney)`\n  (WHY YOU EAT MY PUDDING STRANGER ?)\n```", "```\n> `(defun pudding-eater (person)`\n         `(case person`\n              `((henry)   (setf *arch-enemy* 'stupid-lisp-alien)`\n                         `'(curse you lisp alien - you ate my pudding))`\n              `((johnny)  (setf *arch-enemy* 'useless-old-johnny)`\n                         `'(i hope you choked on my pudding johnny))`\n              `(otherwise '(why you eat my pudding stranger ?))))`\n```", "```\n> `(and (oddp 5) (oddp 7) (oddp 9))`\n\nT\n```", "```\n> `(or (oddp 4) (oddp 7) (oddp 8))`\n\nT\n```", "```\n> `(defparameter *is-it-even* nil)`\n\n*IS-IT-EVEN*\n\n> `(or (oddp 4) (setf *is-it-even* t))`\n\nT\n\n> `*is-it-even*`\n\nT\n```", "```\n> `(defparameter *is-it-even* nil)`\n\n*IS-IT-EVEN\n\n> `(or (oddp 5) (setf *is-it-even* t))`\n\nT\n\n> `*is-it-even*`\n\nNIL\n```", "```\n(if *file-modified*\n    (if (ask-user-about-saving)\n        (save-file)))\n```", "```\n(and *file-modified* (ask-user-about-saving) (save-file))\n```", "```\n(if (and *file-modified*\n         (ask-user-about-saving))\n    (save-file)))\n```", "```\n> `(if (member 1 '(3 4 1 5))`\n      `'one-is-in-the-list`\n      `'one-is-not-in-the-list)`\n\n'ONE-IS-IN-THE-LIST\n```", "```\n> `(member 1 '(3 4 1 5))`\n\n(1 5)\n```", "```\n> `(if (member nil '(3 4 nil 5))`\n      `'nil-is-in-the-list`\n      `'nil-is-not-in-the-list)`\n\n'nil-is-in-the-list\n```", "```\n> `(find-if #'oddp '(2 4 5 6))`\n\n5\n\n> `(if (find-if #'oddp '(2 4 5 6))`\n      `'there-is-an-odd-number`\n      `'there-is-no-odd-number)`\n\n'there-is-an-odd-number\n```", "```\n> `(find-if #'null '(2 4 nil 6))`\n\nNIL\n```", "```\n> `(defparameter *fruit* 'apple)`\n\n*FRUIT*\n\n> `(cond ((eq *fruit* 'apple) 'its-an-apple)`\n        `((eq *fruit* 'orange) 'its-an-orange))`\n\nITS-AN-APPLE\n```", "```\n;;comparing symbols\n> `(equal 'apple 'apple)`\n\nT\n\n;;comparing lists\n> `(equal (list 1 2 3) (list 1 2 3))`\n\nT\n\n;;Identical lists created in different ways still compare as the same\n> `(equal '(1 2 3) (cons 1 (cons 2 (cons 3))))`\n\nT\n\n;;comparing integers\n> `(equal 5 5)`\n\nT\n\n;;comparing floating point numbers\n> `(equal 2.5 2.5)`\n\nT\n\n;;comparing strings\n> `(equal \"foo\" \"foo\")`\n\nT\n\n;;comparing characters\n> `(equal #\\a #\\a)`\n\nT\n```", "```\n;;comparing symbols\n> `(eql 'foo 'foo)`\n\nT\n\n;;comparing numbers\n> `(eql 3.4 3.4)`\n\nT\n\n;;comparing characters\n> `(eql #\\a #\\a)`\n\nT\n```", "```\n;;comparing strings with different CAPS\n> `(equalp \"Bob Smith\" \"bob smith\")`\nT\n;;comparing integers against floating point numbers\n> `(equalp 0 0.0)`\nT\n```", "```\n(defparameter *nodes* '((living-room (you are in the living-room.\n                            a wizard is snoring loudly on the couch.))\n                        (garden (you are in a beautiful garden.\n                            there is a well in front of you.))\n                        (attic (you are in the attic.\n                            there is a giant welding torch in the corner.))))\n```", "```\n> `(assoc 'garden *nodes*)`\n(GARDEN (YOU ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))\n```", "```\n(defun describe-location (location nodes)\n   (cadr (assoc location nodes)))\n```", "```\n> `(describe-location 'living-room *nodes*)`\n(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH.)\n```", "```\n(defparameter *edges* '((living-room (garden west door)\n                                     (attic upstairs ladder))\n                        (garden (living-room east door))\n                        (attic (living-room downstairs ladder))))\n```", "```\n(defun describe-path (edge)\n  `(there is a ,(caddr edge) going ,(cadr edge) from here.))\n```", "```\n> `(describe-path '(garden west door))`\n(THERE IS A DOOR GOING WEST FROM HERE.)\n```", "```\n(defun describe-paths (location edges)\n  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))\n```", "```\n> `(describe-paths 'living-room *edges*)`\n(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE.)\n```", "```\n> `(cdr (assoc 'living-room *edges*))`\n((GARDEN WEST DOOR) (ATTIC UPSTAIRS LADDER))\n```", "```\n> `(mapcar #'describe-path '((GARDEN WEST DOOR) (ATTIC UPSTAIRS LADDER)))`\n((THERE IS A DOOR GOING WEST FROM HERE.)\n (THERE IS A LADDER GOING UPSTAIRS FROM HERE.))\n```", "```\n> `(mapcar #'sqrt '(1 2 3 4 5))`\n(1 1.4142135 1.7320508 2 2.236068)\n```", "```\n> `(mapcar #'car '((foo bar) (baz qux)))`\n(foo baz)\n```", "```\n> `(mapcar (function car) '((foo bar) (baz qux)))`\n(foo baz)\n```", "```\n > `(let ((car \"Honda Civic\"))`\n    `(mapcar #'car '((foo bar) (baz qux))))`\n  (foo baz)\n```", "```\n(defun describe-paths (location edges)\n  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))\n```", "```\n> `(append '(mary had) '(a) '(little lamb))`\n(MARY HAD A LITTLE LAMB)\n```", "```\n> `(apply #'append '((mary had) (a) (little lamb)))`\n(MARY HAD A LITTLE LAMB)\n```", "```\n> `(apply #'append '((THERE IS A DOOR GOING WEST FROM HERE.)`\n                    `(THERE IS A LADDER GOING UPSTAIRS FROM HERE.)))`\n(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE.)\n```", "```\n(defun describe-paths (location edges)\n  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))\n```", "```\n> `(defparameter *objects* '(whiskey bucket frog chain))`\n*OBJECTS*\n```", "```\n(defparameter *object-locations* '((whiskey living-room)\n                                   (bucket living-room)\n                                   (chain garden)\n                                   (frog garden)))\n```", "```\n(defun objects-at (loc objs obj-locs)\n   (labels ((at-loc-p (obj)\n              (eq (cadr (assoc obj obj-locs)) loc)))\n     (remove-if-not #'at-loc-p objs)))\n```", "```\n> `(objects-at 'living-room *objects* *object-locations*)`\n(WHISKEY BUCKET)\n```", "```\n(defun describe-objects (loc objs obj-loc)\n  (labels ((describe-obj (obj)\n               `(you see a ,obj on the floor.)))\n    (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))\n```", "```\n> `(describe-objects 'living-room *objects* *object-locations*)`\n(YOU SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR)\n```", "```\n(defparameter *location* 'living-room)\n```", "```\n(defun look ()\n  (append (describe-location *location* *nodes*)\n          (describe-paths *location* *edges*)\n          (describe-objects *location* *objects* *object-locations*)))\n```", "```\n> `(look)`\n(YOU ARE IN THE LIVING-ROOM OF A WIZARD’S HOUSE.\nTHERE IS A WIZARD SNORING LOUDLY ON THE COUCH.\nTHERE IS A DOOR GOING WEST FROM HERE.\nTHERE IS A LADDER GOING UPSTAIRS FROM HERE.\nYOU SEE A WHISKEY ON THE FLOOR.\nYOU SEE A BUCKET ON THE FLOOR)\n```", "```\n(defun walk (direction)\n  (let ((next (find direction\n                    (cdr (assoc *location* *edges*))\n                    :key #'cadr)))\n  (if next\n      (progn (setf *location* (car next))\n             (look))\n      '(you cannot go that way.))))\n```", "```\n> `(find 'y '((5 x) (3 y) (7 z)) :key #'cadr)`\n(3 Y)\n```", "```\n> `(walk 'west)`\n(YOU ARE IN A BEAUTIFUL GARDEN.\nTHERE IS A WELL IN FRONT OF YOU.\nTHERE IS A DOOR GOING EAST FROM HERE.\nYOU SEE A CHAIN ON THE FLOOR.\nYOU SEE A FROG ON THE FLOOR.)\n```", "```\n(defun pickup (object)\n  (cond ((member object\n                 (objects-at *location* *objects* *object-locations*))\n         (push (list object 'body) *object-locations*)\n           `(you are now carrying the ,object))\n          (t '(you cannot get that.))))\n```", "```\n> `(defparameter *foo* '(1 2 3))`\n*FOO*\n> `(push 7 *foo*)`\n(7 1 2 3)\n> `*foo*`\n(7 1 2 3)\n```", "```\n> `(walk 'east)`\n(YOU ARE IN THE LIVING-ROOM OF A WIZARDS HOUSE. THERE IS A WIZARD SNORING\n LOUDLY ON THE COUCH. THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER\n GOING UPSTAIRS FROM HERE. YOU SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON\n THE FLOOR.)\n> `(pickup 'whiskey)`\n(YOU ARE NOW CARRYING THE WHISKEY)\n```", "```\n(defun inventory ()\n  (cons 'items- (objects-at 'body *objects* *object-locations*)))\n```", "```\n> `(inventory)`\n(ITEMS- WHISKEY)\n```", "```\n> `(print \"foo\")`\n\n \"foo\"\n \"foo\"\n```", "```\n> `(progn (print \"this\")`\n         `(print \"is\")`\n         `(print \"a\")`\n         `(print \"test\"))`\n\n\"this\"\n\"is\"\n\"a\"\n\"test\"\n```", "```\n> `(progn (prin1 \"this\")`\n         `(prin1 \"is\")`\n         `(prin1 \"a\")`\n         `(prin1 \"test\"))`\n\"this\"\"is\"\"a\"\"test\"\n```", "```\n> `(defun say-hello ()`\n      `(print \"Please type your name:\")`\n      `(let ((name (read)))`\n          `(print \"Nice to meet you, \")`\n          `(print name)))`\n  SAY-HELLO.\n  > `(say-hello)`\n  \"Please type your name:\" `\"bob\"`\n  \"Nice to meet you,\"\n  \"bob\"\n```", "```\n> `(defun add-five ()`\n      `(print \"please enter a number:\")`\n      `(let ((num (read)))`\n          `(print \"When I add five I get\")`\n          `(print (+ num 5))))`\nADD-FIVE\n> `(add-five)`\n\"please enter a number:\" `4`\n\"When I add five I get\"\n9\n```", "```\n`(print '3)`     => 3      *`An integer`*\n`(print '3.4)`   => 3.4    *`A float`*\n`(print 'foo)`   => FOO\n    *`A symbol. It may be printed in all caps, since Common`*\n                          *`Lisp symbols are blind to letter case.`*\n`(print '\"foo\")` => \"foo\"  *`A string`*\n`(print '#\\a)`   => #\\a    *`A character`*\n```", "```\n`(princ '3)`     => 3\n`(princ '3.4)`   => 3.4\n`(princ 'foo)`   => FOO\n`(princ '\"foo\")` => foo\n`(princ '#\\a)`   => a\n```", "```\n> `(progn (princ \"This sentence will be interrupted\")`\n         `(princ #\\newline)`\n         `(princ \"by an annoying newline character.\"))`\nThis sentence will be interrupted\nby an annoying newline character.\n```", "```\n> `(defun say-hello ()`\n      `(princ \"Please type your name:\")`\n      `(let ((name (read-line)))`\n          `(princ \"Nice to meet you, \")`\n          `(princ name)))`\n  SAY-HELLO\n  > `(say-hello)`\n  Please type your name: `Bob O'Malley`\n  Nice to meet you, Bob O'Malley\n```", "```\n`> '(+ 1 2)` ;data mode\n(+ 1 2)\n`> (+ 1 2)` ;code mode\n3\n```", "```\n> `(defparameter *foo* '(+ 1 2))`\n*FOO*\n```", "```\n> `(eval *foo*)`\n3\n```", "```\n> `(defun game-repl ()`\n     `(loop (print (eval (read)))))`\nGAME-REPL\n> `(game-repl)`\n`(look)`\n\n(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS\n A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU\n SEE A WHISKEY ON THE FLOOR.)\n```", "```\n(defun game-repl ()\n    (let ((cmd (game-read)))\n        (unless (eq (car cmd) 'quit)\n            (game-print (game-eval cmd))\n            (game-repl))))\n```", "```\n(defun game-read ()\n    (let ((cmd (read-from-string\n                     (concatenate 'string \"(\" (read-line) \")\"))))\n         (flet ((quote-it (x)\n                         (list 'quote x)))\n             (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))\n```", "```\n> `(game-read)`\n`walk east`\n(WALK 'EAST)\n```", "```\n(defparameter *allowed-commands* '(look walk pickup inventory))\n\n  (defun game-eval (sexp)\n      (if (member (car sexp) *allowed-commands*)\n          (eval sexp)\n          '(i do not know that command.)))\n```", "```\n> `(game-print '(THIS IS A SENTENCE. WHAT ABOUT THIS? PROBABLY.))`\nThis is a sentence. What about this? Probably.\n```", "```\n(defun tweak-text (lst caps lit)\n   (when lst\n  (let ((item (car lst))\n         (rest (cdr lst)))\n   (cond ((eq item #\\space) (cons item (tweak-text rest caps lit)))\n         ((member item '(#\\! #\\? #\\.)) (cons item (tweak-text rest t lit)))\n         ((eq item #\\\") (tweak-text rest caps (not lit)))\n           (lit (cons item (tweak-text rest nil lit)))\n         ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))\n         (t (cons (char-downcase item) (tweak-text rest nil nil)))))))\n\n  (defun game-print (lst)\n   (princ (coerce (tweak-text (coerce (string-trim \"() \"\n                                                    (prin1-to-string lst))\n                                       'list)\n                               t\n                              nil)\n                   'string))\n    (fresh-line))\n```", "```\n> `(game-print '(not only does this sentence`\n `have a \"comma,\" it also mentions the \"iPad.\"))`\nNot only does this sentence have a comma, it also mentions the iPad.\n```", "```\n> `(game-repl)`\n`look`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\n a door going west from here. There is a ladder going upstairs from here. You\n see a whiskey on the floor. You see a bucket on the floor.\n`walk west`\nYou are in a beautiful garden. There is a well in front of you. There is a\n door going east from here. You see a frog on the floor. You see a chain on\n the floor.\n`pickup chain`\nYou are now carrying the chain\n`scratch head`\nI do not know that command.\n`pickup chicken`\nYou cannot get that.\n`walk east`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\n a door going west from here. There is a ladder going upstairs from here. You\n see a whiskey on the floor. You see a bucket on the floor.\n`walk upstairs`\nYou are in the attic. There is a giant welding torch in the corner. There is a\n ladder going downstairs from here.\n`inventory`\nItems- chain\n`walk china`\nYou cannot go that way.\n`walk downstairs`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\n a door going west from here. There is a ladder going upstairs from here. You\n see a whiskey on the floor. You see a bucket on the floor.\n`pickup bucket`\nYou are now carrying the bucket\n`look`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\n a door going west from here. There is a ladder going upstairs from here. You\n see a whiskey on the floor.\n`quit`\n```", "```\n> `(game-repl)`\n`format-harddrive`\nI do not know that command.\n```", "```\n(defun half (n)\n    (/ n 2))\n```", "```\n> `#'half`\n#<FUNCTION HALF ...>\n```", "```\n> `(lambda (n) (/ n 2))`\n#<FUNCTION :LAMBDA ...>\n```", "```\n> `(mapcar (lambda (n) (/ n 2)) '(2 4 6))`\n(1 2 3)\n```", "```\n(cons 1 (cons 2 (cons 3 nil)))\n```", "```\n> `(cons 1 (cons 2 (cons 3 nil)))`\n(1 2 3)\n```", "```\n(cons 1 (cons 2 3))\n```", "```\n> `(cons 1 (cons 2 3))`\n(1 2 . 3)\n```", "```\n> `'(1 . (2 . (3 . nil)))`\n(1 2 3)\n```", "```\n> `(cons 2 3)`\n(2 . 3)\n```", "```\n(setf *print-circle* t)\n```", "```\n> `(defparameter foo '(1 2 3))`\nFOO\n> `(setf (cdddr foo) foo)`\n#1=(1 2 3 . #1#)\n```", "```\n(defparameter *drink-order* '((bill . double-espresso)\n                              (lisa . small-drip-coffee)\n                              (john . medium-latte)))\n```", "```\n> `(assoc 'lisa *drink-order*)`\n(LISA . SMALL-DRIP-COFFEE)\n```", "```\n> `(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)`\n((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)\n (BILL . DOUBLE-ESPRESSO)\n (LISA . SMALL-DRIP-COFFEE)\n (JOHN . MEDIUM-LATTE))\n```", "```\n> `(assoc 'lisa *drink-order*)`\n(LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)\n```", "```\n(defparameter *house* '((walls (mortar (cement)\n                                         (water)\n                                         (sand))\n                                 (bricks))\n                         (windows (glass)\n                                   (frame)\n                                  (curtains))\n                          (roof (shingles)\n                                (chimney))))\n```", "```\n(defparameter *wizard-nodes* '((living-room (you are in the living-room.\n                                a wizard is snoring loudly on the couch.))\n                               (garden (you are in a beautiful garden.\n                                there is a well in front of you.))\n                               (attic (you are in the attic. there\n                                is a giant welding torch in the corner.))))\n(defparameter *wizard-edges* '((living-room (garden west door)\n                                            (attic upstairs ladder))\n                               (garden (living-room east door))\n                               (attic (living-room downstairs ladder))))\n```", "```\ndigraph {\n   a->b;\n}\n```", "```\nneato -Tpng -O test.dot\n```", "```\n(defun dot-name (exp)\n  (substitute-if #\\_ (complement #'alphanumericp) (prin1-to-string exp)))\n```", "```\n> `(dot-name 'living-room)`\n\"LIVING_ROOM\"\n> `(dot-name 'foo!)`\n\"FOO_\"\n> `(dot-name '24)`\n\"24\"\n```", "```\n> `(substitute-if #\\e #'digit-char-p \"I'm a l33t hack3r!\")`\n\"I'm a leet hacker!\"\n```", "```\n> `(substitute-if 0 #'oddp '(1 2 3 4 5 6 7 8))`\n'(0 2 0 4 0 6 0 8)\n```", "```\n(complement #'alphanumericp)\n```", "```\n (defparameter *max-label-length* 30)\n\n  (defun dot-label (exp)\n    (if exp\n     (let ((s (write-to-string exp :pretty nil)))\n       (if (> (length s) *max-label-length*)\n           (concatenate 'string (subseq s 0 (- *max-label-length* 3)) \"...\")\n            s))\n      \"\"))\n```", "```\n(defun nodes->dot (nodes)\n   (mapc (lambda (node)\n            (fresh-line)\n           (princ (dot-name (car node)))\n            (princ \"[label=\\\"\")\n           (princ (dot-label node))\n            (princ \"\\\"];\"))\n          nodes))\n```", "```\n>  `(nodes->dot *wizard-nodes*)`\nLIVING_ROOM[label=\"(LIVING-ROOM (YOU ARE IN TH...\"];\nGARDEN[label=\"(GARDEN (YOU ARE IN A BEAUT...\"];\nATTIC[label=\"(ATTIC (YOU ARE IN THE ATTI...\"];\n```", "```\n(defun edges->dot (edges)\n  (mapc (lambda (node)\n          (mapc (lambda (edge)\n                  (fresh-line)\n                  (princ (dot-name (car node)))\n                  (princ \"->\")\n                  (princ (dot-name (car edge)))\n                  (princ \"[label=\\\"\")\n                  (princ (dot-label (cdr edge)))\n                  (princ \"\\\"];\"))\n                (cdr node)))\n        edges))\n```", "```\n> `(edges->dot *wizard-edges*)`\n LIVING_ROOM->GARDEN[label=\"(WEST DOOR)\"];\n  LIVING_ROOM->ATTIC[label=\"(UPSTAIRS LADDER)\"];\n  GARDEN->LIVING_ROOM[label=\"(EAST DOOR)\"];\n  ATTIC->LIVING_ROOM[label=\"(DOWNSTAIRS LADDER)\"];\n```", "```\n(defun graph->dot (nodes edges)\n  (princ \"digraph{\")\n  (nodes->dot nodes)\n  (edges->dot edges)\n    (princ \"}\"))\n```", "```\n> `(graph->dot *wizard-nodes* *wizard-edges*)`\ndigraph{\nLIVING_ROOM[label=\"(LIVING-ROOM (YOU ARE IN TH...\"];\nGARDEN[label=\"(GARDEN (YOU ARE IN A BEAUT...\"];\nATTIC[label=\"(ATTIC (YOU ARE IN THE ATTI...\"];\nLIVING_ROOM->GARDEN[label=\"(WEST DOOR)\"];\nLIVING_ROOM->ATTIC[label=\"(UPSTAIRS LADDER)\"];\nGARDEN->LIVING_ROOM[label=\"(EAST DOOR)\"];\nATTIC->LIVING_ROOM[label=\"(DOWNSTAIRS LADDER)\"];}\n```", "```\n (defun dot->png (fname thunk)\n  (with-open-file (*standard-output*\n                     fname\n                     :direction :output\n                     :if-exists :supersede)\n      (funcall thunk))\n    (ext:shell (concatenate 'string \"dot -Tpng -O \" fname)))\n```", "```\n (with-open-file (my-stream\n                   \"testfile.txt\"\n                   :direction :output\n                   :if-exists :supersede)\n     (princ \"Hello File!\" my-stream))\n```", "```\n (with-open-file (my-stream ...)\n    ...*`body has my-stream defined`*...)\n\n (let ((my-variable ...))\n    ...*`body has my-variable defined`*...)\n```", "```\n(with-open-file (my-stream\n                   \"testfile.txt\"\n                  :direction :output\n                  :if-exists :supersede)\n     (princ \"Hello File!\" my-stream))\n```", "```\n> `(let ((cigar 5))`\n     `cigar)`\n5\n```", "```\n > `:cigar`\n  :CIGAR\n > `(let ((:cigar 5))`\n      `:cigar)`\n  *** - LET: :CIGAR is a constant, may not be used as a variable\n```", "```\n(defun dot->png (fname thunk)\n   (with-open-file (*standard-output*\n                     fname\n                     :direction :output\n                     :if-exists :supersede)\n     (funcall thunk))\n    (ext:shell (concatenate 'string \"dot -Tpng -O \" fname)))\n```", "```\n (defun graph->png (fname nodes edges)\n   (dot->png fname\n             (lambda ()\n               (graph->dot nodes edges))))\n```", "```\n(graph->png \"wizard.dot\" *wizard-nodes* *wizard-edges*)\n```", "```\n(defun uedges->dot (edges)\n   (maplist (lambda (lst)\n               (mapc (lambda (edge)\n                      (unless (assoc (car edge) (cdr lst))\n                         (fresh-line)\n                         (princ (dot-name (caar lst)))\n                         (princ \"--\")\n                         (princ (dot-name (car edge)))\n                         (princ \"[label=\\\"\")\n                         (princ (dot-label (cdr edge)))\n                         (princ \"\\\"];\")))\n                     (cdar lst)))\n             edges))\n\n (defun ugraph->dot (nodes edges)\n   (princ \"graph{\")\n    (nodes->dot nodes)\n    (uedges->dot edges)\n    (princ \"}\"))\n\n (defun ugraph->png (fname nodes edges)\n    (dot->png fname\n              (lambda ()\n                (ugraph->dot nodes edges))))\n```", "```\n> `(mapcar #'print '(a b c))`\nA\nB\nC\n...\n> `(maplist #'print '(a b c))`\n(A B C)\n(B C)\n(C)\n...\n```", "```\n(ugraph->png \"uwizard.dot\" *wizard-nodes* *wizard-edges*)\n```", "```\n (load \"graph-util\")\n\n  (defparameter *congestion-city-nodes* nil)\n  (defparameter *congestion-city-edges* nil)\n  (defparameter *visited-nodes* nil)\n (defparameter *node-num* 30)\n (defparameter *edge-num* 45)\n (defparameter *worm-num* 3)\n (defparameter *cop-odds* 15)\n```", "```\n (defun random-node ()\n    (1+ (random *node-num*)))\n\n (defun edge-pair (a b)\n    (unless (eql a b)\n      (list (cons a b) (cons b a))))\n\n (defun make-edge-list ()\n   (apply #'append (loop repeat *edge-num*\n                         collect (edge-pair (random-node) (random-node)))))\n```", "```\n> `(make-edge-list)`\n((16 . 20) (20 . 16) (9 . 3) (3 . 9) (25 . 18) (18 . 25) (30 . 29)\n (29 . 30) (26 . 13) (13 . 26) (12 . 25) (25 . 12) (26 . 22) (22 . 26)\n (30 . 29) (29 . 30) (3 . 14) (14 . 3) (28 . 6) (6 . 28) (4 . 8) (8 . 4)\n (27 . 8) (8 . 27) (3 . 30) (30 . 3) (25 . 16) (16 . 25) (5 . 21) (21 . 5)\n (11 . 24) (24 . 11) (14 . 1) (1 . 14) (25 . 11) (11 . 25) (21 . 9) (9 . 21)\n (12 . 22) (22 . 12) (21 . 11) (11 . 21) (11 . 17) (17 . 11) (30 . 21) (21 . 30)\n (3 . 11) (11 . 3) (24 . 23) (23 . 24) (1 . 24) (24 . 1) (21 . 19) (19 . 21) (25 . 29)\n (29 . 25) (1 . 26) (26 . 1) (28 . 24) (24 . 28) (20 . 15) (15 . 20)\n (28 . 25) (25 . 28)\n (2 . 11) (11 . 2) (11 . 24) (24 . 11) (29 . 24) (24 . 29)\n(18 . 28) (28 . 18) (14 . 15)\n (15 . 14) (16 . 10) (10 . 16) (3 . 26) (26 . 3) (18 . 9) (9 . 18) (5 . 12)\n (12 . 5) (11 . 18) (18 . 11) (20 . 17) (17 . 20) (25 . 3) (3 . 25))\n```", "```\n> `(loop repeat 10`\n        `collect 1)`\n(1 1 1 1 1 1 1 1 1 1)\n```", "```\n> `(loop for n from 1 to 10`\n        `collect n)`\n(1 2 3 4 5 6 7 8 9 10)\n```", "```\n> `(loop for n from 1 to 10`\n        `collect (+ 100 n))`\n(101 102 103 104 105 106 107 108 109 110)\n```", "```\n (defun direct-edges (node edge-list)\n   (remove-if-not (lambda (x)\n                     (eql (car x) node))\n                   edge-list))\n\n (defun get-connected (node edge-list)\n   (let ((visited nil))\n      (labels ((traverse (node)\n                 (unless (member node visited)\n                  (push node visited)\n                  (mapc (lambda (edge)\n                           (traverse (cdr edge)))\n                         (direct-edges node edge-list)))))\n        (traverse node))\n      visited))\n\n  (defun find-islands (nodes edge-list)\n    (let ((islands nil))\n     (labels ((find-island (nodes)\n                 (let* ((connected (get-connected (car nodes) edge-list))\n                        (unconnected (set-difference nodes connected)))\n                   (push connected islands)\n                  (when unconnected\n                     (find-island unconnected)))))\n        (find-island nodes))\n      islands))\n\n  (defun connect-with-bridges (islands)\n   (when (cdr islands)\n      (append (edge-pair (caar islands) (caadr islands))\n              (connect-with-bridges (cdr islands)))))\n\n (defun connect-all-islands (nodes edge-list)\n    (append (connect-with-bridges (find-islands nodes edge-list)) edge-list))\n```", "```\n(defun make-city-edges ()\n   (let* ((nodes (loop for i from 1 to *node-num*\n                        collect i))\n          (edge-list (connect-all-islands nodes (make-edge-list)))\n          (cops (remove-if-not (lambda (x)\n                                  (zerop (random *cop-odds*)))\n                                edge-list)))\n     (add-cops (edges-to-alist edge-list) cops)))\n\n  (defun edges-to-alist (edge-list)\n   (mapcar (lambda (node1)\n              (cons node1\n                   (mapcar (lambda (edge)\n                              (list (cdr edge)))\n                            (remove-duplicates (direct-edges node1 edge-list)\n                                              :test #'equal))))\n            (remove-duplicates (mapcar #'car edge-list))))\n\n  (defun add-cops (edge-alist edges-with-cops)\n   (mapcar (lambda (x)\n              (let ((node1 (car x))\n                    (node1-edges (cdr x)))\n                (cons node1\n                     (mapcar (lambda (edge)\n                                (let ((node2 (car edge)))\n                                 (if (intersection (edge-pair node1 node2)\n                                                    edges-with-cops\n                                                    :test #'equal)\n                                      (list node2 'cops)\n                                    edge)))\n                              node1-edges))))\n            edge-alist))\n```", "```\n> `(let ((a 5)`\n        `(b (+ a 2)))`\n    `b)`\n*** - EVAL: variable A has no value\n> `(let* ((a 5)`\n         `(b (+ a 2)))`\n    `b)`\n7\n```", "```\n((1 (2)) (2 (1) (3 COPS)) (3 (2 COPS)))\n```", "```\n(defun neighbors (node edge-alist)\n (mapcar #'car (cdr (assoc node edge-alist))))\n\n(defun within-one (a b edge-alist)\n (member b (neighbors a edge-alist)))\n```", "```\n(defun within-two (a b edge-alist)\n   (or (within-one a b edge-alist)\n        (some (lambda (x)\n               (within-one x b edge-alist))\n             (neighbors a edge-alist))))\n```", "```\n(defun make-city-nodes (edge-alist)\n   (let ((wumpus (random-node))\n         (glow-worms (loop for i below *worm-num*\n                            collect (random-node))))\n     (loop for n from 1 to *node-num*\n         collect (append (list n)\n                         (cond ((eql n wumpus) '(wumpus))\n                               ((within-two n wumpus edge-alist) '(blood!)))\n                         (cond ((member n glow-worms)\n                                 '(glow-worm))\n                               ((some (lambda (worm)\n                                         (within-one n worm edge-alist))\n                                       glow-worms)\n                                 '(lights!)))\n                         (when (some #'cdr (cdr (assoc n edge-alist)))\n                            '(sirens!))))))\n```", "```\n((1 (2)) (2 (1) (3 COPS)) (3 (2 COPS)))\n```", "```\n(defun new-game ()\n    (setf *congestion-city-edges* (make-city-edges))\n    (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))\n   (setf *player-pos* (find-empty-node))\n    (setf *visited-nodes* (list *player-pos*))\n    (draw-city))\n```", "```\n(defun find-empty-node ()\n   (let ((x (random-node)))\n     (if (cdr (assoc x *congestion-city-nodes*))\n         (find-empty-node)\n          x)))\n```", "```\n(defun draw-city ()\n  (ugraph->png \"city\" *congestion-city-nodes* *congestion-city-edges*))\n```", "```\n(defun known-city-nodes ()\n   (mapcar (lambda (node)\n             (if (member node *visited-nodes*)\n                  (let ((n (assoc node *congestion-city-nodes*)))\n                   (if (eql node *player-pos*)\n                        (append n '(*))\n                        n))\n                 (list node '?)))\n            (remove-duplicates\n               (append *visited-nodes*\n                       (mapcan (lambda (node)\n                                  (mapcar #'car\n                                         (cdr (assoc node\n                                                     *congestion-city-edges*))))\n                                *visited-nodes*)))))\n```", "```\n(defun known-city-edges ()\n    (mapcar (lambda (node)\n              (cons node (mapcar (lambda (x)\n                                   (if (member (car x) *visited-nodes*)\n                                       x\n                                      (list (car x))))\n                                 (cdr (assoc node *congestion-city-edges*)))))\n            *visited-nodes*))\n```", "```\n> `(defun ingredients (order)`\n     `(mapcan (lambda (burger)`\n                `(case burger`\n                   `(single '(patty))`\n                   `(double '(patty patty))`\n                   `(double-cheese '(patty patty cheese))))`\n             `order))`\nINGREDIENTS\n> `(ingredients '(single double-cheese double))`\n'(PATTY PATTY PATTY CHEESE PATTY PATTY)\n```", "```\n(defun draw-known-city ()\n  (ugraph->png \"known-city\" (known-city-nodes) (known-city-edges)))\n```", "```\n(defun new-game ()\n    (setf *congestion-city-edges* (make-city-edges))\n    (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))\n    (setf *player-pos* (find-empty-node))\n    (setf *visited-nodes* (list *player-pos*))\n    (draw-city)\n   (draw-known-city))\n```", "```\n(defun walk (pos)\n  (handle-direction pos nil))\n\n(defun charge (pos)\n  (handle-direction pos t))\n```", "```\n(defun handle-direction (pos charging)\n    (let ((edge (assoc pos\n                      (cdr (assoc *player-pos* *congestion-city-edges*)))))\n      (if edge\n         (handle-new-place edge pos charging)\n         (princ \"That location does not exist!\"))))\n```", "```\n(defun handle-new-place (edge pos charging)\n   (let* ((node (assoc pos *congestion-city-nodes*))\n          (has-worm (and (member 'glow-worm node)\n                          (not (member pos *visited-nodes*)))))\n     (pushnew pos *visited-nodes*)\n     (setf *player-pos* pos)\n     (draw-known-city)\n     (cond ((member 'cops edge) (princ \"You ran into the cops. Game Over.\"))\n           ((member 'wumpus node) (if charging\n                                       (princ \"You found the Wumpus!\")\n                                       (princ \"You ran into the Wumpus\")))\n           (charging (princ \"You wasted your last bullet. Game Over.\"))\n           (has-worm (let ((new-pos (random-node)))\n                        (princ \"You ran into a Glow Worm Gang! You're now at \")\n                        (princ new-pos)\n                        (handle-new-place nil new-pos nil))))))\n```", "```\n> `(make-array 3)`\n#(NIL NIL NIL)\n```", "```\n> `(defparameter x (make-array 3))`\n#(NIL NIL NIL)\n> `(aref x 1)`\nNIL\n```", "```\n> `(defparameter x (make-array 3))`\n#(NIL NIL NIL)\n> `(setf (aref x 1) 'foo)`\nFOO\n> `x`\n#(NIL FOO NIL)\n> `(aref x 1)`\nFOO\n```", "```\n> `(setf foo '(a b c))`\n  (A B C)\n  > `(second foo)`\n  B\n > `(setf (second foo) 'z)`\n  Z\n  > foo\n  (A Z C)\n```", "```\n> `(setf foo (make-array 4))`\n  #(NIL NIL NIL NIL)\n > `(setf (aref foo 2) '(x y z))`\n  (X Y Z)\n  > `foo`\n #(NIL NIL (X Y Z) NIL)\n > `(setf (car (aref foo 2)) (make-hash-table))`\n  #S(HASH-TABLE)\n > `(setf (gethash 'zoink (car (aref foo 2))) 5)`\n  5\n  > `foo`\n  #(NIL NIL (#S(HASH-TABLE (ZOINK . 5)) Y Z) NIL)\n```", "```\n> `(nth 1 '(foo bar baz))`\nBAR\n```", "```\n> `(make-hash-table)`\n#S(HASH-TABLE ...)\n```", "```\n> `(defparameter x (make-hash-table))`\n  #S(HASH-TABLE ...)\n  > `(gethash 'yup x)`\n NIL ;\n NIL\n```", "```\n> `(defparameter x (make-hash-table))`\n  #S(HASH-TABLE ...)\n > `(setf (gethash 'yup x) '25)`\n  25\n  > `(gethash 'yup x)`\n 25 ;\n T\n```", "```\n> `(defparameter *drink-order* (make-hash-table))`\n#S(HASH-TABLE ...)\n> `(setf (gethash 'bill *drink-order*) 'double-espresso)`\nDOUBLE-ESPRESSO\n> `(setf (gethash 'lisa *drink-order*) 'small-drip-coffee)`\nSMALL-DRIP-COFFEE\n> `(setf (gethash 'john *drink-order*) 'medium-latte)`\nMEDIUM-LATTE\n```", "```\n> `(gethash 'lisa *drink-order*)`\n'small-drip-coffee ;\nT\n```", "```\n> `(round 2.4)`\n 2 ;\n 0.4\n```", "```\n> `(defun foo ()`\n      `(values 3 7))`\n  FOO\n  > `(foo)`\n 3 ;\n 7\n```", "```\n> `(+ (foo) 5)`\n8\n```", "```\n> `(multiple-value-bind (a b) (foo)`\n                       `(* a b))`\n21\n```", "```\n> `(setf *edge-num* 1000)`\n1000\n> `(setf *node-num* 1000)`\n1000\n> `(time (dotimes (i 100) (get-connected 1 (make-edge-list))))`\nReal time: 57.699303 sec.\nRun time: 57.687607 sec.\nSpace: 39566832 Bytes\nGC: 43, GC time: 0.120005 sec.\n```", "```\n (defun hash-edges (edge-list)\n   (let ((tab (make-hash-table)))\n     (mapc (lambda (x)\n              (let ((node (car x)))\n               (push (cdr x) (gethash node tab))))\n            edge-list)\n     tab))\n```", "```\n  (defun get-connected-hash (node edge-tab)\n   (let ((visited (make-hash-table)))\n      (labels ((traverse (node)\n                (unless (gethash node visited)\n                  (setf (gethash node visited) t)\n                  (mapc (lambda (edge)\n                           (traverse edge))\n                         (gethash node edge-tab)))))\n        (traverse node))\n     visited))\n```", "```\n> `(time (dotimes (i 100)`\n                 `(get-connected-hash 1 (hash-edges (make-edge-list)))))`\nReal time: 1.221269 sec.\nRun time: 1.224076 sec.\nSpace: 33096264 Bytes\nGC: 36, GC time: 0.10801 sec. :\n```", "```\n> `(defstruct person`\n             `name`\n             `age`\n             `waist-size`\n             `favorite-color)`\nPERSON\n```", "```\n> `(defparameter *bob* (make-person :name \"Bob\"`\n                                   `:age 35`\n                                   `:waist-size 32`\n                                   `:favorite-color \"blue\"))`\n*BOB*\n```", "```\n> `*bob*`\n#S(PERSON :NAME \"Bob\" :AGE 35 :WAIST-SIZE 32 :FAVORITE-COLOR \"blue\")\n```", "```\n> `(person-age *bob*)`\n35\n```", "```\n> `(setf (person-age *bob*) 36)`\n36\n```", "```\n > `(defparameter *that-guy* #S(person :name`\n `\"Bob\" :age 35 :waist-size 32 :favorite-color \"blue\"))`\n `> (person-age *that-guy*)`\n  35\n```", "```\n> `(defun make-person (name age waist-size favorite-color)`\n        `(list name age waist-size favorite-color))`\n  MAKE-PERSON\n  > `(defun person-age (person)`\n        `(cadr person))`\n  PERSON-AGE\n  > `(defparameter *bob* (make-person \"bob\" 35 32 \"blue\"))`\n  *BOB*\n  > `*bob*`\n (\"bob\" 35 32 \"blue\")\n  > `(person-age *bob*)`\n  35\n```", "```\n> `(length '(a b c))`\n3\n> `(length \"blub\")`\n4\n> `(length (make-array 5))`\n5\n```", "```\n > `(find-if #'numberp '(a b 5 d))`\n  5\n > `(count #\\s \"mississippi\")`\n  4\n > `(position #\\4 \"2kewl4skewl\")`\n  5\n > `(some #'numberp '(a b 5 d))`\n  T\n > `(every #'numberp '(a b 5 d))`\n  NIL\n```", "```\n> `(reduce #'+ '(3 4 6 5 2))`\n20\n```", "```\n > `(reduce (lambda (best item)`\n             `(if (and (evenp item) (> item best))`\n                 `item`\n               `best))`\n            `'(7 4 6 5 2)`\n           `:initial-value 0)`\n  6\n```", "```\n> `(reduce (lambda (best item)`\n            `(if (and (evenp item) (> item best))`\n                `item`\n              `best))`\n          `'(7 4 6 5 2))`\n7\n```", "```\n> `(defun sum (lst)`\n     `(reduce #'+ lst))`\nSUM\n> `(sum '(1 2 3))`\n6\n> `(sum (make-array 5 :initial-contents '(1 2 3 4 5)))`\n15\n> `(sum \"blablabla\")`\nError: The value #\\b is not of type NUMBER.\n```", "```\n > `(map 'list`\n         `(lambda (x)`\n            `(if (eq x #\\s)`\n                 `#\\S`\n                 `x))`\n         `\"this is a string\")`\n (#\\t #\\h #\\i #\\S #\\  #\\i #\\S #\\  #\\a #\\  #\\S #\\t #\\r #\\i #\\n #\\g)\n```", "```\n> `(subseq \"america\" 2 6)`\n\"eric\"\n```", "```\n> `(sort '(5 8 2 4 9 3 6) #'<)`\n(2 3 4 5 6 8 9)\n```", "```\n> `(numberp 5)`\nT\n```", "```\n> `(defun add (a b)`\n     `(cond ((and (numberp a) (numberp b)) (+ a b))`\n           `((and (listp a) (listp b)) (append a b))))`\nADD\n> `(add 3 4)`\n7\n> `(add '(a b) '(c d))`\n(A B C D)\n```", "```\n> `(defmethod add ((a number) (b number))`\n     `(+ a b))`\nADD\n> `(defmethod add ((a list) (b list))`\n     `(append a b))`\nADD\n> `(add 3 4)`\n7\n> `(add '(a b) '(c d))`\n(A B C D)\n```", "```\n(defparameter *player-health* nil)\n(defparameter *player-agility* nil)\n(defparameter *player-strength* nil)\n```", "```\n(defparameter *monsters* nil)\n(defparameter *monster-builders* nil)\n(defparameter *monster-num* 12)\n```", "```\n(defun orc-battle ()\n   (init-monsters)\n    (init-player)\n   (game-loop)\n   (when (player-dead)\n      (princ \"You have been killed. Game Over.\"))\n   (when (monsters-dead)\n      (princ \"Congratulations! You have vanquished all of your foes.\")))\n```", "```\n(defun game-loop ()\n    (unless (or (player-dead) (monsters-dead))\n     (show-player)\n     (dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))\n        (unless (monsters-dead)\n          (show-monsters)\n          (player-attack)))\n      (fresh-line)\n     (map 'list\n           (lambda(m)\n             (or (monster-dead m) (monster-attack m)))\n           *monsters*)\n     (game-loop)))\n```", "```\n> `(dotimes (i 3)`\n      `(fresh-line)`\n      `(princ i)`\n      `(princ \". Hatchoo!\"))`\n0\\. Hatchoo!\n1\\. Hatchoo!\n2\\. Hatchoo!\n```", "```\n(defun init-player ()\n    (setf *player-health* 30)\n    (setf *player-agility* 30)\n    (setf *player-strength* 30))\n\n(defun player-dead ()\n    (<= *player-health* 0))\n\n(defun show-player ()\n    (fresh-line)\n    (princ \"You are a valiant knight with a health of \")\n    (princ *player-health*)\n    (princ \", an agility of \")\n    (princ *player-agility*)\n    (princ \", and a strength of \")\n    (princ *player-strength*))\n```", "```\n(defun player-attack ()\n    (fresh-line)\n   (princ \"Attack style: [s]tab [d]ouble swing [r]oundhouse:\")\n   (case (read)\n    (s (monster-hit (pick-monster)\n                      (+ 2 (randval (ash *player-strength* −1)))))\n    (d (let ((x (randval (truncate (/ *player-strength* 6)))))\n             (princ \"Your double swing has a strength of \")\n             (princ x)\n             (fresh-line)\n            (monster-hit (pick-monster) x)\n             (unless (monsters-dead)\n              (monster-hit (pick-monster) x))))\n    (otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))\n                  (unless (monsters-dead)\n                   (monster-hit (random-monster) 1))))))\n```", "```\n(defun randval (n)\n  (1+ (random (max 1 n))))\n```", "```\n> `(dotimes (i 10)`\n     `(princ (random 5))`\n     `(princ \" \"))`\n1 2 2 4 0 4 2 4 2 3\n```", "```\n(defun random-monster ()\n   (let ((m (aref *monsters* (random (length *monsters*)))))\n      (if (monster-dead m)\n         (random-monster)\n         m)))\n```", "```\n(defun pick-monster ()\n    (fresh-line)\n   (princ \"Monster #:\")\n   (let ((x (read)))\n     (if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))\n          (progn (princ \"That is not a valid monster number.\")\n                 (pick-monster))\n         (let ((m (aref *monsters* (1- x))))\n           (if (monster-dead m)\n                (progn (princ \"That monster is alread dead.\")\n                       (pick-monster))\n               m)))))\n```", "```\n(defun init-monsters ()\n    (setf *monsters*\n         (map 'vector\n               (lambda (x)\n                (funcall (nth (random (length *monster-builders*))\n                          *monster-builders*)))\n              (make-array *monster-num*))))\n```", "```\n(defun monster-dead (m)\n  (<= (monster-health m) 0))\n\n(defun monsters-dead ()\n  (every #'monster-dead *monsters*))\n```", "```\n(defun show-monsters ()\n    (fresh-line)\n    (princ \"Your foes:\")\n   (let ((x 0))\n     (map 'list\n           (lambda (m)\n               (fresh-line)\n               (princ \"   \")\n              (princ (incf x))\n               (princ \". \")\n               (if (monster-dead m)\n                  (princ \"**dead**\")\n                   (progn (princ \"(Health=\")\n                         (princ (monster-health m))\n                          (princ \") \")\n                         (monster-show m))))\n           *monsters*)))\n```", "```\n(defstruct monster (health (randval 10)))\n```", "```\n> `(make-monster)`\n#S(MONSTER :HEALTH 7)\n> `(make-monster)`\n#S(MONSTER :HEALTH 2)\n> `(make-monster)`\n#S(MONSTER :HEALTH 5)\n```", "```\n(defmethod monster-hit (m x)\n   (decf (monster-health m) x)\n    (if (monster-dead m)\n        (progn (princ \"You killed the \")\n              (princ (type-of m))\n               (princ \"! \"))\n        (progn (princ \"You hit the \")\n              (princ (type-of m))\n               (princ \", knocking off \")\n               (princ x)\n               (princ \" health points! \"))))\n```", "```\n> `(type-of 'foo)`\nSYMBOL\n> `(type-of 5)`\nINTEGER\n> `(type-of \"foo\")`\nARRAY\n> `(type-of (make-monster))`\nMONSTER\n```", "```\n(defmethod monster-show (m)\n  (princ \"A fierce \")\n  (princ (type-of m)))\n\n(defmethod monster-attack (m))\n```", "```\n(defstruct (orc (:include monster)) (club-level (randval 8)))\n(push #'make-orc *monster-builders*)\n```", "```\n(defmethod monster-show ((m orc))\n    (princ \"A wicked orc with a level \")\n   (princ (orc-club-level m))\n    (princ \" club\"))\n\n  (defmethod monster-attack ((m orc))\n   (let ((x (randval (orc-club-level m))))\n         (princ \"An orc swings his club at you and knocks off \")\n         (princ x)\n         (princ \" of your health points. \")\n         (decf *player-health* x)))\n```", "```\n(defstruct (hydra (:include monster)))\n  (push #'make-hydra *monster-builders*)\n\n  (defmethod monster-show ((m hydra))\n    (princ \"A malicious hydra with \")\n   (princ (monster-health m))\n    (princ \" heads.\"))\n\n  (defmethod monster-hit ((m hydra) x)\n   (decf (monster-health m) x)\n    (if (monster-dead m)\n        (princ \"The corpse of the fully decapitated and decapacitated\n hydra falls to the floor!\")\n       (progn (princ \"You lop off \")\n               (princ x)\n               (princ \" of the hydra's heads! \"))))\n\n  (defmethod monster-attack ((m hydra))\n    (let ((x (randval (ash (monster-health m) −1))))\n      (princ \"A hydra attacks you with \")\n      (princ x)\n      (princ \" of its heads! It also grows back one more head! \")\n     (incf (monster-health m))\n      (decf *player-health* x)))\n```", "```\n(defstruct (slime-mold (:include monster)) (sliminess (randval 5)))\n  (push #'make-slime-mold *monster-builders*)\n\n  (defmethod monster-show ((m slime-mold))\n    (princ \"A slime mold with a sliminess of \")\n    (princ (slime-mold-sliminess m)))\n\n  (defmethod monster-attack ((m slime-mold))\n   (let ((x (randval (slime-mold-sliminess m))))\n         (princ \"A slime mold wraps around your legs and decreases your agility by \")\n         (princ x)\n         (princ \"! \")\n        (decf *player-agility* x)\n        (when (zerop (random 2))\n           (princ \"It also squirts in your face, taking away a health point! \")\n          (decf *player-health*))))\n```", "```\n(defstruct (brigand (:include monster)))\n  (push #'make-brigand *monster-builders*)\n\n  (defmethod monster-attack ((m brigand))\n   (let ((x (max *player-health* *player-agility* *player-strength*)))\n     (cond ((= x *player-health*)\n             (princ \"A brigand hits you with his slingshot,\n taking off 2 health points! \")\n             (decf *player-health* 2))\n           ((= x *player-agility*)\n             (princ \"A brigand catches your leg with his whip,\n taking off 2 agility points! \")\n             (decf *player-agility* 2))\n           ((= x *player-strength*)\n             (princ \"A brigand cuts your arm with his whip,\n taking off 2 strength points! \")\n             (decf *player-strength* 2)))))\n```", "```\n> `(orc-battle)`\nYou are a valiant knight with a health of 30, an agility of 30, and a strength of 30\nYour foes:\n   1\\. (Health=10) A wicked orc with a level 5 club\n   2\\. (Health=3) A malicious hydra with 3 heads.\n   3\\. (Health=9) A fierce BRIGAND\n   4\\. (Health=3) A malicious hydra with 3 heads.\n   5\\. (Health=3) A wicked orc with a level 2 club\n   6\\. (Health=7) A malicious hydra with 7 heads.\n   7\\. (Health=6) A slime mold with a sliminess of 2\n   8\\. (Health=5) A wicked orc with a level 2 club\n   9\\. (Health=9) A fierce BRIGAND\n   10\\. (Health=2) A wicked orc with a level 6 club\n   11\\. (Health=7) A wicked orc with a level 4 club\n   12\\. (Health=8) A slime mold with a sliminess of 2\n```", "```\nAttack style: [s]tab [d]ouble swing [r]oundhouse:`s`\nMonster #:`6`\nThe corpse of the fully decapitated and decapacitated hydra falls to the floor!\nYour foes:\n   1\\. (Health=10) A wicked orc with a level 5 club\n   2\\. (Health=3) A malicious hydra with 3 heads.\n   3\\. (Health=9) A fierce BRIGAND\n   4\\. (Health=3) A malicious hydra with 3 heads.\n   5\\. (Health=3) A wicked orc with a level 2 club\n   6\\. **dead**\n   7\\. (Health=6) A slime mold with a sliminess of 2\n   8\\. (Health=5) A wicked orc with a level 2 club\n   9\\. (Health=9) A fierce BRIGAND\n   10\\. (Health=2) A wicked orc with a level 6 club\n   11\\. (Health=7) A wicked orc with a level 4 club\n   12\\. (Health=8) A slime mold with a sliminess of 2\n```", "```\nAttack style: [s]tab [d]ouble swing [r]oundhouse:`r`\nYou hit the SLIME-MOLD,\n knocking off 1 health points! You hit the SLIME-MOLD, knocking off 1 health points!\n You hit the ORC, knocking off 1 health points! You lop off 1 of the hydra's heads!\n You lop off 1 of the hydra's heads! You lop off 1 of the hydra's heads! You hit the\n ORC, knocking off 1 health points! The corpse of the fully decapitated and decapaci\ntated hydra falls to the floor! You hit the ORC, knocking off 1 health points! You hit\n the ORC, knocking off 1 health points! You hit the ORC, knocking off 1 health points!\nYour foes:\n   1\\. (Health=9) A wicked orc with a level 5 club\n   2\\. (Health=2) A malicious hydra with 2 heads.\n   3\\. (Health=9) A fierce BRIGAND\n   4\\. **dead**\n   5\\. (Health=2) A wicked orc with a level 2 club\n   6\\. **dead**\n   7\\. (Health=4) A slime mold with a sliminess of 2\n   8\\. (Health=3) A wicked orc with a level 2 club\n   9\\. (Health=9) A fierce BRIGAND\n   10\\. (Health=2) A wicked orc with a level 6 club\n   11\\. (Health=6) A wicked orc with a level 4 club\n   12\\. (Health=8) A slime mold with a sliminess of 2\n```", "```\nAttack style: [s]tab [d]ouble swing [r]oundhouse:`d`\nYour double swing has a strength of 3\nMonster #:8\nYou killed the ORC!\nMonster #:10\nYou killed the ORC!\nAn orc swings his club at you and knocks off 5 of your health points. A hydra\n attacks you with 1 of its heads! It also grows back one more head! A\nbrigand catches your leg with his whip, taking off 2 agility points! An orc\n swings his club at you and knocks off 1 of your health points. A slime mold wraps\n around your legs and decreases your agility by 2! It also squirts in your face,\n taking away a health point! A brigand cuts your arm with his whip, taking off 2\n strength points! An orc swings his club at you and knocks off 1 of your health\n points. A slime mold wraps around your legs and decreases your agility by 1!\nYou are a valiant knight with a health of 21, an agility of 25, and a strength of 28\nYour foes:\n   1\\. (Health=9) A wicked orc with a level 5 club\n   2\\. (Health=3) A malicious hydra with 3 heads.\n   3\\. (Health=9) A fierce BRIGAND\n   4\\. **dead**\n   5\\. (Health=2) A wicked orc with a level 2 club\n   6\\. **dead**\n   7\\. (Health=4) A slime mold with a sliminess of 2\n   8\\. **dead**\n   9\\. (Health=9) A fierce BRIGAND\n   10\\. **dead**\n   11\\. (Health=6) A wicked orc with a level 4 club\n   12\\. (Health=8) A slime mold with a sliminess of 2\n```"]