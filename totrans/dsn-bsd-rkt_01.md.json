["```\ntypedef int (*modeventhand_t)(module_t, int /* modeventtype_t */, void *);\n\n```", "```\ntypedef enum modeventtype {\n        MOD_LOAD,       /* Set when module is loaded. */\n        MOD_UNLOAD,     /* Set when module is unloaded. */\n        MOD_SHUTDOWN,   /* Set on shutdown. */\n        MOD_QUIESCE     /* Set on quiesce. */\n} modeventtype_t;\n\n```", "```\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"Hello, world!\\n\");\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"Good-bye, cruel world!\\n\");\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n\n        }\n\n        return(error);\n}\n\n```", "```\n#define DECLARE_MODULE(name, data, sub, order)                          \\\n        MODULE_METADATA(_md_##name, MDT_MODULE, &data, #name);          \\\n        SYSINIT(name##module, sub, order, module_register_init, &data)  \\\n        struct __hack\n\n```", "```\ntypedef struct moduledata {\n        const char      *name;          /* module name */\n        modeventhand_t  evhand;         /* event handler */\n        void            *priv;          /* extra data */\n} moduledata_t;\n\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"Hello, world!\\n\");\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"Good-bye, cruel world!\\n\");\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n\n}\n\n/* The second argument of DECLARE_MODULE. */\nstatic moduledata_t hello_mod = {\n        \"hello\",        /* module name */\n        load,           /* event handler */\n        NULL            /* extra data */\n\n};\n\nDECLARE_MODULE(hello, hello_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\nKMOD=   hello           # Name of KLD to build.\nSRCS=   hello.c         # List of source files.\n\n.include <bsd.kmod.mk>\n\n```", "```\n$ `make`\nWarning: Object directory not changed from original /usr/home/ghost/hello\n@ -> /usr/src/sys\nmachine -> /usr/src/sys/i386/include\ncc -O2 -pipe -funroll-loops -march=athlon-mp -fno-strict-aliasing -Werror -D_\nKERNEL -DKLD_MODULE -nostdinc -I-   -I. -I@ -I@/contrib/altq -I@/../include -\nI/usr/include -finline-limit=8000 -fno-common  -mno-align-long-strings -mpref\nerred-stack-boundary=2  -mno-mmx -mno-3dnow -mno-sse -mno-sse2 -ffreestanding\n -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prot\notypes -Wpointer-arith -Winline -Wcast-qual  -fformat-extensions -std=c99 -c\nhello.c\nld  -d -warn-common -r -d -o hello.kld hello.o\ntouch export_syms\nawk -f /sys/conf/kmod_syms.awk hello.kld  export_syms | xargs -J% objcopy % h\nello.kld\nld -Bshareable  -d -warn-common -o hello.ko hello.kld\nobjcopy --strip-debug hello.ko\n$ `ls -F`\n@@           export_syms  hello.kld    hello.o\nMakefile     hello.c      hello.ko*    machine@\n\n```", "```\n$ `sudo kldload ./hello.ko`\nHello, world!\n$ `sudo kldunload hello.ko`\nGood-bye, cruel world!\n\n```", "```\ntypedef int     sy_call_t(struct thread *, void *);\n\n```", "```\n❶struct sc_example_args {\n        char *str;\n};\n\nstatic int\nsc_example(struct thread *td, void *syscall_args)\n{\n         ❷struct sc_example_args *uap;\n         ❸uap = (struct sc_example_args *)syscall_args;\n\n        printf(\"%s\\n\", uap->str);\n\n        return(0);\n\n}\n\n```", "```\nstruct sysent {\n        int sy_narg;            /* number of arguments */\n        sy_call_t *sy_call;     /* implementing function */\n        au_event_t sy_auevent;  /* audit event associated with system call */\n\n};\n\n```", "```\nstatic struct sysent sc_example_sysent = {\n        1,                      /* number of arguments */\n        sc_example              /* implementing function */\n};\n\n```", "```\nextern struct sysent sysent[];\n\n```", "```\nstatic int offset = NO_SYSCALL;\n\n```", "```\n#define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)     \\\nstatic struct syscall_module_data name##_syscall_mod = {       \\\n       evh, arg, offset, new_sysent, { 0, NULL }               \\\n};                                                             \\\n                                                               \\\nstatic moduledata_t name##_mod = {                             \\\n       #name,                                                  \\\n       syscall_module_handler,                                 \\\n       &name##_syscall_mod                                 \\\n};                                                             \\\nDECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n/* The system call's arguments. */\nstruct sc_example_args {\n        char *str;\n\n};\n\n/* The system call function. */\nstatic int\nsc_example(struct thread *td, void *syscall_args)\n{\n        struct sc_example_args *uap;\n        uap = (struct sc_example_args *)syscall_args;\n\n        printf(\"%s\\n\", uap->str);\n\n        return(0);\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent sc_example_sysent = {\n        1,                      /* number of arguments */\n        sc_example              /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nSYSCALL_MODULE(sc_example, &offset, &sc_example_sysent, load, NULL);\n\n```", "```\n$ `sudo kldload ./sc_example.ko`\nSystem call loaded at offset 210.\n\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n\nint\nmodfind(const char *modname);\n\n```", "```\n#include <sys/param.h>\n#include <sys/module.h>\n\nint\nmodstat(int modid, struct module_stat *stat);\n\n```", "```\nstruct module_stat {\n        int             version;\n        char            name[MAXMODNAME];       /* module name */\n        int             refs;                   /* number of references */\n        int             id;                     /* module id number */\n        modspecific_t   data;                   /* module specific data */\n};\ntypedef union modspecific {\n        int             intval;                 /* offset value */\n        u_int           uintval;\n        long            longval;\n        u_long          ulongval;\n} modspecific_t;\n\n```", "```\n#include <sys/syscall.h>\n#include <unistd.h>\n\nint\nsyscall(int number, ...);\n\n```", "```\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/module.h>\n\nint\nmain(int argc, char *argv[])\n{\n        int syscall_num;\n        struct module_stat stat;\n        if (argc != 2) {\n                printf(\"Usage:\\n%s <string>\\n\", argv[0]);\n                exit(0);\n        }\n\n        /* Determine sc_example's offset value. */\n        stat.version = sizeof(stat);\n        ❶modstat(modfind(\"sc_example\"), &stat);\n        syscall_num = stat.data.intval;\n\n        /* Call sc_example. */\n        return(syscall(❷syscall_num, argv[1]));\n}\n\n```", "```\n$ `./interface Hello,\\ kernel!`\n$ `dmesg | tail -n 1`\nHello, kernel!\n\n```", "```\n$ `sudo kldload ./sc_example.ko`\nSystem call loaded at offset 210.\n$ `perl -e '$str = \"Hello, kernel!\";' -e 'syscall(210, $str);'`\n$ `dmesg | tail -n 1`\nHello, kernel!\n\n```", "```\n#include <sys/types.h>\n#include <sys/systm.h>\n\nint\ncopyin(const void *uaddr, void *kaddr, size_t len);\n\nint\ncopyinstr(const void *uaddr, void *kaddr, size_t len, size_t *done);\n\n```", "```\n#include <sys/types.h>\n#include <sys/systm.h>\n\nint\ncopyout(const void *kaddr, void *uaddr, size_t len);\n\n```", "```\n#include <sys/types.h>\n#include <sys/systm.h>\n\nint\ncopystr(const void *kfaddr, void *kdaddr, size_t len, size_t *done);\n\n```", "```\nstruct cdevsw {\n        int                     d_version;\n        u_int                   d_flags;\n        const char              *d_name;\n        d_open_t                *d_open;\n        d_fdopen_t              *d_fdopen;\n        d_close_t               *d_close;\n        d_read_t                *d_read;\n        d_write_t               *d_write;\n        d_ioctl_t               *d_ioctl;\n        d_poll_t                *d_poll;\n        d_mmap_t                *d_mmap;\n        d_strategy_t            *d_strategy;\n        dumper_t                *d_dump;\n        d_kqfilter_t            *d_kqfilter;\n        d_purge_t               *d_purge;\n        d_spare2_t              *d_spare2;\n        uid_t                   d_uid;\n        gid_t                   d_gid;\n        mode_t                  d_mode;\n        const char              *d_kind;\n\n        /* These fields should not be messed with by drivers */\n        LIST_ENTRY(cdevsw)      d_list;\n        LIST_HEAD(, cdev)       d_devs;\n        int                     d_spare3;\n        struct cdevsw           *d_gianttrick;\n};\n\n```", "```\nstatic struct cdevsw cd_example_cdevsw = {\n        .d_version =    D_VERSION,\n        .d_open =       open,\n        .d_close =      close,\n        .d_read =       read,\n        .d_write =      write,\n        .d_name =       \"cd_example\"\n};\n\n```", "```\n/* Function prototype. */\nd_write_t       write;\n\nint\nwrite(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n        error = copyinstr(uio->uio_iov->iov_base, &buf, 512, &len);\n        if (error != 0)\n                uprintf(\"Write to \\\"cd_example\\\" failed.\\n\");\n        return(error);\n}\n\n```", "```\nstatic struct cdev *sdev;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n        switch (cmd) {\n\n        case MOD_LOAD:\n                sdev = make_dev(&cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, \"cd_example\");\n                uprintf(\"Character device loaded\\n\");\n                break;\n\n        case MOD_UNLOAD:\n                destroy_dev(sdev);\n                uprintf(\"Character device unloaded\\n\");\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n        return(error);\n}\n\n```", "```\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n\n/* Function prototypes. */\nd_open_t        open;\nd_close_t       close;\nd_read_t        read;\nd_write_t       write;\n\nstatic struct cdevsw cd_example_cdevsw = {\n        .d_version =    D_VERSION,\n        .d_open =       open,\n        .d_close =      close,\n        .d_read =       read,\n        .d_write =      write,\n        .d_name =       \"cd_example\"\n};\n\nstatic char buf[512+1];\nstatic size_t len;\n\nint\nopen(struct cdev *dev, int flag, int otyp, struct thread *td)\n{\n        /* Initialize character buffer. */\n        memset(&buf, '\\0', 513);\n        len = 0;\n\n        return(0);\n}\n\nint\nclose(struct cdev *dev, int flag, int otyp, struct thread *td)\n{\n        return(0);\n}\n\nint\nwrite(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n\n        /*\n         * Take in a character string, saving it in buf.\n         * Note: The proper way to transfer data between buffers and I/O\n         * vectors that cross the user/kernel space boundary is with\n         * uiomove(), but this way is shorter. For more on device driver I/O\n         * routines, see the uio(9) manual page.\n         */\n        error = copyinstr(uio->uio_iov->iov_base, &buf, 512, &len);\n        if (error != 0)\n                uprintf(\"Write to \\\"cd_example\\\" failed.\\n\");\n\n        return(error);\n}\n\nint\nread(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n\n        if (len <= 0)\n                error = −1;\n        else\n                /* Return the saved character string to userland. */\n                copystr(&buf, uio->uio_iov->iov_base, 513, &len);\n\n        return(error);\n}\n\n/* Reference to the device in DEVFS. */\nstatic struct cdev *sdev;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                sdev = make_dev(&cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, \"cd_example\");\n                uprintf(\"Character device loaded.\\n\");\n                break;\n\n        case MOD_UNLOAD:\n                destroy_dev(sdev);\n                uprintf(\"Character device unloaded.\\n\");\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\nDEV_MODULE(cd_example, load, NULL);\n\n```", "```\n#define DEV_MODULE(name, evh, arg)                                      \\\nstatic moduledata_t name##_mod = {                                      \\\n    #name,                                                              \\\n    evh,                                                                \\\n    arg                                                                 \\\n};                                                                      \\\nDECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)\n\n```", "```\n#include <stdio.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <string.h>\n#include <sys/types.h>\n\n#define CDEV_DEVICE     \"cd_example\"\nstatic char buf[512+1];\n\nint\nmain(int argc, char *argv[])\n{\n        int kernel_fd;\n        int len;\n\n        if (argc != 2) {\n                printf(\"Usage:\\n%s <string>\\n\", argv[0]);\n                exit(0);\n        }\n\n        /* Open cd_example. */\n        if ((kernel_fd = open(\"/dev/\" CDEV_DEVICE, O_RDWR)) == −1) {\n                perror(\"/dev/\" CDEV_DEVICE);\n                exit(1);\n        }\n\n        if ((len = strlen(argv[1]) + 1) > 512) {\n                printf(\"ERROR: String too long\\n\");\n                exit(0);\n        }\n\n        /* Write to cd_example. */\n        if (write(kernel_fd, argv[1], len) == −1)\n                perror(\"write()\");\n        else\n                printf(\"Wrote \\\"%s\\\" to device /dev/\" CDEV_DEVICE \".\\n\",\n                    argv[1]);\n\n        /* Read from cd_example. */\n        if (read(kernel_fd, buf, len) == −1)\n                perror(\"read()\");\n        else\n                printf(\"Read \\\"%s\\\" from device /dev/\" CDEV_DEVICE \".\\n\",\n                    buf);\n\n        /* Close cd_example. */\n        if ((close(kernel_fd)) == −1) {\n                perror(\"close()\");\n                exit(1);\n        }\n\n        exit(0);\n}\n\n```", "```\n$ `sudo kldload ./cd_example.ko`\nCharacter device loaded.\n$ `ls -l /dev/cd_example`\ncrw-------  1 root  wheel    0,  89 Mar 26 00:32 /dev/cd_example\n$ `./interface`\nUsage:\n./interface <string>\n$ `sudo ./interface Hello,\\ kernel!`\nWrote \"Hello, kernel!\" to device /dev/cd_example.\nRead \"Hello, kernel!\" from device /dev/cd_example.\n\n```", "```\n$ `kldstat`\nId Refs Address    Size     Name\n 1    4 0xc0400000 63070c   kernel\n 2   16 0xc0a31000 568dc    acpi.ko\n 3    1 0xc1e8b000 2000     hello.ko\n\n```", "```\n$ `kldstat -v`\nId Refs Address    Size     Name\n 1    4 0xc0400000 63070c   kernel\n        Contains modules:\n                Id Name\n                18 xpt\n                19 probe\n                20 cam\n. . .\n 3    1 0xc1e8b000 2000     hello.ko\n        Contains modules:\n                Id Name\n                367 hello\n\n```"]