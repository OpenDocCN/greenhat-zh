- en: Appendix A. How Does Ruby Compare to Other Languages?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways to describe something is to talk about what it isn’t. This
    appendix describes similarities and differences between Ruby and some other popular
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though it isn’t the oldest language around, *C* is the granddaddy of languages
    in many programmers’ minds. For the purposes of this discussion, we’ll be focusing
    more on the differences between Ruby and C than the similarities. C is *procedural*,
    meaning that its programs are intended to be thought of as sets of instructions
    that proceed stepwise through time: *Do this, then do this, then do that*. C is
    neither object oriented nor functional, although the closely related languages
    C++ and Objective C are object oriented. C undeniably has *functions*, bits of
    reusable code that accept various inputs and return various outputs, but they
    are generally not *purely functional* functions. C functions often depend on information
    other than the strict inputs to the function, and they have side effects that
    mean the second call to a given function will not necessarily produce the same
    result as the first call. C functions often return values indicating their success,
    relying on side effects to accomplish their main purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: C’s advantages over Ruby include execution speed, greater familiarity to more
    people, more widespread deployment, and the additional benefits that come from
    its code being compiled, rather than interpreted. (Note that compiled versus interpreted
    is its own holy war.) When a C program compiles, you know it has passed at least
    one specific benchmark of reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s advantages over C include a faster development cycle, flexibility, conceptual
    elegance, and configurability. If you are interested in combining the strengths
    of both Ruby and C, you can start by exploring the RubyInline project, available
    as the `rubyinline` gem or at [http://www.zenspider.com/ZSS/Products/RubyInline](http://www.zenspider.com/ZSS/Products/RubyInline).^([[38](#ftn.APP-A-FNOTE-1)])
  prefs: []
  type: TYPE_NORMAL
- en: C also has what is called *strong, static typing*. This means that variables
    in C are defined to be a certain type of data (the integer 42, for example), and
    they will always remain that type of data. That’s the static part. If you wanted
    to express the integer 42 as a floating-point number, such as 42.0, you would
    need to pass it through a casting conversion function. Ruby is also strongly typed
    (requiring programmers to convert integers to floating-point numbers before using
    them that way), although it is *dynamic*, meaning that variables can change type.
    C also lacks anything similar to Ruby’s irb.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#APP-A-FNOTE-1)]) I was lucky enough to see a demonstration of RubyInline
    by its author, Ryan Davis, at the 2005 RubyConf. It’s a very impressive piece
    of code, and I highly recommend it to anyone interested in combining Ruby and
    C.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that Haskell is included in this listing of languages indicates how
    important the functional paradigm is to this book. *Haskell* is a purely functional
    language designed by committee and released in 1998\. It has several fascinating
    features, most notably *lazy evaluation*, whereby the value of a given piece of
    data does not need to be known (or even meaningful) until it needs to be used.
    This allows a programmer to define things in terms of infinite series, such as
    the set of all integers.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell is the language used for *Pugs*, an implementation of the new Perl 6
    language, which some people think is drawing more attention to Haskell than to
    Perl itself. Haskell has an interactive environment similar to Ruby’s irb, but
    it doesn’t allow function definitions except in external files that are imported,
    whereas irb allows full definitions for classes, methods, and functions. Like
    C, Haskell has both strong and static typing. Haskell is an excellent language
    that’s very suitable for teaching purely functional techniques, as well as general-purpose
    programming. You can read more about it at [http://haskell.org](http://haskell.org).
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purposes of this discussion, Sun Microsystems’ *Java* is a moderately
    complex, object-oriented language similar to C. Java has both strong and static
    typing. In one way, Java is more object oriented than Ruby is: A programmer coding
    in Java must use an object-oriented paradigm for his own programs. On the other
    hand, Java is less object oriented than Ruby is in the way that it implements
    its own built-in features. For example, to get the absolute value of the integer
    100 in Java, you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the programmer wants to use a method called `abs`, which is
    associated with Math, to perform that method’s action on the integer 100\. The
    equivalent operation in Ruby would be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Ruby’s methodology, the programmer simply asks the number 100 to report
    its own absolute value. This approach is common in Ruby, and it assumes that every
    piece of data knows the best way to deal with operations on itself. An advantage
    of this is that the same symbol can be used for different (but conceptually related)
    operations. The `+` sign signifies simple addition for numbers, for example, while
    signifying concatenation for strings, as discussed in [Chapter 1](ch01.html "Chapter 1. Interactive
    Ruby and the Ruby Environment").
  prefs: []
  type: TYPE_NORMAL
- en: Java is also compiled, rather than interpreted, generally using a special type
    of compilation called *bytecode*, which is the same method that projects like
    Parrot, Python, and Ruby 2.0 use.^([[39](#ftn.APP-A-FNOTE-2)]) There is also an
    interesting project called JRuby ([http://jruby.codehaus.org](http://jruby.codehaus.org)),
    which is an implementation of Ruby written in Java. Java is described in greater
    detail at [http://java.sun.com](http://java.sun.com). The Java specification was
    written by Guy Steele, although he didn’t create the language itself (fellow Lisper
    James Gosling did). When he wrote the Java specification, Steele already had the
    distinction of being the co-creator of Scheme, arguably the most conceptually
    pure version of Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#APP-A-FNOTE-2)]) You can read more about Parrot at [http://www.parrotcode.org](http://www.parrotcode.org);
    I’ll cover Python later in this appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As one of Ruby’s most prominent ancestors, *Lisp* deserves some space in this
    section. Lisp has been called “the most intelligent way to misuse a computer.”^([[40](#ftn.APP-A-FNOTE-3)])
    It is properly understood as a family of languages or a language specification,
    rather than a single language. It is also diverse enough to resist many classification
    attempts, but for our purposes, the Lisps can be thought of mainly as functional
    languages with weak, dynamic typing. Renowned Lisper Paul Graham describes “What
    Made Lisp Different” at [http://paulgraham.com/diff.html](http://paulgraham.com/diff.html),
    and it’s interesting to note that Ruby shares all of these features except for
    Lisp’s peculiar syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Lisp’s syntax (or lack thereof) is probably its most noteworthy feature, at
    first glance. Lisp code consists of bits of data bound by opening and closing
    parentheses. These bits are called *lists*, and they give Lisp its name (which
    comes from *LISt Processing*).^([[41](#ftn.APP-A-FNOTE-4)]) Having a syntax that
    is representable as a data structure within the language itself is Lisp’s most
    defining characteristic. Arguably, another language that implemented this same
    feature would not be a distinct language per se, but rather another dialect of
    Lisp.^([[42](#ftn.APP-A-FNOTE-5)]) A good argument can be made that Ruby tries
    to take concepts from Lisp and present them within a more user-friendly framework
    that also takes advantage of good ideas from object orientation, as well as good
    text manipulation. Matz has said, “Some may say Ruby is a bad rip-off of Lisp
    or Smalltalk, and I admit that. But it is nicer to ordinary people.”^([[43](#ftn.APP-A-FNOTE-6)])
    Ruby owes much to Lisp, and along with many other languages, it owes much of its
    powerful text manipulation to this next language, Perl.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#APP-A-FNOTE-3)]) Dutch computer science Edsger Dijkstra said this;
    you can find this and other interesting quotes compiled by Paul Graham at [http://www.paulgraham.com/quo.html](http://www.paulgraham.com/quo.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#APP-A-FNOTE-4)]) Critics contend that this feature makes Lisp a more
    appropriate acronym for *Lots of Irritating Superfluous Parentheses*. Larry Wall,
    the creator of Perl, suggested that Lisp code has all the aesthetic appeal of
    “oatmeal with toenail clippings.” Clearly, Lisp has some public relations problems.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#APP-A-FNOTE-5)]) Relatedly, Philip Greenspun’s tenth Rule of Programming
    at [http://philip.greenspun.com/](http://philip.greenspun.com/) research is “Any
    sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified
    bug-ridden slow implementation of half of Common Lisp.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([[43](#APP-A-FNOTE-6)]) This quote also comes from Paul Graham’s website,
    [http://www.paulgraham.com/quotes.html](http://www.paulgraham.com/quotes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Perl* is known by its mantra TMTOWTDI, and it is an extremely flexible and
    utilitarian language—one that has certainly had an impact on both Ruby and programming,
    in general. *TMTOWTDI* stands for *There’s More Than One Way To Do It*, which
    is a design philosophy that Perl certainly exemplifies. Its role in stressing
    the importance of regular expressions is enough to earn it a place in history.
    Perl was invented in 1987 by Larry Wall, and it was primarily intended to perform
    a role similar to that of Unix-centric languages like shell, awk, and sed. Perl
    focuses on ease of use for tasks like Unix system administration, and it is heavily
    used for web applications, as well. Perl’s initial design was procedural, but
    in recent years it has moved in an increasingly functional direction. It can also
    be used for object-oriented programming, a task for which it was never intended
    and for which it is not ideally suited—but the fact that this is even possible
    in Perl is a testament to its flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: A new version of Perl is in the works (see the discussion of Pugs under Haskell),
    and it reminds me a great deal of Ruby. Coming from me, that is a compliment.
    Perl has weak dynamic typing, and like Ruby, it is interpreted. It has been called
    the *swiss army chainsaw* and the *Jeep* of programming languages, and it can
    be found at [http://perl.com](http://perl.com).
  prefs: []
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*PHP* is another interpreted language using weak dynamic typing that is very
    popular for web applications. In fact, some people erroneously believe that PHP
    is only usable for web applications. It is technically a complete, general-purpose
    programming language, although it has several features that make it more popular
    for web work. Many of the languages discussed here can be used in embedded code
    within web pages, provided that the code is marked off from the rest of the page
    with the appropriate tags. PHP is unusual in that it must always be demarcated
    with such tags, even when it is used for command-line tasks that will never come
    near a webserver. It has weak, dynamic typing and is interpreted.'
  prefs: []
  type: TYPE_NORMAL
- en: PHP and Ruby share the characteristic of having a relatively large number of
    built-in functions. Despite PHP’s general applicability, its primary focus is
    undoubtedly on making it easy for relatively inexperienced programmers to generate
    dynamic web content quickly. PHP’s web integration is such an important part of
    its most frequent use (if not its design) that it is often best compared to other
    programming languages when combined with their own web integration systems, such
    Perl and Mason, or Ruby and eRuby or Rails. PHP’s creator Rasmus Lerdorf began
    work on the project that would eventually become PHP in 1995\. You can find out
    more about it at [http://php.net](http://php.net).
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Python* is a language very similar to Ruby. Its creator, the “Benevolent Dictator
    For Life” Guido van Rossum, named it after the British comedy troupe Monty Python
    when he invented it in the early 1990s. It has strong, dynamic typing very similar
    to Ruby’s and a similarly clean syntax, which is aided by its use of semantically
    significant whitespace. In Python, neither functions, blocks of code, nor statements
    need to have an explicit end-of-line mark (often a semicolon). Ruby’s use of ending
    markers is also quite minimal, although not to the same degree as Python’s is.'
  prefs: []
  type: TYPE_NORMAL
- en: One area where Python and Ruby differ significantly is in flexibility. Python
    explicitly embraces the idea of *There should be one—and preferably only one—obvious
    way to do it*, reporting this along with other ideas at Python’s interactive prompt
    when given the command `import this`.
  prefs: []
  type: TYPE_NORMAL
- en: Python and Ruby have an interesting relationship. Python has added several new
    features recently that borrow heavily from Ruby and Lisp, and at the time of this
    writing book sales for Ruby-related books also generally surpass those of Python-related
    books. Obviously, I hope those trends continue in relation to *this* book. Python
    and Ruby seem like contentious siblings who will hopefully continue to challenge
    and inspire each other to excel. The Pythonistas live at [http://python.org](http://python.org).
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Smalltalk* is a fully object-oriented programming language invented at Xerox
    PARC by a team led by Alan Kay. While Simula is generally recognized as the first
    object-oriented language, Smalltalk was instrumental in popularizing object orientation.
    Ruby borrows very extensively from Smalltalk in two major areas: the notion that
    everything is an object, and the concept of methods as messages that are passed
    to objects.'
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean to say that everything is an object? We’ve touched on this
    briefly in the Java discussion. In many languages, real “object” status is reserved
    for larger or more complicated things, while basic parts of the language are not
    considered objects. That’s why coders must invoke the `abs` method from within
    the Math namespace to get the absolute value of the integer 100 in Java. The *Everything
    is an object* idea that Ruby inherited from Smalltalk is what allows the more
    consistent approach of asking the integer 100 to report its own absolute value.
    We explored the benefits of methods being implemented as messages also in the
    `to_lang.rb` script in [Chapter 10](ch10.html "Chapter 10. More Complex Utilities
    and Tricks, Part II").
  prefs: []
  type: TYPE_NORMAL
- en: Check out Smalltalk at [http://smalltalk.org](http://smalltalk.org) and [http://squeak.org](http://squeak.org).
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Ruby vs. Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, Ruby is interpreted, not compiled, making it fast to develop in and
    slow to run. It is object oriented and functional, not procedural. It has strong,
    dynamic typing, instead of either weak or static typing, and it only automatically
    casts type for Boolean tests. It has built-in regular expression support and a
    clean, readable syntax. It is a general-purpose programming language both in theory
    and in practice. It has a very large collection of built-in methods, and it allows
    you to add to, alter, and extend those methods easily. Like its ancestor Lisp,
    Ruby has a real, usable `nil` value, and it treats all values except for `nil`
    and `false` as `true`. Ruby is also very fun to program in, and it stays out of
    your way.
  prefs: []
  type: TYPE_NORMAL
