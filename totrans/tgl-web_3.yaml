- en: Part II. Browser Security Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having reviewed the basic building blocks of the Web, we can now comfortably
    examine all the security features that keep rogue web applications at bay. [Part II](pt02.html
    "Part II. Browser Security Features") of this book takes a look at everything
    from the well-known but often misunderstood same-origin policy to the obscure
    and proprietary zone settings of Internet Explorer. It explains what these mechanisms
    can do for you—and when they tend to fall apart.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Content Isolation Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the security assurances provided by web browsers are meant to isolate
    documents based on their origin. The premise is simple: Two pages from different
    sources should not be allowed to interfere with each other. Actual practice can
    be more complicated, however, as no universal agreement exists about where a single
    document begins and ends or what constitutes a single origin. The result is a
    sometimes unpredictable patchwork of contradictory policies that don’t quite work
    well together but that can’t be tweaked without profoundly affecting all current
    legitimate uses of the Web.'
  prefs: []
  type: TYPE_NORMAL
- en: These problems aside, there is also little clarity about what actions should
    be subject to security checks in the first place. It seems clear that some interactions,
    such as following a link, should be permitted without special restrictions as
    they are essential to the health of the entire ecosystem, and that others, such
    as modifying the contents of a page loaded in a separate window, should require
    a security check. But a large gray area exists between these extremes, and that
    middle ground often feels as if it’s governed more by a roll of the dice than
    by any unified plan. In these murky waters, vulnerabilities such as cross-site
    request forgery (see [Chapter 4](ch04.html "Chapter 4. Hypertext Markup Language"))
    abound.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to start exploring. Let’s roll a die of our own and kick off the journey
    with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Same-Origin Policy for the Document Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *same-origin policy* (*SOP*) is a concept introduced by Netscape in 1995
    alongside JavaScript and the Document Object Model (DOM), just one year after
    the creation of HTTP cookies. The basic rule behind this policy is straightforward:
    Given any two separate JavaScript execution contexts, one should be able to access
    the DOM of the other only if the protocols, DNS names,^([[43](#ftn.CHP-9-FN-1)])
    and port numbers associated with their host documents match exactly. All other
    cross-document JavaScript DOM access should fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol-host-port tuple introduced by this algorithm is commonly referred
    to as *origin*. As a basis for a security policy, this is pretty robust: SOP is
    implemented across all modern browsers with a good degree of consistency and with
    only occasional bugs.^([[44](#ftn.CHP-9-FN-2)]) In fact, only Internet Explorer
    stands out, as it ignores the port number for the purpose of origin checks. This
    practice is somewhat less secure, particularly given the risk of having non-HTTP
    services running on a remote host for HTTP/0.9 web servers (see [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol")). But usually it makes no appreciable
    difference.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.html#outcomes_of_sop_checks "Table 9-1. Outcomes of SOP Checks")
    illustrates the outcome of SOP checks in a variety of situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1. Outcomes of SOP Checks
  prefs: []
  type: TYPE_NORMAL
- en: '| Originating document | Accessed document | Non-IE browser | Internet Explorer
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [http://example.com/a/](http://example.com/a/) | [http://example.com/b/](http://example.com/b/)
    | Access okay | Access okay |'
  prefs: []
  type: TYPE_TB
- en: '| [http://example.com/](http://example.com/) | [http://www.example.com/](http://www.example.com/)
    | Host mismatch | Host mismatch |'
  prefs: []
  type: TYPE_TB
- en: '| [http://example.com/](http://example.com/) | [https://example.com/](https://example.com/)
    | Protocol mismatch | Protocol mismatch |'
  prefs: []
  type: TYPE_TB
- en: '| [http://example.com:81/](http://example.com:81/) | [http://example.com/](http://example.com/)
    | Port mismatch | Access okay |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This same-origin policy was originally meant to govern access only to the DOM
    ; that is, the methods and properties related to the contents of the actual displayed
    document. The policy has been gradually extended to protect other obviously sensitive
    areas of the root JavaScript object, but it is not all-inclusive. For example,
    non-same-origin scripts can usually still call *location.assign()* or *location.replace(...)*
    on an arbitrary window or a frame. The extent and the consequences of these exemptions
    are the subject of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin
    Rules").
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplicity of SOP is both a blessing and a curse. The mechanism is fairly
    easy to understand and not too hard to implement correctly, but its inflexibility
    can be a burden to web developers. In some contexts, the policy is too broad,
    making it impossible to, say, isolate home pages belonging to separate users (short
    of giving each a separate domain). In other cases, the opposite is true: The policy
    makes it difficult for legitimately cooperating sites (say, *login.example.com*
    and *payments.example.com*) to seamlessly exchange data.'
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to fix the first problem—to narrow down the concept of an origin—are
    usually bound to fail because of interactions with other explicit and hidden security
    controls in the browser. Attempts to broaden origins or facilitate cross-domain
    interactions are more common. The two broadly supported ways of achieving these
    goals are *document.domain* and *postMessage(...)*, as discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: document.domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This JavaScript property permits any two cooperating websites that share a
    common top-level domain (such as *example.com*, or even just *.com*) to agree
    that for the purpose of future same-origin checks, they want to be considered
    equivalent. For example, both *login.example.com* and *payments.example.com* may
    perform the following assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Setting this property overrides the usual hostname matching logic during same-origin
    policy checks. The protocols and port numbers still have to match, though; if
    they don’t, tweaking *document.domain* will not have the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: Both parties must explicitly opt in for this feature. Simply because *login.example.com*
    has set its *document.domain* to *example.com* does not mean that it will be allowed
    to access content originating from the website hosted at [http://example.com/](http://example.com/).
    That website needs to perform such an assignment, too, even if common sense would
    indicate that it is a no-op. This effect is symmetrical. Just as a page that sets
    *document.domain* will not be able to access pages that did not, the action of
    setting the property also renders the caller mostly (but not fully!)^([[45](#ftn.CHP-9-FN-3)])
    out of reach of normal documents that previously would have been considered same-origin
    with it. [Table 9-2](ch09.html#outcomes_of_document.domain_checks "Table 9-2. Outcomes
    of document.domain Checks") shows the effects of various values of *document.domain*.
  prefs: []
  type: TYPE_NORMAL
- en: Despite displaying a degree of complexity that hints at some special sort of
    cleverness, *document.domain* is not particularly safe. Its most significant weakness
    is that it invites unwelcome guests. After two parties mutually set this property
    to *example.com*, it is not simply the case that *login.example.com* and *payments.example.com*
    will be able to communicate; *funny-cat-videos.example.com* will be able to jump
    on the bandwagon as well. And because of the degree of access permitted between
    the pages, the integrity of any of the participating JavaScript contexts simply
    cannot be guaranteed to any realistic extent. In other words, touching *document.domain*
    inevitably entails tying the security of your page to the security of the weakest
    link in the entire domain. An extreme case of setting the value to **.com* is
    essentially equivalent to assisted suicide.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2. Outcomes of *document.domain* Checks
  prefs: []
  type: TYPE_NORMAL
- en: '| Originating document | Accessed document | Outcome |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| URL | document.domain | URL | document.domain |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [http://payments.example.com/](http://payments.example.com/)
    | *example.com* | Access okay |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [https://payments.example.com/](https://payments.example.com/)
    | *example.com* | Protocol mismatch |'
  prefs: []
  type: TYPE_TB
- en: '| [http://payments.example.com/](http://payments.example.com/) | *example.com*
    | [http://example.com/](http://example.com/) | **(not set)** | Access denied |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.example.com/](http://www.example.com/) | **(not set)** | [http://www.example.com/](http://www.example.com/)
    | *example.com* | Access denied |'
  prefs: []
  type: TYPE_TB
- en: postMessage(...)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *postMessage(...)* API is an HTML5 extension that permits slightly less
    convenient but remarkably more secure communications between non-same-origin sites
    without automatically giving up the integrity of any of the parties involved.
    Today it is supported in all up-to-date browsers, although because it is fairly
    new, it is not found in Internet Explorer 6 or 7.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism permits a text message of any length to be sent to any window
    for which the sender holds a valid JavaScript handle (see [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts")). Although the same-origin policy has a number
    of gaps that permit similar functionality to be implemented by other means,^([[46](#ftn.CHP-9-FN-4)])
    this one is actually safe to use. It allows the sender to specify what origins
    are permitted to receive the message in the first place (in case the URL of the
    target window has changed), and it provides the recipient with the identity of
    the sender so that the integrity of the channel can be ascertained easily. In
    contrast, legacy methods that rely on SOP loopholes usually don’t come with such
    assurances; if a particular action is permitted without robust security checks,
    it can usually also be triggered by a rogue third party and not just by the intended
    participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the proper use of *postMessage(...)*, consider a case in which
    a top-level document located at *payments.example.com* needs to obtain user login
    information for display purposes. To accomplish this, it loads a frame pointing
    to *login.example.com*. This frame can simply issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The browser will deliver the message only if the embedding site indeed matches
    the specified, trusted origin. In order to securely process this response, the
    top-level document needs to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*PostMessage(...)* is a very robust mechanism that offers significant benefits
    over *document.domain* and over virtually all other guerrilla approaches that
    predate it; therefore, it should be used as often as possible. That said, it can
    still be misused. Consider the following check that looks for a substring in the
    domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As should be evident, this comparison will not only match sites within *example.com*
    but will also happily accept messages from [www.example.com.bunnyoutlet.com](http://www.example.com.bunnyoutlet.com).
    In all likelihood, you will stumble upon code like this more than once in your
    journeys. Such is life!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recent tweaks to HTML5 extended the *postMessage(...)* API to incorporate somewhat
    overengineered “ports” and “channels,” which are meant to facilitate stream-oriented
    communications between websites. Browser support for these features is currently
    very limited and their practical utility is unclear, but from the security standpoint,
    they do not appear to be of any special concern.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with Browser Credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are wrapping up the overview of the DOM-based same-origin policy, it is
    important to note that it is in no way synchronized with ambient credentials,
    SSL state, network context, or many other potentially security-relevant parameters
    tracked by the browser. Any two windows or frames opened in a browser will remain
    same-origin with each other even if the user logs out from one account and logs
    into another, if the page switches from using a good HTTPS certificate to a bad
    one, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of synchronization can contribute to the exploitability of other security
    bugs. For example, several sites do not protect their login forms against cross-site
    request forgery, permitting any third-party site to simply submit a username and
    a password and log the user into an attacker-controlled account. This may seem
    harmless at first, but when the content loaded in the browser before and after
    this operation is considered same-origin, the impact of normally ignored “self-inflicted”
    cross-site scripting vulnerabilities (i.e., ones where the owner of a particular
    account can target only himself) is suddenly much greater than it would previously
    appear. In the most basic scenario, the attacker may first open and keep a frame
    pointing to a sensitive page on the targeted site (e.g., [http://www.fuzzybunnies.com/address_book.php](http://www.fuzzybunnies.com/address_book.php))
    and then log the victim into the attacker-controlled account to execute self-XSS
    in an unrelated component of [fuzzybunnies.com](http://fuzzybunnies.com). Despite
    the change of HTTP credentials, the code injected in that latter step will have
    unconstrained access to the previously loaded frame, permitting data theft.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[43](#CHP-9-FN-1)]) This and most other browser security mechanisms are
    based on DNS labels, not on examining the underlying IP addresses. This has a
    curious consequence: If the IP of a particular host changes, the attacker may
    be able to talk to the new destination through the user’s browser, possibly engaging
    in abusive behaviors while hiding the true origin of the attack (unfortunate,
    not very interesting) or interacting with the victim''s internal network, which
    normally would not be accessible due to the presence of a firewall (a much more
    problematic case). Intentional change of an IP for this purpose is known as *DNS
    rebinding*. Browsers try to mitigate DNS rebinding to some extent by, for example,
    caching DNS lookup results for a certain time (*DNS pinning*), but these defenses
    are imperfect.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#CHP-9-FN-2)]) One significant source of same-origin policy bugs is
    having several separate URL-parsing routines in the browser code. If the parsing
    approach used in the HTTP stack differs from that used for determining JavaScript
    origins, problems may arise. Safari, in particular, combated a significant number
    of SOP bypass flaws caused by pathological URLs, including many of the inputs
    discussed in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[45](#CHP-9-FN-3)]) For example, in Internet Explorer, it will still be possible
    for one page to navigate any other documents that were nominally same-origin but
    that became “isolated” after setting *document.domain*, to *javascript:* URLs.
    Doing so permits any JavaScript to execute in the context of such as a pseudo-isolated
    domain. On top of this, obviously nothing stops the originating page from simply
    setting its own *document.domain* to a value identical with that of the target
    in order to eliminate the boundary. In other words, the ability to make a document
    non-same-origin with other pages through *document.domain* should not be relied
    upon for anything even remotely serious or security relevant.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#CHP-9-FN-4)]) More about this in [Chapter 11](ch11.html "Chapter 11. Life
    Outside Same-Origin Rules"), but the most notable example is that of encoding
    data in URL fragment identifiers. This is possible because navigating frames to
    a new URL is not subject to security restrictions in most cases, and navigation
    to a URL where only the fragment identifier changes does not actually trigger
    a page reload. Framed JavaScipt can simply poll *location.hash* and detect incoming
    messages this way.
  prefs: []
  type: TYPE_NORMAL
- en: Same-Origin Policy for XMLHttpRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *XMLHttpRequest* API, mentioned in this book on several prior occasions,
    gives JavaScript programs the ability to issue almost unconstrained HTTP requests
    to the server from which the host document originated, and read back response
    headers and the document body. The ability to do so would not be particularly
    significant were it not for the fact that the mechanism leverages the existing
    browser HTTP stack and its amenities, including ambient credentials, caching mechanisms,
    keep-alive sessions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple and fairly self-explanatory use of a synchronous *XMLHttpRequest*
    could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous requests are very similar but are executed without blocking the
    JavaScript engine or the browser. The request is issued in the background, and
    an event handler is called upon completion instead.
  prefs: []
  type: TYPE_NORMAL
- en: As originally envisioned, the ability to issue HTTP requests via this API and
    to read back the data is governed by a near-verbatim copy of the same-origin policy
    with two minor and seemingly random tweaks. First, the *document.domain* setting
    has no effect on this mechanism, and the destination URL specified for *XMLHttpRequest.open(...)*
    must always match the true origin of the document. Second, in this context, port
    number is taken into account in Internet Explorer versions prior to 9, even though
    this browser ignores it elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that *XMLHttpRequest* gives the user an unprecedented level of control
    over the HTTP headers in a request can actually be advantageous to security. For
    example, inserting a custom HTTP header, such as *X-Coming-From: same-origin*,
    is a very simple way to verify that a particular request is not coming from a
    third-party domain, because no other site should be able to insert a custom header
    into a browser-issued request. This assurance is not very strong, because no specification
    says that the implicit restriction on cross-domain headers can’t change;^([[47](#ftn.CHP-9-FN-5)])
    nevertheless, when it comes to web security, such assumptions are often just something
    you have to learn to live with.'
  prefs: []
  type: TYPE_NORMAL
- en: Control over the structure of an HTTP request can also be a burden, though,
    because inserting certain types of headers may change the meaning of a request
    to the destination server, or to the proxies, without the browser realizing it.
    For example, specifying an incorrect *Content-Length* value may allow an attacker
    to smuggle a second request into a keep-alive HTTP session maintained by the browser,
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this happens, the response to that second, injected request may be misinterpreted
    by the browser later, possibly poisoning the cache or injecting content into another
    website. This problem is especially pronounced if an HTTP proxy is in use and
    all HTTP requests are sent through a shared channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this risk, and following a lot of trial and error, modern browsers
    blacklist a selection of HTTP headers and request methods. This is done with relatively
    little consistency: While *Referer*, *Content-Length*, and *Host* are universally
    banned, the handling of headers such as *User-Agent*, *Cookie*, *Origin*, or *If-Modified-Since*
    varies from one browser to another. Similarly, the TRACE method is blocked everywhere,
    because of the unanticipated risk it posed to *httponly* cookies—but the CONNECT
    method is permitted in Firefox, despite carrying a vague risk of messing with
    HTTP proxies.'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, implementing these blacklists has proven to be an entertaining exercise
    on its own. Strictly for your amusement, consider the following cases that worked
    in some browsers as little as three years ago:^([[176](pr03.html#ftn.CHP-9-FT-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: or simply
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Cross-Origin Resource Sharing*^([[177](pr03.html#ftn.CHP-9-FT-2)]) *(CORS)*
    is a proposed extension to *XMLHttpRequest* that permits HTTP requests to be issued
    across domains and then read back if a particular response header appears in the
    returned data. The mechanism changes the semantics of the API discussed in this
    session by allowing certain “vanilla” cross-domain requests, meant to be no different
    from regular navigation, to be issued via *XMLHttpRequest.open(...)* with no additional
    checks; more elaborate requests require an OPTIONS-based preflight request first.
    CORS is already available in some browsers, but it is opposed by Microsoft engineers,
    who pursued a competing *XDomainRequest* approach in Internet Explorer 8 and 9\.
    Because the outcome of this conflict is unclear, a detailed discussion of CORS
    is reserved for [Chapter 16](ch16.html "Chapter 16. New and Upcoming Security
    Features"), which provides a more systematic overview of upcoming and experimental
    mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[47](#CHP-9-FN-5)]) In fact, many plug-ins had problems in this area in the
    past. Most notably, Adobe Flash permitted arbitrary cross-domain HTTP headers
    until 2008, at which point its security model underwent a substantial overhaul.
    Until 2011, the same plug-in suffered from a long-lived implementation bug that
    caused it to resend any custom headers to an unrelated server following an attacker-supplied
    HTTP 307 redirect code. Both of these problems are fixed now, but discovery-to-patch
    time proved troubling.
  prefs: []
  type: TYPE_NORMAL
- en: Same-Origin Policy for Web Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web storage is a simple database solution first implemented by Mozilla engineers
    in Firefox 1.5 and eventually embraced by the HTML5 specification.^([[178](pr03.html#ftn.CHP-9-FT-3)])
    It is available in all current browsers but not in Internet Explorer 6 or 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following several dubious iterations, the current design relies on two simple
    JavaScript objects: *localStorage* and *sessionStorage*. Both objects offer an
    identical, simple API for creating, retrieving, and deleting name-value pairs
    in a browser-managed database. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The *localStorage* object implements a persistent, origin-specific storage that
    survives browser shutdowns, while *sessionStorage* is expected to be bound to
    the current browser window and provide a temporary caching mechanism that is destroyed
    at the end of a browsing session. While the specification says that both *localStorage*
    and *sessionStorage* should be associated with an SOP-like origin (the protocol-host-port
    tuple), implementations in some browsers do not follow this advice, introducing
    potential security bugs. Most notably, in Internet Explorer 8, the protocol is
    not taken into account when computing the origin, putting HTTP and HTTPS pages
    within a shared context. This design makes it very unsafe for HTTPS sites to store
    or read back sensitive data through this API. (This problem is corrected in Internet
    Explorer 9, but there appears to be no plan to backport the fix.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Firefox, on the other hand, the *localStorage* behaves correctly, but the
    *sessionStorage* interface does not. HTTP and HTTPS use a shared storage context,
    and although a check is implemented to prevent HTTP content from reading keys
    created by HTTPS scripts, there is a serious loophole: Any key first created over
    HTTP, and then updated over HTTPS, will remain visible to nonencrypted pages.
    This bug, originally reported in 2009,^([[179](pr03.html#ftn.CHP-9-FT-4)]) will
    eventually be resolved, but when is not clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Security Policy for Cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the semantics of HTTP cookies in [Chapter 3](ch03.html "Chapter 3. Hypertext
    Transfer Protocol"), but that discussion left out one important detail: the security
    rules that must be implemented to protect cookies belonging to one site from being
    tampered with by unrelated pages. This topic is particularly interesting because
    the approach taken here predates the same-origin policy and interacts with it
    in a number of unexpected ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are meant to be scoped to domains, and they can’t be limited easily
    to just a single hostname value. The *domain* parameter provided with a cookie
    may simply match the current hostname (such as *foo.example.com*), but this will
    not prevent the cookie from being sent to any eventual subdomains, such as *bar.foo.example.com*.
    A qualified right-hand fragment of the hostname, such as *example.com*, can be
    specified to request a broader scope, however.
  prefs: []
  type: TYPE_NORMAL
- en: Amusingly, the original RFCs imply that Netscape engineers wanted to allow exact
    host-scoped cookies, but they did not follow their own advice. The syntax devised
    for this purpose was not recognized by the descendants of Netscape Navigator (or
    by any other implementation for that matter). To a limited extent, setting host-scoped
    cookies is possible in some browsers by completely omitting the *domain* parameter,
    but this method will have no effect in Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-3](ch09s04.html#a_sample_of_cookie-setting_behaviors "Table 9-3. A
    Sample of Cookie-Setting Behaviors") illustrates cookie-setting behavior in some
    distinctive cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-3. A Sample of Cookie-Setting Behaviors
  prefs: []
  type: TYPE_NORMAL
- en: '| Cookie set at *foo.example.com*, *domain* parameter is: | Scope of the resulting
    cookie |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Non-IE browsers | Internet Explorer |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (value omitted) | *foo.example.com* (exact) | **.foo.example.com* |'
  prefs: []
  type: TYPE_TB
- en: '| *bar.foo.example.com* | Cookie not set: domain more specific than origin
    |'
  prefs: []
  type: TYPE_TB
- en: '| *foo.example.com* | **.foo.example.com* |'
  prefs: []
  type: TYPE_TB
- en: '| *baz.example.com* | Cookie not set: domain mismatch |'
  prefs: []
  type: TYPE_TB
- en: '| *example.com* | **.example.com* |'
  prefs: []
  type: TYPE_TB
- en: '| *ample.com* | Cookie not set: domain mismatch |'
  prefs: []
  type: TYPE_TB
- en: '| *.com* | Cookie not set: domain too broad, security risk |'
  prefs: []
  type: TYPE_TB
- en: 'The only other true cookie-scoping parameter is the path prefix: Any cookie
    can be set with a specified *path* value. This instructs the browser to send the
    cookie back only on requests to matching directories; a cookie scoped to *domain*
    of *example.com* and *path* of */some/path/* will be included on a request to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This mechanism can be deceptive. URL paths are not taken into account during
    same-origin policy checks and, therefore, do not form a useful security boundary.
    Regardless of how cookies work, JavaScript code can simply hop between any URLs
    on a single host at will and inject malicious payloads into such targets, abusing
    any functionality protected with path-bound cookies. (Several security books and
    white papers recommend path scoping as a security measure to this day. In most
    cases, this advice is dead wrong.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the true scoping features (which, along with cookie name, constitute
    a tuple that uniquely identifies every cookie), web servers can also output cookies
    with two special, independently operated flags: *httponly* and *secure*. The first,
    *httponly*, prevents access to the cookie via the *document.cookie* API in the
    hope of making it more difficult to simply copy a user’s credentials after successfully
    injecting a malicious script on a page. The second, *secure*, stops the cookie
    from being submitted on requests over unencrypted protocols, which makes it possible
    to build HTTPS services that are resistant to active attacks.^([[48](#ftn.CHP-9-FN-6)])'
  prefs: []
  type: TYPE_NORMAL
- en: The pitfall of these mechanisms is that they protect data only against reading
    and not against overwriting. For example, it is still possible for JavaScript
    code delivered over HTTP to simply overflow the per-domain cookie jar and then
    set a new cookie without the *secure* flag.^([[49](#ftn.CHP-9-FN-7)]) Because
    the *Cookie* header sent by the browser provides no metadata about the origin
    of a particular cookie or its scope, such a trick is very difficult to detect.
    A prominent consequence of this behavior is that the common “stateless” way of
    preventing cross-site request forgery vulnerabilities by simultaneously storing
    a secret token in a client-side cookie and in a hidden form field, and then comparing
    the two, is not particularly safe for HTTPS websites. See if you can figure out
    why!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking of destructive interference, until 2010, *httponly* cookies also clashed
    with *XMLHttpRequest*. The authors of that API simply have not given any special
    thought to whether the *XMLHttpRequest.getResponseHeader(...)* function should
    be able to inspect server-supplied *Set-Cookie* values flagged as *httponly*—with
    predictable results.
  prefs: []
  type: TYPE_NORMAL
- en: Impact of Cookies on the Same-Origin Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same-origin policy has some undesirable impact on the security of cookies
    (specifically, on the path-scoping mechanism), but the opposite interaction is
    more common and more problematic. The difficulty is that HTTP cookies often function
    as credentials, and in such cases, the ability to obtain them is roughly equivalent
    to finding a way to bypass SOP. Quite simply, with the right set of cookies, an
    attacker could use her own browser to interact with the target site on behalf
    of the victim; same-origin policy is taken out of the picture, and all bets are
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this property, any discrepancies between the two security mechanisms
    can lead to trouble for the more restrictive one. For example, the relatively
    promiscuous domain-scoping rules used by HTTP cookies mean that it is not possible
    to isolate fully the sensitive content hosted on *webmail.example.com* from the
    less trusted HTML present on *blog.example.com*. Even if the owners of the webmail
    application scope their cookies tightly (usually at the expense of complicating
    the sign-on process), any attacker who finds a script injection vulnerability
    on the blogging site can simply overflow the per-domain cookie jar, drop the current
    credentials, and set his own **.example.com* cookies. These injected cookies will
    be sent to *webmail.example.com* on all subsequent requests and will be largely
    indistinguishable from the real ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'This trick may seem harmless until you realize that such an action may effectively
    log the victim into a bogus account and that, as a result, certain actions (such
    as sending email) may be unintentionally recorded within that account and leaked
    to the attacker before any foul play is noticed. If webmail sounds too exotic,
    consider doing the same on Amazon or Netflix: Your casual product searches may
    be revealed to the attacker before you notice anything unusual about the site.
    (On top of this, many websites are simply not prepared to handle malicious payloads
    in injected cookies, and unexpected inputs may lead to XSS or similar bugs.)'
  prefs: []
  type: TYPE_NORMAL
- en: The antics of HTTP cookies also make it very difficult to secure encrypted traffic
    against network-level attackers. A *secure* cookie set by [https://webmail.example.com/](https://webmail.example.com/)
    can still be clobbered and replaced by a made-up value set by a spoofed page at
    [http://webmail.example.com/](http://webmail.example.com/), even if there is no
    actual web service listening on port 80 on the target host.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with Domain Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The misguided notion of allowing domain-level cookies also poses problems for
    browser vendors and is a continuing source of misery. The key question is how
    to reliably prevent *example.com* from setting a cookie for **.com* and avoid
    having this cookie unexpectedly sent to every other destination on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several simple solutions come to mind, but they fall apart when you have to
    account for country-level TLDs: *example.com.pl* must be prevented from setting
    a **.com.pl* cookie, too. Realizing this, the original Netscape cookie specification
    provided the following advice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only hosts within the specified domain can set a cookie for a domain and domains
    must have at least two (2) or three (3) periods in them to prevent domains of
    the form: “.com”, “.edu”, and “va.us”.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Any domain that fails within one of the seven special top level domains listed
    below only requires two periods. Any other domain requires at least three. The
    seven special top level domains are: “COM”, “EDU”, “NET”, “ORG”, “GOV”, “MIL”,
    and “INT”.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alas, the three-period rule makes sense only for country-level registrars that
    mirror the top-level hierarchy (*example.co.uk*) but not for the just as populous
    group of countries that accept direct registrations (*example.fr*). In fact, there
    are places where both approaches are allowed; for example, both *example.jp* and
    *example.co.jp* are perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the out-of-touch nature of this advice, most browsers disregarded
    it and instead implemented a patchwork of conditional expressions that only led
    to more trouble. (In one case, for over a decade, you could actually set cookies
    for **.com.pl*.) Comprehensive fixes to country-code top-level domain handling
    have shipped in all modern browsers in the past four years, but as of this writing
    they have not been backported to Internet Explorer 6 and 7, and they probably
    never will be.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add insult to injury, the Internet Assigned Numbers Authority added a fair
    number of top-level domains in recent years (for example, *.int* and *.biz*),
    and it is contemplating a proposal to allow arbitrary generic top-level domain
    registrations. If it comes to this, cookies will probably have to be redesigned
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The Unusual Danger of “localhost”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One immediately evident consequence of the existence of domain-level scoping
    of cookies is that it is fairly unsafe to delegate any hostnames within a sensitive
    domain to any untrusted (or simply vulnerable) party; doing so may affect the
    confidentiality, and invariably the integrity, of any cookie-stored credentials—and,
    consequently, of any other information handled by the targeted application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So much is obvious, but in 2008, Tavis Ormandy spotted something far less intuitive
    and far more hilarious:^([[180](pr03.html#ftn.CHP-9-FT-5)]) that because of the
    port-agnostic behavior of HTTP cookies, an additional danger lies in the fairly
    popular and convenient administrative practice of adding a “localhost” entry to
    a domain and having it point to 127.0.0.1.^([[50](#ftn.CHP-9-FN-8)]) When Ormandy
    first published his advisory, he asserted that this practice is widespread—not
    a controversial claim to make—and included the following resolver tool output
    to illustrate his point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Why would this be a security risk? Quite simply, it puts the HTTP services
    on the user’s own machine within the same domain as the remainder of the site,
    and more importantly, it puts all the services that only *look* like HTTP in the
    very same bucket. These services are typically not exposed to the Internet, so
    there is no perceived need to design them carefully or keep them up-to-date. Tavis’s
    case in point is a printer-management service provided by CUPS (Common UNIX Printing
    System), which would execute attacker-supplied JavaScript in the context of *example.com*
    if invoked in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The vulnerability in CUPS can be fixed, but there are likely many other dodgy
    local services on all operating systems—everything from disk management tools
    to antivirus status dashboards. Introducing entries pointing back to 127.0.0.1,
    or any other destinations you have no control over, ties the security of cookies
    within your domain to the security of random third-party software. That is a good
    thing to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies and “Legitimate” DNS Hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The perils of the domain-scoping policy for cookies don’t end with *localhost*.
    Another unintended interaction is related to the common, widely criticized practice
    of some ISPs and other DNS service providers of hijacking domain lookups for nonexistent
    (typically mistyped) hosts. In this scheme, instead of returning the standard-mandated
    NXDOMAIN response from an upstream name server (which would subsequently trigger
    an error message in the browser or other networked application), the provider
    will falsify a record to imply that this name resolves to its site. Its site,
    in turn, will examine the *Host* header supplied by the browser and provide the
    user with unsolicited, paid contextual advertising that appears to be vaguely
    related to her browsing interests. The usual justification offered for this practice
    is that of offering a more user-friendly browsing experience; the real incentive,
    of course, is to make more money.
  prefs: []
  type: TYPE_NORMAL
- en: Internet service providers that have relied on this practice include Cablevision,
    Charter, Earthlink, Time Warner, Verizon, and many more. Unfortunately, their
    approach is not only morally questionable, but it also creates a substantial security
    risk. If the advertising site contains any script-injection vulnerabilities, the
    attacker can exploit them in the context of any other domain simply by accessing
    the vulnerable functionality through an address such as *nonexistent.example.com*.
    When coupled with the design of HTTP cookies, this practice undermines the security
    of any arbitrarily targeted services on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Predictably, script-injection vulnerabilities can be found in such hastily designed
    advertising traps without much effort. For example, in 2008, Dan Kaminsky spotted
    and publicized a cross-site scripting vulnerability on the pages operated by Earthlink.^([[181](pr03.html#ftn.CHP-9-FT-6)])
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, all right: It’s time to stop obsessing over cookies and move on.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[48](#CHP-9-FN-6)]) It does not matter that *https://webmail.example.com/*
    is offered only over HTTPS. If it uses a cookie that is not locked to encrypted
    protocols, the attacker may simply wait until the victim navigates to [http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/),
    silently inject a frame pointing to [http://webmail.example.com/](http://webmail.example.com/)
    on that page, and then intercept the resulting TCP handshake. The browser will
    then send all the *webmail.example.com* cookies over an unencrypted channel, and
    at this point the game is essentially over.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[49](#CHP-9-FN-7)]) Even if this possibility is prevented by separating the
    jars for *httponly* and normal cookies, multiple identically named but differently
    scoped cookies must be allowed to coexist, and they will be sent together on any
    matching requests. They will be not accompanied by any useful metadata, and their
    ordering will be undefined and browser specific.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[50](#CHP-9-FN-8)]) This IP address is reserved for loopback interfaces;
    any attempt to connect to it will route you back to the services running on your
    own machine.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-in Security Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browsers do not provide plug-in developers with a uniform and extensible API
    for enforcing security policies; instead, each plug-in decides what rules should
    be applied to executed content and how to put them into action. Consequently,
    even though plug-in security models are to some extent inspired by the same-origin
    policy, they diverge from it in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: This disconnect can be dangerous. In [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts"), we discussed the tendency for plug-ins to rely on inspecting the JavaScript
    *location* object to determine the origin of their hosting page. This misguided
    practice forced browser developers to restrict the ability of JavaScript programs
    to tamper with some portions of their runtime environment to save the day. Another
    related, common source of incompatibilities is the interpretation of URLs. For
    example, in the middle of 2010, one researcher discovered that Adobe Flash had
    trouble with the following URL:^([[182](pr03.html#ftn.CHP-9-FT-7)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The plug-in decided that the origin of any code retrieved through this URL should
    be set to *example.com*, but the browser, when presented with such a URL, would
    naturally retrieve the data from [bunnyoutlet.com](http://bunnyoutlet.com) instead
    and then hand it over to the confused plug-in for execution.
  prefs: []
  type: TYPE_NORMAL
- en: While this particular bug is now fixed, other vulnerabilities of this type can
    probably be expected in the future. Replicating some of the URL-parsing quirks
    discussed in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL") and [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol") can be a fool’s errand and, ideally,
    should not be attempted at all.
  prefs: []
  type: TYPE_NORMAL
- en: It would not be polite to end this chapter on such a gloomy note! Systemic problems
    aside, let’s see how some of the most popular plug-ins approach the job of security
    policy enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Flash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Flash security model underwent a major overhaul in 2008,^([[183](pr03.html#ftn.CHP-9-FT-8)])
    and since then, it has been reasonably robust. Every loaded Flash applet is now
    assigned an SOP-like origin derived from its originating URL^([[51](#ftn.CHP-9-FN-9)])
    and is granted nominal origin-related permissions roughly comparable to those
    of JavaScript. In particular, each applet can load cookie-authenticated content
    from its originating site, load some constrained datatypes from other origins,
    and make same-origin *XMLHttpRequest*-like HTTP calls through the *URLRequest*
    API. The set of permissible methods and request headers for this last API is managed
    fairly reasonably and, as of this writing, is more restrictive than most of the
    browser-level blacklists for *XMLHttpRequest* itself.^([[184](pr03.html#ftn.CHP-9-FT-9)])
  prefs: []
  type: TYPE_NORMAL
- en: On top of this sensible baseline, three flexible but easily misused mechanisms
    permit this behavior to be modified to some extent, as discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Markup-Level Security Controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The embedding page can specify three special parameters provided through *<embed>*
    or *<object>* tags to control how an applet will interact with its host page and
    the browser itself:'
  prefs: []
  type: TYPE_NORMAL
- en: AllowScriptAccess **parameter** This setting controls an applet’s ability to
    use the JavaScript *ExternalInterface.call(...)* bridge (see [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins")) to execute JavaScript statements
    in the context of the embedding site. Possible values are *always*, *never*, and
    *sameorigin*; the last setting gives access to the page only if the page is same-origin
    with the applet itself. (Prior to the 2008 security overhaul, the plug-in defaulted
    to *always*; the current default is the much safer *sameorigin*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AllowNetworking **parameter** This poorly named setting restricts an applet’s
    permission to open or navigate browser windows and to make HTTP requests to its
    originating server. When set to *all* (the default), the applet can interfere
    with the browser; when set to *internal*, it can perform only nondisruptive, internal
    communications through the Flash plug-in. Setting this parameter to *none* disables
    most network-related APIs altogether.^([[52](#ftn.CHP-9-FN-10)]) (Prior to recent
    security improvements, *allowNetworking=all* opened up several ways to bypass
    *allowScriptAccess=none*, for example, by calling *getURL(...)* on a *javascript:*
    URL. As of this writing, however, all scripting URLs should be blacklisted in
    this scenario.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AllowFullScreen **parameter** This parameter controls whether an applet should
    be permitted to go into full-screen rendering mode. The possible values are *true*
    and *false*, with *false* being the default. As noted in [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins"), the decision to give this
    capability to Flash applets is problematic due to UI spoofing risks; it should
    be not enabled unless genuinely necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security.allowDomain(...)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Security.allowDomain(...)* method^([[185](pr03.html#ftn.CHP-9-FT-10)])
    allows Flash applets to grant access to their variables and functions to any JavaScript
    code or to other applets coming from a different origin. Buyer beware: Once such
    access is granted, there is no reliable way to maintain the integrity of the original
    Flash execution context. The decision to grant such permissions should not be
    taken lightly, and the practice of calling *allowDomain("*")* should usually be
    punished severely.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that a weirdly named *allowInsecureDomain(...)* method is also available.
    The existence of this method does not indicate that *allowDomain(...)* is particularly
    secure; rather, the “insecure” variant is provided for compatibility with ancient,
    pre-2003 semantics that completely ignored the HTTP/HTTPS divide.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Domain Policy Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Through the use of *loadPolicyFile(...)*, any Flash applet can instruct its
    runtime environment to retrieve a security policy file from an almost arbitrary
    URL. This XML-based document, usually named *crossdomain.xml*, will be interpreted
    as an expression of consent to cross-domain, server-level access to the origin
    determined by examining the policy URL.^([[186](pr03.html#ftn.CHP-9-FT-11)]) The
    syntax of a policy file is fairly self-explanatory and may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The policy may permit actions such as loading cross-origin resources or issuing
    arbitrary *URLRequest* calls with whitelisted headers, through the browser HTTP
    stack. Flash developers do attempt to enforce a degree of path separation: A policy
    loaded from a particular subdirectory can in principle permit access only to files
    within that path. In practice, however, the interactions with SOP and with various
    path-mapping semantics of modern browsers and web application frameworks make
    it unwise to depend on this boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making raw TCP connections via *XMLSocket* is also possible and controlled by
    an XML policy, but following Flash’s 2008 overhaul, *XMLSocket* requires that
    a separate policy file be delivered on TCP port 843 of the destination server.
    This is fairly safe, because no other common services run on this port and, on
    many operating systems, only privileged users can launch services on any port
    below 1024\. Because of the interactions with certain firewall-level mechanisms,
    such as FTP protocol helpers, this design may still cause some network-level interference,^([[187](pr03.html#ftn.CHP-9-FT-12)])
    but this topic is firmly beyond the scope of this book
  prefs: []
  type: TYPE_NORMAL
- en: As expected, poorly configured *crossdomain.xml* policies are an appreciable
    security risk. In particular, it is a very bad idea to specify *allow-access-from*
    rules that point to any domain you do not have full confidence in. Further, specifying
    “`*`” as a value for this parameter is roughly equivalent to executing *document.domain
    = “com”*. That is, it’s a death wish.
  prefs: []
  type: TYPE_NORMAL
- en: Policy File Spoofing Risks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other than the possibility of configuration mistakes, another security risk
    with Adobe’s policy-based security model is that random user-controlled documents
    may be interpreted as cross-domain policies, contrary to the site owner’s intent.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to 2008, Flash used a notoriously lax policy parser, which when processing
    *loadPolicyFile(...)* files would skip arbitrary leading garbage in search of
    the opening *<cross-domain-policy>* tag. It would simply ignore the MIME type
    returned by the server when downloading the resource, too. As a result, merely
    hosting a valid, user-supplied JPEG image could become a grave security risk.
    The plug-in also skipped over any HTTP redirects, making it dangerous to do something
    as simple as issuing an HTTP redirect to a location you did not control (an otherwise
    harmless act).
  prefs: []
  type: TYPE_NORMAL
- en: Following the much-needed revamp of the *loadPolicyFile* behavior, many of the
    gross mistakes have been corrected, but the defaults are still not perfect. On
    the one hand, redirects now work intuitively, and the file must be a well-formed
    XML document. On the other, permissible MIME types include *text/**, *application/xml*,
    and *application/xhtml+xml*, which feels a bit too broad. *text/plain* or *text/csv*
    may be misinterpreted as a policy file, and that should not be the case.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, to mitigate the problem, Adobe engineers decided to roll out *meta-policies*,
    policies that are hosted at a predefined, top-level location (*/crossdomain.xml*)
    that the attacker can’t override. A meta-policy can specify sitewide restrictions
    for all the remaining policies loaded from attacker-supplied URLs. The most important
    of these restrictions is *<site-control permitted-cross-domain-policies="...">*.
    This parameter, when set to *master-only*, simply instructs the plug-in to disregard
    subpolicies altogether. Another, less radical value, *by-content-type*, permits
    additional policies to be loaded but requires them to have a nonambiguous *Content-Type*
    header set to *text/x-cross-domain-policy*.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, it’s highly advisable to use a meta-policy that specifies one
    of these two directives.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Silverlight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the transition from Flash to Silverlight seems abrupt, it’s because the two
    are easy to confuse. The Silverlight plug-in borrows from Flash with remarkable
    zeal; in fact, it is safe to say that most of the differences between their security
    models are due solely to nomenclature. Microsoft’s platform uses the same-origin-determination
    approach, substitutes *allowScriptAccess* with *enableHtmlAccess*, replaces *crossdomain.xml*
    with the slightly different *clientaccesspolicy.xml* syntax, provides a *System.Net.Sockets*
    API instead of *XMLSocket*, uses *HttpWebRequest* in place of *URLRequest*, rearranges
    the flowers, and changes the curtains in the living room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The similarities are striking, down to the list of blocked request headers
    for the *HttpWebRequest* API, which even includes *X-Flash-Version* from the Adobe
    spec.^([[188](pr03.html#ftn.CHP-9-FT-13)]) Such consistency is not a problem,
    though: In fact, it is preferable to having a brand-new security model to take
    into account. Plus, to its credit, Microsoft did make a couple of welcome improvements,
    including ditching the insecure *allowDomain* logic in favor of *RegisterScriptableObject*,
    an approach that allows only explicitly specified callbacks to be exposed to third-party
    domains.'
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sun’s Java (now officially belonging to Oracle) is a very curious case. Java
    is a plug-in that has fallen into disuse, and its security architecture has not
    received much scrutiny in the past decade or so. Yet, because of its large installed
    base, it is difficult to simply ignore it and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the closer you look, the more evident it is that the ideas embraced
    by Java tend to be incompatible with the modern Web. For example, a class called
    *java.net.HttpURLConnection*^([[189](pr03.html#ftn.CHP-9-FT-14)]) permits credential-bearing
    HTTP requests to be made to an applet’s originating website, but the “originating
    website” is understood as *any* website hosted at a particular IP address, as
    sanctioned by the *java.net.URL.equals(...)* check. This model essentially undoes
    any isolation between HTTP/1.1 virtual hosts—an isolation strongly enforced by
    the same-origin policy, HTTP cookies, and virtually all other browser security
    mechanisms in use today.
  prefs: []
  type: TYPE_NORMAL
- en: Further along these lines, the *java.net.URLConnection* class^([[190](pr03.html#ftn.CHP-9-FT-15)])
    allows arbitrary request headers, including *Host*, to be set by the applet, and
    another class, *Socket*,^([[191](pr03.html#ftn.CHP-9-FT-16)]) permits unconstrained
    TCP connections to arbitrary ports on the originating server. All of these behaviors
    are frowned upon in the browser and in any other contemporary plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Origin-agnostic access from the applet to the embedding page is provided through
    the *JSObject* mechanism and is expected to be controlled by the embedding party
    through the *mayscript* attribute specified in the *<applet>*, *<embed>*, or *<object>*
    tags.^([[192](pr03.html#ftn.CHP-9-FT-17)]) The documentation suggests that this
    is a security feature:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to security reasons, JSObject support is not enabled in Java Plug-in by
    default. To enable JSObject support in Java Plug-in, a new attribute called MAYSCRIPT
    needs to be present in the EMBED/OBJECT tag.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unfortunately, the documentation neglects to mention that another closely related
    mechanism, *DOMService*,^([[193](pr03.html#ftn.CHP-9-FT-18)]) ignores this setting
    and gives applets largely unconstrained access to the embedding page. While *DOMService*
    is not supported in Firefox and Opera, it is available in other browsers, which
    makes any attempt to load third-party Java content equivalent to granting full
    access to the embedding site.
  prefs: []
  type: TYPE_NORMAL
- en: Whoops.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interesting fact: Recent versions of Java attempt to copy the *crossdomain.xml*
    support available in Flash.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[51](#CHP-9-FN-9)]) In some contexts, Flash may implicitly permit access
    from HTTPS origins to HTTP ones but not the other way round. This is usually harmless,
    and as such, it is not given special attention throughout the remainder of this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[52](#CHP-9-FN-10)]) It should not be assumed that this setting prevents
    any sensitive data available to a rogue applet from being relayed to third parties.
    There are many side channels that any Flash applet could leverage to leak information
    to a cooperating party without directly issuing network requests. In the simplest
    and most universal case, CPU loads can be manipulated to send out individual bits
    of information to any simultaneously loaded applet that continuously samples the
    responsiveness of its runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: Coping with Ambiguous or Unexpected Origins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our overview of the basic security policies and consent isolation
    mechanisms. If there is one observation to be made, it’s that most of these mechanisms
    depend on the availability of a well-formed, canonical hostname from which to
    derive the context for all the subsequent operations. But what if this information
    is not available or is not presented in the expected form?
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s when things get funny. Let’s have a look at some of the common
    corner cases, even if just for fleeting amusement.
  prefs: []
  type: TYPE_NORMAL
- en: IP Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the failure to account for IP addresses when designing HTTP cookies and
    the same-origin policy, almost all browsers have historically permitted documents
    loaded from, say, *http://1.2.3.4/* to set cookies for a “domain” named **.3.4*.
    Adjusting *document.domain* in a similar manner would work as well. In fact, some
    of these behaviors are still present in older versions of Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is unlikely to have an impact on mainstream web applications,
    because such applications are not meant to be accessed through an IP-based URL
    and will often simply fail to function properly. But a handful of systems, used
    primarily by technical staff, are meant to be accessed by their IP addresses;
    these systems may simply not have DNS records configured at all. In these cases,
    the ability for *http://1.2.3.4/* to inject cookies for *http://123.234.3.4/*
    may be an issue. The IP-reachable administrative interfaces of home routers are
    of some interest, too.
  prefs: []
  type: TYPE_NORMAL
- en: Hostnames with Extra Periods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At their core, cookie-setting algorithms still depend on counting the number
    of periods in a URL to determine whether a particular *domain* parameter is acceptable.
    In order to make the call, the count is typically correlated with a list of several
    hundred entries on the vendor-maintained Public Suffix List ([http://publicsuffix.org/](http://publicsuffix.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for this algorithm, it is often possible to put extra periods
    in a hostname and still have it resolve correctly. Noncanonical hostname representations
    with excess periods are usually honored by OS-level resolvers and, if honored,
    will confuse the browser. Although said browser would not automatically consider
    a domain such as [www.example.com.pl](http://www.example.com.pl). (with an extra
    trailing period) to be the same as the real [www.example.com.pl](http://www.example.com.pl),
    the subtle and seemingly harmless difference in the URL could escape even the
    most attentive users.
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, interacting with the URL with trailing period can be unsafe,
    as other documents sharing the **.com.pl*. domain may be able to inject cross-domain
    cookies with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: This period-counting problem was first noticed around 1998.^([[194](pr03.html#ftn.CHP-9-FT-19)])
    About a decade later, many browser vendors decided to roll out basic mitigations
    by adding a yet another special case to the relevant code; as of this writing,
    Opera is still susceptible to this trick.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Fully Qualified Hostnames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many users browse the Web with their DNS resolvers configured to append local
    suffixes to all found hostnames, often without knowing. Such settings are usually
    sanctioned by ISPs or employers through automatic network configuration data (Dynamic
    Host Configuration Protocol, DHCP).
  prefs: []
  type: TYPE_NORMAL
- en: For any user browsing with such a setting, the resolution of DNS labels is ambiguous.
    For example, if the DNS search path includes *coredump.cx*, then [www.example.com](http://www.example.com)
    may resolve to the real [www.example.com](http://www.example.com) website or to
    [www.example.com.coredump.cx](http://www.example.com.coredump.cx) if such a record
    exists. The outcomes are partly controlled by configuration settings and, to some
    extent, can be influenced by an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the browser, both locations appear to be the same, which may have some interesting
    side effects. Consider one particularly perverse case: Should *http://com*, which
    actually resolves to [http://com.coredump.cx/](http://com.coredump.cx/), be able
    to set **.com* cookies by simply omitting the *domain* parameter?'
  prefs: []
  type: TYPE_NORMAL
- en: Local Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because local resources loaded through the *file:* protocol do not have an explicit
    hostname associated with them, it’s impossible for the browser to compute a normal
    origin. For a very long time, the vendors simply decided that the best course
    of action in such a case would be to simply ditch the same-origin policy. Thus,
    any HTML document saved to disk would automatically be granted access to any other
    local files via *XMLHttpRequest* or DOM and, even more inexplicably, would be
    able to access any Internet-originating content in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: This proved to be a horrible design decision. No one expected that the mere
    act of downloading an HTML document would put all of the user’s local files, and
    his online credentials, in jeopardy. After all, accessing that same document over
    the Web would be perfectly safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many browsers have tried to close this loophole in recent years, with varying
    degrees of success:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chrome (and, by extension, other WebKit browsers)**'
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome browser completely disallows any cross-document DOM or *XMLHttpRequest*
    access from *file:* origins, and it ignores *document.cookie* calls or *<meta
    http-equiv="Set-Cookie" ...>* directives in this setting. Access to a *localStorage*
    container shared by all *file:* documents is permitted, but this may change soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Firefox**'
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla’s browser permits access only to files within the directory of the original
    document, as well as nearby subdirectories. This policy is pretty good, but it
    still poses some risk to documents stored or previously downloaded to that location.
    Access to cookies via *document.cookie* or *<meta http-equiv="Set-Cookie" ...>*
    is possible, and all *file:* cookies are visible to any other local JavaScript
    code.^([[53](#ftn.CHP-9-FN-11)]) The same holds true for access to storage mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Explorer 7 and above**'
  prefs: []
  type: TYPE_NORMAL
- en: Unconstrained access to local and Internet content from *file:* origins is permitted,
    but it requires the user to click through a nonspecific warning to execute JavaScript
    first. The consequences of this action are not explained clearly (the help subsystem
    cryptically states that *“Internet Explorer restricts this content because occasionally
    these programs can malfunction or give you content you don’t want”*), and many
    users may well be tricked into clicking through the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer’s cookie semantics are similar to those of Firefox. Web storage
    is not supported in this origin, however.
  prefs: []
  type: TYPE_NORMAL
- en: '**Opera** and **Internet Explorer 6**'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these browsers permit unconstrained DOM or *XMLHttpRequest* access without
    further checks. Noncompartmentalized *file:* cookies are permitted, too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plug-ins live by their own rules in *file:* land: Flash uses a *local-with-filesystem*
    sandbox model,^([[195](pr03.html#ftn.CHP-9-FT-20)]) which gives largely unconstrained
    access to the local filesystem, regardless of the policy enforced by the browser
    itself, while executing Java or Windows Presentation Framework applets from the
    local filesystem may in some cases be roughly equivalent to running an untrusted
    binary.'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The behavior of pseudo-URLs such as *about:*, *data:*, or *javascript:* originally
    constituted a significant loophole in the implementations of the same-origin policy.
    All such URLs would be considered same-origin and would permit unconstrained cross-domain
    access from any other resource loaded over the same scheme. The current behavior,
    which is very different, will be the topic of the next chapter of this book; in
    a nutshell, the status quo reflects several rounds of hastily implemented improvements
    and is a complex mix of browser-specific special cases and origin-inheritance
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Browser Extensions and UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several browsers permit JavaScript-based UI elements or certain user-installed
    browser extensions to run with elevated privileges. These privileges may entail
    circumventing specific SOP checks or calling normally unavailable APIs in order
    to write files, modify configuration settings, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Privileged JavaScript is a prominent feature of Firefox, where it is used with
    XUL to build large portions of the browser user interface. Chrome also relies
    on privileged JavaScript to a smaller but still notable degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same-origin policy does not support privileged contexts in any specific
    way. The actual mechanism by which extra privileges are granted may involve loading
    the document over a special and normally unreachable URL scheme, such as *chrome:*
    or *res:*, and then adding special cases for that scheme in other portions of
    the browser code. Another option is simply to toggle a binary flag for a JavaScript
    context, regardless of its actual origin, and examine that flag later. In all
    cases, the behavior of standard APIs such as *localStorage*, *document.domain*,
    or *document.cookie* may be difficult to predict and should not be relied upon:
    Some browsers attempt to maintain isolation between the contexts belonging to
    different extensions, but most don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever writing browser extensions, any interaction with nonprivileged contexts
    must be performed with extreme caution. Examining untrusted contexts can be difficult,
    and the use of mechanisms such as *eval(...)* or *innerHMTL* may open up privilege-escalation
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[53](#CHP-9-FN-11)]) Because there is no compartmentalization between *file:*
    cookies, it is unsafe to rely on them for legitimate purposes. Some locally installed
    HTML applications ignore this advice, and consequently, their cookies can be easily
    tampered with by any downloaded, possibly malicious, HTML document viewed by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Other Uses of Origins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, that’s all to be said about browser-level content isolation logic for
    now. It is perhaps worth noting that the concept of origins and host- or domain-based
    security mechanisms is not limited to that particular task and makes many other
    appearances in the browser world. Other quasi-origin-based privacy or security
    features include preferences and cached information related to per-site cookie
    handling, pop-up blocking, geolocation sharing, password management, camera and
    microphone access (in Flash), and much, much more. These features tend to interact
    with the security features described in this chapter at least to some extent;
    we explore this topic in more detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Good Security Policy Hygiene for All Websites
  prefs: []
  type: TYPE_NORMAL
- en: To protect your users, include a top-level *crossdomain.xml* file with the *permitted-cross-domain-policies*
    parameter set to *master-only* or *by-content-type*, even if you do not use Flash
    anywhere on your site. Doing so will prevent unrelated attacker-controlled content
    from being misinterpreted as a secondary *crossdomain.xml* file, effectively undermining
    the assurances of the same-origin policy in Flash-enabled browsers.
  prefs: []
  type: TYPE_NORMAL
- en: When Relying on HTTP Cookies for Authentication
  prefs: []
  type: TYPE_NORMAL
- en: Use the *httponly* flag; design the application so that there is no need for
    JavaScript to access authentication cookies directly. Sensitive cookies should
    be scoped as tightly as possible, preferably by not specifying *domain* at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application is meant to be HTTPS only, cookies must be marked as *secure*,
    and you must be prepared to handle cookie injection gracefully. (HTTP contexts
    may overwrite *secure* cookies, even though they can’t read them.) Cryptographic
    cookie signing may help protect against unconstrained modification, but it does
    not defend against replacing a victim’s cookies with another set of legitimately
    obtained credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Arranging Cross-Domain Communications in JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not use *document.domain*. Rely on *postMessage(...)* where possible and
    be sure to specify the destination origin correctly; then verify the sender’s
    origin when receiving the data on the other end. Beware of naïve substring matches
    for domain names: *msg.origin.indexOf(".example.com")* is very insecure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that various pre-*postMessage* SOP bypass tricks, such as relying on *window.name*,
    are not tamper-proof and should not be used for exchanging sensitive data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Embedding Plug-in-Handled Active Content from Third Parties
  prefs: []
  type: TYPE_NORMAL
- en: Consult the cheat sheet in [Chapter 8](ch08.html "Chapter 8. Content Rendering
    with Browser Plug-ins") first for general advice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flash:** Do not specify *allowScriptAccess=always* unless you fully trust
    the owner of the originating domain and the security of its site. Do not use this
    setting when embedding HTTP applets on HTTPS pages. Also, consider restricting
    *allowFullScreen* and *allowNetworking* as appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Silverlight:** Do not specify *enableHtmlAccess=true* unless you trust the
    originating domain, as above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java:** Java applets can’t be safely embedded from untrusted sources. Omitting
    *mayscript* does not fully prevent access to the embedding page, so do not attempt
    to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Hosting Your Own Plug-in-Executed Content
  prefs: []
  type: TYPE_NORMAL
- en: Note that many cross-domain communication mechanisms provided by browser plug-ins
    may have unintended consequences. In particular, avoid *crossdomain.xml*, *clientaccesspolicy.xml*,
    or *allowDomain(...)* rules that point to domains you do not fully trust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Writing Browser Extensions
  prefs: []
  type: TYPE_NORMAL
- en: Avoid relying on *innerHTML*, *document.write(...)*, *eval(...)*, and other
    error-prone coding patterns, which can cause code injection on third-party pages
    or in a privileged JavaScript context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not make security-critical decisions by inspecting untrusted JavaScript security
    contexts, as their behavior can be deceptive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 10. Origin Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some web applications rely on pseudo-URLs such as *about:*, *javascript:*, or
    *data:* to create HTML documents that do not contain any server-supplied content
    and that are instead populated with the data constructed entirely on the client
    side. This approach eliminates the delay associated with the usual HTTP requests
    to the server and results in far more responsive user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the original vision of the same-origin policy did not account
    for such a use case. Specifically, a literal application of the protocol-, host-,
    and port-matching rules discussed in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic") would cause every *about:blank* document created on the client
    side to have a different origin from its parent page, preventing it from being
    meaningfully manipulated. Further, all *about:blank* windows created by completely
    unrelated websites would belong to the same origin and, under the right circumstances,
    would be able to interfere with each other with no supervision at all.
  prefs: []
  type: TYPE_NORMAL
- en: To address this incompatibility of client-side documents with the same-origin
    policy, browsers gradually developed incompatible and sometimes counterintuitive
    approaches to computing a synthetic origin and access permissions for pseudo-URLs.
    An understanding of these rules is important on its own merit, and it will lay
    the groundwork for the discussion of certain other SOP exceptions in [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules").
  prefs: []
  type: TYPE_NORMAL
- en: Origin Inheritance for about:blank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *about:* scheme is used in modern browsers for a variety of purposes, most
    of which are not directly visible to normal web pages. The *about:blank* document
    is an interesting special case, however: This URL can be used to create a minimal
    DOM hierarchy (essentially a valid but empty document) to which the parent document
    may write arbitrary data later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a typical use of this scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the HTML markup provided in this example, and when creating new windows or
    frames in general, *about:blank* can be omitted. The value is defaulted to when
    no other URL is specified by the creator of the parent document.
  prefs: []
  type: TYPE_NORMAL
- en: In every browser, most types of navigation to *about:blank* result in the creation
    of a new document that inherits its SOP origin from the page that initiated the
    navigation. The inherited origin is reflected in the *document.domain* property
    of the new JavaScript execution context, and DOM access to or from any other origins
    is not permitted.
  prefs: []
  type: TYPE_NORMAL
- en: This simple formula holds true for navigation actions such as clicking a link,
    submitting a form, creating a new frame or a window from a script, or programmatically
    navigating an existing document. That said, there are exceptions, the most notable
    of which are several special, user-controlled navigation methods. These include
    manually entering *about:blank* in the address bar, following a bookmark, or performing
    a gesture reserved for opening a link in a new window or a tab.^([[54](#ftn.CHP-10-FN-1)])
    These actions will result in a document that occupies a unique synthetic origin
    and that can’t be accessed by any other page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another special case is the loading of a normal server-supplied document that
    subsequently redirects to *about:blank* using *Location* or *Refresh*. In Firefox
    and WebKit-based browsers, such redirection results in a unique, nonaccessible
    origin, similar to the scenario outlined in the previous paragraph. In Internet
    Explorer, on the other hand, the resulting document will be accessible by the
    parent page if the redirection occurs inside an *<iframe>* but not if it took
    place in a separate window. Opera’s behavior is the most difficult to understand:
    *Refresh* results in a document that can be accessed by the parent page, but the
    *Location* redirect will give the resulting page the origin of the site that performed
    the redirect.'
  prefs: []
  type: TYPE_NORMAL
- en: Further, it is possible for a parent document to navigate an existing document
    frame to an *about:blank* URL, even if the existing document shown in that container
    has a different origin than the caller.^([[55](#ftn.CHP-10-FN-2)]) The newly created
    blank document will inherit the origin from the caller in all browsers other than
    Internet Explorer. In the case of Internet Explorer, such navigation will succeed
    but will result in an inaccessible document. (This behavior is most likely not
    intentional.)
  prefs: []
  type: TYPE_NORMAL
- en: If this description makes your head spin, the handling of *about:blank* documents
    is summarized in [Table 10-1](ch10.html#origin_inheritance_for_about_colon "Table 10-1. Origin
    Inheritance for about:blank URLs").
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1. Origin Inheritance for *about:blank* URLs
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Type of navigation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New page | Existing non-same-origin page | *Location* redirect | *Refresh*
    redirect | URL entry or gesture |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer** | Inherited from caller | Unique origin | (Denied)
    | **Frame**: Inherited from parent | Unique origin |'
  prefs: []
  type: TYPE_TB
- en: '| **Window**: Unique origin |'
  prefs: []
  type: TYPE_TB
- en: '| **Firefox** | Inherited from caller | Unique origin |'
  prefs: []
  type: TYPE_TB
- en: '| **All WebKit** | Inherited from caller | (Denied) | Unique origin |'
  prefs: []
  type: TYPE_TB
- en: '| **Opera** | Inherited from caller | Inherited from redirecting party | Inherited
    from parent |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[54](#CHP-10-FN-1)]) This is usually accomplished by holding ctrl or shift
    while clicking on a link, or by right-clicking the mouse to access a contextual
    menu, and then selecting the appropriate option.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[55](#CHP-10-FN-2)]) The exact circumstances that make this possible will
    be the focus of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
    For now, suffice it to say that this can be accomplished in many settings in a
    browser-specific way. For example, in Firefox, you call *window.open(..., 'target')*,
    while in Internet Explorer, calling *target.location.assign(...)* is the way to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance for data: URLs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *data:* scheme,^([[196](pr03.html#ftn.CHP-10-FT-1)]) first outlined in
    [Chapter 2](ch02.html "Chapter 2. It Starts with a URL"), was designed to permit
    small documents, such as icons, to be conveniently encoded and then directly inlined
    in an HTML document, saving time on HTTP round-trips. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the *data:* scheme is used in conjunction with type-specific subresources,
    the only unusual security consideration is that it poses a challenge for plug-ins
    that wish to derive permissions for an applet from its originating URL. The origin
    can’t be computed by looking at the URL alone, and the behavior is somewhat unpredictable
    and highly plug-in specific (for example, Adobe Flash currently rejects any attempts
    to use *data:* documents).
  prefs: []
  type: TYPE_NORMAL
- en: 'More important than the case of type-specific content is the use of *data:*
    as a destination for windows and frames. In all browsers but Internet Explorer,
    the scheme can be used as an improved variant of *about:blank*, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, there is no compelling reason for a *data:* URL to behave
    differently than *about:blank*. In reality, however, it will behave differently
    in some browsers and therefore must be used with care.
  prefs: []
  type: TYPE_NORMAL
- en: '**WebKit browsers** In Chrome and Safari, all *data:* documents are given a
    unique, nonaccessible origin and do not inherit from the parent at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firefox** In Firefox, the origin for *data:* documents is inherited from
    the navigating context, similar to *about:blank*. However, unlike with *about:blank*,
    manually entering *data:* URLs or opening bookmarked ones results in the new document
    inheriting origin from the page on which the navigation occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opera** As of this writing, a shared “empty” origin is used for all *data:*
    URLs, which is accessible by the parent document. This approach is unsafe, as
    it may allow cross-domain access to frames created by unrelated pages, as shown
    in [Figure 10-1](ch10s02.html#access_between_data_colon_urls_in_opera "Figure 10-1. Access
    between data: URLs in Opera"). (I reported this behavior to Opera, and it likely
    will be amended soon.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Explorer** *data:* URLs are not supported in Internet Explorer versions
    prior to 8\. The scheme is supported only for select types of subresources in
    Internet Explorer 8 and 9 and can’t be used for navigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 10-2](ch10s02.html#origin_inheritance_for_data_colon_urls "Table 10-2. Origin
    Inheritance for data: URLs") summarizes the current behavior of *data:* URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2. Origin Inheritance for *data:* URLs
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Type of navigation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New page | Existing non-same-origin page | *Location* redirect | *Refresh*
    redirect | URL entry or gesture |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer 6/7** | (Not supported) |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer 8/9** | (Not supported for navigation) |'
  prefs: []
  type: TYPE_TB
- en: '| **Firefox** | Inherited from caller | Unique origin | Inherited from previous
    page |'
  prefs: []
  type: TYPE_TB
- en: '| **All WebKit** | Unique origin | (Denied) | Unique origin | Unique origin
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Opera** | Shared origin (This is a bug!) | (Denied) | Inherited from parent
    |'
  prefs: []
  type: TYPE_TB
- en: '![Access between data: URLs in Opera](httpatomoreillycomsourcenostarchimages950021.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Access between *data:* URLs in Opera
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance for javascript: and vbscript: URLs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting-related pseudo-URLs, such as *javscript:*, are a very curious mechanism.
    Using them to load some types of subresources will lead to code execution in the
    context of the document that attempts to load such an operation (subject to some
    inconsistent restrictions, as discussed in [Chapter 4](ch04.html "Chapter 4. Hypertext
    Markup Language")). An example of this may be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: More interestingly (and far less obviously) than the creation of new subresources,
    navigating existing windows or frames to *javascript:* URLs will cause the inlined
    JavaScript code to execute in the context of the navigated page (and not the navigating
    document!)—even if the URL is entered manually or loaded from a bookmark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this behavior, it is obviously very unsafe to allow one document to navigate
    any other non-same-origin context to a *javascript:* URL, as it would enable the
    circumvention of all other content-isolation mechanisms: Just load [fuzzybunnies.com](http://fuzzybunnies.com)
    in a frame, and then navigate that frame to *javascript:do_evil_stuff()* and call
    it a day. Consequently, such navigation is prohibited in all browsers except for
    Firefox. Firefox appears to permit it for some reason, but it changes the semantics
    in a sneaky way. When the origin of the caller and the navigation target do not
    match, it executes the *javascript:* payload in a special null origin, which lacks
    its own DOM or any of the browser-supplied I/O functions registered (thus permitting
    only purely algorithmic operations to occur).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cross-origin case is dangerous, but its same-origin equivalent is not:
    Within a single origin, any content is free to navigate itself or its peers to
    *javascript:* URLs on its own volition. In this case, the *javascript:* scheme
    is honored when following links, submitting forms, calling *location.assign(...)*,
    and so on. In WebKit and Opera, *Refresh* redirection to *javascript:* will work
    as well; other browsers reject such navigation due to vague and probably misplaced
    script-injection concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: The handling of scripting URLs is outlined in [Table 10-3](ch10s03.html#origin_inheritance_for_data_colon
    "Table 10-3. Origin Inheritance for Scripting URLs").
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-3. Origin Inheritance for Scripting URLs
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Type of navigation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New page | Existing same-origin page | Existing non-same-origin page | *Location*
    redirect | *Refresh* redirect | URL entry or gesture |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Internet Explorer** | Inherited from caller | Inherited from navigated
    page | (Denied) | (Denied) | (Denied) | Inherited from navigated page |'
  prefs: []
  type: TYPE_TB
- en: '| **Firefox** | Null context | (Denied) |'
  prefs: []
  type: TYPE_TB
- en: '| **All WebKit** | (Denied) | Inherited from navigated page |'
  prefs: []
  type: TYPE_TB
- en: '| **Opera** | (Denied) | Inherited from navigated page |'
  prefs: []
  type: TYPE_TB
- en: 'On top of these fascinating semantics, there is a yet another twist unique
    to the *javascript:* scheme: In some cases, the handling of such script-containing
    URLs involves a second step. Specifically, if the supplied code evaluates properly,
    and the value of the last statement is nonvoid and can be converted to a string,
    this string will be interpreted as an HTML document and will replace the navigated
    page (inheriting origin from the caller). The logic governing this curious behavior
    is very similar to that influencing the behavior of *data:* URLs. An example of
    such a document-replacing expression is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A Note on Restricted Pseudo-URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The somewhat quirky behavior of the three aforementioned classes of URLs—*about:blank*,
    *javascript:*, and *data:*—are all that most websites need to be concerned with.
    Nevertheless, browsers use a range of other documents with no inherent, clearly
    defined origin (e.g., *about:config* in Firefox, a privileged JavaScript page
    that can be used to tweak the browser’s various under-the-hood settings, or *chrome://downloads*
    in Chrome, which lists the recently downloaded documents with links to open any
    of them). These documents are a continued source of security problems, even if
    they are not reachable directly from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the incompatibility of these URLs with the boundaries controlled
    by the same-origin policy, special care must be taken to make sure that these
    URLs are sufficiently isolated from other content whenever they are loaded in
    the browser as a result of user action or some other indirect browser-level process.
    An interesting case illustrating the risk is a 2010 bug in the way Firefox handled
    *about:neterror*.^([[197](pr03.html#ftn.CHP-10-FT-2)]) Whenever Firefox can’t
    correctly retrieve a document from a remote server (a condition that is usually
    easy to trigger with a carefully crafted link), it puts the destination URL in
    the address bar but loads *about:neterror* in place of the document body. Unfortunately,
    due to a minor oversight, this special error page would be same-origin with any
    *about:blank* document opened by any Internet-originating content, thereby permitting
    the attacker to inject arbitrary content into the *about:neterror* window while
    preserving the displayed destination URL.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of this story? Avoid the urge to gamble with the same-origin policy;
    instead, play along with it. Note that making *about:neterror* a hierarchical
    URL, instead of trying to keep track of synthetic origins, would have prevented
    the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Because of their incompatibility with the same-origin policy, *data:*, *javascript:*,
    and implicit or explicit *about:blank* URLs should be used with care. When performance
    is not critical, it is preferable to seed new frames and windows by pointing them
    to a server-supplied blank document with a definite origin first.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that *data:* and *javascript:* URLs are not a drop-in replacement
    for *about:blank*, and they should be used only when absolutely necessary. In
    particular, it is currently unsafe to assume that *data:* windows can’t be accessed
    across domains.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Life Outside Same-Origin Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same-origin policy is the most important mechanism we have to keep hostile
    web applications at bay, but it’s also an imperfect one. Although it is meant
    to offer a robust degree of separation between any two different and clearly identifiable
    content sources, it often fails at this task.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this disconnect, recall that contrary to what common sense may
    imply, the same-origin policy was never meant to be all-inclusive. Its initial
    focus, the DOM hierarchy (that is, just the *document* object exposed to JavaScript
    code) left many of the peripheral JavaScript features completely exposed to cross-domain
    manipulation, necessitating ad hoc fixes. For example, a few years after the inception
    of SOP, vendors realized that allowing third-party documents to tweak the *location.host*
    property of an unrelated window is a bad idea and that such an operation could
    send potentially sensitive data present in other URL segments to an attacker-specified
    site. The policy has subsequently been extended to at least partly protect this
    and a couple of other sensitive objects, but in some less clear-cut cases, awkward
    loopholes remain.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem is that many cross-domain interactions happen completely outside
    of JavaScript and its object hierarchy. Actions such as loading third-party images
    or stylesheets are deeply rooted in the design of HTML and do not depend on scripting
    in any meaningful way. (In principle, it would be possible to retrofit them with
    origin-based security controls, but doing so would interfere with existing websites.
    Plus, some think that such a decision would go against the design principles that
    made the Web what it is; they believe that the ability to freely cross-reference
    content should not be infringed upon.)
  prefs: []
  type: TYPE_NORMAL
- en: In light of this, it seems prudent to explore the boundaries of the same-origin
    policy and learn about the rich life that web applications can lead outside its
    confines. We begin with document navigation—a mechanism that at first seems strikingly
    simple but that is really anything but.
  prefs: []
  type: TYPE_NORMAL
- en: Window and Frame Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Web, the ability to steer the browser from one website to another is
    taken for granted. Some of the common methods of achieving such navigation are
    discussed throughout [Part I](pt01.html "Part I. Anatomy of the Web") of this
    book; the most notable of these are HTML links, forms, and frames; HTTP redirects;
    and JavaScript *window.open(...)* and *location.** calls.
  prefs: []
  type: TYPE_NORMAL
- en: Actions such as pointing a newly opened window to an off-domain URL or specifying
    the *src* parameter of a frame are intuitive and require no further review. But
    when we look at the ability of one page to navigate another, existing document—well,
    the reign of intuition comes to a sudden end.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Location of Existing Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the simple days before the advent of HTML frames, only one document could
    occupy a given browser window, and only that single window would be under the
    document’s control. Frames changed this paradigm, however, permitting several
    different and completely separate documents to be spliced into a single logical
    view, coexisting within a common region of the screen. The introduction of the
    mechanism also necessitated another step: To sanely implement certain frame-based
    websites, any of the component documents displayed in a window needed the ability
    to navigate its neighboring frames or perhaps the top-level document itself. (For
    example, imagine a two-frame page with a table of contents on the left and the
    actual chapter on the right. Clicking a chapter name in the left pane should navigate
    the chapter in the right pane, and nothing else.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism devised for this last purpose is fairly simple: One can specify
    the *target* parameter on *<a href=...>* links or forms, or provide the name of
    a window to the JavaScript method known as *window.open(...)*, in order to navigate
    any other, previously named document view. In the mid-1990s, when this functionality
    first debuted, there seemed to be no need to incorporate any particular security
    checks into this logic; any page could navigate any other named window or a frame
    displayed by the browser to a new location at will.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the consequences of this design, it is important to pause for
    a moment and examine the circumstances under which a particular document may obtain
    a name to begin with. For frames, the story is simple: In order to reference a
    frame easily on the embedding page, virtually all frames have a *name* attribute
    (and some browsers, such as Chrome, also look at *id*). Browser windows, on the
    other hand, are typically anonymous (that is, their *window.name* property is
    an empty string), unless created programmatically; in the latter case, the name
    is specified by whoever creates the view. Anonymous windows do not necessarily
    stay anonymous, however. If a rogue application is displayed in such a window
    even briefly, it may set the *window.name* property to any value, and this effect
    will persist.'
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned ability to target windows and frames by name is not the only
    way to navigate them; JavaScript programs that hold window handles pointing to
    other documents may directly invoke certain DOM methods without knowing the name
    of their target at all. Attacker-supplied code will not normally hold handles
    to completely unrelated windows, but it can traverse properties such as *opener*,
    *top*, *parent*, or *frames[]* in order to locate even distant relatives within
    the same navigation flow. An example of such a far-reaching lookup (and subsequently,
    navigation) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lookup techniques are not mutually exclusive: JavaScript programs
    can first obtain the handle of an unrelated but named window through *window.open(...)*
    and then traverse the *opener* or *frames[]* properties of that context in order
    to reach its interesting relatives nearby.'
  prefs: []
  type: TYPE_NORMAL
- en: Once a suitable handle is looked up in any fashion, the originating context
    can leverage one of several DOM methods and properties in order to change the
    address of the document displayed in that view. In every contemporary browser,
    calling the *<handle>.location.replace(...)* method, or assigning a value to *<handle>.location*
    or *<handle>.location.href* properties, should do the trick. Amusingly, due to
    random implementation quirks, other theoretically equivalent approaches (such
    as invoking *<handle>.location.assign(...)* or *<handle>.window.open(..., "_self")*)
    may be hit-and-miss.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so it may be possible to navigate unrelated documents to new locations—but
    let’s see what could possibly go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Frame Hijacking Risks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability for one domain to navigate windows created by other sites, or ones
    that are simply no longer same-origin with their creator, is usually not a grave
    concern. This laid-back design may be an annoyance and may pose some minor, speculative
    phishing risk,^([[56](#ftn.CHP-11-FN-1)]) but in the grand scheme of things, it
    is neither a very pronounced issue nor a particularly distinctive one. This is,
    perhaps, the reason why the original authors of the relevant APIs have not given
    the entire mechanism too much thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alas, the concept of HTML frames alters the picture profoundly: Any application
    that relies on frames to build a trusted user interface is at an obvious risk
    if an unrelated site is permitted to hijack such UI elements without leaving any
    trace of the attack in the address bar! [Figure 11-1](ch11.html#a_historically_permitted_comma_dangerous
    "Figure 11-1. A historically permitted, dangerous frame navigation scenario: The
    window on the right is opened at the same time as a banking website and is actively
    subverting it.") shows one such plausible attack scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A historically permitted, dangerous frame navigation scenario: The window
    on the right is opened at the same time as a banking website and is actively subverting
    it.](httpatomoreillycomsourcenostarchimages950023.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1. A historically permitted, dangerous frame navigation scenario:
    The window on the right is opened at the same time as a banking website and is
    actively subverting it.'
  prefs: []
  type: TYPE_NORMAL
- en: Georgi Guninski, one of the pioneering browser security researchers, realized
    as early as 1999 that by permitting unconstrained frame navigation, we were headed
    for some serious trouble. Following his reports, vendors attempted to roll out
    frame navigation restrictions mid-2000.^([[198](pr03.html#ftn.CHP-11-FT-1)]) Their
    implementation constrained all cross-frame navigation to the scope of a single
    window, preventing malicious web pages from interfering with any other simultaneously
    opened browser sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, even this simple policy proved difficult to implement correctly.
    It was only in 2008 that Firefox eliminated this class of problems,^([[199](pr03.html#ftn.CHP-11-FT-2)])
    while Microsoft essentially ignored the problem until 2006\. Still, these setbacks
    aside, we should be fine—right?
  prefs: []
  type: TYPE_NORMAL
- en: Frame Descendant Policy and Cross-Domain Communications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simple security restriction discussed in the previous session was not, in
    fact, enough. The reason was a new class of web applications, sometimes known
    as *mashups*, that combined data from various sources to enable users to personalize
    their working environment and process data in innovative ways. Unfortunately for
    browser vendors, such web applications frequently relied on third-party gadgets
    loaded through *<iframe>* tags, and their developers could not reasonably expect
    that loading a single frame from a rogue source would put all other frames on
    the page at risk. Yet, the simple and elegant window-level navigation policy amounted
    to permitting exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Around 2006, Microsoft agreed that the current approach was not sustainable
    and developed a more secure *descendant policy* for frame navigation in Internet
    Explorer 7\. Under this policy, navigation of non-same-origin frames is permitted
    only if the party requesting the navigation shares the origin with one of the
    ancestors of the targeted view. [Figure 11-2](ch11.html#a_complex_but_permissible_navigation_bet
    "Figure 11-2. A complex but permissible navigation between non-same-origin frames.
    This attempt succeeds only because the originating frame has the same origin as
    one of the ancestors of the targeted document—here, it’s the top-level page itself.")
    shows the navigation scenario permitted by this new policy.
  prefs: []
  type: TYPE_NORMAL
- en: '![A complex but permissible navigation between non-same-origin frames. This
    attempt succeeds only because the originating frame has the same origin as one
    of the ancestors of the targeted document—here, it’s the top-level page itself.](httpatomoreillycomsourcenostarchimages950025.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2. [A complex but permissible navigation between non-same-origin frames.
    This attempt succeeds only because the originating frame has the same origin as
    one of the ancestors of the targeted document—here, it’s the top-level page itself.](http://www.robotroom.com/DebouncedCounter/Figure713.gif)
  prefs: []
  type: TYPE_NORMAL
- en: '[](http://www.fuzzybunnies.com/)[As with many other security improvements,
    Microsoft never backported this policy to the still popular Internet Explorer
    6, and it never convincingly pressured users to abandon the older and increasingly
    insecure (but still superficially supported) version of its browser. On a more
    positive note, by 2009, three security researchers (Adam Barth, Collin Jackson,
    and John C. Mitchell) convinced Mozilla, Opera, and WebKit to roll out a similar
    policy in their browsers,^[](http://www.bunnyoutlet.com/)[200](pr03.html#ftn.CHP-11-FT-3)]
    finally closing the mashup loophole for a good majority of the users of the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, *almost* closing it. Even the new, robust policy has a subtle flaw. Notice
    in [Figure 11-2](ch11.html#a_complex_but_permissible_navigation_bet "Figure 11-2. A
    complex but permissible navigation between non-same-origin frames. This attempt
    succeeds only because the originating frame has the same origin as one of the
    ancestors of the targeted document—here, it’s the top-level page itself.") that
    a rogue site, [http://bunnyoutlet.com/](http://bunnyoutlet.com/), can interfere
    with a private frame that [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    has created for its own use. At first glance, there is no harm here: The attacker’s
    domain is shown in the address bar, so the victim, in theory, should not be fooled
    into interacting with the subverted UI of [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    in any meaningful way. Sadly, there is a catch: Some web applications have learned
    to use frames not to create user interfaces but to relay programmatic messages
    between origins. For applications that need to support Internet Explorer 6 and
    7, where *postMessage(...)* is not available, the tricks similar to the approach
    shown in [Figure 11-3](ch11.html#a_potential_cross-domain_communication_s "Figure 11-3. A
    potential cross-domain communication scheme, where the top-level page encodes
    messages addressed to the embedded gadget in the fragment identifier of the gadget
    frame and the gadget responds by navigating a subframe that is same-origin with
    the top-level document. If this application is framed on a rogue site, the top-level
    document controlled by the attacker will be able to inject messages between the
    two parties by freely navigating send_to_parent and send_to_child.") are commonplace.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A potential cross-domain communication scheme, where the top-level page encodes
    messages addressed to the embedded gadget in the fragment identifier of the gadget
    frame and the gadget responds by navigating a subframe that is same-origin with
    the top-level document. If this application is framed on a rogue site, the top-level
    document controlled by the attacker will be able to inject messages between the
    two parties by freely navigating send_to_parent and send_to_child.](httpatomoreillycomsourcenostarchimages950027.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3. A potential cross-domain communication scheme, where the top-level
    page encodes messages addressed to the embedded gadget in the fragment identifier
    of the gadget frame and the gadget responds by navigating a subframe that is same-origin
    with the top-level document. If this application is framed on a rogue site, the
    top-level document controlled by the attacker will be able to inject messages
    between the two parties by freely navigating *send_to_parent* and *send_to_child*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an application that relies on a similar hack is embedded by a rogue site,
    the integrity of the communication frames may be compromised, and the attacker
    will be able to inject messages into the stream. Even the uses of *postMessage(...)*
    may be at risk: If the party sending the message does not specify a destination
    origin or if the recipient does not examine the originating location, hijacking
    a frame will benefit the attacker in exactly the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Unsolicited Framing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous discussion of cross-frame navigation highlights one of the more
    interesting weaknesses in the browser security model, as well as the disconnect
    between the design goals of HTML and the aim of the same-origin policy. But that’s
    not all: The concept of cross-domain framing is, by itself, fairly risky. Why?
    Well, any malicious page may embed a third-party application without a user’s
    knowledge, let alone consent. Further, it may obfuscate this fact by overlaying
    other visual elements on top of the frame, leaving visible just a small chunk
    of the original site, such as a button that performs a state-changing action.
    In such a setting, any user logged into the targeted application with ambient
    credentials may be easily tricked into interacting with the disguised UI control
    and performing an undesirable and unintended action, such as changing sharing
    settings for a social network profile or deleting data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack can be improved by the rogue site leveraging a CSS2 property called
    *opacity* to make the targeted frame completely invisible without affecting its
    actual behavior. Any click in the area occupied by such a see-through frame will
    be delivered to the UI controls contained therein (see [Figure 11-4](ch11.html#a_simplified_example_of_a_ui-splicing_at
    "Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity
    to hide the document the user will actually interact with")). Too, by combining
    CSS opacity with JavaScript code to make the frame follow the mouse pointer, it
    is possible to carry out the attack fairly reliably in almost any setting: Convincing
    the user to click anywhere in the document window is not particularly hard.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simplified example of a UI-splicing attack that uses CSS opacity to hide
    the document the user will actually interact with](httpatomoreillycomsourcenostarchimages950029.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity
    to hide the document the user will actually interact with
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have recognized the possibility of such trickery to some extent
    since the early 2000s, but a sufficiently convincing attack wasn’t demonstrated
    until 2008, when Robert Hansen and Jeremiah Grossman publicized the issue broadly.^([[201](pr03.html#ftn.CHP-11-FT-4)])
    Thus, the term *clickjacking* was born.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high profile of Hansen and Grossman’s report, and their interesting proof-of-concept
    example, piqued vendors’ interest. This interest proved to be short-lived, however,
    and there appears to be no easy way to solve this problem without taking some
    serious risks. The only even remotely plausible way to mitigate the impact would
    be to add renderer-level heuristics to disallow event delivery to cross-domain
    frames that are partly obstructed or that have not been displayed long enough.
    But this solution is complicated and hairy enough to be unpopular.^([[202](pr03.html#ftn.CHP-11-FT-5)])
    Instead, the problem has been slapped with a Band-Aid. A new HTTP header, *X-Frame-Options*,
    permits concerned sites to opt out of being framed altogether (*X-Frame-Options:
    deny*) or consent only to framing within a single origin (*X-Frame-Options: same-origin*).^([[203](pr03.html#ftn.CHP-11-FT-6)])
    This header is supported in all modern browsers (in Internet Explorer, beginning
    with version 8),^([[57](#ftn.CHP-11-FN-2)]) but it actually does little to address
    the vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the opt-in nature of the defense means that most websites will not
    adopt it or will not adopt it soon enough; in fact, a 2011 survey of the top 10,000
    destinations on the Internet found that barely 0.5 percent used this feature.^([[204](pr03.html#ftn.CHP-11-FT-7)])
  prefs: []
  type: TYPE_NORMAL
- en: To add insult to injury, the proposed mechanism is useless for applications
    that want to be embedded on third-party sites but that wish to preserve the integrity
    of their UIs. Various mashups and gadgets, those syndicated “like” buttons provided
    by social networking sites, and managed online discussion interfaces are all at
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the Threat of a Single Click
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, the clickjacking attack outlined by Grossman and Hansen
    targets simple, single-click UI actions. In reality, however, the problem with
    deceptive framing is more complicated than the early reporting would imply. One
    example of a more complex interaction is the act of selecting, dragging, and dropping
    a snippet of text. In 2010, Paul Stone proposed a number of ways in which such
    an action could be disguised as a plausible interaction with an attacker’s site,^([[205](pr03.html#ftn.CHP-11-FT-8)])
    the most notable of which is the similarity between drag-and-drop and the use
    of a humble document-level scrollbar. The same click-drag-release action may be
    used to interact with a legitimate UI control or to unwittingly drag a portion
    of preselected text out of a sensitive document and drop it into an attacker-controlled
    frame. (Cross-domain drag-and-drop is no longer permitted in WebKit, but as of
    this writing other browser vendors are still debating the right way to address
    this risk.)
  prefs: []
  type: TYPE_NORMAL
- en: An even more challenging problem is keystroke redirection. Sometime in 2010,
    I noticed that it was possible to selectively redirect keystrokes across domains
    by examining the code of a pressed key using the *onkeydown* event in JavaScript.
    If the pressed key matched what a rogue site wanted to enter into a targeted application,
    HTML element focus could be changed momentarily to a hidden *<iframe>*, thereby
    ensuring the delivery of the actual keystrokes to the targeted web application
    rather than the harmless text field the user seems to be interacting with.^([[206](pr03.html#ftn.CHP-11-FT-9)])
    Using this method, an attacker can synthesize arbitrarily complex text in another
    domain on the user’s behalf—for example, inviting the attacker as an administrator
    of the victim’s blog.
  prefs: []
  type: TYPE_NORMAL
- en: Browser vendors addressed the selective keystroke redirection issue by disallowing
    element focus changes in the middle of a keypress, but doing so did not close
    the loophole completely. After all, in some cases, an attacker can predict what
    key will be pressed next and roughly at what time, thereby permitting a preemptive,
    blindly executed focus switch. The two most obvious cases are a web-based action
    game or a typing-speed test, since both typically involve rapid pressing of attacker-influenced
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it gets better: Even if a malicious application only relies on free-form
    text entry—for example, by offering the user a comment-submission form—it’s often
    possible to guess which character will be pressed next based on the previous few
    keystrokes alone. English text (and text in most other human languages) is highly
    redundant, and in many cases, a considerable amount of input can be predicted
    ahead of time: You can bet that *a-a-r-d-v* will be followed by *a-r-k*, and almost
    always you will be right.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[56](#CHP-11-FN-1)]) One potential attack is this: Open a legitimate website
    (say, [http://trusted-bank.com/](http://trusted-bank.com/)) in a new window, wait
    for the user to inspect the address bar, and then quickly change the location
    to an attacker-controlled but similarly named site (e.g., [http://trustea-bank.com/](http://trustea-bank.com/)).
    The likelihood of successfully phishing the victim may be higher than when the
    user is navigating to the bad URL right away.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[57](#CHP-11-FN-2)]) In older versions of Internet Explorer, web application
    developers sometimes resort to JavaScript in an attempt to determine whether the
    *window* object is the same as *parent*, a condition that should be satisfied
    if no higher-level frame is present. Unfortunately, due to the flexibility of
    JavaScript DOM, such checks, as well as many types of possible corrective actions,
    are notoriously unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Domain Content Inclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Framing and navigation are a distinct source of trouble, but these mechanisms
    aside, HTML supports a number of other ways to interact with non-same-origin data.
    The usual design pattern for these features is simple and seemingly safe: A constrained
    data format that will affect the appearance of the document is retrieved and parsed
    without being directly shown to the origin that referenced it. Examples of mechanisms
    that follow this rule include markup such as *<script src=...>*, *<link rel=stylesheet
    href=...>*, *<img src=...>*, and several related cases discussed throughout [Part I](pt01.html
    "Part I. Anatomy of the Web") of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regrettably, the devil is in the details. When these mechanisms were first
    proposed, nobody asked several extremely pressing questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Should these subresources be requested with ambient credentials associated with
    their origin? If so, there is a danger that the response may contain sensitive
    data not intended for the requesting party. It would probably be better to require
    some explicit form of authentication or to notify the server about the origin
    of the requesting page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should the relevant parsers be designed to minimize the risk of mistaking one
    document type for another? And should the servers have control over how their
    responses are interpreted (for example through the *Content-Type* header)? If
    not, what are the consequences of, say, interpreting a user’s private JPEG image
    as a script?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should the requesting page have no way to infer anything about the contents
    of the retrieved payloads? If yes, then this goal needs to be taken into account
    with utmost care when designing all the associated APIs. (If such separation is
    not a goal, the importance of the previous questions is even more pronounced.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The developers acted with conflicting assumptions about these topics, or perhaps
    had not given them any thought at all, leading to a number of profound security
    risks. For example, in most browsers, it used to be possible to read arbitrary,
    cookie-authenticated text by registering an *onerror* handler on cross-domain
    *<script>* loads: The verbose “syntax error” message generated by the browser
    would include a snippet of the retrieved file. Still, no problem in this category
    is more interesting than a glitch discovered by Chris Evans in 2009.^([[207](pr03.html#ftn.CHP-11-FT-10)])
    He noticed that the hallmark fault tolerance of CSS parsers (which, as you may
    recall, recover from syntax errors by attempting to resynchronize at the nearest
    curly bracket) is also a fatal security flaw.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the issue, consider the following simple HTML document.
    This document contains two occurrences of an attacker-controlled string, and—sandwiched
    in between—a sensitive, user-specific value (in this case, a user’s name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume that the attacker lured the victim to his own page and, on this
    page, used *<link rel=stylesheet>* to load the aforementioned cross-domain HTML
    document in place of a stylesheet. The victim’s browser will happily comply: It
    will request the document using the victim’s cookies, will ignore *Content-Type*
    on the subsequent response, and will hand the retrieved content over to the CSS
    parser. The parser will cheerfully ignore all syntax errors leading up to what
    appears to be a CSS rule named *gotcha*. It will then process the *url(''...*
    pseudo-function, consuming all subsequent HTML (including the secret user name!),
    until it reaches a matching quote and a closing parenthesis. When this faux stylesheet
    is later applied to a *class=gotcha* element on the attacker’s website, the browser
    will attempt to load the resulting URL and will leak the secret value to the attacker’s
    server in the process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Astute readers may note that the CSS standard does not support multiline string
    literals, and as such, this trick would not work as specified. That’s partly true:
    In most browsers, the attempt will succeed only if the critical segment of the
    page contains no stray newlines. Some web applications are optimized to avoid
    unnecessary whitespaces and therefore will be vulnerable, but most web developers
    use newlines liberally, thwarting the attack. Alas, as noted in [Chapter 5](ch05.html
    "Chapter 5. Cascading Style Sheets"), one browser behaves differently: Internet
    Explorer accepts multiline strings in stylesheets and many other egregious syntax
    violations, accidentally amplifying the impact of this flaw.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since identifying this problem, Chris Evans has pushed for fixes in all mainstream
    browsers, and as of this writing, most implementations reject cross-domain stylesheets
    that don’t begin right away with a valid CSS rule or that are served with an incompatible
    *Content-Type* header (same-origin stylesheets are treated less restrictively).
    The only vendor to resist was Microsoft, which changed its mind only after a demonstration
    of a successful proof-of-concept attack against Twitter.^([[208](pr03.html#ftn.CHP-11-FT-11)])
    Following this revelation, Microsoft agreed not only to address the problem in
    Internet Explorer 8 but also—uncharacteristically—to backport this particular
    fix to Internet Explorer 6 and 7 as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Chris’s efforts, stylesheets are a solved problem, but similar problems
    are bound to recur for other types of cross-domain subresources. In such cases,
    not all transgressions can be blamed on the sins of the old. For example, when
    browser vendors rolled out *<canvas>*, a simple HTML5 mechanism that enables JavaScript
    to create vector and bitmap graphics,^([[209](pr03.html#ftn.CHP-11-FT-12)]) many
    implementations put no restrictions on loading cross-domain images onto the canvas
    and then reading them back pixel by pixel. As of this writing, this issue, too,
    has been resolved: A canvas once touched by a cross-domain image becomes “tainted”
    and can only be written to, not read. But when we need to fix each such case individually,
    something is very wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Cross-Origin Subresources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have focused on the risks of malicious websites navigating or including
    content that belongs to trusted parties. That said, the ability to load certain
    types of subresources from other origins has significant consequences, even if
    not actively subverted by a third-party site.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part I](pt01.html "Part I. Anatomy of the Web") of the book, we hinted that
    loading a script or a stylesheet from another origin effectively equates the security
    of the document that performs the load to the security of the origin of the loaded
    subresource; in particular, loading an HTTP script on an HTTPS page undoes most
    of the benefits of encryption. Similarly, loading a script from a provider whose
    infrastructure is vulnerable to attack can be nearly as problematic as not properly
    maintaining your own servers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to scripts and stylesheets, other content types that may lead to
    serious trouble include remote fonts (a recent addition to CSS) and plug-ins with
    access to the embedding page (such as *allowScriptAccess=always* for Flash). It
    is also somewhat dangerous to load images, icons, cursors, or HTML frames from
    untrusted sources, although the impact of doing so is contained to some extent
    and will be use specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contemporary browsers attempt to detect cases where HTTPS documents load HTTP
    resources—a condition known as *mixed content*. They do so fairly inconsistently,
    however: Internet Explorer is the only browser that blocks most types of mixed
    content by default (and Chrome is expected to follow suit), but neither Internet
    Explorer nor Firefox nor Opera consistently detects mixed content on *<embed>*,
    *<object>*, or *<applet>* tags. In browsers other than Internet Explorer, the
    default action is a subtle warning (for example, an exclamation mark next to the
    lock icon) or a cryptic dialog, which does very little to protect the user but
    which may alert a sufficiently attentive web developer.'
  prefs: []
  type: TYPE_NORMAL
- en: As to the other flavor of mixed content—loading subresources across domains
    that offer different levels of trust—browsers have no way to detect this. The
    decision to include content from dubious sources is often made too lightly and
    such mistakes can be difficult to spot until too late.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another interesting problem with cross-domain subresources is that they may
    request certain additional permissions or credentials from the browser. The associated
    browser security prompts are usually not designed with such scenarios with mind,
    and they do not always make sufficiently clear which origin is requesting the
    permission and based on what sort of relationship with the top-level site. We
    discussed one such problem in [Chapter 3](ch03.html "Chapter 3. Hypertext Transfer
    Protocol"): the authentication prompt shown in response to HTTP code 401\. Several
    other, related cases will appear in [Chapter 15](ch15.html "Chapter 15. Extrinsic
    Site Privileges").'
  prefs: []
  type: TYPE_NORMAL
- en: Privacy-Related Side Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another unfortunate and noteworthy consequence of the gaps in the same-origin
    policy is the ability to collect information about a user’s interaction with unrelated
    sites. Some of the most rudimentary examples, most of them known for well over
    a decade,^([[210](pr03.html#ftn.CHP-11-FT-13)]) include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using *onload* handlers to measure the time it takes to load certain documents,
    an indication of whether they have been previously visited and cached by the browser
    or not.^([[211](pr03.html#ftn.CHP-11-FT-14)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using *onload* and *onerror* on *<img>* tags to see if an authentication-requiring
    image on a third-party site can be loaded, thus disclosing whether the user is
    logged into that site or not. (Bonus: Sometimes, the error message disclosed to
    the *onerror* handler will include snippets of the targeted page, too.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an unrelated web application in a hidden frame and examining properties
    such as the number and names of subframes created on that page (available through
    the *<handle>.frames[]* array) or the set of global variables (sometimes leaked
    through the semantics of the *delete* operator) in order to detect the same. Naturally,
    the set of sites the user visits or is logged into can be fairly sensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these tricks, a particularly frightening class of privacy problems
    is associated with two APIs created several years ago to help websites understand
    the style applied to any document element (the sum of browser-specific defaults,
    CSS rules, and any runtime tweaks made automatically by the browser or performed
    via JavaScript). The two APIs in question are *getComputedStyle*, mandated by
    CSS Level 2,^([[212](pr03.html#ftn.CHP-11-FT-15)]) and *currentStyle*, proprietary
    to Internet Explorer.^([[213](pr03.html#ftn.CHP-11-FT-16)]) Their functionality,
    together with the ability to assign distinctive styling to visited links (using
    the *:visited* pseudo-class), means that any rogue JavaScript can rapidly display
    and examine thousands of URLs to see which ones are shaded differently (due to
    being present in a user’s browsing history), thereby building a reliable, extensive,
    and possibly incriminating overview of a user’s online habits with unprecedented
    efficiency and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: This problem has been known since at least since 2002, when Andrew Clover posted
    a brief note about it to the popular BUGTRAQ mailing list.^([[214](pr03.html#ftn.CHP-11-FT-17)])
    The issue received little scrutiny in the following years, until a series of layperson-targeted
    demonstrations and a subsequent public outcry around 2006\. A few years later,
    Firefox and WebKit browsers rolled out security improvements to limit the extent
    of styling possible in *:visited* selectors and to limit the ability to inspect
    the resulting composite CSS data.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, such fixes will never be perfect. Even though they make automated
    data collection impossible, smaller quantities of data can be obtained with a
    user’s help. Case in point: Collin Jackson and several other researchers proposed
    a simple scheme that involved presenting a faux CAPTCHA^([[58](#ftn.CHP-11-FN-3)])
    consisting of seven-segment, LCD-like digits.^([[215](pr03.html#ftn.CHP-11-FT-18)])
    Rather than being an actual, working challenge, the number the user would see
    depended on the *:visited*-based styling applied to superimposed links (see [Figure 11-5](ch11s03.html#a_fake_seven-segment_display_can_be_used
    "Figure 11-5. A fake seven-segment display can be used to read back link styling
    when the displayed number is entered into the browser in an attempt to solve a
    CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history."));
    by typing that number back onto the page, the user would unwittingly tell the
    author of the site what exact styling had been applied and, therefore, what sites
    appeared in the victim’s browsing history.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A fake seven-segment display can be used to read back link styling when the
    displayed number is entered into the browser in an attempt to solve a CAPTCHA.
    The user will see 5, 6, 9, or 8, depending on prior browsing history.](httpatomoreillycomsourcenostarchimages950031.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-5. A fake seven-segment display can be used to read back link styling
    when the displayed number is entered into the browser in an attempt to solve a
    CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[58](#CHP-11-FN-3)]) CAPTCHA (sometimes expanded as Completely Automated
    Public Turing test to tell Computers and Humans Apart) is a term for a security
    challenge that is believed to be difficult to solve using computer algorithms
    but that should be easy for a human being. It is usually implemented by showing
    an image of several randomly selected, heavily distorted characters and asking
    the user to type them back. CAPTCHA may be used to discourage the automation of
    certain tasks, such as opening new accounts or sending significant volumes of
    email. (Needless to say, due to advances in computer image processing, robust
    CAPTCHAs are increasingly difficult for humans to solve, too.)
  prefs: []
  type: TYPE_NORMAL
- en: Other SOP Loopholes and Their Uses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter has focused on areas where the limitations of the same-origin
    policy have a clear, negative impact on the security or privacy of online browsing,
    there are several accidental gaps in the scheme that in most cases seem to be
    of no special consequence. For example, in many versions of Internet Explorer,
    it was possible to manipulate the value of *window.opener* or *window.name* of
    an unrelated window. Meanwhile in Firefox, there are currently no constraints
    on setting *location.hash* across domains, even though all other partial location
    properties are restricted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary significance of these mechanisms is that they are often repurposed
    to build cross-domain communication channels in browsers that do not support the
    *postMessage(...)* API. Such mechanisms are often built on shaky ground: The lack
    of SOP enforcement is typically uniform and means that any website, not just the
    “authorized” parties, will be able to interfere with the data. The ability for
    rogue parties to navigate nested frames, as discussed in [Frame Hijacking Risks](ch11.html#frame_hijacking_risks
    "Frame Hijacking Risks") in [Frame Hijacking Risks](ch11.html#frame_hijacking_risks
    "Frame Hijacking Risks"), further complicates the picture.'
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Good Security Hygiene for All Websites
  prefs: []
  type: TYPE_NORMAL
- en: 'Serve all content for your site with *X-Frame-Options: sameorigin*. Make case-by-case
    exceptions only for specific, well-understood locations that require cross-domain
    embedding. Try not to depend on JavaScript “framebusting” code to prevent framing
    because it’s very tricky to get that code right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return user-specific, sensitive data that is not meant to be loaded across domains
    using well-constrained formats that are unlikely to be misinterpreted as standalone
    scripts, stylesheets, and so on. Always use the right *Content-Type*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Including Cross-Domain Resources
  prefs: []
  type: TYPE_NORMAL
- en: In many scenarios (especially when dealing with scripts, stylesheets, fonts,
    and certain types of plug-in-handled content), you are linking the security of
    your site to the originating domain of the subresource. When in doubt, make a
    local copy of the data instead. On HTTPS sites, require all subresources to be
    served over HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Arranging Cross-Domain Communications in JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: Consult the cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic"). Do not use cross-frame communication schemes based on *location.hash*,
    *window.name*, *frameElements*, and similar ephemeral hacks, unless you are prepared
    to deal with injected content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not expect subframes on your page to sit still, especially if you are not
    using *X-Frame-Options* to limit the ability of other sites to frame your application.
    In certain cases, an attacker may be able to navigate such frames to a different
    location without your knowledge or consent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 12. Other Security Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All previously described origin-level content-isolation policies, and the accompanying
    context inheritance and document navigation logic, work hand in hand to form the
    bulk of the browser security model. Impenetrable and fragile, that model is also
    incomplete: A handful of interesting corner cases completely escape any origin-based
    frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: The security risks associated with these corner cases can’t be addressed simply
    by fine-tuning the mechanisms discussed earlier in this book. Instead, additional,
    sometimes hopelessly imperfect security boundaries need to be created from scratch.
    These new boundaries may, for example, further restrict the ability of rogue web
    pages to navigate to certain URLs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter offers a quick look at some of the most significant examples of
    the loopholes in the origin-based model and the ways that vendors have dealt with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation to Sensitive Schemes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, browser vendors reasoned that there was no harm in allowing any
    page on the Internet to navigate to a document stored on a user’s hard drive using
    the *file:* protocol or to open a new window pointing to a privileged resource,
    such as the *about:config* page in Firefox. After all, they thought, the originating
    document and the destination would not be same-origin, and, therefore, any direct
    access to the sensitive data would be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, based on this rationale, browsers permitted such navigation
    to take place. Alas, this decision proved to be not only extremely confusing^([[59](#ftn.CHP-12-FN-1)])
    but also dangerous. The danger comes from the fact that many programs, browsers
    included, tend to store various types of Internet-originating content in the filesystem;
    temporary files and cached documents are a common example. In many cases, an attacker
    could have some control over the creation and contents of such files, and, if
    the resources are created at a predictable location, subsequent navigation to
    the right *file:* URL could allow the attacker to execute his own payload in this
    coveted origin, with access to any other file on the disk and, perhaps, any other
    website on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Comparably disastrous consequences have been observed with a variety of privileged,
    internally handled URLs. The ability to navigate directly to locations such as
    *about:config* (Firefox) not only made it possible to exploit potential vulnerabilities
    in the privileged scripts (a transgression to which browser vendors are not immune)
    but also led to system compromise if, through a literal application of the same-origin
    policy, the browser naïvely deemed *about:config* and *about:blank* to come from
    the same origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having learned from a history of painful mishaps, modern browsers typically
    police navigation based on three tiers of URL schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unrestricted** This category includes virtually all true network protocols,
    such as HTTP, HTTPS, FTP; most encapsulating pseudo-protocols such as *mhtml:*
    or *jar:*; and all schemes registered to plug-ins and external applications. Navigation
    to these URLs is not constrained in any specific way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partly restricted** This category includes several security-sensitive schemes
    such as *file:* and special pseudo-URLs such as *javascript:* or *vbscript:*.
    Navigation to them is not completely denied, but it is subject to additional,
    scheme-specific security checks. For example, access to *file:* is usually permitted
    only from other *file:* documents, requiring the first one to be opened manually.
    (The rules for navigation to *javascript:* URLs were discussed in [Chapter 10](ch10.html
    "Chapter 10. Origin Inheritance").)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fully restricted** This category includes privileged pages in *about:*, *res:*,
    *chrome:*, and similar browser-specific namespaces. Normal, unprivileged HTML
    documents are not permitted to navigate to them under any circumstance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[59](#CHP-12-FN-1)]) For example, on Windows systems, a common prank was
    to use a seamlessly embedded *<iframe>* pointing to *file:///c:/* in order to
    display the contents of a victim’s hard drive, leading some users to believe that
    the page doing so has somehow gained access to their files.
  prefs: []
  type: TYPE_NORMAL
- en: Access to Internal Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trouble with accessing sensitive protocols is merely a prelude to a far
    more serious issue that somehow escaped the creators of the same-origin policy.
    The problem is that DNS-derived origins may have nothing to do with actual network-level
    boundaries—or with how these boundaries change over time. A malicious script may
    be granted same-origin access to intranet sites on the victim’s local network,
    even if a firewall prevents the attacker from interacting with these destinations
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least three distinctive venues for such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Origin Infiltration**'
  prefs: []
  type: TYPE_NORMAL
- en: When a user visits a rogue network—such as an open wireless network at an airport
    or in a café—an attacker on that network may trick the victim’s browser into opening
    a URL such as [http://us-payroll/](http://us-payroll/). When this happens, the
    attacker may provide his own, spoofed content for that site. Frighteningly, if
    the user then brings the same browser to a corporate network, the previously injected
    content will have same-origin access to the real version of [http://us-payroll/](http://us-payroll/),
    complete with the user’s ambient credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persistence of injected content may be achieved in a couple of ways. The
    most basic method is for an attacker simply to inject a hidden [http://us-payroll/](http://us-payroll/)frame
    onto every visited page in the hope that the user will suspend a portable computer
    with the browser still running and then take it to another network. Another technique
    is *cache poisoning*: creating long-lived, cached objects that the browser will
    use instead of retrieving a fresh copy from the destination site. Several other,
    more obscure approaches also exist.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS Rebinding**'
  prefs: []
  type: TYPE_NORMAL
- en: This arguably less serious but more easily exploitable problem was mentioned
    in footnote 1 in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic").
    In short, since the same-origin policy looks just at the DNS name of a host, not
    at the IP address, an attacker who owns [bunnyoutlet.com](http://bunnyoutlet.com)
    is free to respond initially to a DNS lookup from a user with a public IP such
    as *213.134.128.25* and then switch to an address reserved for private networks,
    such as *10.0.0.1*. Documents loaded from both sources will be considered same-origin,
    giving the attacker the ability to interact with the victim’s internal network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mitigating factor is that this interaction will not involve proper ambient
    credentials that the victim normally has for the targeted site: As far as the
    browser is concerned, it is still talking to [bunnyoutlet.com](http://bunnyoutlet.com)
    and not to, say, the aforementioned *us-payroll* site. Still, the prospect of
    the attacker examining the internal network and perhaps trying to brute-force
    the appropriate credentials or identify vulnerabilities is disconcerting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Exploitation of XSS or XSRF Flaws**'
  prefs: []
  type: TYPE_NORMAL
- en: Even outside the realm of the same-origin policy, the mere possibility of navigating
    to intranet URLs means that the attacker may attempt to (blindly) target known
    or suspected vulnerabilities in locally running software. Because internal applications
    are thought to be protected from malicious users, they are often not engineered
    or maintained to the same standards as externally facing code.
  prefs: []
  type: TYPE_NORMAL
- en: One striking example of this problem is the dozens of vulnerabilities discovered
    over the years in internal-only web management interfaces of home network routers
    manufactured by companies such as Linksys (Cisco), Netgear, D-Link, Motorola,
    and Siemens. Cross-site request forgery vulnerabilities in these applications
    can, in extreme cases, permit attackers to access the device and intercept or
    modify all network traffic going to or through it.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the disconnect between browser security mechanisms and network segmentation
    remains an unsolved problem in browser engineering. Several browsers try to limit
    the impact of DNS rebinding by caching DNS responses for a predefined time—a practice
    known as *DNS pinning*—but the defense is imperfect, and the remaining attack
    vectors still remain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unusually, Internet Explorer takes the lead on this front, offering an optional
    way to mitigate the risk. Microsoft’s users are protected to some extent if they
    flip a cryptic zone setting named “websites in less privileged web content zone
    can navigate into this zone” to “disable” in the configuration options for local
    intranet. Unfortunately, the zone model in Internet Explorer comes with some unexpected
    pitfalls, as we’ll discuss in [Chapter 15](ch15.html "Chapter 15. Extrinsic Site
    Privileges").
  prefs: []
  type: TYPE_NORMAL
- en: Prohibited Ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security researchers have cautioned that the ability of browsers to submit
    largely unconstrained cross-origin request bodies, for example with <*form method="POST"
    enctype="text/plain">*, may interfere with certain other fault-tolerant but non-HTTP
    network services. For example, consider SMTP, the dominant mail transfer protocol:
    When interacting with an unsuspecting browser, most servers that speak SMTP will
    patiently ignore the first few incomprehensible lines associated with HTTP headers
    and then honor any SMTP commands that appear in the request body. In effect, the
    browser could be used as a proxy for relaying spam.'
  prefs: []
  type: TYPE_NORMAL
- en: A related but less well-explored concern, discussed in [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol"), is the risk of an attacker talking
    to non-HTTP services running in the same domain as the targeted web application
    and tricking the browser into misinterpreting the returned, possibly partly attacker-controlled
    data as HTML delivered over HTTP/0.9\. This behavior could expose cookies or other
    credentials associated with the targeted site.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of HTTP makes it impossible to solve these problems in a particularly
    robust way. Instead, browser vendors have responded in a rather unconvincing manner:
    by shipping a list of prohibited TCP ports to which requests cannot be sent. For
    Internet Explorer versions 6 and 7, the list consists of the following port numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 19 | chargen |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | ftp |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | smtp |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | pop3 |'
  prefs: []
  type: TYPE_TB
- en: '| 119 | nntp |'
  prefs: []
  type: TYPE_TB
- en: '| 143 | imap2 |'
  prefs: []
  type: TYPE_TB
- en: Versions 8 and 9 of Internet Explorer further prohibit ports 220 (imap3) and
    993 (ssl imap3).
  prefs: []
  type: TYPE_NORMAL
- en: 'All other browsers discussed in this book use a different, common list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | tcpmux | 115 | sftp |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | echo | 117 | uccp-path |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | discard | 119 | nntp |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | systat | 123 | ntp |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | daytime | 135 | loc-srv |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | netstat | 139 | netbios |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | qotd | 143 | imap2 |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | chargen | 179 | bgp |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | ftp-data | 389 | ldap |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | ftp | 465 | ssl smtp |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | ssh | 512 | exec |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | telnet | 513 | login |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | smtp | 514 | shell |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | time | 515 | printer |'
  prefs: []
  type: TYPE_TB
- en: '| 42 | name | 526 | tempo |'
  prefs: []
  type: TYPE_TB
- en: '| 43 | nicname | 530 | courier |'
  prefs: []
  type: TYPE_TB
- en: '| 53 | domain | 531 | chat |'
  prefs: []
  type: TYPE_TB
- en: '| 77 | priv-rjs | 532 | netnews |'
  prefs: []
  type: TYPE_TB
- en: '| 79 | finger | 540 | uucp |'
  prefs: []
  type: TYPE_TB
- en: '| 87 | ttylink | 556 | remotefs |'
  prefs: []
  type: TYPE_TB
- en: '| 95 | supdup | 563 | ssl nntp |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | hostriame | 587 | smtp submission |'
  prefs: []
  type: TYPE_TB
- en: '| 102 | iso-tsap | 601 | syslog |'
  prefs: []
  type: TYPE_TB
- en: '| 103 | gppitnp | 636 | ssl ldap |'
  prefs: []
  type: TYPE_TB
- en: '| 104 | acr-nema | 993 | ssl imap |'
  prefs: []
  type: TYPE_TB
- en: '| 109 | pop2 | 995 | ssl pop3 |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | pop3 | 2049 | nfs |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | sunrpc | 4045 | lockd |'
  prefs: []
  type: TYPE_TB
- en: '| 113 | auth | 6000 | X11 |'
  prefs: []
  type: TYPE_TB
- en: There are, of course, various protocol-specific exceptions to these rules. For
    example, *ftp:* URLs are obviously permitted to access port 21, normally associated
    with that protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The current solution is flawed in several ways, the most important of which
    may be that both lists have numerous glaring omissions and, given the number of
    network protocols devised to date, simply have no chance of ever being exhaustive.
    For example, no rule would prevent the browser from talking to Internet Relay
    Chat (IRC) servers, which use a fault-tolerant, text-based protocol not entirely
    unlike SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lists are also not regularly updated to reflect the demise of nearly extinct
    network protocols or the introduction of new ones. Lastly, they can unfairly and
    unexpectedly penalize system administrators for picking nonstandard ports for
    certain services they want to hide from public view: Doing so means opting out
    of this browser-level protection mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on Third-Party Cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since their inception, HTTP cookies have been misunderstood as the tool that
    enabled online advertisers to violate users’ privacy to an unprecedented and previously
    unattainable extent. This sentiment has been echoed by the mainstream press in
    the years since. For example, in 2001, the *New York Times* published a lengthy
    exposé on the allegedly unique risks of HTTP cookies and even quoted Lawrence
    Lessig, a noted legal expert and a political activist:^([[216](pr03.html#ftn.CHP-12-FT-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Before cookies, the Web was essentially private. After cookies, the Web becomes
    a space capable of extraordinary monitoring.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The high-profile assault on a single HTTP header continued over the course of
    a decade, gradually shifting its focus toward third-party cookies in particular.
    Third-party cookies are the cookies set by domains other than the domain of the
    top-level document, and they are usually associated with the process of loading
    images, frames, or applets from third-party sites. The reason they have attracted
    attention is that operators of advertising networks have embraced such cookies
    as a convenient way to tag a user who sees their ad embedded on [fuzzybunnies.com](http://fuzzybunnies.com)
    and then recognize that user through a similar embedded ad served on [playboy.com](http://playboy.com).
  prefs: []
  type: TYPE_NORMAL
- en: Because the clearly undesirable possibility of performing this type of cross-domain
    tracking has been erroneously conflated with the existence of third-party cookies,
    the pressure on browser vendors has continued to mount. In one instance, the *Wall
    Street Journal* flat out accused Microsoft of being in bed with advertisers for
    not eliminating third-party cookies in the company’s product.^([[217](pr03.html#ftn.CHP-12-FT-2)])
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the readers of this book will recognize that the fixation on HTTP
    cookies is deeply misguided. There is no doubt that some parties use the mechanism
    for vaguely sinister purposes, but nothing makes it uniquely suited for this task;
    there are many other equivalent ways to store unique identifiers on visitors’
    computers (such as cache-based tags, previously discussed in [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol")). Besides, it is simply impossible to
    prevent cooperating sites from using existing unique fingerprints of every browser
    (exposed through the JavaScript object model or plug-ins such as Flash) to correlate
    and mine cross-domain browsing patterns at will. The sites that embed advertisements
    for profit are quite willing to cooperate with the parties who pay their bills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the common reliance on HTTP cookies offers a distinctive advantage
    to users: Unlike many of the easily embraced alternatives, this mechanism is purpose
    built and coupled with reasonably well-designed and fine-grained privacy controls.
    Breaking cookies will not hinder tracking but will remove any pretense of transparency
    from the end user. Another noted privacy and security activist, Ed Felten, once
    said: “If you’re going to track me, please use cookies.”^([[218](pr03.html#ftn.CHP-12-FT-3)])'
  prefs: []
  type: TYPE_NORMAL
- en: Unscrupulous online tracking is a significant social issue, and new technical
    mechanisms may be needed so that users can communicate their privacy preferences
    to well-behaved sites (such as the recently added *DNT* request header^([[219](pr03.html#ftn.CHP-12-FT-4)])
    rolled out in Firefox 4). In order to deal with the ill-behaved ones, a regulatory
    framework may be required, too. In the absence of such a framework, in Internet
    Explorer 9, Microsoft is experimenting with a managed blacklist of known bad sources
    of tracking cookies—but the odds that this would discourage sleazy business practices
    are slim.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, despite having little or no merit, the continued public outcry
    against third-party cookies eventually resulted in several browser vendors shipping
    half-baked and easily circumvented solutions that let them claim they had done
    *something*.
  prefs: []
  type: TYPE_NORMAL
- en: In Internet Explorer, setting and reading third-party cookies is blocked by
    default, except for session cookies accompanied by a satisfactory P3P header.
    *P3P* (*Platform for Privacy Preferences*)^([[220](pr03.html#ftn.CHP-12-FT-5)])
    is a method to construct machine-readable, legally binding summaries of a site’s
    privacy policy, be it as an XML file or as a *compact policy* in an HTTP header.
    For example, the keyword TEL in an HTTP header means that the site uses the collected
    information for telemarketing purposes. (No technical measure will prevent a site
    from lying in a P3P header, but the potential legal consequences are meant to
    discourage that.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The incredibly ambitious, 111-page P3P specification caused the solution to
    crumble under its own weight. Large businesses are usually very hesitant to embrace
    P3P as a solution to technical problems because of the legal footprint of the
    spec, while small businesses and individual site owners copy over P3P header recipes
    with little or no understanding of what they are supposed to convey.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Safari, the task of setting third-party cookies is blocked by default, but
    previously issued cookies can be read freely. However, this behavior can be overridden
    if the user interacts with the cookie-setting document first. Such an interaction
    could be intentional but may very well not be: The clickjacking-related tricks
    outlined in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules")
    apply to this scenario as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other browsers, third-party cookies are permitted by default, but a configuration
    option is provided to change the behavior. Enabling this option limits the ability
    to set third-party cookies, but reading existing ones is not limited in any way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of these checks, a cookie is considered to be coming from a
    third party if it’s loaded from a completely unrelated domain. For example, a
    frame pointing to [bunnyoutlet.com](http://bunnyoutlet.com) loaded on [fuzzybunnies.com](http://fuzzybunnies.com)
    meets this criterion, but [www1.fuzzybunnies.com](http://www1.fuzzybunnies.com)
    and [www2.fuzzybunnies.com](http://www2.fuzzybunnies.com) are considered to be
    in a first-party relationship. The logic used to make this determination is fragile,
    and it suffers from the same problems that cookie *domain* scoping would. In Internet
    Explorer 6 and 7, for example, the comparisons in certain country-level domains
    are performed incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The crusade against third-party cookies could be seen as a harmless exercise,
    but it has had negative consequences, too. Browsers that reject third-party cookies
    make it very difficult to build cookie-based authentication for embeddable gadgets
    and other types of mashups, and they make it difficult to use “sandbox” domains
    to isolate untrusted but private content from the main application to limit the
    impact of script-injection flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Building Web Applications on Internal Networks
  prefs: []
  type: TYPE_NORMAL
- en: Assume that determined attackers will be able to interact with those applications
    through a victim’s browser, regardless of any network-level security controls.
    Ensure that proper engineering standards are met and require HTTPS with *secure*
    cookies for all sensitive applications in order to minimize the risk of origin
    infiltration attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Launching Non-HTTP Services, Particularly on Nonstandard Ports
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the impact of browsers unintentionally issuing HTTP requests to the
    service and the impact of having the response interpreted as HTTP/0.9\. For vulnerable
    protocols, consider dropping the connection immediately if the received data begins
    with “GET” or “POST” as one possible precaution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Using Third-Party Cookies for Gadgets or Sandboxed Content
  prefs: []
  type: TYPE_NORMAL
- en: If you need to support Internet Explorer, be prepared to use P3P policies (and
    evaluate their legal significance). If you need to support Safari, you may have
    to resort to an alternative credential storage mechanism (such as HTML5 *localStorage*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 13. Content Recognition Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at a fair number of well-intentioned browser features
    that, as the technology matured, proved to be short-sighted and outright dangerous.
    But now, brace for something special: In the history of the Web, nothing has proven
    to be as misguided as *content sniffing*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original premise behind content sniffing was simple: Browser vendors assumed
    that in some cases, it would be appropriate—even desirable—to ignore the normally
    authoritative metadata received from the server, such as the *Content-Type* header.
    Instead of honoring the developer’s declared intent, implementations that support
    content sniffing may attempt to second-guess the appropriate course of action
    by applying proprietary heuristics to the returned payload in order to compensate
    for possible mistakes. (Recall from [Chapter 1](ch01.html "Chapter 1. Security
    in the World of Web Applications") that during the First Browser Wars, vendors
    turned fault-tolerance compatibility into an ill-conceived competitive advantage.)'
  prefs: []
  type: TYPE_NORMAL
- en: It didn’t take long for content-sniffing features to emerge as a substantial
    and detrimental aspect of the overall browser security landscape. To their horror
    and disbelief, web developers soon noticed that they couldn’t safely host certain
    nominally harmless document types like *text/plain* or *text/csv* on behalf of
    their users; any attempt to do so would inevitably create a risk that such content
    could be misinterpreted as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps partly in response to these concerns, in 1999 the practice of unsolicited
    content sniffing was explicitly forbidden in HTTP/1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: If and only if the media type is not given by a *Content-Type* field, the recipient
    may attempt to guess the media type via inspection of its content and/or the name
    extension(s) of the URI used to identify the resource.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alas, this uncharacteristically clear requirement arrived a bit too late. Most
    browsers were already violating this rule to some extent, and absent a convenient
    way to gauge the potential consequences, their authors hesitated to simply ditch
    the offending code. Although several of the most egregious mistakes were cautiously
    reverted in the past decade, two companies—Microsoft and Apple—largely resisted
    the effort. They decided that interoperability with broken web applications should
    trump the obvious security problems. To pacify any detractors, they implemented
    a couple of imperfect, secondary security mechanisms intended to mitigate the
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the patchwork of content-handling policies and the subsequently deployed
    restrictions cast a long shadow on the online world, making it nearly impossible
    to build certain types of web services without resorting to contrived and sometimes
    expensive tricks. To understand these limitations, let’s begin by outlining several
    scenarios where a nominally passive document may be misidentified as HTML or something
    like it.
  prefs: []
  type: TYPE_NORMAL
- en: Document Type Detection Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest and the least controversial type of document detection heuristics,
    and the one implemented by all modern browsers, is the logic implemented to handle
    the absence of the *Content-Type* header. This situation, which is encountered
    very rarely, may be caused by the developer accidentally omitting or mistyping
    the header name or the document being loaded over a non-HTTP transport mechanism
    such as *ftp:* or *file:*.
  prefs: []
  type: TYPE_NORMAL
- en: For HTTP specifically, the original RFCs explicitly permit the browser to examine
    the payload for clues when the *Content-Type* value is not available. For other
    protocols, the same approach is usually followed, often as a natural consequence
    of the design of the underlying code.
  prefs: []
  type: TYPE_NORMAL
- en: The heuristics employed to determine the type of a document typically amount
    to checking for static signatures associated with several dozen known file formats
    (such as images and common plug-in-handled files). The response will also be scanned
    for known substrings in order to detect signatureless formats such as HTML (in
    which case, the browser will look for familiar tags—*<body>*, *<font>*, etc).
    In many browsers, noncontent signals, such as trailing *.html* or *.swf* strings
    in the path segment of the URL, are taken into account as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specifics of content-sniffing logic vary wildly from one browser to another
    and are not well documented or standardized. To illustrate, consider the handling
    of Adobe Flash (SWF) files served without *Content-Type*: In Opera, they are recognized
    unconditionally based on a content signature check; in Firefox and Safari, an
    explicit *.swf* suffix in the URL is required; and Internet Explorer and Chrome
    will not autorecognize SWF at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Rest assured, the SWF file format is not an exceptional case. For example, when
    dealing with HTML files, Chrome and Firefox will autodetect the document only
    if one of several predefined HTML tags appears at the very beginning of the file;
    while Firefox will be eager to “detect” HTML based solely on the presence of an
    *.html* extension in the URL, even if no recognizable markup is seen. Internet
    Explorer, on the other hand, will simply always default to HTML in the absence
    of *Content-Type*, and Opera will scan for known HTML tags within the first 1000
    bytes of the returned payload.
  prefs: []
  type: TYPE_NORMAL
- en: The assumption behind all this madness is that the absence of *Content-Type*
    is an expression of an intentional wish by the publisher of the page—but that
    assumption is not always accurate and has caused a fair number of security bugs.
    That said, most web servers actively enforce the presence of a *Content-Type*
    header and will insert a default value if one is not explicitly generated by the
    server-side scripts that handle user requests. So perhaps there is no need to
    worry? Well, unfortunately, this is not where the story of content sniffing ends.
  prefs: []
  type: TYPE_NORMAL
- en: Malformed MIME Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP RFC permits content sniffing only in the absence of *Content-Type*
    data; the browser is openly prohibited from second-guessing the intent of the
    webmaster if the header is present in any shape or form. In practice, however,
    this advice is not taken seriously. The next small step taken off the cliff was
    the decision to engage heuristics if the server-returned MIME type was deemed
    invalid in any way.
  prefs: []
  type: TYPE_NORMAL
- en: According to the RFC, the *Content-Type* header should consist of two slash-delimited
    alphanumeric tokens (*type/subtype*), potentially followed by other semicolon-delimited
    parameters. These tokens may contain any non-whitespace, seven-bit ASCII characters
    other than a couple of special “separators” (a generic set that includes characters
    such as “@”, “?”, and the slash itself). Most browsers attempt to enforce this
    syntax but do so inconsistently; the absence of a slash is seen almost universally
    as an invitation to content sniffing, and so is the inclusion of whitespaces and
    certain (but not all) control characters in the first portion of the identifier
    (the *type* token). On the other hand, the technically illegal use of high-bit
    characters or separators affects the validity of this field only in Opera.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for this design are difficult to understand, but to be fair, the
    security impact is still fairly limited. As far as web application developers
    are concerned, care must be exercised not to make typos in *Content-Type* values
    and not to allow users to specify arbitrary, user-controlled MIME types (merely
    validated against a blacklist of known bad options). These requirements may be
    unexpected, but usually they do not matter a lot. So, what are we ultimately getting
    at?
  prefs: []
  type: TYPE_NORMAL
- en: Special Content-Type Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first clear signal that content sniffing was becoming truly dangerous was
    the handling of a seemingly unremarkable MIME type known as *application/octet-stream*.
    This specific value is not mentioned at all in the HTTP specification but is given
    a special (if vague) role deep in the bowels of RFC 2046:^([[221](pr03.html#ftn.CHP-13-FT-1)])
  prefs: []
  type: TYPE_NORMAL
- en: The recommended action for an implementation that receives an *application/octet-stream*
    entity is to simply offer to put the data in a file, with any *Content-Transfer-Encoding*
    undone, or perhaps to use it as input to a user-specified process.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The original intent of this MIME type may not be crystal clear from the quoted
    passage alone, but it is commonly interpreted as a way for web servers to indicate
    that the returned file has no special meaning to the server and that it should
    not have one to the client. Consequently, most web servers default to *application/octet-stream*
    on all types of opaque, nonweb files, such as downloadable executables or archives,
    if no better *Content-Type* match can be found. However, in rare cases of administrator
    errors (for example, due to deletion of the essential *AddType* directives in
    Apache configuration files), web servers may also fall back to this MIME type
    on documents meant for in-browser consumption. This configuration error is, of
    course, very easy to detect and fix, but Microsoft, Opera, and Apple nevertheless
    chose to compensate for it. The browsers from these vendors eagerly engage in
    content sniffing whenever *application/octet-stream* is seen.^([[60](#ftn.CHP-13-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: This particular design decision has suddenly made it more difficult for web
    applications to host binary files on behalf of the user. For example, any code-hosting
    platform must exercise caution when returning executables or source archives as
    *application/octet-stream*, because there is a risk they may be misinterpreted
    as HTML and displayed inline. That’s a major issue for any software hosting or
    webmail system and for many other types of web apps. (It’s slightly safer for
    them to use any other generic-sounding MIME type, such as *application/binary*,
    because there is no special case for it in the browser code.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the special treatment given to *application/octet-stream*, a
    second, far more damaging exception exists for *text/plain*. This decision, unique
    to Internet Explorer and Safari, traces back to RFC 2046\. In that document, *text/plain*
    is given a dual function: first, to transmit plaintext documents (ones that *“do
    not provide for or allow formatting commands, font attribute specifications, processing
    instructions, interpretation directives, or content markup”*) and, second, to
    provide a fallback value for any text-based documents not otherwise recognized
    by the sender.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between *application/octet-stream* and *text/plain* fallback
    made perfect sense for email messages, a topic that this RFC originally dealt
    with, but proved to be much less relevant to the Web. Nevertheless, some web servers
    adopted *text/plain* as the fallback value for certain types of responses (most
    notably, the output of CGI scripts).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *text/plain* logic subsequently implemented in Internet Explorer and Safari
    in order to detect HTML in such a case is really bad news: It robs web developers
    of the ability to safely use this MIME type to generate user-specific plaintext
    documents and offers no alternatives. This has resulted in a substantial number
    of web application vulnerabilities, but to this day, Internet Explorer developers
    seem to have no regrets and have not changed the default behavior of their code.'
  prefs: []
  type: TYPE_NORMAL
- en: Safari developers, on the other hand, recognized and tried to mitigate the risk
    while keeping the functionality in place—but they failed to appreciate the complexity
    of the Web. The solution implemented in their browser is to rely on a secondary
    signal in addition to the presence of a plausible-looking HTML markup in the document
    body. The presence of an extension such as *.html* or *.xml* at the end of the
    URL path is interpreted by their implementation as a sign that content sniffing
    can be performed safely. After all, the owner of the site wouldn’t name the file
    this way otherwise, right?
  prefs: []
  type: TYPE_NORMAL
- en: Alas, the signal they embraced is next to worthless. As it turns out, almost
    all web frameworks support at least one of several methods for encoding parameters
    in the path segment of the URL instead of in the more traditionally used query
    part. For example, in Apache, one such mechanism is known as PATH_INFO, and it
    happens to be enabled by default. By leveraging such a parameter-passing scheme,
    the attacker can usually append nonfunctional garbage to the path, thereby confusing
    the browser without affecting how the server will respond to the submitted request
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following two URLs will likely have the same effect for
    websites running on Apache or IIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In some less-common web frameworks, the following approach may also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unrecognized Content Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the evident trouble with *text/plain*, the engineers working on Internet
    Explorer decided to take their browser’s heuristics even further. Internet Explorer
    applies both content sniffing and extension matching^([[61](#ftn.CHP-13-FN-2)])
    not only to a handful of generic MIME types but also to any document type not
    immediately recognized by the browser. This broad category may include everything
    from JSON (*application/json*) to multimedia formats such as Ogg Vorbis (*audio/ogg*).
  prefs: []
  type: TYPE_NORMAL
- en: Such a design is, naturally, problematic and causes serious problems when hosting
    any user-controlled document formats other than a small list of universally supported
    MIME types registered internally in the browser or when routed to a handful of
    commonly installed external applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nor do the content-sniffing habits of Internet Explorer finally end there:
    The browser will also resort to payload inspection when dealing with internally
    recognized document formats that, for any reason, can’t be parsed cleanly. In
    Internet Explorer versions prior to 8, serving a user-supplied but nonvalidated
    file claiming to be an JPEG image can lead to the response being treated as HTML.
    And it gets even more hilarious: Even a subtle mistake, such as serving a valid
    GIF file with *Content-Type: image/jpeg*, triggers the same code path. Heck, several
    years ago, Internet Explorer even detected HTML on any valid, properly served
    PNG file. Thankfully, this logic has since been disabled—but the remaining quirks
    are still a minefield.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to fully appreciate the risk of content sniffing on valid images, note
    that it is not particularly difficult to construct images that validate correctly
    but that carry attacker-selected ASCII strings—such as HTML markup—in the raw
    image data. In fact, it is relatively easy to construct images that, when scrubbed,
    rescaled, and recompressed using a known, deterministic algorithm, will have a
    nearly arbitrary string appear out of the blue in the resulting binary stream.
  prefs: []
  type: TYPE_NORMAL
- en: To its credit, in Internet Explorer 8 and beyond, Microsoft decided to disallow
    most types of gratuitous content sniffing on known MIME types in the *image/**
    category. It also disallowed HTML detection (but not XML detection) on image formats
    not recognized by the browser, such as *image/jp2* (JPEG2000).
  prefs: []
  type: TYPE_NORMAL
- en: This single tweak aside, Microsoft has proven rather unwilling to make meaningful
    changes to its content-sniffing logic, and its engineers have publicly defended
    the need to maintain compatibility with broken websites.^([[222](pr03.html#ftn.CHP-13-FT-2)])
    Microsoft probably wants to avoid the wrath of large institutional customers,
    many of whom rely on ancient and poorly designed intranet apps and depend on the
    quirks of the Internet Explorer-based monoculture on the client end.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, due to the backlash that Internet Explorer faced over its *text/plain*
    handling logic, newer versions offer a partial workaround: an optional HTTP header,
    *X-Content-Type-Options: nosniff*, which allows website owners to opt out of most
    of the controversial content heuristics. The use of this header is highly recommended;
    unfortunately, the support for it has not been backported to versions 6 and 7
    of the browser and has only a limited support in other browsers. In other words,
    it cannot be depended on as a sole defense against content sniffing.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Food for thought: According to the data collected in a 2011 survey by SHODAN
    and Chris John Riley,^([[223](pr03.html#ftn.CHP-13-FT-3)]) only about 0.6 percent
    of the 10,000 most popular websites on the Internet used this header on a site-wide
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: Defensive Uses of Content-Disposition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Content-Disposition* header, mentioned several times in [Part I](pt01.html
    "Part I. Anatomy of the Web") of this book, may be considered a defense against
    content sniffing in some use cases. The function of this header is not explained
    satisfactorily in the HTTP/1.1 specification. Instead, it is documented only in
    RFC 2183,^([[224](pr03.html#ftn.CHP-13-FT-4)]) where its role is explained only
    as it relates to mail applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Bodyparts can be designated “attachment” to indicate that they are separate
    from the main body of the mail message, and that their display should not be automatic,
    but contingent upon some further action of the user. The MUA^([[62](#ftn.CHP-13-FN-3)])
    might instead present the user of a bitmap terminal with an iconic representation
    of the attachments, or, on character terminals, with a list of attachments from
    which the user could select for viewing or storage.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The HTTP RFC acknowledges the use of *Content-Disposition: attachment* in the
    web domain but does not elaborate on its intended function. In practice, upon
    seeing this header during a normal document load, most browsers will display a
    file download dialog, usually with three buttons: “open,” “save,” and “cancel.”
    The browser will not attempt to interpret the document any further unless the
    “open” option is selected or the document is saved to disk and then opened manually.
    For the “save” option, an optional *filename* parameter included in the header
    is used to suggest the name of the download, too. If this field is absent, the
    filename will be derived from the notoriously unreliable URL path data.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the header prevents most browsers from immediately interpreting and
    displaying the returned payload, it is particularly well suited for safely hosting
    opaque, downloadable files such as the aforementioned case of archives or executables.
    Furthermore, because it is ignored on type-specific subresource loads (such as
    *<img>* or *<script>*), it may also be employed to protect user-controlled JSON
    responses, images, and so on against content sniffing risks. (The reason why all
    implementations ignore *Content-Disposition* for these types of navigation is
    not particularly clear, but given the benefits, it’s best not to question the
    logic now.)
  prefs: []
  type: TYPE_NORMAL
- en: One example of a reasonably robust use of *Content-Disposition* and other HTTP
    headers to discourage content sniffing on a JSON response may be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The defensive use of *Content-Disposition* is highly recommended where possible,
    but it is important to recognize that the mechanism is neither mandated for all
    user agents nor well documented. In less popular browsers, such as Safari Mobile,
    the header may have no effect; in mainstream browsers, such as Internet Explorer
    6, Opera, and Safari, a series of *Content-Disposition* bugs have at one point
    or another rendered the header ineffective in attacker-controlled cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem with the reliance on *Content-Disposition* is that the user
    may still be inclined to click “open.” Casual users can’t be expected to be wary
    of viewing Flash applets or HTML documents just because a download prompt gets
    in the way. In most browsers, selecting “open” puts the document in a *file:*
    origin, which may be problematic on its own (the recent improvements in Chrome
    certainly help), and in Opera, the document will be displayed in the context of
    the originating domain. Arguably, Internet Explorer makes the best choice: HTML
    documents are placed in a special sandbox using a *mark-of-the-web* mechanism
    (outlined in more detail in [Chapter 15](ch15.html "Chapter 15. Extrinsic Site
    Privileges")), but even in that browser, Java or Flash applets will not benefit
    from this feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Content Directives on Subresources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most content-related HTTP headers, such as *Content-Type*, *Content-Disposition*,
    and *X-Content-Type-Options*, have largely no effect on type-specific subresource
    loads, such as *<img>*, *<script>*, or *<embed>*. In these cases, the embedding
    party has nearly complete control over how the response will be interpreted by
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '*Content-Type* and *Content-Disposition* may also not be given much attention
    when handling requests initiated from within plug-in-executed code. For example,
    recall from [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic") that any
    *text/plain* or *text/csv* documents may be interpreted by Adobe Flash as security-sensitive
    *crossdomain.xml* policies unless an appropriate site-wide metapolicy is present
    in the root directory on the destination server. Whether you wish to call it “content
    sniffing” or just “content-type blindness,” the problem is still very real.'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, even when all previously discussed HTTP headers are used religiously,
    it is important to always consider the possibility that a third-party page may
    trick the browser into interpreting that page as one of several problematic document
    types; applets and applet-related content, PDFs, stylesheets, and scripts are
    usually of particular concern. To minimize the risk of mishaps, you should carefully
    constrain the structure and character set of any served payloads or use “sandbox”
    domains to isolate any document types that can’t be constrained particularly well.
  prefs: []
  type: TYPE_NORMAL
- en: Downloaded Files and Other Non-HTTP Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The behavior of HTTP headers such as *Content-Type*, *Content-Disposition*,
    and *X-Content-Type-Options* may be convoluted and exception ridden, but at the
    very least, they add up to a reasonably consistent whole. Still, it is easy to
    forget that in many real-world cases, the metadata contained in these headers
    is simply not available—and in that case, all bets are off. For example, the handling
    of documents retrieved over *ftp:*, or saved to disk and opened over the *file:*
    protocol, is highly browser- and protocol-specific and often surprises even the
    most seasoned security experts.
  prefs: []
  type: TYPE_NORMAL
- en: When opening local files, browsers usually give precedence to file extension
    data, and if the extension is one of the hardcoded values known to the browser,
    such as *.txt* or *.html*, most browsers will take this information at face value.
    Chrome is the exception; it will attempt to autodetect certain “passive” document
    types, such as JPEG, even inside *.txt* documents. (HTML, however, is strictly
    off-limits.)
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to other extensions registered to external programs, the behavior
    is a bit less predictable. Internet Explorer will usually invoke the external
    application, but most other browsers will resort to content sniffing, behaving
    as though they loaded the document over HTTP with no *Content-Type* set. All browsers
    will also fall back to content sniffing if the extension is not known (say, *.foo*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The heavy reliance on file extension data and content sniffing for *file:*
    documents creates an interesting contrast with the normal handling of Internet-originating
    resources. On the Web, *Content-Type* is by and large the authoritative descriptor
    of document type. File extension information is ignored most of the time, and
    it is perfectly legal to host a functional JPEG file at a location such as [http://fuzzybunnies.com/gotcha.txt](http://fuzzybunnies.com/gotcha.txt).
    But what happens when this document is downloaded to disk? Well, in such case,
    the effective meaning of the resource will unexpectedly change: When accessing
    it over the *file:* protocol, the browser may insist on rendering it as a text
    file, based strictly on the extension data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example above is fairly harmless, but other content promotion vectors,
    such as an image becoming an executable, may be more troubling. To that effect,
    Opera and Internet Explorer will attempt to modify the extension to match the
    MIME type for a handful of known *Content-Type* values. Other browsers do not
    offer this degree of protection, however, and may even be thoroughly confused
    by the situation they find themselves in. [Figure 13-1](ch13.html#prompt_displayed_by_firefox_when_saving
    "Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg
    document served with Content-Disposition: attachment. The “hello.exe” filename
    is derived by the browser from a nonfunctional PATH_INFO suffix appended by the
    attacker at the end of the URL. The prompt incorrectly claims that the .exe file
    is a “JPEG Image.” In fact, when saved to disk, it will be an executable.") captures
    Firefox in one such embarrassing moment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prompt displayed by Firefox when saving a Content-Type: image/jpeg document
    served with Content-Disposition: attachment. The “hello.exe” filename is derived
    by the browser from a nonfunctional PATH_INFO suffix appended by the attacker
    at the end of the URL. The prompt incorrectly claims that the .exe file is a “JPEG
    Image.” In fact, when saved to disk, it will be an executable.](httpatomoreillycomsourcenostarchimages950033.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg
    document served with Content-Disposition: attachment. The “hello.exe” filename
    is derived by the browser from a nonfunctional PATH_INFO suffix appended by the
    attacker at the end of the URL. The prompt incorrectly claims that the .exe file
    is a “JPEG Image.” In fact, when saved to disk, it will be an executable.'
  prefs: []
  type: TYPE_NORMAL
- en: This problem underscores the importance of returning an explicit, harmless *filename*
    value whenever using a *Content-Disposition* attachment, to prevent the victim
    from being tricked into downloading a document format that the site owner never
    intended to host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the complex logic used for *file:* URLs, the simplicity of *ftp:* handling
    may come as a shock. When accessing documents over FTP, most browsers pay no special
    attention to file extensions and will simply indulge in rampant content sniffing.
    One exception is Opera, where extension data still takes precedence. From the
    engineering point of view, the prevalent approach to FTP may seem logical: The
    protocol can be considered roughly equivalent to HTTP/0.9\. Nevertheless, the
    design also violates the principle of least astonishment. Server owners would
    not expect that by allowing users to upload *.txt* documents to an FTP site, they
    are automatically consenting to host active HTML content within their domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[60](#CHP-13-FN-1)]) In Internet Explorer, this implemented logic differs
    subtly from a scenario where no *Content-Type* is present. Instead of always assuming
    HTML, the browser will scan the first 256 bytes for popular HTML tags and other
    predefined content signatures. From the security standpoint, however, it’s not
    a very significant difference.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[61](#CHP-13-FN-2)]) Naturally, path-based extension matching is essentially
    worthless for the reasons discussed in the previous section; but in the case of
    Internet Explorer 6, it gets even worse. In this browser, the extension can appear
    in the query portion of the URL. Nothing stops the attacker from simply appending
    *?foo=bar.html* to the requested URL, effectively ensuring that this check is
    always satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[62](#CHP-13-FN-3)]) MUA stands for “mail user agent,” that is, a client
    application used to retrieve, display, and compose mail messages.
  prefs: []
  type: TYPE_NORMAL
- en: Character Set Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Document type detection is one of the more important pieces of the content-processing
    puzzle, but it is certainly not the only one. For all types of text-based files
    rendered in the browser, one more determination needs to be made: The appropriate
    character set transformation must be identified and applied to the input stream.
    The output encoding sought by the browser is typically UTF-8 or UTF-16; the input,
    on the other hand, is up to the author of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest scenario, the appropriate encoding method will be provided by
    the server in a *charset* parameter of the *Content-Type* header. In the case
    of HTML documents, the same information may also be conveyed to some extent through
    the *<meta>* directive. (The browser will attempt to speculatively extract and
    interpret this directive before actually parsing the document.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the dangerous qualities of certain character encodings, as well
    as the actions taken by the browser when the *charset* parameter is not present
    or is not recognized, once again make life a lot more interesting than the aforementioned
    simple rule would imply. To understand what can go wrong, we first need to recognize
    three special classes of character sets that may alter the semantics of HTML or
    XML documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character sets that permit noncanonical representations of standard 7-bit
    ASCII codes**. Such noncanonical sequences could be used to cleverly encode HTML
    syntax elements, such as angle brackets or quotes, in a manner that survives a
    simple server-side check. For example, the famously problematic UTF-7 encoding
    permits the “<” character to be encoded as a five-character sequence of “+ADw-”,
    a string that most server-side filters will happily permit as is. In a similar
    vein, UTF-8 specification formally prohibits, but technically permits, “<” to
    be represented by unnecessarily verbose 2- to 5-byte sequences, from 0xC0 0xBC
    to 0xFC 0x80 0x80 0x80 0x80 0xBC.^([[63](#ftn.CHP-13-FN-4)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable length encodings that give special meaning to one or more bytes
    that follow a special prefix**. Such logic may result in legitimate HTML syntax
    elements being “consumed” as part of an unintentional multibyte literal. For example,
    the Shift JIS prefix code 0xE0 can cause the subsequent angle bracket or a quote
    to be consumed in Internet Explorer, Firefox, and Opera (but not in Chrome), possibly
    severely altering the meaning of the inline markup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The opposite problem may also occur: The server may be convinced that it is
    outputting a multibyte literal, but this literal may be rejected by the browser
    and interpreted as several individual characters. In EUC-KR, the 0x8E prefix is
    honored only if the subsequent character has an ASCII code of 0x41 or higher.
    Any less and it will not have the expected effect, but not all server-side implementations
    may notice.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Encodings that are completely incompatible with 8-bit ASCII**. These cases
    will simply lead to a very different view of document structure between the client
    and the server. Common examples include UTF-16 or UTF-32.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The bottom line is that unless the server has a perfect command of the character
    set it is generating and unless it is certain that the client will not apply an
    unexpected transformation to the payload, serious complications may arise. For
    example, consider a web application that removes angle brackets from the highlighted
    user-controlled string in the following piece of HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If that document is interpreted as UTF-7 by the receiving party, the actual
    parsed markup will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar problem, this time related to byte consumption in Shift JIS encoding,
    is illustrated below. A multibyte prefix is permitted to consume a closing quote,
    and as a result, the associated HTML tag is not terminated as expected, enabling
    the attacker to inject an extra *onerror* handler into the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is simply imperative to prevent character set autodetection for all text-based
    documents that contain any type of user-controlled data. Most browsers will engage
    in character set detection if the *charset* parameter is not found in the *Content-Type*
    header or in the *<meta>* tag. Some marked differences exist between the implementations
    (for example, only Internet Explorer is keen to detect UTF-7), but you should
    never assume that the outcome of character set sniffing will be safe.
  prefs: []
  type: TYPE_NORMAL
- en: Character set autodetection will also be attempted if the character set is not
    recognized or is mistyped; this problem is compounded by the fact that charset
    naming can be ambiguous and that web browsers are inconsistent in how much tolerance
    they have for common name variations. As a single data point, consider the fact
    that Internet Explorer recognizes both ISO-8859-2 and ISO8859-2 (with no dash
    after the ISO part) as valid character set identifiers in the *Content-Type* header
    but fails to recognize UTF8 as an alias for UTF-8\. The wrong choice can cause
    some serious pain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fun fact: The *X-Content-Type-Options* header has no effect on character-sniffing
    logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Byte Order Marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are not done with character set detection just yet! Internet Explorer needs
    to be singled out for yet another dramatically misguided content-handling practice:
    the tendency to give precedence to the so-called *byte order mark (BOM)*, a sequence
    of bytes that can be placed at the beginning of a file to identify its encoding,
    over the explicitly provided *charset* data. When such a marker is detected in
    the input file, the declared character set is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-1](ch13s02.html#common_byte_order_markers_open_parenthes "Table 13-1. Common
    Byte Order Markers (BOMs)") shows several common markers. Of these, the printable
    UTF-7 BOM is particularly sneaky.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1. Common Byte Order Markers (BOMs)
  prefs: []
  type: TYPE_NORMAL
- en: '| Encoding name | Byte order mark sequence |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-7 | “+/v” followed by “8”, “9”, “+”, or “/” |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8 | 0xEF 0xBB 0xBF |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 little endian | 0xFF 0xFE |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 big endian | 0xFE 0xFF |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 little endian | 0xFF 0xFE 0x00 0x00 |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 big endian | 0x00 0x00 0xFE 0xFF |'
  prefs: []
  type: TYPE_TB
- en: '| GB −18030 | 0x84 0x31 0x95 0x33 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft engineers acknowledge the problem with this design and, as of this
    writing, say that the logic may be revised, depending on the outcome of compatibility
    tests. If the problem is resolved by the time this book hits the shelves, kudos
    to them. Until then, allowing the attacker to control the first few bytes of an
    HTTP response that is not otherwise protected by *Content-Disposition* may be
    a bad idea—and other than padding the response, there is no way to work around
    this glitch.
  prefs: []
  type: TYPE_NORMAL
- en: Character Set Inheritance and Override
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two additional, little-known mechanisms should be taken into account when evaluating
    the potential impact on character set handling strategies in contemporary web
    browsers. Both of these features may permit an attacker to force undesirable character
    encoding upon another page, without relying on character sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: The first apparatus in question, supported by all but Internet Explorer, is
    known as *character set inheritance*. Under this policy, any encoding defined
    for the top-level frame may be automatically applied to any framed documents that
    do not have their own, valid *charset* value set. Initially, such inheritance
    is extended to all framing scenarios, even across completely unrelated websites.
    However, when Stefan Esser, Abhishek Arya, and several other researchers demonstrated
    a number of plausible attacks that leveraged this feature to force UTF-7 parsing
    on unsuspecting targets, Firefox and WebKit developers decided to limit the behavior
    to same-origin frames. (Opera still permits cross-domain inheritance. Although
    it does not support UTF-7, other problematic encodings, such as Shift JIS, are
    fair game.)
  prefs: []
  type: TYPE_NORMAL
- en: The other mechanism that deserves mention is the ability to manually override
    the currently used character set. This feature is available through the *View
    > Encoding* menu or similar in most browsers. Using this menu to change the character
    set causes the page and all its subframes (including cross-domain ones!) to be
    reparsed using the selected encoding, regardless of any *charset* directives encountered
    earlier for that content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because users may be easily duped into selecting an alternative encoding for
    an attacker-controlled page (simply in order to view it correctly), this design
    should make you somewhat uncomfortable. Casual users can’t be expected to realize
    that their election will also apply to hidden *<iframe>* tags and that such a
    seemingly innocuous action may enable cross-site scripting attacks against unrelated
    web properties. In fact, let’s be real: Most of them will not know—and should
    not have to know—what an *<iframe>* is.'
  prefs: []
  type: TYPE_NORMAL
- en: Markup-Controlled Charset on Subresources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are nearing the end of the epic journey through the web of content-handling
    quirks, but we are not quite done yet. Astute readers may recall that in [Type-Specific
    Content Inclusion](ch04s05.html#type-specific_content_inclusion "Type-Specific
    Content Inclusion") in [Frames](ch04s05.html#frames "Frames"), I mentioned that
    on certain types of subresources (namely, stylesheets and scripts), the embedding
    page can specify its own *charset* value in order to apply a specific transformation
    to the retrieved document, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This parameter is honored by all browsers except for Opera. Where it is supported,
    it typically does not take precedence over *charset* in *Content-Type*, unless
    that second parameter is missing or unrecognized. But to every rule, there is
    an exception, and all too often, the name of this exception is Internet Explorer
    6\. In that still-popular browser, the encoding specified by the markup overrides
    HTTP data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this behavior matter in practice? To fully grasp the consequences, let’s
    also quickly return to [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"),
    where we debated the topic of securing server-generated, user-specific, JSON-like
    code against cross-domain inclusion. One example of an application that needs
    such a defense is a searchable address book in a webmail application: The search
    term is provided in the URL, and a JavaScript serialization of the matching contacts
    is returned to the browser but must be shielded from inclusion on unrelated sites.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume that the developer came up with a simple trick to prevent
    third-party web pages from loading this data through *<script src=...>*: A single
    “//” prefix is used to turn the entire response into a comment. Same-origin callers
    that use the *XMLHttpRequest* API can simply examine the response, strip the prefix,
    and pass the data to *eval(...)*—but remote callers, trying to abuse the *<script
    src=...>* syntax, will be out of luck.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this design, a request to */contact_search.php?q=smith* may yield the following
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As long as the search term is properly escaped or filtered, this scheme appears
    safe. But when we realize that the attacker may force the response to be interpreted
    as UTF-7, the picture changes dramatically. A seemingly benign search term that,
    as far as the server is concerned, contains no illegal characters could still
    unexpectedly decode to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This response, when loaded via *<script src=... charset=utf-7>* inside the victim’s
    browser, gives the attacker access to a portion of the user’s address book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not just a thought exercise: The “//” approach is fairly common on
    the Web, and Masato Kinugawa, a noted researcher, found several popular web applications
    affected by this bug. And a more contrived variant of the same attack is also
    possible against other execution-preventing prefixes, such as *while (1);*. In
    the end, the problems with cross-domain *charset* override on *<script>* tags
    is one of the reasons why in [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"),
    we strongly recommend using a robust parser-stopping prefix to prevent the interpreter
    from ever looking at any attacker-controlled bits. Oh—and if you factor in the
    support for E4X, the picture becomes even more interesting,^([[225](pr03.html#ftn.CHP-13-FT-5)])
    but let’s leave it at that.'
  prefs: []
  type: TYPE_NORMAL
- en: Detection for Non-HTTP Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To wrap up this chapter, let’s look at the last missing detail: character set
    encoding detection for documents delivered over non-HTTP protocols. As can be
    expected, documents saved to disk and subsequently opened over the *file:* protocol,
    or loaded by other means where the usual *Content-Type* metadata is absent, will
    usually be subjected to character set detection logic. However, unlike with document
    determination heuristics, there is no substantial difference among all the possible
    delivery methods: In all cases, the sniffing behavior is roughly the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no clean and portable way to address this problem for all text-based
    documents, but for HTML specifically, the impact of character set sniffing can
    be mitigated by embedding a *<meta>* directive inside the document body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You should not ditch *Content-Type* in favor of this indicator. Unlike *<meta>*,
    the header works for non-HTML content, and it is easier to enforce and audit on
    a site-wide level. That said, documents that are likely to be saved to disk and
    that contain attacker-controlled tidbits will benefit from a redundant *<meta>*
    tag. (Just make sure that this value actually matches *Content-Type*.)
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Good Security Practices for All Websites
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruct the web server to append the *X-Content-Options: nosniff* header to
    all HTTP responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consult the cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic") to set up an appropriate */crossdomain.xml* meta-policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the server to append default *charset* and *Content-Type* values on
    all responses that would otherwise not have one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are not using path-based parameter passing (such as PATH_INFO), consider
    disabling this feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Generating Documents with Partly Attacker-Controlled Contents
  prefs: []
  type: TYPE_NORMAL
- en: Always return an explicit, valid, well-known *Content-Type* value. Do not use
    *text/plain* or *application/octet-stream*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any text-based documents, return a explicit, valid, well-known *charset*
    value in the *Content-Type* header; UTF-8 is preferable to any other variable-width
    encodings. Do not assume that *application/xml+svg*, *text/csv*, and other non-HTML
    documents do not need a specified character set. For HTML, consider a redundant
    *<meta>* directive if it’s conceivable that the file may be downloaded by the
    user. Beware of typos—UTF8 is not a valid alias for UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use *Content-Disposition: attachment* and an appropriate, explicit *filename*
    value for responses that do not need to be viewed directly—including JSON data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not allow the user to control the first few bytes of the file. Constrain
    the response as much as possible. Do not pass through NULs, control characters,
    or high-bit values unless absolutely necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing server-side encoding conversions, be sure that your converters
    reject all unexpected or invalid inputs (e.g., overlong UTF-8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Hosting User-Generated Files
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider using a sandbox domain if possible. If you intend to host unconstrained
    or unknown file formats, a sandbox domain is a necessity. Otherwise, at the very
    minimum, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use *Content-Disposition: attachment* and an appropriate, explicit *filename*
    value that matches the *Content-Type* parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carefully validate the input data and always use the appropriate, commonly recognized
    MIME type. Serving JPEG as *image/gif* may lead to trouble. Refrain from hosting
    MIME types that are unlikely to be supported by popular browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refrain from using *Content-Type: application/octet-stream* and use *application/binary*
    instead, especially for unknown document types. Refrain from returning *Content-Type:
    text/plain*. Do not permit user-specified *Content-Type* headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[63](#CHP-13-FN-4)]) Today, this problem is mitigated by most browsers:
    Their parsers now have additional checks to reject overlong UTF-8 encodings as
    a matter of principle. The same cannot be said of all possible server-side UTF-8
    libraries, however.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14. Dealing with Rogue Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous five chapters, we examined a fairly broad range of browser
    security mechanisms—and looking back at them, it is fair to say that almost all
    share a common goal: to stop rogue content from improperly interfering with any
    other, legitimate web pages displayed in a browser. This is an important pursuit
    but also a fairly narrow one; subverting the boundaries between unrelated websites
    is a large part of every attacker’s repertoire but certainly not the only trick
    in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: The other significant design-level security challenge that all browsers have
    to face is that attackers may abuse well-intentioned scripting capabilities in
    order to disrupt or impersonate third-party sites without actually interacting
    with the targeted content. For example, if JavaScript code controlled by an attacker
    is permitted to create arbitrary undecorated windows on a screen, the attacker
    may find that, rather than look for a way to inject a malicious payload into the
    content served at [fuzzybunnies.com](http://fuzzybunnies.com), it may be easier
    to just open a window with a believable replica of the address bar, thus convincing
    the user that the content displayed is from a trusted site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately for victims, in the early days of the Web, no real attention
    was given to the susceptibility of JavaScript APIs to attacks meant to disrupt
    or confuse users, and, unlike cross-domain content isolation issues, this class
    of problems is still not taken very seriously. The situation is unlikely to change
    anytime soon: Vendor resources are stretched thin between addressing comparatively
    more serious implementation-level flaws in the notoriously buggy browser codebases
    and rolling out new, shiny security features that appease web application developers,
    users, and the mainstream press alike.'
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-Service Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The possibility of an attacker crashing a browser or otherwise rendering it
    inoperable is one of the most common, obvious, and least appreciated issues affecting
    the modern Web. In the era of gadgets and mashups, it can have unexpectedly unpleasant
    consequences, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most prominent reason why most browsers are susceptible to *denial-of-service
    (DoS)* attacks is due simply to a lack of planning: Neither the underlying document
    formats nor the capabilities exposed through scripting languages were designed
    to have a sensible, constrained worst-case CPU or memory footprint. In other words,
    any sufficiently complex HTML file or an endless JavaScript loop could bring the
    underlying operating system to its knees. Worse, the attempts to mandate resource
    limits or to give users a way to resume control of a runaway browser following
    a visit to a rogue page meet with resistance. For example, the authors of many
    of the recently proposed HTML5 APIs provide no advice on preventing resource exhaustion
    attacks, nor do they even acknowledge this need, because they think that any limits
    imposed today will likely hinder the growth of the Web 5 or 10 years from now.
    Browser developers, in turn, refuse to take any action absent any standards-level
    guidance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common utilitarian argument against any proposed DoS defenses is that they
    are pointless—that the browser is hopelessly easy to crash in a multitude of ways,
    so why take special measures to address a specific vector today? It’s hard to
    argue with this view, but it’s also important to note that it acts as a self-fulfilling
    prophecy: The steady increase in the number of DoS vectors is making it more and
    more unlikely that the situation will be comprehensively addressed any time soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be fair, the computational complexity of certain operations is not the only
    reason why browsers are easy to crash. Vendors are also constrained by the need
    to maintain a significant degree of synchronicity during page-rendering and script-execution
    steps (see [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts")). This design
    eliminates the need for website developers to write reentrant and thread-safe
    code and has substantial code complexity and security benefits. Unfortunately,
    it also makes it much easier for one document to lock up the entire browser, or
    at least a good portion thereof.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of all these considerations, and even if browser vendors refuse to
    acknowledge DoS risks as a specific flaw, the impact of such attacks is difficult
    to ignore. For one, whenever a browser is brought down, there is a substantial
    risk of data loss (in the browser itself or in any applications indirectly affected
    by the attack). Also, on some social-networking sites, an attacker may be able
    to lock out the victim from the site simply by sharing a rogue gadget, or perhaps
    even a well-selected image, with the victim, preventing that person from ever
    using that service again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common tricks used to take a browser out of service include loading
    complex XHTML or SVG documents, opening a very large number of windows, running
    an endless JavaScript loop that allocates memory, queuing a significant number
    of *postMessage(...)* calls, and so on. While these examples are implementation-specific,
    every browser offers a fair number of ways to achieve this goal. Even in Chrome,
    which uses separate renderer processes to isolate unrelated pages, it’s not difficult
    to bring down the entire browser: The top-level process mediates a variety of
    script-accessible and sometimes memory- or CPU-intensive tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, it’s no surprise that despite generally dismissive attitudes,
    the major browsers nevertheless implement several DoS countermeasures. They do
    not add up to a coherent strategy, and have they have been rolled out only in
    response to the widespread abuse of specific APIs or to mitigate nonmalicious
    but common programming errors. Nevertheless, let’s look at them briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Execution Time and Memory Use Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of the aforementioned need to enforce a degree of synchronicity for
    many types of JavaScript operations, most browser vendors err on the side of caution
    and execute scripts synchronously with most of the remaining browser code. This
    design has an obvious downside: A good portion of the browser may become completely
    unresponsive as the JavaScript engine is, say, trying to evaluate a bogus *while
    (1)* loop. In Opera and Chrome, the top-level user interface will still be largely
    responsive, if sluggish, but in most other browsers, it won’t even be possible
    to close the browser window using the normal UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Because endless loops are fairly easy to create by accident, in order to aid
    developers, Internet Explorer, Firefox, Chrome, and Safari enforce a modest time
    limit on any continuously or nearly continuously executing scripts. If the script
    is making the browser unresponsive for longer than a couple of seconds, the user
    will be shown a dialog and given the option to abort execution. Picking this option
    will have a result similar to encountering an unhandled exception, that is, of
    abandoning the current execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regrettably, such a limit is not a particularly robust defense against malicious
    scripts. For example, regardless of the user’s choice, it is still possible to
    resume execution through timers or event handlers, and it’s easy to avoid triggering
    the prompt in the first place by periodically returning the CPU briefly to an
    idle state in order to reset the counter. Too, as noted previously, there are
    ways to hog CPU resources without resorting to busy loops: Rendering complex XHTML,
    SVG, or XSLT documents can be just as disruptive and is not subject to any checks.'
  prefs: []
  type: TYPE_NORMAL
- en: Execution time aside, there have been attempts to control the memory footprint
    of executed scripts. The size of the call stack is limited to a browser-specific
    value between 500 and 65535, and attempting a deeper recursion will result in
    an unconditional stop. Script heap size, on the other hand, is typically not restricted
    in a meaningful way; pages can allocate and use up gigabytes of memory. In fact,
    most of the previously implemented restrictions (such as the 16MB cap in Internet
    Explorer 6) have been removed in more recent releases.
  prefs: []
  type: TYPE_NORMAL
- en: Connection Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many web applications, each web page consists not only of the proper HTML
    document retrieved from the URL visible in the address bar but also as many as
    several dozen other, separately loaded subresources, such as images, stylesheets,
    and scripts. Because requesting all of these elements through individually established
    HTTP connections can be slow, the reader may recall from [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol") that the protocol has been extended
    to offer keep-alive sessions and request pipelining. But even with these improvements,
    one stubborn problem remains. The inherent limitation of the protocol is that
    the server must always send responses in the same order that it received the requests,
    so if any of the subresources (no matter how inconsequential) takes a bit longer
    to generate, the loading of all subsequent ones will be delayed.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this problem, and to optimize performance when keep-alive requests
    or pipelining can’t be used, all browsers permit the opening of several simultaneous
    HTTP connections to the destination server. This way, the browser can issue multiple
    requests in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the parallel connection design can be expensive for the destination
    website, especially if the server relies on the traditional *fork()*-based connection-handling
    architecture.^([[64](#ftn.CHP-14-FN-1)]) Therefore, in order to limit the risk
    of accidentally or intentionally launching a distributed DoS attack, the number
    of parallel connections needs to be limited to a modest per-host value, typically
    between 4 and 16\. Furthermore, to prevent attackers from overloading the browser
    itself (or affecting the performance of the nearby networking equipment), the
    total number of simultaneous connections to all destinations is also constrained
    to a low multiple of the per-host cap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many implementations, the per-host connection limit is enforced by looking
    at DNS labels, not at IP addresses. Therefore, an attacker may still be able to
    point several bogus DNS entries in his own domains to any unrelated target IP
    and circumvent the first restriction. The global connection limit will be still
    in effect, though.
  prefs: []
  type: TYPE_NORMAL
- en: Although the number of concurrent HTTP sessions is limited, there are no practical
    restrictions on how long an active session may be kept alive (that is, as long
    as no kernel-level TCP/IP timeouts are encountered). This design may make it possible
    for attackers to simply exhaust the global connection limit by talking to a couple
    of intentionally slow destinations, preventing the user from doing anything useful
    in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Pop-Up Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *window.open(...)* and *window.showModalDialog(...)*^([[65](#ftn.CHP-14-FN-2)])
    APIs permit web pages to create new browser windows, pointing them to any otherwise
    permitted URLs. In both cases, the browser may be instructed not to show certain
    window decorations for the newly loaded document or to position the window on
    the screen in a specific way. A simple use of *window.open(...)* might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In addition to these two JavaScript methods, new windows may also be opened
    indirectly by programatically interacting with certain HTML elements. For example,
    it is possible to call the *click()* method on an HTML link or to invoke the *submit()*
    method on a form. If the relevant markup includes a *target* parameter, the resulting
    navigation will take place in a new window of a specified name.
  prefs: []
  type: TYPE_NORMAL
- en: As could be expected, the ability for random web pages to open new browser windows
    soon proved to be problematic. In the late 1990s, many players in the then-young
    online advertising industry decided they needed to attract attention to their
    ads at any cost, even at the expense of profoundly annoying and alienating their
    audiences. Automatically spawning windows solely to show a flashy advertisement
    seemed like a great way to do business and make new friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pop-up and pop-under^([[66](#ftn.CHP-14-FN-3)]) advertisements have quickly
    emerged as one of the best-known and most reviled aspects of the Web. For good
    reason, too: Especially with pop-unders, it would not be unusual to amass a dozen
    of them after two to three hours of casual browsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to widespread complaints, browser vendors stepped in and implemented a
    simple restriction: Spurious attempts by non-whitelisted pages to create new windows
    would be silently ignored.^([[67](#ftn.CHP-14-FN-4)]) Exceptions were made for
    attempts made immediately after a mouse click or a similar user action. For example,
    in the case of JavaScript, the ability to call *window.open(...)* would be granted
    to code executed in response to an *onclick* event and revoked shortly thereafter.
    (In Internet Explorer and WebKit, this permission expires the moment the event
    handler is exited. Other browsers may recognize a short grace period of one second
    or so.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pop-up blocking feature initially curtailed pop-up advertising but, ultimately,
    proved to be fairly ineffective: Many websites would simply wait for the user
    to click anywhere on the page (in order to follow a link or even scroll the document)
    and spawn new windows in response. Others simply moved on to even more disruptive
    practices such as interstitials—full-page advertisements you need to click through
    to get to the content you actually want to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advertising arms race aside, the war on *window.open(...)* is also interesting
    from the DoS perspective. Creating hundreds of thousands of windows, thereby exhausting
    OS-enforced limits on the number of UI handles, is a sure way to crash the browser
    and to disrupt other applications as well. Any mechanism that limits this capability
    would be, at least in theory, a valuable defense. No such luck: Unbelievably,
    only Internet Explorer and Chrome sensibly limit the actual number of times *window.open(...)*
    can be called in response to a single click. In other browsers, once the temporary
    permission to open windows is granted, the attacker can go completely nuts and
    open as many windows as she desires.'
  prefs: []
  type: TYPE_NORMAL
- en: Dialog Use Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Window-related woes aside, all web-originating scripts can open certain browser-
    or OS-handled dialogs. The usefulness of these dialogs to modern web applications
    is minimal, but they still constitute another interesting part of the browser
    security landscape. Dialog-initiating APIs include *window.alert(...)*, used to
    display simple text messages; *window.prompt(...)* and *window.confirm(...)*,
    used to request basic user input; and *window.print(...)*, which brings up the
    OS-level printing dialog. A couple of obscure vendor extensions, such as Mozilla’s
    *window.sidebar.addPanel(...)* and *window.sidebar.addSearchEngine(...)* (to create
    bookmarks and register new search providers, respectively), are also on this list.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned JavaScript methods aside, several types of dialogs can be
    spawned indirectly. For example, it is possible to invoke the *click()* method
    on a file upload button or to navigate to a downloadable file, which usually brings
    up the OS-supplied file selection dialog. Navigating to a URL that requires HTTP
    authentication will also typically bring up a browser-level prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what makes dialogs so interesting? The challenge with these prompts is
    quite different from that of programmatically created windows. Unlike the largely
    asynchronous *window.open(...)* API, dialogs pause the execution of JavaScript
    and defer many other actions (such as navigation or event delivery), effectively
    preventing dialogs from being created in large numbers to exhaust resources and
    crash the application. But their modal behavior is also their curse: They prevent
    any interaction with some portion of the browser until the user dismisses the
    dialog itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates an interesting loophole. If a new dialog is opened immediately
    after the old one is closed, the victim may be locked out of a vital portion of
    the browser UI, often even losing the ability to close the window or navigate
    away from the offending page. Malware authors sometimes abuse that quirk to force
    casual, panicked users to perform a dangerous action (such as downloading and
    executing an untrusted executable) just to be permitted to continue their work:
    Making any other choice in the script-initiated security prompt will only make
    the same dialog reappear over and over again.'
  prefs: []
  type: TYPE_NORMAL
- en: Probably because of this malware-related tangent, browser vendors have begun
    experimenting with less disruptive prompting methods. In Chrome, for example,
    some of the most common modal dialogs have a checkbox that allows the user to
    suppress future attempts by the page to use the offending API (until the next
    reload, that is). In Opera, it is possible to stop the execution of scripts on
    the page. And in both Opera and recent versions of Firefox, many common dialogs
    are modal only in relation to the document-controlled area of the window, still
    allowing the tab to be closed or a different URL to be entered in the address
    bar. Nevertheless, the coverage of such improvements is limited.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firefox generated a profoundly confusing and vague prompt following the execution
    of an onbeforeunload handler on a web page. The handler gives page authors a chance
    to explain the consequences of navigating away from their page (such as losing
    any unsaved data) and requests a final decision from the user.For usability reasons,
    random pages on the Internet are no longer permitted to abort pending navigation
    by means other than this specific onbeforeunload dialog. (Surprisingly, the by-design
    ability to trap the user on a rogue page forever and cancel any navigation attempts
    wasn’t received well.) In this screenshot, the first and the last line come from
    the browser itself; the middle two lines are an “explanation” supplied by an (unnamed!)
    rogue website instead. The security impact of this particular dialog is minimal,
    but it is a remarkable example of poor UI design. Sadly, a nearly identical dialog
    is also used by Internet Explorer, and most other browser dialogs are not much
    better.](httpatomoreillycomsourcenostarchimages950035.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1. Firefox generated a profoundly confusing and vague prompt following
    the execution of an onbeforeunload handler on a web page. The handler gives page
    authors a chance to explain the consequences of navigating away from their page
    (such as losing any unsaved data) and requests a final decision from the user.^([[68](#ftn.CHP-14-FN-5)])
    In this screenshot, the first and the last line come from the browser itself;
    the middle two lines are an “explanation” supplied by an (unnamed!) rogue website
    instead. The security impact of this particular dialog is minimal, but it is a
    remarkable example of poor UI design. Sadly, a nearly identical dialog is also
    used by Internet Explorer, and most other browser dialogs are not much better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many browser-level dialogs do a poor job of explaining where the prompt originated
    and its intended purpose. In some cases, such as the Firefox dialog shown in [Figure 14-1](ch14.html#firefox_generated_a_profoundly_confusing
    "Figure 14-1. Firefox generated a profoundly confusing and vague prompt following
    the execution of an onbeforeunload handler on a web page. The handler gives page
    authors a chance to explain the consequences of navigating away from their page
    (such as losing any unsaved data) and requests a final decision from the user.
    In this screenshot, the first and the last line come from the browser itself;
    the middle two lines are an “explanation” supplied by an (unnamed!) rogue website
    instead. The security impact of this particular dialog is minimal, but it is a
    remarkable example of poor UI design. Sadly, a nearly identical dialog is also
    used by Internet Explorer, and most other browser dialogs are not much better."),
    the result can be comical—and there is a more sinister side to such goofiness,
    too. Spawning authoritative-sounding dialogs that claim to be coming from the
    operating system itself is a common trick used by malware authors to confuse less
    experienced users. It’s not hard to imagine why that works.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[64](#CHP-14-FN-1)]) The traditional design of most Unix services is to have
    a master “listener” process, and then create a new process for handling every
    accepted connection. For the developer, this model is remarkable in its simplicity;
    but it comes with many significant hidden costs for the operating system, which
    sometimes finds handling more than several hundred simultaneous connections at
    once challenging.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[65](#CHP-14-FN-2)]) The little-known *showModalDialog(...)* method is a
    bit of a misnomer. It is essentially equivalent to *window.open(...)*, but it
    is supposed to vaguely emulate the behavior of a modal dialog by blocking the
    scripts in the calling context until such a “dialog” window is dismissed. The
    exact behavior of this API varies randomly from one browser to another. For example,
    it is sometimes possible for other pages to navigate the underlying window or
    execute new scripts while the original JS code that called *showModalDialog(...)*
    is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[66](#CHP-14-FN-3)]) A “pop-under” is a pop-up window that, immediately after
    its creation, is moved to the back of the window stack with the help of *opener.window.focus()*
    or *window.blur()*. Pop-unders are arguably slightly less distracting than pop-ups,
    because the user does not have to take immediate action to go back to the original
    document. They are no less despised, however.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[67](#CHP-14-FN-4)]) For example, a call to *window.open(...)* would not
    generate an exception. The return value in such a case is not standardized, however,
    making it difficult to detect a blocked pop-up reliably. In Internet Explorer
    and Firefox, the function will return *null*; in Safari, it will return another
    special value, *undefined*; in Opera, a dummy window handle will be supplied;
    and in Chrome, the returned window handle will even have a quasi-functional DOM.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[68](#CHP-14-FN-5)]) For usability reasons, random pages on the Internet
    are no longer permitted to abort pending navigation by means other than this specific
    *onbeforeunload* dialog. (Surprisingly, the by-design ability to trap the user
    on a rogue page forever and cancel any navigation attempts wasn’t received well.)
  prefs: []
  type: TYPE_NORMAL
- en: Window-Positioning and Appearance Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right, all right—let’s move beyond the arguably uninspiring and unpopular
    topic of DoS flaws. There is a lot more to the various UI-related APIs—and *window.open(...)*
    is a particularly curious case. Recall from the discussion earlier in this chapter
    that this humble function permits web applications not only to create new windows
    but also to position them in a specific spot on the screen. Several other methods,
    such as *window.moveTo(...)*, *window.resizeTo(...)*, *window.focus()*, or *window.blur()*,
    further permit such a window to be moved around the screen, scaled, or stacked
    in a particular way. Finally, *window.close()* allows it to be discreetly disposed
    of when the script no longer needs it.
  prefs: []
  type: TYPE_NORMAL
- en: As with most other UI-manipulation features, these APIs soon proved to be a
    source of pain. Following a series of amusing hacks that involved creating “hidden”
    windows by placing them partly or completely off-screen or by making them really
    tiny, these functions now require newly created windows to have certain minimal
    dimensions and to stay entirely within the visible desktop area. (It is still
    possible to create a window that constantly hops around the screen and evades
    all mouse-driven attempts to close it, but given what you’ve read so far, this
    deserves nothing but a heavy sigh.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The restrictions on window size do not mean that the entire contents of the
    address bar have to be visible to the user, however. An undersized window could
    be leveraged to mislead the user as to the origin of a document simply by carefully
    truncating the hostname, as shown in [Figure 14-2](ch14s02.html#a_window_carefully_sized_by_a_script_so
    "Figure 14-2. A window carefully sized by a script so that the real origin of
    the displayed content is elided in a confusing way. The actual URL of this cat-themed
    page is , not ."). Browser vendors have been aware of this problem since at least
    my report in 2010,^([[226](pr03.html#ftn.CHP-14-FT-1)]) but as of this writing,
    only Internet Explorer uses a somewhat convincing if subtle mitigation: It appends
    “...” at the end of any elided hostnames in the address bar.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting issue with script-controlled window positioning is the prospect
    of creating several cleverly aligned, overlapping windows to form what appears
    to be a single document window with an address bar that doesn’t correspond to
    portions of the document displayed. This attack, which I like to call *window
    splicing*, is perhaps best illustrated in [Figure 14-3](ch14s02.html#a_window-splicing_attack_in_chrome._what
    "Figure 14-3. A window-splicing attack in Chrome. What may appear as a single
    document is actually a composite of two overlapping, aligned windows. The user
    is led to believe that the file upload button comes from the domain shown in the
    address bar of the top window, but it does not. Certain visual cues indicate foul
    play (for example, part of the window border has a slightly different hue), but
    they are too subtle to be easily noticed by the user.").
  prefs: []
  type: TYPE_NORMAL
- en: '![A window carefully sized by a script so that the real origin of the displayed
    content is elided in a confusing way. The actual URL of this cat-themed page is
    , not .](httpatomoreillycomsourcenostarchimages950037.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2. A window carefully sized by a script so that the real origin of
    the displayed content is elided in a confusing way. The actual URL of this cat-themed
    page is [http://www.example.com.coredump.cx/](http://www.example.com.coredump.cx/),
    not [http://www.example.com/](http://www.example.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Window positioning offers some interesting if far-fetched attack scenarios,
    but manipulating the contents of a programmatically created window is also of
    some relevance to browser security. We have already mentioned that one of the
    features of the *window.open(...)* API is its ability to hide certain elements
    of the browser chrome (scrollbars, menus, and so on) in the newly opened window.
    An example of such a UI-restricting call is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![A window-splicing attack in Chrome. What may appear as a single document
    is actually a composite of two overlapping, aligned windows. The user is led to
    believe that the file upload button comes from the domain shown in the address
    bar of the top window, but it does not. Certain visual cues indicate foul play
    (for example, part of the window border has a slightly different hue), but they
    are too subtle to be easily noticed by the user.](httpatomoreillycomsourcenostarchimages950039.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3. A window-splicing attack in Chrome. What may appear as a single
    document is actually a composite of two overlapping, aligned windows. The user
    is led to believe that the file upload button comes from the domain shown in the
    address bar of the top window, but it does not. Certain visual cues indicate foul
    play (for example, part of the window border has a slightly different hue), but
    they are too subtle to be easily noticed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these settings, `location=no`, was meant to hide the address bar. This
    is, of course, a horrible idea: It enables the attacker not only to hide the actual
    address bar but also to load a page that simply provides a pixel-perfect image
    of the address bar showing a completely unrelated URL. Heck, with some minimal
    effort, that fake address bar may even be fully interactive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Realizing the dangers of this design, most browsers eventually began displaying
    a minimalistic, read-only address bar in any windows opened with `location=no`;
    Apple, however, sees no harm in allowing this setting to work as originally envisioned
    in the 1990s. Too bad: [Figure 14-4](ch14s02.html#allowing_websites_to_hide_the_address_ba
    "Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea.
    The displayed document is not retrieved from . Instead, the page simply displays
    a screenshot of a real address bar in a window created by window.open("...", "location=no").")
    shows a simple attack on its UI. (I contacted Apple about this attack sometime
    in 2010 but have yet to hear back.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowing websites to hide the address bar in Safari is a bad idea. The displayed
    document is not retrieved from . Instead, the page simply displays a screenshot
    of a real address bar in a window created by window.open("...", "location=no").](httpatomoreillycomsourcenostarchimages950041.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea.
    The displayed document is not retrieved from [http://www.example.com/](http://www.example.com/).
    Instead, the page simply displays a screenshot of a real address bar in a window
    created by *window.open("*[http://coredump.cx/](http://coredump.cx/)*...", "location=no")*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft has not fared much better: Although they patched up *window.open(...)*,
    they forgot about *window.createPopup(...)*, an ancient and obscure API still
    not subject to the necessary checks.'
  prefs: []
  type: TYPE_NORMAL
- en: Timing Attacks on User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problems we’ve discussed so far in this chapter may be hard to fix, but
    at least in principle, the solutions are not out of reach. Still, here’s a preposterous
    question: Could the current model of web scripting be fundamentally incompatible
    with the way human beings work? By that, I do not mean merely the dangers of web-delivered
    social engineering that targets the inattentive and the easily confused; rather,
    I’m asking if it’s possible for scripts to consistently outsmart alert and knowledgeable
    victims simply due to the inherent limitations of human cognition?'
  prefs: []
  type: TYPE_NORMAL
- en: The question is outlandish enough not to be asked often, yet the answer may
    be yes. Consider that in a typical, attentive human subject, the usual latency
    between a visual stimulus and a voluntary motor response is between 100 and 300
    milliseconds.^([[227](pr03.html#ftn.CHP-14-FT-2)]) Humans do not pause for that
    long to assess the situation after every minute muscle movement; instead, we subconsciously
    schedule a series of learned motor actions well in advance and process any sensory
    feedback as it arrives later on. For a split second, we cannot abort a premeditated
    action, even if something goes horribly wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, on today’s personal computers, a lot can happen in as little as one-tenth
    of that interval. In particular, scripts can open new windows, move them around,
    or close any existing ones; they can also initiate or abort system-level prompts.
    In such a setting, designing security-sensitive UIs is not nearly as simple as
    it seems, and some types of attacks may be simply impossible to defend against
    without a major paradigm shift in how we design software.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the issue, consider a page that attempts to start an unsolicited
    download of a dangerous file type. The download will typically initiate a browser-level
    dialog with three options: “open,” “save,” and “cancel.” Sane users will make
    that last choice—but not if the attacker robs them of a chance to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that just milliseconds after the dialog is opened, and perhaps
    before the user even registers its presence, a new window is created on top that
    hides it from view. In that window, the attacker plants a carefully positioned
    button or link that the user is likely to click, for example, a button to dismiss
    an annoying interstitial advertisement. As the user attempts to perform this perfectly
    reasonable action, the rogue page may use *onmousemove* events to monitor the
    position and velocity of the mouse pointer and fairly accurately predict the timing
    of an upcoming click. Closing the overlay window several milliseconds before that
    click, only to reveal the “open” button in the same position, will lead the user
    inevitably to make that choice in the security prompt. There is simply nothing
    the user can do. (I demonstrated a practical attack on Firefox along these lines
    in 2007.)^([[228](pr03.html#ftn.CHP-14-FT-3)])
  prefs: []
  type: TYPE_NORMAL
- en: 'In response to the attacks on security dialogs, a variety of security delays
    have been implemented in the past few years, requiring anywhere from 500 milliseconds
    to 5 seconds between the dialog coming into focus and any dangerous buttons being
    enabled for user input. But such delays do not sit well with browser UI designers:
    They hate them, feeling that the product should be as responsive as possible and
    that annoying the user with nonclickable buttons or countdowns is a significant
    usability issue. Some have even pushed to remove existing timeouts from legacy
    UIs.^([[69](#ftn.CHP-14-FN-6)]) HTML5 geolocation-sharing prompts are impacted
    by this view. Many browsers are not protected against the attack on this UI in
    any significant way.^([[229](pr03.html#ftn.CHP-14-FT-4)])'
  prefs: []
  type: TYPE_NORMAL
- en: To further complicate the picture, browser-level user interfaces are not the
    only concern for UI-timing attacks. The security- or privacy-sensitive functionality
    of many trusted websites can also be attacked, and fixing that problem is a lot
    harder than adding delay timers on a handful of known dangerous system-level UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Millisecond-level click or keypress hijacking aside, it has been repeatedly
    demonstrated that with minimal and seemingly innocuous conditioning, healthy and
    focused test subjects can be reliably tricked into ignoring even very prominent
    and unusual visual stimuli. The infamous Invisible Gorilla experiment,^([[230](pr03.html#ftn.CHP-14-FT-5)])
    shown in [Figure 14-5](ch14s03.html#a_single_frame_from_the_invisible_gorill "Figure 14-5. A
    single frame from the Invisible Gorilla experiment, courtesy of Daniel Simons
    (). When asked to view this video and count the number of times the players pass
    the basketball, most viewers fail to notice a person in a gorilla suit casually
    strolling across the room halfway through the clip. Really! Go to and try it on
    a friend."), is a particularly well-known example of this. Almost all viewers
    watching a clip prepared by the researchers fail to notice a plainly visible gorilla
    in a crowd. The corollary is that even savvy users can be conditioned to ignore
    cues such as changes to the address bar or to SSL indicators in the browser—a
    very disconcerting thought. The only reason why we are not trying to solve this
    problem today is that few exploit writers are behavioral scientists. But if you
    are a high-profile target, this seems like a risky bet.
  prefs: []
  type: TYPE_NORMAL
- en: '![A single frame from the Invisible Gorilla experiment, courtesy of Daniel
    Simons (). When asked to view this video and count the number of times the players
    pass the basketball, most viewers fail to notice a person in a gorilla suit casually
    strolling across the room halfway through the clip. Really! Go to and try it on
    a friend.](httpatomoreillycomsourcenostarchimages950043.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-5. A single frame from the Invisible Gorilla experiment, courtesy
    of Daniel Simons^([[231](pr03.html#ftn.CHP-14-FT-6)]) ([http://dansimons.com/](http://dansimons.com/)).
    When asked to view this video and count the number of times the players pass the
    basketball, most viewers fail to notice a person in a gorilla suit casually strolling
    across the room halfway through the clip. Really! Go to [http://theinvisiblegorilla.com/videos.html](http://theinvisiblegorilla.com/videos.html)
    and try it on a friend.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Permitting User-Created <iframe> Gadgets on Your Site
  prefs: []
  type: TYPE_NORMAL
- en: Don’t do so unless you are prepared to live with the consequences. You can’t
    reliably prevent a malicious gadget from launching DoS attacks on your users.
    Any such gadget will also be able to bring up various obscure dialogs that, as
    a rule, will not distinguish between your top-level page and the domain the gadget
    is hosted in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Building Security-Sensitive UIs
  prefs: []
  type: TYPE_NORMAL
- en: Because of the risk of UI race conditions, avoid situations where a vital setting
    can be changed with a single keypress or a single click. Require at least two
    operations (such as selecting a checkbox and then clicking Save). If single-click
    actions are unavoidable, consider examining other signals. For example, was the
    mouse pointer in the current window 500 milliseconds ago?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[69](#CHP-14-FN-6)]) See, for example, Mozilla bug 561177, where one of the
    Firefox UI engineers proposed the removal of a security delay from the plug-in
    installation prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15. Extrinsic Site Privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up the discussion of all the noteworthy browser security features, we’ll
    look at a handful of mechanisms that grant special privileges to sites hand-picked
    by the user or hardcoded by the authors of the browser itself. The approach taken
    in these cases is in stark contrast to the schemes we have discussed previously,
    all of which rely on a fairly sensible examination of intrinsic properties of
    the displayed content. Normally, the implementation would have us look at the
    source of the document, the context it is displayed in, or the nature of the operation
    that the document is attempting to perform, but barring the outcome of these checks,
    the browser would never give preferential treatment to a single otherwise unremarkable
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: Per-site privileges violate this principle of impartiality in a fairly brutal
    way, for reasons ranging from questionable to—more commonly—just utilitarian.
    There are compelling usability reasons to bring certain inherently dangerous features
    to the browser world, but there is no good way to programmatically decide which
    web applications are trustworthy enough to be given access to them. Delegating
    this task to a human being may be the best thing we can do.^([[70](#ftn.CHP-15-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the creation of a caste of privileged applications can be very problematic
    because the boundaries between any two web applications are not particularly well
    defined to begin with, making it difficult to contain the permissions precisely.
    And because the already imperfect boundaries apply only to certain cross-site
    interactions, vulnerabilities such as XSS or XSRF may further contribute to the
    misery. In the end, a significant disconnect may develop between the intent of
    a per-site permission and the actual consequences of such a grant.
  prefs: []
  type: TYPE_NORMAL
- en: Browser- and Plug-in-Managed Site Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When balancing security, privacy, and usability, browser vendors sometimes find
    themselves between a rock and a hard place. Some proposed features seem essential
    to the continued growth of the Web but are simply too dangerous to be made available
    to every website on the Internet. Examples of such problematic mechanisms include
    giving access to video camera or microphone feeds,^([[71](#ftn.CHP-15-FN-2)])
    allowing websites to query for user geolocation data,^([[72](#ftn.CHP-15-FN-3)])
    installing browser extensions or themes, or opening desktop notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a work-around for this problem, vendors require the user to approve the
    application’s request in order for it to be allowed to access a privileged API.
    On the first attempt to use restricted functionality, the user is typically provided
    with a visual cue (ranging from an icon to a modal prompt) and given three choices:
    ignore the request, permit it once, or permanently authorize the requesting site
    to access the API. Of these choices, the last one is the most interesting: If
    selected, all future access from a matching host will be automatically approved,
    sometimes without any further visual indication.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most whitelists look only at the hostname, and not at the protocol or port.
    Any entry on these lists will therefore match more than one SOP origin. In particular,
    authorizing [https://fuzzybunnies.com/](https://fuzzybunnies.com/) to access your
    camera may also authorize the nonencrypted site at [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Granting websites access to privacy- or security-sensitive features should be
    done with care, because, as noted earlier, the implications of doing so extend
    beyond merely trusting the authors of the whitelisted application. Permission
    is granted to any content executed in the matching origin, regardless of how the
    payload got there, greatly amplifying the impact of simple (and, in the long run,
    inevitable) implementation bugs. A script injection vulnerability in a privileged
    origin no longer merely exposes the data stored within the application but may
    also leak client-originating sensitive data feeds.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoded Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the list of user-authorized privileged domains, some browsers
    or browser plug-ins come with a list of vendor-selected sites or SOP origins that
    are given substantial privileges to reconfigure or update portions of the browser
    or the operating system. Some of the most prominent examples of this trend include
    [update.microsoft.com](http://update.microsoft.com), which is recognized by ActiveX
    controls that ship with Microsoft Windows and is allowed to install software updates;
    [addons.mozilla.org](http://addons.mozilla.org) and [chrome.google.com](http://chrome.google.com),
    recognized by their corresponding browsers and given special privileges to install
    extensions or themes; or [www.macromedia.com](http://www.macromedia.com), which
    is allowed to reconfigure Adobe Flash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The designs of these mechanisms vary and, as a rule, are not documented in
    a satisfactory way. Some features require second-level verification, such as a
    cryptographic signature or user consent, but others do not. Broadly speaking,
    the proliferation of such privileged domains is troubling, because it is clear
    that they will not be immune to the usual security problems that plague the rest
    of the modern Web. Case in point: [http://xssed.com/](http://xssed.com/) lists
    six publicly reported XSS vulnerabilities in [addons.mozilla.org](http://addons.mozilla.org).^([[232](pr03.html#ftn.CHP-15-FT-1)])'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[70](#CHP-15-FN-1)]) It is fair to complain that browsers do not do much
    to equip users with affirmative signals about the trustworthiness of a visited
    site, even though many robust indicators may plausibly be arrived at in an automated
    way. Blacklist-driven attempts to block known malicious sites exist, but given
    the negligible cost of registering a new domain (or compromising a random existing
    one), these approaches are arguably of less value.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[71](#CHP-15-FN-2)]) This functionality is currently supported only by plug-ins,
    such as Adobe Flash, but on track to become a part of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[72](#CHP-15-FN-3)]) This API derives user location from parameters such
    as the current IP address, the list of nearby wireless networks or cell towers,
    or the data supplied by a hardware GPS receiver. With the exception of GPS data,
    it may be necessary to consult an external service provider to map these inputs
    to physical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Form-Based Password Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Surprised? Don’t be. Mentioning password managers may seem out of place, but
    it is very useful to consider this technology as an indirect form of a site-bound
    privilege. Before we explain, let’s briefly review why password management is
    implemented in modern browsers to begin with and how it actually operates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to the first question is fairly simple: Today, almost every major
    website requires, or at least strongly encourages, all visitors to open an account.
    Logging in is typically necessary in order to customize the appearance of the
    site and is a prerequisite for interacting with other registered users. Unfortunately,
    these site-specific authentication systems are not synchronized (save for several
    limited-scale “federated login” experiments, such as OpenID),^([[233](pr03.html#ftn.CHP-15-FT-2)])
    and they effectively force the general population to create and memorize several
    dozen robust passwords, one for every destination frequented. This approach is
    difficult to sustain and leads to rampant and dangerous password reuse; that’s
    where browser vendors decided to step in.'
  prefs: []
  type: TYPE_NORMAL
- en: Form-based password managers are an inelegant but pragmatic solution to the
    problem of coping with the proliferation of per-site credentials. They apply simple
    heuristics to detect the submission of normal-looking login forms (the browser
    looks for an *<input type=password>* field and then perhaps examines the names
    of form fields for strings such as *user* and *pass*). When a suitable form is
    detected, the browser will offer to save the associated login information in a
    persistent store on the hard drive,^([[73](#ftn.CHP-15-FN-4)]) and if the user
    consents, it will then automatically retrieve and paste this data into matching
    forms encountered later on. In Firefox, Chrome, and Safari, the process of retrieving
    a stored password is automatic; in Internet Explorer and Opera, an additional
    user gesture may be required to confirm the intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of password managers is fragile but has one clear benefit: It works
    right away even without official support (or, for that matter, informed consent)
    from any websites. Web applications that are unhappy about this feature may opt
    out by appending a poorly named *autocomplete=off* parameter to the offending
    password field,^([[74](#ftn.CHP-15-FN-5)]) but beyond that, the process is almost
    completely seamless.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary way that every in-browser password manager protects stored data
    is by tying the credentials to the SOP origin where they were originally entered—paying
    close attention to the hostname, protocol, and port. Some browsers also consider
    secondary indicators, such as the ordering or naming of form fields, the URL path
    to the form, or the address to which the credentials are sent. (As we know from
    [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"), such scoping measures
    are not particularly useful from the security standpoint due to the operation
    of the same-origin policy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In browsers that autocomplete login forms without the need for human interaction,
    it is sensible to look at the mechanism as a form of a privileged API: Any content
    executing in the appropriate origin will be able to request browser-stored credentials
    by constructing a believable-looking form and then waiting for it to be automatically
    populated with login data. In order to read back this information, the script
    merely needs to examine the *value* property of the DOM element associated with
    the password field.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removing the ability to inspect values of password fields may seem like a simple
    way to improve the scheme, but it is not a very good one. The data could still
    be stolen by, say, waiting for password autocompletion, changing the data submission
    method from POST to GET, and then calling *submit()* on the login form. These
    steps would result in navigation to a page that has the password plainly visible
    in the *location.search* string. (Plus, many web applications have legitimate
    uses for reading back these fields on the client side, for example, to advise
    on password strength.)
  prefs: []
  type: TYPE_NORMAL
- en: As should be clear, the most serious risk associated with password managers
    is the amplification of XSS bugs. In web applications that use *httponly* cookies,
    a successful exploitation of an XSS flaw may give the attacker only transient
    access to a user’s account, but if the same vulnerability can be leveraged to
    steal a user’s password, the consequences are more dire and longer-lived.^([[75](#ftn.CHP-15-FN-6)])
    More obscure side effects are possible, too. For example, any application that
    allows users to construct custom form-based surveys must carefully restrict the
    layout of the generated forms or risk doubling as a password-harvesting tool.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[73](#CHP-15-FN-4)]) This data may be stored on disk as a plaintext representation,
    a naïvely obfuscated string, or a properly encrypted value protected with a “master”
    password that needs to be entered beforehand. All three methods are comparably
    vulnerable to determined attackers with access to the local system, but the plaintext
    approach is sometimes frowned upon, as it is more exposed to nosy but nontechnical
    users.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[74](#CHP-15-FN-5)]) Despite the name, this stops the browser from recording
    the password and not just from autocompleting it.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[75](#CHP-15-FN-6)]) Such consequences may extend beyond the affected application:
    Even with password managers in place, password reuse is a common, unfortunate
    trend.'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer’s Zone Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internet Explorer’s zone model^([[234](pr03.html#ftn.CHP-15-FT-3)]) is a proprietary
    attempt to reconcile the different security requirements that users (or system
    administrators) may have for different types of web applications, for example,
    a banking page and an online game. Microsoft’s approach is to establish several
    predefined classes of websites—known as *zones*—each with its own set of configurable
    security permissions. The five supported zones are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**My computer (aka local machine)** This hidden zone is used for all local
    *file:* resources (with one exception—more about it soon). The user cannot add
    or remove any elements from this set and cannot change its security settings through
    the normal user interface. Administrators and developers can modify the registry
    or use *urlmon.dll* hooks to override settings, however.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local intranet** This zone is meant to include trusted applications on a
    user’s local network. By default, *local intranet* enjoys many problematic privileges,
    such as unrestricted access to the system clipboard, the ability to open windows
    without an address bar, or the ability to bypass the usual frame navigation security
    checks (the descendant policy, outlined in [Chapter 11](ch11.html "Chapter 11. Life
    Outside Same-Origin Rules")). Members of this set are detected automatically using
    several configurable heuristics, and they may include destinations with non-fully
    qualified hostnames, addresses on the HTTP proxy exemption list,^([[76](#ftn.CHP-15-FN-7)])
    or remote *file:* URLs accessed over SMB. Manual inclusion of sites in this zone
    is also possible (in addition to or instead of the built-in heuristics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *local intranet* zone makes an implicit connection between a local network
    and a trusted environment. This connection is often dubious in the modern-day
    environment, especially given the prevalence of public Internet access over unencrypted
    Wi-Fi: Other uses of the network are not any more trustworthy than a random website
    hosted across the globe.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Trusted sites** These are nominally empty zones roughly equivalent to *local
    intranet* in terms of their security settings but managed solely by the user.
    Autodetection heuristics are unavailable, and all entries have to be created by
    hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restricted sites** In these nominally empty zones, the user may add “untrusted”
    destinations. The default settings for these zones remove many rudimentary and
    generally harmless capabilities from the loaded content (for example, *Refresh*
    headers will not work) while offering limited security benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The practicality of this zone seems unclear. Because of the need to whitelist
    every untrusted site, the zone obviously can’t be relied upon as an alternative
    to browsing the Internet with sensible default settings for previously unseen
    destinations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Internet** This is a default zone for sites not included in any of the remaining
    categories. Its default settings match the general browser security model baseline
    discussed previously in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of zones, coupled with some of their security controls, seems to
    be a step in the right direction. For example, it allows system administrators
    to fine-tune the permissions for *file:* documents without affecting the security
    or convenience of normal browsing—or to prohibit Internet sites from navigating
    to local, corporate systems (using the setting named “Websites in less privileged
    web content zone can navigate into this zone”). Unfortunately, the actual implementation
    of the zone model is muddied by a lack of focus, and in practice, it is misused
    more often than it is genuinely benefited from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first problem evident to anyone trying to master the zone mechanism is
    its obtuse terminology and the almost-comical complexity of many of the settings.
    Every zone comes with over 100 checkboxes; some of these will alter the browser
    security model profoundly, while others have no security consequences whatsoever.
    (The aforementioned *Refresh* setting is one example of a security no-op; the
    ability to disable form submission is another.) These two classes of settings
    are not distinguished in any clear way, and many are nearly impossible to comprehend
    at a glance. For example, the option “Binary and script behaviors” can be set
    to “enable” or “disable,” but the help subsystem offers no information about what
    either setting will actually do. The only explanation is provided in the official
    developer documentation posted on Microsoft’s site—but even this document can
    confuse.^([[235](pr03.html#ftn.CHP-15-FT-4)]) See for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internet Explorer contains dynamic binary behaviors: components that encapsulate
    specific functionality for HTML elements to which they were attached. These binary
    behaviors are not controlled by any Internet Explorer security setting, allowing
    them to work on Web pages in the Restricted Sites zone. In Windows Server 2003
    Service Pack 1, there is a new Internet Explorer security setting for binary behaviors.
    This new setting disables binary behaviors in the Restricted Sites zone by default.
    In combination with the Local Machine Lockdown security feature, it also requires
    administrative approval for binary behaviors to run in the Local Machine zone
    by default. This new binary behaviors security setting provides a general mitigation
    to vulnerabilities in Internet Explorer binary behaviors.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are many similar cases of settings that require a substantial effort
    to understand. For example, it is unlikely that even the most seasoned administrators
    will understand the implications of tweaking settings named “Access data sources
    across domains” or “Navigate windows and frames across different domains”. All
    this confusion has an interesting consequence: Trusted parties unintentionally
    dispense dubious advice. For example, Charles Schwab, a prominent investment bank,
    tells customers to disable the frame navigation descendant model,^([[236](pr03.html#ftn.CHP-15-FT-5)])
    essentially making HTML frames unsafe to use not only for Charles Schwab but also
    for any other website. One of the sites maintained by the Internal Revenue Service
    provides the same, extremely inconsiderate tip.^([[237](pr03.html#ftn.CHP-15-FT-6)])'
  prefs: []
  type: TYPE_NORMAL
- en: The complexity and poor documentation of Internet Explorer’s zone settings aside,
    the other problem with the zone model is the clustering of unrelated permissions.
    The settings for *local intranet* and *trusted sites* containers enable a random
    collection of features that may be required by some trusted sites—but none of
    the trusted sites could possibly require *all* of the permissions the zone entails.
    Because of this design, adding sites to privileged zones can once more have unexpectedly
    far-ranging consequences in the case of, say, a trivial XSS flaw.
  prefs: []
  type: TYPE_NORMAL
- en: Mark of the Web and Zone.Identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To maintain the integrity of the zone model on downloaded files, Internet Explorer
    further utilizes two overlapping mechanisms to track the original zone information
    for any externally retrieved document:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mark of the Web (MotW)** This simple pseudo-HTML tag is inserted at the beginning
    of HTML documents downloaded via Internet Explorer to indicate their initial source.^([[238](pr03.html#ftn.CHP-15-FT-7)])
    One example of a MotW tag may be *<!-- saved from url=(0024)*[http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    *-->*. The URL recorded in this tag is mapped to an appropriate zone; the document
    is then opened in a unique origin in that zone. The most important consesequence
    is that the downloaded content is isolated from other *file:* URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The inline nature of MotW is one of its flaws. Faux tags can be pre-inserted
    by rogue parties into HTML documents downloaded through non-Internet Explorer
    browsers, saved from email clients, or downloaded by Internet Explorer with a
    non-HTML extension (and then subjected to content sniffing). Though, to be fair,
    the privileges of *file:* documents saved without any MotW tags are significant
    enough to keep attackers relatively uninterested in hopping from the *My Computer*
    zone to, say, *Local Intranet*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Alternate Data Stream (ADS) Zone Identifier** This is a piece of NTFS metadata
    attached by Internet Explorer (and Chrome) to every downloaded file, indicating
    the numerical code of the zone the file was retrieved from.^([[239](pr03.html#ftn.CHP-15-FT-8)])
    The *Zone.Identifier* mechanism is less portable than MotW, and the information
    is lost when files are saved to non-NTFS filesystems. However, it is also more
    versatile, as it can be applied to non-HTML documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zone.Identifier* metadata is recognized by Internet Explorer itself, by the
    Windows GUI shell, and by some other Microsoft products, but third-party software
    almost universally ignores it. Where it is supported, it may result in a more
    restrictive security policy being applied to the document; more commonly, it just
    pops up a security warning about the unspecified risks of opening Internet-originating
    data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Requesting Elevated Permissions from Within a Web Application
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that requesting access to geolocation data, video or microphone
    feeds, and other privileged APIs comes with responsibility. If your site is prone
    to XSS vulnerabilities, you are gambling not only with the data stored in the
    application but with the privacy of your users. Plan accordingly and compartmentalize
    the privileged functionality well. Never ask your users to lower their Internet
    Explorer security settings to accommodate your application, and do not blindly
    follow this advice when given by others—no matter who they are.
  prefs: []
  type: TYPE_NORMAL
- en: When Writing Plug-ins or Extensions That Recognize Privileged Origins
  prefs: []
  type: TYPE_NORMAL
- en: You are putting your users at elevated risk due to inevitable web application
    security bugs. Design APIs robustly and try to use secondary security measures,
    such as cryptography, to further secure communications with your server. Do not
    whitelist nonencrypted origins, as they are prone to spoofing on open wireless
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[76](#CHP-15-FN-7)]) In configurations where a proxy is required to access
    protected internal systems but not required to access the Internet, these may
    have the unintended and scary effect of classifying the entire Web as a local
    network.
  prefs: []
  type: TYPE_NORMAL
