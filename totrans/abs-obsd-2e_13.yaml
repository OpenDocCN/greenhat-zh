- en: Chapter 13. Software Management
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章。软件管理
- en: '*Blowfish is solid,*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Blowfish 是可靠的，*'
- en: '*but the third-party software?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是第三方软件呢？*'
- en: '*Easy road to ruin.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*通往毁灭的捷径。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Most people don’t use
    an operating system; they use software, which runs atop an underlying operating
    system. No matter how robust an operating system is, it’s useless without applications.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages1616079.png) 大多数人并不使用操作系统；他们使用软件，这些软件运行在底层操作系统之上。无论操作系统多么健壮，没有应用程序它都是无用的。'
- en: 'Many commercial operating systems include hundreds or thousands of small programs:
    games, desktop toys, and everything from fancy-looking clocks to disk scrubbers
    and web browsers. Most users never touch most of these programs, but the programs
    take up disk space (and possibly other resources) just the same. Every program
    drags along some amount of infrastructure, and all of this software can cause
    any number of problems.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业操作系统包括数百或数千个小程序：游戏、桌面玩具，从看起来很酷的时钟到磁盘清理器和网络浏览器应有尽有。大多数用户从未接触过这些程序中的大多数，但程序仍然占用磁盘空间（以及可能的其他资源）。每个程序都会携带一些基础设施，所有这些软件都可能引起各种问题。
- en: Unlike many other operating systems, OpenBSD deliberately includes relatively
    little software in the default installation. You get exactly what you need to
    provide the infrastructure for software, and nothing more. While a traditional
    UNIX or Unix-like system includes compilers, games, and man pages, you don’t even
    need to install these when installing OpenBSD! Even if you install everything
    included in OpenBSD, it will have far less software than any commercial operating
    system. That’s because almost everything is considered an add-on package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他操作系统不同，OpenBSD 故意将相对较少的软件包含在默认安装中。你将获得提供软件基础设施所需的一切，没有更多。虽然传统的 UNIX 或类
    Unix 系统包括编译器、游戏和手册页，但在安装 OpenBSD 时甚至不需要安装这些！即使你安装了 OpenBSD 中包含的一切，它也将比任何商业操作系统拥有更少的软件。这是因为几乎所有东西都被视为附加包。
- en: The advantage to this sparseness is that you know exactly what’s on the system,
    which simplifies debugging. A random shared library from a program you’ve never
    used won’t break your programs. The downside is that you need to think a bit to
    decide exactly what you do want to include, and you’ll need to install those programs.
    OpenBSD makes installing software as easy as possible through the ports and packages
    system, which is introduced in this chapter. But first, let’s take a look at building
    software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种稀疏性的优点是，你知道系统上确切有什么，这简化了调试。一个来自你从未使用过的程序的随机共享库不会破坏你的程序。缺点是，你需要稍微思考一下才能决定确切需要包含什么，并且你需要安装这些程序。OpenBSD
    通过 ports 和 packages 系统尽可能简化软件安装，这些将在本章中介绍。但首先，让我们看看如何构建软件。
- en: Making Software
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作软件
- en: Building software is complicated because source code must be very specifically
    processed to create a program that works—let alone a program that works well!
    The `make(1)` program makes building software easily reproducible, so that a program
    can be built exactly as the software author intends. `make` takes its instructions
    from a configuration file, or *makefile*, which tells `make` exactly how to build
    a program from source. You don’t need to know the internals of a makefile, so
    we’re not going to dissect one here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件很复杂，因为源代码必须非常具体地处理才能创建一个能工作的程序——更不用说一个能良好工作的程序了！`make(1)` 程序使软件构建变得易于重复，因此程序可以按照软件作者的意图构建。`make`
    从配置文件或 *makefile* 中获取指令，它告诉 `make` 如何从源代码构建程序。你不需要了解 makefile 的内部结构，所以我们不会在这里分析一个。
- en: A makefile includes one or more targets and a set of instructions to carry out.
    For example, typing `make install` tells `make` to check the makefile for a procedure
    called `install` and, if found, to execute it. A target’s name usually relates
    to what `make` should be doing. The `make install` process, for example, usually
    installs the software built by previous steps. You’ll find targets to install,
    configure, and uninstall most software, and `make` handles a huge variety of functions,
    some of which far outstrip the creators’ original intentions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 包含一个或多个目标和一组执行指令。例如，输入 `make install` 告诉 `make` 检查 makefile 中是否存在名为
    `install` 的过程，如果找到，则执行它。目标名称通常与 `make` 应执行的操作相关。例如，`make install` 过程通常用于安装之前步骤构建的软件。你将找到用于安装、配置和卸载大多数软件的目标，而
    `make` 可以处理大量功能，其中一些功能远远超出了创建者的原始意图。
- en: Source Code and Software
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码和软件
- en: Source code is the human-readable instructions for building the actual machine
    code that makes up a program. You’ve probably already been exposed to some form
    of source code; if not, go look at a few files under */usr/src* (assuming, of
    course, that you installed the source code as I recommended back in [Chapter 3](ch03.html
    "Chapter 3. Installation Walk-Through")). While you don’t have to read source
    code, you should be able to recognize it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码是构建构成程序的机器代码的指令，是供人类阅读的。你可能已经接触过某种形式的源代码；如果没有，去看看*/usr/src*目录下的几个文件（当然，假设你已经像我建议的那样安装了源代码，见[第3章](ch03.html
    "第3章。安装指南"））。虽然你不必阅读源代码，但你应该能够识别它。
- en: Once you have a program’s source code, you build (or compile) the program on
    the type of system on which you want to run it. (Building software for a foreign
    platform via cross-compiling demands that you know much more about building software,
    and is not always possible.) If the software was written for an operating system
    sufficiently similar to what you’re building it on, you’ll create a working program.
    If the operating system differs too much, either the build fails or the resulting
    software won’t run. Once you’ve built the software successfully on your system,
    you can copy the resulting program (or *binary*) to other systems on the same
    platform, with the same operating system version and supporting software, and
    expect it to run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了程序源代码，你就可以在你想运行它的系统类型上构建（或编译）程序。（通过交叉编译为外国平台构建软件需要你了解更多的软件构建知识，并且并不总是可能的。）如果软件是为与你构建的操作系统足够相似的操作系统编写的，你将创建一个可工作的程序。如果操作系统差异太大，构建可能会失败，或者生成的软件无法运行。一旦你在自己的系统上成功构建了软件，你就可以将生成的程序（或*二进制文件*）复制到同一平台上的其他系统，具有相同的操作系统版本和支持软件，并期望它能够运行。
- en: Some programs are sufficiently well written that you can compile them on many
    different platforms. A few programs specifically include support for widely divergent
    platforms. For example, you can compile the Apache web server on Windows, NetWare,
    and Unix-like platforms by typing `make install`. This is quite uncommon, however,
    and takes considerable effort on the part of the software authors. It also makes
    the code more complex, and supporting all these operating systems means that it
    cannot easily support all the features that make those operating systems special.
    (But note that the ability to *build* software on a variety of platforms doesn’t
    necessarily mean that it *runs* well on all of those platforms.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序编写得足够好，以至于你可以在许多不同的平台上编译它们。一些程序特别包括对广泛不同的平台的支持。例如，你可以通过输入`make install`来在Windows、NetWare和类Unix平台上编译Apache网络服务器。然而，这种情况相当罕见，并且需要软件开发者付出相当大的努力。这也使得代码更加复杂，支持所有这些操作系统意味着它不能轻易地支持那些操作系统特有的所有功能。（但请注意，能够在各种平台上*构建*软件并不一定意味着它能在所有这些平台上*运行*得很好。）
- en: Generally speaking, if you can build a program from source, it usually runs.
    A sufficiently experienced sysadmin can use the source code and error messages
    to learn why a program won’t build, or why it builds but doesn’t run. In many
    cases, the problem is simple and can be fixed with minimal education.^([[34](#ftn.id453650)])
    This is one reason why access to source code is important.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，如果你可以从源代码构建程序，它通常可以运行。一个经验丰富的系统管理员可以使用源代码和错误信息来了解为什么程序无法构建，或者为什么它构建了但无法运行。在许多情况下，问题很简单，可以通过最少的教育来修复。[^[[34](#ftn.id453650)])
    这就是为什么访问源代码很重要的一个原因。
- en: Back when every sysadmin was a programmer, debugging software builds absorbed
    major portions of the sysadmin’s time. Every Unix-like platform was slightly (or
    wildly) different. To build programs, sysadmins needed to understand their platform,
    the software’s original platform, and the differences between the two. The duplication
    of effort to build common programs was truly horrendous. Tools such as `autoconf`
    and `configure` were intended to help simplify this problem, but these programs
    just paper over the underlying problems. Building many software packages requires
    much more time running `configure` scripts than they need to actually compile.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个系统管理员都是程序员的那些日子里，调试软件构建占据了系统管理员大部分的时间。每个类Unix平台都有细微（或极端）的差异。为了构建程序，系统管理员需要了解他们的平台、软件的原始平台以及两者之间的差异。构建常见程序的努力重复是真正可怕的。像`autoconf`和`configure`这样的工具旨在帮助简化这个问题，但这些程序只是掩盖了根本问题。构建许多软件包需要运行`configure`脚本的时间比实际编译所需的时间多得多。
- en: The OpenBSD ports and packages system removes all this pain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD Ports 和 Packages 系统消除了所有这些痛苦。
- en: The Ports and Packages System
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ports 和 Packages 系统
- en: '*Ports* are a mechanism for reproducibly and consistently building software
    on OpenBSD. *Packages* are precompiled ports for a specific OpenBSD version and
    platform. Packages install quickly and easily, and are recommended by the OpenBSD
    folks. Installing from a port takes more time and effort, but can be customized
    for your environment or server.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ports* 是在 OpenBSD 上可重复和一致地构建软件的一种机制。*Packages* 是针对特定 OpenBSD 版本和平台的预编译 Ports。软件包安装快速且简单，并且被
    OpenBSD 团队推荐。从 Ports 安装需要更多时间和精力，但可以根据您的环境或服务器进行定制。'
- en: The basic idea behind the ports system is that if source code must be modified
    or tweaked to build or run on OpenBSD, the modification process should be automated.
    If you need other software to build this program from source code or run it, those
    dependencies should be automatically used. If you record exactly which files the
    software installs, you can easily uninstall it. And if you have all of these things,
    you can pick up the software and install it on any similar OpenBSD system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ports 系统背后的基本思想是，如果源代码必须修改或调整以在 OpenBSD 上构建或运行，修改过程应该自动化。如果您需要其他软件来从源代码构建此程序或运行它，这些依赖项应该自动使用。如果您记录了软件安装的确切文件，您可以轻松地卸载它。如果您拥有所有这些，您就可以将这些软件取出来，并在任何类似的
    OpenBSD 系统上安装它。
- en: Packages are the installable files produced by the ports system. You can install
    packages over the network, either from your own package repository or from an
    OpenBSD mirror site. But before you can use a package, you must find it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包是由 Ports 系统产生的可安装文件。您可以通过网络安装软件包，无论是从您自己的软件包仓库还是从 OpenBSD 镜像站点。但在您可以使用软件包之前，您必须找到它。
- en: Using Packages
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用软件包
- en: Packages are the preferred method to install OpenBSD software. Packages are
    built by the OpenBSD Project’s ports team, and are expected to work without any
    special tweaks from the user. You must configure the software, of course, but
    the software itself should work as expected. Unless you are planning to make modifications
    to a specific piece of software, you’ll be a lot happier simply installing the
    package fetched from a nearby mirror rather than building it from the port (or,
    worse, installing from the source code without the port).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包是安装 OpenBSD 软件的首选方法。软件包由 OpenBSD 项目 Ports 团队构建，并预期无需用户进行任何特殊调整即可正常工作。当然，您必须配置软件，但软件本身应该按预期工作。除非您计划修改特定软件，否则您将非常高兴简单地安装从附近镜像获取的软件包，而不是从
    Ports 构建（或者更糟糕的是，在没有 Ports 的情况下从源代码安装）。
- en: Package Files and $PKG_PATH
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件包文件和 $PKG_PATH
- en: Every package is available as a single file named after the port it is found
    in, a version number, and a *.tgz* extension. For example, version 2.4.2 of the
    `adsuck` software is available in the file *adsuck-2.4.2.tgz*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件包都以单个文件的形式提供，文件名以软件包所在的端口名称、版本号和 *.tgz* 扩展名命名。例如，`adsuck` 软件的 2.4.2 版本可在
    *adsuck-2.4.2.tgz* 文件中找到。
- en: Before you can install packages, you need to find a source for them. Find package
    files on the official release CDs or on OpenBSD mirror sites.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够安装软件包之前，您需要找到它们的来源。在官方发布 CD 或 OpenBSD 镜像站点上找到软件包文件。
- en: The packages are on the FTP and HTTP mirrors in the directory */pub/OpenBSD/*release*/packages/*platform.
    For example, the packages for the amd64 platform for OpenBSD 5.3 are in the directory
    */pub/OpenBSD/5.3/packages/amd64*. Look at the OpenBSD mirror list. Choose a mirror
    server near you, and verify that it actually has the *packages* directory for
    the release and platform you run. My closest mirror is *[http://ftp10.usa.openbsd.org](http://ftp10.usa.openbsd.org)*.^([[35](#ftn.id366676)])
    I find the 5.3 amd64 packages at *[http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64](http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64)*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包位于 */pub/OpenBSD/*release*/packages/*platform 的 FTP 和 HTTP 镜像目录中。例如，OpenBSD
    5.3 的 amd64 平台软件包位于 */pub/OpenBSD/5.3/packages/amd64* 目录中。查看 OpenBSD 镜像列表。选择您附近的镜像服务器，并验证它实际上有您运行版本和平台的
    *packages* 目录。我最近的镜像服务器是 *[http://ftp10.usa.openbsd.org](http://ftp10.usa.openbsd.org)*.^([[35](#ftn.id366676)])
    我在 *[http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64](http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64)*
    找到了 5.3 amd64 软件包。
- en: On the official CD, you’ll find packages in */*release*/*platform*/packages*.
    (Downloaded installation CDs do not include packages.) If you mounted the 5.3
    CD at */mnt*, you would find the packages at */mnt/5.3/amd64/packages*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方 CD 上，您可以在 */release*/*platform*/packages* 目录下找到软件包。（下载的安装 CD 不包含软件包。）如果您将
    5.3 CD 挂载到 */mnt*，您将在 */mnt/5.3/amd64/packages* 下找到软件包。
- en: Once you’ve chosen a package repository, set the `$PKG_PATH` variable in your
    shell to it. This tells OpenBSD’s package management tools where to get the packages
    and gives you quick access to a single authoritative source of packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了软件包仓库，在你的 shell 中设置 `$PKG_PATH` 变量到它。这告诉 OpenBSD 的软件包管理工具在哪里获取软件包，并为你提供了快速访问单个权威软件包源的方法。
- en: If you set `$PKG_PATH` to an invalid location, `pkg_add` (the command for installing
    a package) won’t work. Using a location with packages for a different architecture
    makes `pkg_add` give an error that packages are “not for the right architecture.”
    If you choose an incorrect release, you’ll see “bad major” or other library version
    errors. Either of these types of errors mean that your `$PKG_PATH` is wrong.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `$PKG_PATH` 设置为无效位置，`pkg_add`（安装软件包的命令）将无法工作。使用不同架构的软件包位置会使 `pkg_add` 报错，表示软件包“不是为正确的架构”。如果你选择了错误的版本，你会看到“主要版本错误”或其他库版本错误。这两种类型的错误都意味着你的
    `$PKG_PATH` 是错误的。
- en: You can also list multiple package repositories. If the package tools don’t
    find a desired package in the first repository, they try the next one. This lets
    you use a local package repository for your custom packages, and then fall back
    to the official OpenBSD repository if you don’t have a local package. I use this
    when I must build a custom package for my network and want to use it across multiple
    machines.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以列出多个软件包仓库。如果软件包工具在第一个仓库中找不到所需的软件包，它们会尝试下一个。这让你可以使用本地软件包仓库来存储自定义软件包，如果你没有本地软件包，则会回退到官方
    OpenBSD 仓库。我会在必须为我的网络构建自定义软件包并希望跨多台机器使用时使用这种方法。
- en: Installing packages via FTP or HTTP is not quite as secure as installing them
    from CD. While the OpenBSD release team has verified all the packages on the CD
    set, an intruder could have tampered with whatever mirror you choose. These intrusions
    would be caught comparatively quickly, but it’s possible that you could install
    packages between the time of the intrusion and the time the damage is reversed.
    If you’re deeply concerned about package integrity, get an official CD set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 FTP 或 HTTP 安装软件包并不像从 CD 安装那样安全。虽然 OpenBSD 发布团队已经验证了 CD 集中的所有软件包，但入侵者可能会篡改你选择的任何镜像。这些入侵会被相对较快地发现，但有可能在入侵和修复损坏之间安装软件包。如果你非常关心软件包的完整性，请获取官方
    CD 集合。
- en: Finding Packages
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找软件包
- en: As I write this, the latest OpenBSD/i386 snapshot has 7485 packages on the FTP
    site. This is a long list to browse through to find the specific package you want.
    If you have the ports tree installed, you can search it for packages, but if you
    wanted to use the ports tree, you wouldn’t be using packages, now would you?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这篇文章时，最新的 OpenBSD/i386 快照在 FTP 站点上拥有 7485 个软件包。这是一个很长的列表，需要浏览以找到你想要的特定软件包。如果你已经安装了
    ports 树，你可以用它来搜索软件包，但如果你想要使用 ports 树，你不会使用软件包，对吧？
- en: Say you need a piece of software that runs only on Apache 2.2\. How can you
    find this? Find packages on the command line, or use a website.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一款只能在 Apache 2.2 上运行的软件。你该如何找到它？在命令行中查找软件包，或者使用一个网站。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most people don’t need an external web server on OpenBSD; the web servers included
    with OpenBSD are perfectly fine for average users. I would install Apache 2.2
    only if I had a specific application written for Apache 2.2\. If you want to run,
    say, a PHP web application, just use OpenBSD’s included `nginx` web server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人不需要在 OpenBSD 上安装外部 Web 服务器；OpenBSD 内置的 Web 服务器对于普通用户来说已经足够好了。我只有在有专门为 Apache
    2.2 编写的应用程序时才会安装 Apache 2.2。如果你想运行，比如说，一个 PHP Web 应用程序，只需使用 OpenBSD 内置的 `nginx`
    Web 服务器。
- en: Finding Packages on the Command Line
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在命令行中查找软件包
- en: '`pkg_info(1)` displays information about packages. While you would normally
    use `pkg_info` to explore the packages you’ve already installed, you can use `-Q`
    to run a case-insensitive search on the packages in your package repository. If
    you know part of the package name, try the package search.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg_info(1)` 显示有关软件包的信息。虽然你通常使用 `pkg_info` 来探索你已经安装的软件包，但你也可以使用 `-Q` 来对你软件包仓库中的软件包进行不区分大小写的搜索。如果你知道软件包名称的一部分，尝试进行软件包搜索。'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the names, you can guess that the package `apache-httpd-2.2.22` contains
    Apache 2.2.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称中，你可以猜测软件包 `apache-httpd-2.2.22` 包含了 Apache 2.2。
- en: Finding Packages on the Web
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在网络上查找软件包
- en: The easiest way to search packages is to use the unofficial OpenBSD Ports website
    at *[http://www.openports.se/](http://www.openports.se/)*. While this isn’t an
    official OpenBSD website, it has provided a good interface into the OpenBSD ports
    tree for several years. If I search for Apache on this site, the third hit is
    for “www/apache-httpd, apache HTTP server.”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索包的最简单方法是使用非官方的OpenBSD Ports网站*[http://www.openports.se/](http://www.openports.se/)*。虽然这不是官方的OpenBSD网站，但它已经为OpenBSD
    ports树提供良好的接口多年。如果我在这个网站上搜索Apache，第三个搜索结果是“www/apache-httpd, apache HTTP服务器”。
- en: Once you know the name of the package containing the software you want, you
    can install it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道包含你想要软件的包的名称，你就可以安装它。
- en: Installing Packages
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'Use `pkg_add(1)` to install packages. You don’t need the version number—just
    the package name. Here, I install the Apache package I found earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pkg_add(1)`安装包。你不需要版本号——只需要包名。在这里，我安装了之前找到的Apache包：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A great deal of software requires other software to run, and OpenBSD’s package
    tools track these *dependencies*. `pkg_add` starts my Apache installation by installing
    the various dependencies of the chosen package, as shown at **1**. Apache 2.2.22
    requires `libiconv` and `pcre`, among several other packages. As each package
    installs, you’ll see a progress bar scroll across the screen. If a dependency
    cannot be installed, the package installation terminates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件需要其他软件来运行，OpenBSD的包工具跟踪这些**依赖关系**。`pkg_add`通过安装所选包的各种依赖关系来启动我的Apache安装，如**1**所示。Apache
    2.2.22需要`libiconv`和`pcre`等几个其他包。随着每个包的安装，你会在屏幕上看到进度条滚动。如果某个依赖关系无法安装，包安装将终止。
- en: After installing all the dependencies, `pkg_add` installs the actual Apache
    2.2 package, as shown at **2**. At the end of package installation, you’ll see
    notices for startup scripts added by the package, as shown at **3**, and then
    any notes from the OpenBSD team about the packages, like those at **4**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装所有依赖关系后，`pkg_add`安装实际的Apache 2.2包，如**2**所示。在包安装结束时，你会看到由包添加的启动脚本的通知，如**3**所示，然后是来自OpenBSD团队的关于包的任何注释，如**4**所示。
- en: Which Files Are Installed?
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装了哪些文件？
- en: Use the `-L` option to `pkg_info` to see which files a package installs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pkg_info`的`-L`选项来查看一个包安装了哪些文件。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, all of these files are installed under */usr/local*. OpenBSD
    installs all packages under */usr/local*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有这些文件都安装在了*/usr/local*下。OpenBSD将所有包都安装在了*/usr/local*下。
- en: Verbose Installation
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 详细安装
- en: If you’re interested in the details of how `pkg_add` works, use the `-v` flag
    to trigger verbose mode. You can specify multiple `-v` flags for added detail.
    I recommend trying verbose mode a few times, in varying levels of detail, to get
    a deeper understanding of what `pkg_add` actually does.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣`pkg_add`的工作细节，使用`-v`标志来触发详细模式。你可以指定多个`-v`标志以获得更多细节。我建议尝试几次详细模式，以不同的详细程度来深入了解`pkg_add`实际上做了什么。
- en: Ambiguous Packages
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模糊的包
- en: Sometimes `pkg_add` needs an extra hint about what you want to install. For
    example, everything in my production network is tied together with LDAP, and I
    need to run an OpenLDAP mirror in each datacenter. (I could use OpenBSD’s integrated
    LDAP daemon instead, but the master servers run OpenLDAP, and I don’t want to
    mix LDAP servers.) The following is my attempt to install OpenLDAP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`pkg_add`需要额外的提示来了解你想要安装的内容。例如，我的生产网络中的所有内容都与LDAP相关联，我需要在每个数据中心运行一个OpenLDAP镜像。（我可以用OpenBSD的集成LDAP守护进程代替，但主服务器运行OpenLDAP，我不想混合LDAP服务器。）以下是我尝试安装OpenLDAP的尝试。
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see at **1**, OpenBSD has two OpenLDAP server packages: recent releases
    of version 2.3 and version 2.4\. I want version 2.4\. The OpenBSD OpenLDAP package
    is compiled with Cyrus SASL (Simple Authentication and Security Layer), which
    in turn comes in six different flavors, as you can see at **2**—one for each supported
    database. I choose the version that uses LDAP as its backend. (I don’t need this
    particular SASL; any SASL will suffice.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如**1**所示，OpenBSD有两个OpenLDAP服务器包：2.3和2.4版本的最新发布。我想要2.4版本。OpenBSD OpenLDAP包是用Cyrus
    SASL（简单身份验证和安全层）编译的，它又分为六种不同的风味，如**2**所示——每种支持的数据库对应一种。我选择使用LDAP作为其后端的版本。（我不需要这个特定的SASL；任何SASL都足够了。）
- en: '`pkg_add` realizes that this is something of a chicken-and-egg problem. LDAP
    is compiled using Cyrus, but Cyrus is compiled using LDAP. Fortunately, as you
    can see at **3**, it knows that this is a permissible configuration. The dependencies
    are installed, and then the OpenLDAP server that I want is added.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg_add` 认识到这是一个类似“先有鸡还是先有蛋”的问题。LDAP 是使用 Cyrus 编译的，但 Cyrus 是使用 LDAP 编译的。幸运的是，如您在
    **3** 处所见，它知道这是一个允许的配置。依赖项被安装，然后添加了我想要的 OpenLDAP 服务器。'
- en: Identifying Where Files Originate
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定文件来源
- en: As you’ve seen in earlier examples, many packages install other packages as
    dependencies. Once you’ve installed a few complicated software packages, */usr/local*
    starts to fill up with weird-looking files and programs. Eventually, you’ll wonder
    which packages are needed or where a package was installed from.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在早期示例中看到的，许多软件包会安装其他软件包作为依赖项。一旦您安装了一些复杂的软件包，`/usr/local` 就会开始充满看起来奇怪的文件和程序。最终，您会想知道哪些软件包是必需的，或者软件包是从哪里安装的。
- en: OpenBSD maintains records for every installed package in */var/db/pkg*, including
    files installed and dependency information, but wading through these files resembles
    effort, and I won’t do it. Also, many package names are obscure, opaque, obfuscated,
    or otherwise obtuse. (It’s not that the OpenBSD packages team tries to make package
    names incomprehensible, but there’s only so much it can do when the software has
    a name like `icu4c`.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 在 */var/db/pkg* 中维护每个已安装软件包的记录，包括已安装的文件和依赖信息，但浏览这些文件似乎是一项艰巨的任务，而且我不会这么做。此外，许多软件包名称晦涩难懂，不透明，混淆或其它难以理解。（并不是
    OpenBSD 软件包团队试图使软件包名称难以理解，但当软件名称像 `icu4c` 这样时，他们能做的也就这么多。）
- en: Thankfully, `pkg_info(1)` can easily answer most questions about your installed
    software. Start by getting a complete list of all software packages on the machine
    with the `-a` argument.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`pkg_info(1)` 可以轻松回答您关于已安装软件的大部分问题。首先，使用 `-a` 参数获取机器上所有软件包的完整列表。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hang on a minute! I’ve installed `tcsh`, of course, as my aged brain isn’t up
    to learning a new shell. I installed OpenLDAP, and chose to add `cyrus-SASL` as
    a dependency. Did `pkg_add` really install all of these other packages as dependencies?
    Or has one of my junior admins installed extra cruft? Do I really *need* all of
    these packages, or do I just need to smack a minion?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我当然已经安装了 `tcsh`，因为我的老脑筋学不会新的 shell。我安装了 OpenLDAP，并选择添加 `cyrus-SASL` 作为依赖项。`pkg_add`
    真的安装了所有这些其他软件包作为依赖项吗？或者我的初级管理员安装了额外的垃圾？我真的*需要*所有这些软件包，还是只需要敲打一个仆人？
- en: OpenBSD records which software packages you’ve installed, versus those installed
    as dependencies. Use the `-m` flag to see only those packages you manually installed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 记录了您安装的软件包，以及作为依赖项安装的软件包。使用 `-m` 标志仅显示您手动安装的软件包。
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks more familiar. Apparently everything else really is a dependency.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更熟悉。显然，其他所有东西都是依赖项。
- en: Now let’s look at some options. For longer descriptions of each package, add
    the `-d` flag or use the `-a` flag to show information for all packages. If you
    want to run `pkg_info` for a single package, use the package name as an argument.
    For example, `-L` shows the list of files a package installs. With the `-a` flag,
    it will show all files included in all installed packages, but that’s probably
    more than you want. To show all files installed by a package, use the `-L` flag
    and the package name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些选项。要获取每个软件包的更详细描述，请添加 `-d` 标志或使用 `-a` 标志显示所有软件包的信息。如果您想为单个软件包运行 `pkg_info`，请使用软件包名称作为参数。例如，`-L`
    显示软件包安装的文件列表。使用 `-a` 标志，它将显示所有已安装软件包中包含的所有文件，但这可能不是您想要的。要显示软件包安装的所有文件，请使用 `-L`
    标志和软件包名称。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `tcsh(1)` package includes the actual `tcsh` binary, the
    man page, and a whole bunch of National Language Support (NLS) files. Given a
    package name, you can identify which files are part of the package.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`tcsh(1)` 软件包包括实际的 `tcsh` 二进制文件、手册页以及一大堆国家语言支持 (NLS) 文件。给定一个软件包名称，您可以识别出哪些文件是该软件包的一部分。
- en: Going the other way, sometimes you want to know where a particular file originated.
    For example, I occasionally browse my server filesystems looking for weird stuff.
    I define “weird stuff” as “things I don’t recognize.” If I see an unfamiliar program
    or file, I’ll check to see which package installed it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，有时您想知道某个特定文件是从哪里来的。例如，我偶尔会浏览我的服务器文件系统，寻找奇怪的东西。我定义“奇怪的东西”为“我不认识的东西”。如果我看到一个不熟悉的程序或文件，我会检查它是哪个软件包安装的。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only `pluginviewer` I had previously encountered was one designed to help
    Unix web browsers run third-party software when a website demanded a plug-in.
    I don’t know what this `pluginviewer` does, but apparently it’s a legitimate part
    of `cyrus-SASL`. To find something to worry about, I need to keep looking.^([[36](#ftn.id485212)])
    If you do many file searches like this, you can get faster results by using `pkglocatedb`
    (*/usr/ports/databases/pkglocatedb*).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前遇到的唯一`pluginviewer`是设计用来帮助Unix网络浏览器在网站要求插件时运行第三方软件的。我不知道这个`pluginviewer`做什么，但显然它是`cyrus-SASL`的一个合法部分。为了找到值得担心的事情，我需要继续寻找。[^[[36](#ftn.id485212)])
    如果你进行许多此类文件搜索，可以通过使用`pkglocatedb`（*/usr/ports/databases/pkglocatedb*）来获得更快的搜索结果。
- en: After installation, many packages show a message, which I frequently read and
    promptly forget. To display this information again, use `pkg_info` with the `-M`
    flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，许多软件包会显示一条消息，我经常阅读并迅速忘记。要再次显示此信息，请使用带有`-M`标志的`pkg_info`。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you don’t remember which package had the message you wanted, use the `-a`
    flag instead of a package name to display the messages for all packages that have
    one. To show all packages that are not required by other packages, use the `-t`
    flag, which you might think matches all packages you chose to install. If you
    didn’t request a package, it could only be installed as a dependency to something
    you requested, right?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不清哪个软件包包含了你想要的消息，请使用`-a`标志而不是软件包名称来显示所有包含该消息的软件包的消息。要显示所有不是由其他软件包所需的软件包，请使用`-t`标志，你可能认为这个标志与你要安装的所有软件包匹配。如果你没有请求安装软件包，它只能作为你请求的某物的依赖项安装，对吧？
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I know that I did not choose to install `icu4c`. I have no moral objections
    to the software, mind you, but it’s nothing I requested. How did a piece of software
    that I didn’t choose to install, and isn’t required by anything else, get on this
    system?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我没有选择安装`icu4c`。请记住，我对该软件没有道德上的反对，但它并不是我请求的。一个我未选择安装且不是其他任何东西所需的软件包是如何出现在这个系统上的？
- en: It’s there because I uninstalled something that required it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它在那里是因为我卸载了需要它的东西。
- en: Uninstalling Packages
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载软件包
- en: To remove a previously installed package, use `pkg_delete(1)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除之前安装的软件包，请使用`pkg_delete(1)`。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`pkg_delete` does not request confirmation. It doesn’t ask if you are sure.
    It just blasts the software off the disk and gets on with its day. It also doesn’t
    remove the unprivileged users and groups created for the software, as you might
    still have files owned by them.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg_delete`不会请求确认。它不会询问你是否确定。它只是将软件从磁盘上删除，然后继续其日常事务。它也不会删除为软件创建的无权限用户和组，因为你可能仍然拥有它们拥有的文件。'
- en: Remember that many packages require other packages. By default, `pkg_delete`
    doesn’t remove dependencies of packages you remove. For example, earlier we saw
    that `icu4c` had been installed automatically as a leftover dependency from a
    removed OpenLDAP server package. To automatically remove unneeded dependencies,
    use the `-a` flag. For example, to completely eradicate the `openldap-server`
    package and its infrastructure from the machine, run `pkg_delete` twice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，许多软件包需要其他软件包。默认情况下，`pkg_delete`不会删除你移除的软件包的依赖项。例如，我们之前看到`icu4c`作为从移除的OpenLDAP服务器软件包中遗留的依赖项自动安装。要自动删除不需要的依赖项，请使用`-a`标志。例如，要完全从机器上清除`openldap-server`软件包及其基础设施，请运行`pkg_delete`两次。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This should clean your system of all packages installed as dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会清理你的系统，移除所有作为依赖项安装的软件包。
- en: Package Limitations
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件包限制
- en: The package system is fast, efficient, reliable, and the OpenBSD Project’s preferred
    way for users to install software. But the system does have a few limitations
    that you should be aware of, including lags in the software-porting process and
    the support for newer packages on older versions of OpenBSD.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包系统快速、高效、可靠，并且是OpenBSD项目推荐用户安装软件的方式。但该系统确实有一些限制，你应该了解，包括软件移植过程中的延迟和对旧版OpenBSD上较新软件包的支持。
- en: Each OpenBSD release supports only packages built for that release, and new
    packages are not built for old releases. The packages issued with the release
    are all you’ll get. (There are slight exceptions to this if you’re running `-stable`;
    see [Chapter 20](ch20.html "Chapter 20. Upgrading").) If you’re running OpenBSD
    5.3 and try to install packages from OpenBSD 5.4, they won’t work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个OpenBSD版本只支持为该版本构建的软件包，并且不会为旧版本构建新软件包。发布中提供的软件包就是你将得到的所有内容。（如果你运行的是`-stable`，则对此有一些轻微的例外；参见[第20章](ch20.html
    "第20章。升级"）。）如果你运行OpenBSD 5.3并尝试安装来自OpenBSD 5.4的软件包，它们将无法工作。
- en: Most packages include software produced by third parties. OpenBSD provides the
    packaging, but the software itself is released on a schedule completely independent
    of OpenBSD’s. After the software developers release their newest software, the
    OpenBSD package is updated, but there’s a gap between the software’s release date
    and the release of the OpenBSD package. A popular package might be updated in
    hours, while larger, less frequently used, or unpopular packages can languish
    at an older version for days or weeks. These packages are not officially available
    until the next OpenBSD release, so you might run software that’s a point or two
    behind the latest for a few months. Usually, this is not a problem (if it is,
    investigate OpenBSD’s `-stable` branch, discussed in [Chapter 20](ch20.html "Chapter 20. Upgrading").)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件包包括第三方生产的软件。OpenBSD 提供了打包，但软件本身是独立于 OpenBSD 的发布计划发布的。在软件开发者发布他们最新的软件后，OpenBSD
    软件包会更新，但软件的发布日期和 OpenBSD 软件包的发布日期之间存在差距。一个流行的软件包可能在几小时内更新，而较大、使用频率较低或不流行的软件包可能保持较旧版本数天或数周。这些软件包在下一个
    OpenBSD 发布之前不是官方可用的，所以你可能会运行几个月前比最新版本落后一点或两点的软件。通常，这不会成为问题（如果成为问题，可以调查 OpenBSD
    的 `-stable` 分支，在第 20 章中讨论。）
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If packages won’t work for you, investigate building third-party software through
    ports. You won’t get newer versions of the software, but you can get slightly
    different versions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法使用软件包，可以调查通过 ports 构建第三方软件。你不会获得软件的新版本，但可以获得略微不同的版本。
- en: Using Ports
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ports
- en: The ports collection is the toolkit to build OpenBSD packages. Installing software
    from ports takes longer than installing via packages, is more error-prone, and
    requires a deeper understanding of the system and the add-on software than packages
    demand. You can’t get packages for every possible situation, however (one particularly
    annoying example is when the license for a particular piece of software makes
    it illegal for the OpenBSD project to create and distribute packages), and sometimes
    ports are the only way to get third-party software on your OpenBSD system short
    of compiling it yourself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ports 集合是构建 OpenBSD 软件包的工具。从 ports 安装软件比通过软件包安装耗时更长，更容易出错，并且需要比软件包更深入地了解系统和附加软件。然而，并不是所有可能的情况都能获得软件包（一个特别令人烦恼的例子是，当特定软件的许可证使得
    OpenBSD 项目创建和分发软件包成为非法时），有时 ports 是在 OpenBSD 系统上获取第三方软件的唯一方式，除非你自己编译。
- en: What makes ports interesting is their level of automation. With one command,
    a port can find the source code for a program, download it, verify its integrity,
    apply any patches needed to make it run on OpenBSD, toggle any flags needed for
    any custom features of your system, build the code into actual binaries, produce
    a package, and install it. If you have compiled software on other platforms, you’ll
    quickly realize how ports simplify building software.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ports 的有趣之处在于它们的自动化程度。一条命令就可以让一个 ports 找到程序的源代码，下载它，验证其完整性，应用任何必要的补丁以使其在 OpenBSD
    上运行，切换任何必要的系统自定义功能标志，将代码构建成实际的二进制文件，生成一个软件包，并安装它。如果你在其他平台上编译过软件，你会很快意识到 ports
    如何简化软件构建。
- en: Like packages, ports work only on the version of OpenBSD for which they are
    released. That means that you must use the OpenBSD 5.4 ports collection on OpenBSD
    5.4; the 5.5 ports collection won’t work. Oh, it might look like it works sometimes,
    but the software will fail unpredictably, and no one will have sympathy for you
    (sympathy for your coworkers, perhaps, but not for you).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件包一样，ports 只适用于它们发布的 OpenBSD 版本。这意味着你必须使用 OpenBSD 5.4 的 ports 集合在 OpenBSD
    5.4 上；5.5 的 ports 集合将无法工作。哦，它有时可能看起来像可以工作，但软件将不可预测地失败，没有人会同情你（也许会同情你的同事，但不会同情你）。
- en: When you upgrade OpenBSD, the expectation is that you will upgrade your ports
    collection and all installed packages to the precise matching version. You might
    be able to use older packages on a newer OpenBSD, as long as you don’t delete
    the older shared libraries required by the software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你升级 OpenBSD 时，预期你会升级你的 ports 集合以及所有已安装的软件包到精确匹配的版本。你可能会在新版的 OpenBSD 上使用旧版本的软件包，只要你不删除软件所需的旧共享库。
- en: The Ports Tree
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ports 树
- en: The ports tree is usually installed in */usr/ports*. If you want the ports tree,
    you must manually fetch the *ports.tar.gz* file from your OpenBSD release and
    extract it under */usr*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Ports 树通常安装在 */usr/ports*。如果你想安装 ports 树，你必须手动从你的 OpenBSD 发布版中获取 *ports.tar.gz*
    文件，并在 */usr* 下提取它。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I suggested this way back in [Chapter 4](ch04.html "Chapter 4. Post-Install
    Setup"), but you can also get the ports tree and keep the files up to date using
    `cvs(1)`, as covered in [Chapter 20](ch20.html "Chapter 20. Upgrading"). Look
    in this directory, and you’ll find a whole bunch of directories and files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](ch04.html "第4章。安装后设置")中就建议过这种方法，但你也可以使用`cvs(1)`来获取端口树并保持文件更新，正如[第20章](ch20.html
    "第20章。升级")中所述。查看这个目录，你会找到一大堆目录和文件。
- en: The *INDEX* file contains a list of every port in the system, in alphabetical
    order but machine-readable format. You can search this file for ports, but I recommend
    using one of the tools discussed later to do so.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*INDEX* 文件包含系统中每个端口的列表，按字母顺序排列，但以机器可读的格式。你可以搜索这个文件以查找端口，但我建议使用稍后讨论的工具之一来这样做。'
- en: The *Makefile* contains the basic machine instructions for making the ports
    system work. While it’s intended for use by `make(1)`, you can learn a lot by
    reading the makefile for any port. Most of the really complicated ports code is
    in the *ports/infrastructure* directory, and all of the makefiles in the ports
    system build on that infrastructure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile* 包含使端口系统工作的基本机器指令。虽然它是为 `make(1)` 设计的，但通过阅读任何端口的makefile，你可以学到很多东西。大多数真正复杂的端口代码都在
    *ports/infrastructure* 目录中，而端口系统中的所有makefile都是基于这个基础设施构建的。'
- en: The remaining directories are software categories. Each category contains a
    further layer of directories, and each directory under a category is a port of
    a specific piece of software. OpenBSD has more than 7600 ports as of this writing,
    so this hierarchical organization is vital to keeping them in some sort of manageable
    order.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的目录是软件类别。每个类别包含进一步的目录层，每个类别下的目录都是特定软件的端口。截至本文撰写时，OpenBSD有超过7600个端口，因此这种层次结构对于保持它们某种可管理顺序至关重要。
- en: For example, the following is a listing of the contents of the *news* directory,
    which contains programs for using and managing Usenet news. This is one of the
    smaller categories. Some categories have hundreds of entries, but they’re arranged
    in much the same way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是对 *news* 目录内容的列表，该目录包含用于使用和管理Usenet新闻的程序。这是一个较小的类别。有些类别有数百个条目，但它们的排列方式大致相同。
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like the *CVS* directory in the main ports tree, the category’s *CVS* directory
    contains CVS version control information that doesn’t matter for day-to-day operation.
    The *Makefile* contains a list of valid ports within the category. You can build
    all of the ports in this category using this makefile, although that’s mostly
    useful only when building packages en masse. (When the OpenBSD Project team builds
    everything in the ports tree, it uses */usr/ports/infrastructure/bin/dpb*.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像主端口树中的 *CVS* 目录一样，该类别的 *CVS* 目录包含CVS版本控制信息，这对于日常操作并不重要。*Makefile* 包含该类别内有效端口的列表。你可以使用这个makefile构建该类别中的所有端口，尽管这主要在批量构建软件包时有用。（当OpenBSD项目团队构建端口树中的所有内容时，它使用
    */usr/ports/infrastructure/bin/dpb*。）
- en: 'Let’s go down another level. Here’s the port for `tcsh`, one of my nonnegotiable
    requirements as a sysadmin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再深入一层。这里是为 `tcsh` 提供的端口，这是作为系统管理员我不可协商的要求之一：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *CVS* directory contains version control information, as in every *CVS*
    directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*CVS* 目录包含版本控制信息，就像每个 *CVS* 目录一样。'
- en: The *Makefile* gives specific instructions for building `tcsh` on OpenBSD, including
    where to get the software and any patches, how to extract it, where the package
    can be distributed from, and any supported customizations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile* 为在OpenBSD上构建 `tcsh` 提供了具体的说明，包括获取软件和任何补丁的地方，如何提取它，软件包可以从哪里分发，以及任何支持的定制。'
- en: The *distinfo* file contains several different cryptographic hashes for the
    source code to be downloaded, to avoid building software from compromised source
    code, and the size of the source file. Newer ports contain only SHA-256 hashes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*distinfo* 文件包含要下载的源代码的几个不同的加密散列，以避免从受损害的源代码构建软件，以及源文件的尺寸。较新的端口只包含SHA-256散列。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it’s possible (difficult, but possible) to have a compromised file match
    a specific hash, it’s extremely unlikely that an altered source code file could
    match hashes computed with several different algorithms and have the same size
    as the uncompromised code. Even if people figure out how to break a particular
    hash, use of multiple hashes and the file size make compromising a source file
    nearly impossible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能（困难，但可能）存在一个被篡改的文件与特定的哈希值匹配，但一个被修改的源代码文件能够与使用几种不同的算法计算出的哈希值匹配，并且与未受损害的代码具有相同的大小，这种情况极为不可能。即使人们想出如何破解特定的哈希值，使用多个哈希值和文件大小几乎使得篡改源文件变得不可能。
- en: The *patches* directory contains code alterations needed to make this software
    run on OpenBSD. Some ports have no patches; others have dozens.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*patches* 目录包含使此软件在OpenBSD上运行的代码修改。一些端口没有补丁；其他端口有几十个。'
- en: Finally, the *pkg* directory describes the package and lists the files that
    the complete package must include.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*pkg* 目录描述了软件包并列出了完整软件包必须包含的文件。
- en: Secondary Ports
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二级端口
- en: Some ports include other ports. Here are the contents of the *emulators/fedora*
    port.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口包含其他端口。以下是 *emulators/fedora* 端口的内含内容。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The file *Makefile.inc* is new, as are the subdirectories *base*, *cups*, *motif*,
    and *sdl*. The subdirectories are independent ports. These four ports are often
    installed together, and as a whole, support OpenBSD’s Linux emulation (documented
    in `compat_linux(8)`). All four ports call in the common instructions in *Makefile.inc*.
    (The ports tree doesn’t include many of these, but don’t be shocked when you find
    one.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile.inc* 文件是新的，同样新的还有子目录 *base*、*cups*、*motif* 和 *sdl*。这些子目录是独立的端口。这四个端口通常一起安装，作为一个整体，支持OpenBSD的Linux仿真（在
    `compat_linux(8)` 中有文档说明）。所有四个端口都调用了 *Makefile.inc* 中的公共指令。（端口树不包括这些指令中的许多，但当你发现一个时不要感到惊讶。）'
- en: Read-Only Ports Tree
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读端口树
- en: The process of building a port creates an installable package and uses a whole
    bunch of temporary files, source files, and status files. By default, all of these
    files are placed inside the ports tree itself. While this works, I encourage you
    to treat */usr/ports* as a read-only OpenBSD directory tree, just like */usr/bin*,
    */usr/lib*, and so on. Doing so simplifies upgrading and identifying local changes,
    helps identify what you’ve built from ports, and saves space on the */usr* partition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构建端口的流程会创建一个可安装的软件包并使用大量临时文件、源文件和状态文件。默认情况下，所有这些文件都放置在端口树内部。虽然这样可行，但我鼓励您将 */usr/ports*
    视为一个只读的OpenBSD目录树，就像 */usr/bin*、*/usr/lib* 等一样。这样做简化了升级和识别本地更改，有助于识别您从端口构建的内容，并节省
    */usr* 分区的空间。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Build files for ports can range from a few kilobytes to several gigabytes, so
    it’s best to build ports on a large scratch partition. If you have unpartitioned
    disk space, create a partition just for building ports. Or use any partition with
    space, or even an NFS partition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 端口的构建文件可以从几千字节到几个吉字节不等，因此最好在大型临时分区上构建端口。如果您有未分区的磁盘空间，创建一个仅用于构建端口的分区。或者使用任何有空间的分区，甚至是一个NFS分区。
- en: 'Configure the ports collection by setting variables in */etc/mk.conf*. To use
    a read-only ports tree, set the variables in these directories:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 */etc/mk.conf* 中设置变量来配置端口集合。要使用只读端口树，在这些目录中设置变量：
- en: '****`WRKOBJDIR`****. Directory where the software is extracted from source
    and compiled. These can be deleted and re-created as needed.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`WRKOBJDIR`****. 从源代码提取软件并编译的目录。这些目录可以根据需要删除和重新创建。'
- en: '****`PACKAGE_REPOSITORY`****. Directory where completed packages are stored.
    The ports collection builds packages, which you can then install.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`PACKAGE_REPOSITORY`****. 存储完成软件包的目录。端口集合构建软件包，然后您可以安装它们。'
- en: '****`PLIST_DB`****. Directory where package packing lists are stored.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`PLIST_DB`****. 存储软件打包列表的目录。'
- en: '****`BULK_COOKIES_DIR`****. Directory for storing status cookies during mass
    builds of packages.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`BULK_COOKIES_DIR`****. 存储在大量构建软件包期间的状态cookie的目录。'
- en: '****`UPDATE_COOKIES_DIR`****. Directory for storing status cookies during mass
    updates of packages.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`UPDATE_COOKIES_DIR`****. 存储在大量更新软件包期间的状态cookie的目录。'
- en: '****`DISTDIR`****. Directory where vendor source code is kept. Source code
    is usually retained for reuse.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISTDIR`****. 存储供应商源代码的目录。通常保留源代码以供重用。'
- en: If these directories are owned by your regular user account, you can do a large
    part of package building without being root.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些目录属于您的常规用户账户，您可以在不作为root用户的情况下完成大部分软件打包工作。
- en: 'On one particular test system, I have hundreds of gigabytes free in */home*,
    so I chose to put my package directories there. Here’s my */etc/mk.conf*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个特定的测试系统中，我在 */home* 中有数百GB的空闲空间，所以我选择将我的包目录放在那里。这是我的 */etc/mk.conf*：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The ports system will build everything in */home/ports/wrkobjdir*. Original
    source code files go in */home/ports/distdir*. The ports system maintains various
    records in */home/ports/update_cookies* and */home/ports/bulk_cookies*. Completed
    packages go into */home/ports/pkgrepo*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ports系统将在 */home/ports/wrkobjdir* 中构建所有内容。原始源代码文件放在 */home/ports/distdir* 中。ports系统在
    */home/ports/update_cookies* 和 */home/ports/bulk_cookies* 中维护各种记录。完成的包放入 */home/ports/pkgrepo*
    中。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have a dedicated port-building machine, consider per-release package
    repositories. For example, I might have three versions of OpenBSD running at any
    given time. The package-building machine always runs the latest release, but I
    don’t want to throw away my old packages, so I use a package repository directory
    like */home/ports/pkgrepo/5.4* for packages built on a 5.4 system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个专用的端口构建机器，可以考虑按发布版本包仓库。例如，我可能在任何给定时间运行三个版本的OpenBSD。包构建机器始终运行最新版本，但我不想丢弃我的旧包，因此我使用一个包仓库目录，如
    */home/ports/pkgrepo/5.4*，用于在5.4系统上构建的包。
- en: Finding Software
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找软件
- en: As with packages, the first problem with ports is finding software you want.
    (To randomly poke around the ports tree in a pretty interface, see the *[http://www.openports.se](http://www.openports.se)*
    website.) OpenBSD has several ways to search the ports collection, including the
    ports index, keywords, and via SQL.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与包一样，ports的第一个问题是找到你想要的软件。（要在漂亮的界面中随机浏览ports树，请参阅 *[http://www.openports.se](http://www.openports.se)*
    网站。）OpenBSD有几种方式可以搜索ports集合，包括ports索引、关键词和SQL。
- en: The Ports Index
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Ports索引
- en: 'The file */usr/ports/INDEX* lists all software in the ports tree, sorted by
    category and then alphabetically. If you have a good idea what your port is called,
    you can search the file for your preferred software. The index describes each
    port in a single pipe-delimited line, much like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */usr/ports/INDEX* 按类别和字母顺序列出ports树中的所有软件。如果你对你的端口名称有一个很好的想法，你可以搜索文件以查找你首选的软件。索引以单行管道分隔符描述每个端口，就像这样：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While the ports tree itself finds this a convenient format, it’s not particularly
    human-readable. To translate this to a human-friendly format, go into */usr/ports*
    and run **`make print-index`**. (This process goes on for tens of thousands of
    lines, so feed it to a pager.) Here’s the same port in the human-readable format:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ports树本身认为这种格式很方便，但它并不特别适合人类阅读。要将此转换为适合人类阅读的格式，请进入 */usr/ports* 并运行 **`make
    print-index`**。 (这个过程可能涉及数万行，因此请将其传递给分页器。)以下是同一端口的适合人类阅读的格式：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Port` statement gives the official name of the port and the version of
    the ported software. This software is called `gcpio`, and it’s at version 2.11\.
    The `Path` gives the ports tree category and directory where the port can be found—in
    this case, *archivers/gcpio*. The `Info` line gives a very brief description of
    the software. This is the GNU version of `cpio(1)`. The `Maint`, or maintainer,
    is the person or group responsible for maintaining this software in the ports
    tree. The OpenBSD ports team supports the `gcpio` port. The best-maintained ports
    usually have an individual as a maintainer, rather than the mailing list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Port` 语句给出了端口的官方名称和被移植软件的版本。这个软件被称为 `gcpio`，版本为2.11。`Path` 给出了ports树类别和端口可以找到的目录——在这种情况下，*archivers/gcpio*。`Info`
    行给出了软件的非常简短的描述。这是 `cpio(1)` 的GNU版本。`Maint`，或维护者，是负责在ports树中维护此软件的个人或团体。OpenBSD
    ports团队支持 `gcpio` 端口。维护得最好的端口通常有一个个人作为维护者，而不是邮件列表。'
- en: The final three entries describe other software required by this software. The
    `L-deps` line lists shared libraries, `B-deps` lists software needed to build
    this port, and `R-deps` lists the port’s runtime dependencies.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个条目描述了此软件所需的其它软件。`L-deps` 行列出了共享库，`B-deps` 列出了构建此端口所需的软件，而 `R-deps` 列出了端口的运行时依赖。
- en: What good does this do? Suppose you’re still hung up on an Apache 2 web server.
    You can search *INDEX* for ports beginning with “apache.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？假设你仍然对Apache 2网络服务器感到困扰。你可以在 *INDEX* 中搜索以“apache”开头的端口。
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first three (omitted) entries are ports related to Apache, but they are
    not the web server software. The fourth line is our port.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个（省略）条目与Apache相关，但它们不是网络服务器软件。第四行是我们的端口。
- en: Gathering this information from the index is rather limited, however. If you
    don’t know the name of the software, or how OpenBSD packages the software, you
    can’t easily find the port. In that case, try one of the other methods discussed
    next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从索引中收集这些信息相当有限。如果你不知道软件的名称，或者不知道 OpenBSD 如何打包软件，你很难找到端口。在这种情况下，尝试以下讨论的其他方法之一。
- en: Finding by Keyword
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过关键词查找
- en: 'If you don’t know a package’s exact name, try the ports collection’s search
    feature: `make search` and a key scans the index for a specific word. To search
    for Apache-related software, try this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道软件包的确切名称，尝试端口集合的搜索功能：`make search` 并输入一个键来扫描索引中的特定单词。要搜索与 Apache 相关的软件，尝试以下：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On my system, this returns 62 results. You’ll need to scroll through several
    pages of possibilities, but you’ll find what you want.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，这会返回 62 个结果。你可能需要浏览几页的选项，但你会找到你想要的。
- en: You might need to try several possible keywords for a particular package, as
    some keywords have no hits and others generate too many.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的软件包，你可能需要尝试几个可能的搜索关键词，因为一些关键词没有匹配项，而其他关键词则会产生过多的结果。
- en: Finding via SQL
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 SQL 查找
- en: The `sqlports` package lets you build a database of the *INDEX* file, permitting
    you to search for ports based on highly arbitrary criteria via SQL. For example,
    say you want to know all ports that depend on `libiconv` and `expat`. In this
    case, `sqlports` is your friend. Install it from ports or packages, and it will
    automatically build a database in */usr/local/share/sqlports* from *INDEX*, and
    then use OpenBSD’s `sqlite3` to query the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlports` 软件包允许你构建一个基于 *INDEX* 文件的数据库，使你能够通过 SQL 查询根据高度任意的标准搜索端口。例如，假设你想知道所有依赖于
    `libiconv` 和 `expat` 的端口。在这种情况下，`sqlports` 是你的好朋友。从端口或软件包中安装它，它将自动从 *INDEX* 构建一个数据库在
    */usr/local/share/sqlports*，然后使用 OpenBSD 的 `sqlite3` 查询数据库。'
- en: 'I won’t teach SQL^([[37](#ftn.id431051)]) here, but just as an example, here’s
    how to search for ports whose name includes the string “apache” using `sqlports`
    (which can build much more complex queries than this one):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不会教授 SQL^([[37](#ftn.id431051)]), 但仅作为一个例子，以下是如何使用 `sqlports`（它可以构建比这更复杂的查询）来搜索名称中包含字符串“apache”的端口：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Apache `httpd` server is the fourth hit, but there are another dozen or
    so ports. Every name that begins with `p5-` is a Perl module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Apache 的 `httpd` 服务器是第四个搜索结果，但还有大约十几个端口。所有以 `p5-` 开头的名称都是 Perl 模块。
- en: Building Ports
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建端口
- en: You’ve decided to ignore the OpenBSD team’s recommendations to use packages,
    downloaded and extracted the ports tree, found software you need to install from
    ports, and designated an area for building ports. Now what?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经决定忽略 OpenBSD 团队关于使用软件包的建议，下载并提取了端口树，从端口中找到了需要安装的软件，并指定了一个构建端口的区域。现在怎么办？
- en: 'The port directories don’t contain actual source code. When you build a package
    from a port, the system does the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 端口目录不包含实际的源代码。当你从一个端口构建软件包时，系统会执行以下操作：
- en: Automatically downloads the appropriate source code from an approved Internet
    site
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从批准的互联网站点自动下载适当的源代码
- en: Checks the downloaded code for integrity errors
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查下载的代码是否存在完整性错误
- en: Extracts the code to the build area
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码提取到构建区域
- en: Patches the code
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补代码
- en: Compiles the code
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码
- en: Creates the package
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建软件包
- en: Installs the package (optional)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装软件包（可选）
- en: Additionally, if the port you’re adding has unmet dependencies, the system also
    handles installing those dependencies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你添加的端口有未满足的依赖项，系统也会处理安装这些依赖项。
- en: 'To make all this happen, just go to the *port* directory and enter this command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使所有这些发生，只需转到 *端口* 目录并输入以下命令：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should see the port build the software, create the package, and install
    the package on your system.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到端口在构建软件，创建软件包，并在你的系统上安装软件包。
- en: What a Port Installation Does
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口安装的作用
- en: 'It’s time to dissect a port build and installation. Here’s how to install `tcsh`
    from a port:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候剖析端口构建和安装过程了。以下是从端口安装 `tcsh` 的方法：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The port first checks to see if the software’s required libraries are in place.
    Building `tcsh` requires the `termlib` and `c` libraries. The port finds `termlib`
    but not a file containing the `tcsh` source code on the local system, so the port
    fetches the code. (When building a port, you should see the system downloading
    the appropriate source code.) The port then verifies the checksum of the downloaded
    code. If the port can’t get all of the code, or the checksums don’t match, the
    build process stops.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 端口首先检查软件所需的库是否已安装。构建 `tcsh` 需要的库包括 `termlib` 和 `c` 库。端口找到了 `termlib`，但在本地系统中没有找到包含
    `tcsh` 源代码的文件，因此端口会下载代码。（在构建端口时，你应该看到系统正在下载适当的源代码。）端口随后验证下载代码的校验和。如果端口无法获取所有代码，或者校验和不匹配，构建过程将停止。
- en: 'Once all necessary source code is downloaded and verified, the build continues
    with something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必要的源代码都已下载并验证，构建将继续进行，如下所示：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The port extracts the source code from the compressed file(s), applies any OpenBSD-specific
    patches, and starts the build process. (Many of you know that `configure` is not
    the same as building software, but not all software requires a `configure` step.
    The port knows what to do.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 端口从压缩文件（夹）中提取源代码，应用任何针对 OpenBSD 的特定补丁，并开始构建过程。（你们中很多人都知道 `configure` 并不等于构建软件，但并非所有软件都需要
    `configure` 步骤。端口知道该做什么。）
- en: The build process will go on for many lines. Building something like OpenOffice
    can take days and generate hundreds of thousands of lines of output.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将延续多行。构建像 OpenOffice 这样的软件可能需要几天时间，并生成数十万行输出。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to debug a port build failure, those messages that scroll off the
    top of your screen or terminal window contain all the clues you get. For that
    reason, I often build ports in a `script(1)` session. If you like the idea of
    keeping build messages around, see the `script` man page for details.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调试端口构建失败，那些从你的屏幕或终端窗口顶部滚过的消息包含了你所获得的所有线索。因此，我经常在 `script(1)` 会话中构建端口。如果你喜欢保留构建消息的想法，请查看
    `script` 的手册页面以获取详细信息。
- en: Eventually, you should see a message that the build has finished and the port
    is installing the software.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你应该会看到一个消息，表明构建已完成，端口正在安装软件。
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The port installs the software in a temporary location in the port building
    directory, but that’s not where we want the software installed! Remember that
    the ports system builds packages, and then installs from the package. This “fake”
    installation is for building the package.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 端口将在端口构建目录的临时位置安装软件，但这不是我们希望软件安装的地方！记住，端口系统构建软件包，然后从软件包中进行安装。这种“虚假”安装是为了构建软件包。
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There’s the package, retained in the package repository specified earlier. You
    might want to grab this file to install on your other machines, or perhaps even
    share the package repository via NFS.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是软件包，保留在之前指定的软件包仓库中。你可能想抓取这个文件以在其他机器上安装，或者甚至通过 NFS 共享软件包仓库。
- en: Now, because we specified `make install` on the command line, the port installs
    the created package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们已在命令行上指定了 `make install`，端口将安装创建的软件包。
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Installing the package requires making some of the same checks as building the
    package. Yes, the port could not have built the package without those libraries,
    but the ports system doesn’t assume that the package was built on the local system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包需要执行与构建软件包时相同的检查。是的，没有那些库，端口无法构建软件包，但端口系统并不假设软件包是在本地系统上构建的。
- en: Port Build Stages
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口构建阶段
- en: The package build process actually includes several stages, or smaller chunks
    of build procedure. Each stage performs all the stages before it. The final stage,
    `make install`, calls all of them, which provides several points where you can
    intervene in the port build process. If you want to make custom changes to a package,
    you can do it here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包构建过程实际上包括几个阶段，或者构建过程的更小部分。每个阶段都会执行它之前的所有阶段。最后的阶段 `make install` 会调用所有这些阶段，这提供了几个可以在端口构建过程中干预的点。如果你想对软件包进行自定义更改，你可以在这一步进行。
- en: Let’s look at each of the stages called for every port build.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个端口构建过程中所需的所有阶段。
- en: The make fetch Stage
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make fetch` 阶段'
- en: The `make fetch` stage gets the source code, or *distfiles*, for the port. First,
    it looks in any directories specified by the *mk.conf* variable `$DISTDIR`. If
    this variable isn’t set, it looks in the directory specified by the shell environment
    variable `$DISTDIR`. If neither variable is set, it looks in */usr/ports/distfiles*.
    If `make fetch` finds the distribution files and thinks that they’re the correct
    version, it hands control to the next requested stage, and the build continues.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`make fetch`阶段获取端口的源代码或*distfiles*。首先，它会查找由*mk.conf*变量`$DISTDIR`指定的任何目录。如果此变量未设置，它会查找由shell环境变量`$DISTDIR`指定的目录。如果这两个变量都没有设置，它会查找`/usr/ports/distfiles`目录。如果`make
    fetch`找到了分发文件并认为它们是正确的版本，它就会将控制权交给下一个请求的阶段，然后构建继续进行。'
- en: If the source code is not on the local machine, `make fetch` tries to download
    it from an Internet site specified in the port’s makefile as `MASTER_SITES`. (You
    can customize download locations, as discussed in [Customizing Ports](ch13.html#customizing_ports
    "Customizing Ports").)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源代码不在本地机器上，`make fetch`会尝试从端口makefile中指定的`MASTER_SITES`指定的互联网站点下载它。（你可以自定义下载位置，如[自定义端口](ch13.html#customizing_ports
    "自定义端口")中讨论的那样。）
- en: You’ll find the `make fetch` command very useful when there are certain times
    in your day when you can download more easily than other times. For example, I
    have a T1 to my house,^([[38](#ftn.id370871)]) but my employer’s office has roughly
    66 times as much bandwidth as I have at home. I can run `make fetch` on my laptop
    while visiting my employer, go home, and build the port in peace. (And the boss
    thinks I come in because he buys lunch.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一天中的某些时间比其他时间更容易下载时，你会发现在这些时间使用`make fetch`命令非常有用。例如，我家里有一个T1，^([[38](#ftn.id370871)))
    但我的雇主办公室的带宽大约是我家里的66倍。我可以在访问我的雇主时在我的笔记本电脑上运行`make fetch`，然后回家，在平静中构建端口。（而且老板认为我是因为他买午餐才来的。）
- en: The make checksum Stage
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make checksum`阶段'
- en: The `make checksum` stage verifies that distfiles have not been corrupted, either
    by the download process or maliciously. OpenBSD includes several different checksums
    for each distfile, but only checks that the SHA-256 checksum matches the distfile.
    If the checksum matches, the build proceeds to the next stage. If the checksums
    do not match, the build immediately aborts. The build will not continue until
    you find a distfile that matches the checksum.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`make checksum`阶段验证分发文件是否未被损坏，无论是下载过程还是恶意行为。OpenBSD为每个分发文件包含多个不同的校验和，但它只检查SHA-256校验和是否与分发文件匹配。如果校验和匹配，构建将进入下一个阶段。如果校验和不匹配，构建将立即中止。构建将不会继续，直到你找到一个与校验和匹配的分发文件。'
- en: Not all software developers are conscientious about updating the names of their
    distfiles when they update their software. For these software packages, the *foo-1.0.tgz*
    file the port developer downloaded in the morning might differ from the *foo-1.0.tgz*
    file you download later that same day. Perhaps the original software author thought
    that no one would notice, but the OpenBSD folks would, if only via the logic built
    into the ports tools. After all, the ports system can’t tell the difference between
    a source file quietly modified by the software author and a source file quietly
    modified by an intruder. If you get a distfile that doesn’t match the recorded
    checksum, try to fetch a matching file by setting the `REFETCH` variable to `true`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有软件开发者都会在更新他们的软件时更新他们分发文件的名称。对于这些软件包，端口开发者早上下载的*foo-1.0.tgz*文件可能与当天稍后你下载的*foo-1.0.tgz*文件不同。也许原始软件作者认为没有人会注意到，但OpenBSD的人会注意到，即使是通过端口工具中内置的逻辑。毕竟，端口系统无法区分软件作者静默修改的源文件和入侵者静默修改的源文件。如果你得到一个与记录的校验和不匹配的分发文件，请尝试通过将`REFETCH`变量设置为`true`来获取匹配的文件。
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now `make` will walk through all the distfile sources listed in the port, downloading
    them successively in an effort to find a distfile that matches that used by the
    port developer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`make`将遍历端口中列出的所有distfile源，依次下载它们，以找到与端口开发者使用的匹配的分发文件。
- en: If you are absolutely certain that the file you downloaded is the correct, untampered-with
    one, but it still doesn’t pass `make checksum`, you’re wrong. If you know that
    you’re wrong, but you really do want to install compromised or damaged software,
    set the environment variable `NO_CHECKSUM=yes` to skip the `make checksum` stage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绝对确信你下载的文件是正确的，未被篡改的，但仍然无法通过`make checksum`，那么你是错误的。如果你知道自己错了，但确实想安装受损或损坏的软件，请设置环境变量`NO_CHECKSUM=yes`以跳过`make
    checksum`阶段。
- en: Warning
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Skipping the `make checksum` stage might be valid for debugging, but it certainly
    isn’t the way to create a stable, useful, or secure package. You also might invalidate
    the rest of the port. Perhaps the OpenBSD patches will no longer apply cleanly,
    the software just won’t run, or you could even be installing a backdoor, inviting
    scumbags to stash problematic content on your machine. You are utterly on your
    own if you insist on ignoring a checksum mismatch.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过`make checksum`阶段可能对调试是有效的，但绝对不是创建稳定、有用或安全软件包的方法。您还可能使端口号的其余部分无效。也许OpenBSD补丁将不再干净地应用，软件可能无法运行，或者您甚至可能安装了后门，邀请坏蛋在您的机器上存储有问题的内容。如果您坚持忽略校验和不匹配，那么您将完全独自承担风险。
- en: The make prepare Stage
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make prepare`阶段'
- en: At this point, the ports system gets into recursion. At `make prepare`, the
    port checks for any software needed to build or run the software you’re trying
    to build. If the port lists any of these dependencies, it checks to see if they
    are installed. If the dependencies are not installed, this stage kicks off `make
    install` for those required ports. Once all of the required dependencies are installed,
    this stage ends.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，端口号系统进入递归。在`make prepare`时，端口号会检查构建或运行你试图构建的软件所需的任何软件。如果端口号列出了这些依赖项之一，它会检查这些依赖项是否已安装。如果依赖项未安装，此阶段将启动`make
    install`以安装这些所需的端口号。一旦所有必需的依赖项都安装完毕，此阶段结束。
- en: The make extract Stage
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make extract`阶段'
- en: The ports system must extract the source code from the distfile before building
    the software. Source code is extracted into the directory defined by `$WRKOBJDIR`,
    or in a directory under */usr/ports/pobj/* named after the port. By default, my
    `tcsh` port would extract under */usr/ports/pobj/tcsh*, but because I defined
    a separate location for building software, it’s built under */home/ports/wrkobjdir/tcsh*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号系统必须在构建软件之前从distfile中提取源代码。源代码提取到由`$WRKOBJDIR`定义的目录中，或者在`/usr/ports/pobj/`下的一个以端口号命名的目录中。默认情况下，我的`tcsh`端口号会提取到`/usr/ports/pobj/tcsh/`下，但由于我定义了构建软件的单独位置，它是在`/home/ports/wrkobjdir/tcsh/`下构建的。
- en: The make patch Stage
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make patch`阶段'
- en: Any patches included in the port’s patches directory are applied in the `make
    patch` stage. If the patches all apply correctly, this stage ends. If the patches
    do not apply correctly, the port fails.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在端口号补丁目录中的任何补丁都在`make patch`阶段应用。如果所有补丁都正确应用，此阶段结束。如果补丁未正确应用，端口号将失败。
- en: To apply your own patches to the port, or to review the code before compiling
    it, run `make patch` first. Your patches might conflict with the port patches
    if you apply them first, cause compilation failures, or bring up any number of
    other problems. By running `make patch` first, you get to see the code as OpenBSD
    can compile it. Anything you break after that is definitely your fault.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您自己的补丁应用到端口号，或编译前审查代码，请先运行`make patch`。如果您首先应用补丁，可能会与端口号补丁冲突，导致编译失败，或引发其他各种问题。通过先运行`make
    patch`，您可以查看OpenBSD可以编译的代码。之后您破坏的任何内容都是您的责任。
- en: The make configure Stage
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make configure`阶段'
- en: Many software packages use a `configure` script to prepare themselves for compilation
    on a specific platform. The `make configure` command runs that script. If you
    want to edit the `configure` script, do so before running this stage! If there
    is no `configure` script, the port silently skips this stage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件包使用`configure`脚本来准备在特定平台上编译。`make configure`命令运行该脚本。如果您想编辑`configure`脚本，请在运行此阶段之前进行编辑！如果没有`configure`脚本，端口号会静默跳过此阶段。
- en: The make build Stage
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make build`阶段'
- en: The `make build` stage compiles the fetched, extracted, patched, and configured
    software. If you type `make` in a port directory, the port calls `make build`.
    This stage doesn’t assemble a package; it just performs the compilation and creates
    the actual program binaries in the port’s work directory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`make build`阶段编译已获取、提取、打补丁和配置的软件。如果您在端口号目录中输入`make`，端口号会调用`make build`。此阶段不会组装软件包；它只是在端口号的工作目录中执行编译并创建实际的程序二进制文件。'
- en: The make fake Stage
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make fake`阶段'
- en: The `make fake` stage installs the software in a subdirectory, laid out exactly
    as it would be under the *root* directory. This fake root directory is in the
    work directory, named *fake-* with the architecture appended, such as *fake-amd64*.
    Everything that will be in the package is installed under this directory, with
    the same ownership and permissions that it will include in the package.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`make fake` 阶段在子目录中安装软件，布局与在 *root* 目录下完全相同。这个虚拟根目录在工作目录中，命名为 *fake-* 并附加架构，例如
    *fake-amd64*。所有将包含在包中的内容都将安装在这个目录下，具有与包中相同的所有权和权限。'
- en: The make package Stage
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make package` 阶段'
- en: The `make package` stage bundles up the port’s fake installation directory,
    adds in packaging and installation instructions, and ties it all up in a package
    exactly like those available on the FTP site. The package will be stored under
    the *PKGREPO* directory you defined earlier (or in */usr/ports/packages* if you
    didn’t define one), in a subdirectory organized by architecture, and in further
    subdirectories organized by available distribution locations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`make package` 阶段将端口的虚拟安装目录打包，添加打包和安装说明，并将所有内容捆绑成一个与 FTP 站点上可用的包完全相同的包。该包将存储在您之前定义的
    *PKGREPO* 目录下（如果没有定义，则存储在 */usr/ports/packages*），在按架构组织的子目录中，并在按可用分发位置组织的进一步子目录中。'
- en: '`make package` means that you can build this port on one machine without installing
    it. You must install the build dependencies to build the port, however.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`make package` 意味着您可以在不安装的情况下在一个机器上构建此端口。但是，您必须安装构建依赖项来构建端口。'
- en: The make install Stage
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make install` 阶段'
- en: The `make install` stage runs `pkg_add(1)` to install the package you compiled.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`make install` 阶段运行 `pkg_add(1)` 来安装您编译的包。'
- en: The make clean Stage
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`make clean` 阶段'
- en: Some packages require a lot of disk space. The `make clean` stage removes all
    of the build files except the distfile and the completed package.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包需要大量的磁盘空间。`make clean` 阶段删除所有构建文件，除了 distfile 和完成的包。
- en: Customizing Ports
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Ports
- en: OpenBSD includes a variety of hooks to let you easily customize how you get
    and build ports. If possible, you should use the OpenBSD-provided infrastructure,
    but there may be cases where that’s not possible. Here, we’ll look at some of
    the more commonly used customization settings.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 包含各种钩子，让您可以轻松自定义获取和构建 ports 的方式。如果可能，您应该使用 OpenBSD 提供的基础设施，但在某些情况下可能无法这样做。在这里，我们将查看一些更常用的自定义设置。
- en: Local Distfile Mirrors
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地 Distfile 镜像
- en: While ports provide several places to get source code, you might want to override
    those sites. Perhaps you share a network with a major mirror site, or you don’t
    have unfettered Internet access. OpenBSD lets you set your own preferred mirror
    sites.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ports 提供了几个获取源代码的地方，但您可能想覆盖这些站点。也许您与一个主要镜像站点共享网络，或者您没有无限制的互联网访问。OpenBSD 允许您设置自己的首选镜像站点。
- en: Preferred Collection Mirrors
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 首选集合镜像
- en: Many software sources can be grouped into *collections*, which tend to be mirrored
    together. An example is the official GNU software collection. A GNU mirror site
    probably has everything in the official GNU collection. The Gnu C Compiler Project
    has its own set of software and mirrors. There are older software collections,
    such as SunSITE, and newer ones, such as SourceForge.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件源可以被分组到 *collections* 中，这些通常一起镜像。一个例子是官方的 GNU 软件集合。GNU 镜像站点可能包含官方 GNU 集合中的所有内容。GNU
    C 编译器项目有其自己的软件和镜像。还有较旧的软件集合，如 SunSITE，以及较新的，如 SourceForge。
- en: Each collection is available from a list of mirror sites. OpenBSD maintains
    lists of these mirror sites in */usr/ports/infrastructure/templates/network.conf.template*.
    Never edit this file; it’s a core ports file, and upgrading changes it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都可通过镜像站点列表获取。OpenBSD 在 */usr/ports/infrastructure/templates/network.conf.template*
    中维护这些镜像站点的列表。永远不要编辑此文件；它是一个核心 ports 文件，升级会更改它。
- en: 'For example, here’s a list of mirrors for a smaller project, BerliOS:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个较小项目 BerliOS 的镜像列表：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Several ports want to fetch BerliOS-related software from the main BerliOS download
    site. The OpenBSD port developers have identified three desirable mirrors, as
    listed in the variable `MASTER_SITE_BERLIOS`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 几个 ports 想从主要的 BerliOS 下载站点获取与 BerliOS 相关的软件。OpenBSD 端口开发者已经确定了三个理想的镜像，如变量 `MASTER_SITE_BERLIOS`
    中列出。
- en: But suppose you have a BerliOS mirror much closer to you. Perhaps it’s not an
    official mirror, or you’ve managed to finagle access to a nonpublic mirror. It’s
    closer, it’s faster, and you would prefer to use it. OpenBSD looks at */usr/ports/infrastructure/db/network.conf*
    before the default mirror list. You could copy the default mirror list to this
    file and edit it, but then you would need to manually synchronize changes during
    upgrades. That’s work, and therefore morally questionable. Instead, add entries
    only in *network.conf*, and include the default *network.conf.template*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设你有一个离你更近的 BerliOS 镜像。可能它不是一个官方镜像，或者你已经设法获得了对非公开镜像的访问权限。它更近，更快，你更愿意使用它。OpenBSD
    在默认镜像列表之前查看 */usr/ports/infrastructure/db/network.conf*。你可以将默认镜像列表复制到该文件并编辑它，但这样在升级期间就需要手动同步更改。这是工作量，因此从道德上讲是有问题的。相反，只在
    *network.conf* 中添加条目，并包含默认的 *network.conf.template*。
- en: 'Suppose you have a private BerliOS mirror at *[http://www.blackhelicopters.org/berlios/](http://www.blackhelicopters.org/berlios/)*.
    You would create a *network.conf* file like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个位于 *[http://www.blackhelicopters.org/berlios/](http://www.blackhelicopters.org/berlios/)*
    的私有 BerliOS 镜像。你会创建一个类似这样的 *network.conf* 文件：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `+=` used in both *network.conf* and *network.conf.template* means “Add
    this value to variable such-and-such.” More desirable mirrors appear first in
    the list. This *network.conf* entry adds the private mirror to the variable `MASTER_SITE_BERLIOS`,
    and then calls in *network.conf.default*, which appends all of the other mirrors.
    The end result is that the BerliOS mirror list will contain four mirrors: your
    preferred mirror first and the default OpenBSD-approved mirrors later. If a file
    does not exist on a mirror, the port will try the other mirrors in order.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *network.conf* 和 *network.conf.template* 中使用的 `+=` 表示“将此值添加到某个变量”。更理想的镜像排在列表前面。此
    *network.conf* 条目将私有镜像添加到变量 `MASTER_SITE_BERLIOS`，然后调用 *network.conf.default*，它追加所有其他镜像。最终结果是
    BerliOS 镜像列表将包含四个镜像：你首选的镜像排在第一位，默认的 OpenBSD-批准的镜像排在后面。如果一个文件在某个镜像上不存在，端口将按顺序尝试其他镜像。
- en: 'I used BerliOS as an example because it has a small mirror list, but the same
    applies to any other software collection that OpenBSD recognizes. Other collections
    available at this time are shown in [Table 13-1](ch13.html#some_software_collections
    "Table 13-1. Table 13-1: Some Software Collections").'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我以 BerliOS 为例，因为它有一个小的镜像列表，但同样适用于 OpenBSD 识别的任何其他软件集合。目前可用的其他集合在 [表 13-1](ch13.html#some_software_collections
    "表 13-1. 表 13-1：一些软件集合") 中显示。
- en: 'Table 13-1. Table 13-1: Some Software Collections'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1. 表 13-1：一些软件集合
- en: '| Collection | Description |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 描述 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MASTER_SITE_GNU` | Software from the GNU project |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_GNU` | GNU 项目的软件 |'
- en: '| `MASTER_SITE_GCC` | Software from the GCC project |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_GCC` | GCC 项目的软件 |'
- en: '| `MASTER_SITE_XCONTRIB` | Contributions to the X Window System |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_XCONTRIB` | 对 X Window 系统的贡献 |'
- en: '| `MASTER_SITE_R5CONTRIB` | Older X Window System contributions |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_R5CONTRIB` | 较旧的 X Window 系统贡献 |'
- en: '| `MASTER_SITE_SUNSITE` | A collection of Sun software |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_SUNSITE` | Sun 软件集合 |'
- en: '| `MASTER_SITE_SOURCEFORGE` | Software hosted by SourceForge |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_SOURCEFORGE` | 由 SourceForge 托管的软件 |'
- en: '| `MASTER_SITE_SOURCEFORGE_JP` | Japanese SourceForge mirrors |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_SOURCEFORGE_JP` | 日本 SourceForge 镜像 |'
- en: '| `MASTER_SITE_GNOME` | Software from the Gnome project |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_GNOME` | Gnome 项目的软件 |'
- en: '| `MASTER_SITE_PERL_CPAN` | The biggest Perl module collection |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_PERL_CPAN` | 最大的 Perl 模块集合 |'
- en: '| `MASTER_SITE_TEX_CTAN` | Software for TeX typesetting |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_TEX_CTAN` | TeX 排版软件 |'
- en: '| `MASTER_SITE_KDE` | Software related to KDE |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_KDE` | 与 KDE 相关的软件 |'
- en: '| `MASTER_SITE_SAVANNAH` | Software development hosted by the FSF |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_SAVANNAH` | 由 FSF 托管的软件开发 |'
- en: '| `MASTER_SITE_AFTERSTEP` | Software related to the AfterStep window manager
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_AFTERSTEP` | 与 AfterStep 窗口管理器相关的软件 |'
- en: '| `MASTER_SITE_WINDOWMAKER` | Software related to the Window Maker window manager
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_WINDOWMAKER` | 与 Window Maker 窗口管理器相关的软件 |'
- en: '| `MASTER_SITE_FREEBSD_LOCAL` | Software distributed by the FreeBSD Project,
    but not included in FreeBSD |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_FREEBSD_LOCAL` | 由 FreeBSD 项目分发，但未包含在 FreeBSD 中的软件 |'
- en: '| `MASTER_SITE_PACKETSTORM` | Security software part of the Packet Storm collection
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_PACKETSTORM` | Packet Storm 集合中的安全软件 |'
- en: '| `MASTER_SITE_APACHE` | Apache Foundation software |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_APACHE` | Apache 基金会的软件 |'
- en: '| `MASTER_SITE_BERLIOS` | Parts of the BerliOS Linux project |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_BERLIOS` | BerliOS Linux 项目的部分 |'
- en: '| `MASTER_SITE_MYSQL` | Software from the MySQL project (Oracle) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_MYSQL` | MySQL 项目的软件（Oracle） |'
- en: '| `MASTER_SITE_PYPI` | Python software |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_PYPI` | Python软件 |'
- en: '| `MASTER_SITE_RUBYGEMS` | Modules for Ruby |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_RUBYGEMS` | Ruby模块 |'
- en: '| `MASTER_SITE_NPM` | JavaScript packages |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_NPM` | JavaScript软件包 |'
- en: '| `MASTER_SITE_ISC` | Software from the Internet Software Consortium |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `MASTER_SITE_ISC` | 来自互联网软件联盟的软件 |'
- en: If you have a Debian mirror in your university datacenter, list it in *network.conf*.
    If it appears a second time, later in the list, because it’s listed in *network.conf.template*,
    so what? Either the distfile is there, in which case you save time and bandwidth,
    or the *distfile* isn’t there, in which case you waste 50 milliseconds checking
    the local mirror a second time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你大学数据中心有一个Debian镜像，请在*network.conf*中列出它。如果它出现在列表的后面，因为它在*network.conf.template*中列出，那又如何呢？要么distfile在那里，这样你就可以节省时间和带宽，要么distfile不在那里，这样你就在第二次检查本地镜像时浪费了50毫秒。
- en: Fallback Mirrors
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回退镜像
- en: OpenBSD supports two fallback mirrors. If all other distfile sources fail, you
    can check either the OpenBSD or FreeBSD mirrors for the file. Both OpenBSD and
    FreeBSD tend to mirror distfiles for active ports. This isn’t preferred, because
    if everyone did this, it would use bandwidth that the projects need for distributing
    their own software. But if you’re desperate, set `MASTER_SITE_OPENBSD` and/or
    `MASTER_SITE_FREEBSD` to `YES` in *network.conf*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD支持两个回退镜像。如果所有其他distfile源都失败，你可以检查OpenBSD或FreeBSD镜像中的文件。OpenBSD和FreeBSD都倾向于为活跃的ports镜像distfiles。这不是首选的，因为如果每个人都这样做，就会占用项目分发他们自己的软件所需的带宽。但如果你绝望了，请在*network.conf*中将`MASTER_SITE_OPENBSD`和/或`MASTER_SITE_FREEBSD`设置为`YES`。
- en: Primary Mirror
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主要镜像
- en: You can have the ports system check a particular site first for all distfiles,
    regardless of the download site listed in the port. Perhaps you have a local mirror
    where you’ve stuck a whole bunch of distfiles, or you automatically load distfiles
    from your ports-building machines to a central location. Define this site with
    the variable `MASTER_SITE_OVERRIDE` in *network.conf*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让ports系统首先检查特定站点上的所有distfiles，无论端口中列出的下载站点是什么。也许你有一个本地镜像，你在那里存放了大量distfiles，或者你自动将distfiles从你的ports-building机器加载到一个中央位置。在*network.conf*中使用变量`MASTER_SITE_OVERRIDE`来定义这个站点。
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve built local distfile mirrors many times, usually when starting a new job.
    I manage to update the mirror for about six months before some other task supersedes
    it and the mirror becomes obsolete, so I don’t generally recommend this practice.
    But if maintaining a local distfile mirror reduces your workload instead of increasing
    it, enjoy.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次构建了本地的distfile镜像，通常是在开始新工作的时候。我设法维持这个镜像大约六个月，然后由于其他任务优先级更高，镜像就变得过时了，所以我不太推荐这种做法。但如果维护本地distfile镜像能减轻你的工作量而不是增加，那就请享受吧。
- en: Flavors
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本
- en: Some ports can create multiple but slightly different packages through *flavors*.
    The Apache 2.2 web server I keep dragging out as an example can be built with
    or without LDAP support, as can programs with optional X support. Shells can be
    built in dynamic or static versions. OpenBSD’s official packages are built with
    the most common choices, but these alternatives are reasonable and occasionally
    necessary.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一些ports可以通过*flavors*创建多个但略有不同的包。我一直在举例的Apache 2.2网络服务器，可以带或不带LDAP支持来构建，可选X支持的程序也是如此。Shell可以构建为动态或静态版本。OpenBSD的官方包使用最常用的选择构建，但这些替代方案是合理且偶尔必要的。
- en: 'To identify the flavors that a port supports, go to the port directory and
    run **`make show=FLAVORS`**. Here’s how to check the flavors of the popular text
    editor Vim:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别端口支持的版本，请转到端口目录并运行**`make show=FLAVORS`**。以下是检查流行文本编辑器Vim版本的方法：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can guess what some of these eight flavors do, but how can you learn about
    the others? You can check the package’s description file for brief descriptions
    of each flavor. Here are the descriptions for the Vim flavors, from *editors/vim/pkg/DESCR-main*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以猜到这些八个版本中的一些功能，但你如何了解其他的呢？你可以检查包的描述文件，以获取每个版本的简要描述。以下是Vim版本的描述，来自*editors/vim/pkg/DESCR-main*：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Motif? I remember Motif. And now I’m going to try really hard to forget it again.
    But if you want Motif support in your Vim version, go for it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Motif？我记得Motif。现在我打算再次努力忘记它。但如果你想在Vim版本中支持Motif，那就去做吧。
- en: 'To fall back to my ongoing example, here are the flavors for Apache 2:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以我正在进行的例子为例，以下是Apache 2的版本：
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I use LDAP to attach websites to my central authentication system. If I can
    get LDAP authentication on my web server, I want it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用LDAP将网站连接到我的中央认证系统。如果我的web服务器上可以启用LDAP认证，我就想用它。
- en: Building a Flavored Port
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建风味端口
- en: 'Define any desired flavors with the `$FLAVOR` environment variable, but not
    in your *.profile* or *.cshrc* file, as a port will not build if you request an
    unrecognized flavor. Define it when you build the port. For example, while still
    in the *apache-httpd* directory, I run this command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$FLAVOR`环境变量定义任何所需的口味，但不要在*.profile*或*.cshrc*文件中定义，因为如果请求一个未识别的风味，端口将不会构建。在构建端口时定义它。例如，仍然在*apache-httpd*目录中，我运行这个命令：
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By your defining the flavor on the command line, the port knows to check for
    the OpenLDAP client needed to build Apache. When the build finishes, you should
    get a package file with the flavor appended—in this case, *apache-httpd-2.2.20p1-ldap.tgz*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行上定义风味，端口知道要检查构建Apache所需的OpenLDAP客户端。当构建完成时，你应该得到一个带有风味附加的包文件——在这个例子中，*apache-httpd-2.2.20p1-ldap.tgz*。
- en: Flavors and Dependencies
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 风味和依赖
- en: 'When you build a *flavored port*, the flavor does not propagate to dependencies.
    You need to check the flavored port’s dependencies to see if they need flavoring
    as well. For example, my flavored Apache package calls in the OpenLDAP client,
    which has no flavors, but OpenLDAP calls in `cyrus-SASL`, and if I check that
    port, I see this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个*风味端口*时，风味不会传播到依赖项。你需要检查风味端口的依赖项，看看它们是否也需要风味。例如，我的风味Apache包调用OpenLDAP客户端，它没有风味，但OpenLDAP调用`cyrus-SASL`，如果检查该端口，我会看到这个：
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Cyrus SASL comes in LDAP flavor, but defining that I want Apache built in LDAP
    flavor doesn’t mean that `cyrus-SASL` will also be built with LDAP support. If
    I need LDAP support in this dependency, I must build it separately. I don’t need
    it for my environment, so I won’t bother, but check for potential issues like
    these when building your packages.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Cyrus SASL有LDAP风味，但定义我想以LDAP风味构建Apache并不意味着`cyrus-SASL`也会以LDAP支持构建。如果我在这个依赖项中需要LDAP支持，我必须单独构建它。我不需要它在我的环境中，所以我不需要麻烦，但在构建你的包时检查这些潜在问题。
- en: 'If you decide to rebuild a dependent port with a flavor, be sure to rebuild
    all the ports that depend on that port afterward. Be sure that your packages have
    correct dependencies using the targets `print-build-depends` and `print-run-depends`.
    Here, I see which ports I’ll need to build for my flavored Apache 2:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定以某种风味重新构建一个依赖的端口，请确保之后重新构建所有依赖于该端口的端口。确保你的包使用`print-build-depends`和`print-run-depends`目标有正确的依赖。在这里，我看到我需要为我的风味Apache
    2构建哪些端口：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I can check the flavors of each of these ports.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以检查这些端口的每个风味。
- en: Building Multiple Flavors
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建多个风味
- en: You can build multiple flavors of one port on the same system. Each package
    filename includes the flavor, so you can have packages for both the Motif and
    GTK2 versions of Vim. Carefully inspect the dependencies to verify that each is
    built with the correct flavoring. For packages with flavored dependencies, I recommend
    removing every flavored dependency and rebuilding them all again, so that everything
    gets the correct flavor.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一系统上构建一个端口的多个风味。每个包文件名都包含风味，因此你可以拥有Vim的Motif和GTK2版本的包。仔细检查依赖关系，以验证每个都是使用正确的风味构建的。对于具有风味依赖的包，我建议移除所有风味依赖并重新构建它们，以确保一切都能获得正确的风味。
- en: Uninstalling and Reinstalling Flavored Ports
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 卸载和重新安装风味端口
- en: 'Flavoring a package changes its name. I can’t run `pkg_delete apache-httpd`
    because it’s not installed. Query the system for the packages you’ve manually
    installed, and you’ll see this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 风味包会改变其名称。我不能运行`pkg_delete apache-httpd`，因为它没有安装。查询系统以查找你手动安装的包，你会看到这个：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When working with this package, you must specify the flavor.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此包时，你必须指定风味。
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similarly, to reinstall a flavored package, specify the flavored package file.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要重新安装风味包，指定风味包文件。
- en: Subpackages
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子包
- en: 'Some ports contain multiple wildly different packages. This isn’t like adding
    LDAP support to Apache or Motif support to Vim—those are changes to the existing
    package, not wildly different. Some ports create two completely different packages,
    such as a database client and the associated database server. I’ve drawn in OpenLDAP
    through this chapter’s examples, and both the OpenLDAP server and client come
    from the same port: *databases/openldap*. Other applications might have plug-ins
    for accessing several different database engines. These are called *subpackages*
    or *multipackages*.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口包含多个截然不同的软件包。这并不像向Apache添加LDAP支持或向Vim添加Motif支持那样——那些是对现有软件包的修改，而不是截然不同。一些端口创建了两个完全不同的软件包，例如数据库客户端和相关的数据库服务器。我在本章的示例中引入了OpenLDAP，OpenLDAP服务器和客户端都来自同一个端口：*databases/openldap*。其他应用程序可能有插件来访问多个不同的数据库引擎。这些被称为*子软件包*或*多重软件包*。
- en: Unlike flavors, OpenBSD provides all subpackages of a port. You can install
    both the server and client versions of OpenLDAP from official packages. When the
    port is built, all the subpackages are built. The package is split into subpackages
    at the package-bundling stage.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与风味不同，OpenBSD提供了一个端口的全部子软件包。你可以从官方软件包中安装OpenLDAP的服务器和客户端版本。当端口构建时，所有子软件包都会构建。在软件包捆绑阶段，软件包被分割成子软件包。
- en: 'To see all the subpackages supported by a port, run the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一个端口支持的所有子软件包，请运行以下命令：
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This port has two subpackages: `openldap-main` and `openldap-server`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此端口有两个子软件包：`openldap-main`和`openldap-server`。
- en: How can you learn what each subpackage includes? As with flavors, you can check
    its description file, which is *pkg/DESCR*. OpenLDAP includes *pkg/DESCR-server*
    and *pkg/DESCR-main*. Reading these shows that the `main` package is the client,
    as you would expect.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何了解每个子软件包包含的内容？与风味一样，你可以检查其描述文件，它是*pkg/DESCR*。OpenLDAP包括*pkg/DESCR-server*和*pkg/DESCR-main*。阅读这些文件显示，`main`软件包是客户端，正如你所期望的那样。
- en: If you run `make install` in the port directory, you get the main version of
    the port—in this case, the OpenLDAP client. OpenLDAP clients outnumber the servers,
    so that’s also what you would expect. To build a different subpackage, set `SUBPACKAGE`
    in the environment on the command line, as you did for flavors.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个端口目录中运行`make install`，你会得到端口的主体版本——在这个例子中，是OpenLDAP客户端。OpenLDAP客户端的数量超过了服务器，这也是你所期望的。要构建不同的子软件包，在命令行上设置环境变量`SUBPACKAGE`，就像你为风味所做的那样。
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This builds the `-server` version. Be sure to include the leading dash, as specifying
    a nonexistent subpackage makes the build fail.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建`-server`版本。务必包含前面的连字符，因为指定一个不存在的子软件包会导致构建失败。
- en: Packages and rc.d Scripts
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包和rc.d脚本
- en: '[Chapter 5](ch05.html "Chapter 5. The Boot Process") covered how to have OpenBSD
    start packaged software, but let’s review it quickly. When you install a package
    that can be started at boot time, the package also installs a startup script in
    */etc/rc.d*. If I install the OpenLDAP server, the package installation will report:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。启动过程")介绍了如何让OpenBSD启动打包的软件，但让我们快速回顾一下。当你安装一个可以在启动时启动的软件包时，该软件包也会在*/etc/rc.d*中安装一个启动脚本。如果我安装OpenLDAP服务器，软件包安装将报告：'
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To start the `slapd(8)` OpenLDAP server at boot, add the script name to the
    `pkg_scripts` variable in */etc/rc.conf.local*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时启动`slapd(8)` OpenLDAP服务器，请将脚本名称添加到*/etc/rc.conf.local*中的`pkg_scripts`变量。
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: OpenBSD runs these scripts in order at boot, and in reverse order at shutdown.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD在启动时按顺序运行这些脚本，在关机时按相反顺序运行。
- en: To change a package’s command-line arguments from the default, add a *`command`*`_flags`
    variable to *rc.conf.local*. Do not edit the startup script.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要从默认值更改软件包的命令行参数，请向*/etc/rc.conf.local*中的*`command`*`_flags`变量添加一个*`command`*`_flags`变量。不要编辑启动脚本。
- en: '[PRE43]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can now manage your add-on software in any way you need.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以以任何你需要的方式管理你的附加软件。
- en: Now let’s move on to configuring OpenBSD’s integrated software, through the
    files in */etc*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续配置OpenBSD的集成软件，通过*/etc*中的文件。
- en: '* * *'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#id453650)]) In the IT industry, “minimal education” means a willingness
    to dig in and figure it out, plus a few years of college or professional experience;
    access to programming textbooks or other educational materials; or a whole lot
    of youth, stubbornness, and motivation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#id453650)]) 在IT行业，“最小教育”意味着愿意深入研究并找出答案，再加上几年的大学或专业经验；访问编程教科书或其他教育材料；或者大量的青春、固执和动力。
- en: ^([[35](#id366676)]) No, it’s not. There is no *ftp10.usa.openbsd.org*. Follow
    the instructions. Look at the mirror list and pick a mirror that actually exists
    and is close to you. Never blindly copy my examples!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#id366676)]) 不，不是的。没有 *ftp10.usa.openbsd.org*。遵循指示。查看镜像列表，选择一个实际存在且离你较近的镜像。永远不要盲目复制我的示例！
- en: ^([[36](#id485212)]) If you don’t see anything to worry about on any given server,
    you aren’t looking hard enough.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#id485212)]) 如果你在任何服务器上都没有看到任何需要担心的事情，那么你还没有足够仔细地查看。
- en: ^([[37](#id431051)]) This example exhausts my understanding of SQL. As long
    as I maintain my database ignorance, people won’t expect my help fixing their
    databases.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#id431051)]) 这个例子耗尽了我对SQL的理解。只要我保持对数据库的无知，人们就不会期待我帮助他们修复数据库。
- en: ^([[38](#id370871)]) Don’t laugh. It’s paid for.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[38](#id370871)]) 别笑。这是有偿的。
