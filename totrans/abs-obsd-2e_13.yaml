- en: Chapter 13. Software Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Blowfish is solid,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*but the third-party software?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Easy road to ruin.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Most people don’t use
    an operating system; they use software, which runs atop an underlying operating
    system. No matter how robust an operating system is, it’s useless without applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many commercial operating systems include hundreds or thousands of small programs:
    games, desktop toys, and everything from fancy-looking clocks to disk scrubbers
    and web browsers. Most users never touch most of these programs, but the programs
    take up disk space (and possibly other resources) just the same. Every program
    drags along some amount of infrastructure, and all of this software can cause
    any number of problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many other operating systems, OpenBSD deliberately includes relatively
    little software in the default installation. You get exactly what you need to
    provide the infrastructure for software, and nothing more. While a traditional
    UNIX or Unix-like system includes compilers, games, and man pages, you don’t even
    need to install these when installing OpenBSD! Even if you install everything
    included in OpenBSD, it will have far less software than any commercial operating
    system. That’s because almost everything is considered an add-on package.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to this sparseness is that you know exactly what’s on the system,
    which simplifies debugging. A random shared library from a program you’ve never
    used won’t break your programs. The downside is that you need to think a bit to
    decide exactly what you do want to include, and you’ll need to install those programs.
    OpenBSD makes installing software as easy as possible through the ports and packages
    system, which is introduced in this chapter. But first, let’s take a look at building
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Making Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building software is complicated because source code must be very specifically
    processed to create a program that works—let alone a program that works well!
    The `make(1)` program makes building software easily reproducible, so that a program
    can be built exactly as the software author intends. `make` takes its instructions
    from a configuration file, or *makefile*, which tells `make` exactly how to build
    a program from source. You don’t need to know the internals of a makefile, so
    we’re not going to dissect one here.
  prefs: []
  type: TYPE_NORMAL
- en: A makefile includes one or more targets and a set of instructions to carry out.
    For example, typing `make install` tells `make` to check the makefile for a procedure
    called `install` and, if found, to execute it. A target’s name usually relates
    to what `make` should be doing. The `make install` process, for example, usually
    installs the software built by previous steps. You’ll find targets to install,
    configure, and uninstall most software, and `make` handles a huge variety of functions,
    some of which far outstrip the creators’ original intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Source Code and Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source code is the human-readable instructions for building the actual machine
    code that makes up a program. You’ve probably already been exposed to some form
    of source code; if not, go look at a few files under */usr/src* (assuming, of
    course, that you installed the source code as I recommended back in [Chapter 3](ch03.html
    "Chapter 3. Installation Walk-Through")). While you don’t have to read source
    code, you should be able to recognize it.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a program’s source code, you build (or compile) the program on
    the type of system on which you want to run it. (Building software for a foreign
    platform via cross-compiling demands that you know much more about building software,
    and is not always possible.) If the software was written for an operating system
    sufficiently similar to what you’re building it on, you’ll create a working program.
    If the operating system differs too much, either the build fails or the resulting
    software won’t run. Once you’ve built the software successfully on your system,
    you can copy the resulting program (or *binary*) to other systems on the same
    platform, with the same operating system version and supporting software, and
    expect it to run.
  prefs: []
  type: TYPE_NORMAL
- en: Some programs are sufficiently well written that you can compile them on many
    different platforms. A few programs specifically include support for widely divergent
    platforms. For example, you can compile the Apache web server on Windows, NetWare,
    and Unix-like platforms by typing `make install`. This is quite uncommon, however,
    and takes considerable effort on the part of the software authors. It also makes
    the code more complex, and supporting all these operating systems means that it
    cannot easily support all the features that make those operating systems special.
    (But note that the ability to *build* software on a variety of platforms doesn’t
    necessarily mean that it *runs* well on all of those platforms.)
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, if you can build a program from source, it usually runs.
    A sufficiently experienced sysadmin can use the source code and error messages
    to learn why a program won’t build, or why it builds but doesn’t run. In many
    cases, the problem is simple and can be fixed with minimal education.^([[34](#ftn.id453650)])
    This is one reason why access to source code is important.
  prefs: []
  type: TYPE_NORMAL
- en: Back when every sysadmin was a programmer, debugging software builds absorbed
    major portions of the sysadmin’s time. Every Unix-like platform was slightly (or
    wildly) different. To build programs, sysadmins needed to understand their platform,
    the software’s original platform, and the differences between the two. The duplication
    of effort to build common programs was truly horrendous. Tools such as `autoconf`
    and `configure` were intended to help simplify this problem, but these programs
    just paper over the underlying problems. Building many software packages requires
    much more time running `configure` scripts than they need to actually compile.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD ports and packages system removes all this pain.
  prefs: []
  type: TYPE_NORMAL
- en: The Ports and Packages System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ports* are a mechanism for reproducibly and consistently building software
    on OpenBSD. *Packages* are precompiled ports for a specific OpenBSD version and
    platform. Packages install quickly and easily, and are recommended by the OpenBSD
    folks. Installing from a port takes more time and effort, but can be customized
    for your environment or server.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind the ports system is that if source code must be modified
    or tweaked to build or run on OpenBSD, the modification process should be automated.
    If you need other software to build this program from source code or run it, those
    dependencies should be automatically used. If you record exactly which files the
    software installs, you can easily uninstall it. And if you have all of these things,
    you can pick up the software and install it on any similar OpenBSD system.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are the installable files produced by the ports system. You can install
    packages over the network, either from your own package repository or from an
    OpenBSD mirror site. But before you can use a package, you must find it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packages are the preferred method to install OpenBSD software. Packages are
    built by the OpenBSD Project’s ports team, and are expected to work without any
    special tweaks from the user. You must configure the software, of course, but
    the software itself should work as expected. Unless you are planning to make modifications
    to a specific piece of software, you’ll be a lot happier simply installing the
    package fetched from a nearby mirror rather than building it from the port (or,
    worse, installing from the source code without the port).
  prefs: []
  type: TYPE_NORMAL
- en: Package Files and $PKG_PATH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every package is available as a single file named after the port it is found
    in, a version number, and a *.tgz* extension. For example, version 2.4.2 of the
    `adsuck` software is available in the file *adsuck-2.4.2.tgz*.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can install packages, you need to find a source for them. Find package
    files on the official release CDs or on OpenBSD mirror sites.
  prefs: []
  type: TYPE_NORMAL
- en: The packages are on the FTP and HTTP mirrors in the directory */pub/OpenBSD/*release*/packages/*platform.
    For example, the packages for the amd64 platform for OpenBSD 5.3 are in the directory
    */pub/OpenBSD/5.3/packages/amd64*. Look at the OpenBSD mirror list. Choose a mirror
    server near you, and verify that it actually has the *packages* directory for
    the release and platform you run. My closest mirror is *[http://ftp10.usa.openbsd.org](http://ftp10.usa.openbsd.org)*.^([[35](#ftn.id366676)])
    I find the 5.3 amd64 packages at *[http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64](http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64)*.
  prefs: []
  type: TYPE_NORMAL
- en: On the official CD, you’ll find packages in */*release*/*platform*/packages*.
    (Downloaded installation CDs do not include packages.) If you mounted the 5.3
    CD at */mnt*, you would find the packages at */mnt/5.3/amd64/packages*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve chosen a package repository, set the `$PKG_PATH` variable in your
    shell to it. This tells OpenBSD’s package management tools where to get the packages
    and gives you quick access to a single authoritative source of packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you set `$PKG_PATH` to an invalid location, `pkg_add` (the command for installing
    a package) won’t work. Using a location with packages for a different architecture
    makes `pkg_add` give an error that packages are “not for the right architecture.”
    If you choose an incorrect release, you’ll see “bad major” or other library version
    errors. Either of these types of errors mean that your `$PKG_PATH` is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: You can also list multiple package repositories. If the package tools don’t
    find a desired package in the first repository, they try the next one. This lets
    you use a local package repository for your custom packages, and then fall back
    to the official OpenBSD repository if you don’t have a local package. I use this
    when I must build a custom package for my network and want to use it across multiple
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages via FTP or HTTP is not quite as secure as installing them
    from CD. While the OpenBSD release team has verified all the packages on the CD
    set, an intruder could have tampered with whatever mirror you choose. These intrusions
    would be caught comparatively quickly, but it’s possible that you could install
    packages between the time of the intrusion and the time the damage is reversed.
    If you’re deeply concerned about package integrity, get an official CD set.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I write this, the latest OpenBSD/i386 snapshot has 7485 packages on the FTP
    site. This is a long list to browse through to find the specific package you want.
    If you have the ports tree installed, you can search it for packages, but if you
    wanted to use the ports tree, you wouldn’t be using packages, now would you?
  prefs: []
  type: TYPE_NORMAL
- en: Say you need a piece of software that runs only on Apache 2.2\. How can you
    find this? Find packages on the command line, or use a website.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most people don’t need an external web server on OpenBSD; the web servers included
    with OpenBSD are perfectly fine for average users. I would install Apache 2.2
    only if I had a specific application written for Apache 2.2\. If you want to run,
    say, a PHP web application, just use OpenBSD’s included `nginx` web server.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Packages on the Command Line
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`pkg_info(1)` displays information about packages. While you would normally
    use `pkg_info` to explore the packages you’ve already installed, you can use `-Q`
    to run a case-insensitive search on the packages in your package repository. If
    you know part of the package name, try the package search.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the names, you can guess that the package `apache-httpd-2.2.22` contains
    Apache 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Packages on the Web
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The easiest way to search packages is to use the unofficial OpenBSD Ports website
    at *[http://www.openports.se/](http://www.openports.se/)*. While this isn’t an
    official OpenBSD website, it has provided a good interface into the OpenBSD ports
    tree for several years. If I search for Apache on this site, the third hit is
    for “www/apache-httpd, apache HTTP server.”
  prefs: []
  type: TYPE_NORMAL
- en: Once you know the name of the package containing the software you want, you
    can install it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use `pkg_add(1)` to install packages. You don’t need the version number—just
    the package name. Here, I install the Apache package I found earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A great deal of software requires other software to run, and OpenBSD’s package
    tools track these *dependencies*. `pkg_add` starts my Apache installation by installing
    the various dependencies of the chosen package, as shown at **1**. Apache 2.2.22
    requires `libiconv` and `pcre`, among several other packages. As each package
    installs, you’ll see a progress bar scroll across the screen. If a dependency
    cannot be installed, the package installation terminates.
  prefs: []
  type: TYPE_NORMAL
- en: After installing all the dependencies, `pkg_add` installs the actual Apache
    2.2 package, as shown at **2**. At the end of package installation, you’ll see
    notices for startup scripts added by the package, as shown at **3**, and then
    any notes from the OpenBSD team about the packages, like those at **4**.
  prefs: []
  type: TYPE_NORMAL
- en: Which Files Are Installed?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the `-L` option to `pkg_info` to see which files a package installs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all of these files are installed under */usr/local*. OpenBSD
    installs all packages under */usr/local*.
  prefs: []
  type: TYPE_NORMAL
- en: Verbose Installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re interested in the details of how `pkg_add` works, use the `-v` flag
    to trigger verbose mode. You can specify multiple `-v` flags for added detail.
    I recommend trying verbose mode a few times, in varying levels of detail, to get
    a deeper understanding of what `pkg_add` actually does.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguous Packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes `pkg_add` needs an extra hint about what you want to install. For
    example, everything in my production network is tied together with LDAP, and I
    need to run an OpenLDAP mirror in each datacenter. (I could use OpenBSD’s integrated
    LDAP daemon instead, but the master servers run OpenLDAP, and I don’t want to
    mix LDAP servers.) The following is my attempt to install OpenLDAP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see at **1**, OpenBSD has two OpenLDAP server packages: recent releases
    of version 2.3 and version 2.4\. I want version 2.4\. The OpenBSD OpenLDAP package
    is compiled with Cyrus SASL (Simple Authentication and Security Layer), which
    in turn comes in six different flavors, as you can see at **2**—one for each supported
    database. I choose the version that uses LDAP as its backend. (I don’t need this
    particular SASL; any SASL will suffice.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg_add` realizes that this is something of a chicken-and-egg problem. LDAP
    is compiled using Cyrus, but Cyrus is compiled using LDAP. Fortunately, as you
    can see at **3**, it knows that this is a permissible configuration. The dependencies
    are installed, and then the OpenLDAP server that I want is added.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Where Files Originate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen in earlier examples, many packages install other packages as
    dependencies. Once you’ve installed a few complicated software packages, */usr/local*
    starts to fill up with weird-looking files and programs. Eventually, you’ll wonder
    which packages are needed or where a package was installed from.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD maintains records for every installed package in */var/db/pkg*, including
    files installed and dependency information, but wading through these files resembles
    effort, and I won’t do it. Also, many package names are obscure, opaque, obfuscated,
    or otherwise obtuse. (It’s not that the OpenBSD packages team tries to make package
    names incomprehensible, but there’s only so much it can do when the software has
    a name like `icu4c`.)
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, `pkg_info(1)` can easily answer most questions about your installed
    software. Start by getting a complete list of all software packages on the machine
    with the `-a` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Hang on a minute! I’ve installed `tcsh`, of course, as my aged brain isn’t up
    to learning a new shell. I installed OpenLDAP, and chose to add `cyrus-SASL` as
    a dependency. Did `pkg_add` really install all of these other packages as dependencies?
    Or has one of my junior admins installed extra cruft? Do I really *need* all of
    these packages, or do I just need to smack a minion?
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD records which software packages you’ve installed, versus those installed
    as dependencies. Use the `-m` flag to see only those packages you manually installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This looks more familiar. Apparently everything else really is a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at some options. For longer descriptions of each package, add
    the `-d` flag or use the `-a` flag to show information for all packages. If you
    want to run `pkg_info` for a single package, use the package name as an argument.
    For example, `-L` shows the list of files a package installs. With the `-a` flag,
    it will show all files included in all installed packages, but that’s probably
    more than you want. To show all files installed by a package, use the `-L` flag
    and the package name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `tcsh(1)` package includes the actual `tcsh` binary, the
    man page, and a whole bunch of National Language Support (NLS) files. Given a
    package name, you can identify which files are part of the package.
  prefs: []
  type: TYPE_NORMAL
- en: Going the other way, sometimes you want to know where a particular file originated.
    For example, I occasionally browse my server filesystems looking for weird stuff.
    I define “weird stuff” as “things I don’t recognize.” If I see an unfamiliar program
    or file, I’ll check to see which package installed it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only `pluginviewer` I had previously encountered was one designed to help
    Unix web browsers run third-party software when a website demanded a plug-in.
    I don’t know what this `pluginviewer` does, but apparently it’s a legitimate part
    of `cyrus-SASL`. To find something to worry about, I need to keep looking.^([[36](#ftn.id485212)])
    If you do many file searches like this, you can get faster results by using `pkglocatedb`
    (*/usr/ports/databases/pkglocatedb*).
  prefs: []
  type: TYPE_NORMAL
- en: After installation, many packages show a message, which I frequently read and
    promptly forget. To display this information again, use `pkg_info` with the `-M`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t remember which package had the message you wanted, use the `-a`
    flag instead of a package name to display the messages for all packages that have
    one. To show all packages that are not required by other packages, use the `-t`
    flag, which you might think matches all packages you chose to install. If you
    didn’t request a package, it could only be installed as a dependency to something
    you requested, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I know that I did not choose to install `icu4c`. I have no moral objections
    to the software, mind you, but it’s nothing I requested. How did a piece of software
    that I didn’t choose to install, and isn’t required by anything else, get on this
    system?
  prefs: []
  type: TYPE_NORMAL
- en: It’s there because I uninstalled something that required it.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To remove a previously installed package, use `pkg_delete(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`pkg_delete` does not request confirmation. It doesn’t ask if you are sure.
    It just blasts the software off the disk and gets on with its day. It also doesn’t
    remove the unprivileged users and groups created for the software, as you might
    still have files owned by them.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that many packages require other packages. By default, `pkg_delete`
    doesn’t remove dependencies of packages you remove. For example, earlier we saw
    that `icu4c` had been installed automatically as a leftover dependency from a
    removed OpenLDAP server package. To automatically remove unneeded dependencies,
    use the `-a` flag. For example, to completely eradicate the `openldap-server`
    package and its infrastructure from the machine, run `pkg_delete` twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This should clean your system of all packages installed as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Package Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package system is fast, efficient, reliable, and the OpenBSD Project’s preferred
    way for users to install software. But the system does have a few limitations
    that you should be aware of, including lags in the software-porting process and
    the support for newer packages on older versions of OpenBSD.
  prefs: []
  type: TYPE_NORMAL
- en: Each OpenBSD release supports only packages built for that release, and new
    packages are not built for old releases. The packages issued with the release
    are all you’ll get. (There are slight exceptions to this if you’re running `-stable`;
    see [Chapter 20](ch20.html "Chapter 20. Upgrading").) If you’re running OpenBSD
    5.3 and try to install packages from OpenBSD 5.4, they won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Most packages include software produced by third parties. OpenBSD provides the
    packaging, but the software itself is released on a schedule completely independent
    of OpenBSD’s. After the software developers release their newest software, the
    OpenBSD package is updated, but there’s a gap between the software’s release date
    and the release of the OpenBSD package. A popular package might be updated in
    hours, while larger, less frequently used, or unpopular packages can languish
    at an older version for days or weeks. These packages are not officially available
    until the next OpenBSD release, so you might run software that’s a point or two
    behind the latest for a few months. Usually, this is not a problem (if it is,
    investigate OpenBSD’s `-stable` branch, discussed in [Chapter 20](ch20.html "Chapter 20. Upgrading").)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If packages won’t work for you, investigate building third-party software through
    ports. You won’t get newer versions of the software, but you can get slightly
    different versions.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ports collection is the toolkit to build OpenBSD packages. Installing software
    from ports takes longer than installing via packages, is more error-prone, and
    requires a deeper understanding of the system and the add-on software than packages
    demand. You can’t get packages for every possible situation, however (one particularly
    annoying example is when the license for a particular piece of software makes
    it illegal for the OpenBSD project to create and distribute packages), and sometimes
    ports are the only way to get third-party software on your OpenBSD system short
    of compiling it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: What makes ports interesting is their level of automation. With one command,
    a port can find the source code for a program, download it, verify its integrity,
    apply any patches needed to make it run on OpenBSD, toggle any flags needed for
    any custom features of your system, build the code into actual binaries, produce
    a package, and install it. If you have compiled software on other platforms, you’ll
    quickly realize how ports simplify building software.
  prefs: []
  type: TYPE_NORMAL
- en: Like packages, ports work only on the version of OpenBSD for which they are
    released. That means that you must use the OpenBSD 5.4 ports collection on OpenBSD
    5.4; the 5.5 ports collection won’t work. Oh, it might look like it works sometimes,
    but the software will fail unpredictably, and no one will have sympathy for you
    (sympathy for your coworkers, perhaps, but not for you).
  prefs: []
  type: TYPE_NORMAL
- en: When you upgrade OpenBSD, the expectation is that you will upgrade your ports
    collection and all installed packages to the precise matching version. You might
    be able to use older packages on a newer OpenBSD, as long as you don’t delete
    the older shared libraries required by the software.
  prefs: []
  type: TYPE_NORMAL
- en: The Ports Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ports tree is usually installed in */usr/ports*. If you want the ports tree,
    you must manually fetch the *ports.tar.gz* file from your OpenBSD release and
    extract it under */usr*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I suggested this way back in [Chapter 4](ch04.html "Chapter 4. Post-Install
    Setup"), but you can also get the ports tree and keep the files up to date using
    `cvs(1)`, as covered in [Chapter 20](ch20.html "Chapter 20. Upgrading"). Look
    in this directory, and you’ll find a whole bunch of directories and files.
  prefs: []
  type: TYPE_NORMAL
- en: The *INDEX* file contains a list of every port in the system, in alphabetical
    order but machine-readable format. You can search this file for ports, but I recommend
    using one of the tools discussed later to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The *Makefile* contains the basic machine instructions for making the ports
    system work. While it’s intended for use by `make(1)`, you can learn a lot by
    reading the makefile for any port. Most of the really complicated ports code is
    in the *ports/infrastructure* directory, and all of the makefiles in the ports
    system build on that infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining directories are software categories. Each category contains a
    further layer of directories, and each directory under a category is a port of
    a specific piece of software. OpenBSD has more than 7600 ports as of this writing,
    so this hierarchical organization is vital to keeping them in some sort of manageable
    order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following is a listing of the contents of the *news* directory,
    which contains programs for using and managing Usenet news. This is one of the
    smaller categories. Some categories have hundreds of entries, but they’re arranged
    in much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Like the *CVS* directory in the main ports tree, the category’s *CVS* directory
    contains CVS version control information that doesn’t matter for day-to-day operation.
    The *Makefile* contains a list of valid ports within the category. You can build
    all of the ports in this category using this makefile, although that’s mostly
    useful only when building packages en masse. (When the OpenBSD Project team builds
    everything in the ports tree, it uses */usr/ports/infrastructure/bin/dpb*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go down another level. Here’s the port for `tcsh`, one of my nonnegotiable
    requirements as a sysadmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The *CVS* directory contains version control information, as in every *CVS*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The *Makefile* gives specific instructions for building `tcsh` on OpenBSD, including
    where to get the software and any patches, how to extract it, where the package
    can be distributed from, and any supported customizations.
  prefs: []
  type: TYPE_NORMAL
- en: The *distinfo* file contains several different cryptographic hashes for the
    source code to be downloaded, to avoid building software from compromised source
    code, and the size of the source file. Newer ports contain only SHA-256 hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it’s possible (difficult, but possible) to have a compromised file match
    a specific hash, it’s extremely unlikely that an altered source code file could
    match hashes computed with several different algorithms and have the same size
    as the uncompromised code. Even if people figure out how to break a particular
    hash, use of multiple hashes and the file size make compromising a source file
    nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: The *patches* directory contains code alterations needed to make this software
    run on OpenBSD. Some ports have no patches; others have dozens.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *pkg* directory describes the package and lists the files that
    the complete package must include.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some ports include other ports. Here are the contents of the *emulators/fedora*
    port.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The file *Makefile.inc* is new, as are the subdirectories *base*, *cups*, *motif*,
    and *sdl*. The subdirectories are independent ports. These four ports are often
    installed together, and as a whole, support OpenBSD’s Linux emulation (documented
    in `compat_linux(8)`). All four ports call in the common instructions in *Makefile.inc*.
    (The ports tree doesn’t include many of these, but don’t be shocked when you find
    one.)
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only Ports Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of building a port creates an installable package and uses a whole
    bunch of temporary files, source files, and status files. By default, all of these
    files are placed inside the ports tree itself. While this works, I encourage you
    to treat */usr/ports* as a read-only OpenBSD directory tree, just like */usr/bin*,
    */usr/lib*, and so on. Doing so simplifies upgrading and identifying local changes,
    helps identify what you’ve built from ports, and saves space on the */usr* partition.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Build files for ports can range from a few kilobytes to several gigabytes, so
    it’s best to build ports on a large scratch partition. If you have unpartitioned
    disk space, create a partition just for building ports. Or use any partition with
    space, or even an NFS partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the ports collection by setting variables in */etc/mk.conf*. To use
    a read-only ports tree, set the variables in these directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`WRKOBJDIR`****. Directory where the software is extracted from source
    and compiled. These can be deleted and re-created as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`PACKAGE_REPOSITORY`****. Directory where completed packages are stored.
    The ports collection builds packages, which you can then install.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`PLIST_DB`****. Directory where package packing lists are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`BULK_COOKIES_DIR`****. Directory for storing status cookies during mass
    builds of packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`UPDATE_COOKIES_DIR`****. Directory for storing status cookies during mass
    updates of packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISTDIR`****. Directory where vendor source code is kept. Source code
    is usually retained for reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these directories are owned by your regular user account, you can do a large
    part of package building without being root.
  prefs: []
  type: TYPE_NORMAL
- en: 'On one particular test system, I have hundreds of gigabytes free in */home*,
    so I chose to put my package directories there. Here’s my */etc/mk.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The ports system will build everything in */home/ports/wrkobjdir*. Original
    source code files go in */home/ports/distdir*. The ports system maintains various
    records in */home/ports/update_cookies* and */home/ports/bulk_cookies*. Completed
    packages go into */home/ports/pkgrepo*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a dedicated port-building machine, consider per-release package
    repositories. For example, I might have three versions of OpenBSD running at any
    given time. The package-building machine always runs the latest release, but I
    don’t want to throw away my old packages, so I use a package repository directory
    like */home/ports/pkgrepo/5.4* for packages built on a 5.4 system.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with packages, the first problem with ports is finding software you want.
    (To randomly poke around the ports tree in a pretty interface, see the *[http://www.openports.se](http://www.openports.se)*
    website.) OpenBSD has several ways to search the ports collection, including the
    ports index, keywords, and via SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The Ports Index
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The file */usr/ports/INDEX* lists all software in the ports tree, sorted by
    category and then alphabetically. If you have a good idea what your port is called,
    you can search the file for your preferred software. The index describes each
    port in a single pipe-delimited line, much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While the ports tree itself finds this a convenient format, it’s not particularly
    human-readable. To translate this to a human-friendly format, go into */usr/ports*
    and run **`make print-index`**. (This process goes on for tens of thousands of
    lines, so feed it to a pager.) Here’s the same port in the human-readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Port` statement gives the official name of the port and the version of
    the ported software. This software is called `gcpio`, and it’s at version 2.11\.
    The `Path` gives the ports tree category and directory where the port can be found—in
    this case, *archivers/gcpio*. The `Info` line gives a very brief description of
    the software. This is the GNU version of `cpio(1)`. The `Maint`, or maintainer,
    is the person or group responsible for maintaining this software in the ports
    tree. The OpenBSD ports team supports the `gcpio` port. The best-maintained ports
    usually have an individual as a maintainer, rather than the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: The final three entries describe other software required by this software. The
    `L-deps` line lists shared libraries, `B-deps` lists software needed to build
    this port, and `R-deps` lists the port’s runtime dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What good does this do? Suppose you’re still hung up on an Apache 2 web server.
    You can search *INDEX* for ports beginning with “apache.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first three (omitted) entries are ports related to Apache, but they are
    not the web server software. The fourth line is our port.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering this information from the index is rather limited, however. If you
    don’t know the name of the software, or how OpenBSD packages the software, you
    can’t easily find the port. In that case, try one of the other methods discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Finding by Keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t know a package’s exact name, try the ports collection’s search
    feature: `make search` and a key scans the index for a specific word. To search
    for Apache-related software, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On my system, this returns 62 results. You’ll need to scroll through several
    pages of possibilities, but you’ll find what you want.
  prefs: []
  type: TYPE_NORMAL
- en: You might need to try several possible keywords for a particular package, as
    some keywords have no hits and others generate too many.
  prefs: []
  type: TYPE_NORMAL
- en: Finding via SQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `sqlports` package lets you build a database of the *INDEX* file, permitting
    you to search for ports based on highly arbitrary criteria via SQL. For example,
    say you want to know all ports that depend on `libiconv` and `expat`. In this
    case, `sqlports` is your friend. Install it from ports or packages, and it will
    automatically build a database in */usr/local/share/sqlports* from *INDEX*, and
    then use OpenBSD’s `sqlite3` to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'I won’t teach SQL^([[37](#ftn.id431051)]) here, but just as an example, here’s
    how to search for ports whose name includes the string “apache” using `sqlports`
    (which can build much more complex queries than this one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Apache `httpd` server is the fourth hit, but there are another dozen or
    so ports. Every name that begins with `p5-` is a Perl module.
  prefs: []
  type: TYPE_NORMAL
- en: Building Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve decided to ignore the OpenBSD team’s recommendations to use packages,
    downloaded and extracted the ports tree, found software you need to install from
    ports, and designated an area for building ports. Now what?
  prefs: []
  type: TYPE_NORMAL
- en: 'The port directories don’t contain actual source code. When you build a package
    from a port, the system does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically downloads the appropriate source code from an approved Internet
    site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks the downloaded code for integrity errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts the code to the build area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiles the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs the package (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, if the port you’re adding has unmet dependencies, the system also
    handles installing those dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make all this happen, just go to the *port* directory and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see the port build the software, create the package, and install
    the package on your system.
  prefs: []
  type: TYPE_NORMAL
- en: What a Port Installation Does
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to dissect a port build and installation. Here’s how to install `tcsh`
    from a port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The port first checks to see if the software’s required libraries are in place.
    Building `tcsh` requires the `termlib` and `c` libraries. The port finds `termlib`
    but not a file containing the `tcsh` source code on the local system, so the port
    fetches the code. (When building a port, you should see the system downloading
    the appropriate source code.) The port then verifies the checksum of the downloaded
    code. If the port can’t get all of the code, or the checksums don’t match, the
    build process stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all necessary source code is downloaded and verified, the build continues
    with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The port extracts the source code from the compressed file(s), applies any OpenBSD-specific
    patches, and starts the build process. (Many of you know that `configure` is not
    the same as building software, but not all software requires a `configure` step.
    The port knows what to do.)
  prefs: []
  type: TYPE_NORMAL
- en: The build process will go on for many lines. Building something like OpenOffice
    can take days and generate hundreds of thousands of lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to debug a port build failure, those messages that scroll off the
    top of your screen or terminal window contain all the clues you get. For that
    reason, I often build ports in a `script(1)` session. If you like the idea of
    keeping build messages around, see the `script` man page for details.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, you should see a message that the build has finished and the port
    is installing the software.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The port installs the software in a temporary location in the port building
    directory, but that’s not where we want the software installed! Remember that
    the ports system builds packages, and then installs from the package. This “fake”
    installation is for building the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There’s the package, retained in the package repository specified earlier. You
    might want to grab this file to install on your other machines, or perhaps even
    share the package repository via NFS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because we specified `make install` on the command line, the port installs
    the created package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Installing the package requires making some of the same checks as building the
    package. Yes, the port could not have built the package without those libraries,
    but the ports system doesn’t assume that the package was built on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: Port Build Stages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package build process actually includes several stages, or smaller chunks
    of build procedure. Each stage performs all the stages before it. The final stage,
    `make install`, calls all of them, which provides several points where you can
    intervene in the port build process. If you want to make custom changes to a package,
    you can do it here.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of the stages called for every port build.
  prefs: []
  type: TYPE_NORMAL
- en: The make fetch Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make fetch` stage gets the source code, or *distfiles*, for the port. First,
    it looks in any directories specified by the *mk.conf* variable `$DISTDIR`. If
    this variable isn’t set, it looks in the directory specified by the shell environment
    variable `$DISTDIR`. If neither variable is set, it looks in */usr/ports/distfiles*.
    If `make fetch` finds the distribution files and thinks that they’re the correct
    version, it hands control to the next requested stage, and the build continues.
  prefs: []
  type: TYPE_NORMAL
- en: If the source code is not on the local machine, `make fetch` tries to download
    it from an Internet site specified in the port’s makefile as `MASTER_SITES`. (You
    can customize download locations, as discussed in [Customizing Ports](ch13.html#customizing_ports
    "Customizing Ports").)
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the `make fetch` command very useful when there are certain times
    in your day when you can download more easily than other times. For example, I
    have a T1 to my house,^([[38](#ftn.id370871)]) but my employer’s office has roughly
    66 times as much bandwidth as I have at home. I can run `make fetch` on my laptop
    while visiting my employer, go home, and build the port in peace. (And the boss
    thinks I come in because he buys lunch.)
  prefs: []
  type: TYPE_NORMAL
- en: The make checksum Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make checksum` stage verifies that distfiles have not been corrupted, either
    by the download process or maliciously. OpenBSD includes several different checksums
    for each distfile, but only checks that the SHA-256 checksum matches the distfile.
    If the checksum matches, the build proceeds to the next stage. If the checksums
    do not match, the build immediately aborts. The build will not continue until
    you find a distfile that matches the checksum.
  prefs: []
  type: TYPE_NORMAL
- en: Not all software developers are conscientious about updating the names of their
    distfiles when they update their software. For these software packages, the *foo-1.0.tgz*
    file the port developer downloaded in the morning might differ from the *foo-1.0.tgz*
    file you download later that same day. Perhaps the original software author thought
    that no one would notice, but the OpenBSD folks would, if only via the logic built
    into the ports tools. After all, the ports system can’t tell the difference between
    a source file quietly modified by the software author and a source file quietly
    modified by an intruder. If you get a distfile that doesn’t match the recorded
    checksum, try to fetch a matching file by setting the `REFETCH` variable to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now `make` will walk through all the distfile sources listed in the port, downloading
    them successively in an effort to find a distfile that matches that used by the
    port developer.
  prefs: []
  type: TYPE_NORMAL
- en: If you are absolutely certain that the file you downloaded is the correct, untampered-with
    one, but it still doesn’t pass `make checksum`, you’re wrong. If you know that
    you’re wrong, but you really do want to install compromised or damaged software,
    set the environment variable `NO_CHECKSUM=yes` to skip the `make checksum` stage.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skipping the `make checksum` stage might be valid for debugging, but it certainly
    isn’t the way to create a stable, useful, or secure package. You also might invalidate
    the rest of the port. Perhaps the OpenBSD patches will no longer apply cleanly,
    the software just won’t run, or you could even be installing a backdoor, inviting
    scumbags to stash problematic content on your machine. You are utterly on your
    own if you insist on ignoring a checksum mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: The make prepare Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, the ports system gets into recursion. At `make prepare`, the
    port checks for any software needed to build or run the software you’re trying
    to build. If the port lists any of these dependencies, it checks to see if they
    are installed. If the dependencies are not installed, this stage kicks off `make
    install` for those required ports. Once all of the required dependencies are installed,
    this stage ends.
  prefs: []
  type: TYPE_NORMAL
- en: The make extract Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ports system must extract the source code from the distfile before building
    the software. Source code is extracted into the directory defined by `$WRKOBJDIR`,
    or in a directory under */usr/ports/pobj/* named after the port. By default, my
    `tcsh` port would extract under */usr/ports/pobj/tcsh*, but because I defined
    a separate location for building software, it’s built under */home/ports/wrkobjdir/tcsh*.
  prefs: []
  type: TYPE_NORMAL
- en: The make patch Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any patches included in the port’s patches directory are applied in the `make
    patch` stage. If the patches all apply correctly, this stage ends. If the patches
    do not apply correctly, the port fails.
  prefs: []
  type: TYPE_NORMAL
- en: To apply your own patches to the port, or to review the code before compiling
    it, run `make patch` first. Your patches might conflict with the port patches
    if you apply them first, cause compilation failures, or bring up any number of
    other problems. By running `make patch` first, you get to see the code as OpenBSD
    can compile it. Anything you break after that is definitely your fault.
  prefs: []
  type: TYPE_NORMAL
- en: The make configure Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many software packages use a `configure` script to prepare themselves for compilation
    on a specific platform. The `make configure` command runs that script. If you
    want to edit the `configure` script, do so before running this stage! If there
    is no `configure` script, the port silently skips this stage.
  prefs: []
  type: TYPE_NORMAL
- en: The make build Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make build` stage compiles the fetched, extracted, patched, and configured
    software. If you type `make` in a port directory, the port calls `make build`.
    This stage doesn’t assemble a package; it just performs the compilation and creates
    the actual program binaries in the port’s work directory.
  prefs: []
  type: TYPE_NORMAL
- en: The make fake Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make fake` stage installs the software in a subdirectory, laid out exactly
    as it would be under the *root* directory. This fake root directory is in the
    work directory, named *fake-* with the architecture appended, such as *fake-amd64*.
    Everything that will be in the package is installed under this directory, with
    the same ownership and permissions that it will include in the package.
  prefs: []
  type: TYPE_NORMAL
- en: The make package Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make package` stage bundles up the port’s fake installation directory,
    adds in packaging and installation instructions, and ties it all up in a package
    exactly like those available on the FTP site. The package will be stored under
    the *PKGREPO* directory you defined earlier (or in */usr/ports/packages* if you
    didn’t define one), in a subdirectory organized by architecture, and in further
    subdirectories organized by available distribution locations.
  prefs: []
  type: TYPE_NORMAL
- en: '`make package` means that you can build this port on one machine without installing
    it. You must install the build dependencies to build the port, however.'
  prefs: []
  type: TYPE_NORMAL
- en: The make install Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make install` stage runs `pkg_add(1)` to install the package you compiled.
  prefs: []
  type: TYPE_NORMAL
- en: The make clean Stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some packages require a lot of disk space. The `make clean` stage removes all
    of the build files except the distfile and the completed package.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD includes a variety of hooks to let you easily customize how you get
    and build ports. If possible, you should use the OpenBSD-provided infrastructure,
    but there may be cases where that’s not possible. Here, we’ll look at some of
    the more commonly used customization settings.
  prefs: []
  type: TYPE_NORMAL
- en: Local Distfile Mirrors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While ports provide several places to get source code, you might want to override
    those sites. Perhaps you share a network with a major mirror site, or you don’t
    have unfettered Internet access. OpenBSD lets you set your own preferred mirror
    sites.
  prefs: []
  type: TYPE_NORMAL
- en: Preferred Collection Mirrors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many software sources can be grouped into *collections*, which tend to be mirrored
    together. An example is the official GNU software collection. A GNU mirror site
    probably has everything in the official GNU collection. The Gnu C Compiler Project
    has its own set of software and mirrors. There are older software collections,
    such as SunSITE, and newer ones, such as SourceForge.
  prefs: []
  type: TYPE_NORMAL
- en: Each collection is available from a list of mirror sites. OpenBSD maintains
    lists of these mirror sites in */usr/ports/infrastructure/templates/network.conf.template*.
    Never edit this file; it’s a core ports file, and upgrading changes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a list of mirrors for a smaller project, BerliOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Several ports want to fetch BerliOS-related software from the main BerliOS download
    site. The OpenBSD port developers have identified three desirable mirrors, as
    listed in the variable `MASTER_SITE_BERLIOS`.
  prefs: []
  type: TYPE_NORMAL
- en: But suppose you have a BerliOS mirror much closer to you. Perhaps it’s not an
    official mirror, or you’ve managed to finagle access to a nonpublic mirror. It’s
    closer, it’s faster, and you would prefer to use it. OpenBSD looks at */usr/ports/infrastructure/db/network.conf*
    before the default mirror list. You could copy the default mirror list to this
    file and edit it, but then you would need to manually synchronize changes during
    upgrades. That’s work, and therefore morally questionable. Instead, add entries
    only in *network.conf*, and include the default *network.conf.template*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a private BerliOS mirror at *[http://www.blackhelicopters.org/berlios/](http://www.blackhelicopters.org/berlios/)*.
    You would create a *network.conf* file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+=` used in both *network.conf* and *network.conf.template* means “Add
    this value to variable such-and-such.” More desirable mirrors appear first in
    the list. This *network.conf* entry adds the private mirror to the variable `MASTER_SITE_BERLIOS`,
    and then calls in *network.conf.default*, which appends all of the other mirrors.
    The end result is that the BerliOS mirror list will contain four mirrors: your
    preferred mirror first and the default OpenBSD-approved mirrors later. If a file
    does not exist on a mirror, the port will try the other mirrors in order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I used BerliOS as an example because it has a small mirror list, but the same
    applies to any other software collection that OpenBSD recognizes. Other collections
    available at this time are shown in [Table 13-1](ch13.html#some_software_collections
    "Table 13-1. Table 13-1: Some Software Collections").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1. Table 13-1: Some Software Collections'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_GNU` | Software from the GNU project |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_GCC` | Software from the GCC project |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_XCONTRIB` | Contributions to the X Window System |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_R5CONTRIB` | Older X Window System contributions |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_SUNSITE` | A collection of Sun software |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_SOURCEFORGE` | Software hosted by SourceForge |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_SOURCEFORGE_JP` | Japanese SourceForge mirrors |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_GNOME` | Software from the Gnome project |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_PERL_CPAN` | The biggest Perl module collection |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_TEX_CTAN` | Software for TeX typesetting |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_KDE` | Software related to KDE |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_SAVANNAH` | Software development hosted by the FSF |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_AFTERSTEP` | Software related to the AfterStep window manager
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_WINDOWMAKER` | Software related to the Window Maker window manager
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_FREEBSD_LOCAL` | Software distributed by the FreeBSD Project,
    but not included in FreeBSD |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_PACKETSTORM` | Security software part of the Packet Storm collection
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_APACHE` | Apache Foundation software |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_BERLIOS` | Parts of the BerliOS Linux project |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_MYSQL` | Software from the MySQL project (Oracle) |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_PYPI` | Python software |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_RUBYGEMS` | Modules for Ruby |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_NPM` | JavaScript packages |'
  prefs: []
  type: TYPE_TB
- en: '| `MASTER_SITE_ISC` | Software from the Internet Software Consortium |'
  prefs: []
  type: TYPE_TB
- en: If you have a Debian mirror in your university datacenter, list it in *network.conf*.
    If it appears a second time, later in the list, because it’s listed in *network.conf.template*,
    so what? Either the distfile is there, in which case you save time and bandwidth,
    or the *distfile* isn’t there, in which case you waste 50 milliseconds checking
    the local mirror a second time.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback Mirrors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenBSD supports two fallback mirrors. If all other distfile sources fail, you
    can check either the OpenBSD or FreeBSD mirrors for the file. Both OpenBSD and
    FreeBSD tend to mirror distfiles for active ports. This isn’t preferred, because
    if everyone did this, it would use bandwidth that the projects need for distributing
    their own software. But if you’re desperate, set `MASTER_SITE_OPENBSD` and/or
    `MASTER_SITE_FREEBSD` to `YES` in *network.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Mirror
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can have the ports system check a particular site first for all distfiles,
    regardless of the download site listed in the port. Perhaps you have a local mirror
    where you’ve stuck a whole bunch of distfiles, or you automatically load distfiles
    from your ports-building machines to a central location. Define this site with
    the variable `MASTER_SITE_OVERRIDE` in *network.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve built local distfile mirrors many times, usually when starting a new job.
    I manage to update the mirror for about six months before some other task supersedes
    it and the mirror becomes obsolete, so I don’t generally recommend this practice.
    But if maintaining a local distfile mirror reduces your workload instead of increasing
    it, enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: Flavors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some ports can create multiple but slightly different packages through *flavors*.
    The Apache 2.2 web server I keep dragging out as an example can be built with
    or without LDAP support, as can programs with optional X support. Shells can be
    built in dynamic or static versions. OpenBSD’s official packages are built with
    the most common choices, but these alternatives are reasonable and occasionally
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify the flavors that a port supports, go to the port directory and
    run **`make show=FLAVORS`**. Here’s how to check the flavors of the popular text
    editor Vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can guess what some of these eight flavors do, but how can you learn about
    the others? You can check the package’s description file for brief descriptions
    of each flavor. Here are the descriptions for the Vim flavors, from *editors/vim/pkg/DESCR-main*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Motif? I remember Motif. And now I’m going to try really hard to forget it again.
    But if you want Motif support in your Vim version, go for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fall back to my ongoing example, here are the flavors for Apache 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I use LDAP to attach websites to my central authentication system. If I can
    get LDAP authentication on my web server, I want it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Flavored Port
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Define any desired flavors with the `$FLAVOR` environment variable, but not
    in your *.profile* or *.cshrc* file, as a port will not build if you request an
    unrecognized flavor. Define it when you build the port. For example, while still
    in the *apache-httpd* directory, I run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By your defining the flavor on the command line, the port knows to check for
    the OpenLDAP client needed to build Apache. When the build finishes, you should
    get a package file with the flavor appended—in this case, *apache-httpd-2.2.20p1-ldap.tgz*.
  prefs: []
  type: TYPE_NORMAL
- en: Flavors and Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you build a *flavored port*, the flavor does not propagate to dependencies.
    You need to check the flavored port’s dependencies to see if they need flavoring
    as well. For example, my flavored Apache package calls in the OpenLDAP client,
    which has no flavors, but OpenLDAP calls in `cyrus-SASL`, and if I check that
    port, I see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Cyrus SASL comes in LDAP flavor, but defining that I want Apache built in LDAP
    flavor doesn’t mean that `cyrus-SASL` will also be built with LDAP support. If
    I need LDAP support in this dependency, I must build it separately. I don’t need
    it for my environment, so I won’t bother, but check for potential issues like
    these when building your packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to rebuild a dependent port with a flavor, be sure to rebuild
    all the ports that depend on that port afterward. Be sure that your packages have
    correct dependencies using the targets `print-build-depends` and `print-run-depends`.
    Here, I see which ports I’ll need to build for my flavored Apache 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I can check the flavors of each of these ports.
  prefs: []
  type: TYPE_NORMAL
- en: Building Multiple Flavors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can build multiple flavors of one port on the same system. Each package
    filename includes the flavor, so you can have packages for both the Motif and
    GTK2 versions of Vim. Carefully inspect the dependencies to verify that each is
    built with the correct flavoring. For packages with flavored dependencies, I recommend
    removing every flavored dependency and rebuilding them all again, so that everything
    gets the correct flavor.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling and Reinstalling Flavored Ports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Flavoring a package changes its name. I can’t run `pkg_delete apache-httpd`
    because it’s not installed. Query the system for the packages you’ve manually
    installed, and you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When working with this package, you must specify the flavor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, to reinstall a flavored package, specify the flavored package file.
  prefs: []
  type: TYPE_NORMAL
- en: Subpackages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some ports contain multiple wildly different packages. This isn’t like adding
    LDAP support to Apache or Motif support to Vim—those are changes to the existing
    package, not wildly different. Some ports create two completely different packages,
    such as a database client and the associated database server. I’ve drawn in OpenLDAP
    through this chapter’s examples, and both the OpenLDAP server and client come
    from the same port: *databases/openldap*. Other applications might have plug-ins
    for accessing several different database engines. These are called *subpackages*
    or *multipackages*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike flavors, OpenBSD provides all subpackages of a port. You can install
    both the server and client versions of OpenLDAP from official packages. When the
    port is built, all the subpackages are built. The package is split into subpackages
    at the package-bundling stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all the subpackages supported by a port, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This port has two subpackages: `openldap-main` and `openldap-server`.'
  prefs: []
  type: TYPE_NORMAL
- en: How can you learn what each subpackage includes? As with flavors, you can check
    its description file, which is *pkg/DESCR*. OpenLDAP includes *pkg/DESCR-server*
    and *pkg/DESCR-main*. Reading these shows that the `main` package is the client,
    as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `make install` in the port directory, you get the main version of
    the port—in this case, the OpenLDAP client. OpenLDAP clients outnumber the servers,
    so that’s also what you would expect. To build a different subpackage, set `SUBPACKAGE`
    in the environment on the command line, as you did for flavors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This builds the `-server` version. Be sure to include the leading dash, as specifying
    a nonexistent subpackage makes the build fail.
  prefs: []
  type: TYPE_NORMAL
- en: Packages and rc.d Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. The Boot Process") covered how to have OpenBSD
    start packaged software, but let’s review it quickly. When you install a package
    that can be started at boot time, the package also installs a startup script in
    */etc/rc.d*. If I install the OpenLDAP server, the package installation will report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To start the `slapd(8)` OpenLDAP server at boot, add the script name to the
    `pkg_scripts` variable in */etc/rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: OpenBSD runs these scripts in order at boot, and in reverse order at shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: To change a package’s command-line arguments from the default, add a *`command`*`_flags`
    variable to *rc.conf.local*. Do not edit the startup script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can now manage your add-on software in any way you need.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s move on to configuring OpenBSD’s integrated software, through the
    files in */etc*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#id453650)]) In the IT industry, “minimal education” means a willingness
    to dig in and figure it out, plus a few years of college or professional experience;
    access to programming textbooks or other educational materials; or a whole lot
    of youth, stubbornness, and motivation.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#id366676)]) No, it’s not. There is no *ftp10.usa.openbsd.org*. Follow
    the instructions. Look at the mirror list and pick a mirror that actually exists
    and is close to you. Never blindly copy my examples!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#id485212)]) If you don’t see anything to worry about on any given server,
    you aren’t looking hard enough.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#id431051)]) This example exhausts my understanding of SQL. As long
    as I maintain my database ignorance, people won’t expect my help fixing their
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#id370871)]) Don’t laugh. It’s paid for.
  prefs: []
  type: TYPE_NORMAL
