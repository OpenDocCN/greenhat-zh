- en: Chapter 1. Interactive Ruby and the Ruby Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Ruby, as in most programming languages, we’ll generally store programs in
    external files and execute them at once, as a unit. However, Ruby also gives you
    the option of typing the lines of a program one at a time and seeing the results
    as you go along, using Interactive Ruby (irb); irb is a shell, similar to bash
    in a Unix or Unix-like system or the command prompt in Windows. Using irb will
    give you a good idea of how Ruby processes information, and it should also help
    you gain an understanding of Ruby’s basics before you ever even write a program.
  prefs: []
  type: TYPE_NORMAL
- en: Who should read this chapter? If you’ve already used Ruby and also already know
    the meaning of the terms *expression, irb, flow control, variable, function, method*,
    and *constant*, you can probably just skim this chapter. (If you encounter anything
    unfamiliar later, you can always come back.) If you’ve never programmed before,
    you should read this chapter carefully. If you’ve already used a language with
    an interactive environment, like Lisp or Python, you can probably just look at
    the irb sessions to see how Ruby differs from the language you already know—it’s
    likely that it does in some key ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The irb program is an example of a *read-eval-print-loop* (REPL) environment.
    This is an idea that comes from Ruby’s ancestor Lisp. It means just what the name
    says: It *reads* a line, *evaluates* that line, *prints* the results of the evaluation,
    and *loops*, waiting to read another line. The shell gives you immediate feedback
    for every line you enter, which is an ideal way to learn the syntax of a language.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting irb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting irb is very straightforward. On a Unix or Unix-like machine (such
    as GNU/Linux or Mac OS X), you can just type **`irb`** at the shell prompt. This
    should give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On a Windows machine, you’ll choose **Start ▸ Run**, type **`irb`**, then click
    **OK**. You can also run the command **`irb`** directly from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Using irb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve started it, irb is waiting for you to type your first line.
    *Lines* consist of one or more expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As far as Ruby is concerned, an *expression* is just a bit of code that has
    a value. In fine computer programming tradition, let’s see how irb reacts to the
    expression `“Hello, world!”`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This listing shows the line you need to type as well as how irb responds.
    Note also that irb shows you line numbers at the beginning of each line. I will
    occasionally refer to these numbers, as well*.'
  prefs: []
  type: TYPE_NORMAL
- en: What has happened here? You typed `“Hello, world!”`, and irb happily spat it
    right back at you. The interesting part of this is what isn’t explicit. The expression
    you entered has a value in Ruby, and therefore in irb. `“Hello, world!”` is a
    *String*, which is a sequence of characters, usually enclosed with either single
    or double quotation marks. Let’s prove it.
  prefs: []
  type: TYPE_NORMAL
- en: Everything Is an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Ruby, like its ancestor Smalltalk, everything is an *object*, which is just
    an instance of a class. `“Hello, world!”` happens to an instance of the class
    String.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Objects have *methods* (called on an object as `some_object.some_method`), which
    are just actions an object can perform. The method called `class` simply reports
    which class something belongs to; in other words, the type of thing that it is.
    Since `“Hello, world!”` is a String, that’s exactly what the `class` method reports
    when called on `“Hello, world!”`. There are other types of objects besides Strings,
    of course.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This book assumes that you are familiar with object orientation. If you’re
    not, here’s a crash description. An object is a thing. It could be any type of
    thing. Every object is an instance of a class; for example, the objects* Glasgow,
    Cairo, *and* Buffalo *would all be instances of the class *`City`*. The objects
    are distinct from each other, but they are the same type of thing*. Monty Python
    *and* The Kids in the Hall *would both be instances of the class *`Comedy Troupe`*,
    and so on. In Ruby, you will traditionally name instances with all lowercase letters
    and use underscores in the place of spaces; you will name classes with CamelCase.
    In actual Ruby code, the class *`ComedyTroupe`* would have instances (objects)
    called *`monty_python`* and *`kids_in_the_hall`**.'
  prefs: []
  type: TYPE_NORMAL
- en: Integers, Fixnums, and Bignums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other type of object (or class) is *Integer*, which is any number that
    is divisible by one. These should be familiar to you: 0, 1, -5, 27, and so on.
    Let’s enter an Integer in irb.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you call the method *`class`* on an Integer, it will report either Fixnum
    or Bignum, not Integer. This stems from how Ruby stores numbers internally. Computers
    can operate faster if they don’t waste space, so they have to worry about how
    much space numbers take up. However, computers also need to be able to handle
    very large numbers. Therefore, they compromise and store small numbers so that
    they take up little space, but they also store very large numbers, which inevitably
    take up more space. Sophisticated high-level languages like Ruby translate between
    these different types of numbers automatically, so you can just deal with numbers
    without worrying about these specific details. Isn’t that handy? For example,
    *`100.class`* returns *`Fixnum`*, and *`(100 ** 100).class`* returns *`Bignum`*.
    That’s because 100 is small enough to fit in a Fixnum, but the value of *`(100
    ** 100)`* will only fit in a Bignum—it’s too big for a Fixnum*.'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the number 100 has the value of 100 in irb, as you might expect.
    But we want to be able to do more than just see what we’ve typed, so let’s do
    something with our number 100\. Let’s add it to 100.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that irb has added these numbers correctly, and it shows you the
    result. In Ruby, `100 + 100` is an expression, just as `“Hello, world!”` and `100`
    by itself are expressions. The value of `100 + 100` is, naturally, 200\. Numbers
    have a method called `+`, which is how they add themselves to other numbers. That’s
    precisely what we’ve done here.
  prefs: []
  type: TYPE_NORMAL
- en: Addition, Concatenation, and Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `+` sign can do more than just add numbers. Let’s add two other expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By adding the String `“Hello,”` to the String `“world!”`, we’ve created the
    new longer String `“Hello, world!”`. Strings don’t perform addition, exactly.
    They use the `+` sign to do an operation called *concatenation*, which is just
    tacking one thing onto the end of another. In Ruby, the `+` sign means *Do whatever
    addition-like operations make the most sense for this class of object*. This allows
    you to just use the `+` sign and assume that Integers will add themselves in a
    reasonable “numbery” way, Strings will add themselves in a reasonable “stringy”
    way, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we try to add two different types of objects? Let’s find out
    in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That expression didn’t work out as well as the others. `TypeError` is an example
    of what Ruby (and many other languages) call an *exception*, which is a notice
    from a programming language that there has been an error. Our `TypeError` means
    that Ruby wasn’t happy that we asked to add a String to a number.^([[4](#ftn.CHP-1-FNOTE-1)])
    Strings know how to add themselves to each other, as do numbers—but they can’t
    cross types. When adding, we want both operands to be the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution to this problem is an operation called *casting*, which is the
    conversion of something from one type to another. Let’s see an example of casting
    in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the method `to_s` on `100` before trying to add it to `“Hello, world!”`.
    This method stands for to *String*—as you may have guessed, it converts the object
    it is called upon into a String. By the time we need to add these two operands
    together, they are both Strings, and Ruby dutifully concatenates them.^([[5](#ftn.CHP-1-FNOTE-2)])
    Let’s verify that `100.to_s` is a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So it is. But what happens when we want to convert something into an Integer?
    Is there a `to_i` method that we could call on the String `“100”` ? Let’s find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Casting is common in strongly-typed languages, like Ruby. It’s less common
    in weakly-typed languages, although it still can come up. Both approaches have
    their proponents*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, indeed. So we now know how to convert both Strings and Integers into
    each other, via either the `to_s` or `to_i` methods. It would be nice if we could
    see a list of all the methods we could call on a given object. We can do that
    too, with an aptly named method: `methods`. Let’s call it on the Integer 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see that both `+` and `to_s` are in the list of method names.^([[6](#ftn.CHP-1-FNOTE-3)])
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how the output of `methods` is enclosed with square brackets (`[]`).
    These brackets indicate that the enclosed items are the members of an *Array*,
    which is a list of objects. Arrays are just another class in Ruby, like String
    or Integer, and (unlike some other languages) there is no requirement for all
    members of a given Array to be instances of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to convert a single item into an Array is to wrap it in brackets,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays also know how to add themselves, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is just an another Array, comprised of all the elements of the added
    Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with String, Integer, and Array, Ruby also has a class called Boolean.
    Strings are sequences of characters, Integers are any numbers divisible by 1,
    and Arrays are lists of members. *Boolean* values can only be true or false. Booleans
    have many uses, but they are most commonly used in evaluations that determine
    whether to perform one action or an alternative. Such operations are called *flow
    control*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Booleans are named after the mathematician George Boole, who did much of the
    early work of formalizing them*.'
  prefs: []
  type: TYPE_NORMAL
- en: Flow Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most commonly used flow control operations is `if`. It evaluates
    the expression that follows it as either true or false. Let’s demonstrate some
    flow control with `if` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We just asked whether or not the expression `100 if true` is true. Since the
    expression `true` evaluates to a true value, we do get the value `100`. What happens
    when the expression evaluated by `if` isn’t true?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is something new. The expression `false` is not true, so we don’t get the
    expression `100`. In fact, we get no expression at all—irb tells us it has no
    value to report. Ruby has a specific value that stands for the absence of a value
    (or an otherwise meaningless value), which is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: The value could be absent for several reasons. It could be an inexpressible
    concept, or it could refer to missing data, which is what happened in our example.
    We never told irb what to report when the evaluated expression was false, so the
    value is missing. Any value that might need to be represented as *n/a* is a good
    candidate for a `nil` value. This situation comes up often when you are interacting
    with a database. Not all languages have a `nil`; some have it, but assume that
    it must be an error. Ruby is completely comfortable with `nil` values being used
    where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nil` value is distinct from all other values. However, when we force Ruby
    to evaluate `nil` as a Boolean, it evaluates to `false`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only values that evaluate to false Booleans are `nil` and `false`. In many
    other languages `0` or `“”` (a String with zero characters) will also evaluate
    to false, but this is not so in Ruby. Everything other than `nil` or `false` evaluates
    to true when forced into a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*We have to explicitly cast Strings and Integers into each other with the *`to_s`*
    and *`to_i`* methods, but notice that we don’t need to do this for Boolean values.
    Boolean casting is implicit when you use *`if`*. If you were to do explicit casting
    into a Boolean, you might expect a method similar to *`to_s`* and *`to_i`*, called
    *`to_b`*. There is no such method in Ruby yet, but we’ll write our own in [Chapter 3](ch03.html
    "Chapter 3. Programmer Utilities")*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want a certain value if an evaluated expression is true (as we’ve
    done with `if` already), but that we also want some non-`nil` value when the evaluated
    expression is false. How do we do that? Here’s an example in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s our first multi-line expression in irb. It should be fairly straightforward,
    returning `100`, because `true` evaluates to true. Let’s try again, with a few
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, since `false` evaluates as not true, the value of the multi-line
    expression is the value from the `else`, which is `50`. This format is a bit wordier
    than the previous tests that just used `if`. We also need the `end` keyword to
    tell irb when we’re done with the expression we started with `if`. If we wanted
    to do tests like these multi-line expressions often, retyping slight variations
    of the same basic idea over and over could become tedious. That’s where methods
    come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Notice that irb gives you some useful information in its prompt. The prompt
    often ends with a *`>`* symbol, which is usually preceded by a number. That number
    is how many levels deep you are, meaning the number of end statements you’ll need
    to get back to the top level. You’ll also notice that sometimes instead of ending
    with a *`>`* symbol, the prompt will end with an asterisk (*`*`*). This means
    that irb only has an incomplete statement and is waiting for that statement to
    be completed. Very useful*.'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We touched on methods earlier, but we’ll discuss them in more detail now. A
    *method* is just a bit of code that is attached to an object; it takes one or
    more input values and returns something as a result.^([[7](#ftn.CHP-1-FNOTE-4)])
    We call the inputs to a method the *arguments* or *parameters*, and we call the
    resulting value the *return value*. We define methods in Ruby with the keyword
    `def`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We just defined a method called `first_if_true`, which takes three arguments
    (which it calls `first, second`, and `to_be_tested`, respectively) and returns
    either the value of `first` or `second`, based on whether or not `to_be_tested`
    evaluates to true. We’ve now defined our earlier multi-line tests as something
    abstract that can be re-used with different values. Let’s try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Notice that the name of *`first_if_true`* tells you what it will do. This
    is a good habit to get into. Method names should tell you what they do. Clear,
    intuitive method names are an important part of good documentation. The same advice
    holds for variables, described later. By that criterion, *`result`* (as seen later)
    is not a very good name. It’s okay for a simple example that merely introduces
    the concept of assigning into a variable, but it’s unsuitably vague for real production
    code*.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `first_if_true` tests the third value and then returns either
    the first value or the second value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to try out the `first_if_true` method in irb with different arguments,
    either now or later. It should give you a good idea of how Ruby processes expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While methods return values when they are used, the simple act of defining
    a method returns *`nil`*, as you can see*.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What would happen if you wanted to use the output of one method as an input
    to another method? One of the most convenient ways to do so is with *variables*.
    Similar to algebra or physics, we just decide to refer to some value by name,
    like *m* for some specific mass or *v* for some specific velocity. We assign a
    value into a variable with a single `=` sign, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We assigned the value of `first_if_true(nil, “Hello, world!”, false)` (which
    happens to be `“Hello, world!”`) into a variable called `result`. We now have
    the value `“Hello, world!”` stored under the name `result`, which still evaluates
    as you’d expect it to, as you can see at line 39\. We can now use `result` like
    we would any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we can pass `result` through `first_if_true` and also evaluate it
    (as `to_be_tested`) for Boolean value. We can use it as a part of a larger expression,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the example on line 42, we’ve reversed the Boolean value of `result` with
    the keyword `not` before we pass it into `first_if_true`. We don’t make any changes
    to `result` on line 42\. We just create a new expression with `(not result)` that
    happens to evaluate to whatever the Boolean opposite of `result` is. The `result`
    itself stays unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*I’ve added some spaces just to make it easier to read which parentheses enclose
    the arguments to the method and which enclose the *`(not result)`* expression.
    Ruby and irb don’t care about whitespace very much*.'
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we want to refer to a value by name, but we don’t need to change
    it. In fact, sometimes we intend not to change it. Good examples from physics
    are the speed of light or the acceleration due to Earth’s gravity—they don’t change.
    In Ruby, we can define such values as *constants*, which must start with a capital
    letter. (By tradition, they are often entirely uppercase.) Let’s define a constant
    and then use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We see that we can assign into a constant just like we did into a variable.
    We can then use that constant by name, as an expression or within a larger expression,
    as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-1-FNOTE-1)]) Specifically a Fixnum, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-1-FNOTE-2)]) Technically, instead of casting, we’ve created an entirely
    new object that happens to be the String equivalent of 100.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-1-FNOTE-3)]) By the way, you can chain methods together, such as
    `100.methods.sort`. If you try that in irb, you’ll get the same list of methods
    as you’d get with `100.methods`, but in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-1-FNOTE-4)]) Ruby is object oriented, so it uses the term *method*.
    Languages with less of an object-oriented focus will call methods *functions*.
    A *method* is simply a function that is attached to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ruby Interpreter and Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you come from a Unix background, you’re probably already familiar with the
    concept of command-line options and environment variables. If you’re not familiar
    with these terms, they’re just ways for the computer to keep track of external
    data, usually configuration options. Ruby uses *command-line options* and *environment
    variables* to keep track of things like how paranoid or lax it should be in relation
    to security or how verbose to be about warnings. We’ve already seen an example
    of this in the instructions for installing Ruby from a source download, when we
    executed this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’d expect, that just asks Ruby to report its version. You can find out
    the various command-line options that Ruby understands by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables can store these command-line options as defaults; they
    can also store other information not specific to Ruby that Ruby may still find
    necessary to perform certain tasks. Users of Unix-like systems store their files
    inside what’s called a *HOME* directory, which keeps their data out of the way
    of other users. The My Documents folder in Windows is similar. Another important
    environment variable is `ARGV`, which is an Array that keeps track of all of the
    arguments passed to Ruby. When you execute an external Ruby program, as you often
    will by using the syntax below, the program’s name will be found in `ARGV`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move on to some specific example programs. We’ll be dealing with many
    of the topics we’ve only touched on in this chapter in greater detail appropriate
    to each example.
  prefs: []
  type: TYPE_NORMAL
