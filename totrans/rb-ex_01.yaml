- en: Chapter 1. Interactive Ruby and the Ruby Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 交互式 Ruby 和 Ruby 环境
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: In Ruby, as in most programming languages, we’ll generally store programs in
    external files and execute them at once, as a unit. However, Ruby also gives you
    the option of typing the lines of a program one at a time and seeing the results
    as you go along, using Interactive Ruby (irb); irb is a shell, similar to bash
    in a Unix or Unix-like system or the command prompt in Windows. Using irb will
    give you a good idea of how Ruby processes information, and it should also help
    you gain an understanding of Ruby’s basics before you ever even write a program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，就像在大多数编程语言中一样，我们通常会存储程序在外部文件中，并一次性执行它们作为一个单元。然而，Ruby 也允许您逐行输入程序的代码，并在进行过程中查看结果，使用交互式
    Ruby（irb）；irb 是一个 shell，类似于 Unix 或类似 Unix 系统中的 bash 或 Windows 中的命令提示符。使用 irb 将让您了解
    Ruby 如何处理信息，这也有助于您在编写程序之前就理解 Ruby 的基础知识。
- en: Who should read this chapter? If you’ve already used Ruby and also already know
    the meaning of the terms *expression, irb, flow control, variable, function, method*,
    and *constant*, you can probably just skim this chapter. (If you encounter anything
    unfamiliar later, you can always come back.) If you’ve never programmed before,
    you should read this chapter carefully. If you’ve already used a language with
    an interactive environment, like Lisp or Python, you can probably just look at
    the irb sessions to see how Ruby differs from the language you already know—it’s
    likely that it does in some key ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 谁应该阅读这一章？如果您已经使用过 Ruby，并且已经知道 *表达式、irb、流程控制、变量、函数、方法* 和 *常量* 这些术语的含义，您可能只需浏览这一章。（如果您以后遇到任何不熟悉的内容，您总是可以回来。）如果您以前从未编程过，您应该仔细阅读这一章。如果您已经使用过具有交互式环境的语言，如
    Lisp 或 Python，您可能只需查看 irb 会话，以了解 Ruby 与您已知的语言有何不同——它可能在某些关键方面有所不同。
- en: 'The irb program is an example of a *read-eval-print-loop* (REPL) environment.
    This is an idea that comes from Ruby’s ancestor Lisp. It means just what the name
    says: It *reads* a line, *evaluates* that line, *prints* the results of the evaluation,
    and *loops*, waiting to read another line. The shell gives you immediate feedback
    for every line you enter, which is an ideal way to learn the syntax of a language.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: irb 程序是一个 *读取-评估-打印循环*（REPL）环境的例子。这个想法来自 Ruby 的祖先 Lisp。这意味着正如其名所说：它 *读取* 一行，*评估*
    该行，*打印* 评估的结果，然后 *循环*，等待读取另一行。shell 会立即对您输入的每一行给出反馈，这是学习一种语言语法的理想方式。
- en: Starting irb
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 irb
- en: 'Starting irb is very straightforward. On a Unix or Unix-like machine (such
    as GNU/Linux or Mac OS X), you can just type **`irb`** at the shell prompt. This
    should give you the following result:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 irb 非常简单。在 Unix 或类似 Unix 的机器上（例如 GNU/Linux 或 Mac OS X），你只需在 shell 提示符下输入
    **`irb`**。这应该会给你以下结果：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On a Windows machine, you’ll choose **Start ▸ Run**, type **`irb`**, then click
    **OK**. You can also run the command **`irb`** directly from the command line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，您可以选择 **开始 ▸ 运行**，输入 **`irb`**，然后点击 **确定**。您也可以直接从命令行运行 **`irb`**
    命令。
- en: Using irb
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 irb
- en: Now that you’ve started it, irb is waiting for you to type your first line.
    *Lines* consist of one or more expressions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经启动了它，irb 正在等待您输入第一行。*行* 由一个或多个表达式组成。
- en: Expressions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: As far as Ruby is concerned, an *expression* is just a bit of code that has
    a value. In fine computer programming tradition, let’s see how irb reacts to the
    expression `“Hello, world!”`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就 Ruby 而言，一个 *表达式* 只是一段有值的代码。按照精细的计算机编程传统，让我们看看 irb 对表达式 `“Hello, world!”` 的反应。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This listing shows the line you need to type as well as how irb responds.
    Note also that irb shows you line numbers at the beginning of each line. I will
    occasionally refer to these numbers, as well*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*此列表显示了您需要输入的行以及 irb 的响应。请注意，irb 还会在每行的开头显示行号。我偶尔会引用这些数字，以及*。'
- en: What has happened here? You typed `“Hello, world!”`, and irb happily spat it
    right back at you. The interesting part of this is what isn’t explicit. The expression
    you entered has a value in Ruby, and therefore in irb. `“Hello, world!”` is a
    *String*, which is a sequence of characters, usually enclosed with either single
    or double quotation marks. Let’s prove it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？您输入了 `“Hello, world!”`，irb 高兴地将其直接返回给您。有趣的部分在于不明确的部分。您输入的表达式在 Ruby 中有一个值，因此也在
    irb 中。`“Hello, world!”` 是一个 *字符串*，它是一系列字符，通常用单引号或双引号括起来。让我们来证明这一点。
- en: Everything Is an Object
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切都是对象
- en: In Ruby, like its ancestor Smalltalk, everything is an *object*, which is just
    an instance of a class. `“Hello, world!”` happens to an instance of the class
    String.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，就像它的祖先Smalltalk一样，一切都是一个*对象*，它只是一个类的实例。`“Hello, world!”`是字符串类的一个实例。
- en: 'Let’s verify that in irb:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在irb中验证一下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Objects have *methods* (called on an object as `some_object.some_method`), which
    are just actions an object can perform. The method called `class` simply reports
    which class something belongs to; in other words, the type of thing that it is.
    Since `“Hello, world!”` is a String, that’s exactly what the `class` method reports
    when called on `“Hello, world!”`. There are other types of objects besides Strings,
    of course.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象有*方法*（在对象上调用时为`some_object.some_method`），这些方法只是对象可以执行的操作。调用`class`方法只是简单地报告某个事物属于哪个类；换句话说，它是哪种类型的东西。由于`“Hello,
    world!”`是一个字符串，所以当在`“Hello, world!”`上调用`class`方法时，它报告的就是这个。当然，除了字符串之外，还有其他类型的对象。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This book assumes that you are familiar with object orientation. If you’re
    not, here’s a crash description. An object is a thing. It could be any type of
    thing. Every object is an instance of a class; for example, the objects* Glasgow,
    Cairo, *and* Buffalo *would all be instances of the class *`City`*. The objects
    are distinct from each other, but they are the same type of thing*. Monty Python
    *and* The Kids in the Hall *would both be instances of the class *`Comedy Troupe`*,
    and so on. In Ruby, you will traditionally name instances with all lowercase letters
    and use underscores in the place of spaces; you will name classes with CamelCase.
    In actual Ruby code, the class *`ComedyTroupe`* would have instances (objects)
    called *`monty_python`* and *`kids_in_the_hall`**.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书假设你已经熟悉面向对象。如果你不熟悉，这里有一个简要的描述。对象是一个东西。它可以是任何类型的东西。每个对象都是类的实例；例如，对象*格拉斯哥、开罗*和*布法罗*都是类*`City`*的实例。这些对象彼此不同，但它们是同一类型的东西*。蒙提·派森*和*儿童在厅里*都是类*`Comedy
    Troupe`*的实例，等等。在Ruby中，你通常会使用全部小写字母命名实例，并在空格处使用下划线；你将使用驼峰命名法命名类。在实际的Ruby代码中，类*`ComedyTroupe`*将具有名为*`monty_python`*和*`kids_in_the_hall`*的实例（对象）**。'
- en: Integers, Fixnums, and Bignums
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数、Fixnums和Bignums
- en: 'One other type of object (or class) is *Integer*, which is any number that
    is divisible by one. These should be familiar to you: 0, 1, -5, 27, and so on.
    Let’s enter an Integer in irb.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的对象（或类）是*整数*，它是指可以被1整除的任何数字。这些应该对你来说很熟悉：0，1，-5，27等等。让我们在irb中输入一个整数。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you call the method *`class`* on an Integer, it will report either Fixnum
    or Bignum, not Integer. This stems from how Ruby stores numbers internally. Computers
    can operate faster if they don’t waste space, so they have to worry about how
    much space numbers take up. However, computers also need to be able to handle
    very large numbers. Therefore, they compromise and store small numbers so that
    they take up little space, but they also store very large numbers, which inevitably
    take up more space. Sophisticated high-level languages like Ruby translate between
    these different types of numbers automatically, so you can just deal with numbers
    without worrying about these specific details. Isn’t that handy? For example,
    *`100.class`* returns *`Fixnum`*, and *`(100 ** 100).class`* returns *`Bignum`*.
    That’s because 100 is small enough to fit in a Fixnum, but the value of *`(100
    ** 100)`* will only fit in a Bignum—it’s too big for a Fixnum*.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在整数上调用`class`方法，它将报告Fixnum或Bignum，而不是Integer。这源于Ruby内部存储数字的方式。计算机在不需要浪费空间的情况下可以更快地运行，所以它们必须担心数字占用多少空间。然而，计算机还需要能够处理非常大的数字。因此，它们做出了妥协，存储小的数字以节省空间，但同时也存储非常大的数字，这些数字不可避免地会占用更多的空间。像Ruby这样的高级语言会自动在这些不同类型的数字之间进行转换，所以你只需处理数字，无需担心这些具体的细节。这不是很方便吗？例如，*`100.class`*返回*`Fixnum`*，而*`(100
    ** 100).class`*返回*`Bignum`*。这是因为100足够小，可以放入Fixnum中，但*`(100 ** 100)`*的值只能放入Bignum中——它太大，不能放入Fixnum中*。'
- en: We see that the number 100 has the value of 100 in irb, as you might expect.
    But we want to be able to do more than just see what we’ve typed, so let’s do
    something with our number 100\. Let’s add it to 100.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，数字100在irb中的值是100，正如你所期望的那样。但我们都想能够做更多的事情，而不仅仅是看到我们输入的内容，所以让我们用我们的数字100来做点什么。让我们把它加到100上。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that irb has added these numbers correctly, and it shows you the
    result. In Ruby, `100 + 100` is an expression, just as `“Hello, world!”` and `100`
    by itself are expressions. The value of `100 + 100` is, naturally, 200\. Numbers
    have a method called `+`, which is how they add themselves to other numbers. That’s
    precisely what we’ve done here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到irb已经正确地添加了这些数字，并显示了结果。在Ruby中，`100 + 100`是一个表达式，就像`“Hello, world!”`和单独的`100`一样也是表达式。`100
    + 100`的值自然是200。数字有一个名为`+`的方法，这是它们如何将自己添加到其他数字的方法。这正是我们在这里所做的事情。
- en: Addition, Concatenation, and Exceptions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法、连接和异常
- en: 'The `+` sign can do more than just add numbers. Let’s add two other expressions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`符号不仅能加数字。让我们添加另外两个表达式：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By adding the String `“Hello,”` to the String `“world!”`, we’ve created the
    new longer String `“Hello, world!”`. Strings don’t perform addition, exactly.
    They use the `+` sign to do an operation called *concatenation*, which is just
    tacking one thing onto the end of another. In Ruby, the `+` sign means *Do whatever
    addition-like operations make the most sense for this class of object*. This allows
    you to just use the `+` sign and assume that Integers will add themselves in a
    reasonable “numbery” way, Strings will add themselves in a reasonable “stringy”
    way, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字符串`“Hello,”`添加到字符串`“world!”`中，我们创建了新的更长的字符串`“Hello, world!”`。字符串并不真正执行加法操作，它们使用`+`符号执行一个称为*连接*的操作，这仅仅是把一个东西附加到另一个东西的末尾。在Ruby中，`+`符号意味着*执行对这个类对象最有意义的类似加法操作*。这允许你只使用`+`符号并假设整数将以合理的“数字”方式相加，字符串将以合理的“字符串”方式相加，依此类推。
- en: What happens when we try to add two different types of objects? Let’s find out
    in irb.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将两种不同类型的对象相加时会发生什么？让我们在irb中找出答案。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That expression didn’t work out as well as the others. `TypeError` is an example
    of what Ruby (and many other languages) call an *exception*, which is a notice
    from a programming language that there has been an error. Our `TypeError` means
    that Ruby wasn’t happy that we asked to add a String to a number.^([[4](#ftn.CHP-1-FNOTE-1)])
    Strings know how to add themselves to each other, as do numbers—but they can’t
    cross types. When adding, we want both operands to be the same type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式没有像其他表达式那样顺利。`TypeError`是Ruby（以及许多其他语言）称为*异常*的例子，这是编程语言发出的错误通知。我们的`TypeError`意味着Ruby对我们要求将字符串添加到数字中并不高兴.^([[4](#ftn.CHP-1-FNOTE-1)])
    字符串知道如何将自己相加，数字也是如此——但它们不能跨越类型。在加法中，我们希望两个操作数都是同一类型。
- en: Casting
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'The solution to this problem is an operation called *casting*, which is the
    conversion of something from one type to another. Let’s see an example of casting
    in irb:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是一个称为*类型转换*的操作，即将某物从一种类型转换为另一种类型。让我们在irb中看看类型转换的例子：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We call the method `to_s` on `100` before trying to add it to `“Hello, world!”`.
    This method stands for to *String*—as you may have guessed, it converts the object
    it is called upon into a String. By the time we need to add these two operands
    together, they are both Strings, and Ruby dutifully concatenates them.^([[5](#ftn.CHP-1-FNOTE-2)])
    Let’s verify that `100.to_s` is a String:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试将`100`添加到`“Hello, world!”`之前，我们调用`to_s`方法。这个方法代表将对象转换为*字符串*——正如你可能猜到的，它将调用它的对象转换为字符串。在我们需要将这两个操作数相加的时候，它们都是字符串，Ruby忠实地将它们连接起来.^([[5](#ftn.CHP-1-FNOTE-2)])
    让我们验证`100.to_s`是否是一个字符串：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So it is. But what happens when we want to convert something into an Integer?
    Is there a `to_i` method that we could call on the String `“100”` ? Let’s find
    out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的。但当我们想要将某个东西转换为整数时会发生什么？是否有`to_i`方法可以调用字符串`“100”`？让我们找出答案。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Casting is common in strongly-typed languages, like Ruby. It’s less common
    in weakly-typed languages, although it still can come up. Both approaches have
    their proponents*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*在强类型语言中，如Ruby，类型转换很常见。在弱类型语言中，虽然也可能出现，但不太常见。两种方法都有其支持者*。'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can, indeed. So we now know how to convert both Strings and Integers into
    each other, via either the `to_s` or `to_i` methods. It would be nice if we could
    see a list of all the methods we could call on a given object. We can do that
    too, with an aptly named method: `methods`. Let’s call it on the Integer 100:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实可以。所以我们现在知道如何通过`to_s`或`to_i`方法将字符串和整数相互转换。如果我们能查看一个给定对象可以调用的所有方法列表，那会很好。我们也可以通过一个恰如其名的`methods`方法来做这件事。让我们在整数100上调用它：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see that both `+` and `to_s` are in the list of method names.^([[6](#ftn.CHP-1-FNOTE-3)])
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`+`和`to_s`都在方法名列表中.^([[6](#ftn.CHP-1-FNOTE-3)])
- en: Arrays
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Notice how the output of `methods` is enclosed with square brackets (`[]`).
    These brackets indicate that the enclosed items are the members of an *Array*,
    which is a list of objects. Arrays are just another class in Ruby, like String
    or Integer, and (unlike some other languages) there is no requirement for all
    members of a given Array to be instances of the same class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`methods`输出的括号是如何用方括号`[]`括起来的。这些括号表示括号内的项是数组的成员，数组是对象的列表。数组只是Ruby中的另一个类，就像String或Integer一样，而且（与某些其他语言不同）没有要求给定数组中的所有成员必须是同一类的实例。
- en: 'An easy way to convert a single item into an Array is to wrap it in brackets,
    like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个项目转换为数组的一种简单方法是将它用括号括起来，如下所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Arrays also know how to add themselves, as shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也知道如何添加自己，如下所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is just an another Array, comprised of all the elements of the added
    Arrays.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果只是一个包含所有添加的数组元素的另一个数组。
- en: Booleans
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Along with String, Integer, and Array, Ruby also has a class called Boolean.
    Strings are sequences of characters, Integers are any numbers divisible by 1,
    and Arrays are lists of members. *Boolean* values can only be true or false. Booleans
    have many uses, but they are most commonly used in evaluations that determine
    whether to perform one action or an alternative. Such operations are called *flow
    control*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了String、Integer和Array之外，Ruby还有一个名为Boolean的类。字符串是字符序列，整数是任何可以被1整除的数，数组是成员的列表。*布尔值*只能是真或假。布尔值有很多用途，但它们最常用于确定是否执行一个动作或另一个动作的评估操作。这类操作被称为*流程控制*。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Booleans are named after the mathematician George Boole, who did much of the
    early work of formalizing them*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值是以数学家乔治·布尔的名字命名的，他做了大量早期工作来形式化它们*。'
- en: Flow Control
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程控制
- en: 'One of the most commonly used flow control operations is `if`. It evaluates
    the expression that follows it as either true or false. Let’s demonstrate some
    flow control with `if` :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的流程控制操作之一是`if`。它评估其后的表达式为真或假。让我们用`if`演示一些流程控制：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We just asked whether or not the expression `100 if true` is true. Since the
    expression `true` evaluates to a true value, we do get the value `100`. What happens
    when the expression evaluated by `if` isn’t true?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚询问表达式`100 if true`是否为真。由于表达式`true`评估为真值，所以我们确实得到了值`100`。当`if`评估的表达式不为真时会发生什么？
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is something new. The expression `false` is not true, so we don’t get the
    expression `100`. In fact, we get no expression at all—irb tells us it has no
    value to report. Ruby has a specific value that stands for the absence of a value
    (or an otherwise meaningless value), which is `nil`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种新的情况。表达式`false`不是真的，所以我们没有得到表达式`100`。事实上，我们什么都没有得到——irb告诉我们它没有值可以报告。Ruby有一个特定的值表示值的缺失（或无意义的值），即`nil`。
- en: The value could be absent for several reasons. It could be an inexpressible
    concept, or it could refer to missing data, which is what happened in our example.
    We never told irb what to report when the evaluated expression was false, so the
    value is missing. Any value that might need to be represented as *n/a* is a good
    candidate for a `nil` value. This situation comes up often when you are interacting
    with a database. Not all languages have a `nil`; some have it, but assume that
    it must be an error. Ruby is completely comfortable with `nil` values being used
    where appropriate.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值可能因多种原因而缺失。它可能是一个无法表达的概念，或者它可能指的是缺失的数据，这正是我们例子中的情况。当我们评估的表达式为假时，我们从未告诉irb要报告什么，因此值是缺失的。任何可能需要表示为*n/a*的值都是`nil`值的良好候选。当你与数据库交互时，这种情况经常发生。并非所有语言都有`nil`；一些语言有，但假设它必须是错误。Ruby完全适应在适当的地方使用`nil`值。
- en: 'The `nil` value is distinct from all other values. However, when we force Ruby
    to evaluate `nil` as a Boolean, it evaluates to `false`, as shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil`值与所有其他值都不同。然而，当我们强制Ruby将`nil`评估为布尔值时，它评估为`false`，如下所示：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only values that evaluate to false Booleans are `nil` and `false`. In many
    other languages `0` or `“”` (a String with zero characters) will also evaluate
    to false, but this is not so in Ruby. Everything other than `nil` or `false` evaluates
    to true when forced into a Boolean.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一评估为假布尔值的值是`nil`和`false`。在许多其他语言中，`0`或`“”`（一个零字符的字符串）也会评估为假，但在Ruby中并非如此。当强制转换为布尔值时，除了`nil`或`false`之外的所有内容都评估为真。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We have to explicitly cast Strings and Integers into each other with the *`to_s`*
    and *`to_i`* methods, but notice that we don’t need to do this for Boolean values.
    Boolean casting is implicit when you use *`if`*. If you were to do explicit casting
    into a Boolean, you might expect a method similar to *`to_s`* and *`to_i`*, called
    *`to_b`*. There is no such method in Ruby yet, but we’ll write our own in [Chapter 3](ch03.html
    "Chapter 3. Programmer Utilities")*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们必须显式地将字符串和整数转换为彼此，使用`*to_s*`和`*to_i*`方法，但请注意，对于布尔值我们不需要这样做。当你使用`*if*`时，布尔转换是隐式的。如果你要显式地将布尔值转换为其他类型，你可能会期望有一个类似于`*to_s*`和`*to_i*`的方法，称为`*to_b*`。但在Ruby中目前还没有这样的方法，但我们在[第三章](ch03.html
    "第三章。程序员工具")中会自己编写一个*。'
- en: 'Let’s say we want a certain value if an evaluated expression is true (as we’ve
    done with `if` already), but that we also want some non-`nil` value when the evaluated
    expression is false. How do we do that? Here’s an example in irb:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在评估表达式为真时得到某个特定值（就像我们之前用`if`做的那样），同时当评估表达式为假时也希望得到一些非`nil`值。我们该如何做呢？以下是一个在irb中的示例：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That’s our first multi-line expression in irb. It should be fairly straightforward,
    returning `100`, because `true` evaluates to true. Let’s try again, with a few
    differences:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在irb中的多行表达式。它应该相当简单，返回`100`，因为`true`评估为真。让我们再次尝试，但有一些不同之处：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, since `false` evaluates as not true, the value of the multi-line
    expression is the value from the `else`, which is `50`. This format is a bit wordier
    than the previous tests that just used `if`. We also need the `end` keyword to
    tell irb when we’re done with the expression we started with `if`. If we wanted
    to do tests like these multi-line expressions often, retyping slight variations
    of the same basic idea over and over could become tedious. That’s where methods
    come into play.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于`false`评估为非真，多行表达式的值就是`else`中的值，即`50`。这种格式比之前只使用`if`的测试要复杂一些。我们还需要`end`关键字来告诉irb我们何时完成了从`if`开始的表达式。如果我们想经常进行这样的多行表达式测试，反复输入相同基本想法的微小变化可能会变得繁琐。这就是方法发挥作用的地方。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Notice that irb gives you some useful information in its prompt. The prompt
    often ends with a *`>`* symbol, which is usually preceded by a number. That number
    is how many levels deep you are, meaning the number of end statements you’ll need
    to get back to the top level. You’ll also notice that sometimes instead of ending
    with a *`>`* symbol, the prompt will end with an asterisk (*`*`*). This means
    that irb only has an incomplete statement and is waiting for that statement to
    be completed. Very useful*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，irb在其提示符中给你一些有用的信息。提示符通常以`*`符号结束，通常前面有一个数字。这个数字表示你处于多少层深度，即你需要多少个`end`语句才能回到顶层。你也会注意到，有时提示符不会以`*`符号结束，而是以星号(*)结束。这意味着irb只有一个不完整的语句，正在等待该语句被完成。非常有用*。'
- en: Methods
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'We touched on methods earlier, but we’ll discuss them in more detail now. A
    *method* is just a bit of code that is attached to an object; it takes one or
    more input values and returns something as a result.^([[7](#ftn.CHP-1-FNOTE-4)])
    We call the inputs to a method the *arguments* or *parameters*, and we call the
    resulting value the *return value*. We define methods in Ruby with the keyword
    `def`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了方法，但现在我们将更详细地讨论它们。一个*方法*只是附加到对象上的一小段代码；它接受一个或多个输入值并返回一个结果。^([[7](#ftn.CHP-1-FNOTE-4)])
    我们称方法的输入为*参数*或*参数*，称结果值为*返回值*。我们在Ruby中使用`def`关键字定义方法：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We just defined a method called `first_if_true`, which takes three arguments
    (which it calls `first, second`, and `to_be_tested`, respectively) and returns
    either the value of `first` or `second`, based on whether or not `to_be_tested`
    evaluates to true. We’ve now defined our earlier multi-line tests as something
    abstract that can be re-used with different values. Let’s try it out.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个名为`first_if_true`的方法，它接受三个参数（分别称为`first, second`和`to_be_tested`）并根据`to_be_tested`是否评估为真返回`first`或`second`的值。我们现在已经将之前的多行测试定义为可以重复使用不同值的抽象概念。让我们试试看。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Notice that the name of *`first_if_true`* tells you what it will do. This
    is a good habit to get into. Method names should tell you what they do. Clear,
    intuitive method names are an important part of good documentation. The same advice
    holds for variables, described later. By that criterion, *`result`* (as seen later)
    is not a very good name. It’s okay for a simple example that merely introduces
    the concept of assigning into a variable, but it’s unsuitably vague for real production
    code*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*`first_if_true` 的名字告诉你它将做什么。这是一个好习惯。方法名应该告诉你它们做什么。清晰直观的方法名是良好文档的重要部分。同样的建议也适用于稍后描述的变量。根据这个标准，*`result`*（如稍后所见）不是一个很好的名字。对于仅仅介绍将值赋给变量的概念的一个简单例子来说是可以的，但对于真正的生产代码来说，它太模糊了*。'
- en: Remember that `first_if_true` tests the third value and then returns either
    the first value or the second value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `first_if_true` 测试第三个值，然后返回第一个值或第二个值。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Feel free to try out the `first_if_true` method in irb with different arguments,
    either now or later. It should give you a good idea of how Ruby processes expressions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以在 irb 中尝试使用不同的参数来测试 `first_if_true` 方法，无论是现在还是以后。这应该能给你一个很好的想法，了解 Ruby 如何处理表达式。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While methods return values when they are used, the simple act of defining
    a method returns *`nil`*, as you can see*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*当方法被使用时，它们会返回值，但定义一个方法的简单行为会返回 *`nil`*，正如你所看到的*。'
- en: Variables
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'What would happen if you wanted to use the output of one method as an input
    to another method? One of the most convenient ways to do so is with *variables*.
    Similar to algebra or physics, we just decide to refer to some value by name,
    like *m* for some specific mass or *v* for some specific velocity. We assign a
    value into a variable with a single `=` sign, as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将一个方法的输出作为另一个方法的输入，会发生什么？这样做最方便的方法之一是使用 *变量*。类似于代数或物理学，我们只是决定通过名字来引用某个值，比如用
    *m* 表示某个特定的质量，用 *v* 表示某个特定的速度。我们用一个单独的 `=` 符号将值赋给变量，如下所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We assigned the value of `first_if_true(nil, “Hello, world!”, false)` (which
    happens to be `“Hello, world!”`) into a variable called `result`. We now have
    the value `“Hello, world!”` stored under the name `result`, which still evaluates
    as you’d expect it to, as you can see at line 39\. We can now use `result` like
    we would any other value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `first_if_true(nil, “Hello, world!”, false)`（恰好是 `"Hello, world!"`）的值赋给了一个名为
    `result` 的变量。现在，我们已经在 `result` 这个名字下存储了 `"Hello, world!"` 这个值，它仍然按照你预期的那样评估，正如你在第
    39 行所看到的。现在我们可以像使用任何其他值一样使用 `result`：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice how we can pass `result` through `first_if_true` and also evaluate it
    (as `to_be_tested`) for Boolean value. We can use it as a part of a larger expression,
    too:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以将 `result` 通过 `first_if_true` 传递，并评估它（作为 `to_be_tested`）的布尔值。我们也可以将它作为更大表达式的一部分：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the example on line 42, we’ve reversed the Boolean value of `result` with
    the keyword `not` before we pass it into `first_if_true`. We don’t make any changes
    to `result` on line 42\. We just create a new expression with `(not result)` that
    happens to evaluate to whatever the Boolean opposite of `result` is. The `result`
    itself stays unchanged.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 42 行的例子中，我们在将 `result` 传递给 `first_if_true` 之前，用关键字 `not` 反转了 `result` 的布尔值。我们在第
    42 行没有对 `result` 进行任何修改。我们只是创建了一个新的表达式 `(not result)`，它恰好评估为 `result` 的布尔相反值。`result`
    本身保持不变。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I’ve added some spaces just to make it easier to read which parentheses enclose
    the arguments to the method and which enclose the *`(not result)`* expression.
    Ruby and irb don’t care about whitespace very much*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*我添加了一些空格，只是为了更容易阅读哪些括号包含了方法的参数，哪些括号包含了 *`(not result)`* 表达式。Ruby 和 irb 对空白符并不很关心*。'
- en: Constants
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'Sometimes we want to refer to a value by name, but we don’t need to change
    it. In fact, sometimes we intend not to change it. Good examples from physics
    are the speed of light or the acceleration due to Earth’s gravity—they don’t change.
    In Ruby, we can define such values as *constants*, which must start with a capital
    letter. (By tradition, they are often entirely uppercase.) Let’s define a constant
    and then use it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要通过名字来引用一个值，但不需要改变它。实际上，有时候我们打算不改变它。物理学中的好例子是光速或地球重力加速度——它们不会改变。在 Ruby
    中，我们可以将这些值定义为 *常量*，这些常量必须以大写字母开头。（按照传统，它们通常是全部大写。）让我们定义一个常量然后使用它：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We see that we can assign into a constant just like we did into a variable.
    We can then use that constant by name, as an expression or within a larger expression,
    as desired.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以像给变量赋值一样给常量赋值。然后我们可以按名字使用那个常量，作为一个表达式或在一个更大的表达式中，根据需要。
- en: '* * *'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-1-FNOTE-1)]) Specifically a Fixnum, in our case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FNOTE-1)]) 在我们的例子中，特别是一个Fixnum。
- en: ^([[5](#CHP-1-FNOTE-2)]) Technically, instead of casting, we’ve created an entirely
    new object that happens to be the String equivalent of 100.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FNOTE-2)]) 从技术上来说，我们并没有进行类型转换，而是创建了一个全新的对象，它恰好是数字100的字符串等价物。
- en: ^([[6](#CHP-1-FNOTE-3)]) By the way, you can chain methods together, such as
    `100.methods.sort`. If you try that in irb, you’ll get the same list of methods
    as you’d get with `100.methods`, but in alphabetical order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-1-FNOTE-3)]) 顺便说一下，你可以将方法链接起来，例如`100.methods.sort`。如果你在irb中尝试这样做，你会得到与`100.methods`相同的函数列表，但按字母顺序排列。
- en: ^([[7](#CHP-1-FNOTE-4)]) Ruby is object oriented, so it uses the term *method*.
    Languages with less of an object-oriented focus will call methods *functions*.
    A *method* is simply a function that is attached to an object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-1-FNOTE-4)]) Ruby是面向对象的，因此它使用*方法*这个术语。那些不太注重面向对象的语言可能会把方法称为*函数*。*方法*就是一个附加到对象上的函数。
- en: Using the Ruby Interpreter and Environment
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ruby解释器和环境
- en: 'If you come from a Unix background, you’re probably already familiar with the
    concept of command-line options and environment variables. If you’re not familiar
    with these terms, they’re just ways for the computer to keep track of external
    data, usually configuration options. Ruby uses *command-line options* and *environment
    variables* to keep track of things like how paranoid or lax it should be in relation
    to security or how verbose to be about warnings. We’ve already seen an example
    of this in the instructions for installing Ruby from a source download, when we
    executed this command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Unix背景，你可能已经熟悉命令行选项和环境变量的概念。如果你不熟悉这些术语，它们只是计算机跟踪外部数据（通常是配置选项）的方式。Ruby使用*命令行选项*和*环境变量*来跟踪诸如在安全方面应该多么谨慎或宽松，以及关于警告应该多么详细等问题。我们已经在从源代码下载安装Ruby的说明中看到了一个例子，当时我们执行了以下命令：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you’d expect, that just asks Ruby to report its version. You can find out
    the various command-line options that Ruby understands by executing this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，这仅仅是要求Ruby报告其版本。你可以通过执行以下命令来找出Ruby理解的各种命令行选项：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Environment variables can store these command-line options as defaults; they
    can also store other information not specific to Ruby that Ruby may still find
    necessary to perform certain tasks. Users of Unix-like systems store their files
    inside what’s called a *HOME* directory, which keeps their data out of the way
    of other users. The My Documents folder in Windows is similar. Another important
    environment variable is `ARGV`, which is an Array that keeps track of all of the
    arguments passed to Ruby. When you execute an external Ruby program, as you often
    will by using the syntax below, the program’s name will be found in `ARGV`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以存储这些命令行选项作为默认值；它们还可以存储Ruby可能仍认为执行某些任务所必需的其他信息。Unix-like系统的用户将他们的文件存储在一个称为*HOME*目录中，这样可以避免其他用户的数据。Windows中的“我的文档”文件夹与此类似。另一个重要的环境变量是`ARGV`，它是一个数组，用于跟踪传递给Ruby的所有参数。当你执行外部Ruby程序时（你通常会使用以下语法），程序的名字将会在`ARGV`中找到。
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s move on to some specific example programs. We’ll be dealing with many
    of the topics we’ve only touched on in this chapter in greater detail appropriate
    to each example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨一些具体的示例程序。我们将更详细地处理本章中仅略提的一些主题，并针对每个示例进行适当的深入探讨。
