<html><head></head><body><div class="part" title="Part&#xA0;III-10.&#xA0;INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="interactive_and_administrative_utilities"/>Part III-10. INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS</h1></div></div></div><div class="partintro" id="id3385010" title="INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS"><div/><p><a class="xref" href="ch87.html" title="Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS">Chapter 87</a></p><p><a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a></p><p>File and message transfer applications include the File Transfer Protocol (FTP), electronic mail (email), and the World Wide Web, which makes file and message transfer the most important category of classic TCP/IP applications. However, those applications do not represent the only ways that TCP/IP internetworks are used. While not as glamorous as some of the application protocols we have examined so far in this section, interactive and administrative protocols are also important and worth understanding.</p><p>This final part of the book covers a couple other categories of TCP/IP applications. The first chapter describes interactive and remote application protocols, which are used traditionally to allow a user of one computer to access another, or to permit the real-time exchange of information. The second chapter discusses TCP/IP administration and troubleshooting utilities, which can be employed by both administrators and end users to manage TCP/IP networks and diagnose problems with them.</p></div></div>
<div class="chapter" title="Chapter&#xA0;87.&#xA0;TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_ip_interactive_and_remote_applicatio"/>Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e94868"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> When it comes to TCP/IP applications, file and message transfer applications get the most attention, because they are the ones used most often on modern internetworks. Another category of TCP/IP application protocols that is less well known is the group that allows users to interactively access and use other computers directly over an internetwork, such as the public Internet. These applications are not often employed by end users today, but they are still important—both from a historical perspective and because of their usefulness in certain circumstances, especially to network administrators.</p><p>In this chapter, I provide a brief description of the classic <a class="indexterm" id="idx-CHP-87-3138"/>interactive and remote application protocols used in TCP/IP. I first describe the Telnet Protocol, one of the earliest and most conceptually important application protocols in TCP/IP. This discussion includes a description of Telnet client/server communication, the Telnet Network Virtual Terminal (NVT), and Telnet's protocol commands and options. I then describe the Berkeley remote access family, often called the <span class="emphasis"><em>r commands</em></span> or protocols because their command names begin with that letter. Finally, I provide a brief overview of the Internet Relay Chat (IRC) protocol, the original interactive chat application of the Internet and one still used widely today.</p><div class="sect1" title="Telnet Protocol"><div class="titlepage"><div><div><h1 class="title"><a id="telnet_protocol"/>Telnet Protocol</h1></div></div></div><p><a class="indexterm" id="idx-CHP-87-3139"/>In the very earliest days of internetworking, one of the most important problems that computer scientists needed to solve was how to allow someone operating one computer to access and use another as if that remote user were connected to it locally. The protocol created to meet this need was called <span class="emphasis"><em>Telnet</em></span>, and the effort to develop it was tied closely to that of the Internet and TCP/IP as a whole. Even though most Internet users today never invoke the Telnet Protocol directly, they use some of its underlying principles indirectly all the time. Every time you send a piece of email, use the File Transfer Protocol (FTP) to transfer a file, or load a web page, you are using technology based on Telnet. For this reason, the Telnet Protocol can make a valid claim to the title of the most historically important application protocol in TCP/IP.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-520"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>A basic comprehension of the Transmission Control Protocol (TCP), especially its sliding window mechanism and flow control features, will be helpful in understanding Telnet. Those topics are covered in Chapters <a class="xref" href="ch48.html" title="Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER">Chapter 48</a> and <a class="xref" href="ch49.html" title="Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES">Chapter 49</a>.</em></span></p></div><div class="sect2" title="Telnet Overview, History, and Standards"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_overview_history_and_standards"/>Telnet Overview, History, and Standards</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3140"/>The history of Telnet actually goes back over a decade before the modern TCP/IP protocol suite that we know today. As I mentioned in my overview of FTP, the early developers of TCP/IP internetworking technologies identified two overall application needs for networks to fill: enabling <span class="emphasis"><em>direct access</em></span> to resources and also allowing <span class="emphasis"><em>indirect access</em></span> to resources. FTP was created for indirect access, by allowing users to retrieve a resource from a remote host, use it locally, and if desired, copy it back to its source. Telnet was designed for direct access, by allowing users to access a remote machine and use it as if they were connected to it locally.</p><div class="sect3" title="Telnet History"><div class="titlepage"><div><div><h3 class="title"><a id="telnet_history"/>Telnet History</h3></div></div></div><p>Telnet was initially developed in the late 1960s. This was well before the era of the small personal computers that so many of us use exclusively today. All computers of that period were large and usually shared by many users. To work on a computer, you had to access a physical terminal connected to that machine, which was usually specially tailored to the needs and requirements of the host. Two specific issues resulted from this situation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If an organization had several different computers, each user needed a separate terminal to access each computer that he or she used. This was expensive and inefficient. I can recall reading a quote from a book that compared this situation to having a room containing a number of television sets, each of which could only display a single channel.</p></li><li class="listitem"><p>Perhaps a more significant issue was the difficulty in allowing a user at one site to access and use a machine at another site. The only method at the time for accomplishing this was to install a dedicated data circuit from the site of the computer to the site of the user, to connect the user's terminal to the remote machine. Again, each circuit would enable access to only one machine. Every combination of user and computer required a separate, expensive circuit to be installed and maintained.</p></li></ul></div><p>The solution to both of these issues was to create a more general way of allowing any terminal to access any computer. The underlying internetwork provided the mechanism for communicating information between computers. This became the physical network connecting sites and the TCP/IP protocol suite connecting networks. On top of this ran an application protocol that allowed a user to establish a session to any networked computer and use it. That application protocol is Telnet.</p><p>Telnet was the first application protocol demonstrated on the fledgling ARPAnet, in 1969. The first RFC specifically defining Telnet was RFC 97, "First Cut at a Proposed <a class="indexterm" id="idx-CHP-87-3141"/>Telnet Protocol," published in February 1971. Development of Telnet continued throughout the 1970s, with quite a number of different RFCs devoted to revisions of the protocol and discussions of issues related to it. It took many years to refine Telnet and resolve all the difficulties that were associated with its development. The final version of the protocol, "Telnet Protocol Specification," was published as RFC 854 in May 1983. Over the years, other RFCs have been published to clarify the use of the protocol and address various issues such as authentication. There are also a number of other RFCs that define Telnet options, as discussed in the "Telnet Options and Option Negotiation" section later in this chapter.</p></div><div class="sect3" title="Fundamental Telnet Concepts"><div class="titlepage"><div><div><h3 class="title"><a id="fundamental_telnet_concepts"/>Fundamental Telnet Concepts</h3></div></div></div><p>At first glance, it may be surprising that Telnet took so long to develop, because in theory, it should be a very simple protocol to define. All it needs to do is send keystrokes and program output over the network like any other protocol. Its definition would be simple if every terminal and computer used the same communication method, but they do not. Telnet becomes complicated because it needs to allow a terminal from one manufacturer to be able to talk to a computer that may use a very different data representation.</p><p>Telnet solves this problem by defining a method that ensures compatibility between terminal types and computers, while allowing special features to be used by computers and terminals that agree to support them. The protocol is built on a foundation of three main concepts.</p><p><span class="strong"><strong>Network Virtual Terminal (NVT)</strong></span> Telnet defines a standardized, fictional terminal called the <span class="emphasis"><em>Network Virtual Terminal (NVT)</em></span> that is used for universal communication by all devices. A Telnet client takes input from a user and translates it from its native form to the NVT format to send to a Telnet server running on a remote computer. The server translates from NVT to whatever representation the computer being accessed requires. The process is reversed when data is sent from the remote computer back to the user. This system allows clients and servers to communicate even if they use entirely different hardware and internal data representations. Special <a class="indexterm" id="idx-CHP-87-3142"/>Telnet commands are interspersed with the data to allow the client and server devices to perform various functions needed to manage the operation of the protocol.</p><p><span class="strong"><strong>Options and Option Negotiation</strong></span> Having Telnet clients and servers act as NVTs avoids incompatibilities between devices, but does so by stripping all terminal-specific functionality to provide a common base representation that is understood by everyone. Since there are many cases where more intelligent terminals and computers may wish to use more advanced communication features and services, Telnet defines a rich set of options and a mechanism by which a Telnet client and server can negotiate their use. If the client and server agree on the use of an option, it can be enabled; if not, they can always fall back on the NVT to ensure basic communication.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-87-3143"/>Symmetric Operation</strong></span> While Telnet is a client/server protocol, it is specifically designed to not make assumptions about the nature of the client and server software. Once a Telnet session is established, the computers can each send and receive data as equals. They can also each initiate the negotiation of options. This makes the protocol extremely flexible and has led to its use in a variety of places, as discussed in the next section.</p></div><div class="sect3" title="Telnet Applications"><div class="titlepage"><div><div><h3 class="title"><a id="telnet_applications"/>Telnet Applications</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3144"/>Telnet is most often associated with remote login, which is its common traditional use. A user typically uses a Telnet client program to open a Telnet connection to a remote server, which then treats the Telnet client like a local terminal, allowing the user to log in and access the server's resources as if he were using a directly attached terminal. Telnet is still used this way quite extensively by UNIX users, who often need to log in to remote hosts from their local machines (I use Telnet in this manner every day to access a machine hundreds of miles away). However, this use of Telnet is not nearly as common among the majority of Internet users who work on Windows or Apple computers, where network resources are accessed not through direct login, but by other means.</p><p>Although remote login is a big part of what Telnet is about, the protocol was not inherently designed for that specific function. When Telnet is used to access a remote device, the protocol itself is used only to set up the connection between the client and server machines, encode data to be transmitted according to the rules of the Telnet NVT, and facilitate the negotiation and use of options. The client and server devices decide whether Telnet is used for remote access or for some other purpose.</p><p>This flexibility, combined with Telnet's age in the TCP/IP suite, has led to its being adopted for a variety of other protocols. Since Telnet doesn't make assumptions about what a client is and what a server is, any program or application can use it. Many of the file and message transfer applications—such as FTP, Simple Mail Transfer Protocol (SMTP), Network News Transfer Protocol (NNTP), and Hypertext Transfer Protocol (HTTP)—communicate by sending text commands and messages, and use Telnet's NVT specification to ensure the compatibility of communication between devices. They don't actually establish Telnet sessions or use features like option negotiation; they just send data in a manner consistent with how Telnet works. Thus, even though modern Internet users may never intentionally invoke Telnet specifically, they use it indirectly every time they send or receive email or browse the Web. Administrators can even use Telnet client software to access devices such as FTP and HTTP servers, and send those devices commands manually.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-521"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Telnet</em></span> is one of the oldest protocols in the TCP/IP suite, first developed in the 1960s to allow a user on one computer system to directly access and use another. It is most often used for remote login, with Telnet client software on a user's machine establishing a session with a Telnet server on a remote host to let the user work with the host as if connected directly. To ensure compatibility between terminals and hosts that use different hardware and software, communication between Telnet client and server software is based on a simplified, fictional data representation, called the <span class="emphasis"><em>Network Virtual Terminal (NVT)</em></span>, which can be enhanced through the negotiation of options.</p></div></div></div><div class="sect2" title="Telnet Connections and Client/Server Operation"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_connections_and_clientserver_oper"/>Telnet Connections and Client/Server Operation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3145"/>Telnet's overall function is to define a means by which a user or process on one machine can access and use another machine as if it were locally connected. This makes Telnet inherently client/server in operation, like so many other application protocols in TCP/IP. Usually, the Telnet client is a piece of software that acts as an interface to the user, processing keystrokes and user commands and presenting output from the remote machine. The Telnet server is a program running on a remote computer that has been set up to allow remote sessions.</p><div class="sect3" title="TCP Sessions and Client/Server Communication"><div class="titlepage"><div><div><h3 class="title"><a id="tcp_sessions_and_clientserver_communicat"/>TCP Sessions and Client/Server Communication</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3146"/>Telnet is used for the interactive communication of data and commands between a client and server over a prolonged period of time, and is thus strongly based on the concept of a <span class="emphasis"><em>session</em></span>. For this reason, Telnet runs over the connection-oriented Transmission Control Protocol (TCP). Telnet servers listen for connections on well-known TCP port number 23. When a client wants to access a particular server, it initiates a TCP connection to the appropriate server, which responds to set up a TCP connection using the standard TCP three-way handshake (described in <a class="xref" href="ch47.html" title="Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION">Chapter 47</a>).</p><p>The TCP connection is maintained for the duration of the Telnet session, which can remain alive for hours, days, or even weeks at a time. The quality of service features of TCP guarantee that data is received reliably and in order, and ensure that data is not sent at too high a rate for either client or server. A machine offering Telnet service can support multiple simultaneous sessions with different users, keeping each distinct by identifying it using the IP address and port number of the client.</p><p>Since TCP is a full-duplex protocol, both the client and server can send information at will over the Telnet session. By default, both devices begin by using the standard NVT method for encoding data and control commands (which we will explore fully a little later in this chapter). They can also negotiate the use of Telnet options to provide greater functionality for the session. While option negotiation can occur at any time, it is normal for there to be a burst of such option exchanges when a Telnet session is first established and only occasional option command exchanges thereafter.</p><p>With the TCP connection in place and the Telnet session active, the client and server software begin their normal jobs of interfacing the user to the remote host. To the user, the Telnet session appears fundamentally the same as sitting down at a terminal directly connected to the remote host. In most cases, the server will begin the user's session by sending a login prompt to ask for a user name and password. The Telnet client will accept this information from the user and send it to the server. Assuming the information is valid, the user will be logged in and can use the host in whatever manner her account authorizes.</p><p>As mentioned in the Telnet overview, even though the protocol is commonly used for remote login, it does not need to be used in this manner. The administrator of the computer that is running the Telnet server determines how it is to be used on that machine. As just one example, a Telnet server can be interfaced directly to a process or program providing a service. I can recall years ago using an Internet server that provided weather information to the public using Telnet. After using the protocol to connect to that machine, users were presented not with a login prompt, but with a menu of weather display options. Today, the Web has replaced most of such facilities, as it is far better suited to this type of information retrieval.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-522"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Telnet is a client/server protocol that uses TCP to establish a session between a user terminal and a remote host. The Telnet client software takes input from the user and sends it to the server, which feeds it to the host machine's operating system. The Telnet server takes output from the host and sends it to the client to display to the user. While Telnet is most often used to implement remote login capability, it is not specifically designed for logins. The protocol is general enough to allow it to be used for a variety of functions.</p></div></div><div class="sect3" title="Use of Telnet to Access Other Servers"><div class="titlepage"><div><div><h3 class="title"><a id="use_of_telnet_to_access_other_servers"/>Use of Telnet to Access Other Servers</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3147"/>The Telnet NVT representation is used by a variety of other protocols such as SMTP and HTTP. This means that the same Telnet client that allows you to access a Telnet server can be used to directly access other application servers. All you need to do is specify the port number corresponding to the service. For example, the following command will allow you to directly interface to a web server:</p><a id="I_programlisting1_d1e95045"/><pre class="programlisting">telnet <em class="replaceable"><code>www.someserversomewhere.org</code></em> 80</pre><p>You will not receive a login prompt, but instead the server will wait for you to send an HTTP Request message, as if you were a web browser. If you enter a valid request, the server will send you an HTTP Response message. Used in this way, Telnet can be very valuable as a diagnostic tool.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-523"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The Telnet <a class="indexterm" id="idx-CHP-87-3148"/>Network Virtual Terminal (NVT) data representation has been adopted by a host of other TCP/IP protocols as the basis for their messaging systems. Telnet client software can thus be used not only to connect to Telnet servers, but also to connect to servers of protocols such as SMTP and HTTP, which is useful for diagnostic purposes.</p></div></div></div><div class="sect2" title="Telnet Communications Model and the Network Virtual Terminal (NVT)"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_communications_model_and_the_netw"/>Telnet Communications Model and the Network Virtual Terminal (NVT)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3149"/><a class="indexterm" id="idx-CHP-87-3150"/>At its heart, Telnet is a rather simple protocol. Once a TCP connection is made and the Telnet session begins, the only real task for the client and server software is to capture input and output, and redirect it over the network. So, when the user presses a key on his local terminal, the Telnet client software captures it and sends it over the network to the remote machine. There, the Telnet server software sends the keypress to the operating system, which treats it as if it had been typed locally. When the operating system produces output, the process is reversed: Telnet server software captures the output and sends it over the network to the user's client program, which displays it on the printer or monitor.</p><p>To invoke two well-known clichés, I could say that this looks good on paper, but that the devil is in the details. This simplified implementation would work only if every computer and terminal used the exact same hardware, software, and data representation. Of course, this is far from the case today, and was even worse when Telnet was being developed. Computers back in the "good old days" were highly proprietary and not designed to interoperate. They differed in numerous ways—from the type of keyboard a terminal used and the keystrokes it could send, to the number of characters per line and lines per screen on a terminal, to the character set used to encode data and control functions. In short, Computer A was designed to accept input in a particular form from its own terminals, and not those of Computer B.</p><p>This is actually a fairly common issue in the world of networking, and one to which I can draw a real-world analogy to help explain the problem and how it may be solved. Suppose that an important international conference was attended by 30 ambassadors from different nations, each of which had one assistant. Every ambassador and assistant pair spoke only their own language and thus could only speak to each other—just like a computer and terminal designed to interface only to each other. To allow the assistant from one country to speak to the ambassador from the others, one solution would be to train the assistants to speak the languages of all the other attending nations. Back in the computing world, this would be like defining the Telnet Protocol so that every Telnet client software implementation understood how to speak to every computer in existence. This would work, but it would be quite impractical and difficult to do.</p><p>An alternative approach is to define a single common language and have all the ambassadors and assistants learn it. While this would require some work, it would be a lot less than requiring people to learn dozens of languages. Each ambassador and assistant would speak both a native language and this chosen common language. Each could communicate with all of the others using this common language, without needing to know all of the languages that might be used by anyone at the conference. Even more important, if an ambassador and assistant showed up at the conference speaking a new, 31st language, all the other delegates wouldn't need to learn it.</p><p>Telnet uses a very similar approach for dealing with its problem of hardware and software compatibility. Rather than having terminals and hosts communicate using their various native languages, all Telnet clients and servers agree to send data and commands that adhere to a fictional, virtual terminal type call the <a class="indexterm" id="idx-CHP-87-3151"/>NVT.</p><div class="sect3" title="The NVT"><div class="titlepage"><div><div><h3 class="title"><a id="the_nvt"/>The NVT</h3></div></div></div><p>The NVT defines a set of rules for how information is formatted and sent, such as character set, line termination, and how information about the Telnet session itself is sent.</p><p>Each Telnet client running on a terminal understands both its native language and the NVT language. When users enter information on their local terminal, it is converted to NVT form for transmission over the network. When the Telnet server receives this information, it translates it from NVT form to the format that the remote host expects to receive it. The identical process is performed for transmissions from the server to the client, in reverse. This is illustrated in <a class="xref" href="ch87.html#telnet_communication_and_the_network_vir" title="Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet uses the Network Virtual Terminal (NVT) representation to allow a user terminal and remote host that use different internal formats to communicate.">Figure 87-1</a>.</p><div class="figure"><a id="telnet_communication_and_the_network_vir"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e95098"/><img alt="Telnet communication and the Network Virtual Terminal (NVT) Telnet uses the Network Virtual Terminal (NVT) representation to allow a user terminal and remote host that use different internal formats to communicate." src="httpatomoreillycomsourcenostarchimages288325.png.jpg"/></div></div><p class="title">Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet uses the Network Virtual Terminal (NVT) representation to allow a user terminal and remote host that use different internal formats to communicate.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-524"/>Tip</h3><p><a class="indexterm" id="idx-CHP-87-3152"/><a class="indexterm" id="idx-CHP-87-3153"/><span class="strong"><strong>KEY CONCEPT</strong></span> The Telnet <span class="emphasis"><em>Network Virtual Terminal (NVT)</em></span> is a uniform data representation that ensures the compatibility of communication between terminals and hosts that may use very different hardware, software, and data formats. The Telnet client translates user input from the terminal's native form to NVT form for transport to the Telnet server, where it is converted to the host's internal format. The process is reversed for output from the host to the user.</p></div><p>The NVT is defined to consist of a logical keyboard for input and a logical printer for output (the age of the protocol is reflected in these terms; decades ago there were no monitors, all output was on paper). NVT uses the 7-bit <a class="indexterm" id="idx-CHP-87-3154"/><span class="emphasis"><em>United States ASCII (US-ASCII)</em></span> character set. Each character is encoded using one 8-bit byte.</p><p>However, a client and server can use Telnet options to negotiate other data representations, including the transmission of either extended ASCII or even full 8-bit binary data.</p></div><div class="sect3" title="NVT ASCII Control Codes"><div class="titlepage"><div><div><h3 class="title"><a id="nvt_ascii_control_codes"/>NVT ASCII Control Codes</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3155"/>Regular ASCII consists of 95 regular, printable characters (codes 32 through 126) and 33 control codes (0 through 31 and 127). The Telnet standard specifies that the output device must be able to handle all the printable characters, and it mandates how several of the other common <a class="indexterm" id="idx-CHP-87-3156"/>ASCII control codes should be interpreted. Of these codes, three (0, 10, and 13) are required to be accepted by all Telnet software; five others are optional, but if supported, must be interpreted in a manner consistent with the Telnet specification. <a class="xref" href="ch87.html#interpretation_of_standard_telnet_nvt_as" title="Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes">Table 87-1</a> describes the standard Telnet NVT <a class="indexterm" id="idx-CHP-87-3157"/>ASCII control codes.</p><div class="table"><a id="interpretation_of_standard_telnet_nvt_as"/><p class="title">Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Interpretation of Standard Telnet NVT ASCII Control Codes"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ASCII Value (Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ASCII Character Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ASCII Character</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Support Optional/Mandatory</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NUL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Null</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No operation (no effect on output).</p></td><td style="border-bottom: 0.5pt solid ; "><p>Mandatory</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BEL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bell</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Produces an audible or visible signal on the output without moving the print head. This notification may be used to get the user's attention, as in the case of an error.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Optional</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Backspace</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moves the print position one character to the left.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Optional</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>HT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Horizontal Tab</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moves the printer to the next horizontal tab stop. The standard does not specify how devices agree on tab stop positions; this can be negotiated using Telnet options.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Optional</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LF</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Line Feed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moves the printer to the next line, keeping the print position the same.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Mandatory</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>VT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Vertical Tab</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moves the print line to the next vertical tab stop. As with the HT character, devices must use an option to come to an agreement on vertical tab stop positions.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Optional</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FF</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Form Feed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moves the printer to the top of the next page (or on a display, clears the screen and positions the cursor at the top).</p></td><td style="border-bottom: 0.5pt solid ; "><p>Optional</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; "><p>CR</p></td><td style="border-right: 0.5pt solid ; "><p>Carriage Return</p></td><td style="border-right: 0.5pt solid ; "><p>Moves the printer to the left margin of the current print line.</p></td><td style=""><p>Mandatory</p></td></tr></tbody></table></div></div><p>The Telnet NVT scheme defines the combination of the carriage return (CR) and line feed (LF) characters to represent the end of a line of ASCII text. The literal meaning of these two characters is return to the left margin (the CR) and go to the next line (the LF). However, NVT treats the CRLF sequence as more than just two independent characters; they are taken collectively to define a <a class="indexterm" id="idx-CHP-87-3158"/><span class="emphasis"><em>logical end-of-line character</em></span>. This is necessary because not all terminal types define an end of line using both CR and LF. Translation of end-of-line characters between the native and NVT formats is one of the functions that Telnet client and server software must perform to ensure compatibility between terminals and hosts.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-525"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <a class="indexterm" id="idx-CHP-87-3159"/>Telnet NVT format is based on 7-bit US-ASCII, with each byte carrying one character. The standard specifies that devices must handle all standard printable ASCII characters, as well as three mandatory control characters. Two of these are the carriage return (CR) and line feed (LF) characters; when combined, these define the logical end of a line of text. The Telnet standard also describes the interpretation of five other optional ASCII control characters.</p></div></div><div class="sect3" title="Half-Duplex and Full-Duplex Modes"><div class="titlepage"><div><div><h3 class="title"><a id="half-duplex_and_full-duplex_modes"/>Half-Duplex and Full-Duplex Modes</h3></div></div></div><p>Another artifact of the age of Telnet is that for maximum compatibility, the NVT specification is designed under the assumption of half-duplex operation: only one device can transmit at a time. A device that is sending data is supposed to end its transmission with the special Telnet Go Ahead command, telling the other device that it may now transmit (the next section describes Telnet protocol <a class="indexterm" id="idx-CHP-87-3160"/>commands). This is similar to how people using walkie-talkies end each transmission with "Over," to tell their partners that they may now respond.</p><p>Of course, modern networks operate in a full-duplex mode, and using half-duplex communication would be needlessly inefficient. In most cases, the Telnet client and server agree to use an option (Suppress Go Ahead) that eliminates the need to send this command. However, having this as the default is a good example of how NVT acts as a least common denominator in Telnet, in case the simpler operating mode is needed by either device.</p></div></div><div class="sect2" title="Telnet Protocol Commands"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_protocol_commands"/>Telnet Protocol Commands</h2></div></div></div><p>Most of the input that users enter at a terminal takes the form of data and commands that are sent to the application program they are using. However, computer systems also provide a means by which users can instruct the terminal to send certain commands that control how the terminal itself operates, and how it interacts with the computer to which it is connected. The best example of this is the command to interrupt a process, which is usually sent by pressing a special key or key combination on the user terminal.</p><p>Telnet needs to have a way to allow such commands to be entered by the user. However, here we run into the same problem that arises in the communication of data between terminals and computers: a lack of uniformity in representation. While all terminals and computers support the ability to interrupt a running program, for example, they may each use a different keystroke to invoke it. For example, on most UNIX systems, the key combination ctrl-C interrupts a program, but typing this on a Windows system will not (it usually represents the copy data function!).</p><p>Since the problem is the same as the one we ran into in representing data flow, it's not too surprising that the solution is the same: the use of a universal representation for a set of standard commands to be passed between the terminal and host computer. All keystrokes that represent these commands are translated to the standard Telnet codes for transmission, and then translated to the specific needs of the host computer. So, if a user presses ctrl-C on a UNIX terminal where this is defined as the interrupt function, instead of sending that exact keystroke, the Telnet client sends the special Telnet Interrupt Process command, which is translated by the Telnet server to the command code appropriate for the connected host.</p><p>The Telnet standard includes a number of these special codes to allow a user to control the operation of the remote computer. It also defines a set of commands that are specific to the Telnet Protocol itself; these let the Telnet client and Telnet server software communicate. Collectively, these are called Telnet <span class="emphasis"><em>protocol commands</em></span>.</p><p>All Telnet commands are sent in the same communication stream as regular data. They are represented using special byte values in the range from 240 to 254. To differentiate between data bytes of these values and Telnet commands, every command is preceded by a special <span class="emphasis"><em>escape character</em></span>, given the name <span class="emphasis"><em>Interpret As Command (IAC)</em></span><a class="indexterm" id="idx-CHP-87-3161"/>. IAC has a value of 255; when the recipient sees this character, it knows the next byte is a command, not data. So, since the Telnet Interrupt Process command has the value 244, to send this command, the Telnet client would transmit the byte 255 and then 244. If the actual data byte value 255 needs to be sent, it is transmitted as two 255 bytes. Some Telnet commands also include additional bytes of data, which are sent after the command code itself. A good example is the use of parameters in Telnet option negotiation, as you will see in the "Telnet Options and Option Negotiation" section later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-526"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The Telnet Protocol defines a set of <span class="emphasis"><em>protocol commands</em></span> that are used for two purposes: first, to represent standard control functions that need to be sent between a terminal and host, such as the command to interrupt a process, and second, to enable protocol communication between the Telnet client and server software. Protocol commands are sent in the normal data communication stream over the Telnet session's TCP connection. Each is represented by a byte value from 240 to 254, and is preceded by the <a class="indexterm" id="idx-CHP-87-3162"/>Interpret As Command (IAC) command, byte value 255, which tells the recipient that the next byte in the stream is a command.</p></div><p>You may be wondering at this point why the IAC character is needed at all. After all, Telnet uses US-ASCII, which is 7-bit data in the byte range of 0 to 127, and the Telnet commands have values higher than 127. One general rationale for using the IAC escape character is to be explicit that a command is being sent. A more specific reason is to accommodate the optional sending of 8-bit binary data over Telnet, which the client and server can negotiate. If this mode were enabled and commands were not preceded by the IAC character, this would require all data bytes with values from 240 to 255 to be marked somehow so they would be interpreted as data and not commands. It is more efficient to include an extra byte for commands than data, since commands are sent less frequently. By escaping commands, only data byte value 255 requires two bytes to be sent.</p><p><a class="xref" href="ch87.html#telnet_protocol_commands-id001" title="Table 87-2. Telnet Protocol Commands">Table 87-2</a> lists the <a class="indexterm" id="idx-CHP-87-3163"/>Telnet protocol commands in numerical byte value order, showing for each its command code and name, and describing its meaning and use.</p><div class="table"><a id="telnet_protocol_commands-id001"/><p class="title">Table 87-2. Telnet Protocol Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Telnet Protocol Commands"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Byte Value (Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>240</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnegotiation End</p></td><td style="border-bottom: 0.5pt solid ; "><p>Marks the end of a Telnet option subnegotiation, used with the SB code to specify more specific option parameters. See the "Telnet Options and Option Negotiation" section later in this chapter for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>241</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NOP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Operation</p></td><td style="border-bottom: 0.5pt solid ; "><p>Null command; does nothing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>242</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DM</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data Mark</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to mark the end of a sequence of data that the recipient should scan for urgent Telnet <a class="indexterm" id="idx-CHP-87-3164"/>commands. See the discussion of Telnet interrupt handling in the following section for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>243</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BRK</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Break</p></td><td style="border-bottom: 0.5pt solid ; "><p>Represents the pressing of the "break" or "attention" key on the terminal.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>244</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Interrupt Process</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the recipient to interrupt, abort, suspend, or terminate the process currently in use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>245</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Abort Output</p></td><td style="border-bottom: 0.5pt solid ; "><p>Instructs the remote host to continue running the current process but discard all remaining output from it. This may be needed if a program starts to send unexpectedly large amounts of data to the user.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>246</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AYT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Are You There</p></td><td style="border-bottom: 0.5pt solid ; "><p>May be used to check that the remote host is still "alive." When this character is sent, the remote host returns some type of output to indicate that it is still functioning.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>247</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EC</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Erase Character</p></td><td style="border-bottom: 0.5pt solid ; "><p>Instructs the recipient to delete the last undeleted character from the data stream. Used to undo the sending of a character.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>248</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Erase Line</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the recipient to delete all characters from the data stream back to (but not including) the last end-of-line (CRLF) sequence.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>249</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>GA</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Go Ahead</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used in Telnet half-duplex mode to signal the other device that it may transmit.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>250</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SB</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnegotiation</p></td><td style="border-bottom: 0.5pt solid ; "><p>Marks the beginning of a Telnet option subnegotiation, used when an option requires the client and server to exchange parameters. See the "Telnet Options and Option Negotiation" section later in this chapter for a full description.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>251</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>WILL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Will Perform</p></td><td style="border-bottom: 0.5pt solid ; "><p>In Telnet option negotiation, indicates that the device sending this code is willing to perform or continue performing a particular option.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>252</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>WONT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Won't Perform</p></td><td style="border-bottom: 0.5pt solid ; "><p>In Telnet option negotiation, indicates that the device sending this code is either not willing to perform a particular option or is now refusing to continue to perform it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>253</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Do Perform</p></td><td style="border-bottom: 0.5pt solid ; "><p>In Telnet option negotiation, requests that the other device perform a particular option or confirms the expectation that the other device will perform that option.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DONT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Don't Perform</p></td><td style="border-bottom: 0.5pt solid ; "><p>In Telnet option negotiation, specifies that the other party not perform an option or confirms a device's expectation that the other party not perform an option.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>255</p></td><td style="border-right: 0.5pt solid ; "><p>IAC</p></td><td style="border-right: 0.5pt solid ; "><p>Interpret As Command</p></td><td style=""><p>Precedes command values 240 through 254 as described in the preceding descriptions. A pair of IAC bytes in a row represents the data value 255.</p></td></tr></tbody></table></div></div><p>Perhaps ironically, the <a class="indexterm" id="idx-CHP-87-3165"/>Telnet commands are not used as much today as they were when Telnet was in its early days, because many of the compatibility issues that we discussed earlier no longer exist. ASCII has become the standard character set of the computing world, so many of the functions such as aborting output or interrupting a process no longer require the use of Telnet commands. They are still widely used, however, for internal Telnet operations such as option negotiation.</p></div><div class="sect2" title="Telnet Interrupt Handling"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_interrupt_handling"/>Telnet Interrupt Handling</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3166"/>All the bytes of data sent from a Telnet client to a server are received in the order that they were sent, and vice versa. This is the way that we expect an application to operate. In fact, ensuring that data is not received out of order is one of the jobs that we assume of the reliable transport protocol <a class="indexterm" id="idx-CHP-87-3167"/>TCP, over which Telnet runs. However, this can cause a problem for Telnet because of the way Telnet sends both data and commands over the same connection.</p><p>The most important case where this issue arises is when a user needs to interrupt a process. Suppose that you are using Telnet to run an interactive program that takes user input, processes it, and then produces output. You are merrily typing away when you notice that you haven't seen any output from the program for a while. It has apparently hung up due to a programming error or other glitch.</p><p>If you were using the program on a directly connected terminal, you would simply use the key or keystroke command appropriate to that terminal to interrupt or abort the process and restart it. Instead, you are using Telnet, so you enter the appropriate keystroke, which gets converted to the special <a class="indexterm" id="idx-CHP-87-3168"/>Telnet Interrupt Process command code (byte value 244, preceded by the Telnet Interpret As Command code, 255).</p><p>Since Telnet uses only a single stream for commands and data, that code is placed into the TCP data stream to be sent over to the Telnet server. Since you were entering data for a while, that Telnet Interrupt Process code will be sitting behind a bunch of regular data bytes. Now the remote process has stopped reading this data, which means the TCP receive buffer on the server will start to fill up. The Interrupt Process command will thus remain stuck in the buffer, waiting to be read. In fact, if the number of data bytes in front of the command is high enough, the TCP buffer on the server may fill entirely, causing the server to close the client's TCP send window. This means the Interrupt Process command will wait in the client's outgoing TCP queue and <span class="emphasis"><em>never</em></span> be sent to the remote host!</p><p>What we need here is some way to be able to flag the Interrupt Process command, so that it can be sent to the remote host regardless of the number of data bytes outstanding in front of it. If you've already perused the chapters devoted to TCP, you may be thinking that you have already read about a feature of that protocol that seems ideally suited for this exact problem, and you would be correct! The TCP urgent function (described in <a class="xref" href="ch48.html" title="Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER">Chapter 48</a>) allows an important piece of data to be marked so that it is given priority over regular data, a process sometimes called <span class="emphasis"><em>out-of-band signaling</em></span> (because the signal is outside the normal data stream). Telnet uses this feature of TCP to define what it calls the <span class="emphasis"><em>synch function</em></span>.</p><p>When needed, the synch function is invoked by the client sending the special Telnet Data Mark (DM) protocol command, while instructing its TCP layer to mark that data as urgent. The URG bit in the TCP segment carrying this command causes it to bypass TCP's normal flow control mechanism so it is sent over to the remote host. The Telnet server software, seeing the synch in the data stream, searches through all of the data in its buffer looking only for Telnet control commands such as Interrupt Process, Abort Output, and Are You There. These commands are then executed immediately. The server continues to search for important commands up to the point where the Data Mark command is seen. All intervening data is discarded; it will need to be retransmitted. After the Data Mark is processed, the server returns to normal operation.</p><p>It is also possible for the server to use the synch function in communication with the user on the client device. For example, if the user sends the Abort Output command to the server, she is telling the server to discard all remaining output from the current process. The server will stop sending that output, and can also use the synch function to clear all outstanding data that is waiting in buffers to be sent to the client machine (since it causes data to be discarded).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-527"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Telnet protocol commands are sent in the same stream with user data, which means a problem with the remote host that stops the flow of data might cause user commands to become backed up and never received by the host. Since this may include commands issued by the user to try to fix the problem on the host, this can be a serious problem. To alleviate this situation, Telnet includes the <span class="emphasis"><em>synch function</em></span>, which uses TCP's urgent data transmission feature to force the receipt of essential commands, even when regular data is not being processed.</p></div></div><div class="sect2" title="Telnet Options and Option Negotiation"><div class="titlepage"><div><div><h2 class="title"><a id="telnet_options_and_option_negotiation"/>Telnet Options and Option Negotiation</h2></div></div></div><p>The basic Telnet NVT specification solves the problem of compatibility between different terminal and computer types by defining a common representation for data and commands that every Telnet client and server uses. The price for this universal representation, however, is very high: All of the advanced or special capabilities of terminals and hosts are stripped off. The result is a language that everyone can speak but that is not capable of much more than basic conversation.</p><p>The creators of Telnet recognized that, while it was important to define NVT as a common base to ensure cross-device compatibility, it was also essential that some means be provided by which clients and servers could agree to use more advanced means of communication. They defined a set of <span class="emphasis"><em>Telnet options</em></span> and a mechanism by which a Telnet client and server can <span class="emphasis"><em>negotiate</em></span> which options they want to use.</p><p>Most Telnet options are used for improving the efficiency of how data is transferred between devices. For example, by default, the NVT assumes half-duplex operation with each device, requiring it to use the Go Ahead command after each transmission. However, virtually all hardware now supports full-duplex communication, so devices will usually agree to use the Suppress Go Ahead option to eliminate the need to send this character. Similarly, it is possible for devices to negotiate the sending of 8-bit binary data instead of the standard 7-bit ASCII of the Telnet NVT.</p><p>The process of Telnet option negotiation is described in the main Telnet standard document, RFC 854, as well as a companion document, RFC 855, "Telnet Option Specifications." The options themselves are described in a separate set of Internet standards. Several of these were published at the same time as RFCs 854 and 855; others were defined earlier as part of previous versions of Telnet; and still others have been added over the years. There are now several dozen different Telnet <a class="indexterm" id="idx-CHP-87-3169"/>options in existence. A master list is maintained by Internet Assigned Numbers Authority (IANA), just as it maintains other TCP/IP parameters. An up-to-date listing of all Telnet <a class="indexterm" id="idx-CHP-87-3170"/>options can be found on the IANA website at <a class="ulink" href="http://www.iana.org/assignments/telnet-options/">http://www.iana.org/assignments/telnet-options/</a>.</p><div class="sect3" title="Common Telnet Options"><div class="titlepage"><div><div><h3 class="title"><a id="common_telnet_options"/>Common Telnet Options</h3></div></div></div><p>Each Telnet option is identified using a decimal byte code with a possible value of 0 to 254. The value 255 is reserved to extend the option list should more than 255 options ever be needed. Each option also has a text code string associated with it, which is often used as a symbol in place of the code number in both protocol discussions and diagnostic output. <a class="xref" href="ch87.html#common_telnet_options-id001" title="Table 87-3. Common Telnet Options">Table 87-3</a> lists some of the more interesting Telnet options and provides a brief description of each.</p><div class="table"><a id="common_telnet_options-id001"/><p class="title">Table 87-3. Common Telnet Options</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Telnet Options"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining RFC</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TRANSMIT-BINARY</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Binary Transmission</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices to send data in 8-bit binary form instead of 7-bit ASCII.</p></td><td style="border-bottom: 0.5pt solid ; "><p>856</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ECHO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices to negotiate any of a variety of different echo modes. (When you press a key on a terminal, you also expect to see the character you entered appear on the terminal screen as output; this is called echoing the input.)</p></td><td style="border-bottom: 0.5pt solid ; "><p>857</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SUPPRESS-GO-AHEAD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Suppress Go Ahead</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices not operating in half-duplex mode to no longer need to end transmissions using the Telnet Go Ahead command.</p></td><td style="border-bottom: 0.5pt solid ; "><p>858</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STATUS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Status</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lets a device request the status of a Telnet option.</p></td><td style="border-bottom: 0.5pt solid ; "><p>859</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TIMING-MARK</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Timing Mark</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices to negotiate the insertion of a special timing mark into the data stream, which is used for synchronization.</p></td><td style="border-bottom: 0.5pt solid ; "><p>860</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOCRD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Carriage Return Disposition</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lets the devices negotiate how carriage returns will be handled.</p></td><td style="border-bottom: 0.5pt solid ; "><p>652</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOHTS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Horizontal Tab Stops</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the devices to determine what horizontal tab stop positions will be used for output display.</p></td><td style="border-bottom: 0.5pt solid ; "><p>653</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOHTD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Horizontal Tab Stop Disposition</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the devices to negotiate how horizontal tabs will be handled and by which end of the connection.</p></td><td style="border-bottom: 0.5pt solid ; "><p>654</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOFFD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Form Feed Disposition</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the devices to negotiate how form feed characters will be handled.</p></td><td style="border-bottom: 0.5pt solid ; "><p>655</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOVTS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Vertical Tab Stops</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Used to determine what vertical tab stop positions will be used for output display.</p></td><td style="border-bottom: 0.5pt solid ; "><p>656</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOVTD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Vertical Tab Disposition</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lets devices negotiate the disposition of vertical tab stops.</p></td><td style="border-bottom: 0.5pt solid ; "><p>657</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAOLFD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Output Line Feed Disposition</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices to decide how line feed characters should be handled.</p></td><td style="border-bottom: 0.5pt solid ; "><p>658</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EXTEND-ASCII</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extended ASCII</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lets devices agree to use extended ASCII for transmissions and negotiate how it will be used.</p></td><td style="border-bottom: 0.5pt solid ; "><p>698</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TERMINAL-TYPE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Terminal Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the client and server to negotiate the use of a specific terminal type. If they agree, this allows the output from the server to be ideally customized to the needs of the particular terminal the user is using.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1091</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>31</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NAWS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Negotiate About Window Size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Permits communication of the size of the terminal window.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1073</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TERMINAL-SPEED</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Terminal Speed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows devices to report on the current terminal speed.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1079</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>33</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TOGGLE-FLOW-CONTROL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remote Flow Control</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows flow control between the client and the server to be enabled and disabled.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1372</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>34</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LINEMODE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Line Mode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the client to send data one line at a time instead of one character at a time. This improves performance by replacing a large number of tiny TCP transmissions with a smaller number of larger ones.</p></td><td style="border-bottom: 0.5pt solid ; "><p>1184</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>37</p></td><td style="border-right: 0.5pt solid ; "><p>AUTHENTICATION</p></td><td style="border-right: 0.5pt solid ; "><p>Authentication</p></td><td style="border-right: 0.5pt solid ; "><p>Lets the client and server negotiate a method of authentication to secure connections.</p></td><td style=""><p>1416</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-528"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The Telnet NVT specification ensures that all devices using Telnet can talk to each other, but accomplishes this communication at the lowest level. To allow the use of more sophisticated formats and services, Telnet defines a number of <span class="emphasis"><em>options</em></span>. If a client and server both implement a particular option, they can enable its use through a process of <a class="indexterm" id="idx-CHP-87-3171"/><span class="emphasis"><em>negotiation</em></span>.</p></div></div><div class="sect3" title="Telnet Option Negotiation"><div class="titlepage"><div><div><h3 class="title"><a id="telnet_option_negotiation"/>Telnet Option Negotiation</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3172"/>The first stage in Telnet option negotiation is for the client and server to decide whether they want to enable a particular option. One of the aspects of Telnet's symmetry of operation is that either device may choose to initiate the use of an option. The initiating device may either specify that it wants to start using an option or that it wants the other device to start using it. The responding device may agree or disagree. An option can be enabled only if both devices agree to its use.</p><p>This negotiation is performed using four Telnet protocol commands: WILL, WONT, DO, and DONT.</p><p>To specify that it wants to start using an option, the initiator sends the WILL command to the other device. There are two possible replies by the responding device:</p><p><span class="strong"><strong>DO</strong></span> Sent to indicate agreement that the initiator should use the option; it is then considered enabled.</p><p><span class="strong"><strong>DONT</strong></span> Sent to specify that the initiator must not use the option.</p><p>If the initiator wants the other device to start using an option, it sends the DO command. That device may respond in two ways:</p><p><span class="strong"><strong>WILL</strong></span> Sent to specify that the responding device will agree to use the option; the option is enabled.</p><p><span class="strong"><strong>WONT</strong></span> Sent to tell the initiator that the responder will not use the option requested.</p><p>The symmetry of Telnet and the fact that both DO and WILL can be used either to initiate a negotiation or respond to one make Telnet's option negotiation potentially complicated. Since either device can initiate negotiation of an option at any time, this could result in acknowledgment loops if both devices were to try to enable an option simultaneously or each kept responding to the other's replies. For this reason, the Telnet standard specifies restrictions on when the WILL and DO commands are used. One is that a device may send a negotiation command only to request a change in the status of an option; it cannot send DO or WILL just to confirm or reinforce the current state of the option. Another is that a device receiving a request to start using an option it is already using should not acknowledge it using DO or WILL.</p><p>Since an option may be activated only if both devices agree to use it, either may disable the use of an option at any time by sending one of these commands:</p><p><span class="strong"><strong>WONT</strong></span> Sent by a device to indicate that it is going to stop using an option. The other device must respond with DONT as a confirmation.</p><p><span class="strong"><strong>DONT</strong></span> Sent by a device to indicate that it wants the other device to stop using an option. The other device must respond with WONT.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-529"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Either device may choose to negotiate the use of a Telnet option. The initiator uses the WILL command to specify that it wants to start using a particular option; if the other device agrees, it responds with DO; otherwise, it sends DONT. Alternatively, the initiator can use the DO command to indicate that it wants the other device to start using an option; that device responds with WILL if it agrees to do so or WONT if it does not. Either device may disable the use of an option at any time by sending the other a WONT or DONT command.</p></div></div><div class="sect3" title="Option Subnegotiation"><div class="titlepage"><div><div><h3 class="title"><a id="option_subnegotiation"/>Option Subnegotiation</h3></div></div></div><p><a class="indexterm" id="idx-CHP-87-3173"/>All of the DO/DONT/WILL/WONT negotiation just described serves only to enable or disable an option. Some options, such as the binary transmission option (TRANSMIT-BINARY), are either only off or on; in which case, this option negotiation is sufficient. Other options require that after they are enabled, the client and server exchange parameters to control how the option works. For example, the TERMINAL-TYPE option requires some way for the client to send the server the name of the terminal. Telnet allows the client and server to send an arbitrary amount of data related to the option using a process called <span class="emphasis"><em>option subnegotiation</em></span>.</p><p>A device begins the subnegotiation <a class="indexterm" id="idx-CHP-87-3174"/>process by sending a special sequence of Telnet protocol commands and data. First, the device sends the SB (subnegotiation) command, followed by the option number and parameters as defined by the particular option, and then ending the subnegotiation data by sending the SE (subnegotiation end) command. Both SB and SE must be preceded by the Interpret As Command (IAC) command byte.</p><p>Let's take the terminal type negotiation as an example. Suppose the server supports this option and would like the client to use it. The server starts option negotiation by sending the DO command:</p><a id="I_programlisting1_d1e96154"/><pre class="programlisting">IAC DO TERMINAL-TYPE</pre><p>Assuming the client agrees, it will respond with the WILL command:</p><a id="I_programlisting1_d1e96158"/><pre class="programlisting">IAC WILL TERMINAL-TYPE</pre><p>Now the terminal type option is in effect, but the server still doesn't know which terminal the client is using. It can prompt the client to provide that information by sending this command:</p><a id="I_programlisting1_d1e96162"/><pre class="programlisting">IAC SB TERMINAL-TYPE SEND IAC SE</pre><p>The client receiving this option subnegotiation command will respond with the following:</p><a id="I_programlisting1_d1e96166"/><pre class="programlisting">IAC SB TERMINAL-TYPE IS &lt;<em class="replaceable"><code>some_terminal_type</code></em>&gt; IAC SE</pre><div class="tip" title="Tip"><h3 class="title"><a id="tip-530"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The WILL and DO commands only turn on a Telnet option that a client and server agree to use. In some cases, an option requires additional information to be sent between the client and server device for it to function properly. This is accomplished through a process of <span class="emphasis"><em>option subnegotiation</em></span>. Either device sends the other a set of data relevant to the option, bracketed by the SB (subnegotiation) and SE (subnegotiation end) Telnet protocol commands.</p></div></div></div></div></div>
<div class="sect1" title="Berkeley Remote (r) Commands"><div class="titlepage"><div><div><h1 class="title"><a id="berkeley_remote_r_commands"/>Berkeley Remote (r) Commands</h1></div></div></div><p><a class="indexterm" id="idx-CHP-87-3175"/>TCP/IP has achieved success in large part due to its universality—it has been implemented on virtually every major computing platform. While the suite is thus not specific to any operating system, there is no denying that its history is closely tied to a particular one—UNIX. Most of the computers on the early Internet used UNIX, and the development of TCP/IP has paralleled that of UNIX in a number of respects.</p><p>One of the most important organizations involved in the development of UNIX, and thus TCP/IP indirectly, was the University of California at Berkeley (UCB). The USB-developed well-known <span class="emphasis"><em>Berkeley Software Distribution (BSD)</em></span> UNIX has been in widespread use for over 20 years. They also developed a set of commands for BSD UNIX to facilitate various remote operation functions over a TCP/IP internetwork. Each of these programs begins with the letter <span class="emphasis"><em>r</em></span> (for remote), so they have come to be known as both the <span class="emphasis"><em>Berkeley remote commands</em></span> (or utilities) and also simply the <span class="emphasis"><em>r commands</em></span>. Since their initial creation, they have been adopted for most variations of UNIX and some other operating systems as well.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-531"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This section will probably make much more sense to those who have some understanding of the UNIX operating system than those who do not.</em></span>.</p></div><div class="sect2" title="Berkeley Remote Login (rlogin)"><div class="titlepage"><div><div><h2 class="title"><a id="berkeley_remote_login_rlogin"/>Berkeley Remote Login (rlogin)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3176"/>The head of the Berkeley remote protocol family is the remote login command, <a class="indexterm" id="idx-CHP-87-3177"/><code class="literal">rlogin</code>. As the name clearly implies, the purpose of this program is to allow a user on a UNIX host to log in to another host over a TCP/IP internetwork. Since Telnet is also often used for remote login, <code class="literal">rlogin</code> and Telnet are sometimes considered alternatives to each other for TCP/IP remote login. While they can be used in a similar way, they are quite different in a few respects.</p><p>From a conceptual standpoint, Telnet is designed as a protocol to enable terminal/host communication. As I mentioned in the Telnet overview earlier in this chapter, that protocol was not designed specifically for the purpose of remote login. In contrast, <code class="literal">rlogin</code> was intended for that specific purpose, and this is reflected in its operation.</p><p>The protocol requires <code class="literal">rlogin</code> server software to be running on the host that is going to allow remote access; it is usually called <code class="literal">rlogind</code> (for <code class="literal">rlogin</code> <span class="emphasis"><em>daemon</em></span>, the latter word being the standard UNIX term for a background server process). The server listens for incoming connection requests on TCP port 513. Users who want to remotely log in to the server run the <code class="literal">rlogin</code> command on their local host and specify the name of the server. The client makes a TCP connection to the server and then sends to the server a string containing the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The login name of the user on the client machine</p></li><li class="listitem"><p>The login name that the user wants to use on the server (which is often the same as the user's login name on the client, but not always)</p></li><li class="listitem"><p>Control information such as the type and speed of the terminal</p></li></ul></div><p>The server processes this information and begins the login process. It will normally prompt the user for a password to log in to the remote host. Assuming the password is correct, the user will be logged in to the remote host and can use it as if the user were locally connected.</p><p>From a practical standpoint, the <code class="literal">rlogin</code> command is much simpler than Telnet; it does not support Telnet's full command structure, nor capabilities such as option negotiation. It does include a small set of commands, however. The client is able to send to the server one key piece of information: the current size of the terminal window in use. The server is able to tell the client to turn on or off flow control, request that the client send it the current window size, or ask the client to flush pending output that the server has sent, up to a certain point in the data stream.</p><p>Some organizations have many different UNIX hosts that are used every day, and needing to constantly type passwords when using <code class="literal">rlogin</code> can be somewhat of a chore. On these systems, it is possible for administrators to set up control files that specify combinations of host names, user names, and passwords. If set up correctly, this enables an authorized user to use <code class="literal">rlogin</code> to remotely access a host automatically, without needing to enter either a login name or password.</p><p>As originally designed, <code class="literal">rlogin</code> is a classic example of a protocol from the early days of TCP/IP, since it emphasizes simplicity and usability over security. This is especially true of the automated login process just described. The original schemes used by <code class="literal">rlogin</code> for authentication are considered inadequate for modern TCP/IP internetworks, especially those connected to the Internet. Later versions of <code class="literal">rlogin</code> have been enhanced with more secure authorization methods. There is also a newer program called <a class="indexterm" id="idx-CHP-87-3178"/><code class="literal">slogin</code> (for <a class="indexterm" id="idx-CHP-87-3179"/><span class="emphasis"><em>secure login</em></span>) that uses stronger authentication and encryption, which is intended to replace <code class="literal">rlogin</code> on newer systems.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-532"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The Berkeley remote, or <span class="emphasis"><em>r</em></span>, commands facilitate remote operations between UNIX hosts on a TCP/IP internetwork. The base command of the family is the <span class="emphasis"><em>remote login</em></span> command, <code class="literal">rlogin</code>, which allows a device on one host to access and use another as if it were locally connected to it. rlogin is often used as an alternative to Telnet. It is simpler than Telnet, both conceptually and practically.</p></div></div><div class="sect2" title="Berkeley Remote Shell (rsh)"><div class="titlepage"><div><div><h2 class="title"><a id="berkeley_remote_shell_rsh"/>Berkeley Remote Shell (rsh)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3180"/>A user would normally use <code class="literal">rlogin</code> when he needs to log in to a server to perform a number of tasks. There are some situations, however, where a user needs to only enter one command on a remote host. With <code class="literal">rlogin</code>, the user would need to log in to the host, execute the command, and then log back out again. This isn't exactly an earth-shattering amount of inconvenience, especially when the correct configuration files are set up to allow automatic login. Over the course of time, however, all the extra logging in and out can become tedious. As a convenience, a variation of <code class="literal">rlogin</code>, called <a class="indexterm" id="idx-CHP-87-3181"/><code class="literal">rsh</code> (for <span class="emphasis"><em>remote shell</em></span>), allows a user to access a remote host and execute a single command on it without requiring the login and logout steps.</p><div class="note" title="Note"><h3 class="title"><a id="note-187"/>Note</h3><p>Shell <span class="emphasis"><em>is the standard term used in UNIX to refer to the user interface that accepts commands from the user and displays output on the screen</em></span>.</p></div><p>The <code class="literal">rsh</code> command is based on <code class="literal">rlogin</code> and works in much the same way, except that it is oriented around executing a command rather than establishing a persistent login session. The server process on the remote host is usually called <code class="literal">rshd</code> (for <span class="emphasis"><em>remote shell daemon</em></span>) and listens for incoming <code class="literal">rsh</code> requests. When one is received, the user is logged in through the same mechanism as <code class="literal">rlogin</code>. The command runs on the remote host, and then the user is automatically logged out.</p><p><code class="literal">rsh</code> is most useful when automatic login is employed, so that the program can be run without the need for the user to enter a login name or password. In that case, it is possible to have programs use <code class="literal">rsh</code> to automatically run commands on remote hosts without the need for human intervention, which opens up a number of possibilities for UNIX users. The normal UNIX user interface concepts of <span class="emphasis"><em>standard input (stdin), standard output (stdout), and standard error (stderr)</em></span> also apply to <code class="literal">rsh</code>, so you can use it to execute a remote command and redirect the output to a local file. For example, the following command would let a user get a listing of his home directory on the host server and store it in the local file named remotelist:</p><a id="I_programlisting1_d1e96382"/><pre class="programlisting">rsh &lt;<em class="replaceable"><code>somehost</code></em>&gt; ls -l &gt;remotelist</pre><div class="tip" title="Tip"><h3 class="title"><a id="tip-533"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <code class="literal">rsh</code> (remote shell) command is similar to the Berkeley <code class="literal">rlogin</code> command, but instead of opening a login session on a remote host, it executes a single, user-provided command. <code class="literal">rsh</code> can be helpful for users who need to perform a quick operation on a remote host, and it can also be employed by other programs to automate network tasks.</p></div><p>Since <code class="literal">rsh</code> is based on <code class="literal">rlogin</code>, all of the concerns that apply to <code class="literal">rlogin</code> are also relevant here, especially with regard to security. (We really don't want unauthorized users running commands on our servers!) As with <code class="literal">rlogin</code>, newer versions of <code class="literal">rsh</code> support more advanced authentication options than the original software. Also, just as <code class="literal">slogin</code> is a newer, more secure version of <code class="literal">rlogin</code>, there is a program called <a class="indexterm" id="idx-CHP-87-3182"/><code class="literal">ssh</code> (for <a class="indexterm" id="idx-CHP-87-3183"/><span class="emphasis"><em>secure shell</em></span>) that replaces <code class="literal">rsh</code> on many systems.</p><div class="note" title="Note"><h3 class="title"><a id="note-188"/>Note</h3><p><span class="emphasis"><em>On some systems, if</em></span> <code class="literal">rsh</code> <span class="emphasis"><em>is entered without a command specified to execute, an interactive remote session is established, exactly as if the</em></span> <code class="literal">rlogin</code> <span class="emphasis"><em>command had been entered instead of</em></span> <code class="literal">rsh</code>.</p></div></div><div class="sect2" title="Other Berkeley Remote Commands"><div class="titlepage"><div><div><h2 class="title"><a id="other_berkeley_remote_commands"/>Other Berkeley Remote Commands</h2></div></div></div><p>The <code class="literal">rlogin</code> and <code class="literal">rsh</code> commands are the generic members of the Berkeley <span class="emphasis"><em>r</em></span> family of programs that allow remote access to a host. To complement these, the developers also defined a small number of specific remote commands. These are essentially remote versions of some of the more common UNIX functions. Instead of the command being applied to only one system, however, it is used between two systems or across all systems on a TCP/IP network.</p><p>All of these commands are based on <code class="literal">rlogin</code> in the same way as <code class="literal">rsh</code> is. They work in the same way, but instead of opening a session or passing a user-specified command to the remote host, they execute a particular function. The following are the most common of these remote commands:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-87-3184"/>Remote Copy (<strong class="userinput"><code><a class="indexterm" id="idx-CHP-87-3185"/>rcp</code></strong>)</strong></span> This is the remote version of the UNIX copy (<code class="literal">cp</code>) command. It allows a file to be copied between the local host and the remote host or between two remote hosts. The usual syntax is basically the same as the regular <code class="literal">cp</code> command, but the source and/or destination is specified as being on a remote host. The <code class="literal">rcp</code> command can be used in a manner similar to FTP, but is much simpler and less capable. Or, to put it another way, <code class="literal">rcp</code> is to FTP what <code class="literal">rlogin</code> is to Telnet. (That's not a perfect analogy, but it's pretty close.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-87-3186"/>Remote Uptime (<strong class="userinput"><code><a class="indexterm" id="idx-CHP-87-3187"/>ruptime</code></strong>)</strong></span> The UNIX command <code class="literal">uptime</code> displays how long a computer has been running since it was last booted, along with information related to its current load. <code class="literal">ruptime</code> is the remote version of this command; it displays the current status of each machine on the network (up or down), how long each up machine has been up since its last boot, and its load statistics.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-87-3188"/>Remote Who (<strong class="userinput"><code><a class="indexterm" id="idx-CHP-87-3189"/>rwho</code></strong>)</strong></span> This is the remote version of the <code class="literal">who</code> command. Where <code class="literal">who</code> shows all the users logged on to the host where it is run, <code class="literal">rwho</code> shows all users logged on to all machines on the network.</p><p>The <code class="literal">ruptime</code> and <code class="literal">rwho</code> commands both rely on the presence of the <code class="literal">rwhod</code> (for <span class="emphasis"><em>remote who daemon</em></span>) running in the background on networked machines. These processes routinely share information with each other about host uptime and who is logged on to each system, so it can be quickly displayed when either <code class="literal">ruptime</code> or <code class="literal">rwho</code> is run.</p><p>On some operating systems, other remote commands may also be implemented. As with <code class="literal">rlogin</code> and <code class="literal">rsh</code>, security issues may apply to these commands, and there may be efficiency concerns with others (such as <code class="literal">rwho</code>). For these reasons, on many networks, these commands are no longer used.</p></div></div>
<div class="sect1" title="Internet Relay Chat Protocol (IRC)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_relay_chat_protocol_irc"/>Internet Relay Chat Protocol (IRC)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-87-3190"/>The primary advantage that electronic mail (email) offers over conventional mail is <span class="emphasis"><em>speed</em></span>. Instead of needing to wait for days or weeks for a message to be delivered, it usually arrives in minutes or even seconds. This makes email far more useful than the regular postal service for most types of information transfer. There are some cases, however, where speed of delivery is not sufficient to make email an ideal mechanism for communication. One such case is where a <span class="emphasis"><em>dialogue</em></span> is required between two parties.</p><p>Consider that even though email may be delivered very quickly, it uses a decoupled model of communication. Say that Ellen sends an email to Jane. The message may show up in Jane's inbox in a matter of seconds, but Jane may not be around to read it at the time it arrives. Jane might not see the message until hours later. Then Jane would send a response to Ellen, who might not see it for a while. If the subject they are discussing requires several dozen iterations of this sort, it could take a very long time before the exchange is completed.</p><p>In the real world, of course, most of us would never use email for such a conversation, preferring instead that high-tech communication device that we call the telephone. Many people using computers realized that it would be useful to have a way for two or more people to interactively discuss issues in a manner similar to a telephone conversation. In the online world, this is commonly called <span class="emphasis"><em>chatting</em></span>, and one of the first and most important application protocols designed to implement it in TCP/IP was the <span class="emphasis"><em>Internet Relay Chat (IRC) Protocol</em></span>.</p><p>Prior to the widespread use of the Internet, people with computers would often communicate by dialing in to a <a class="indexterm" id="idx-CHP-87-3191"/>bulletin board system (<a class="indexterm" id="idx-CHP-87-3192"/><span class="emphasis"><em>BBS)</em></span> or other proprietary service. IRC was originally created by a gentleman from Finland named Jarkko Oikarinen, based on his experience with chat applications on BBSes. He wrote the first client and server software in 1988. The protocol was later formally defined in RFC 1459, "Internet Relay Chat Protocol," published May 1993. In April 2000, the IRC standard was revised and enhanced with several new extended capabilities, and published as a set of four smaller documents: RFCs 2810 through 2813. Each of these focuses on one particular area of IRC functionality.</p><div class="note" title="Note"><h3 class="title"><a id="note-189"/>Note</h3><p><span class="emphasis"><em>RFC 1459 has the experimental RFC status, and the RFC 2810 to 2813 group is designated Informational. This makes IRC optional; it does not need to be implemented on TCP/IP devices</em></span>.</p></div><div class="sect2" title="IRC Communication Model and Client/Server Operation"><div class="titlepage"><div><div><h2 class="title"><a id="irc_communication_model_and_clientserver"/>IRC Communication Model and Client/Server Operation</h2></div></div></div><p>IRC is an interesting protocol in that it is not based strictly on the standard <a class="indexterm" id="idx-CHP-87-3193"/>client/server model of TCP/IP protocol operation. <span class="emphasis"><em>IRC servers</em></span> are TCP/IP machines that run IRC server software. They are configured with information that allows them to establish TCP connections to each other. IRC uses TCP because the connections are maintained over a long period of time, and reliable transport of data is required. Server connections are used to exchange control information and user data, forming a <a class="indexterm" id="idx-CHP-87-3194"/>logical <span class="emphasis"><em>IRC network</em></span> at the application level, which allows any server to send to any other server, using intermediate servers as conduits. Servers are managed by <span class="emphasis"><em>IRC operators (IRCops)</em></span> who have special privileges that allow them to ensure that everything runs smoothly on the network.</p><p>The IRC network forms the backbone of the IRC communication service. A user can access the network by running <span class="emphasis"><em>IRC client</em></span> software on any TCP/IP-enabled device. The user enters the name of one of the servers on the network and establishes a TCP connection to that server. This causes the user to be connected directly to one server, and thus, indirectly to all of the others on the network. This allows that user to send and receive messages to and from all other users connected either to the user's server or other servers.</p></div><div class="sect2" title="Messaging and IRC Channels"><div class="titlepage"><div><div><h2 class="title"><a id="messaging_and_irc_channels"/>Messaging and IRC Channels</h2></div></div></div><p><a class="indexterm" id="idx-CHP-87-3195"/><a class="indexterm" id="idx-CHP-87-3196"/>The most common type of communication in IRC is <span class="emphasis"><em>group messaging</em></span>, which is accomplished using <span class="emphasis"><em>IRC channels</em></span>. A channel is a virtual meeting place of sorts and is also sometimes called a <span class="emphasis"><em>chat room</em></span> (though IRC purists scoff at the use of that term). Every IRC network has hundreds or even thousands of different channels, each of which is dedicated to a particular type of discussion, ranging from the serious to the silly. For example, a group of people interested in talking about meteorology could establish a channel called #weather, where they would meet regularly to discuss various aspects of climatology and interesting weather events.</p><p>IRC is an inherently text-based protocol (though it is also possible to use IRC clients to transfer arbitrary files between users, including images and executable programs). To communicate in a channel, all a user needs to do is enter text in the appropriate spot in the IRC client program, and then the program automatically sends this text to every other member of the channel. The IRC network handles the relaying of these messages in real time from the sender's connected server to other servers in the network, and then to all user machines on those servers. When other users see the first user's message, they can reply with messages of their own, which will, in turn, be propagated across the network. Each IRC user chooses a <a class="indexterm" id="idx-CHP-87-3197"/>nickname (often abbreviated <span class="emphasis"><em>nick</em></span>) that is like a <span class="emphasis"><em>handle</em></span> used for communication while connected to the network.</p><p>IRC also supports one-to-one communication, which can be used for private conversation. To use this method, a user just needs the nickname of another user to whom she wants to talk. She uses a special command to send messages directly to that user, who can respond in kind. This is not a secure form of communication, since the messages are not encrypted, and they pass through servers where they could be monitored. However, there is so much traffic on a typical IRC network that any given message is unlikely to be monitored.</p><p>The IRC Protocol defines a rich command set that allows users to perform essential functions, such as joining or leaving a channel, changing nicknames, changing servers, setting operating modes for channels, and so forth. The exact command set and features available depend both on the specific software used for the user's IRC client and the features available on the IRC network itself. Not all IRC networks run the same version of the protocol.</p></div><div class="sect2" title="IRC and the Modern Internet"><div class="titlepage"><div><div><h2 class="title"><a id="irc_and_the_modern_internet"/>IRC and the Modern Internet</h2></div></div></div><p>IRC became very popular in the early 1990s because of the powerful way that it allows users from anywhere on the Internet to meet and share information dynamically. It acts like a text-based telephone, but users across the globe don't have the expense of long-distance calls.</p><p>One of the most important characteristics of IRC is its open-ended nature; it gives every person the freedom to communicate in whatever way he or she considers best. For example, every IRC channel has an owner, who has certain rights related to how the channel is used, including the ability to decide who should be allowed in the channel. This may seem autocratic, but IRC lets anyone start a new channel instantly and become that channel's owner, without the need for prior registration or authorization. This means that if you don't like how a particular channel is run, you can start your own with a minimum of fuss. You are not forced to adhere to anyone's rules, other than the rules set forth for the server (which are usually just intended to prevent abuse).</p><p>This same principle extends to the IRC networks themselves. There isn't just one single IRC network; there are dozens of different ones. Some are large, well-established networks that may have more than 100 servers and thousands of users; others are smaller and devoted to specific areas of interest or geographical regions. Anyone can set up their own IRC network if they have the hardware and software, and some organizations have set up private, dedicated IRC servers for their own use.</p><p>IRC is considered by many to be the most important ancestor of the related interactive applications collectively known as <span class="emphasis"><em>instant messaging</em></span>. These services are offered by several organizations, including America Online (AOL), Yahoo, and Microsoft's MSN. The idea behind them is very similar to that of IRC. Each allows a message sent by one user to be displayed immediately to another, though most are focused primarily on user-to-user messages rather than group messaging. Instant messaging has surpassed IRC in overall use, perhaps due to the large subscriber base of services like AOL. However, IRC is still widely used by thousands of enthusiasts on a daily basis for both entertainment and business purposes.</p></div></div>
<div class="chapter" title="Chapter&#xA0;88.&#xA0;TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_administration_and_troubleshooting"/>Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e96712"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>This final chapter on application protocols is a bit different from the previous ones. It doesn't describe applications designed for end users. Rather, it discusses a set of TCP/IP troubleshooting utilities <a class="indexterm" id="idx-CHP-88-3198"/>and protocols, which are normally the province of internetwork administrators. Even though millions of people use TCP/IP every day without even knowing that these applications exist—much less how they work—they are critically important to those who maintain TCP/IP internetworks. Since many of you are studying TCP/IP so that you can implement and administer this technology, understanding how these applications work is well worth your time.</p><p>In this chapter, I provide an overview of a number of software utilities that are commonly employed to help set up, configure, and maintain TCP/IP internetworks. These programs allow a network administrator to perform functions such as checking the identity of a host, verifying connectivity between two hosts, checking the path of routers between devices, examining the configuration of a computer, and looking up a Domain Name System (DNS) domain name.</p><p>The goal of this chapter is to provide explanations of the general purpose and function of troubleshooting utilities, so you will know how they can help you manage TCP/IP networks. As part of these descriptions, I demonstrate the typical syntax used to invoke each <a class="indexterm" id="idx-CHP-88-3199"/>utility in both UNIX and Windows. Due to variations in software implementations, you will need to consult your operating system documentation for the details on exactly how each program should be used on your network. On Windows systems, try <code class="literal">&lt;</code><em class="replaceable"><code>program</code></em><code class="literal">&gt; /?</code> to see the syntax of the program; on UNIX/Linux, try <code class="literal">man &lt;</code><em class="replaceable"><code>program</code></em><code class="literal">&gt;</code>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-534"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>Many of the software tools described in this section are designed to manage the operation of other TCP/IP protocols, such as the Internet Protocol (IP), the Domain Name System (DNS), and the Dynamic Host Configuration Protocol (DHCP). To fully appreciate how these utilities work, you need to understand the basics of these and other key TCP/IP protocols. In particular, a number of the utilities discussed here communicate use Internet Control Message Protocol (ICMP) messages, so I would recommend familiarity with ICMP (discussed in <a class="xref" href="pt09.html" title="Part II-6. IP SUPPORT PROTOCOLS">Part II-6</a>) before proceeding</em></span>.</p></div><div class="sect1" title="TCP/IP Host Name Utility (hostname)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_host_name_utility_hostname"/>TCP/IP Host Name Utility (hostname)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-88-3200"/>One of the most fundamental of tasks in diagnosing problems with a networked computer is identifying it. Just as the first thing we usually do when we meet someone is exchange names, one of the first actions an administrator takes when accessing a device is to determine its name, if it is not known. This is accomplished using the <code class="literal">hostname</code> utility.</p><p>You may recall from our discussion of TCP/IP name systems in <a class="xref" href="pt12.html" title="Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION">Part III-1</a> that there are two different ways that hosts can be named. The first way is to manually assign flat names to devices using host tables or equivalent means; this is most often used for devices that not going to be accessed on the public Internet. The second is to give a device a domain name within DNS. The <code class="literal">hostname</code> utility can be used for both types of named hosts, but it functions in a slightly different way for each.</p><p>On most systems, including Windows and many UNIX implementations, the <code class="literal">hostname</code> utility is very simple. When you enter the command by itself on a line with no arguments, it displays the full name of the host. If it is entered with the <code class="literal">-s</code> (short) parameter and the host name is a fully qualified DNS domain name, only the local label of the node is shown and not the full domain name; if the host has a flat (non-DNS) name, the <code class="literal">-s</code> parameter has no effect. Here is a simple example:</p><a id="I_programlisting2_d1e96785"/><pre class="programlisting">% hostname
fearn.pair.com
% hostname -s
fearn</pre><p>The <code class="literal">hostname</code> utility is also intended to allow an administrator to set the name of a host. The syntax for this is also simple; you just supply the name of the host as a parameter, as follows:</p><a id="I_programlisting2_d1e96792"/><pre class="programlisting">hostname &lt;<em class="replaceable"><code>new-hostname</code></em>&gt;</pre><p>However, in most implementations, the use of the <code class="literal">hostname</code> command for setting a device's name is either disabled or restricted. In Windows systems, a special applet in the Control Panel is used to set the device's name; attempting to set it using <code class="literal">hostname</code> will result in an error message. In UNIX, the superuser of the system can use <code class="literal">hostname</code> to set the device's name, but it is more common for this to be done by other means, such as editing the configuration file <a class="indexterm" id="idx-CHP-88-3201"/><code class="literal">/etc/hosts</code>. If a simple flat name is being assigned to this host, the administrator has full control over it. However, if DNS is used, then the proper procedures for registering the name must be followed.</p><div class="note" title="Note"><h3 class="title"><a id="note-190"/>Note</h3><p><span class="emphasis"><em>The</em></span> <code class="literal">hostname</code> <span class="emphasis"><em>utility is not, strictly speaking, tied into the operation of DNS or other formal mechanisms for identifying a host. It simply displays what the administrator has set it to show. It makes sense for this to be set to the host's DNS name, but there may be exceptions, such as in small networks that might not use DNS</em></span>.</p></div><p>In most operating systems, the <code class="literal">-s</code> parameter is the only one that this command supports. The parameter is not supported on all implementations of the <code class="literal">hostname</code> command, however. On some implementations, if you use <code class="literal">hostname -s</code>, the system may report its host name as being <span class="emphasis"><em>–s</em></span>. On certain Linux systems, the <code class="literal">hostname</code> utility includes a few additional parameters that allow different ways for the host name to be displayed, as well as some miscellaneous functions such as showing the version number of the program.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-535"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The simplest and most basic of TCP/IP administrative utilities is hostname, which returns the name of the host on which it is run.</p></div></div></div>
<div class="sect1" title="TCP/IP Communication Verification Utility (ping)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_communication_verification_utility"/>TCP/IP Communication Verification Utility (ping)</h1></div></div></div><p>One of the most common problems that network administrators are asked to solve is that two hosts are not able to communicate. For example, a user on a corporate network might not be able to retrieve one of his files from a local server, or another user might be having difficulty loading her favorite website. In these and similar situations, one important step in diagnosing the problem is to verify that basic communication is possible between the TCP/IP software stacks on the two machines. This is most often done using the <code class="literal">ping</code> utility, or <a class="indexterm" id="idx-CHP-88-3202"/><code class="literal">ping6</code> in Internet Protocol version 6 (IPv6) implementations. The IPv6 version of <code class="literal">ping</code> works in much the same way as IPv4 ping, but <code class="literal">ping6</code>'s options and parameters reflect the changes made in addressing and routing in IPv6.</p><div class="note" title="Note"><h3 class="title"><a id="note-191"/>Note</h3><p><span class="emphasis"><em>Some people say that</em></span> <code class="literal">ping</code> <a class="indexterm" id="idx-CHP-88-3203"/><span class="emphasis"><em>is an acronym for Packet Internet Groper, while others insist that it is actually based on the use of the term to refer to a sonar pulse sent by a submarine to check for nearby objects. I really don't know which of these is true, but I prefer the second explanation. Consider that the utility works in a way similar to a sonar ping, and that it was originally written by a gentleman named Mike Muuss, who worked at the United States Army Ballistics Research Laboratory</em></span><a class="indexterm" id="idx-CHP-88-3204"/>.</p></div><p><code class="literal">ping</code> is one of the most commonly used diagnostic utilities, and it is present in just about every TCP/IP implementation. It is usually implemented and accessed as a command-line utility, though there are also now graphical and menu-based versions of the program on some operating systems.</p><div class="sect2" title="Operation of the ping Utility"><div class="titlepage"><div><div><h2 class="title"><a id="operation_of_the_ping_utility"/>Operation of the ping Utility</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3205"/>The <code class="literal">ping</code> utility is implemented using Internet Control Message Protocol (ICMP) Echo (Request) and Echo Reply messages, which are designed specifically for this type of diagnostic <a class="indexterm" id="idx-CHP-88-3206"/>use. When Device A sends an ICMP Echo message to Device B, Device B responds by sending an ICMP Echo Reply message back to Device A. The same functionality exists in ICMPv6, the IPv6 version of ICMP; the ICMPv6 Echo and Echo Reply messages differ from the IPv4 ones only slightly in their field structure.</p><p>This would seem to indicate that <code class="literal">ping</code> would be an extremely simple utility that would send one Echo message and wait to see if an Echo Reply was received back. If so, this would mean that the two devices were able to communicate; if not, this would indicate a problem somewhere on the internetwork between the two. However, almost all <code class="literal">ping</code> implementations are much more complex than this. They use multiple sets of Echo and Echo Reply messages, along with considerable internal logic, to allow an administrator to determine all of the following, and more:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Whether or not the two devices can communicate</p></li><li class="listitem"><p>Whether congestion or other problems exist that might allow communication to succeed sometimes but cause it to fail in others, seen as packet loss; if so, how bad the loss is</p></li><li class="listitem"><p>How much time it takes to send a simple ICMP message between devices, which gives an indication of the overall latency between the hosts and also indicates if there are certain types of problems</p></li></ul></div></div><div class="sect2" title="Basic Use of ping"><div class="titlepage"><div><div><h2 class="title"><a id="basic_use_of_ping"/>Basic Use of ping</h2></div></div></div><p>The most basic use of the <code class="literal">ping</code> command is to enter it by itself with the IP address of a host. Virtually all implementations also allow you to use a host name, which will be resolved to an IP address automatically. When you invoke the utility with no additional options, it uses default values for parameters such as what size message to send, how many messages to be sent, how long to wait for a reply, and so on. The utility will transmit a series of Echo messages to the host and report back whether or not a reply was received for each. If a reply is seen, it will also indicate how long it took for the response to be received. When the program is finished, it will provide a statistical summary showing what percentage of the Echo messages received a reply and the average amount of time it took for them to be received.</p><div class="note" title="Note"><h3 class="title"><a id="note-192"/>Note</h3><p><span class="emphasis"><em>While the inability to get a response from a device to a</em></span> <code class="literal">ping</code> <span class="emphasis"><em>has traditionally been interpreted as a problem in communication, this is not always necessarily the case. In the current era of increased security consciousness, some networks are set up to not respond to Echo messages, to protect against attacks that use floods of such messages. In this case, a</em></span> <code class="literal">ping</code> <span class="emphasis"><em>will fail, even though the host may be quite reachable</em></span>.</p></div><p><a class="xref" href="ch88s02.html#verifying_communication_using_the_ping_u" title="Example 88-1. Verifying communication using the ping utility">Example 88-1</a> shows an example of using the <code class="literal">ping</code> command on a Windows XP computer (mine!), which, by default, sends four 32-byte Echo messages and allows four seconds before considering an Echo message lost. I use a satellite Internet connection that has fairly high latency and also occasionally drops packets. This isn't great for me, but it is useful for illustrating how <code class="literal">ping</code> works.</p><div class="example"><a id="verifying_communication_using_the_ping_u"/><p class="title">Example 88-1. Verifying communication using the ping utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;ping www.pcguide.com
Pinging pcguide.com [209.68.14.80] with 32 bytes of data:

Reply from 209.68.14.80: bytes=32 time=582ms TTL=56
Reply from 209.68.14.80: bytes=32 time=601ms TTL=56
Request timed out.
Reply from 209.68.14.80: bytes=32 time=583ms TTL=56

Ping statistics for 209.68.14.80:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 582ms, Maximum = 601ms, Average = 588ms</pre></div></div></div><div class="sect2" title="Methods of Diagnosing Connectivity Problems Using ping"><div class="titlepage"><div><div><h2 class="title"><a id="methods_of_diagnosing_connectivity_probl"/>Methods of Diagnosing Connectivity Problems Using ping</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3207"/>Most people find that using <code class="literal">ping</code> with default settings is enough for their needs. In fact, the utility can be <a class="indexterm" id="idx-CHP-88-3208"/>used in this simplest form to perform a surprising number of diagnostic checks. In many cases, you can use the <code class="literal">ping</code> command to diagnose connectivity problems by issuing it multiple times in sequence, often starting with checks at or close to the transmitting device and then proceeding outward toward the other device with which the communication problem has been observed. Here are some examples of how ping can be used in this way:</p><p><span class="strong"><strong>Internal Device TCP/IP Stack Operation</strong></span> By performing a <code class="literal">ping</code> on the device's own address, you can verify that its internal TCP/IP stack is working. This can also be done using the standard IP loopback address, 127.0.0.1.</p><p><span class="strong"><strong>Local Network Connectivity</strong></span> If the internal test succeeds, it's a good idea to do a <code class="literal">ping</code> on another device on the local network, to verify that local communication is possible.</p><p><span class="strong"><strong>Local Router Operation</strong></span> If there is no problem on the local network, it makes sense to <code class="literal">ping</code> whatever local router the device is using to make sure it is operating and reachable.</p><p><span class="strong"><strong>Domain Name Resolution Functionality</strong></span> If a <code class="literal">ping</code> performed on a DNS domain name fails, you should try it with the device's IP address instead. If that works, this implies either a problem with domain name configuration or resolution.</p><p><span class="strong"><strong>Remote Host Operation</strong></span> If all the preceding checks succeed, you can try performing a <code class="literal">ping</code> to a remote host to see if it responds. If it does not, you can try a different remote host. If that one works, it is possible that the problem is actually with the first remote device itself and not with your local device.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-536"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The TCP/IP ping utility is used to verify the ability of two devices on a TCP/IP internetwork to communicate. It operates by having one device send ICMP Echo (Request) messages to another, which responds with Echo Reply messages. The program can be helpful in diagnosing a number of connectivity issues, especially if it is used to test the ability to communicate with other devices in different locations. It also allows the average round-trip delay to exchange messages with another device to be estimated.</p></div></div><div class="sect2" title="ping Options and Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ping_options_and_parameters"/>ping Options and Parameters</h2></div></div></div><p>In addition to the basic uses described in the previous sections, all <code class="literal">ping</code> implementations include a number of <a class="indexterm" id="idx-CHP-88-3209"/>options and parameters that allow an administrator to fine-tune how it works. They allow ping to be used for more extensive or specific types of testing. For example, <code class="literal">ping</code> can be set in a mode where it sends Echo messages continually, to check for an intermittent problem over a long period of time. You can also increase the size of the messages sent or the frequency with which they are transmitted, to test the ability of the local network to handle large amounts of traffic.</p><p>As with the other utilities described in this chapter, the exact features of the <code class="literal">ping</code> program are implementation-dependent. Even though UNIX and Windows systems often include many of the same options, they usually use completely different option codes. <a class="xref" href="ch88s02.html#common_unix_ping_utility_options_and_par" title="Table 88-1. Common UNIX ping Utility Options and Parameters">Table 88-1</a> shows some of the more important options that are often defined for the utility on many UNIX systems, and where appropriate, the parameters supplied with the option. <a class="xref" href="ch88s02.html#common_windows_ping_utility_options_and_" title="Table 88-2. Common Windows ping Utility Options and Parameters">Table 88-2</a> shows <code class="literal">ping</code> options for a typical Windows system.</p><div class="table"><a id="common_unix_ping_utility_options_and_par"/><p class="title">Table 88-1. Common UNIX ping Utility Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common UNIX ping Utility Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-c &lt;</code><em class="replaceable"><code>count</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the number of Echo messages that should be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-f</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Flood mode; sends Echo packets at high speed to stress test a network. This can cause serious problems if not used carefully!</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-i &lt;</code><em class="replaceable"><code>wait-interval</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the utility how long to wait between transmissions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-m &lt;</code><em class="replaceable"><code>ttl-value</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Overrides the default Time to Live (TTL) value for outgoing Echo messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-n</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Numeric output only; suppresses lookups of DNS host names to save time.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-p &lt;</code><em class="replaceable"><code>pattern</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a byte pattern to be specified for inclusion in the transmitted Echo messages. This can be useful for diagnosing certain odd problems that may occur only with certain types of transmissions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-q</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Quiet output; only summary lines are displayed at the start and end of the program's execution, while the lines for each individual message are suppressed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-R</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the utility to include the Record Route IP option, so the route taken by the ICMP Echo message can be displayed. This option is not supported by all implementations. Using the <a class="indexterm" id="idx-CHP-88-3210"/><code class="literal">traceroute</code> utility (described in the next section) is usually a better idea.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-s &lt;</code><em class="replaceable"><code>packet-size</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the size of outgoing message to use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-S &lt;</code><em class="replaceable"><code>src-addr</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>On devices that have multiple IP interfaces (addresses), allows a <code class="literal">ping</code> sent from one interface to use an address from one of the others.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-t &lt;</code><em class="replaceable"><code>timeout</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Specifies a timeout period, in seconds, after which the <code class="literal">ping</code> utility will terminate, regardless of how many requests or replies have been sent or received.</p></td></tr></tbody></table></div></div><div class="table"><a id="common_windows_ping_utility_options_and_"/><p class="title">Table 88-2. Common Windows ping Utility Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Windows ping Utility Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-a</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>If the target device is specified as an IP address, forces the address to be resolved to a DNS host name and displayed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-f</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the Don't Fragment bit in the outgoing datagram.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-i &lt;</code><em class="replaceable"><code>ttl-value</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the Time to Live (TTL) value to be used for outgoing Echo messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-j &lt;</code><em class="replaceable"><code>host-list</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends the outgoing messages using the specified loose source route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-k &lt;</code><em class="replaceable"><code>host-list</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends the outgoing messages using the indicated strict source route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-l &lt;</code><em class="replaceable"><code>buffer-size</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the size of the data field in the transmitted Echo messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-n &lt;</code><em class="replaceable"><code>count</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the utility how many Echo messages to send.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-r &lt;</code><em class="replaceable"><code>count</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the use of the Record Route IP option and the number of hops to be recorded. It's usually preferable to use the <code class="literal">traceroute</code> utility (described in the next section).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-s &lt;</code><em class="replaceable"><code>count</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the use of the IP Timestamp option to record the arrival time of the Echo and Echo Reply messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-t</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends Echo messages continuously until the program is interrupted.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-w &lt;</code><em class="replaceable"><code>timeout</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Specifies how long the program should wait for each Echo Reply before giving up, in milliseconds (default is 4,000, for 4 seconds).</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="TCP/IP Route Tracing Utility (traceroute)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_route_tracing_utility_traceroute"/>TCP/IP Route Tracing Utility (traceroute)</h1></div></div></div><p>The <code class="literal">ping</code> utility is extremely helpful for checking whether two devices are able to communicate with each other. However, it provides very little information regarding what is going on between those two devices. In the event that <code class="literal">ping</code> shows either a total inability to communicate or intermittent connectivity with high loss of transmitted data, administrators need to know more about what is happening to IP datagrams as they are carried across the internetwork. This is especially important when the two devices are far from each other, especially if you are trying to reach a server on the public Internet.</p><p>I described in my overview of IP datagram delivery that when two devices are not on the same network, data sent between them must be delivered from one network to the next until it reaches its destination. This means that any time data is sent from Device A on one network to Device B on another, it follows a route, which may not be the same for each transmission. When communication problems arise, it is very useful to be able to check the specific route taken by data between two devices. A special route tracing utility is provided for this function, called <code class="literal">traceroute</code> (abbreviated <a class="indexterm" id="idx-CHP-88-3211"/><code class="literal">tracert</code> in Windows systems, a legacy of the old eight-character limit for DOS program names).</p><p>The IPv6 equivalent of this program is called <code class="literal">traceroute6</code>, which functions in a very similar manner to its IPv4 predecessor. It obviously uses IPv6 datagrams instead of IPv4 ones, and responses from traced devices are in the form of ICMPv6 Time Exceeded and Destination Unreachable messages rather than their ICMPv4 counterparts.</p><div class="sect2" title="Operation of the traceroute Utility"><div class="titlepage"><div><div><h2 class="title"><a id="operation_of_the_traceroute_utility"/>Operation of the traceroute Utility</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3212"/>Like the <code class="literal">ping</code> utility, <code class="literal">traceroute</code> is implemented using ICMP messages. However, unlike <code class="literal">ping</code>, <code class="literal">traceroute</code> was not originally designed to use a special ICMP message type intended exclusively for route tracing. Instead, it makes clever use of the IP and ICMP features that are designed to prevent routing problems.</p><p>Recall that the IP datagram format includes a Time to Live (TTL) field. This field is set to the maximum number of times that a datagram may be forwarded before it must be discarded; it exists to prevent datagrams from circling an internetwork endlessly. If a datagram must be discarded due to expiration of the TTL field, the device that discards it is supposed to send an ICMP Time Exceeded message back to the device that sent the discarded datagram. (This is explained in detail in <a class="xref" href="ch32.html" title="Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS">Chapter 32</a>.) Under normal circumstances, this occurs only when there is a problem, such as a router loop or another misconfiguration issue. What <code class="literal">traceroute</code> does is to force each router in a route to report back to it by intentionally setting the TTL value in test datagrams to a value too low to allow them to reach their destination.</p><p>Suppose you have Device A and Device B, which are separated by Routers R1 and R2—three hops total (A to R1, R1 to R2 and R2 to B). If you do a <code class="literal">traceroute</code> from Device A to Device B, here's what happens (see <a class="xref" href="ch88s03.html#operation_of_the_traceroutetracert_utili" title="Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility identifies the devices in a route by forcing them to report back failures to route datagrams with parameters intentionally set to invalid values. The first message sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The second message has a TTL value of 2, so it will be dropped and reported by Router R2. The third message will pass both routers and get to the destination host, Device B, but since the message is deliberately chosen with a bogus port number, this will cause an ICMP Destination Unreachable message to be returned. These error messages identify the sequence of devices in the route between Devices A and B.">Figure 88-1</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The <code class="literal">traceroute</code> utility sends a dummy User Datagram Protocol (UDP) message (sometimes called a <span class="emphasis"><em>probe</em></span>) to a port number that is intentionally selected to be invalid. The TTL field of the IP datagram is set to 1. When Router R1 receives the message, it decrements the field, which will make its value 0. That router discards the probe and sends an ICMP Time Exceeded message back to Device A.</p></li><li class="listitem"><p>Device A sends a second UDP message with the TTL field set to 2. This time, Router R1 reduces the TTL value to 1 and sends it to Router R2, which reduces the TTL field to 0 and sends a Time Exceeded message back to Device A.</p></li><li class="listitem"><p>Device A sends a third UDP message, with the TTL field set to 3. This time, the message will pass through both routers and be received by Device B. However, since the port number was invalid, the message is rejected by Device B, which sends back a Destination Unreachable message to Device A.</p></li></ol></div><p>So Device A sends out three messages to Device B, and it gets back three error messages and is happy about it! The route to Device B is thus indicated by the identities of the devices sending back the error messages, in sequence. By keeping track of the time between when it sent each UDP message and received back the corresponding error message, the <code class="literal">traceroute</code> utility can also display how long it took to communicate with each device. In practice, usually three dummy messages are sent with each TTL value, so their transit times can be averaged by the user if desired.</p><div class="note" title="Note"><h3 class="title"><a id="note-193"/>Note</h3><p><span class="emphasis"><em>Not all</em></span> <code class="literal">traceroute</code> <span class="emphasis"><em>utility implementations use the technique described here. Microsoft's</em></span> <code class="literal">tracert</code> <span class="emphasis"><em>works by sending ICMP Echo messages with increasing TTL values, rather than UDP packets. It knows it has reached the final host when it gets back an Echo Reply message. A special ICMP Traceroute message was also developed in 1993, which was intended to improve the efficiency of</em></span><a class="indexterm" id="idx-CHP-88-3213"/> <code class="literal">traceroute</code> <span class="emphasis"><em>by eliminating the need to send many UDP messages for each route tracing. Despite its technical advantages, since this message was introduced long after TCP/IP was widely deployed, it never became a formal Internet standard and its use is not seen as often as the traditional method</em></span>.</p></div><div class="figure"><a id="operation_of_the_traceroutetracert_utili"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e97446"/><img alt="Operation of the traceroute/tracert utility The traceroute utility identifies the devices in a route by forcing them to report back failures to route datagrams with parameters intentionally set to invalid values. The first message sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The second message has a TTL value of 2, so it will be dropped and reported by Router R2. The third message will pass both routers and get to the destination host, Device B, but since the message is deliberately chosen with a bogus port number, this will cause an ICMP Destination Unreachable message to be returned. These error messages identify the sequence of devices in the route between Devices A and B." src="httpatomoreillycomsourcenostarchimages288327.png.jpg"/></div></div><p class="title">Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility identifies the devices in a route by forcing them to report back failures to route datagrams with parameters intentionally set to invalid values. The first message sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The second message has a TTL value of 2, so it will be dropped and reported by Router R2. The third message will pass both routers and get to the destination host, Device B, but since the message is deliberately chosen with a bogus port number, this will cause an ICMP Destination Unreachable message to be returned. These error messages identify the sequence of devices in the route between Devices A and B.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-537"/>Tip</h3><p><a class="indexterm" id="idx-CHP-88-3214"/><a class="indexterm" id="idx-CHP-88-3215"/><span class="strong"><strong>KEY CONCEPT</strong></span> The <code class="literal">traceroute</code> utility takes the idea behind ping one step further, allowing administrators to not only check communication between two devices, but also letting them see a list of all the intermediate devices between the pair. It works by having the initiating host send a series of test datagrams with TTL values that <a class="indexterm" id="idx-CHP-88-3216"/>cause each to expire sequentially at each device on the route. The <code class="literal">traceroute</code> program also shows how much time it takes to communicate with each device between the sending host and a destination device.</p></div></div><div class="sect2" title="Basic Use of the traceroute Utility"><div class="titlepage"><div><div><h2 class="title"><a id="basic_use_of_the_traceroute_utility"/>Basic Use of the traceroute Utility</h2></div></div></div><p><a class="xref" href="ch88s03.html#route_tracing_using_the_traceroute_utili" title="Example 88-2. Route tracing using the traceroute utility">Example 88-2</a> shows an example of a <code class="literal">traceroute</code> sent between two of the UNIX computers I use on a regular basis. I added the <code class="literal">-q2</code> parameter to change the default of three dummy messages per hop to two, so the output would fit better on the page.</p><div class="example"><a id="route_tracing_using_the_traceroute_utili"/><p class="title">Example 88-2. Route tracing using the traceroute utility</p><div class="example-contents"><pre class="programlisting">traceroute -q2 www.pcguide.com
traceroute to www.pcguide.com (209.68.14.80), 40 hops max, 40 byte packets
 1  cisco0fe0-0-1.bf.sover.net (209.198.87.10)  1.223 ms  1.143 ms
 2  cisco1fe0.bf.sover.net (209.198.87.12)  1.265 ms  1.117 ms
 3  cisco0a5-0-102.wnskvtao.sover.net (216.114.153.170)  8.004 ms  7.270 ms
 4  207.136.212.234 (207.136.212.234)  7.163 ms  7.601 ms
 5  sl-gw18-nyc-2-0.sprintlink.net (144.232.228.145)  15.948 ms  20.931 ms
 6  sl-bb21-nyc-12-1.sprintlink.net (144.232.13.162)  21.578 ms  16.324 ms
 7  sl-bb27-pen-12-0.sprintlink.net (144.232.20.97)  18.296 ms  *
 8  sl-bb24-pen-15-0.sprintlink.net (144.232.16.81)  18.041 ms  18.338 ms
 9  sl-bb26-rly-0-0.sprintlink.net (144.232.20.111)  20.259 ms  21.648 ms
10  sl-bb20-rly-12-0.sprintlink.net (144.232.7.249)  132.302 ms  37.825 ms
11  sl-gw9-rly-8-0.sprintlink.net (144.232.14.22)  23.085 ms  20.082 ms
12  sl-exped4-1-0.sprintlink.net (144.232.248.126)  43.374 ms  42.274 ms
13  * *
14  pcguide.com (209.68.14.80)  41.310 ms  49.455 ms</pre></div></div><p>In this case, the servers are separated by 14 hops. Notice how the elapsed time generally increases as the distance from the transmitting device increases, but it is not consistent because of random elements in the delay between any two devices (see the incongruously large value in hop 10, for example). Also notice the asterisk (*) in the seventh hop, which means that no response was received before the timeout period for the second transmission with a TTL value of 7. Finally, there is no report at all for hop 13. This machine may have been configured not to send Time Exceeded messages.</p><p>Additional unusual results may be displayed under certain circumstances. For example, the <code class="literal">traceroute</code> program may display a code such a <code class="literal">!H</code>, <code class="literal">!N</code>, or <code class="literal">!P</code> to indicate receipt of an unexpected Destination Unreachable message for a host, network, or protocol, respectively. Other error messages may also exist, depending on the implementation.</p></div><div class="sect2" title="traceroute Options and Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="traceroute_options_and_parameters"/>traceroute Options and Parameters</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3217"/>As is the case with <code class="literal">ping</code>, <code class="literal">traceroute</code> can be used with an IP address or host name. If no parameters are supplied, default values will be used for key parameters. On the system I use, the defaults are three probes for each TTL value, a maximum of 64 hops tested, and packets 40 bytes in size. However, my implementation also supports a number of options and parameters to give me more control over how the utility functions (such as the <code class="literal">-q</code> parameter I used in <a class="xref" href="ch88s03.html#route_tracing_using_the_traceroute_utili" title="Example 88-2. Route tracing using the traceroute utility">Example 88-2</a>). Some of the typical options available in UNIX systems are described in <a class="xref" href="ch88s03.html#common_unix_traceroute_utility_options_a" title="Table 88-3. Common UNIX traceroute Utility Options and Parameters">Table 88-3</a>. A smaller set of options exists in Windows, as shown in <a class="xref" href="ch88s03.html#common_windows_tracert_utility_options_a" title="Table 88-4. Common Windows tracert Utility Options and Parameters">Table 88-4</a>.</p><div class="table"><a id="common_unix_traceroute_utility_options_a"/><p class="title">Table 88-3. Common UNIX traceroute Utility Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common UNIX traceroute Utility Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-g &lt;</code><em class="replaceable"><code>host-list</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies a source route to be used for the trace.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-M &lt;</code><em class="replaceable"><code>initial-ttl-value</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Overrides the default value of 1 for the initial TTL value of the first outgoing probe message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-m &lt;</code><em class="replaceable"><code>max-ttl-value</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the maximum TTL value to be used. This limits how long a route the utility will attempt to trace.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-n</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the route using numeric addresses only, rather than showing both IP addresses and host names. This speeds up the display by saving the utility from needing to perform reverse DNS lookups on all the devices in the route (ICMP messages use IP addresses, not domain names).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-p &lt;</code><em class="replaceable"><code>port-number</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the port number to be used as the destination of the probe messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-q &lt;</code><em class="replaceable"><code>queries</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the utility how many probes to send to each device in the route (the default is 3).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-r</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the program to bypass the normal routing tables and send directly to a host on an attached network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-s &lt;</code><em class="replaceable"><code>src-addr</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>On devices that have multiple IP interfaces (addresses), allows the device to use an address from one interface on a <code class="literal">traceroute</code> using another interface.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-S</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Instructs the program to display a summary of how many probes did not receive a reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-v</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets verbose output mode, which informs the user of all ICMP messages received during the trace.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-w &lt;</code><em class="replaceable"><code>wait-time</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Specifies how long the utility should wait for a reply to each probe, in seconds (the typical default is 3 to 5).</p></td></tr></tbody></table></div></div><div class="table"><a id="common_windows_tracert_utility_options_a"/><p class="title">Table 88-4. Common Windows tracert Utility Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Windows tracert Utility Options and Parameters"><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></td><td style="border-bottom: 0.5pt solid ; "><p>Description</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-d</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the route using numeric addresses only, rather than showing both IP addresses and host names, for faster display. This is the same as the <code class="literal">-n</code> option on UNIX systems.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-h &lt;</code><em class="replaceable"><code>maximum-hops</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the maximum number of hops to use for tracing (the default is 30).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-j &lt;</code><em class="replaceable"><code>host-list</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends the outgoing probes using the specified loose source route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-w &lt;</code><em class="replaceable"><code>wait-time</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Specifies how long to wait for a reply to each probe, in milliseconds (the default is 4,000, for 4 seconds).</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="TCP/IP Address Resolution Protocol Utility (arp)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_address_resolution_protocol_utilit"/>TCP/IP Address Resolution Protocol Utility (arp)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-88-3218"/>All devices on an internetwork are considered to be virtually connected at layer 3, since the process of routing lets any device communicate with any other device. However, there is no way for devices on distant networks to communicate directly. The internetwork communication at layer 3 actually consists of a number of steps, called <span class="emphasis"><em>hops</em></span>, that carry the data from its source to destination. Each hop in a route requires that data be sent between a pair of hardware devices, and each transmission must use layer 2 hardware addresses. Since TCP/IP uses layer 3 addresses, this means each hop requires that we translate the IP address of the target of the hop to a hardware address. This is called <span class="emphasis"><em>address resolution</em></span>; the reasons why it is needed and the methods used for it are explained in detail in <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>.</p><p>In TCP/IP, address resolution functions are performed by the aptly named Address Resolution Protocol (<a class="indexterm" id="idx-CHP-88-3219"/>ARP). When a device needs to transmit to a device with a particular IP address, it can use ARP's request/reply messaging protocol to find out which hardware device corresponds to that IP address. However, each such message exchange takes time and network bandwidth, so for efficiency, every device maintains an ARP cache, which is a table containing mappings between IP and hardware addresses. The ARP cache table can contain a combination of static cache entries that are manually inserted for frequently accessed devices, and dynamic entries, which are entered automatically when a request/reply resolution is done. The next time it is necessary to send a device mapped in the ARP cache table, the lookup process can be avoided.</p><p>To allow administrators to manage this ARP cache table, TCP/IP devices include an <code class="literal">arp</code> utility. It has the following three basic functions, which are invoked using three different versions of the command (which, for once, are the same in UNIX and Windows):</p><p><span class="strong"><strong>ARP Cache Table Display</strong></span> When the <code class="literal">-a</code> option is used with the utility, it displays the current contents of the ARP cache table. The syntax is <code class="literal">arp -d &lt;</code><em class="replaceable"><code>host-name</code></em><code class="literal">&gt;</code>. Each entry in the table shows the IP address and hardware address pair for one device (interface, actually). Usually, it also indicates whether each entry is static or dynamic. The exact format of the display varies from one implementation to the next; some programs show IP addresses, others show host names, and still others may show both. Some systems default to displaying host names but allow the <code class="literal">-n</code> option to also be used to force only IP addresses (not names) to be displayed.</p><p><span class="strong"><strong>ARP Cache Table Entry Addition</strong></span> This version allows an administrator to make a new manual ARP cache table entry that maps the given host name to the specified hardware address. The syntax is <code class="literal">arp -s &lt;</code><em class="replaceable"><code>host-name</code></em><code class="literal">&gt; &lt;</code><em class="replaceable"><code>hw-addr</code></em><code class="literal">&gt;</code>.</p><p><span class="strong"><strong>ARP Cache Table Entry Deletion</strong></span> Using <code class="literal">arp</code> with the <code class="literal">-d</code> option removes the specified cache entry from the table. Some implementations allow the addition of another parameter to specify that all entries should be removed from the cache. The basic syntax is <code class="literal">arp -d &lt;</code><em class="replaceable"><code>host-name</code></em><code class="literal">&gt;</code>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-538"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The TCP/IP arp utility is used by an administrator to inspect or modify a host's ARP cache table, which contains mappings between TCP/IP host names and IP addresses.</p></div><p>Certain versions of the software may also supplement these basic commands with additional features. One common additional option on UNIX systems is the ability to specify a file from which cache table entries may be read, using the syntax <code class="literal">arp -f &lt;</code><em class="replaceable"><code>file-name</code></em><code class="literal">&gt;</code>. This saves a considerable amount of time and effort compared to typing each entry manually using <code class="literal">arp -s</code>.</p><p>Note also that the operating system may allow only authorized users to access options that cause the ARP cache table to be changed. This is especially true of the delete function.</p></div>
<div class="sect1" title="TCP/IP DNS Name Resolution and Lookup Utilities (nslookup, host, and dig)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_dns_name_resolution_and_lookup_uti"/>TCP/IP DNS Name Resolution and Lookup Utilities (nslookup, host, and dig)</h1></div></div></div><p>DNS is a critically important part of TCP/IP internetworks, especially the modern Internet, because it allows hosts to be accessed using easily remembered names rather than confusing numerical addresses. Two different primary types of devices are involved in the operation of DNS: DNS name servers that store information about domains and DNS resolvers that query DNS servers to transform names into addresses, as well as perform other necessary functions.</p><p>DNS resolvers are employed by Internet users on a continual basis to translate DNS names into address, but under normal circumstances, they are always invoked indirectly. Each time a user types a DNS name into a program such as a web browser or File Transfer Protocol (FTP) client—or even uses it in one of the other utilities described in this chapter, such as <code class="literal">ping</code> or <code class="literal">traceroute</code>—the resolver automatically performs the name resolution without the user having to ask. For this reason, there is no need for users to manually resolve DNS names into addresses.</p><p>However, administrators often do need to perform a DNS resolution manually. For example, when troubleshooting a problem, the administrator may know a host's name but not its address. In the case of a security problem, the address may show up in a log file but the host name may not be known. In addition, even though users do not need to know the specifics of the resource records that define a DNS domain, administrators often need to be able to check these details, to make sure a domain is set up properly. Administrators also need some way to be able to diagnose problems with DNS servers themselves. To support all of these needs, modern TCP/IP implementations come equipped with one or more DNS name resolution and information lookup utilities. Here, we will look at three such utilities: <code class="literal">nslookup</code>, <code class="literal">host</code>, and <code class="literal">dig</code>.</p><div class="sect2" title="The nslookup Utility"><div class="titlepage"><div><div><h2 class="title"><a id="the_nslookup_utility"/>The nslookup Utility</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3220"/>One of the most common DNS diagnostic utilities is <code class="literal">nslookup</code> (for name server lookup), which has been around for many years. The details of how the program is implemented depend on the operating system, though most of them offer versions that are quite similar in operation and settings. The utility can normally be used in two modes: interactive or noninteractive.</p><p>The noninteractive version of <code class="literal">nslookup</code> is the simplest, and it is most often used when an administrator wants to just quickly translate a name into an address or vice versa. To run this version, issue the <code class="literal">nslookup</code> command using the following simple syntax:</p><a id="I_programlisting2_d1e97866"/><pre class="programlisting">nslookup &lt;<em class="replaceable"><code>host</code></em> &gt; [&lt;<em class="replaceable"><code>server</code></em>&gt;]</pre><p>Here, <code class="literal">&lt;</code><em class="replaceable"><code>host</code></em><code class="literal">&gt;</code> can be a DNS domain name, for performing a normal resolution, or it may be an IP address, for a reverse resolution to return the associated DNS domain name. The <code class="literal">&lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;</code> parameter is optional; if it's omitted, the program uses the default name server of the host where the command was issued. <a class="xref" href="ch88s05.html#dns_name_resolution_using_the_nslookup_u" title="Example 88-3. DNS name resolution using the nslookup utility">Example 88-3</a> shows a simple example of noninteractive use of <code class="literal">nslookup</code>.</p><div class="example"><a id="dns_name_resolution_using_the_nslookup_u"/><p class="title">Example 88-3. DNS name resolution using the nslookup utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;nslookup www.pcguide.com
Server:  ns1-mar.starband.com
Address:  148.78.249.200

Non-authoritative answer:
Name:    pcguide.com
Address:  209.68.14.80
Aliases:  www.pcguide.com</pre></div></div><p>This example was done on my home PC that uses the Starband satellite Internet service, which is configured to use Starband's name server (<code class="literal">ns1-mar.starband.com</code>). The answer provided here is labeled <span class="emphasis"><em>non-authoritative</em></span>, because it came from the Starband name server's DNS cache, rather than one of the DNS name servers that is a DNS authority for <a class="ulink" href="http://www.pcguide.com">www.pcguide.com</a>.</p><div class="note" title="Note"><h3 class="title"><a id="note-194"/>Note</h3><p><span class="emphasis"><em>It is also possible to specify one or more options to modify the behavior of the lookup in noninteractive mode. These options are the same as the parameters controlled by the</em></span> <code class="literal">nslookup</code> <span class="emphasis"><em>set command described in <a class="xref" href="ch88s05.html#typical_nslookup_utility_commands" title="Table 88-5. Typical nslookup Utility Commands">Table 88-5</a>. They are specified by preceding them with a dash. For example</em></span>, <code class="literal">nslookup -timeout=10 www.pcguide.com</code> <span class="emphasis"><em>would perform the same lookup as in <a class="xref" href="ch88s05.html#dns_name_resolution_using_the_nslookup_u" title="Example 88-3. DNS name resolution using the nslookup utility">Example 88-3</a>, but with the timeout interval set to 10 seconds</em></span>.</p></div><p>The interactive mode of <code class="literal">nslookup</code> is selected by simply issuing the name of the command with no parameters. This will cause the program to display the current default name server's DNS name and address, and then provide a prompt at which the administrator may enter commands. Interactive mode allows someone to perform multiple lookups easily without having to type <code class="literal">nslookup</code> each time. More important, it provides more convenient control over the types of information that can be requested and how the lookups are performed.</p><p>You can usually determine the exact command set available in an <code class="literal">nslookup</code> implementation by issuing the command <code class="literal">help</code> or <code class="literal">?</code> at the <code class="literal">nslookup</code> prompt. <a class="xref" href="ch88s05.html#typical_nslookup_utility_commands" title="Table 88-5. Typical nslookup Utility Commands">Table 88-5</a> shows some of the commands that are usually found in most <code class="literal">nslookup</code> implementations.</p><div class="table"><a id="typical_nslookup_utility_commands"/><p class="title">Table 88-5. Typical nslookup Utility Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical nslookup Utility Commands"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-88-3221"/>Command and Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;</code><em class="replaceable"><code>host</code></em><code class="literal">&gt; [&lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Look up the specified host, optionally using the specified DNS name server. Note that there is no actual command here; you just enter the name directly at the command prompt.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">server &lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Change the default server to <code class="literal">&lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;</code>, using information obtained from the current default server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">lserver &lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Change the default server to <code class="literal">&lt;</code><em class="replaceable"><code>server</code></em><code class="literal">&gt;</code>, using information obtained from the initial name server; that is, the system's default server that was in place when the <code class="literal">nslookup</code> command was started (prior to any preceding changes of the current name server in this session).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">root</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Changes the default name server to one of the DNS root name servers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ls [-t &lt;</code><em class="replaceable"><code>type</code></em><code class="literal">&gt;] &lt;</code><em class="replaceable"><code>name</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests a list of information available for the specified domain name, by conducting a zone transfer. By default, the host names and addresses associated with the domain are listed; the <code class="literal">-t</code> option may be used to restrict the output to a particular record type. Other options may also be defined. (Most servers restrict the use of zone transfers to designated slave servers, so this command may not work for ordinary clients.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">help</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays help information (usually a list of valid commands and options).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as <code class="literal">help</code> (works on only some systems).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">set all</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the current value of all <code class="literal">nslookup</code> options.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">set &lt;</code><em class="replaceable"><code>option</code></em><code class="literal">&gt;[=&lt;</code><em class="replaceable"><code>value</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets an option to control the behavior of the utility. Most implementations include quite a number of options, some of which are controlled by just specifying a keyword, while others require a value for the option. For example, <code class="literal">set recurse</code> tells the program to use recursive resolution, while <code class="literal">set norecurse</code> turns it off. <code class="literal">set retry=3</code> sets the number of retries to 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">exit</code></p></td><td style=""><p>Quits the program.</p></td></tr></tbody></table></div></div><p>The <code class="literal">nslookup</code> utility is widely deployed on both UNIX and Windows systems, but the program is not without its critics. The complaints about it mainly center around its use of nonstandard methods of obtaining information, rather than standard resolution routines. I have also read reports that it can produce spurious results in some cases. One example of a significant problem with the command is that it will abort if it is unable to perform a reverse lookup of its own IP address. This can cause confusion, because users mistake that error for an error trying to find the name they were looking up. For this and other reasons, a number of people in UNIX circles consider <code class="literal">nslookup</code> to be a hack of sorts. In some newer UNIX systems, <code class="literal">nslookup</code> has been deprecated (still included in the operating system for compatibility, but not recommended and may be removed in the future). Instead, a pair of newer utilities is provided: <code class="literal">host</code> and <code class="literal">dig</code>.</p></div><div class="sect2" title="The host Utility"><div class="titlepage"><div><div><h2 class="title"><a id="the_host_utility"/>The host Utility</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3222"/>The <code class="literal">host</code> utility is most often used for simple queries such as those normally performed using <code class="literal">nslookup</code>'s noninteractive mode. It is invoked in the same way as noninteractive <code class="literal">nslookup</code>:</p><a id="I_programlisting2_d1e98161"/><pre class="programlisting">host &lt;<em class="replaceable"><code>host</code></em>&gt; [&lt;<em class="replaceable"><code>server</code></em>&gt;]</pre><p>The output is also similar to that of noninteractive <code class="literal">nslookup</code>, but less verbose. Here is an example:</p><a id="I_programlisting2_d1e98174"/><pre class="programlisting">%host www.pcguide.com
www.pcguide.com is an alias for pcguide.com.
pcguide.com has address 209.68.14.80</pre><p>Even though <code class="literal">host</code> does not operate interactively, it includes a number of options that can allow an administrator to get the same information that would have been obtained using <code class="literal">nslookup</code>'s interactive mode. Some of the more common options are shown in <a class="xref" href="ch88s05.html#typical_host_utility_options_and_paramet" title="Table 88-6. Typical host Utility Options and Parameters">Table 88-6</a>.</p><div class="table"><a id="typical_host_utility_options_and_paramet"/><p class="title">Table 88-6. Typical host Utility Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical host Utility Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-d</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Turns on debug mode.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-l</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a complete list of information for a domain; this is similar to the <code class="literal">ls</code> command in interactive <code class="literal">nslookup</code>. This may be used with the <code class="literal">-t</code> option to select only a particular type of resource record for the domain.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-r</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Disables recursion in the request. When this is specified, only the server directly queried will return any information; it will not query other servers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-t &lt;</code><em class="replaceable"><code>query-type</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies a query for a particular resource record type, allowing any type of DNS information to be retrieved.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-v</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Uses verbose mode for output (additional details are provided).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-w</code></p></td><td style=""><p>Waits as long as necessary for a response (no timeout).</p></td></tr></tbody></table></div></div></div><div class="sect2" title="The dig Utility"><div class="titlepage"><div><div><h2 class="title"><a id="the_dig_utility"/>The dig Utility</h2></div></div></div><p>The second alternative to <code class="literal">nslookup</code> is <a class="indexterm" id="idx-CHP-88-3223"/><code class="literal">dig</code>, which stands for Domain Information Groper (likely a play on the supposed origin of the name <code class="literal">ping</code>). It differs from the <code class="literal">host</code> command in that it provides considerably more information about a domain, even when invoked in the simplest of ways. It is also quite a bit more complicated, with a large number of options and features, such as a batch mode for obtaining information about many domains.</p><p>The basic syntax for the <code class="literal">dig</code> command is different from that of <code class="literal">nslookup</code> and <code class="literal">host</code>. If you specify a nondefault name server, it is prepended with an at sign (@) and comes before the host to be looked up. You can also specify a specific type of resource record, like this:</p><a id="I_programlisting2_d1e98293"/><pre class="programlisting">dig [@&lt;<em class="replaceable"><code>server</code></em> &gt;] &lt;<em class="replaceable"><code>host</code></em> &gt;  [&lt;<em class="replaceable"><code>type</code></em> &gt;]</pre><p><a class="xref" href="ch88s05.html#dns_name_resolution_using_the_nslo-id001" title="Example 88-4. DNS name resolution using the nslookup utility">Example 88-4</a> shows the output from running <code class="literal">dig</code> on the same domain (<a class="ulink" href="http://www.pcguide.com">www.pcguide.com</a>) that I used as an example for nslookup (<a class="xref" href="ch88s05.html#dns_name_resolution_using_the_nslookup_u" title="Example 88-3. DNS name resolution using the nslookup utility">Example 88-3</a>) and <code class="literal">host</code>. You can see that it provides much more information about the domain.</p><div class="example"><a id="dns_name_resolution_using_the_nslo-id001"/><p class="title">Example 88-4. DNS name resolution using the nslookup utility</p><div class="example-contents"><pre class="programlisting">%dig www.pcguide.com
; &lt;&lt;&gt;&gt; DiG 9.2.1 &lt;&lt;&gt;&gt; www.pcguide.com
;; global options:  printcmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 15912
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0
;; QUESTION SECTION:
;www.pcguide.com.               IN      A

;; ANSWER SECTION:
www.pcguide.com.        3600    IN      CNAME   pcguide.com.
pcguide.com.            3600    IN      A       209.68.14.80

;; AUTHORITY SECTION:
pcguide.com.            3600    IN      NS      ns0.ns0.com.
pcguide.com.            3600    IN      NS      ns23.pair.com.

;; Query time: 1840 msec
;; SERVER: 209.68.1.87#53(209.68.1.87)
;; WHEN: Tue Nov 18 16:05:08 2003
;; MSG SIZE  rcvd: 109Server:  ns1-mar.starband.com</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="note-195"/>Note</h3><p><span class="emphasis"><em>The</em></span> <code class="literal">dig</code> <span class="emphasis"><em>utility is very useful, but has still not been implemented on some systems. Fortunately, there is an online</em></span> <code class="literal">dig</code> <span class="emphasis"><em>utility you can access using your browser on the Internet. Find it at</em></span> <a class="ulink" href="http://www.gont.com.ar/tools/dig">http://www.gont.com.ar/tools/dig</a>.</p></div><p>The <code class="literal">dig</code> command includes dozens of options and settings. Since this chapter is already getting very long and <code class="literal">dig</code> is by far the most advanced of the three utilities, I will stop here. Consult your system's documentation for the full instructions on how <code class="literal">dig</code> works and a list of its parameters.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-539"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Most TCP/IP implementations provide one or more utilities that can be employed by an administrator to manually resolve DNS domain names to IP addresses or perform related searches for DNS information. One of the most common is nslookup, which allows a host name to be translated to an address or vice versa; it has both interactive and noninteractive modes. On some operating systems, nslookup has been replaced by the host <a class="indexterm" id="idx-CHP-88-3224"/>utility for simple DNS lookups and by the dig program for more detailed inspections of DNS resource information.</p></div></div></div>
<div class="sect1" title="TCP/IP DNS Registry Database Lookup Utility (whois/nicname)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_dns_registry_database_lookup_utili"/>TCP/IP DNS Registry Database Lookup Utility (whois/nicname)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-88-3225"/><a class="indexterm" id="idx-CHP-88-3226"/><a class="indexterm" id="idx-CHP-88-3227"/>Utilities such as <code class="literal">nslookup</code> and <code class="literal">host</code> allow administrators to resolve a DNS domain name to an address and also view detailed information about a domain's resource records. There are cases, however, where administrators need to know its DNS registration information, rather technical information about a domain. This includes details such as which organization owns the domain, when its registration expires, and who are the designated contacts who manage it.</p><p>In the early days of DNS, all domain names were centrally registered by a single authority, called the Internet <a class="indexterm" id="idx-CHP-88-3228"/>Network Information Center (InterNIC or just NIC). To allow Internet users to look up information about domains and contacts, InterNIC set up a special server. To allow users to retrieve information from this server, developers created a protocol called both <code class="literal">nicname</code> and <code class="literal">whois</code>. It was initially described in RFC 812 (in 1982) and then later in RFC 943 (in 1985). Over time, the name <code class="literal">whois</code> has become the preferred of the two, and it is the one used today for the utility program that allows an administrator to look up DNS registration data. (It can also be used to look up information about IP addresses, but is used for that purpose much less commonly.)</p><p>As the Internet grew and expanded, it moved away from having a single centralized authority. The modern Internet has a hierarchical structure of authorities that are responsible for registering domain names in different portions of the DNS name space. In recent years, this has been further complicated by the deregulation process that allows multiple registries for the generic top-level domains such as .COM, .NET, and .ORG. All of this means that more work is needed to look up domain registration information, since it is distributed across many databases on different servers.</p><p>To make it easier for administrators to find information about domains in this large distributed database, modern TCP/IP implementations generally come with an intelligent version of the <code class="literal">whois</code> utility. It is able to accept as input the name of a domain and automatically locate the appropriate registry in which that domain's information is located. The utility is usually used as follows:</p><a id="I_programlisting2_d1e98408"/><pre class="programlisting">whois [-h &lt;<em class="replaceable"><code>whois-host</code></em> &gt;] &lt;<em class="replaceable"><code>domain</code></em>&gt;</pre><p>In this syntax, <code class="literal">&lt;</code><em class="replaceable"><code>domain</code></em><code class="literal">&gt;</code> represents the name about which registration information is requested. The administrator can use the <code class="literal">-h</code> parameter to force the program to query a particular whois server, but again, this is usually not required. Some implementations also include other options that can be used to direct queries to particular registries.</p><p><a class="xref" href="ch88s06.html#dns_domain_registry_lookup_using_the_who" title="Example 88-5. DNS domain registry lookup using the whois program">Example 88-5</a> shows the sample output of the <code class="literal">whois</code> command on a FreeBSD UNIX machine (I have stripped out some of the preliminary general information and legal disclaimers to shorten the listing).</p><div class="example"><a id="dns_domain_registry_lookup_using_the_who"/><p class="title">Example 88-5. DNS domain registry lookup using the whois program</p><div class="example-contents"><pre class="programlisting">%whois pcguide.com
Registrant:
  The PC Guide
  2080 Harwood Hill Road
  Bennington, VT 05201
  US

  ixl@fearn.pair.com
   +1.8025555555

Domain Name: PCGUIDE.COM

Administrative &amp; Technical Contact:
  Charles Kozierok
  The PC Guide
  2080 Harwood Hill Road
  Bennington, VT 05201
  US
 
  ixl@fearn.pair.com
   +1.8025555555

Domain Name Servers:
  NS23.PAIR.COM
  NS0.NS0.COM

 Created:     August 25, 1997
Modified:     July  7, 2003
 Expires:     August 24, 2008
 
** Register Now at http://www.pairNIC.com/ **</pre></div></div><p>In this case, the registrar of the domain <a class="ulink" href="http://pcguide.com">pcguide.com</a> is pairNIC, the DNS registry division of pair Networks, the company I have used for web hosting for many years (since 1997, as you can see). This output is public information and lets anyone who has an interest in pcguide.com determine that I own the domain and learn how to contact me. (No, 555-5555 is not my real phone number.) It also tells them that pair Networks runs the name servers that contain domain information for my domain.</p><p>Many operating systems, including Windows, do not come with a <code class="literal">whois</code> command implementation, but there are third-party programs that will support the function. In recent years, many different organizations have also set up websites that implement the <code class="literal">whois</code> function, which is much more convenient and user-friendly to those more accustomed to graphical user interface operating systems like Windows. Many of these sites are provided as free services by DNS registrars, so customers can check if a name they are interested in is already taken, and if so, by whom.</p><p>One drawback of some of these systems is that they usually do not have the intelligence to check all the different registries where domain name records are stored. In most cases, a <code class="literal">whois</code> service provided by a registrar will search for names only in the particular top-level domains in which the registrar operates. So, if the registrar deals with .COM, .ORG, and .NET, it may support <code class="literal">whois</code> queries only for those top-level domains. To check the registration information for domains in more obscure domains, such as some of the less common geopolitical (country code) domains, a considerable amount of searching may be required.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-540"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The TCP/IP <code class="literal">whois</code> utility allows registration information to be displayed for a DNS domain, such as its owner, contact information, and the date that its registration expires. The program is most commonly found on UNIX operating systems, where it is given intelligence that allows it to automatically query the correct servers to find the information for most domains. Newer Web-based <code class="literal">whois</code> utilities also exist, but they are usually limited to displaying information about domains in only a specific subset of top-level domains.</p></div></div>
<div class="sect1" title="TCP/IP Network Status Utility (netstat)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_network_status_utility_netstat"/>TCP/IP Network Status Utility (netstat)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-88-3229"/>Given how complex TCP/IP is, it's actually quite amazing that most of the time, all of the different protocols, services, and programs perform their jobs both efficiently and silently. Most of us don't even realize just how much is going on in the background, and that's as it should be. On the other hand, when a problem does occur on a TCP/IP network, the administrator charged with fixing it needs to obtain as much information as possible about what all those bits and pieces of the suite are doing behind the scenes. The network status utility, <code class="literal">netstat</code>, serves this purpose.</p><p>The <code class="literal">netstat</code> program is very simple in concept, being designed for only one purpose: to show information about the operation of TCP/IP on a device. The complexity of TCP/IP, however, leads to <code class="literal">netstat</code> being rather elaborate itself. The program can provide a large variety of information. As usual, the options and output of <code class="literal">netstat</code> depend on the particular operating system type and version. It is somewhat different on UNIX and Windows machines, so I will describe each platform's version separately.</p><div class="sect2" title="The UNIX netstat Utility"><div class="titlepage"><div><div><h2 class="title"><a id="the_unix_netstat_utility"/>The UNIX netstat Utility</h2></div></div></div><p>On most <a class="indexterm" id="idx-CHP-88-3230"/>UNIX systems, the <code class="literal">netstat</code> utility is very full-featured, with a typical implementation including dozens of options that can be used to control what information is displayed. These options may not all be used simultaneously; rather, they are arranged into option groups, each of which presents one class of information. Within each group, one option is mandatory, and that is the one that identifies the group, and hence the general kind of information that will be displayed. Other options are also possible in each group, which are optional and modify the command to provide better control of exactly what is output. In essence, <code class="literal">netstat</code> is like many related utilities rolled into one.</p><p><a class="xref" href="ch88s07.html#typical_unix_netstat_option_groups_optio" title="Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters">Table 88-7</a> provides a simplified summary of the option groups for a typical UNIX <code class="literal">netstat</code> implementation, in this case FreeBSD.</p><div class="table"><a id="typical_unix_netstat_option_groups_optio"/><p class="title">Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical UNIX netstat Option Groups, Options, and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Group, Options, and Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat [-AaLSW] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;] [-n]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Default invocation of <code class="literal">netstat</code>, with no mandatory options. It prompts the utility to display a list of active sockets on the host machine. The other options shown can be used to control what precisely is output; for example, <code class="literal">-a</code> also shows server processes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -i [-abdt] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-n] netstat -I &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt; [-abdt] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-n]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells <code class="literal">netstat</code> to provide information about all network interfaces (<code class="literal">-i</code>) or a particular network interface (<code class="literal">-I &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt;</code>). The <code class="literal">-a</code> option shows multicast addresses as well, <code class="literal">-b</code> displays bytes of data in and out on the interface, <code class="literal">-d</code> shows the number of dropped packets, and <code class="literal">-t</code> displays the value of watchdog timers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -w &lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt; -d [-I &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays packet traffic information on all interfaces every <code class="literal">&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;</code> seconds, or just on the specified interface if <code class="literal">-I &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt;</code> is included. If <code class="literal">-d</code> is included, it also indicates the number of dropped packets.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -s [-s] [-z] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows systemwide statistics for each of the protocols on the system (which may be modified to show information for only a particular address family or protocol). If the <code class="literal">-s</code> option is repeated, counters that have a value of zero are suppressed. The <code class="literal">-z</code> option resets the statistics after they are displayed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -i -s [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;] netstat -I &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt; -s [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays statistics as for <code class="literal">netstat -s</code>, but on a per-interface basis rather than aggregated for the whole system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -m</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Outputs memory management routine statistics.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -r [-Aa] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [-n] [-W]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the contents of the host's routing tables. The options <code class="literal">-A</code> and <code class="literal">-a</code> provide additional information about the routes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -rs [-s]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays routing statistics. The <code class="literal">-s</code> option suppresses counters with a zero value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -g [-W] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows multicast routing information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">netstat -gs [-s] [-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;]</code></p></td><td style=""><p>Shows multicast routing statistics. The <code class="literal">-s</code> option suppresses counters with a zero value.</p></td></tr></tbody></table></div></div><p>Most of the options shown in the option groups in <a class="xref" href="ch88s07.html#typical_unix_netstat_option_groups_optio" title="Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters">Table 88-7</a> are particular to those groups; for example, you cannot use <code class="literal">-s</code> when issuing the command <code class="literal">netstat -i</code>. However, there are also a number of universal options that can be used with more than one of these groups to modify the behavior of <code class="literal">netstat</code> variations in a consistent way. These options are described in <a class="xref" href="ch88s07.html#typical_unix_netstat_universal_options_a" title="Table 88-8. Typical UNIX netstat Universal Options and Parameters">Table 88-8</a>.</p><div class="table"><a id="typical_unix_netstat_universal_options_a"/><p class="title">Table 88-8. Typical UNIX netstat Universal Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical UNIX netstat Universal Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-f &lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Limits the output of the command to information on a particular protocol address family, for hosts running multiple protocol suites. For example, the address family for regular TCP/IP is <code class="literal">inet</code>; for IPv6, it is <code class="literal">inet6</code>. Others may also be supported.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Restricts output to data related only to a particular protocol, such as IP, TCP, UDP, or ICMP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-n</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows network addresses in numeric form, instead of showing them as symbolic names. Also shows ports as numbers instead of converting well-known UDP and TCP port numbers to the protocol names that use them (for example, 23 rather than telnet).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-W</code></p></td><td style=""><p>Suppresses the automatic truncation of addresses (which is sometimes done for display formatting).</p></td></tr></tbody></table></div></div><p>The <code class="literal">netstat</code> command can produce a startling amount of output, especially if you do not restrict it with some of the options in <a class="xref" href="ch88s07.html#typical_unix_netstat_universal_options_a" title="Table 88-8. Typical UNIX netstat Universal Options and Parameters">Table 88-8</a>. This is particularly true for <code class="literal">netstat</code> by itself and with the <code class="literal">-s</code> option. <a class="xref" href="ch88s07.html#sample_connections_list_from_the_unix_ne" title="Example 88-6. Sample connections list from the UNIX netstat utility">Example 88-6</a> shows sample output from running "plain" <code class="literal">netstat</code>, but I have truncated the list of connections so it would not be too long (I also reformatted the listing so it would fit on the page better). Notice the last column, which shows the current state of the TCP connection (see the TCP finite state machine description in <a class="xref" href="ch47.html" title="Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION">Chapter 47</a>).</p><div class="example"><a id="sample_connections_list_from_the_unix_ne"/><p class="title">Example 88-6. Sample connections list from the UNIX netstat utility</p><div class="example-contents"><pre class="programlisting">%netstat
Active Internet connections
Prot  Rcv  Snd  Local Address     Foreign Address       (state)
tcp4  0    0    pcguide.com.http  c-24-118-141-124.3384  ESTABLISHED
tcp4  0    827  pcguide.com.http  webcacheB03a.cac.46075 ESTABLISHED
tcp4  0    0    qs36.smtp         MV1-24.171.17.64.1339  ESTABLISHED
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1338  ESTABLISHED
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1337  FIN_WAIT_1
tcp4  0    84   pcguide.com.http  dial81-131-97-70.2902  FIN_WAIT_1
tcp4  0    0    pcguide.com.http  216.76.14.221.9954     FIN_WAIT_2
tcp4  0    0    pcguide.com.http  216.76.14.221.9945     FIN_WAIT_2
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1326  TIME_WAIT</pre></div></div><p><a class="xref" href="ch88s07.html#sample_ip_statistics_from_the_unix_netst" title="Example 88-7. Sample IP statistics from the UNIX netstat utility">Example 88-7</a> shows an example of the output of <code class="literal">netstat -s.</code> Here, I have limited the output by using <code class="literal">-p ip</code> to tell the program to show me only the statistics for IP.</p><div class="example"><a id="sample_ip_statistics_from_the_unix_netst"/><p class="title">Example 88-7. Sample IP statistics from the UNIX netstat utility</p><div class="example-contents"><pre class="programlisting">%netstat -s -p ip
ip:
        57156204 total packets received
        0 bad header checksums
        4 with size smaller than minimum
        0 with data size &lt; data length
        0 with ip length &gt; max ip packet size
        0 with header length &lt; data size
        0 with data length &lt; header length
        0 with bad options
        0 with incorrect version number
        138 fragments received
        6 fragments dropped (dup or out of space)
        128 fragments dropped after timeout
        2 packets reassembled ok
        57085912 packets for this host
        24736 packets for unknown/unsupported protocol
        0 packets forwarded (0 packets fast forwarded)
        44957 packets not forwardable
        4 packets received for unknown multicast group
        0 redirects sent
        66183465 packets sent from this host
        177 packets sent with fabricated ip header
        0 output packets dropped due to no bufs, etc.
        0 output packets discarded due to no route
        0 output datagrams fragmented
        0 fragments created
        0 datagrams that can't be fragmented
        0 tunneling packets that can't find gif
        22 datagrams with bad address in header</pre></div></div></div><div class="sect2" title="The Windows netstat Utility"><div class="titlepage"><div><div><h2 class="title"><a id="the_windows_netstat_utility"/>The Windows netstat Utility</h2></div></div></div><p>The <a class="indexterm" id="idx-CHP-88-3231"/>Windows <code class="literal">netstat</code> utility is quite a bit simpler than the UNIX one, because it has a lot fewer options. This is good news for those learning about the program, but not so wonderful for those who want maximum power and flexibility in using it.</p><p>Like the UNIX <code class="literal">netstat</code> version, the Windows utility has a set of options groups that dictate the general type of information shown, and a few universal options that can be used with multiple groups. The option groups and generic options are shown in Tables <a class="xref" href="ch88s07.html#typical_windows_netstat_option_groups_op" title="Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters">Table 88-9</a> and <a class="xref" href="ch88s07.html#typical_windows_netstat_universal_option" title="Table 88-10. Typical Windows netstat Universal Options and Parameters">Table 88-10</a>, respectively.</p><div class="table"><a id="typical_windows_netstat_option_groups_op"/><p class="title">Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical Windows netstat Option Groups, Options, and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Group, Options, and Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat [-n] [-o] [&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;] netstat -a [-n] [-o]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>When called with no mandatory options, <code class="literal">netstat</code> displays information about active TCP connections.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt; [&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays all active TCP connections, as well as both TCP and UDP ports to which the host is listening.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -e [&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows statistics for Ethernet interfaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netstat -r [&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the current routing table for the device.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">netstat -s [-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;]
[&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;]</code></p></td><td style=""><p>Displays TCP/IP statistics for the system by protocol.</p></td></tr></tbody></table></div></div><div class="table"><a id="typical_windows_netstat_universal_option"/><p class="title">Table 88-10. Typical Windows netstat Universal Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical Windows netstat Universal Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-n</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays network addresses in numeric form instead of symbolic name form. Also shows ports in numeric form instead of displaying standard process names associated with well-known UDP or TCP port numbers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-o</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the process ID associated with each connection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-p &lt;</code><em class="replaceable"><code>protocol</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Limits the display to only the information associated with the specified protocol.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Causes the <code class="literal">netstat</code> command to be repeated every <code class="literal">&lt;</code><em class="replaceable"><code>interval</code></em><code class="literal">&gt;</code> seconds, rather than just displaying its information once. This can be used with any of the <code class="literal">netstat</code> option groups. For example, <code class="literal">netstat -s 5</code> displays TCP/IP statistics every 5 seconds.</p></td></tr></tbody></table></div></div><p>The output from the Windows <code class="literal">netstat</code> program is fairly similar to that of the UNIX utility when the same or similar options are given, but the UNIX version usually provides more details. <a class="xref" href="ch88s07.html#sample_icmp_statistics_from_the_windows_" title="Example 88-8. Sample ICMP statistics from the Windows netstat utility">Example 88-8</a> shows an example illustrating TCP/IP statistics on my home Windows XP machine, using <code class="literal">-p icmp</code> to restrict the output to ICMP statistics only.</p><div class="example"><a id="sample_icmp_statistics_from_the_windows_"/><p class="title">Example 88-8. Sample ICMP statistics from the Windows netstat utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;netstat -s -p icmp
ICMPv4 Statistics
                            Received    Sent
  Messages                  243         248
  Errors                    0           0
  Destination Unreachable   9           4
  Time Exceeded             7           0
  Parameter Problems        0           0
  Source Quenches           0           0
  Redirects                 0           0
  Echos                     224         20
  Echo Replies              3           224
  Timestamps                0           0
  Timestamp Replies         0           0
  Address Masks             0           0
  Address Mask Replies      0           0</pre></div></div><p><a class="xref" href="ch88s07.html#sample_routing_table_display_from_the_wi" title="Example 88-9. Sample routing table display from the Windows netstat utility">Example 88-9</a> shows the routing table display from <code class="literal">netstat</code> (which I modified slightly to fit the page). You would get similar output using the UNIX <code class="literal">netstat -s -p icmp</code> or <code class="literal">netstat -r</code> command, but with additional information.</p><div class="example"><a id="sample_routing_table_display_from_the_wi"/><p class="title">Example 88-9. Sample routing table display from the Windows netstat utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;netstat -r
Route Table
=================================================================
Interface List
0x1 ........................... MS TCP Loopback interface
0x2 ...00 04 76 4e 75 3f ...... 3Com 10/100 Mini PCI Ethernet
=================================================================
=================================================================
Active Routes:
  Network Dest     Netmask          Gateway        Interface      Met
  0.0.0.0          0.0.0.0          148.64.128.1   148.64.133.73   30
  127.0.0.0        255.0.0.0        127.0.0.1      127.0.0.1       1
  148.64.128.0     255.255.192.0    148.64.133.73  148.64.133.73   30
  148.64.133.73    255.255.255.255  127.0.0.1      127.0.0.1       30
  148.64.255.255   255.255.255.255  148.64.133.73  148.64.133.73   30
  224.0.0.0        240.0.0.0        148.64.133.73  148.64.133.73   30
  255.255.255.255  255.255.255.255  148.64.133.73  148.64.133.73   1
Default Gateway:      148.64.128.1
=================================================================
Persistent Routes:
  None</pre></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-541"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> TCP/IP implementations include the <code class="literal">netstat</code> utility to allow information about network status to be displayed. On UNIX systems, <code class="literal">netstat</code> is a full-featured program with many options arranged into option groups, each of which shows a particular type of information about the operation of TCP/IP protocols. On Windows systems, <code class="literal">netstat</code> is somewhat more limited in function, but it still can display a considerable amount of information.</p></div></div></div>
<div class="sect1" title="TCP/IP Configuration Utilities (ifconfig, ipconfig, and winipcfg)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_configuration_utilities_ifconfig_i"/>TCP/IP Configuration Utilities (ifconfig, ipconfig, and winipcfg)</h1></div></div></div><p>A significant part of any network administrator's job is setting up and maintaining the devices that make a TCP/IP network function, a process generally called <span class="emphasis"><em>configuration</em></span>. Networked hosts consist of both hardware and software that work together to implement all the layers and functions of the protocol stack. An administrator uses hardware tools to configure physical devices, performing tasks such as installing network interface cards, connecting cables, and manipulating switches and other hardware settings. Similarly, administrators need tools to configure the software that runs TCP/IP interfaces and controls the operation of higher-layer protocols on networked hosts. UNIX administrators use the <code class="literal">ifconfig</code> utility. On Windows NT, 2000, and XP, the configuration tool is <code class="literal">ipconfig</code>. Earlier versions of Windows have the <code class="literal">winipcfg</code> utility.</p><div class="sect2" title="The ifconfig Utility for UNIX"><div class="titlepage"><div><div><h2 class="title"><a id="the_ifconfig_utility_for_unix"/>The ifconfig Utility for UNIX</h2></div></div></div><p><a class="indexterm" id="idx-CHP-88-3232"/>On UNIX systems, administrators use the interface configuration utility, <code class="literal">ifconfig</code>, to view and modify the software settings that control how TCP/IP functions on a host. It is a very powerful program that allows an administrator to set up and manage a very wide array of network settings. The implementation of <code class="literal">ifconfig</code> varies greatly between flavors of UNIX; while most are similar in general terms, they may have different options and syntaxes.</p><p>You can use the <code class="literal">ifconfig</code> program for a variety of purposes: to create or remove a network interface, change its settings, or simply examine the existing configuration. Thus, like the <code class="literal">netstat</code> utility, <code class="literal">ifconfig</code> is like several related programs combined into one, and how it works depends on the syntax you used to invoke it. And also like <code class="literal">netstat</code>, <code class="literal">ifconfig</code> has a number of universal options that can be applied to many of its different uses.</p><p><a class="xref" href="ch88s08.html#typical_unix_ifconfig_syntaxes_options_a" title="Table 88-11. Typical UNIX ifconfig Syntaxes, Options, and Parameters">Table 88-11</a> provides a simplified summary of the different functions that <code class="literal">ifconfig</code> can perform and the syntaxes that are used to specify each in a typical UNIX implementation (NetBSD in this case). You can use <code class="literal">ifconfig</code> to modify an interface's configuration by setting any of several dozen configuration parameters, using the syntax shown in the last row of that table. <a class="xref" href="ch88s08.html#typical_unix_ifconfig_universal_options_" title="Table 88-12. Typical UNIX ifconfig Universal Options and Parameters">Table 88-12</a> describes the common options and parameters that can be used for many of these different modes. I have provided a brief description of some sample parameters in <a class="xref" href="ch88s08.html#typical_unix_ifconfig_interface_configur" title="Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters">Table 88-13</a> (see your <code class="literal">ifconfig</code> documentation for a complete list).</p><div class="table"><a id="typical_unix_ifconfig_syntaxes_options_a"/><p class="title">Table 88-11. Typical UNIX ifconfig Syntaxes, Options, and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical UNIX ifconfig Syntaxes, Options, and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax, Options and Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ifconfig [-L] [-m] &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>When <code class="literal">ifconfig</code> is called with just an interface specification and no other options (other than possibly <code class="literal">-L</code> and <code class="literal">-m</code>), it displays the configuration information for that network interface.</p>
<p>Note that entering <code class="literal">ifconfig</code> by itself with no interface displays just help information for the parameter. To see all interfaces, use the <code class="literal">-a</code> parameter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [&lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays information about all the interfaces on the host. The output may be restricted using the universal parameters shown or by specifying an address family (see <a class="xref" href="ch88s08.html#typical_unix_ifconfig_universal_options_" title="Table 88-12. Typical UNIX ifconfig Universal Options and Parameters">Table 88-12</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ifconfig -l [-b] [-d] [-u] [-s]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Lists all available interfaces on the system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ifconfig &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt; create</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates the specified logical network interface on the host, which is then configured using the syntax shown in the last row of this table. Note that some variations of UNIX allow certain parameters to be set at the time of creation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ifconfig &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt; destroy</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Destroys the specified logical interface.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">ifconfig &lt;</code><em class="replaceable"><code>interface</code></em><code class="literal">&gt; [&lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;] [&lt;</code><em class="replaceable"><code>address</code></em><code class="literal">&gt; [&lt;</code><em class="replaceable"><code>dest-address</code></em><code class="literal">&gt;]] [&lt;</code><em class="replaceable"><code>parameters</code></em><code class="literal">&gt;]</code></p></td><td style=""><p>Configures parameters for a particular interface on the host. If the address is being set, it is the first parameter specified, after the optional address family, if present. The <code class="literal">&lt;dest-address&gt;</code> is used to specify a destination address for a point-to-point link. After this, any of several dozen parameters may be specified for the interface, some of which are shown in <a class="xref" href="ch88s08.html#typical_unix_ifconfig_interface_configur" title="Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters">Table 88-13</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="typical_unix_ifconfig_universal_options_"/><p class="title">Table 88-12. Typical UNIX ifconfig Universal Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical UNIX ifconfig Universal Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameter</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-L</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the address lifetime for IPv6 addresses.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-m</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays all supported media for the interface.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-b</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Limits the display of interface information to broadcast interfaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-d</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows only interfaces that are presently down (disabled).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-u</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows only interfaces that are presently up (operational).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-s</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Shows only interfaces that may be connected.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">&lt;</code><em class="replaceable"><code>family</code></em><code class="literal">&gt;</code></p></td><td style=""><p>Specifies a particular address family, either to limit output or indicate what address type is being configured. The value <code class="literal">inet</code> is used for IPv4 and <code class="literal">inet6</code> for IPv6.</p></td></tr></tbody></table></div></div><div class="table"><a id="typical_unix_ifconfig_interface_configur"/><p class="title">Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical UNIX ifconfig Interface Configuration Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">alias / -alias</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Establishes or removes a network address alias.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">arp / -arp</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Enables or disables the use of ARP on this interface.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">delete</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes the specified network address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">down</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Marks an interface as being down, disabling it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">media &lt;</code><em class="replaceable"><code>type</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the media type of the interface to a particular value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mtu &lt;</code><em class="replaceable"><code>n</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the maximum transmission unit (MTU) of the interface.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">netmask &lt;</code><em class="replaceable"><code>mask</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the network or subnet mask for the interface's address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">pref</code>ixlen &lt;<em class="replaceable"><code>n</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as <code class="literal">netmask</code> but allows the mask to be specified using a CIDR-style prefix length.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">up</code></p></td><td style=""><p>Sets an interface up, enabling it.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-196"/>Note</h3><p><span class="emphasis"><em>Since creating, destroying, or modifying interfaces can cause a host to stop working properly, administrative (superuser) rights are generally required on most systems in order to do anything with</em></span> <code class="literal">ifconfig</code> <span class="emphasis"><em>other than examining the existing configuration</em></span>.</p></div><p><a class="xref" href="ch88s08.html#sample_output_of_the_unix_ifconfig_-a_co" title="Example 88-10. Sample output of the UNIX ifconfig -a command">Example 88-10</a> shows sample output of the <code class="literal">ifconfig -a</code> command on one of the UNIX machines I use regularly, showing the settings for its interfaces.</p><div class="example"><a id="sample_output_of_the_unix_ifconfig_-a_co"/><p class="title">Example 88-10. Sample output of the UNIX ifconfig -a command</p><div class="example-contents"><pre class="programlisting">%ifconfig -a
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
  address: 00:a0:c9:8c:f4:a1
  media: Ethernet autoselect (100baseTX full-duplex)
  status: active
  inet 166.84.1.3 netmask 0xffffffe0 broadcast 166.84.1.31
  inet alias 166.84.1.13 netmask 0xffffffff broadcast 166.84.1.13
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt; mtu 33228
  inet 127.0.0.1 netmask 0xff000000</pre></div></div></div><div class="sect2" title="The ipconfig for Windows NT, 2000, and XP"><div class="titlepage"><div><div><h2 class="title"><a id="the_ipconfig_for_windows_nt_2000_and_xp"/>The ipconfig for Windows NT, 2000, and XP</h2></div></div></div><p>Windows takes a somewhat different approach to network configuration than UNIX. As described in the previous section, you can use the UNIX <code class="literal">ifconfig</code> program both to view and modify a wide range of configuration parameters. In Windows, however, most setup and parameter modification is done using the Windows Control Panel. Windows does include a <a class="indexterm" id="idx-CHP-88-3233"/>utility that is somewhat similar to UNIX's <code class="literal">ifconfig</code>, but it has far less functionality and is used mainly to inspect the existing configuration, not change it. It also allows an administrator to easily perform a few simple functions on a host.</p><p>On Windows NT, 2000, and XP, the equivalent of <code class="literal">ifconfig</code> is a command-line utility called <code class="literal">ipconfig</code>. Like <code class="literal">ifconfi</code>g, the Windows utility is controlled using options that are supplied to the program. However, because it is so much simpler than <code class="literal">ifconfig</code>, there are only a few options, as summarized in <a class="xref" href="ch88s08.html#typical_windows_ipconfig_options_and_par" title="Table 88-14. Typical Windows ipconfig Options and Parameters">Table 88-14</a>.</p><div class="table"><a id="typical_windows_ipconfig_options_and_par"/><p class="title">Table 88-14. Typical Windows ipconfig Options and Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Typical Windows ipconfig Options and Parameters"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option/Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(none)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When called with no options or parameters, <code class="literal">ipconfig</code> displays the IP address, subnet mask, and default gateway for each interface on the host.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/all</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Similar to calling <code class="literal">ipconfig</code> with no options, but displays more detailed configuration information about the host's interfaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/release [&lt;</code><em class="replaceable"><code>adapter</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Releases (terminates) the DHCP lease on either the specified adapter (interface) or all interfaces, if none is provided.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/</code>renew [&lt;<em class="replaceable"><code>adapter</code></em><code class="literal">&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Manually renews the DHCP lease for either the specified adapter (interface) or all adapters, if none is mentioned.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/displaydns</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays the contents of the host's DNS resolver cache.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/flushdns</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Clears the host's DNS resolver cache.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/re</code>gisterdns</p></td><td style="border-bottom: 0.5pt solid ; "><p>Refreshes (renews) all DHCP leases and also reregisters any DNS names associated with the host.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/showclassid &lt;</code><em class="replaceable"><code>adapter</code></em><code class="literal">&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Displays DHCP class IDs associated with this adapter (these are used to arrange clients into groups that are given different treatment by DHCP servers). The adapter must be specified, even if there is only one.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">/setclassid &lt;</code><em class="replaceable"><code>adapter</code></em><code class="literal">&gt; [&lt;</code><em class="replaceable"><code>classid</code></em><code class="literal">&gt;]</code></p></td><td style=""><p>Modifies the DHCP class ID for the specified adapter.</p></td></tr></tbody></table></div></div><p>As mentioned earlier, <code class="literal">ipconfig</code> is most often used to just examine the existing configuration. You can see from the list of options in <a class="xref" href="ch88s08.html#typical_windows_ipconfig_options_and_par" title="Table 88-14. Typical Windows ipconfig Options and Parameters">Table 88-14</a> that most of the other uses of <code class="literal">ipconfig</code> are related to controlling the operation of protocols such as DNS and the Dynamic Host Configuration Protocol (DHCP), rather than configuring a host. One common use of <code class="literal">ipconfig</code> is to force a host to seek out a new DHCP lease, which can be done using <code class="literal">ipconfig /release</code> followed by <code class="literal">ipconfig /renew</code>.</p><p><a class="xref" href="ch88s08.html#simplified_configuration_information_fro" title="Example 88-11. Simplified configuration information from the Windows ipconfig utility">Example 88-11</a> shows an example of the output from using the <code class="literal">ipconfig</code> command without any options. For detailed information on interfaces, you can use the <code class="literal">/all</code> option, as shown in the example in <a class="xref" href="ch88s08.html#detailed_configuration_information_from_" title="Example 88-12. Detailed configuration information from the Windows ipconfig utility">Example 88-12</a> (which I've modified slightly so it is easier to read).</p><div class="example"><a id="simplified_configuration_information_fro"/><p class="title">Example 88-11. Simplified configuration information from the Windows ipconfig utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;ipconfig
Windows IP Configuration

Ethernet adapter Local Area Connection 2:
 
        Connection-specific DNS Suffix  . :
        IP Address. . . . . . . . . . . . : 148.64.133.73
        Subnet Mask . . . . . . . . . . . : 255.255.192.0
        Default Gateway . . . . . . . . . : 148.64.128.1</pre></div></div><div class="example"><a id="detailed_configuration_information_from_"/><p class="title">Example 88-12. Detailed configuration information from the Windows ipconfig utility</p><div class="example-contents"><pre class="programlisting">D:\aa&gt;ipconfig /all
Windows IP Configuration
 
   Host Name . . . . . . . . . . . . : ixl
   Primary Dns Suffix  . . . . . . . :
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No

Ethernet adapter Local Area Connection 2:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : 3Com PCI Ethernet Adapter
   Physical Address. . . . . . . . . : 00-04-76-4E-75-3F
   Dhcp Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes
   IP Address. . . . . . . . . . . . : 148.64.133.73
   Subnet Mask . . . . . . . . . . . : 255.255.192.0
   Default Gateway . . . . . . . . . : 148.64.128.1
   DHCP Server . . . . . . . . . . . : 148.64.128.1
   DNS Servers . . . . . . . . . . . : 148.78.249.200
                                       148.78.249.201
   Lease Obtained. . . . . . . . . . : April 19, 2003 11:51:37 AM
   Lease Expires . . . . . . . . . . : April 19, 2003 12:21:37 PM</pre></div></div></div><div class="sect2" title="The winipcfg Utility for Windows 95, 98, and Me"><div class="titlepage"><div><div><h2 class="title"><a id="the_winipcfg_utility_for_windows_95_98_a"/>The winipcfg Utility for Windows 95, 98, and Me</h2></div></div></div><p>Windows 95, 98, and Me have a graphical tool called <code class="literal">winipcfg</code>, instead of the <code class="literal">ipconfig</code> command-line utility. This program allows you to examine the configuration parameters in much the same way as <code class="literal">ipconfig</code>, and also to release and renew DHCP leases, but it does not support the other options of <code class="literal">ipconfig</code> (such as displaying the host's DNS cache). An example of the main <code class="literal">winipcfg</code> screen is shown in <a class="xref" href="ch88s08.html#windows_9598me_winipcfg_utility_the_wini" title="Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used in older, consumer-oriented versions of Windows to check the configuration of a host and release/renew DHCP leases.">Figure 88-2</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-542"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> On UNIX systems, the <code class="literal">ifconfig</code> utility can be used to display or modify a large number of TCP/IP configuration settings. Windows systems provide either the command-line utility <code class="literal">ipconfig</code> or the graphical tool winipcfg. Both let an administrator see basic TCP/IP configuration information for a host and allow tasks to be performed such as renewing a DHCP lease, but they are otherwise quite limited compared with the UNIX <code class="literal">ifconfig</code> program.</p></div><div class="figure"><a id="windows_9598me_winipcfg_utility_the_wini"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e99719"/><img alt="Windows 95/98/Me winipcfg utility The winipcfg utility can be used in older, consumer-oriented versions of Windows to check the configuration of a host and release/renew DHCP leases." src="httpatomoreillycomsourcenostarchimages288329.png"/></div></div><p class="title">Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used in older, consumer-oriented versions of Windows to check the configuration of a host and release/renew DHCP leases.</p></div></div></div>
<div class="sect1" title="Miscellaneous TCP/IP Troubleshooting Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="miscellaneous_tcpip_troubleshooting_prot"/>Miscellaneous TCP/IP Troubleshooting Protocols</h1></div></div></div><p><a class="indexterm" id="idx-CHP-88-3234"/>As soon as you set up a network, it will very quickly develop problems that you will need to address. Recognizing that the complexity of TCP/IP internetworks would make diagnosing certain problems difficult, the suite's architects defined a number of <a class="indexterm" id="idx-CHP-88-3235"/>miscellaneous <a class="indexterm" id="idx-CHP-88-3236"/>utility protocols that can be helpful in testing and troubleshooting networks. Despite having been around for more than 20 years, these protocols are somewhat obscure and get little attention. However, even though they are no longer implemented on many systems, I feel they are worth a quick look.</p><p>These simple protocols are designed to be implemented as services that run on TCP/IP servers. Each listens for requests on a dedicated well-known port number and then responds with a particular type of information. These protocols can be used with both TCP and UDP, enabling each transport protocol to be tested. In the case of UDP, the server counts each UDP datagram sent to it as a request and sends a response to it. When used with TCP, a connection is first established by the client to the server. In some of the protocols, this connection is then used to send data continuously between the client and server; in others, the establishment of the connection is considered an implied request to the server, which will immediately send a response and then close the connection.</p><p><a class="xref" href="ch88s09.html#miscellaneous_tcpip_troubleshootin-id001" title="Table 88-15. Miscellaneous TCP/IP Troubleshooting Protocols">Table 88-15</a> provides a brief description of each of these troubleshooting protocols under both UDP and TCP. I have shown for each the port number that the service uses and also the RFC that defines it.</p><div class="table"><a id="miscellaneous_tcpip_troubleshootin-id001"/><p class="title">Table 88-15. Miscellaneous TCP/IP Troubleshooting Protocols</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Miscellaneous TCP/IP Troubleshooting Protocols"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Protocol</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Port Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Defining RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Echo Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>862</p></td><td style="border-bottom: 0.5pt solid ; "><p>Echoes received data back to its originator. When used on UDP, the payload of each message is simply packaged into a return UDP datagram and sent back. For TCP, each byte sent by the client is echoed back by the server until the connection is closed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Discard Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>863</p></td><td style="border-bottom: 0.5pt solid ; "><p>Throws away all data that is sent to it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Character Generator Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>864</p></td><td style="border-bottom: 0.5pt solid ; "><p>Generates random characters of data and sends them to a device. When used with UDP, each UDP message sent to the server causes it to send back a UDP message containing a random amount (0 to 512 bytes) of data. When used with TCP, the server just starts sending characters as soon as a client establishes a connection, and continues until the connection is terminated by the client.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Quote of the Day Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>865</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a short message (selected by the server's administrator) to a client device. For UDP, the message is sent for each incoming UDP message; for TCP, the message is sent by the server once when the connection is established, which is then closed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Active Users</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>866</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sends a list of active users to a device. For UDP, the list is sent for each incoming UDP message; if it is longer than 512 bytes, it will be sent in multiple messages. For TCP, the list is sent automatically when the connection is made to the server, and then the connection is terminated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Daytime Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>867</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the current time on the server in human-readable form, in response to receipt of a UDP message or an incoming TCP connection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Time Protocol</p></td><td style="border-right: 0.5pt solid ; "><p>37</p></td><td style="border-right: 0.5pt solid ; "><p>868</p></td><td style=""><p>Returns the current time in machine-readable form—specifically, the number of seconds since midnight, January 1, 1900 GMT. The time is sent for each UDP message received by the server or upon establishment of a TCP connection.</p>
<p>Note that this protocol cannot be used for time synchronization of servers, because it does not compensate for variability in the time required for the messages to be carried over the internetwork.</p></td></tr></tbody></table></div></div></div></body></html>