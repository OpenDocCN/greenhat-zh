- en: Part III-4. TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 65](ch65.html "Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK
    OVERVIEW")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 66](ch66.html "Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION
    (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 67](ch67.html "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL
    (SNMP) CONCEPTS AND OPERATION")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 68](ch68.html "Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 69](ch69.html "Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)")'
  prefs: []
  type: TYPE_NORMAL
- en: Modern networks and internetworks are larger, faster, and more capable than
    their predecessors of years gone by. As we expand, speed up, and enhance our networks,
    they become more complex, and as a result, more difficult to manage. Years ago,
    an administrator could get by with very simple tools to keep a network running,
    but today, more sophisticated network management technologies are required to
    match the sophistication of our networks.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most important tools in the network manager's toolbox are now in
    the form of software, not hardware. To manage a sprawling, heterogeneous, and
    complex internetwork, we can employ software applications to gather information
    and control devices using the internetwork itself. TCP/IP, being the most popular
    internetworking suite, has such software tools. One of the most important is a
    pair of protocols that have been implemented as part of an overall method of network
    management called the *TCP/IP Internet Standard Management Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part describes the TCP/IP Internet Standard Management Framework, looking
    at each of its architectural and protocol components and how they interoperate.
    The first chapter provides an overview of the network management framework itself
    and serves as an introduction to the chapters that follow. The second chapter
    discusses the way that network management information is structured and arranged
    into information stores called *management information bases (MIBs)*. The third
    chapter describes the concepts behind and operation of the key protocol in TCP/IP
    network management: the Simple Network Management Protocol (SNMP). The fourth
    chapter provides details on SNMP''s messaging and message formats. Finally, the
    fifth chapter takes a brief look at Remote Network Monitoring (RMON), an enhancement
    of SNMP—sometimes called a protocol, even though it really isn''t—that provides
    administrators with greater management and monitoring abilities on a TCP/IP internetwork.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while you may be tempted to jump straight to the chapter on SNMP,
    what is written there will make a lot more sense if you read the chapters of this
    part in order.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'TCP/IP network management functions are most commonly associated with the key
    protocol responsible for implementing those functions: the *Simple Network Management
    Protocol (SNMP)*. Many people have heard of SNMP, and it is common for SNMP to
    be considered "the" way that network management is performed in TCP/IP. This is
    true to an extent, but is really an oversimplification. The actual SNMP protocol
    is only one part of a higher-level network management strategy called the *Internet
    Standard Management Framework*. In order to really understand how SNMP works,
    you need to first have some background on the way this network management is structured
    as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide an introduction to TCP/IP network management by describing
    the concepts and components of the TCP/IP Internet Standard Management Framework.
    I begin with an overview and history of the framework, and discuss how it is related
    to SNMP. I describe the TCP/IP network management model and the key components
    that compose a network management system. I provide a summary of the architecture
    of the Internet Standard Management Framework. I then describe the three main
    versions of the Framework and SNMP and how they compare. I conclude with a discussion
    of the many standards used to describe this technology.
  prefs: []
  type: TYPE_NORMAL
- en: Overview and History of the TCP/IP Internet Standard Management Framework and
    Simple Network Management Protocol (SNMP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An adage from the world of professional sports says that a baseball umpire is
    doing a good job when you forget that he is there. In many ways, the same could
    be said of a network administrator. The administrator is doing a good job when
    the network is running so smoothly and efficiently that users forget that the
    administrator exists. Because, as the administrator knows all too well, the second
    there is a problem, the users will all remember very quickly that he or she is
    there.
  prefs: []
  type: TYPE_NORMAL
- en: A primary job of a network administrator is to keep tabs on the network and
    ensure that it is operating normally. Information about the hardware and software
    on the network is a key to performing this task properly.
  prefs: []
  type: TYPE_NORMAL
- en: When networks were small, an administrator could stay informed about the status
    of hardware and software using simple means, such as physically walking over to
    a computer and using it, or using a low-level link layer management protocol.
    This is simply not possible with modern internetworks, which are large, geographically
    diverse, and often consist of many different lower-layer technologies. Usually,
    the only thing all the devices on the network have in common is an implementation
    of a particular internetworking protocol suite, such as TCP/IP. This makes the
    internetwork itself a logical way to facilitate the communication of network management
    information between devices and a network administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Early Development of SNMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many people recognized during the early days of the Internet that some sort
    of network management technology would be needed for TCP/IP. Unfortunately, at
    first there was no single standard. In the 1980s, several different technologies
    were developed by different working groups. There were three main contestants:
    the *High-level Entity Management System (HEMS)/High-level Entity Management Protocol
    (HEMP)* as defined by RFCs 1021 through 1024; the *Simple Gateway Monitoring Protocol
    (SGMP)*, defined by RFC 1028; and the *Common Management Information Protocol
    (CMIP)*, which is actually part of the OSI protocol suite.'
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Engineering Task Force (IETF) recognized the importance of having
    a unifying management standard for TCP/IP, and in 1988, published RFC 1052, "IAB
    Recommendations for the Development of Internet Network Management Standards."
    This memo is not a standard, but more a statement of intention and documentation
    of a meeting held on this subject. The conclusion of RFC 1052 was that SGMP be
    used as the basis of a new Internet standard to be called the *Simple Network
    Management Protocol (SNMP)*. This development was to be carried out by the SNMP
    Working Group.
  prefs: []
  type: TYPE_NORMAL
- en: The Two Meanings of SNMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rationale of the middle two words in the name Simple Network Management
    Protocol is obvious, but the other two words are slightly more problematic. The
    word *Protocol* implies that SNMP is just a TCP/IP communication protocol, like
    other protocols, such as the Dynamic Host Configuration Protocol (DHCP) and the
    File Transfer Protocol (FTP). Unfortunately, this is both true and untrue: the
    name is ambiguous.'
  prefs: []
  type: TYPE_NORMAL
- en: At a lower level, SNMP does indeed refer specifically to the actual protocol
    that carries network management information between devices. This is what most
    people think of when they talk about SNMP. However, as defined by the SNMP working
    group, the TCP/IP network management solution as a whole consists of a number
    of different elements arranged in an architecture. This architecture originally
    had no specific name, but is now called the *Internet Standard Management Framework*.
    Oddly, this higher-level framework is not abbreviated ISMF, but is *also* called
    SNMP, which means that context is important in understanding that term.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*To avoid confusion, I will often use the phrases SNMP Framework and SNMP protocol
    to differentiate these two uses of the term SNMP*.'
  prefs: []
  type: TYPE_NORMAL
- en: Design Goals of SNMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *Simple* in the protocol's name is another problem. Even in its first
    iteration, it was only somewhat simple. The most current version of SNMP is fairly
    complicated indeed, with many different standards defining the SNMP Framework,
    the SNMP protocol itself, and a number of supporting elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why is it called *Simple?* Well, as they say, everything is relative. SNMP
    is simple when compared to other protocols that are even more complex. Some of
    this can be seen by looking at the basic goals of the Internet Standard Management
    Framework and the SNMP protocol as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP defines a universal way that management information can be easily defined
    for any object, and then exchanged between that object and a device designed to
    facilitate network management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP separates the functions of defining and communicating management information
    from the applications that are used for network management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual SNMP protocol is fairly simple, consisting of only a few easy-to-understand
    protocol operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of SNMP is relatively simple for the designers and manufacturers
    of products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Simple Network Management Protocol (SNMP)* defines a set
    of technologies that allow network administrators to remotely monitor and manage
    TCP/IP network devices. The term SNMP refers both to a specific communication
    protocol (sometimes called the *SNMP protocol*) and an overall framework for Internet
    management (the *SNMP Framework*).'
  prefs: []
  type: TYPE_NORMAL
- en: Since SNMP is a TCP/IP application layer protocol, it can theoretically run
    over a variety of transport mechanisms. It is most commonly implemented over the
    Internet Protocol (IP), but the most recent versions also define *transport mappings*
    that can allow SNMP information to be carried over other internetworking technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Further Development of SNMP and the Problem of SNMP Variations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first Internet Standard Management Framework developed (in 1988) is now
    called *SNMP version 1 (SNMPv1)*. This initial version of SNMP achieved widespread
    acceptance, and it is still probably the most common version of SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the history of SNMP since that time has been a rather confusing standards
    nightmare. SNMPv1 had a number of weaknesses, particularly in the area of security.
    For this reason, shortly after SNMPv1 was done, work began on a new version of
    SNMP. Unfortunately, this effort became a quagmire, with many competing variations
    of SNMPv2 being created. After many years of confusion, none of the SNMPv2 variants
    achieved significant success.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, a third version of the SNMP Framework and protocol has been published,
    which adds new features and reunites SNMP under a single, universal protocol again.
    The discussions of SNMP versions and SNMP standards later in this chapter further
    explore the history of SNMP since 1988\. They can be considered a continuation
    of this historical overview, as they help clarify the very confusing story behind
    SNMP versions over the last decade and a half.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *More background on the SNMP protocol proper can be
    found in the overview of the actual protocol itself, in [Chapter 67](ch67.html
    "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION")*.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP SNMP Operational Model, Components, and Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, it seems the *Simple* Network Management Protocol isn't quite so simple
    after all. There are many versions and standards and uses of SNMP, and so a lot
    to learn. I think a good place to start in understanding what SNMP does is to
    look at its *model of operation*. Then we can examine the components that compose
    a TCP/IP network management system and define the terminology used to describe
    them.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Device Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The overall idea behind SNMP is to allow the information needed for network
    management to be exchanged using TCP/IP. More specifically, the protocol allows
    a network administrator to make use of a special network device that interacts
    with other network devices to collect information from them and modify how they
    operate. In the simplest sense, two different basic types of hardware devices
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed Nodes** Regular nodes on a network that have been equipped with software
    to allow them to be managed using SNMP. These are, generally speaking, conventional
    TCP/IP devices. They are also sometimes called *managed devices*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Management Station (NMS)** A designated network device that runs
    special software to allow it to manage the regular managed nodes mentioned just
    above. One or more NMSs must be present on the network, as these devices are the
    ones that really run SNMP.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each device that participates in network management using SNMP runs a piece
    of software, generically called an *SNMP entity*. The SNMP entity is responsible
    for implementing all of the various functions of the SNMP protocol. Each entity
    consists of two primary software components. Which components make up the SNMP
    entity on a device depends on whether the device is a managed node or an NMS.
  prefs: []
  type: TYPE_NORMAL
- en: Managed Node Entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SNMP entity on a managed node consists of the following software elements
    and constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Agent** A software program that implements the SNMP protocol and allows
    a managed node to provide information to an NMS and accept instructions from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Management Information Base (MIB)** An MIB defines the types of information
    stored about the node that can be collected and used to control the managed node.
    Information exchanged using SNMP takes the form of objects from the MIB.'
  prefs: []
  type: TYPE_NORMAL
- en: Network Management Station Entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SNMP entity on an NMS consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Manager** A software program that implements the SNMP protocol, allowing
    the NMS to collect information from managed nodes and to send instructions to
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Applications** One or more software applications that allow a human
    network administrator to use SNMP to manage a network.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Operational Model Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, to integrate and reiterate all of this, let's summarize. SNMP consists of
    a small number of *network management stations (NMSs)* that interact with regular
    TCP/IP devices that are called *managed nodes*. The *SNMP manager* on the NMS
    and the *SNMP agents* on the managed nodes implement the SNMP protocol and allow
    network management information to be exchanged. *SNMP applications* run on the
    NMS and provide the interface to the human administrator, and allow information
    to be collected from the *management information bases (MIBs)* at each SNMP agent.
    [Figure 65-1](ch65s02.html#snmp_operational_model_this_diagram_show "Figure 65-1. SNMP
    operational model This diagram shows a simplified implementation of SNMP, with
    one network management station (NMS) used to maintain three managed nodes. Each
    device has an SNMP entity, and they communicate using SNMP messages. The SNMP
    entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).") illustrates the SNMP operational model.
  prefs: []
  type: TYPE_NORMAL
- en: An SNMP managed node can be pretty much any network device that can communicate
    using TCP/IP, as long as it is programmed with the proper SNMP entity software.
    SNMP is designed to allow regular hosts to be managed, as well as intelligent
    network interconnection devices, such as routers, bridges, hubs, and switches.
    Other devices—printers, scanners, consumer electronic devices, specialized medical
    devices, and so on—can also be managed, as long as they connect to a TCP/IP internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: On a larger network, an NMS may be a separate, high-powered TCP/IP computer
    dedicated to network management. However, it is really software that makes a device
    into an NMS, so the NMS may not be a separate hardware device. It may act as an
    NMS and also perform other functions on the network.
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP operational model This diagram shows a simplified implementation of
    SNMP, with one network management station (NMS) used to maintain three managed
    nodes. Each device has an SNMP entity, and they communicate using SNMP messages.
    The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).](httpatomoreillycomsourcenostarchimages288225.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 65-1. SNMP operational model This diagram shows a simplified implementation
    of SNMP, with one network management station (NMS) used to maintain three managed
    nodes. Each device has an SNMP entity, and they communicate using SNMP messages.
    The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP allows a network administrator using a *network management
    station (NMS)* to control a set of managed nodes. Each device incorporates an
    *SNMP entity* that implements the technology. In an NMS, the entity consists of
    an *SNMP manager* module and a set of SNMP applications. In a managed node, the
    entity consists of an SNMP agent and *management information base (MIB)*.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Internet Standard Management Framework Architecture and Protocol Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Internet Standard Management Framework encompasses all of the technologies
    that compose the TCP/IP network management solution. The SNMP Framework consists
    of a number of architectural components that define how management information
    is structured, how it is stored, and how it is exchanged using the SNMP protocol.
    The Framework also describes how the different components fit together, how SNMP
    is to be implemented in network devices, and how the devices interact.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Framework Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we will explore in more detail in the next chapter, the Internet Standard
    Management Framework is entirely *information-oriented*. It includes four primary
    components (see [Figure 65-2](ch65s03.html#components_of_the_tcpip_internet_standar
    "Figure 65-2. Components of the TCP/IP Internet Standard Management Framework")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure of Management Information (SMI)** To ensure interoperability of
    various devices, we want to have a consistent way of describing the characteristics
    of devices to be managed using SNMP. In computer science, a *data description
    language (DDL)* is the tool for this job. The *SMI* is a standard that defines
    the structure, syntax, and characteristics of management information in SNMP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Management Information Bases (MIBs)** Each managed device contains a set
    of variables that is used to manage it. These variables represent information
    about the operation of the device that is sent to an NMS, and/or parameters sent
    to the managed device to control it. The *MIB* is the full set of these variables
    that describe the management characteristics of a particular type of device. Each
    variable in a MIB is called a *MIB object*, and it is defined using the SMI data
    description language. A device may have many objects, corresponding to the different
    hardware and software elements it contains.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Initially, a single document defined the MIB for SNMP, but this model was
    inflexible. To allow new MIB objects to be more easily defined, groups of related
    MIB objects are now defined in separate RFC standards called* MIB modules. *More
    than 100 such MIB modules have been defined so far*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Network Management Protocol (SNMP)** This is the actual SNMP protocol
    itself. It defines how information is exchanged between SNMP agents and NMSs.
    The SNMP *protocol operations* define the various SNMP messages and how they are
    created and used. SNMP *transport mappings* describe how SNMP can be used over
    various underlying internetworks, such as TCP/IP, IPX, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security and Administration** To the previous three main architectural components,
    the SNMP Framework adds a number of supporting elements. These provide enhancements
    to the operation of the SNMP protocol for security and address issues related
    to SNMP implementation, version transition, and other administrative issues.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components of the TCP/IP Internet Standard Management Framework](httpatomoreillycomsourcenostarchimages288227.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 65-2. Components of the TCP/IP Internet Standard Management Framework
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The three main components of the Internet Standard Management
    Framework (SNMP Framework) are the Structure of Management Information (SMI),
    management information bases (MIBs), and the SNMP protocol itself. These are supported
    by SNMP security and administration elements.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Framework Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creators of SNMP specifically designed the Framework to be modular, because
    when SNMP was originally created, it was seen as only a temporary solution until
    a transition could be made to another network management protocol from the OSI
    protocol suite. The modular architecture separated definitional, data, and functional
    (protocol) elements, to allow the SNMP protocol itself to be replaced without
    changing how network management information was defined and described.
  prefs: []
  type: TYPE_NORMAL
- en: This transition to the OSI protocol never occurred, but the architecture has
    still proven valuable in defining the entire scope of SNMP and in making its implementation
    much simpler. Each of the major components discussed in the previous section—the
    SMI, MIBs, and SNMP itself—are described in different standards. The modularity
    of the SNMP Framework has also allowed changes to be made to these components
    relatively independently of each other, making the transition between SNMP versions
    easier than it would have been if one huge document defined everything.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Internet Standard Management Framework and SNMP Versions (SNMPv1, SNMPv2
    Variants, and SNMPv3)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS"),
    I explained the differences between proprietary, de facto, and open standards,
    and described the many benefits of open standards. History is replete with examples
    of technologies that have succeeded because they used an open standard when a
    competing standard was proprietary.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP and the Internet are often held up as a model for proper open-standards
    development. Thousands of TCP/IP standards have been developed and published using
    the well-known Request for Comments (RFC) standardization process. The result
    has been the most successful set of internetworking protocols in computing history,
    accepted and used worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Nobody is perfect, however, and no process is perfect either. Some problems
    occurred in the introduction of SNMP version 2, leading to a virtual breakdown
    in the normally smooth protocol standardization method, and a proliferation of
    incompatible variants that we aren't used to seeing in TCP/IP. The story behind
    this is a continuation of the general SNMP overview and history from earlier in
    this chapter, and it explains the many SNMP standard names and numbers, so you
    can make sense of them. At the same time, the discussion serves as a vivid reminder
    of how important proper standard development is, and what the consequences are
    when there isn't universal agreement on how a standard should evolve.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first version of SNMP was developed in early 1988 and published in the
    form of three RFC standards in August 1988\. This first version is now known as
    *SNMP version 1* or *SNMPv1*. The three SNMPv1 standards provided the initial
    description of the three main Internet Standard Management Framework components:
    the SMI, MIB, and SNMP protocol itself. However, the term *Internet Standard Management
    Framework* was not actually used at that time.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1 was generally accepted and widely deployed in many networks. SNMPv1 got
    the job done and became the standard for TCP/IP network management. It is still
    widely used today. It is the Old Faithful of SNMP versions. Slight revisions were
    made to the initial standards, and more and more MIB modules were defined over
    time, but the technology remained the same for a number of years.
  prefs: []
  type: TYPE_NORMAL
- en: As with any technology, users of SNMPv1 identified weaknesses in it and opportunities
    for improvement. One of the areas in which SNMPv1 was most criticized was the
    area of security. SNMPv1 used only a "trivial" (as RFC 3410 puts it) authentication
    scheme, employing a password-like construct called a *community string*.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of security turned out to be the bone of contention that eventually
    led to serious problems in the development of SNMP. Some people felt that community
    strings were sufficient security, but many others felt it was important that better
    security be put into SNMP. There were many different ways proposed to add security
    to SNMP, but no universal agreement on how to do it. The points raised about the
    security weaknesses in the original SNMPv1 had some validity, as I explore in
    the discussion of SNMP protocol operations in [Chapter 67](ch67.html "Chapter 67. TCP/IP
    SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION").
  prefs: []
  type: TYPE_NORMAL
- en: SNMPsec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first attempt to add security came in the form of three standards published
    in July 1992 that defined a new security mechanism using logical identifiers called
    *parties*. This is sometimes called *SNMP Security* or *SNMPsec*. This method
    was more secure than the original SNMPv1, but SNMPsec was never widely accepted,
    and it is now considered historical.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of party-based security never went away, however. It was used as the
    basis of the definition of the first full revision of SNMP, when *SNMP version
    2 (SNMPv2)* was published in RFCs 1441 through 1452 in April 1993\. This new version
    incorporated the new security model, as well as making changes to the actual SNMP
    protocol operations, changes to the SMI standard (defining version 2 of SMI, SMIv2),
    and formalizing the concept of the Internet Standard Management Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this new standard also was never universally accepted. Some people
    thought the whole new version was a great advance, but others took issue with
    the party-based security, claiming it was too complex. A great deal of debate
    and discussion took place over the next couple of years, as an attempt was made
    to get everyone on board with the new version.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2 Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Acceptance of SNMPv2 never happened. Instead, different splinter groups broke
    off and began work on *variants* of SNMPv2\. To prevent confusion, the original
    SNMPv2 became known as either *SNMPv2 classic* (reminiscent of the name a particular
    soft drink) or *SNMPv2p*, with the *p* referring to party-based security. Things
    got very interesting (and confusing) when the following were proposed and/or developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMPv1.5** You can tell immediately that an idea is probably going to be
    a problem when it proposes a version number lower than a number already standardized.
    SNMPv1.5 was an attempt to retain the uncontroversial elements in SNMPv2p—the
    enhancements to the SNMP protocol and SMI—while going back to community-based
    security as in SNMPv1\. It never became a standard itself, but became the basis
    of the next variant.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Community-Based SNMPv2 (SNMPv2c)** This is SNMPv2p modified to use community
    strings instead of party-based security; in essence, the same idea as SNMPv1.5,
    but with a more official-sounding name and a few changes. Interestingly, the standard
    that defines this, RFC 1901, still has an experimental status, despite the fact
    that SNMPv2c actually achieved some degree of commercial success, where the standard
    SNMPv2p did not. SNMPv2c was defined by standards RFC 1902 through 1908, which
    incorporate other changes, including a new version of SMI (SMIv2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Based SNMPv2 (SNMPv2u)** This is an alternative security method for
    SNMPv2c, which is based on users rather than community strings. It is considered
    simpler than party-based but more secure than community-string security. It is
    defined by RFC 1909 and RFC 1910\. It, too, is formally considered experimental.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMPv2*** As if all of the other variants were not enough, a well-known vendor
    decided to define another variant called *SNMPv2** that combined elements of SNMPv2p
    and SNMPv2u. This was never formally standardized. (Yes, that''s an asterisk in
    the name. No, there''s no footnote at the bottom of the page, so don''t bother
    looking for one. Yes, putting an asterisk in a name is extremely confusing. No,
    I don''t know how it is that marketing people get paid good money to come up with
    names like this.)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you were a network administrator in the mid-1990s and were
    faced with SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv2*. Which one would you choose?
    Well, if you are like most people, you would choose none of the above, saying,
    "I think I'll stick with SNMPv1 until these version 2 folks get their act together!"
    And that's basically what happened. Some proponents of these variations promoted
    them, but there was never any agreement, and the result was that the success of
    all of the various and sundry SNMPv2s was limited. As I said, this is a classic
    illustration of how important universal standardization is.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I would imagine that, at some point, everyone realized that the situation was
    a mess and decided enough is enough. In 1996, work began on a new approach to
    resolve the outstanding issues and return universality to SNMP. In 1998, *SNMP
    version 3 (SNMPv3)* was developed, which includes additional enhancements to SNMP
    and finally gets all the players back on the same team.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3 is the most current version of SNMP and is still being actively revised.
    One of the important changes in SNMPv3 is a more formalized way of handing different
    security approaches to SNMP—obviously, a lesson learned from the SNMPv2 experience.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3 uses SNMPv2 protocol operations and its protocol data unit (PDU) message
    format, and the SMIv2 standard from SNMPv2 as well. SNMPv3 allows a number of
    different security methods to be incorporated into its architecture, and includes
    standards describing user-based security as defined in SNMPv2u and SNMPv2*, as
    well as a new view-based access control model. It also includes additional tools
    to aid in the administration of SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Internet Standard Management Framework and SNMP Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've now seen that there are three different versions of the Internet Standard
    Management Framework. Some of these versions have different variants. Each version
    or variant of the Framework includes multiple modular components. Each component
    has one or more documents that define it. Some of these have multiple revisions.
    Add to that dozens of individual MIBs defined for SNMP and other support documents,
    and what do you have? A boatload of TCP/IP standards, that's what. There are probably
    more RFCs defining parts of SNMP than any other single TCP/IP protocol or technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is specifically because there are so many versions and components and documents
    associated with SNMP that I feel it is important to keep all the standards straight.
    To that end, Tables [Table 65-1](ch65s05.html#snmp_version__snmpv_standards "Table 65-1. SNMP
    Version 1 (SNMPv1) Standards") through [Table 65-6](ch65s05.html#snmp_version__snmpv_standards-id001
    "Table 65-6. SNMP Version 3 (SNMPv3) Standards") show the major SNMP standards
    for each of the versions and variants of the SNMP Framework: SNMPv1, SNMPsec,
    SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv3\. (SNMPv2* was not standardized using the
    regular RFC process.) Each individual RFC defines one component of one version
    of the Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: The usual way that RFCs work is that when new versions of a standard are released
    that are direct replacements for older ones, the older ones are obsoleted by the
    new ones. With SNMP, due to the many versions and the controversy over the variants,
    this is a bit unclear. For example, the standards defining SNMPv2p are not considered
    by the IETF to obsolete the standards for SNMPv1, but the IETF says the standards
    for SNMPv2c and SNMPv2u do obsolete those of SNMPv2p.
  prefs: []
  type: TYPE_NORMAL
- en: To keep all of this distinct, I decided to show the standards for each version
    or variant separately. I put the RFC numbers for obsolete RFCs only where those
    RFCs are for the same SNMP version or variant. For example, RFC 3410 obsoletes
    2570 because they both deal with SNMPv3 and 3410 is a direct replacement for 2570\.
    Also, there are a few cases where the name of a standard changed slightly between
    RFC numbers; I have shown the current name. A full, hyperlinked list of RFCs can
    be found at [http://www.rfc-editor.org/rfc-index.html](http://www.rfc-editor.org/rfc-index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Table 65-1. SNMP Version 1 (SNMPv1) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1065 | 1155 | May 1990 | Structure and Identification of Management Information
    for TCP/IP-Based Internets |'
  prefs: []
  type: TYPE_TB
- en: '| 1066 | 1156 | May 1990 | Management Information Base for Network Management
    of TCP/IP-Based Internets |'
  prefs: []
  type: TYPE_TB
- en: '| 1067, 1098 | 1157 | May 1990 | Simple Network Management Protocol (SNMP)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1158 | 1213 | March 1991 | Management Information Base for Network Management
    of TCP/IP-Based Internets: MIB-II |'
  prefs: []
  type: TYPE_TB
- en: Table 65-2. SNMP Security (SNMPsec) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1351 | July 1992 | SNMP Administrative Model |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1352 | July 1992 | SNMP Security Protocols |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1353 | July 1992 | Definitions of Managed Objects for Administration
    of SNMP Parties |'
  prefs: []
  type: TYPE_TB
- en: Table 65-3. Party-Based SNMP Version 2 (SNMPv2p) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1441 | April 1993 | Introduction to Version 2 of the Internet-Standard
    Network Management Framework |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1442 | April 1993 | Structure of Management Information for Version 2
    of the Simple Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1443 | April 1993 | Textual Conventions for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1444 | April 1993 | Conformance Statements for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1445 | April 1993 | Administrative Model for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1446 | April 1993 | Security Protocols for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1447 | April 1993 | Party MIB for Version 2 of the Simple Network Management
    Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1448 | April 1993 | Protocol Operations for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1449 | April 1993 | Transport Mappings for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1450 | April 1993 | Management Information Base for Version 2 of the
    Simple Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1451 | April 1993 | Manager-to-Manager Management Information Base |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1452 | April 1993 | Coexistence Between Version 1 and Version 2 of the
    Internet-Standard Network Management Framework |'
  prefs: []
  type: TYPE_TB
- en: Table 65-4. Community-Based SNMP Version 2 (SNMPv2c) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1901 | January 1996 | Introduction to Community-Based SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1902 | January 1996 | Structure of Management Information for Version
    2 of the Simple Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1903 | January 1996 | Textual Conventions for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1904 | January 1996 | Conformance Statements for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1905 | January 1996 | Protocol Operations for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1906 | January 1996 | Transport Mappings for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1907 | January 1996 | Management Information Base for Version 2 of the
    Simple Network Management Protocol (SNMPv2) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1908 | January 1996 | Coexistence between Version 1 and Version 2 of
    the Internet-Standard Network Management Framework |'
  prefs: []
  type: TYPE_TB
- en: Table 65-5. User-Based SNMP Version 2 (SNMPv2u) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1909 | February 1996 | An Administrative Infrastructure for SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: '| — | 1910 | February 1996 | User-Based Security Model for SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: Table 65-6. SNMP Version 3 (SNMPv3) Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | 2576 | March 2000 | Coexistence between Version 1, Version 2, and Version
    3 of the Internet-Standard Network Management Framework |'
  prefs: []
  type: TYPE_TB
- en: '| — | 2578 | April 1999 | Structure of Management Information Version 2 (SMIv2)
    |'
  prefs: []
  type: TYPE_TB
- en: '| — | 2579 | April 1999 | Textual Conventions for SMIv2 |'
  prefs: []
  type: TYPE_TB
- en: '| — | 2580 | April 1999 | Conformance Statements for SMIv2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2570 | 3410 | December 2002 | Introduction and Applicability Statements for
    Internet-Standard Management Framework |'
  prefs: []
  type: TYPE_TB
- en: '| 2261, 2271, 2571 | 3411 | December 2002 | An Architecture for Describing
    Simple Network Management Protocol (SNMP) Management Frameworks |'
  prefs: []
  type: TYPE_TB
- en: '| 2262, 2272, 2572 | 3412 | December 2002 | Message Processing and Dispatching
    for the Simple Network Management Protocol (SNMP) |'
  prefs: []
  type: TYPE_TB
- en: '| 2263, 2273, 2573 | 3413 | December 2002 | Simple Network Management Protocol
    (SNMP) Applications |'
  prefs: []
  type: TYPE_TB
- en: '| 2264, 2274, 2574 | 3414 | December 2002 | User-Based Security Model (USM)
    for Version 3 of the Simple Network Management Protocol (SNMPv3) |'
  prefs: []
  type: TYPE_TB
- en: '| 2265, 2275, 2575 | 3415 | December 2002 | View-Based Access Control Model
    (VACM) for the Simple Network Management Protocol (SNMP) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 3416 | December 2002 | Version 2 of the Protocol Operations for the Simple
    Network Management Protocol (SNMP) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 3417 | December 2002 | Transport Mappings for the Simple Network Management
    Protocol (SNMP) |'
  prefs: []
  type: TYPE_TB
- en: '| — | 3418 | December 2002 | Management Information Base (MIB) for the Simple
    Network Management Protocol (SNMP) |'
  prefs: []
  type: TYPE_TB
- en: In addition to all of the standards listed in these tables, there are dozens
    of supplemental RFCs that describe MIB modules and also clarify various fine points
    of operation related to SNMP. You can find all the MIBs in an online list of RFCs
    by searching for "MIB" or "SNMP."
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT
    INFORMATION BASES (MIBS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Internet Standard Management Framework defines three major components that
    describe how devices can be managed on a TCP/IP internetwork. One of these, the
    actual Simple Network Management Protocol (SNMP) is relatively well known, but
    is only part of the overall picture. SNMP describes how information is exchanged
    between SNMP entities, but two other components are equally important, because
    they describe the information itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I describe these two important supporting elements of the
    TCP/IP Internet Standard Management Framework: the Management Information Base
    (MIB) standard that describes types of information that SNMP works with, and the
    Structure of Management Information (SMI) standard that specifies how MIB information
    is defined. Understanding these two parts of the SNMP Framework is an important
    initial step before we examine the actual SNMP protocol itself.'
  prefs: []
  type: TYPE_NORMAL
- en: I begin with an overview description of the SMI data description language and
    how MIBs work. I discuss the MIB object name hierarchy and the notation used to
    refer to names. I also describe how MIB objects work, discussing the different
    object types and MIB object groups. I describe MIB concepts common to all of the
    versions of SNMP, and discuss both of the specific versions of SMI (SMIv1 and
    SMIv2) used in those SNMP versions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *If you have not yet already read the preceding
    chapter describing the SNMP Internet Standard Management Framework, you should
    do so before proceeding here*.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP SMI and MIBs Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to really understanding TCP/IP network management is to comprehend the
    *information-oriented* nature of the entire Internet Standard Management Framework
    (SNMP Framework). To see what I mean by this, let's step back for a moment and
    consider in general terms the problem of network management, and more specifically,
    the problem of managing devices on a network.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP's Information-Oriented Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A network administrator needs to perform two basic types of actions: gather
    data about devices to learn how they are functioning and give commands to devices
    to change how they are functioning. In the simplest terms, the first category
    can be considered as a read operation, and the second is comparable to a write
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: A classic way of implementing this functionality is to define a communication
    protocol. Most such protocols are *command-oriented*—they consist of a specific
    set of commands to perform the read and write operations. For example, a network
    management protocol might have a read command such as "report on number of hours
    device has been in use," and a write command might be something like "put this
    device into test mode." The network manager would control the device by giving
    the appropriate commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'A command-oriented management protocol has the advantage of simplicity, since
    it''s clear what the commands are for and how they are to be used. It can be reasonably
    well suited for use in certain environments, but it doesn''t work well on a large,
    heterogeneous TCP/IP internetwork. The main reason for this is that command-orientation
    inextricably ties the protocol to the devices being managed. Consider the following
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Every type of device might require a distinct set of commands. For example,
    the commands given to a router might need to be different than those given to
    a host. This would lead either to a proliferation of commands in the protocol
    or to inflexibility in allowing proper management of different device types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time a company created a new type of device, or made a unique version
    of a type of device, the network management protocol would need to be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the operation of a kind of device changed, due perhaps to a change
    in another protocol, the management protocol would need to be updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protocol itself could not be easily changed without affecting a lot of hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to the problems of command-oriented management protocols is to
    use an *information-oriented* model. Instead of defining specific commands that
    interrogate or control devices, the devices are defined in terms of units of information
    that are to be exchanged between the devices and a management station.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of read commands and write commands, we have *variables* that can be
    read or written. Take the two examples mentioned earlier. Instead of a command
    like "report on a number of hours device has been in use," the device keeps a
    variable called "number of hours in use," and the network management station can
    read this as one of many variables, with no need for a specific protocol command.
    Instead of a write command called "put this device into test mode," the device
    has a variable called "current mode." The network manager can change the mode
    of the device to test mode by changing the value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: This difference may seem subtle, but it underlies every aspect of how SNMP works.
    I believe part of why the SNMP Framework is hard to understand is because insufficient
    emphasis is placed on looking at things in the "SNMP way," which means thinking
    about information objects and not commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Unlike most protocols, which are *command-oriented*, SNMP is
    *information-oriented*. SNMP operations are implemented using objects called *variables*
    that are maintained in managed devices. Rather than issuing commands, a network
    management station checks the status of a device by reading variables, and controls
    the operation of the device by changing (writing) variables.'
  prefs: []
  type: TYPE_NORMAL
- en: MIB and MIB Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given this backdrop, we can look at the SNMP Framework in a new light. The actual
    SNMP protocol itself, which we'll examine in the next couple of chapters, has
    only a few, generic commands to accomplish read and write tasks. It deals with
    only the methods by which network management information is exchanged between
    SNMP agents and SNMP network management stations (NMSs), which were described
    in the previous chapter. The network management information is really the heart
    of TCP/IP network management.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of SNMP being defined in terms of commands used to control particular
    devices, it is defined in terms of management information variables, generally
    called *objects*. Each object describes a particular characteristic of a device.
    Some objects are fairly generic and are meaningful for any device on a TCP/IP
    network; for example, an object describing something related to the Internet Protocol
    (IP) itself, such as the device's IP address. Other objects might be particular
    to a specific type of device; for example, a router will have objects that a regular
    host's Ethernet network interface card would not.
  prefs: []
  type: TYPE_NORMAL
- en: A collection of objects used in SNMP is called a *management information base*,
    or *MIB*. (In fact, SNMP objects are often called *MIB objects*.) The first version
    of SNMP, SNMPv1, had a single standard that defined the entire MIB for SNMP. Newer
    versions provide more flexibility by using different *MIB modules* that define
    sets of variables particular to the hardware or software used by a device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The management data variables in a managed device are maintained
    in a logical collection called a *management information base (MIB)*. The objects
    in the MIB are often called *MIB objects*, and they are typically collected into
    sets called *MIB modules*.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining objects using modules allows for significant flexibility in defining
    the variables that allow management of different types of devices. A device can
    incorporate all the MIB modules appropriate to the hardware and software it uses.
    For example, if you had a device using Ethernet, it would incorporate variables
    from the Ethernet MIB. A device using Token Ring would use the Token Ring MIB.
    Both devices would also use the common SNMP MIB that is used by all TCP/IP devices.
    Other modules might also be included as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Due to its name, the MIB is often called a database. This is, strictly speaking,
    inaccurate. The MIB is a description of objects. The actual MIB in a device may
    be implemented as a software database, but that is not required*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining MIB Objects: SMI'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of MIB objects solves the problem of the network management protocol
    being tied to the network management information. However, we must be very particular
    about how we define these objects. Again, the reason is the wide variety of devices
    that TCP/IP allows to be connected together. Each device may represent information
    in a different way. For all of them to communicate with each other, we need to
    ensure that management information is represented in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the SNMP Framework that ensures the universality of MIB objects
    is the *Structure of Management Information (SMI)* standard. SMI defines the rules
    for how MIB objects and MIB modules are constructed. In SMI, MIB objects are described
    using a precise set of definitions based on a data description language called
    the ISO *Abstract Syntax Notation 1 (ASN.1)* standard.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, we really have three levels of abstraction in SNMP. The actual SNMP
    protocol moves values that represent the state of management devices. The MIB
    defines what these variables are. And the SMI defines how the variables in the
    MIB are themselves defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main SMI standards. The original, *SMIv1*, was part of the first
    SNMP Framework, SNMPv1, defined in RFC 1155\. It sets out the basic rules for
    MIBs and MIB variables. The second, *SMIv2*, was defined as part of SNMPv2p in
    RFC 1442 and further updated in RFC 2578, part of SNMPv3\. It is similar to the
    earlier version, but defines more object types, as well as the structure of MIB
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'These SMI standards are responsible for defining the following important information
    elements in SNMP:'
  prefs: []
  type: TYPE_NORMAL
- en: The general characteristics associated with all MIB objects—the standard way
    by which all MIB objects are described
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of MIB objects that can be created, such as integers, strings,
    and more complex data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hierarchical structure for naming MIB objects, so they can be addressed in
    a consistent manner without names overlapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information associated with each MIB module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Structure of Management Information (SMI)* standard is
    responsible for defining the rules for how MIB objects are structured, described,
    and organized. SMI allows dissimilar devices to communicate by ensuring that they
    use a universal data representation for all management information.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP MIB Objects, Object Characteristics, and Object Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in the previous sections, the SNMP Framework is designed to facilitate
    the exchange of management information. The MIB defines a device's management
    information and contains a number of variables called *MIB objects*, also called
    *managed objects*. These objects are defined according to the rules set out in
    the SMI standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to begin looking at MIB objects is by examining the SMI rules
    that define them. As I mentioned earlier in this chapter, two different versions
    of SMI have been created: SMIv1 as part of the original SNMP, and SMIv2 as part
    of SNMPv2 and SNMPv3\. The two are similar in terms of how MIB objects are described,
    but SMIv2 allows more information to be associated with each object.'
  prefs: []
  type: TYPE_NORMAL
- en: MIB Object Characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as a typical protocol uses a field format for specifying the content of
    messages sent between devices using the protocol, SMI uses a format that specifies
    the fundamental characteristics of each MIB object. The most basic of these are
    five mandatory characteristics defined in SMIv1\. These are also used in SMIv2,
    but a couple of names were changed, and the possible values for some of the fields
    were modified as well. An MIB object may have the following characteristics (see
    [Figure 66-1](ch66s02.html#snmp_management_information_base_mib_thi "Figure 66-1. SNMP
    management information base (MIB) This diagram shows an SNMP MIB containing N
    MIB objects. Each object has five mandatory characteristics and a variable number
    of optional characteristics.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Name** Each object has a name that serves to uniquely identify it.
    Actually, that''s not entirely true. Each object has *two* names: a textual name
    called an *object descriptor* and a numeric *object identifier*, which indicates
    the object''s place in the MIB object name hierarchy. We''ll explore these names
    and how they are used shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax** Defines the object''s data type and the structure that describes
    it. This attribute is very important because it defines the data type of information
    that the object contains. There are two basic categories of data types allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular data types are single pieces of information, of the type we are used
    to dealing with on a regular basis, such as integers and strings. These are called
    *base types* in SMIv2\. SMIv1 differentiates between *primitive types* like integers
    defined in ASN.1, and *defined types* that are special forms of primitive types
    that are still single pieces of information but with certain special meaning attached
    to how they are used. SMIv2 doesn't use those two terms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabular data types are collections of multiple data elements. They may take
    the form of a list of base types or a table of base types. For example, a table
    of integers could be constructed to represent a set of values. In SMIv1, these
    are called *constructor types*; in SMIv2 they are *conceptual tables*. They can
    be accessed using special SNMP mechanisms designed for reading tables. See the
    topic on SNMP table traversal for more on tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access (Max-Access in SMIv2)** This field defines the ways that an SNMP application
    will normally use the object. In SMIv1, there are four different possible values:
    *read-only*, *read-write*, *write-only*, and *not-accessible*. In SMIv2 there
    are five values, which are described as a hierarchy of sorts. SMIv2 calls this
    characteristic *Max-Access* (*maximum access*) to make it explicit that higher
    access levels include the lower levels as well. For example, an object with read-create
    access can also be used in any of the modes below it, such as read-write, but
    not vice versa. The following are the five SMIv2 access values, in decreasing
    order of access (note that write-only has been removed in SMIv2):'
  prefs: []
  type: TYPE_NORMAL
- en: '*read-create* (object can be read, written, or created)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*read-write* (object can be read or written)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*read-only* (object can only be read)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*accessible-for-notify* (object can be used only using SNMP notification or
    SNMP traps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*not-accessible* (used for special purposes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status** Indicates the currency of the object definition. In SMIv1 there
    are three values: *mandatory*, *optional*, and *obsolete*. In SMIv2, the first
    two are combined into simply *current*, meaning a current definition. The value
    *obsolete* is retained, and *deprecated* is added, meaning the definition is obsolete
    but maintained for compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition (Description in SMIv2)** A textual description of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Characteristics** SMIv2 adds the following optional characteristics
    that may appear in the definition of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Units* is a textual description of the units associated with the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reference* is a text cross-reference to a related document or other information
    relevant to the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Index* is a value used to define objects that are actually more complex rows
    of other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Augments* is an alternative to the Index field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DefVal* defines an acceptable default value for the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each management information variable, called an *MIB object*,
    has associated with it five key attributes: its name, syntax, maximum access,
    status, and definition. It may also have a number of optional characteristics.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP management information base (MIB) This diagram shows an SNMP MIB containing
    N MIB objects. Each object has five mandatory characteristics and a variable number
    of optional characteristics.](httpatomoreillycomsourcenostarchimages288229.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 66-1. SNMP management information base (MIB) This diagram shows an SNMP
    MIB containing N MIB objects. Each object has five mandatory characteristics and
    a variable number of optional characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: SMI Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 66-1](ch66s02.html#snmp_smi_regular_data_types "Table 66-1. SNMP SMI
    Regular Data Types") shows the regular data types supported for objects in both
    SMIv1 and SMIv2\. (The names with 32 in them are the ones used in SMIv2; they
    were changed to make the type''s bit size explicit.) The first five entries in
    the table are primitive types; the rest are defined types, using the SMIv1 terminology.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 66-1. SNMP SMI Regular Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '| Data Type Code | Description | In SMIv1? | In SMIv2? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Integer/Integer32 | A 32-bit signed integer in two''s complement notation,
    capable of holding a value from -2,147,483,648 to +2,147,483,647\. Can also be
    used to represent an enumerated type; for example, where 1 represents a particular
    constant, 2 represents a different one, and so on. | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Octet String | A variable-length string of binary or text data. | Yes | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| Null | Nothing. | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Bits | An enumeration of named bits. Used to allow a set of bit flags to
    be treated as a single data type. | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned | A 32-bit unsigned integer, from 0 to 4,294,967,295. | No | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| Network Address/IpAddress | An IP address, encoded as a 4-byte octet string.
    | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Counter/Counter32 | A 32-bit unsigned integer that begins at 0 and increases
    up to 4,294,967,295, then wraps back to 0. | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Gauge/Gauge32 | A 32-bit unsigned integer that may have a value from 0 to
    4,294,967,295 and may increase or decrease, like a gauge. A minimum and maximum
    value are associated with the gauge, indicating its normal range. | Yes | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| TimeTicks | A 32-bit unsigned integer that indicates the number of hundredths
    of seconds since some arbitrary start date. Used for timestamping and to compute
    elapsed time. | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Opaque | Data using arbitrary ASN.1 syntax that is to be passed between devices
    without being interpreted. As in the Network File System''s (NFS) XDR (see [Chapter 58](ch58.html
    "Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM
    (NFS)")), the term opaque means that the data is treated like a black box, whose
    internal details cannot be seen. | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Counter64 | A counter like Counter32 but 64 bits wide, allowing a value from
    0 to 18,446,744,073,709,551,615. | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: In addition to the types shown in [Table 66-1](ch66s02.html#snmp_smi_regular_data_types
    "Table 66-1. SNMP SMI Regular Data Types"), other defined types are also created
    to indicate more specific semantics for a particular data type. These are called
    *textual conventions* and are described in RFC 2579 for SMIv2\. For example, a
    type called *TimeStamp* is the same as *TimeTicks*. However, seeing an object
    using the former rather than the latter makes it more clear that the variable
    is representing a particular timestamp value. Another is called *TimeInterval*,
    which is also just an integer underneath its name, but conveys a different interpreted
    meaning.
  prefs: []
  type: TYPE_NORMAL
- en: If all of this seems very confusing to you, note that this description is actually
    a significant simplification of SMI's object definitions. Check out [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"), which shows an object definition
    from RFC 3418, using SMIv2.
  prefs: []
  type: TYPE_NORMAL
- en: Example 66-1. Example SNMP SMIv2 object definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that `DisplayString` is a textual convention for a displayed text string.
    The last part, `{ system 6 }`, will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP MIB Object Descriptors and Identifiers and the Object Name Hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the many MIB object characteristics, only one is sufficiently interesting
    that it really deserves its own exposition. Or perhaps I should say that only
    one is sufficiently complicated to require further explanation. This is the object
    name, part of the larger naming system used for MIB objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each MIB object actually has two names: an *object descriptor* and an *object
    identifier*.'
  prefs: []
  type: TYPE_NORMAL
- en: Object Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object descriptor is a conventional text name that provides a user-friendly
    handle to refer to the object. The name is assigned based on the particular MIB
    object group in which the object is located. In the previous example, `sysLocation`
    is the object descriptor for that MIB object. I describe these names in greater
    detail later in this chapter, when I discuss MIB modules and object groups.
  prefs: []
  type: TYPE_NORMAL
- en: Object Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text names are convenient, but they are generally unstructured. There are at
    present more than 10,000 different MIB objects, and even if each has a distinct
    text name, a huge collection of such names doesn't help us to manage these objects
    and see how they are related. For this, we need a more structured approach to
    categorizing and naming objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is similar to another problem that you may recall reading about:
    the problem of how to assign names on the Internet. Originally, names for hosts
    were simple, flat names, but this quickly grew unwieldy. The DNS hierarchical
    name space (see [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE,
    AND TERMINOLOGY")) allows every device to be arranged into a single hierarchical
    tree structure. The name of the device can be formed by traversing the tree from
    the top down to the location of the device, listing the labels traversed separated
    by dots. For example, the web server of The PC Guide is at [http://www.pcguide.com](http://www.pcguide.com).'
  prefs: []
  type: TYPE_NORMAL
- en: This same concept is used to organize MIB objects in SNMP. A single, universal
    hierarchy that contains all MIB objects is used. It is hierarchical in nature,
    and it is split into levels from the most general to the most specific. Each object
    has a particular place in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important difference between the MIB name hierarchy and the DNS
    one: the MIB name hierarchy is even more universal than the one for DNS. The entire
    subtree of all MIB objects is just one branch of the full, international object
    hierarchy maintained by the International Organization for Standardization (ISO)
    and the International Telecommunication Union (ITU). This object identification
    hierarchy is so general that it can contain a name for every object or variable
    in use by any technology in the entire world (and possibly other planets or solar
    systems).'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for my jocularity will become apparent in a moment. Suffice it to
    say that this object tree is enormous. Each node in this tree is identified with
    both a label and an integer. The labels are for descriptive purposes. Object (or
    subtree) identifiers are formed by listing the numbers in sequence from the top
    of the tree down to the node, separated by dots. SNMP doesn't reverse the order
    of the labels the way DNS does, however. They are listed top-down from left to
    right. (The text labels can be used for names, too, but they are not because they
    would get very long due to how deep the tree structure is.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP MIB objects have two names. The first is a text *object
    descriptor*, which provides a means of addressing the object in a way that is
    familiar and easy for humans. The second is the *object identifier*, which consists
    of a sequence of integers that specifies the location of the object in the global
    object hierarchy maintained by the international standards bodies ISO and ITU.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the MIB Object Name Hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore how the MIB object tree is structured, and more important, how
    SNMP MIB objects fit into it. [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.") illustrates the global object name hierarchy and SNMP
    MIB hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Global object name hierarchy and SNMP MIB hierarchies This diagram shows
    the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of
    objects to be universally represented. The path within this larger tree to the
    tree branches relevant to SNMP can be found by following the shaded boxes. The
    two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each
    contains its own substructure (some of which is illustrated here) defining thousands
    of different MIB objects. The branch on the left side is used for generic MIB
    objects and the one on the right for private ones. A separate hierarchy is also
    defined for SNMPv2.](httpatomoreillycomsourcenostarchimages288231.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree''s root has no label, and has three children:'
  prefs: []
  type: TYPE_NORMAL
- en: ccitt(0) for ITU (formerly the CCITT) standards (also seen as itu(0)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iso(1) for ISO standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: joint-iso-ccitt(2) for joint standards (also seen as joint-iso-itu(2)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the iso(1) node, we see the following at the next several levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Within iso(1), the ISO has created a subtree for use by other organizations,
    called org(3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within org(3), there is a subtree for the United States Department of Defense
    (which, as you may recall, was the originator of the Internet): dod(6).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within dod(6), there is a subtree called internet(1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything we work with in SNMP is under this one very specific subtree: 1.3.6.1,
    which if we used the text labels would be iso.org.dod.internet. Within this part
    of the name space, there are six subtrees below:'
  prefs: []
  type: TYPE_NORMAL
- en: directory(1) is reserved for future use by ISO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mgmt(2) is the primary subtree where MIB objects are located. This is 1.3.6.1.2\.
    It contains a subtree called mib(1), which is 1.3.6.1.2.1\. When MIB-II was created,
    a subtree called mib-2(1) was created using the same number, 1.3.6.1.2.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: experimental(3) contains objects used for standards under development. This
    is 1.3.6.1.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private(4) is used for objects defined by private companies. This node, 1.3.6.1.4,
    has a subtree called enterprise(1), which is 1.3.6.1.4.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: security(5) is reserved for security use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: snmpV2(6) defines objects used specifically for SNMP version 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what''s the bottom line of all this? Well, basically all MIB module objects
    are named within one of these two branches of the overall object tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular MIB Objects** These are in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private MIB Objects** These are in the enterprise(1) subtree under private(4),
    which is 1.3.6.1.4.1\. For example, within enterprise(1), there is an entry cisco(9)
    for Cisco Systems. So all Cisco-specific MIB objects start with 1.3.6.1.4.1.9.'
  prefs: []
  type: TYPE_NORMAL
- en: Clear as mud, right? Why didn't they just make a separate hierarchy where "mib"
    was at the top instead of six levels deep? How dare you even suggest such a thing?
    Don't you understand the importance of global standards?
  prefs: []
  type: TYPE_NORMAL
- en: All facetiousness aside, this name hierarchy is a bit cumbersome to deal with
    (okay, more than a bit), but it does allow us to keep MIB objects organized in
    a sensible way. Within the 1.3.6.1.2.1 subtree, we find most of the regular MIB
    objects used in SNMP. Each subtree within 1.3.6.1.2.1 corresponds to one of the
    regular SNMP object groups or a particular MIB module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** All MIB objects have object identifiers that fit within two
    branches of the global object hierarchy. Regular MIB objects (which are not vendor-specific)
    fit in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1\. Private objects, which
    can be created by a hardware vendor to assist in managing that vendor''s products,
    are in the enterprise(1) subtree under private(4), which is 1.3.6.1.4.1.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Definition of MIB Object Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object is given a text object descriptor by putting its name at the start
    of the object, as shown in [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"), but the definition of numeric
    object identifiers is, again, more complex. It is done by defining only the number
    of the object within its particular subtree. This means the object identifiers
    are defined recursively (one based on another) and are not explicitly stated for
    each object. This is syntactically precise, but makes it hard to see at a glance
    what the number is for any particular object.
  prefs: []
  type: TYPE_NORMAL
- en: Consider again the example in [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"). For this object, `sysLocation`
    is the object descriptor and `{ system 6 }` is the object identifier. This means
    it is object number 6 within the node system, which is in turn defined as `{ mib-2
    1 }`—it is the first node within the mib-2 subtree. Since mib-2 is 1.3.6.1.2.1,
    as noted in the previous section, this means `system` is 1.3.6.1.2.1.1 and `sysLocation`
    is 1.3.6.1.2.1.1.6.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP MIB Modules and Object Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MIB contains the collection of MIB objects that describe the characteristics
    of a device using the SNMP Framework. When SNMP was first created, there were
    not that many objects in the MIB. Furthermore, they were mostly generic objects
    that applied fairly universally to TCP/IP devices as a whole. In fact, most of
    the MIB objects were variables related to the operation of TCP/IP protocols such
    as IP, the Transmission Control Protocol (TCP), and the Internet Control Message
    Protocol (ICMP).
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, at first, a single document defined "the" MIB for SNMP. The
    first of these documents was RFC 1066, part of the initial SNMPv1 specification.
    It was then revised in RFC 1156\. In RFC 1158, a second version of the MIB, *MIB
    II*, was defined, which was essentially the same but made a few changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Organization of MIB Objects into Object Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number of MIB objects defined in the early MIB standards was relatively
    small. However, there were still several dozen of them, and it was recognized
    from the start that more would be created in time. To help organize the objects
    in a logical way, they were arranged into *object groups*. These groups serve
    the purpose of separating the objects and defining how they should be given object
    identifiers in the overall object name hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each group has associated with it three important pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group Name** This is a name that is used as a text label in the object identification
    tree described earlier in this chapter (see [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.")). These objects are all located within the iso.org.dod.internet.mgmt.mib
    subtree. So, for example, the group system would be iso.org.dod.internet.mgmt.mib.system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group Number** This number corresponds to the group name used for making
    numeric identifiers from the object name tree. For example, the group system has
    the number 1, and so the group''s object identifier is 1.3.6.1.2.1.1\. All objects
    in that group will be under that tree; for example, `sysUpTime` is 1.3.6.1.2.1.1.3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group Code** This is a text label that may be the same as the group name
    or may be an abbreviation. It is used as a prefix in making object descriptors
    (the text names of objects). For example, for the group system, the code is `sys`,
    and so an object in this group is `sysUpTime`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 66-2](ch66s04.html#snmp_generic_mib_object_groups "Table 66-2. SNMP
    Generic MIB Object Groups") shows the eight generic SNMP groups defined in RFC
    1158, along with their codes, names, and numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 66-2. SNMP Generic MIB Object Groups
  prefs: []
  type: TYPE_NORMAL
- en: '| Group Name | Group Code | Group Number | Full Group Identifier | Description
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| system | `sys` | 1 | 1.3.6.1.2.1.1 | General objects of relevance to all
    or most devices. For example, a general description of the device is an object
    in this group, as is the identifier of the object. Later MIB versions greatly
    expanded the number of variables in this group. |'
  prefs: []
  type: TYPE_TB
- en: '| interfaces | `if` | 2 | 1.3.6.1.2.1.2 | Objects related to the IP interfaces
    between this device and the internetwork. (Recall that a regular host normally
    has one interface, while a router has two or more.) |'
  prefs: []
  type: TYPE_TB
- en: '| at (address translation) | `at` | 3 | 1.3.6.1.2.1.3 | Objects used for IP
    address translation. (No longer used.) |'
  prefs: []
  type: TYPE_TB
- en: '| ip | `ip` | 4 | 1.3.6.1.2.1.4 | Objects related to the IP layer of the device
    as a whole (as opposed to interface-specific information in the `if` group). |'
  prefs: []
  type: TYPE_TB
- en: '| icmp | `icmp` | 5 | 1.3.6.1.2.1.5 | Objects related to the operation of ICMP.
    |'
  prefs: []
  type: TYPE_TB
- en: '| tcp | `tcp` | 6 | 1.3.6.1.2.1.6 | Objects related to the operation of the
    TCP. |'
  prefs: []
  type: TYPE_TB
- en: '| udp | `udp` | 7 | 1.3.6.1.2.1.7 | Objects related to the operation of the
    User Datagram Protocol (UDP). |'
  prefs: []
  type: TYPE_TB
- en: '| egp | `egp` | 8 | 1.3.6.1.2.1.8 | Objects related to the operation of the
    Exterior Gateway Protocol (EGP). |'
  prefs: []
  type: TYPE_TB
- en: '| cmot | `cmot` | 9 | 1.3.6.1.2.1.9 | Objects related to running the CMIP protocol
    over TCP (historical, not used). |'
  prefs: []
  type: TYPE_TB
- en: '| transmission | `trans` | 10 | 1.3.6.1.2.1.10 | Objects related to the specific
    method of information transmission used by each interface on the system. |'
  prefs: []
  type: TYPE_TB
- en: '| snmp | `snmp` | 11 | 1.3.6.1.2.1.11 | Objects used to manage SNMP itself.
    |'
  prefs: []
  type: TYPE_TB
- en: All of the groups in this table are fairly generic, and with the exception of
    the one about EGP, apply to pretty much every TCP/IP system using SNMP. (The mention
    of EGP, a routing protocol now considered obsolete, shows the age of this list.)
    The first five groups and the last one are mandatory for all systems. The others
    are used only by devices that use the indicated protocols or functions.
  prefs: []
  type: TYPE_NORMAL
- en: MIB Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's most conspicuous about the object groups listed in [Table 66-2](ch66s04.html#snmp_generic_mib_object_groups
    "Table 66-2. SNMP Generic MIB Object Groups") is the groups that are not included.
    There are no groups for most of the other TCP/IP protocols, nor any for variables
    that might be needed for specific hardware types. For example, most hosts will
    have a network card in them using a layer 2 protocol like Ethernet or Token Ring.
    How does a manager check or control the operation of this hardware? What about
    newer routing protocols like Open Shortest Path First (OSPF) or Border Gateway
    Protocol (BGP)? How about objects related to running the Domain Name System (DNS)?
  prefs: []
  type: TYPE_NORMAL
- en: Updating the MIB document constantly would have been impractical. Instead, in
    SNMPv2, the MIB was changed from a single document to a group of documents. The
    basic organization into groups of objects was retained, but instead of all groups
    being in the same standard, they are divided into multiple standards. A method
    was also defined for how to create *MIB modules* that describe new groups of objects
    specific to a particular technology. A list of these modules is maintained by
    the *Internet Assigned Numbers Authority* (IANA), the organization that maintains
    all of these sorts of numbers. The current list of SNMP MIB modules can be found
    at [http://www.iana.org/assignments/smi-numbers](http://www.iana.org/assignments/smi-numbers).
  prefs: []
  type: TYPE_NORMAL
- en: The use of MIB modules makes putting SNMP support into a device somewhat like
    going shopping. The basic groups common to all devices are incorporated into each
    device, and then other modules/groups are used as needed. [Table 66-3](ch66s04.html#some_common_snmp_mib_modules
    "Table 66-3. Some Common SNMP MIB Modules") provides a brief selection of MIB
    modules to give you an idea of what is out there, also showing the module's group
    number (within the 1.3.6.1.2.1 name subtree). There are many, many more modules
    than listed in this table.
  prefs: []
  type: TYPE_NORMAL
- en: Table 66-3. Some Common SNMP MIB Modules
  prefs: []
  type: TYPE_NORMAL
- en: '| MIB Module Name | Group Number | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ospf` | 14 | Objects related to OSPF |'
  prefs: []
  type: TYPE_TB
- en: '| `bgp` | 15 | Objects related to BGP |'
  prefs: []
  type: TYPE_TB
- en: '| `rmon` | 16 | Objects used as part of Remote Network Monitoring (RMON) |'
  prefs: []
  type: TYPE_TB
- en: '| `snmpDot3 RptrMgt` | 22 | Objects related to IEEE 802.3 (Ethernet) repeaters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rip-2` | 23 | Objects used as part of version 2 of the Routing Information
    Protocol (RIP) |'
  prefs: []
  type: TYPE_TB
- en: '| `snmpDot3 MauMgt` | 26 | Objects related to IEEE 802.3 (Ethernet) medium
    attachment units |'
  prefs: []
  type: TYPE_TB
- en: '| `etherMIB` | 35 | Ethernet-like generic objects |'
  prefs: []
  type: TYPE_TB
- en: '| `mipMIB` | 44 | Mobile IP objects |'
  prefs: []
  type: TYPE_TB
- en: '| `ipMIB` | 48 | IP objects for SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: '| `tcpMIB` | 49 | TCP objects for SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: '| `udpMIB` | 50 | UDP objects for SNMPv2 |'
  prefs: []
  type: TYPE_TB
- en: The last three entries in [Table 66-3](ch66s04.html#some_common_snmp_mib_modules
    "Table 66-3. Some Common SNMP MIB Modules") might seem a bit confusing, since
    there were already groups for IP, TCP, and UDP, as shown in [Table 66-2](ch66s04.html#snmp_generic_mib_object_groups
    "Table 66-2. SNMP Generic MIB Object Groups"). The reason for these is that when
    the new modular architecture for MIB objects was created in SNMPv2, the definition
    of objects for the individual protocols that was part of the one document in SNMPv1
    was separated out into individual MIB documents for consistency and to allow them
    to be updated independently. In fact, the base SNMPv2 and SNMPv3 MIB documents
    now define only objects in the `system` and `snmp` groups.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** MIB objects created early in SNMP''s history were organized
    into *MIB object groups* that reside within the mib(1) subtree, starting with
    identifier code 1.3.6.1.2.1\. As the popularity of TCP/IP grew, it became impractical
    to centrally define all MIB objects, so sets of objects particular to different
    hardware devices are now specified in *MIB modules*.'
  prefs: []
  type: TYPE_NORMAL
- en: MIB Module Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format for MIB modules is described in the SMI standard, version 2 (SMIv2).
    This document specifies how modules are to be defined in a way similar to how
    objects themselves are defined: by listing a set of characteristics that must
    be included in each module description. The module fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module Name** The name of the module. Remember that modules are really objects,
    syntactically, so like regular objects, they have a textual object descriptor
    (like `tcpMIB`) and an object identifier (in the case of `tcpMIB`, the number
    50).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Last Updated** The date and time that the module was last revised.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organization** The name of the organization that is managing the development
    of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contact Information** The name, address, telephone number, and email address
    of the point person for this module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description** A description of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Revision and Revision Description** One Revision entry is placed for each
    revision of the module to show its history. Each entry has a description associated
    with it.'
  prefs: []
  type: TYPE_NORMAL
- en: After the definition of the module itself, the objects in the module are described.
    For an example, see RFC 2012, which defines the SNMPv2 TCP MIB.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The overall network management solution for TCP/IP networks is the Internet
    Standard Management Framework. In the previous two chapters, we have taken a look
    at the Framework as a whole, and also discussed the two components that define
    the management information transmitted between TCP/IP devices to accomplish network
    management. The third major part of the SNMP Framework is the actual *Simple Network
    Management Protocol (SNMP)*, which is responsible for moving management information
    between devices.
  prefs: []
  type: TYPE_NORMAL
- en: The core of the protocol consists of a set of *protocol operations* that allow
    management information to be exchanged between SNMP agents and managers. Having
    previously examined the generalities of SNMP and what management information base
    (MIB) objects are, we can now get down to the nitty gritty of how management information
    is actually communicated using SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I provide a detailed description of the operations performed
    by the SNMP protocol. I begin with a brief overview and history of the protocol.
    I then provide a general description of how SNMP operates and the two basic methods
    that devices use to communicate. I also describe SNMP''s message classes and the
    basic operations performed in SNMP: basic request/response, table traversal, object
    modification, and notification. I conclude with a discussion of SNMP security
    issues and a summary of the security methods in each of the SNMP versions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The number and types of protocol operations in SNMP changed between SNMPv1
    and SNMPv2\. The operations defined in SNMPv2 have been carried forward into the
    newest version, SNMPv3\. Most of the discussion focuses on SNMPv3 as the newest
    implementation, noting the differences between it and the original and still widely
    used SNMPv1*.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Protocol Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in the previous chapters, the SNMP Framework is often described
    as being *information-oriented*. A specific decision was made in the design of
    the SNMP Framework to decouple the management information conveyed between SNMP
    agents and SNMP managers from the protocol used to carry that information. This
    provides numerous benefits to the technology as a whole, chief among them flexibility
    and modularity.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the operation of the management protocol is *not* defined in
    terms of specific commands made to check the status of a device or change how
    it operates. Instead, the protocol is defined in terms of management information
    variables called *objects*, and a communication protocol that allows these objects
    to be either examined or changed by a network administrator. I describe this concept
    thoroughly in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The MIB and Structure of Management Information (SMI) spell out the rules for
    how MIB objects are created and described. These MIB objects describe the types
    of information that can be read from the device or written to the device. The
    last piece of the puzzle is the actual protocol that is responsible for these
    read- and write-type operations. This is SNMP itself, which I give the somewhat
    redundant name *SNMP protocol* to differentiate it from the SNMP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the separation of the protocol from the management information
    it carries is that the protocol itself becomes significantly reduced in complexity.
    Instead of the SNMP protocol needing to define dozens or even hundreds of operations
    that specify particular network management functions, it needs to deal with only
    the transmission of MIB object information between SNMP agents and managers. The
    SNMP protocol itself does not pay attention to what is in these objects; it is
    merely concerned with moving them around. In some ways, the SNMP protocol is the
    only really simple part of SNMP!
  prefs: []
  type: TYPE_NORMAL
- en: Early Development of SNMPv1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history of the SNMP protocol goes back to the predecessor of the SNMP Framework,
    the *Simple Gateway Monitoring Protocol (SGMP)*, which was defined in RFC 1028
    in 1987\. SGMP was designed as an interim solution for network management while
    larger issues were being explored, as I explained in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"). However, this standard is where
    many of the basic design concepts underlying the modern SNMP protocol can be found.
  prefs: []
  type: TYPE_NORMAL
- en: The SGMP standard specified the basic design model used in SNMP by describing
    SGMP in terms of only retrievals of, or alterations to, variables stored on an
    Internet gateway (router). The standard also outlines the small number of protocol
    operations that are still the basis for SNMP's operation today.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of the SNMP Framework, SNMPv1, included the first formal definition
    of the SNMP protocol in RFC 1067 (later revised by RFCs 1098 and 1157). This standard
    refines the protocol operations given in the SGMP document. It makes the operation
    of the SNMP protocol fit into the overall SNMP Framework, working with formally
    defined MIB objects.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2 and the Division of SNMP into Protocol Operations and Transport Mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When SNMPv2 was created, the single document describing the SNMP protocol was
    split into two standards, to make the protocol more modular and better reflective
    of the layers used in internetworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Operations** The first document of the pair describes the actual
    mechanics by which MIB objects are moved between SNMP devices using particular
    SNMP message types. In SNMPv3, it is RFC 3416, "Version 2 of the Protocol Operations
    for the Simple Network Management Protocol (SNMP)." When people talk about just
    "the SNMP standard," this is the document they usually mean.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport Mappings** The second document details how the SNMP protocol operations
    described in the first standard can be transported over a variety of different
    protocol suites. By using the correct mapping, SNMP operations can be carried
    out using lower-layer technologies other than the Internet Protocol (IP). This
    standard is represented in SNMPv3 by RFC 3417, "Transport Mappings for the Simple
    Network Management Protocol (SNMP)."'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The actual mechanism used to communicate management information
    between network management stations (NMSs) and managed devices is called the *Simple
    Network Management Protocol*, which may be called the *SNMP protocol* to differentiate
    it from the SNMP Framework. It consists of a number of *protocol operations* that
    describe the actual message exchanges that take place between devices, and a set
    of *transport mappings* that define how these messages are carried over various
    types of internetworks. The Internet Protocol (IP) is the most common transport
    mapping used for SNMP.'
  prefs: []
  type: TYPE_NORMAL
- en: I discuss transport mappings in a little more detail in the description of SNMP
    messaging later in this chapter, but since the IP/User Datagram Protocol (UDP)
    method is by far the most common transport mechanism, there isn't a great deal
    to say about that aspect of the SNMP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Communication Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For SNMP to be useful in enabling the management of a network, it must allow
    a network administrator using a network management station (NMS) to easily check
    the status of SNMP agents in managed devices. In data communications, there are
    two general techniques that are used in a situation where one entity needs to
    be kept informed about activity or occurrences on another:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Poll-Driven Communication** This term refers to the general technique of
    having the one who wants the information ask for it—just like someone might conduct
    a political poll. In SNMP, the NMS would poll SNMP agents for information. A common
    real-life example of polling is the model used by the regular mail service; every
    day you go to check your mailbox to see if you have any mail.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt-Driven Communication** This term refers to having a device with
    information that another needs to know decide to send the information of its own
    volition. In SNMP, this would refer to an SNMP agent sending information to an
    NMS without being asked. This is the model used by that most famous of interrupters—the
    telephone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which communication method is better? The usual answer applies here: Neither
    is better or worse universally, which is why both options exist. Due to the obvious
    strengths and weaknesses of these models, the SNMP protocol is designed to use
    both. Polling is used for the periodic gathering of routine information, such
    as checking the usage statistics and general status of a device. Interrupts are
    used in the form of *traps* that a network administrator can set on a managed
    device. These traps cause an SNMP agent to interrupt an NMS when an event of importance
    occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP uses two basic methods for exchanging management information.
    Routine communication uses a *poll-driven* technique, where the network management
    station (NMS) requests information from managed nodes. An *interrupt-driven* model
    is also supported. In situations where a managed device needs to tell an NMS about
    an occurrence immediately, it can send a *trap* message without waiting for a
    request from the NMS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of most of our look at SNMP in this chapter will concentrate on SNMP
    protocol operations: what messages are used, how they are structured, and how
    they are exchanged. In examining these messages, we will see the two main ways
    that information exchanges occur in SNMP—by polling and by interrupt—and also
    discover how the SNMP protocol works with MIB objects.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Protocol Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual communication of information in the SNMP protocol is performed in
    a manner similar to most other protocols, through the exchange of SNMP messages.
    These messages are sometimes called *protocol data units* or *PDUs*. This is a
    term you may have heard used in other protocols, and it is part of the formal
    definition of data encapsulation in the OSI Reference Model, as explained in [Chapter 5](ch05.html
    "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS"). A message is, of
    course, a data unit used by the protocol. SNMP messages all have *-PDU* at the
    ends of their names to identify them.
  prefs: []
  type: TYPE_NORMAL
- en: Some consider *protocol data unit* to be analogous to the military using oblong,
    metallic-headed, manually operated, fastener-acceleration device to refer to a
    hammer. To be fair though, strictly speaking, in SNMP, a PDU and a message are
    not exactly the same. The PDU is the higher-layer data that SNMP encapsulates,
    as described by the OSI model. The SNMP message format is a *wrapper* that encapsulates
    a PDU along with header fields, as I describe in the next chapter on SNMP messaging.
    However, the point of a message is to send a PDU, so the two are close enough,
    and the terms are sometimes used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP PDU Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SNMPv1 originally defined six PDUs. The number of PDUs was expanded, and some
    changes were made to their names and uses in SNMPv2 and SNMPv3\. The current SNMP
    Framework categorizes the PDUs into different *classes*. These classes describe
    both the function of each message type and the kind of communication they use
    to perform their task (polling versus interrupting).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP messages consist of a set of fields wrapped around a data
    element called a *protocol data unit* or *PDU*. In some cases, the terms message
    and PDU are used interchangeably, although they are technically not the same.
    SNMP PDUs are arranged into *classes* based on their function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 67-1](ch67s02.html#snmp_pdu_message_classes "Table 67-1. SNMP PDU (Message)
    Classes") lists the main SNMPv2/SNMPv3 PDU classes, describes them, and shows
    which PDUs are in each class in SNMPv2/SNMPv3\. These classes were not used in
    SNMPv1, but for clarity, I also show which messages from SNMPv1 fall into the
    classes conceptually.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 67-1. SNMP PDU (Message) Classes
  prefs: []
  type: TYPE_NORMAL
- en: '| SNMPv3 PDU Class | Description | SNMPv1 PDUs | SNMPv2/SNMPv3 PDUs |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read | Messages that read management information from a managed device using
    a polling mechanism. | GetRequest-PDU, GetNextRequest-PDU | GetRequest-PDU, GetNextRequest-PDU,
    GetBulkRequest-PDU |'
  prefs: []
  type: TYPE_TB
- en: '| Write | Messages that change management information on a managed device to
    affect the device''s operation. | SetRequest-PDU | SetRequest-PDU |'
  prefs: []
  type: TYPE_TB
- en: '| Response | Messages sent in response to a previous request. | GetResponse-PDU
    | Response-PDU |'
  prefs: []
  type: TYPE_TB
- en: '| Notification | Messages used by a device to send an interrupt-like notification
    to an SNMP manager. | Trap-PDU | Trapv2-PDU, InformRequest-PDU |'
  prefs: []
  type: TYPE_TB
- en: The GetBulkRequest-PDU and InformRequest-PDU messages are new in SNMPv2/v3\.
    The GetResponse-PDU message was renamed Response-PDU (since it is a response and
    not a message that gets anything), and the new Trapv2-PDU replaces Trap-PDU.
  prefs: []
  type: TYPE_NORMAL
- en: There are three other special classes defined by the current SNMP Framework
    that are of less interest to us because they don't define actively used messages,
    but which I should mention for completeness. The Internal class contains a special
    message called Report-PDU defined for internal SNMP communication. The SNMP standards
    also provide two classes called Confirmed and Unconfirmed, which are used to categorize
    the messages listed in [Table 67-1](ch67s02.html#snmp_pdu_message_classes "Table 67-1. SNMP
    PDU (Message) Classes") based on whether or not they are acknowledged. The Report-PDU,
    Trapv2-PDU, and Response-PDU messages are considered Unconfirmed, and the rest
    are Confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at how the major message types in the four main classes are
    used. Note that in general terms, all protocol exchanges in SNMP are described
    in terms of one SNMP entity sending messages to another. Most commonly, the entity
    sending requests is an SNMP manager, and the one responding is an SNMP agent,
    except for traps, which are sent by agents. For greater clarity, I try to use
    these more specific terms (*manager* or *agent*) when possible, rather than just
    *entity*.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Request/Response Information Poll Using GetRequest and (Get)Response Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The obvious place to begin our detailed look at SNMP protocol operations is
    with the simplest type of information exchange. This would be a simple *poll*
    operation to read one or more management information variables, used by one SNMP
    entity (typically an SNMP manager) to request or read information from another
    entity (normally an SNMP agent on a managed device). SNMP implements this as a
    simple, two-message request/response protocol exchange, similar to the request/reply
    processes found in so many TCP/IP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'This information request process typically begins with the user of an application
    wanting to check the status of a device or look at information about it. As we''ve
    seen, all this information is stored on the device in the form of MIB objects.
    The communication, therefore, takes the form of a request for particular MIB objects
    and a reply from the device containing those objects'' values. In simplified form,
    the steps in the process are as follows (see [Figure 67-1](ch67s02.html#snmp_information_poll_process_the_basic_
    "Figure 67-1. SNMP information poll process The basic SNMP information polling
    process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager
    and a Response-PDU returned by an SNMP agent.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Manager Creates GetRequest-PDU** Based on the information required by
    the application and user, the SNMP software on the NMS creates a GetRequest-PDU
    message. It contains the names of the MIB objects whose values the application
    wants to retrieve.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Manager Sends GetRequest-PDU** The SNMP manager sends the PDU to the
    device that is being polled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Receives and Processes GetRequest-PDU** The SNMP agent receives
    and processes the request. It looks at the list of MIB object names contained
    in the message and checks to see if they are valid (ones the agent actually implements).
    It looks up the value of each variable that was correctly specified.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Creates Response-PDU** The agent creates a Response-PDU to send
    back to the SNMP manager. This message contains the values of the MIB objects
    requested and/or error codes to indicate any problems with the request, such as
    an invalid object name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Sends Response-PDU** The agent sends the response back to the
    SNMP manager.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Manager Processes Response-PDU** The manager processes the information
    in the Response-PDU received from the agent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![SNMP information poll process The basic SNMP information polling process
    involves a simple exchange of a GetRequest-PDU sent by an SNMP manager and a Response-PDU
    returned by an SNMP agent.](httpatomoreillycomsourcenostarchimages288233.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 67-1. SNMP information poll process The basic SNMP information polling
    process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager
    and a Response-PDU returned by an SNMP agent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The most basic type of communication in SNMP is an *information
    poll*, which allows an NMS to read one or more MIB objects from a managed node
    using a simple request/reply message exchange.'
  prefs: []
  type: TYPE_NORMAL
- en: The Response-PDU message is called GetResponse-PDU in SNMPv1\. Presumably, this
    name was chosen based on the fact that it was a response to a get operation, to
    make the names GetRequest-PDU and GetResponse-PDU somewhat symmetric. The problem
    is that this name is confusing, for two reasons. First, it sounds to some people
    like the purpose of the PDU is to "get a response." Second, the GetResponse-PDU
    was also defined as the response message for operations other than get operations,
    including the reply message for SetRequest-PDU. Having a GetResponse message be
    sent in reply to a SetRequest message is disconcerting. The new name is more generic
    and avoids these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Table Traversal Using GetNextRequest and GetBulkRequest Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GetRequest-PDU message is used by applications to request values for regular,
    single variables in an SNMP managed object's MIB. As I mentioned in [Chapter 66](ch66.html
    "Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION
    BASES (MIBS)"), however, the SMI also allows an MIB to contain *tabular data*.
  prefs: []
  type: TYPE_NORMAL
- en: MIB tables are a useful way for a device to store and organize a set of related
    data items. It would be far from ideal to try to structure these items just as
    collections of regular objects. For example, a device may have multiple IP addresses.
    It would be inefficient to define one MIB object called ipAddr1, another called
    ipAddr2, and so on to store IP address information. Instead, an object called
    ipAddrTable is defined in the original SNMPv1 MIB, which specifies a table containing
    one or more entries called ipAddrEntry. Each entry contains the IP address and
    subnet mask for one of the interfaces of the device.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1 Table Traversal Using GetNextRequest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There needs to be a way to let an SNMP manager read the contents of these tables
    from a device. This can be done using the regular GetRequest-PDU message, by specifying
    each entry in the table, one after the other. However, this is somewhat crude,
    and it leaves a problem: the SNMP manager may not know how many entries are in
    the table, and therefore, how many entries it should request.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem of *table traversal* was addressed in SNMPv1 through the creation
    of a new message type called GetNextRequest-PDU. You can think of this as a relative
    of the regular GetRequest-PDU. The GetNextRequest-PDU contains the name of a tabular
    variable, as well as a particular entry in the table. The device receiving the
    GetNextRequest-PDU uses this to look up the next value in the table and return
    it in a GetResponse-PDU message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual protocol exchange is about the same as that described in the previous
    section: a request is sent by the SNMP manager, and a reply is returned by the
    SNMP agent. The difference is that instead of the SNMP agent returning the value
    for the variable specified, it returns the value of the *next* variable in the
    table. This is then used as the value for the next request, and so on, until the
    last entry in the table is reached. Once this happens and a GetNextRequest-PDU
    is sent that contains this last entry, the responding device indicates this by
    returning the MIB object that conceptually follows the table in the implementation
    of the MIB. This signals to the SNMP manager that the table has been fully traversed.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The SNMP GetNextRequest-PDU message allows an NMS to request
    a series of consecutive variables in an MIB. This is most commonly used to allow
    tabular data to be more easily retrieved, without requiring that each variable
    in the table be individually specified.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2/v3 Table Traversal Using GetBulkRequest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GetNextRequest-PDU message is functional, but while it is more elegant than
    using regular GetRequest-PDU messages, it is not any more efficient—each entry
    in the table must still be requested one at a time. This means that retrieving
    the information in a table takes a long time and also results in a great deal
    of traffic being generated, due to the number of requests and replies that must
    be sent.
  prefs: []
  type: TYPE_NORMAL
- en: To make table traversal easier and more conservative in its use of network resources,
    SNMPv2 introduced a new message type called GetBulkRequest-PDU. You can probably
    surmise the idea here from the name. Instead of specifying a particular MIB object
    to get or to get next, a GetBulkRequest-PDU allows an SNMP manager to send a single
    request that results in a number of entries in a table being returned in a Response-PDU
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GetBulkRequest-PDU is designed to allow both regular variables and tables
    to be retrieved in a single request. The PDU includes a list of objects, just
    as in a GetRequest-PDU or GetNextRequest-PDU. The list is organized so that regular
    objects appear first and table objects come afterwards. Two special parameters
    are included in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non Repeaters** Specifies the number of nonrepeating, regular objects to
    be retrieved. This is the number of regular objects at the start of the object
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Repetitions** Specifies the number of iterations, or entries, to read
    for the remaining tabular objects.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose an SNMP manager wanted to request four regular variables
    and three entries from a table. The GetNextRequest-PDU would contain five MIB
    object specifications, with the table last. The Non Repeaters field would be set
    to 4, and the Max Repetitions field set to 3.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** To improve the efficiency of table traversal, SNMPv2 introduced
    the GetBulkRequest-PDU message, which allows an NMS to request a sequence of MIB
    objects from a table using a single request to a managed node.'
  prefs: []
  type: TYPE_NORMAL
- en: The original method of traversing tables using GetRequest-PDU and GetNextRequest-PDU
    from SNMPv1 was retained in SNMPv2 and SNMPv3 when they were developed. However,
    the introduction of the more efficient GetBulkRequest-PDU means that GetNextRequest-PDU
    is not as important as it was in SNMPv1\. Bear in mind, however, that using GetBulkRequest-PDU
    does require that the requesting entity know how many entries to ask for. So,
    some trial and error, or multiple requests, may be required to get a whole table
    if the number of entries is not known.
  prefs: []
  type: TYPE_NORMAL
- en: Object Modification Using SetRequest Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GetRequest-PDU, GetNextRequest-PDU, and GetBulkRequest-PDU messages are
    the three members of the SNMP Read class of PDUs—they are used to let an SNMP
    manager read MIB objects from an SNMP agent. The opposite function is represented
    by the SNMP Write class, which contains a single member: the SNMP SetRequest-PDU
    message.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of this PDU is fairly obvious; where one of the three Get PDUs specifies
    a variable whose value is to be retrieved, the SetRequest-PDU message contains
    a specification for variables whose values are to be modified by the network administrator.
    Remember that SNMP does not include specific commands to let a network administrator
    control a managed device. This is the *control* method, which works by setting
    variables that affect the operation of the managed device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set process is the complement of the get process, using the same basic
    idea, but a reversal in how the object values travel and what is done with them.
    The process follows these steps (see [Figure 67-2](ch67s02.html#snmp_object_modification_process_the_com
    "Figure 67-2. SNMP object modification process The communication process for setting
    a MIB object value is very similar to that used for reading one. The main difference
    is that the object values are sent from the SNMP manager to the SNMP agent, carried
    in the SetRequest-PDU message.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Manager Creates SetRequest-PDU** Based on the information changes specified
    by the user through the SNMP application, the SNMP software on the NMS creates
    a SetRequest-PDU message. It contains a set of MIB object names and the values
    to which they are to be set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Manager Sends SetRequest-PDU** The SNMP manager sends the PDU to the
    device being controlled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Receives and Processes SetRequest-PDU** The SNMP agent receives
    and processes the set request. It examines each object in the request, along with
    the value to which the object is to be set, and determines if the request should
    or should not be honored.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Makes Changes and Creates Response-PDU** Assuming that the information
    in the request was correct (and any security provisions have been satisfied),
    the SNMP agent makes changes to its internal variables. The agent creates a Response-PDU
    to send back to the SNMP manager, which either indicates that the request succeeded
    or contains error codes to indicate any problems with the request found during
    processing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Agent Sends Response-PDU** The agent sends the response back to the
    SNMP manager.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP Manager Processes Response-PDU** The manager processes the information
    in the Response-PDU to see the results of the set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![SNMP object modification process The communication process for setting a
    MIB object value is very similar to that used for reading one. The main difference
    is that the object values are sent from the SNMP manager to the SNMP agent, carried
    in the SetRequest-PDU message.](httpatomoreillycomsourcenostarchimages288235.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 67-2. SNMP object modification process The communication process for
    setting a MIB object value is very similar to that used for reading one. The main
    difference is that the object values are sent from the SNMP manager to the SNMP
    agent, carried in the SetRequest-PDU message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, telling a device to change a variable''s value is a more significant
    request than just asking the device to read the value. For this reason, the managed
    device must very carefully analyze and verify the information in the request to
    ensure that the request is valid. The checks performed include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the names of the objects to be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that the objects are allowed to be modified (based on their Access
    or Max-Access object characteristic, as described in [Chapter 66](ch66.html "Chapter 66. TCP/IP
    STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the value included in the request to ensure that its type and size
    are valid for the object to be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is also a place where general protocol security issues become more important,
    as I'll discuss near the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP NMSs control the operation of managed devices by changing
    MIB objects on those devices. This is done using the SetRequest-PDU message, which
    specifies the objects to be modified and their values.'
  prefs: []
  type: TYPE_NORMAL
- en: Information Notification Using Trap and InformRequest Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, I introduced the two basic methods of communicating
    information between SNMP devices: using polls or interrupts. All of the message
    types and exchanges we have examined thus far in this section have been poll-driven.
    They consist of an SNMP manager making a specific request that results in action
    being taken, and a response being generated by an SNMP agent.'
  prefs: []
  type: TYPE_NORMAL
- en: Polling is ideal for the exchange of routine information that needs to be gathered
    on a regular basis. For example, the regular get requests could be used to verify
    the settings on a device, examine error counts over a period of time, or check
    its uptime or use statistics. And, obviously, polling is the only real method
    for performing a set operation, where data is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'But polling is not well suited for important information that needs to be communicated
    quickly. The reason is that poll-driven communication is always initiated by the
    recipient of the information: the SNMP manager. If something significant occurs
    on a managed device that the manager wasn''t expecting, the manager won''t find
    out about it unless it specifically asks to see the variable that has changed.
    This means that important variables would need to be checked all the time by the
    SNMP manager, which is highly efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, using polling to implement situations where critical information
    needs to be sent would be like having the emergency response service in your town
    call everyone every hour to find out if they needed an ambulance or fire truck.
    Similarly, in SNMP, a mechanism was needed to let an SNMP agent initiate the communication
    of information. This capability was originally made part of the SNMPv1 protocol
    through the inclusion of the Trap-PDU message type.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, a *trap* is simply a set of conditions that a device monitors
    continuously. If the appropriate conditions occur, the trap is *triggered* and
    causes some sort of action to be taken. In SNMP, traps are programmed into SNMP
    agents, and when they are triggered, an SNMP Trap-PDU message is sent to an SNMP
    manager to inform it of the occurrence. Examples of traps in the SNMPv1 specification
    include ones that trigger in the event of a communication link failure, restart
    of the device, or an authentication problem.
  prefs: []
  type: TYPE_NORMAL
- en: Use of SNMP Trap and Trapv2 Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The communication in the case of a trap is trivial. The SNMP agent sends the
    trap, and the SNMP manager is thereby considered informed of what happened. That's
    pretty much it. These are Unconfirmed messages, and no reply is made back to the
    SNMP agent. The triggering of the trap may lead the network administrator to take
    follow-up action at the device that sent the trap.
  prefs: []
  type: TYPE_NORMAL
- en: The designer of a particular MIB must determine which traps to create for a
    particular group of objects. The implementation must specify the conditions under
    which the traps will trigger and also the destination to which the Trap-PDU message
    will be sent when this occurs. In SNMPv2, the trap notification message was retained
    in the form of the Trapv2-PDU message.
  prefs: []
  type: TYPE_NORMAL
- en: Use of the SNMPv2 InformRequest Message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SNMPv2 also incorporates a second notification message type: the InformRequest-PDU
    message. This type of message is not the same as a trap, but it is related to
    traps for two reasons: Both message types are used to communicate information
    without the recipient initiating the process, and the two messages are sometimes
    used in conjunction.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the InformRequest-PDU is actually to facilitate the communication
    of information between NMSs. The SNMP manager on one NMS can choose to inform
    another of some piece of information by sending an InformRequest-PDU to that other
    SNMP manager. The receiving manager then replies back with a Response-PDU to the
    one that sent the InformRequest-PDU, confirming receipt of the inform message.
  prefs: []
  type: TYPE_NORMAL
- en: A common way that this message is used is to spread the news when a trap occurs.
    Suppose a device experiences a power failure, which results in a Trapv2-PDU being
    sent to NMS 1\. The network administrator may want to set up NMS 1 so that receipt
    of particular traps causes the information in the trap to be forwarded to another
    NMS. The InformRequest-PDU would be used to carry that information from NMS 1
    to, say, NMS 2.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP managed devices can inform an NMS of an important occurrence
    by sending it a Trap-PDU or Trapv2-PDU message. Network administrators determine
    the circumstances under which one of these messages should be transmitted. SNMPv2
    adds to this capability the InformRequest-PDU message, which can be used to propagate
    information about an event between management stations.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Protocol Security Issues and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my description of the various SNMP versions in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"), it's possible that I may have
    been a bit harsh on those who worked on SNMP during the 1990s. The proliferation
    of many SNMP version 2 variants really was unfortunate, and not something we often
    see in the world of TCP/IP. However, now that we've seen the sort of work that
    SNMP does, the desire for security in the protocol would seem to be clear. Given
    that, and given the very low level of security in the initial SNMPv1 protocol,
    it's understandable to some extent why a conflict over security issues arose.
  prefs: []
  type: TYPE_NORMAL
- en: The need for security in SNMP is obvious because the MIB objects being communicated
    contain critical information about network devices. We don't want just anyone
    snooping into our network to find out our IP addresses, how long our machines
    have been running, whether our links are down, or pretty much anything else. When
    it comes to object write operations using a SetRequest-PDU, the concerns are magnified
    even more, because we definitely don't want strangers being able to control or
    interfere with our managed devices by issuing bogus commands to change MIB objects
    that control device operation!
  prefs: []
  type: TYPE_NORMAL
- en: Problems with SNMPv1 Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, the security incorporated into SNMPv1 was extremely limited.
    It really took the form of only one policy and one simple technology.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP was created with the mindset that the MIB objects used in the protocol
    would be relatively *weak*. This means that the objects are designed so that any
    problems in working with them result in minimal damage. The policy of the designers
    of SNMP was that MIB objects that are normally read should not contain critical
    information, and objects that are written should not control critical functions.
  prefs: []
  type: TYPE_NORMAL
- en: So, a read-only MIB object containing a description of a machine is fine, but
    one containing the administrative password is not. Similarly, a read-write MIB
    object that controls when the computer next reboots is acceptable, but one that
    tells the object to reformat its hard disk is definitely not!
  prefs: []
  type: TYPE_NORMAL
- en: All the devices in an SNMP network managed by a particular set of NMSs are considered
    to be in a *community*. Each SNMPv1 message sent between members of the community
    is identified by a *community string* that appears in a field in the message header.
    This string is like a simple password. Any messages received with the wrong string
    will be rejected by the recipient.
  prefs: []
  type: TYPE_NORMAL
- en: These security features are better than nothing, but not much. The use of weak
    objects is comparable to a policy that says not to leave your car in front of
    the convenience store with the doors unlocked and the key in the ignition—it is
    basically saying, "Don't ask for trouble." This is wise, but it's not a complete
    security solution.
  prefs: []
  type: TYPE_NORMAL
- en: The community strings protect against obvious tampering in the form of unauthorized
    messages. However, the strings are sent in plain text, and they can easily be
    discovered and then used to compromise the community. So, this is like locking
    your doors when parking your car—it protects against the casual thief but not
    a pro.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for some people, not leaving their car running and locking the doors
    when they park provide enough security, and SNMPv1's security was also sufficient
    for some users of SNMP. But in newer, larger internetworks, especially ones spanning
    large distances or using public carriers, SNMPv1 wasn't up to the task. This is
    why all that fun stuff occurred with SNMPv2.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2/v3 Security Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the evolution of SNMPv2 variants, and eventually the creation of SNMPv3,
    several new security models were created to improve SNMPv1''s security:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Party-Based Security Model** Party-based security was the model for the original
    SNMPv2 standard, now called *SNMPv2p*. A logical entity called a *party* is defined
    for communication that specifies a particular authentication protocol and a privacy
    (encryption) protocol. The information is used to verify that a particular request
    is authentic, and to ensure that the sender and receiver agree on how to encrypt
    and decrypt data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Based Security Model (USM)** USM was developed in the SNMPv2u variant
    and used in SNMPv2* (SNMPv2 asterisk). It eventually was adopted in SNMPv3\. The
    idea here is to move away from tying security to the machines and instead use
    more traditional security based on access rights of a user of a machine. A variety
    of authentication and encryption protocols can be used to ensure access rights
    are respected and to protect message privacy. The method relies on timestamps,
    clock synchronization, and other techniques to protect against certain types of
    attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**View-Based Access Control Model (VACM)** VACM is part of SNMPv3, and it defines
    a method where more fine control can be placed on access to objects on a device.
    A *view* specifies a particular set of MIB objects that can be accessed by a particular
    group in a particular context. By controlling these views, an administrator can
    manage what information is accessed by whom.'
  prefs: []
  type: TYPE_NORMAL
- en: Party-based security pretty much died with SNMPv2p. USM and VACM are part of
    SNMPv3 and provide enhanced security for those who need it. Again, it's interesting
    to note how many networks continue to use SNMPv1, security warts and all.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3 took another important security-related step in redefining the SNMP architecture
    to seamlessly support multiple security models. This enables different implementations
    to choose the security model that is best for them. USM is the default model in
    SNMPv3.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we saw extensively in the previous chapter, the communication of management
    information is accomplished through the exchange of Simple Network Management
    Protocol (SNMP) messages that contain *protocol data units (PDUs)*. Like the messages
    of most TCP/IP protocols, these PDUs are designed to use a particular field format,
    and are created, addressed, and transported according to specific protocol rules.
    SNMP messages include fields that control the operation of the protocol, and they
    carry a payload of management information in the form of management information
    base (MIB) objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the details of how messaging is accomplished in
    the SNMP protocol. I begin with a general discussion of issues related to message
    generation, addressing, and transport, and a description of how retransmission
    of messages is handled when necessary. I discuss the way fields are defined in
    SNMP messages and describe their general format, explaining the difference between
    the overall message and the PDU it contains. I then examine the message format
    used in all of the important SNMP versions, showing the structure of each message
    type and the fields used.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Protocol Message Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message generation in SNMP is a bit different than the typical TCP/IP client/server
    model used for most other protocols. There aren't really any formal clients and
    servers in SNMP, since management information can be obtained from any device;
    it is distributed. Most of the message exchanges use a matched pair of request
    and reply messages. The network management station (NMS) usually *acts* as the
    client in these exchanges, sending a particular get or set request to an SNMP
    agent, which plays the role of server for the information it contains. However,
    SNMP agents aren't usually considered servers in the conventional sense.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP traps deviate from the normal request/reply model of message generation
    entirely. When a trap is triggered, an SNMP agent sends a trap message to an NMS
    on its own, not in reaction to receiving a request. Since trap messages are unconfirmed,
    there is no reply. Note, however, that the SNMP versions 2 and 3 (SNMPv2 and SNMPv3)
    InformRequest-PDU message (discussed later in this chapter) is confirmed, and
    a response message is thus sent back to the NMS that generates it.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Transport Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a message has been generated, it is sent using the protocols at the levels
    below the application layer where SNMP resides. As you saw in the overview of
    the SNMP protocol in the previous chapter, the current SNMP standard set separates
    the description of protocol operations and PDUs from the methods used to actually
    send them.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 2, SNMP has defined several *transport mappings* that
    describe how SNMP PDUs can be sent over a variety of internetworking protocol
    suites, including TCP/IP, OSI, IPX/SPX (Novell), and AppleTalk. Many of the specific
    details of SNMP messaging depend on the transport mapping that is used in a particular
    implementation. SNMP is primarily used on TCP/IP internetworks, and TCP/IP is
    where our interest lies here, so the rest of this discussion will deal with transport
    issues when SNMP is used over the Internet Protocol (IP).
  prefs: []
  type: TYPE_NORMAL
- en: The standard IP transport mapping for SNMP calls for it to be carried using
    the User Datagram Protocol (UDP). This decision goes back to the initial implementation
    of SNMPv1 (before there were distinct transport mappings). UDP was likely chosen
    because it is more efficient for the simple request/reply messaging scheme SNMP
    uses. The many Transmission Control Protocol (TCP) features were not considered
    necessary and add overhead that SNMP's designers wanted to avoid. It is possible
    that TCP could be used to carry SNMP, defined as a different transport mapping,
    but I don't believe this is actually done.
  prefs: []
  type: TYPE_NORMAL
- en: Two well-known UDP port numbers are reserved for SNMP. The first is port 161,
    which is the general-purpose SNMP number. All devices that are set up to listen
    for SNMP requests—both agents and managers—listen on port 161\. Each device receives
    any messages sent and replies back to the client, the SNMP entity that issued
    the request, which uses an ephemeral port number to identify the requesting process.
    The second UDP port number is 162, which is reserved for SNMP traps. Having two
    numbers allows regular messages and traps to be kept separate. Normally, only
    NMSs would listen on port 162, since agents are not recipients of traps.
  prefs: []
  type: TYPE_NORMAL
- en: The use of UDP allows SNMP information communication to be streamlined, since
    there is no need to establish a TCP connection, and since message headers are
    shorter and processing time slightly reduced. But the use of UDP introduces a
    couple of issues that SNMP implementations must be concerned with, including message
    size and lost messages.
  prefs: []
  type: TYPE_NORMAL
- en: UDP Message Size Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first issue is that of message length. SNMP PDUs can carry many MIB objects,
    which means they could potentially be rather large. However, UDP is limited in
    the size of message it can carry (where TCP is not). The standards specify that
    SNMP entities must accept messages up to at least 484 bytes in size. They also
    recommend that SNMP implementations be able to accept even larger messages, up
    to 1,472 bytes, which would correspond to the largest size message that can be
    encapsulated in an Ethernet frame (1,500 bytes, allowing 20 bytes for the IP header
    and 8 for the UDP header).
  prefs: []
  type: TYPE_NORMAL
- en: The use of the GetBulkRequest-PDU message type in SNMPv2 and SNMPv3 requires
    particular care, since it allows a single request to result in many MIB objects
    being sent back in a response. The Max Repetitions parameter must be chosen conservatively
    so the SNMP agent doesn't try to send an enormous message that won't fit.
  prefs: []
  type: TYPE_NORMAL
- en: Lost Transmission Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second issue with UDP is the price we pay for its efficiency and simplicity:
    a lack of transport features. UDP doesn''t guarantee data delivery or handle retransmissions,
    which means a request or reply could, in theory, be lost in transit. Only the
    device that initially sends a request can know if there was a problem with transport.
    It sends the request, and if it receives no reply, it knows either the request
    or response got lost. This puts the responsibility for retransmission on the device
    that sends the request message.'
  prefs: []
  type: TYPE_NORMAL
- en: NMSs sending requests to SNMP agents generally use a timer to keep track of
    how much time has elapsed since a request was sent. If the response doesn't arrive
    within a certain time interval, the request is sent again. Because of how SNMP
    works, having a request be received more than once accidentally will normally
    not cause any problems (a property known as *idempotence*). The NMS does need
    to employ an algorithm to ensure that it does not generate too many retransmissions
    and clog the network (especially since congestion might be causing the loss of
    its messages in the first place).
  prefs: []
  type: TYPE_NORMAL
- en: Since traps are unconfirmed, there is no way for the intended recipient of a
    trap PDU to know if did not arrive, nor is there any way for the sender of the
    trap PDU to know. This is just a weakness in the protocol; the overall reliability
    of TCP/IP (and the underlying networks) ensures that these messages are not lost
    very often.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP is designed with a separately defined set of *protocol
    operations* and *transport mappings*, so it can be carried over many different
    internetworking technologies. The most common of these transport mechanisms is
    TCP/IP, where SNMP makes use of UDP running over IP, for its efficient and simple
    communication. The lack of reliability features in UDP means that requests must
    be tracked by the device sending them and retransmitted if no reply is received.
    The limited size of UDP messages restricts the amount of information that can
    be sent in any SNMP PDU.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP General Message Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To structure its messages for transport, SNMP uses a special field format, like
    most protocols. What's interesting about SNMP, however, is that its standards
    do not describe the SNMP message format using a simple list of fields the way
    most TCP/IP standards do. Instead, SNMP messages are defined using the same data
    description language (*Abstract Syntax Notation 1* or *ASN.1*) that is used to
    describe MIB objects.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that SNMP messages implement the various SNMP protocol
    operations with the ultimate goal of allowing MIB objects to be conveyed between
    SNMP entities. These MIB objects become fields within the messages to be sent.
    The MIB objects carried in SNMP messages are defined using ASN.1 as described
    in the Structure of Management Information (SMI) standard. So, it makes sense
    to define SNMP messages and all their fields using the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Since all SNMP fields are defined like MIB objects, they are like objects in
    that they have certain characteristics. Specifically, each field has a name, and
    its contents are described using one of the standard SMI data types. So, unlike
    normal message formats where each field has just a name and a length, an SNMP
    message format field has a name and a *syntax*, such as Integer, Octet String,
    or IpAddress. The syntax of the field defines its length and how it is formatted
    and used.
  prefs: []
  type: TYPE_NORMAL
- en: Just as regular message formats use integers to represent specific values (for
    example, the numeric Opcode field in the DNS message header, which indicates the
    DNS message type), this can be done in SNMP using an enumerated integer type.
    An example would be the Error Status field, where a range of integer values represents
    different error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to define SNMP messages using ASN.1 allows the message format description
    to be consistent with how the objects in the format are described, which is nice.
    Unfortunately, it means that the field formats are very hard to determine from
    the standards, because they are not described in one place. Instead, the overall
    message format is defined as a set of components, and those components contain
    subcomponents that may be defined elsewhere, and so on. In fact, the full message
    format isn't even defined in one standard; parts are spread across several standards.
    So, you can't look in one place and see the whole message format. Well, I should
    say that you can't if you use the standards, but you can if you look here.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier for you, I have converted these distributed syntax descriptions
    into the same tabular field formats I use throughout the rest of this book. I
    will begin here by describing the general format used for SNMP messages, and in
    the remainder of the chapter, explore the specific formats used in each version
    of SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: The Difference Between SNMP Messages and PDUs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand SNMP messages, it is important that you first grasp the difference
    between SNMP messages and SNMP PDUs. We've seen in looking at SNMP protocol operations
    that the two terms are often used interchangeably. This is because each message
    carries one PDU, and the PDU is the most important part of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, strictly speaking, an SNMP PDU and an SNMP message are not exactly
    the same. The PDU is the actual piece of information that is being communicated
    between SNMP entities. It is carried within the SNMP message along with a number
    of header fields, which are used to carry identification and security information.
    Thus, conceptually, the SNMP message format can be considered to have two overall
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Header** Contains fields used to control how the message is processed,
    including fields for implementing SNMP security.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Body (PDU)** Contains the main portion of the message. In this case,
    the message body is the PDU being transmitted.'
  prefs: []
  type: TYPE_NORMAL
- en: The overall SNMP message is sometimes called a *wrapper* for the PDU, since
    it encapsulates the PDU and precedes it with additional fields. The distinction
    between the PDU and the message format as a whole began as a formality in SNMPv1,
    but it became quite important in later versions. The reason is that it allows
    the fields used for basic protocol operations (which are in the PDU) to be kept
    separate from fields used to implement security features. In SNMPv2, the implementation
    of security became a very big deal indeed, so this flexibility was quite important.
  prefs: []
  type: TYPE_NORMAL
- en: General PDU Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fields in each PDU depend on the PDU type, but can be divided into the
    following general substructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PDU Control Fields** A set of fields that describe the PDU and communicate
    information from one SNMP entity to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PDU Variable Bindings** A set of descriptions of the MIB objects in the PDU.
    Each object is described as a *binding* of a name to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Each PDU will follow this general structure, which is shown in [Figure 68-1](ch68s03.html#snmp_general_message_format-id001
    "Figure 68-1. SNMP general message format"), differing only in the number of control
    fields and variable bindings and how they are used. In theory, each PDU could
    have a different message format using a distinct set of control fields, but in
    practice, most PDUs for a given SNMP version use the same control fields (with
    some exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP general message format](httpatomoreillycomsourcenostarchimages288237.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-1. SNMP general message format
  prefs: []
  type: TYPE_NORMAL
- en: Each variable binding describes one MIB object. The binding consists of a pair
    of subfields, one specifying the name of the object in standard SNMP object identifier
    notation and one its value, formatted to match the object's SMI syntax. For example,
    if the object were of type Integer, the value field would be four bytes wide and
    contain a numeric integer value. [Table 68-1](ch68s03.html#snmp_variable_binding_format
    "Table 68-1. SNMP Variable Binding Format") describes the subfield format for
    each PDU variable binding.
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-1. SNMP Variable Binding Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Object Name | Sequence of Integer | Variable | The numeric object identifier
    of the MIB object, specified as a sequence of integers. For example, the object
    `sysLocation` has the object identifier 1.3.6.1.2.1.1.6, so it would be specified
    as 1 3 6 1 2 1 1 6 using ASN.1. |'
  prefs: []
  type: TYPE_TB
- en: '| Object Value | Variable | Variable | In any type of get request, this subfield
    is a placeholder; it is structured using the appropriate syntax for the object
    but has no value (since the get request is asking for that value!). In a set request
    (SetRequest-PDU) or in a reply message carrying requested data (GetResponse-PDU
    or Response-PDU), the value of the object is placed here. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The general format of SNMP messages consists of a *message
    header* and a *message body*. The body of the message is also called the *protocol
    data unit*, or *PDU*, and contains a set of PDU *control fields* and a number
    of *variable bindings*. Each variable binding describes one MIB object and consists
    of the object''s name and value.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Version 1 (SNMPv1) Message Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SNMP general message format was first used to define the format of messages
    in the original SNMP protocol, SNMPv1\. This first version of SNMP is probably
    best known for its relative simplicity compared to the versions that followed
    it. This is reflected in its message format, which is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1 General Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The general message format in SNMPv1 is a wrapper consisting of a small header
    and an encapsulated PDU. Not very many header fields were needed in SNMPv1 because
    the community-based security method in SNMPv1 is very rudimentary. The overall
    format for SNMPv1 messages is described in [Table 68-2](ch68s04.html#snmp_version__snmpv_general_message_form
    "Table 68-2. SNMP Version 1 (SNMPv1) General Message Format") and illustrated
    in [Figure 68-2](ch68s04.html#snmpv1_general_message_format-id001 "Figure 68-2. SNMPv1
    general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-2. SNMP Version 1 (SNMPv1) General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv1,
    this value is actually 0, not 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Community | Octet String | Variable | Community String: Identifies the SNMP
    community in which the sender and recipient of this message are located. This
    is used to implement the simple SNMP community-based security mechanism, described
    in the previous chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv1 general message format](httpatomoreillycomsourcenostarchimages288239.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-2. SNMPv1 general message format
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1 PDU Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the PDUs in SNMPv1 have the same format, with one exception: Trap-PDU.
    The exact semantics of each field in the PDU depend on the particular message.
    For example, the ErrorStatus field only has meaning in a reply and not a request,
    and object values are used differently in requests and replies as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 68-3](ch68s04.html#snmpv_common_pdu_format "Table 68-3. SNMPv1 Common
    PDU Format") shows the common format for most of the SNMPv1 PDUs: GetRequest-PDU,
    GetNextRequest-PDU, SetRequest-PDU, and GetResponse-PDU.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-3. SNMPv1 Common PDU Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type:0 = GetRequest-PDU1 = GetNextRequest-PDU2 = GetNextRequest-PDU3 =
    SetRequest-PDU |'
  prefs: []
  type: TYPE_TB
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a GetResponse-PDU by the responding SNMP entity. |'
  prefs: []
  type: TYPE_TB
- en: '| Error Status | Integer (Enumerated) | 4 | Error Status: An integer value
    that is used in a GetResponse*-*PDU to tell the requesting SNMP entity the result
    of its request. A value of zero indicates that no error occurred; the other values
    indicate what sort of error happened, as listed in [Table 68-4](ch68s04.html#snmpv_error_status_field_values
    "Table 68-4. SNMPv1 Error Status Field Values"). |'
  prefs: []
  type: TYPE_TB
- en: '| Error Index | Integer | 4 | Error Index: When Error Status is nonzero, this
    field contains a pointer that specifies which object generated the error. Always
    zero in a request. |'
  prefs: []
  type: TYPE_TB
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU, and in the case of a SetRequest-PDU
    or GetResponse-PDU, containing their values. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  prefs: []
  type: TYPE_TB
- en: Table 68-4. SNMPv1 Error Status Field Values
  prefs: []
  type: TYPE_NORMAL
- en: '| Error Status Value | Error Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | noError | No error occurred. This code is also used in all request PDUs,
    since they have no error status to report. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | tooBig | The size of the GetResponse-PDU would be too large to transport.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | noSuchName | The name of a requested object was not found. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | badValue | A value in the request didn''t match the structure that the
    recipient of the request had for the object. For example, an object in the request
    was specified with an incorrect length or type. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | readOnly | An attempt was made to set a variable that has an Access value
    indicating that it is read-only. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | genErr | An error other than one of the preceding four specific types
    occurred. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv1 common PDU format](httpatomoreillycomsourcenostarchimages288241.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-3. SNMPv1 common PDU format
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 68-5](ch68s04.html#snmpv_trap-pdu_format "Table 68-5. SNMPv1 Trap-PDU
    Format") describes the special format for the SNMPv1 Trap-PDU, and it is illustrated
    in [Figure 68-4](ch68s04.html#snmpv1_trap-pdu_format "Figure 68-4. SNMPv1 Trap-PDU
    format").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-5. SNMPv1 Trap-PDU Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type, which is 4 for a Trap-PDU message. |'
  prefs: []
  type: TYPE_TB
- en: '| Enterprise | Sequence of Integer | Variable | Enterprise: An object identifier
    for a group, which indicates the type of object that generated the trap. |'
  prefs: []
  type: TYPE_TB
- en: '| Agent Addr | NetworkAddress | 4 | Agent Address: The IP address of the SNMP
    agent that generated the trap. This is also in the IP header at lower levels but
    inclusion in the SNMP message format allows for easier trap logging within SNMP.
    Also, in the case of a multihomed host, this specifies the preferred address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Generic Trap | Integer (Enumerated) | 4 | Generic Trap Code: A code value
    specifying one of a number of predefined generic trap types. |'
  prefs: []
  type: TYPE_TB
- en: '| Specific Trap | Integer | 4 | Specific Trap Code: A code value indicating
    an implementation-specific trap type. |'
  prefs: []
  type: TYPE_TB
- en: '| Time Stamp | TimeTicks | 4 | Time Stamp: The amount of time since the SNMP
    entity sending this message last initialized or reinitialized. Used to time stamp
    traps for logging purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv1 Trap-PDU format](httpatomoreillycomsourcenostarchimages288243.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-4. SNMPv1 Trap-PDU format
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Version 2 (SNMPv2) Message Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After SMNPv1 had been in use for several years, certain issues with it were
    noticed and areas for improvement identified. This led to the development of the
    original SNMPv2, which was intended to enhance SNMPv1 in many areas, including
    MIB object definitions, protocol operations, and security. This last area, security,
    led to the proliferation of SNMPv2 version variants that I described in [Chapter 65](ch65.html
    "Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW").
  prefs: []
  type: TYPE_NORMAL
- en: Since there are several different SNMPv2s, there are also several message formats
    for SNMPv2\. This is confusing, but it would be even worse without the modular
    nature of SNMP messages coming to the rescue. The protocol operations in SNMPv2
    were changed from SNMPv1, which necessitated some modifications to the format
    of SNMPv2 PDUs. However, the protocol operations are the same for all the SNMPv2
    variations. The differences between SNMPv2 variants are in the areas of security
    implementation. Thus, the result of this is that the PDU format is the same for
    all the SNMPv2 types, while the overall message format differs for each variant.
    (This is why the distinction between a PDU and a message is not just an academic
    one!)
  prefs: []
  type: TYPE_NORMAL
- en: 'During the SNMPv2 divergence, four variations were defined: the original SNMPv2
    (SNMPv2p), community-based SNMPv2 (SNMPv2c), user-based SNMPv2 (SNMPv2u), and
    SNMPv2 asterisk (SNMPv2*). Of these, the first three were documented in sets of
    SNMP RFC standards, as discussed in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"); the fourth was not. The structure
    of the overall message format for each variant is discussed in an administrative
    or security standard for the variation in question, which makes reference to the
    shared SNMPv2 standard for the PDU format (RFC 1905).'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Version 2 (SNMPv2p) Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The party-based security model is quite complex, but the basic messaging in
    this version is described through the definition of a *management communication*,
    which describes the source and destination party and makes reference to a *context*
    for the communication. The overall message format is described in detail in RFC
    1445\. This information is summarized in [Table 68-6](ch68s05.html#snmp_version__snmpvp_general_message_for
    "Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format") and shown graphically
    in [Figure 68-5](ch68s05.html#snmpv2p_general_message_format "Figure 68-5. SNMPv2p
    general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2p,
    this value is 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Dst Party | Sequence of Integer | Variable | Destination Party: An object
    identifier that specifies the party that is the intended recipient of the message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Src Party | Sequence of Integer | Variable | Source Party: An object identifier
    that specifies the party that is the sender of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| Context | Sequence of Integer | Variable | Context: Defines a set of MIB
    object resources that is accessible by a particular entity. |'
  prefs: []
  type: TYPE_TB
- en: '| PDU | — | Variable | PDU: The protocol data unit of the message. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv2p general message format](httpatomoreillycomsourcenostarchimages288245.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-5. SNMPv2p general message format
  prefs: []
  type: TYPE_NORMAL
- en: Community-Based SNMP Version 2 (SNMPv2c) Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The community-based version of SNMPv2 was intended to keep the new protocol
    enhancements introduced by SNMPv2p but go back to the simple SNMPv1 security model.
    As such, the defining document for SNMPv2c, RFC 1901, specifies that its overall
    message format is the same as that of SNMPv1, except that the version number is
    changed. This is shown in [Table 68-7](ch68s05.html#community-based_snmp_version__snmpvc_gen
    "Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format")
    and illustrated in [Figure 68-6](ch68s05.html#snmpv2c_general_message_format "Figure 68-6. SNMPv2c
    general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2c,
    this value is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Community | Octet String | Variable | Community String: Identifies the SNMP
    community in which the sender and recipient of this message are located. |'
  prefs: []
  type: TYPE_TB
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv2c general message format](httpatomoreillycomsourcenostarchimages288247.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-6. SNMPv2c general message format
  prefs: []
  type: TYPE_NORMAL
- en: User-Based SNMP Version 2 (SNMPv2u) Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user-based version of SNMPv2 was defined as an optional security model at
    the time that SNMPv2c was standardized. RFC 1910 defines the user-based security
    model and the message format described in [Table 68-8](ch68s05.html#user-based_snmp_version__snmpvu_general_
    "Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format") and
    illustrated in [Figure 68-7](ch68s05.html#snmpv2u_general_message_format "Figure 68-7. SNMPv2u
    general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2u,
    this value is 2\. Note that this is the same value as used for SNMPv2p. |'
  prefs: []
  type: TYPE_TB
- en: '| Parameters | Octet String | Variable | Parameters: A string of parameters
    used to implement the user-based security model, which are briefly described in
    [Table 68-9](ch68s05.html#snmpvu_parameter_field_subfields "Table 68-9. SNMPv2u
    Parameter Field Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. This may be in either encrypted or unencrypted form. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv2u general message format](httpatomoreillycomsourcenostarchimages288249.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-7. SNMPv2u general message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-9. SNMPv2u Parameter Field Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Model | 1 | Model Number: Set to 1 to identify the user-based model. |'
  prefs: []
  type: TYPE_TB
- en: '| QoS | 1 | Quality of Service: Indicates whether authentication and/or privacy
    (encryption) have been used and whether generation of a Report-PDU is allowed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Agent ID | 12 | Agent Identifier: The identifier of the agent sending the
    message. Used to defeat replay attacks and certain other types of security attacks.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Agent Boots | 4 | Agent Number of Boots: The number of times the agent has
    been booted or rebooted since its Agent ID was set; used to defeat certain security
    attacks. |'
  prefs: []
  type: TYPE_TB
- en: '| Agent Time | 4 | Agent Time Since Last Boot: The number of seconds since
    the last boot of this agent. Again, used to defeat replay and other security attacks.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Max Size | 2 | Maximum Message Size: The maximum size of message that the
    sender of this message can receive. |'
  prefs: []
  type: TYPE_TB
- en: '| User Len | 1 | User Length: The length of the User Name field below. |'
  prefs: []
  type: TYPE_TB
- en: '| User Name | Variable (1 to 16) | User Name: The name of the user on whose
    behalf the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| Auth Len | 1 | Authentication Digest Length: The length of the Auth Digest
    field. |'
  prefs: []
  type: TYPE_TB
- en: '| Auth Digest | Variable (0 to 255) | Authentication Digest: An authentication
    value used to verify the identity and genuineness of this message, when authentication
    is used. |'
  prefs: []
  type: TYPE_TB
- en: '| Context Selector | Variable (0 to 40) | Context Selector: A string that is
    combined with the Agent ID to specify a particular context that contains the management
    information referenced by this message. |'
  prefs: []
  type: TYPE_TB
- en: SNMPv2 PDU Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format of protocol data units in SNMPv2 is described in RFC 1905, and it
    is similar to that of SNMPv1\. The format for all PDUs in SNMPv2 is the same,
    except for the GetBulkRequest-PDU message. (Oddly, this includes the Trapv2-PDU
    message, even though the Trap-PDU message in SNMPv1 used a distinct format.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001 "Table 68-10. SNMPv2
    Common PDU Format") shows the common SNMPv2 PDU format. [Table 68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "Table 68-11. SNMPv2 PDU Error Status Field Values") contains a listing of the
    different values for the Error Status field and how they are interpreted. [Figure 68-8](ch68s05.html#snmpv2_common_pdu_format
    "Figure 68-8. SNMPv2 common PDU format") illustrates the SNMPv2 common PDU format.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-10. SNMPv2 Common PDU Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type:0 = GetRequest-PDU1 = GetNextRequest-PDU2 = Response-PDU3 = SetRequest-PDU4
    = Obsolete, not used (this was the old Trap-PDU in SNMPv1)5 = GetBulkRequest-PDU
    (has its own format; see [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format"))6 = InformRequest-PDU7 = Trapv2-PDU8
    = Report-PDU |'
  prefs: []
  type: TYPE_TB
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a Response-PDU by the responding SNMP entity. |'
  prefs: []
  type: TYPE_TB
- en: '| Error Status | Integer (Enumerated) | 4 | Error Status: An integer value
    that is used in a Response-PDU to tell the requesting SNMP entity the result of
    its request. A value of zero indicates that no error occurred; the other values
    indicate what sort of error happened (see [Table 68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "Table 68-11. SNMPv2 PDU Error Status Field Values")). |'
  prefs: []
  type: TYPE_TB
- en: '| Error Index | Integer | 4 | Error Index: When Error Status is nonzero, this
    field contains a pointer that specifies which object generated the error. Always
    zero in a request. |'
  prefs: []
  type: TYPE_TB
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU, and in the case of messages other
    than requests, containing their values. See the discussion of the general SNMP
    general PDU format earlier in this chapter for more on these bindings. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The first six Error Status field values (0 to 5) are maintained as used in
    SNMPv1 for compatibility, but SNMPv2 adds many new error codes that provide more
    specific indication of the exact nature of an error in a request. The genErr code
    is still used only when none of the specific error types (either the old codes
    or the new ones) apply*.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-11. SNMPv2 PDU Error Status Field Values
  prefs: []
  type: TYPE_NORMAL
- en: '| Error Status Value | Error Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | noError | No error occurred. This code is also used in all request PDUs,
    since they have no error status to report. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | tooBig | The size of the Response-PDU would be too large to transport.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | noSuchName | The name of a requested object was not found. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | badValue | A value in the request didn''t match the structure that the
    recipient of the request had for the object. For example, an object in the request
    was specified with an incorrect length or type. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | readOnly | An attempt was made to set a variable that has an Access value
    indicating that it is read-only. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | genErr | An error occurred other than one indicated by a more specific
    error code in this table. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | noAccess | Access was denied to the object for security reasons. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | wrongType | The object type in a variable binding is incorrect for the
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | wrongLength | A variable binding specifies a length incorrect for the
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | wrongEncoding | A variable binding specifies an encoding incorrect for
    the object. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | wrongValue | The value given in a variable binding is not possible for
    the object. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | noCreation | A specified variable does not exist and cannot be created.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | inconsistentValue | A variable binding specifies a value that could
    be held by the variable but cannot be assigned to it at this time. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | resourceUnavailable | An attempt to set a variable required a resource
    that is not available. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | commitFailed | An attempt to set a particular variable failed. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | undoFailed | An attempt to set a particular variable as part of a group
    of variables failed, and the attempt to then undo the setting of other variables
    was not successful. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | authorizationError | A problem occurred in authorization. |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | notWritable | The variable cannot be written or created. |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | inconsistentName | The name in a variable binding specifies a variable
    that does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '![SNMPv2 common PDU format](httpatomoreillycomsourcenostarchimages288251.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-8. SNMPv2 common PDU format
  prefs: []
  type: TYPE_NORMAL
- en: The special format of the SNMPv2 GetBulkRequest-PDU message is shown in [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format") and illustrated in [Figure 68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "Figure 68-9. SNMPv2 GetBulkRequest-PDU format").
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMPv2 GetBulkRequest-PDU format](httpatomoreillycomsourcenostarchimages288253.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-9. SNMPv2 GetBulkRequest-PDU format
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-12. SNMPv2 GetBulkRequest-PDU Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type, which is 5 for a GetBulkRequest-PDU message. |'
  prefs: []
  type: TYPE_TB
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a Response-PDU by the responding SNMP entity. |'
  prefs: []
  type: TYPE_TB
- en: '| Non Repeaters | Integer | 4 | Non Repeaters: Specifies the number of nonrepeating,
    regular objects at the start of the variable list in the request. |'
  prefs: []
  type: TYPE_TB
- en: '| Max Repetitions | Integer | 4 | Maximum Repetitions: The number of iterations
    in the table to be read for the repeating objects that follow the nonrepeating
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  prefs: []
  type: TYPE_TB
- en: '[Chapter 67](ch67.html "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL
    (SNMP) CONCEPTS AND OPERATION") contains full details on how the Non Repeaters
    and Max Repetitions fields are used.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Version 3 (SNMPv3) Message Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the late 1990s, SNMPv3 was created to resolve the problems that occurred
    with the many different variations of SNMPv2\. The SNMPv3 Framework adopts many
    components that were created in SNMPv2, including the SNMPv2 protocol operations,
    PDU types, and PDU format. The significant changes made in SNMPv3 include a more
    flexible way of defining security methods and parameters to allow the coexistence
    of multiple security techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The general message format for SNMPv3 still follows the same idea of an overall
    message wrapper that contains a header and an encapsulated PDU, but it is further
    refined. The fields in the header have themselves been divided into those dealing
    with security and those that do not deal with security matters. The fields not
    related to security are common to all SNMPv3 implementations. The use of the security
    fields can be tailored by each SNMPv3 security model, and processed by the module
    in an SNMP entity that deals with security. This solution provides considerable
    flexibility while avoiding the problems that plagued SNMPv2.
  prefs: []
  type: TYPE_NORMAL
- en: The overall SNMPv3 message format is described in RFC 3412, which specifies
    its message processing and dispatching. [Table 68-13](ch68s06.html#snmp_version__snmpv_general_messag-id001
    "Table 68-13. SNMP Version 3 (SNMPv3) General Message Format") describes the SNMPv3
    message format, and it is illustrated in [Figure 68-10](ch68s06.html#snmpv3_general_message_format
    "Figure 68-10. SNMPv3 general message format").
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMPv3 general message format](httpatomoreillycomsourcenostarchimages288255.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 68-10. SNMPv3 general message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 68-13. SNMP Version 3 (SNMPv3) General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Msg Version | Integer | 4 | Message Version Number: Describes the SNMP version
    number of this message; used for ensuring compatibility between versions. For
    SNMPv3, this value is 3. |'
  prefs: []
  type: TYPE_TB
- en: '| Msg ID | Integer | 4 | Message Identifier: A number used to identify an SNMPv3
    message and to match response messages to request messages. The use of this field
    is similar to that of the Request ID field in the SNMPv2 PDU format (see [Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001
    "Table 68-10. SNMPv2 Common PDU Format")), but they are not identical. This field
    was created to allow matching at the message-processing level, regardless of the
    contents of the PDU, to protect against certain security attacks. Thus, Msg ID
    and Request ID are used independently. |'
  prefs: []
  type: TYPE_TB
- en: '| Msg Max Size | Integer | 4 | Maximum Message Size: The maximum size of message
    that the sender of this message can receive. Minimum value of this field is 484.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Msg Flags | Octet String | 1 | Message Flags: A set of flags that controls
    processing of the message. The current substructure of this field is shown in
    [Table 68-14](ch68s06.html#snmpv_msg_flags_subfields "Table 68-14. SNMPv3 Msg
    Flags Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: '| Msg Security Model | Integer | 4 | Message Security Model: An integer value
    indicating which security model was used for this message. For the user-based
    security model (the default in SNMPv3), this value is 3. |'
  prefs: []
  type: TYPE_TB
- en: '| Msg Security Parameters | — | Variable | Message Security Parameters: A set
    of fields that contain parameters required to implement the particular security
    model used for this message. The contents of this field are specified in each
    document describing an SNMPv3 security model. For example, the parameters for
    the user-based model are in RFC 3414. |'
  prefs: []
  type: TYPE_TB
- en: '| Scoped PDU | — | Variable | Scoped PDU: Contains the PDU to be transmitted,
    along with parameters that identify an SNMP context, which describes a set of
    management information accessible by a particular entity. The PDU is said to be
    *scoped* because it is applied within the scope of this context. (Yes, security
    stuff is confusing, sorry; it would take pages and pages to properly explain contexts;
    see RFC 3411.) The field may be encrypted or unencrypted depending on the value
    of *Priv Flag*. Its structure is shown in [Table 68-15](ch68s06.html#snmpv_scoped_pdu_subfields
    "Table 68-15. SNMPv3 Scoped PDU Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: Table 68-14. SNMPv3 Msg Flags Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 5 | Reserved: Reserved for future use. |'
  prefs: []
  type: TYPE_TB
- en: '| Reportable Flag | 1 | Reportable Flag: When set to 1, a device receiving
    this message must send back a Report-PDU whenever conditions arise where such
    a PDU should be generated. |'
  prefs: []
  type: TYPE_TB
- en: '| Priv Flag | 1 | Privacy Flag: When set to 1, indicates that encryption was
    used to protect the privacy of the message. May not be set to 1 unless Auth Flag
    is also set to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Auth Flag | 1 | Authentication Flag: When set to 1, indicates that authentication
    was used to protect the authenticity of this message. |'
  prefs: []
  type: TYPE_TB
- en: Table 68-15. SNMPv3 Scoped PDU Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Syntax | Size | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Context Engine ID | Octet String | Variable | Used to identify to which application
    the PDU will be sent for processing. |'
  prefs: []
  type: TYPE_TB
- en: '| Context Name | Octet String | Variable | An object identifier specifying
    the particular context associated with this PDU. |'
  prefs: []
  type: TYPE_TB
- en: '| PDU | — | Variable | The protocol data unit being transmitted. |'
  prefs: []
  type: TYPE_TB
- en: Fortunately, SNMPv3 uses the protocol operations from SNMPv2, as described in
    RFC 3416, which is just an update of RFC 1904\. Thus, the PDU formats for SNMPv3
    are the same as those of SNMPv2 (see Tables [Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001
    "Table 68-10. SNMPv2 Common PDU Format") through [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format") and Figures [Figure 68-8](ch68s05.html#snmpv2_common_pdu_format
    "Figure 68-8. SNMPv2 common PDU format") and [Figure 68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "Figure 68-9. SNMPv2 GetBulkRequest-PDU format")).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've seen in the preceding chapters of this part that the Simple Network Management
    Protocol (SNMP) defines both a framework and a specific protocol for exchanging
    network information on a TCP/IP internetwork. The general model used by SNMP is
    that of a network management station (NMS) that sends requests to SNMP agents
    running on managed devices. The SNMP agents may also initiate certain types of
    communication by sending *trap* messages to tell the NMS when particular events
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: This model works well, which is why SNMP has become so popular. However, one
    fundamental limitation of the protocol and the model it uses is that it is oriented
    around the communication of network information from SNMP agents that are normally
    part of regular TCP/IP devices, such as hosts and routers. The amount of information
    gathered by these devices is usually somewhat limited, because obviously hosts
    and routers have real work to do—that is, doing the jobs of being hosts and routers.
    They can't devote themselves to network management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in situations where more information is needed about a network than is
    gathered by traditional devices, administrators often use special hardware units
    called *network analyzers*, *monitors*, or *probes*. These are dedicated pieces
    of equipment that are connected to a network and used strictly for the purpose
    of gathering statistics and watching for events of interest or concern to the
    administrator. It would obviously be very useful if these devices could use SNMP
    to allow the information they gather to be retrieved, and to let them generate
    traps when they notice something important. To enable this, the *Remote Network
    Monitoring (RMON)* specification was created.
  prefs: []
  type: TYPE_NORMAL
- en: RMON Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RMON is often called a protocol, and you will sometimes see SNMP and RMON referred
    to as the TCP/IP network management protocols. However, RMON really isn't a separate
    protocol at all—it defines no protocol operations. RMON is actually part of SNMP,
    and the RMON specification is simply a management information base (MIB) module
    that defines a particular set of MIB objects for use by network monitoring probes.
    Architecturally, it is just one of the many MIB modules that compose the SNMP
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SNMP *Remote Network Monitoring (RMON)* was created to enable
    the efficient management of networks using dedicated management devices such as
    network analyzers, monitors, or probes. RMON is often called a protocol, but it
    does not define any new protocol operations. It is actually an MIB module for
    SNMP that describes objects that permit advanced network management capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: The first standard documenting RMON was RFC 1271, "Remote Network Monitoring
    Management Information Base," published in 1991\. RFC 1271 was replaced by RFC
    1757 in 1995, which made a couple of changes to the specification. RFC 2819, published
    in May 2000, updates RMON to use the new Structure of Management Information version
    2 (SMIv2) specification that is part of SNMPv2 but is functionally the same as
    RFC 1757.
  prefs: []
  type: TYPE_NORMAL
- en: RMON MIB Hierarchy and Object Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since RMON is a MIB module, it consists almost entirely of descriptions for
    MIB objects, each with the standard characteristics belonging to all such objects.
    All the objects within RMON are arranged into the SNMP object name hierarchy within
    the *rmon* group, which is group number 16 within the SNMP mib (mib-2) object
    tree, 1.3.6.1.2.1\. So, all RMON objects have identifiers starting with 1.3.6.1.2.1.16\.
    This single RMON group is broken down into several lower-level groups that provide
    more structure for the RMON objects defined by the specification. [Figure 69-1](ch69s02.html#snmp_remote_network_monitoring_rmon_mib_
    "Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a
    special MIB module, rmon(16), which fits into the overall SNMP object hierarchy
    tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such
    as sys(1) and if(2); see Figure 66-2 in Chapter 66\. Within this group, which
    has the group identifier 1.3.6.1.2.1.16, are nine subgroups of RMON objects.")
    shows this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 69-1](ch69s02.html#snmp_rmon_mib_object_groups "Table 69-1. SNMP RMON
    MIB Object Groups") describes each of the RMON groups, showing its name, group
    code (which is used as the prefix for object descriptors in the group), and RMON
    group number and SNMP object hierarchy identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a special MIB
    module, rmon(16), which fits into the overall SNMP object hierarchy tree under
    mib/mib-2(1) within mgmt(2)—just like other MIB object groups such as sys(1) and
    if(2); see in . Within this group, which has the group identifier 1.3.6.1.2.1.16,
    are nine subgroups of RMON objects.](httpatomoreillycomsourcenostarchimages288257.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a
    special MIB module, rmon(16), which fits into the overall SNMP object hierarchy
    tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such
    as sys(1) and if(2); see [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.") in [Chapter 66](ch66.html "Chapter 66. TCP/IP STRUCTURE
    OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)"). Within
    this group, which has the group identifier 1.3.6.1.2.1.16, are nine subgroups
    of RMON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Table 69-1. SNMP RMON MIB Object Groups
  prefs: []
  type: TYPE_NORMAL
- en: '| RMON Group Name | RMON Group Code | RMON Group Number | Full Group Identifier
    | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| statistics | etherStats | 1 | 1.3.6.1.2.1.16.1 | This group contains objects
    that keep track of network statistics measured by the device. Statistics may include
    network traffic load, average packet size, number of broadcasts observed, counts
    of errors that have occurred, the number of packets in various size ranges, and
    so forth. |'
  prefs: []
  type: TYPE_TB
- en: '| history | history, etherHistory | 2 | 1.3.6.1.2.1.16.2 | The history group
    contains a single table object that controls how often statistical data is sampled
    by the probe. The additional etherHistory group is optional and contains extra
    Ethernet-specific information; it is contained logically within the history group.
    |'
  prefs: []
  type: TYPE_TB
- en: '| alarm | alarm | 3 | 1.3.6.1.2.1.16.3 | This group defines the parameters
    under which an alarm may be generated to inform an administrator of an occurrence
    of import. The alarm group contains a table that describes the thresholds that
    will cause an event to be triggered (see the event group description in this table).
    |'
  prefs: []
  type: TYPE_TB
- en: '| hosts | host | 4 | 1.3.6.1.2.1.16.4 | This group contains objects that keep
    track of information for each host on a network. |'
  prefs: []
  type: TYPE_TB
- en: '| hostsTopN | hostTopN | 5 | 1.3.6.1.2.1.16.5 | This group contains objects
    that facilitate reporting of hosts sorted in a particular way. The administrator
    determines how these ordered statistics are tracked. For example, an administrator
    could generate a report listing hosts sorted by the number of packets transmitted,
    showing the most active devices. |'
  prefs: []
  type: TYPE_TB
- en: '| matrix | matrix | 6 | 1.3.6.1.2.1.16.6 | This group keeps track of statistics
    for data exchanges between particular pairs of hosts. The amount of data sent
    between any two devices on the network could be tracked here. Since a large network
    could have thousands of such device pairs, to conserve resources on the probe,
    often only the most recent conversations between device pairs are kept in the
    MIB. |'
  prefs: []
  type: TYPE_TB
- en: '| filter | filter | 7 | 1.3.6.1.2.1.16.7 | This group allows an administrator
    to set up filters that control what sorts of network packets the probe will capture.
    |'
  prefs: []
  type: TYPE_TB
- en: '| capture | buffer, capture | 8 | 1.3.6.1.2.1.16.8 | This group is used to
    allow a probe to capture packets based on particular parameters set up in the
    filter group. |'
  prefs: []
  type: TYPE_TB
- en: '| event | event | 9 | 1.3.6.1.2.1.16.9 | When a particular alarm is triggered
    based on the parameters in the objects in the alarm group, an event is generated.
    This group controls how these events are processed, including creating and sending
    an SNMP trap message to an NMS. |'
  prefs: []
  type: TYPE_TB
- en: The original RMON standard was heavily oriented around Ethernet local area networks
    (LANs), and you can see some of that in [Table 69-1](ch69s02.html#snmp_rmon_mib_object_groups
    "Table 69-1. SNMP RMON MIB Object Groups"). Probes can also gather and report
    information related to other networking technologies by using other RMON groups
    created for that purpose. The best example of this was the definition of a set
    of groups specifically for Token Ring, which was defined in RFC 1513 in 1993.
  prefs: []
  type: TYPE_NORMAL
- en: RMON Alarms, Events, and Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alarms and events are particularly useful constructs in RMON, as they allow
    the immediate communication of important information to an NMS. The administrator
    has full control over what conditions will cause an alarm to be sounded and how
    an event is generated. This includes specifying which variables or statistics
    to monitor, how often to check them, and what values will trigger an alarm. A
    log entry may also be recorded when an event occurs. If an event results in transmission
    of a trap message, the administrator will thus be notified and can decide how
    to respond, depending on the severity of the event.
  prefs: []
  type: TYPE_NORMAL
- en: Like all MIB modules and groups, a particular manufacturer may decide which
    RMON groups to implement. However, certain groups—such as alarm and event—are
    related, and some groups—such as statistics—are usually implemented in all RMON
    probes. Obviously, when RMON is used, the NMS must be aware of RMON groups and
    must allow a network management application to be run that will exploit the capabilities
    of the RMON MIB objects.
  prefs: []
  type: TYPE_NORMAL
