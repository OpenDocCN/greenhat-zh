- en: Part III-4. TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分-4. TCP/IP网络管理框架和协议
- en: '[Chapter 65](ch65.html "Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK
    OVERVIEW")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第65章](ch65.html "第65章。TCP/IP互联网标准管理框架概述")'
- en: '[Chapter 66](ch66.html "Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION
    (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第66章](ch66.html "第66章。TCP/IP管理信息（SMI）和管理信息库（MIBs）结构")'
- en: '[Chapter 67](ch67.html "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL
    (SNMP) CONCEPTS AND OPERATION")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第67章](ch67.html "第67章。TCP/IP简单网络管理协议（SNMP）概念和操作")'
- en: '[Chapter 68](ch68.html "Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第68章](ch68.html "第68章。SNMP协议消息和消息格式")'
- en: '[Chapter 69](ch69.html "Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第69章](ch69.html "第69章。TCP/IP远程网络监控（RMON")'
- en: Modern networks and internetworks are larger, faster, and more capable than
    their predecessors of years gone by. As we expand, speed up, and enhance our networks,
    they become more complex, and as a result, more difficult to manage. Years ago,
    an administrator could get by with very simple tools to keep a network running,
    but today, more sophisticated network management technologies are required to
    match the sophistication of our networks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与多年前的前辈相比，现代网络和互联网更大、更快、功能更强大。随着我们扩展、加速和增强我们的网络，它们变得更加复杂，因此管理起来也更加困难。多年前，管理员可以用非常简单的工具来维持网络的运行，但如今，需要更复杂的网络管理技术来匹配我们网络的复杂性。
- en: Some of the most important tools in the network manager's toolbox are now in
    the form of software, not hardware. To manage a sprawling, heterogeneous, and
    complex internetwork, we can employ software applications to gather information
    and control devices using the internetwork itself. TCP/IP, being the most popular
    internetworking suite, has such software tools. One of the most important is a
    pair of protocols that have been implemented as part of an overall method of network
    management called the *TCP/IP Internet Standard Management Framework*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员工具箱中的一些最重要的工具现在都是以软件的形式存在的，而不是硬件。为了管理一个庞大、异构和复杂的互联网，我们可以使用软件应用程序来收集信息并使用互联网本身来控制设备。作为最受欢迎的互联网套件，TCP/IP提供了这样的软件工具。其中最重要的一个是作为整体网络管理方法的一部分实现的两个协议，称为*TCP/IP互联网标准管理框架*。
- en: 'This part describes the TCP/IP Internet Standard Management Framework, looking
    at each of its architectural and protocol components and how they interoperate.
    The first chapter provides an overview of the network management framework itself
    and serves as an introduction to the chapters that follow. The second chapter
    discusses the way that network management information is structured and arranged
    into information stores called *management information bases (MIBs)*. The third
    chapter describes the concepts behind and operation of the key protocol in TCP/IP
    network management: the Simple Network Management Protocol (SNMP). The fourth
    chapter provides details on SNMP''s messaging and message formats. Finally, the
    fifth chapter takes a brief look at Remote Network Monitoring (RMON), an enhancement
    of SNMP—sometimes called a protocol, even though it really isn''t—that provides
    administrators with greater management and monitoring abilities on a TCP/IP internetwork.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分描述了TCP/IP互联网标准管理框架，探讨了其各个架构和协议组件以及它们如何交互。第一章提供了网络管理框架本身的概述，并为后续章节提供了介绍。第二章讨论了网络管理信息是如何结构化和组织到称为*管理信息库（MIBs）*的信息存储中的。第三章描述了TCP/IP网络管理中关键协议背后的概念和操作：简单网络管理协议（SNMP）。第四章提供了SNMP消息和消息格式的详细信息。最后，第五章简要介绍了远程网络监控（RMON），这是SNMP的一个增强功能——尽管它有时被称为协议，但实际上并不是——它为管理员提供了在TCP/IP互联网上更强大的管理和监控能力。
- en: Note that while you may be tempted to jump straight to the chapter on SNMP,
    what is written there will make a lot more sense if you read the chapters of this
    part in order.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然你可能想直接跳到SNMP章节，但如果你按照顺序阅读本部分的所有章节，那里的内容会更有意义。
- en: Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第65章。TCP/IP互联网标准管理框架概述
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'TCP/IP network management functions are most commonly associated with the key
    protocol responsible for implementing those functions: the *Simple Network Management
    Protocol (SNMP)*. Many people have heard of SNMP, and it is common for SNMP to
    be considered "the" way that network management is performed in TCP/IP. This is
    true to an extent, but is really an oversimplification. The actual SNMP protocol
    is only one part of a higher-level network management strategy called the *Internet
    Standard Management Framework*. In order to really understand how SNMP works,
    you need to first have some background on the way this network management is structured
    as a whole.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP网络管理功能最常与负责实现这些功能的关键协议相关联：*简单网络管理协议（SNMP）*。许多人听说过SNMP，并且通常认为SNMP是TCP/IP中执行网络管理“的方式”。这在某种程度上是正确的，但实际上是一种过度简化。实际的SNMP协议只是称为*互联网标准管理框架*的更高层次网络管理策略的一部分。为了真正理解SNMP是如何工作的，你需要首先了解这种网络管理作为整体是如何构建的。
- en: In this chapter, I provide an introduction to TCP/IP network management by describing
    the concepts and components of the TCP/IP Internet Standard Management Framework.
    I begin with an overview and history of the framework, and discuss how it is related
    to SNMP. I describe the TCP/IP network management model and the key components
    that compose a network management system. I provide a summary of the architecture
    of the Internet Standard Management Framework. I then describe the three main
    versions of the Framework and SNMP and how they compare. I conclude with a discussion
    of the many standards used to describe this technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过描述TCP/IP互联网标准管理框架的概念和组件来介绍TCP/IP网络管理。我首先概述了框架的历史，并讨论了它与SNMP的关系。我描述了TCP/IP网络管理模型和组成网络管理系统的主要组件。我总结了互联网标准管理框架的架构。然后，我描述了框架和SNMP的三个主要版本以及它们之间的比较。最后，我讨论了用于描述这项技术的许多标准。
- en: Overview and History of the TCP/IP Internet Standard Management Framework and
    Simple Network Management Protocol (SNMP)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP互联网标准管理框架和简单网络管理协议（SNMP）概述和历史
- en: An adage from the world of professional sports says that a baseball umpire is
    doing a good job when you forget that he is there. In many ways, the same could
    be said of a network administrator. The administrator is doing a good job when
    the network is running so smoothly and efficiently that users forget that the
    administrator exists. Because, as the administrator knows all too well, the second
    there is a problem, the users will all remember very quickly that he or she is
    there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 来自职业体育界的谚语说，当人们忘记棒球裁判的存在时，裁判就做得很好。在许多方面，这同样适用于网络管理员。当网络运行得如此顺畅和高效，以至于用户忘记了管理员的存在时，管理员就做得很好。因为，正如管理员所深知的那样，一旦出现问题，用户会很快记住他或她的存在。
- en: A primary job of a network administrator is to keep tabs on the network and
    ensure that it is operating normally. Information about the hardware and software
    on the network is a key to performing this task properly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员的主要工作之一是监控网络并确保其正常运行。关于网络上的硬件和软件的信息是正确执行此任务的关键。
- en: When networks were small, an administrator could stay informed about the status
    of hardware and software using simple means, such as physically walking over to
    a computer and using it, or using a low-level link layer management protocol.
    This is simply not possible with modern internetworks, which are large, geographically
    diverse, and often consist of many different lower-layer technologies. Usually,
    the only thing all the devices on the network have in common is an implementation
    of a particular internetworking protocol suite, such as TCP/IP. This makes the
    internetwork itself a logical way to facilitate the communication of network management
    information between devices and a network administrator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络规模较小时，管理员可以通过简单的方式了解硬件和软件的状态，例如亲自走到一台计算机前使用它，或者使用低级链路层管理协议。在当今的大型、地理上分散且通常由许多不同底层技术组成的互联网中，这是不可能的。通常，网络上所有设备唯一共同之处在于它们都实现了特定的互联网协议套件，例如TCP/IP。这使得互联网本身成为促进设备与网络管理员之间网络管理信息交流的逻辑方式。
- en: Early Development of SNMP
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP的早期发展
- en: 'Many people recognized during the early days of the Internet that some sort
    of network management technology would be needed for TCP/IP. Unfortunately, at
    first there was no single standard. In the 1980s, several different technologies
    were developed by different working groups. There were three main contestants:
    the *High-level Entity Management System (HEMS)/High-level Entity Management Protocol
    (HEMP)* as defined by RFCs 1021 through 1024; the *Simple Gateway Monitoring Protocol
    (SGMP)*, defined by RFC 1028; and the *Common Management Information Protocol
    (CMIP)*, which is actually part of the OSI protocol suite.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网的早期，许多人认识到需要某种网络管理技术来支持 TCP/IP。不幸的是，最初并没有一个单一的标准。在 1980 年代，不同的工作组开发了多种不同的技术。有三个主要竞争者：由
    RFC 1021 至 1024 定义的高层实体管理系统（HEMS）/高层实体管理协议（HEMP）；由 RFC 1028 定义的 *简单网关监控协议（SGMP*）；以及实际上是
    OSI 协议套件一部分的 *通用管理信息协议（CMIP*）。
- en: The Internet Engineering Task Force (IETF) recognized the importance of having
    a unifying management standard for TCP/IP, and in 1988, published RFC 1052, "IAB
    Recommendations for the Development of Internet Network Management Standards."
    This memo is not a standard, but more a statement of intention and documentation
    of a meeting held on this subject. The conclusion of RFC 1052 was that SGMP be
    used as the basis of a new Internet standard to be called the *Simple Network
    Management Protocol (SNMP)*. This development was to be carried out by the SNMP
    Working Group.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网工程任务组（IETF）认识到拥有一个统一的管理标准对于 TCP/IP 的重要性，并于 1988 年发布了 RFC 1052，“IAB 关于开发互联网网络管理标准的建议”。这份备忘录不是一个标准，而更多的是一个意向声明和对有关此主题的会议的记录。RFC
    1052 的结论是使用 SGMP 作为新互联网标准的基础，该标准被称为 *简单网络管理协议（SNMP*）。这项发展将由 SNMP 工作组执行。
- en: The Two Meanings of SNMP
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 的两种含义
- en: 'The rationale of the middle two words in the name Simple Network Management
    Protocol is obvious, but the other two words are slightly more problematic. The
    word *Protocol* implies that SNMP is just a TCP/IP communication protocol, like
    other protocols, such as the Dynamic Host Configuration Protocol (DHCP) and the
    File Transfer Protocol (FTP). Unfortunately, this is both true and untrue: the
    name is ambiguous.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简单网络管理协议（SNMP）名称中中间两个单词的合理性是显而易见的，但其他两个单词则稍微有些问题。单词 *协议* 假设 SNMP 只是一个 TCP/IP
    通信协议，就像其他协议一样，例如动态主机配置协议（DHCP）和文件传输协议（FTP）。不幸的是，这个说法既是真的又是假的：名称是含糊的。
- en: At a lower level, SNMP does indeed refer specifically to the actual protocol
    that carries network management information between devices. This is what most
    people think of when they talk about SNMP. However, as defined by the SNMP working
    group, the TCP/IP network management solution as a whole consists of a number
    of different elements arranged in an architecture. This architecture originally
    had no specific name, but is now called the *Internet Standard Management Framework*.
    Oddly, this higher-level framework is not abbreviated ISMF, but is *also* called
    SNMP, which means that context is important in understanding that term.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在较低级别，SNMP 确实指的是在设备之间传输网络管理信息的实际协议。这就是大多数人谈论 SNMP 时所想到的。然而，根据 SNMP 工作组的定义，TCP/IP
    网络管理解决方案作为一个整体由多个不同的元素组成，这些元素按照一种架构排列。这个架构最初没有特定的名称，但现在被称为 *互联网标准管理框架*。奇怪的是，这个高级框架不是缩写为
    ISMF，而是 *也* 被称为 SNMP，这意味着理解这个术语时上下文很重要。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*To avoid confusion, I will often use the phrases SNMP Framework and SNMP protocol
    to differentiate these two uses of the term SNMP*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了避免混淆，我经常会使用“SNMP 框架”和“SNMP 协议”这两个短语来区分这两个术语的用法*。'
- en: Design Goals of SNMP
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 的设计目标
- en: The word *Simple* in the protocol's name is another problem. Even in its first
    iteration, it was only somewhat simple. The most current version of SNMP is fairly
    complicated indeed, with many different standards defining the SNMP Framework,
    the SNMP protocol itself, and a number of supporting elements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议名称中的单词 *简单* 是另一个问题。即使在它的第一个版本中，它也只是相对简单。SNMP 的最新版本实际上相当复杂，有多个不同的标准定义了 SNMP
    框架、SNMP 协议本身以及许多支持元素。
- en: 'So why is it called *Simple?* Well, as they say, everything is relative. SNMP
    is simple when compared to other protocols that are even more complex. Some of
    this can be seen by looking at the basic goals of the Internet Standard Management
    Framework and the SNMP protocol as a whole:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么叫 *简单* 呢？好吧，正如他们所说，一切都是相对的。与更复杂的其他协议相比，SNMP是简单的。这可以通过查看互联网标准管理框架和SNMP协议的整体基本目标来看到：
- en: SNMP defines a universal way that management information can be easily defined
    for any object, and then exchanged between that object and a device designed to
    facilitate network management.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP定义了一种通用的方式，可以轻松地为任何对象定义管理信息，然后在该对象和用于简化网络管理的设备之间交换。
- en: SNMP separates the functions of defining and communicating management information
    from the applications that are used for network management.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP将定义和通信管理信息的功能与应用程序分开，这些应用程序用于网络管理。
- en: The actual SNMP protocol is fairly simple, consisting of only a few easy-to-understand
    protocol operations.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的SNMP协议相当简单，只包含几个易于理解的协议操作。
- en: The implementation of SNMP is relatively simple for the designers and manufacturers
    of products.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于产品和的设计师和制造商来说，SNMP的实现相对简单。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The *Simple Network Management Protocol (SNMP)* defines a set
    of technologies that allow network administrators to remotely monitor and manage
    TCP/IP network devices. The term SNMP refers both to a specific communication
    protocol (sometimes called the *SNMP protocol*) and an overall framework for Internet
    management (the *SNMP Framework*).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *简单网络管理协议（SNMP）* 定义了一套技术，允许网络管理员远程监控和管理TCP/IP网络设备。术语SNMP既指一个特定的通信协议（有时称为
    *SNMP协议*），也指一个整体的互联网管理框架（*SNMP框架*）。'
- en: Since SNMP is a TCP/IP application layer protocol, it can theoretically run
    over a variety of transport mechanisms. It is most commonly implemented over the
    Internet Protocol (IP), but the most recent versions also define *transport mappings*
    that can allow SNMP information to be carried over other internetworking technologies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SNMP是一个TCP/IP应用层协议，理论上它可以在各种传输机制上运行。它最常在互联网协议（IP）上实现，但最新的版本也定义了可以允许SNMP信息通过其他互联网技术传输的
    *传输映射*。
- en: Further Development of SNMP and the Problem of SNMP Variations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP的进一步发展和SNMP变体的问题
- en: The first Internet Standard Management Framework developed (in 1988) is now
    called *SNMP version 1 (SNMPv1)*. This initial version of SNMP achieved widespread
    acceptance, and it is still probably the most common version of SNMP.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个开发的互联网标准管理框架（在1988年）现在被称为 *SNMP版本1（SNMPv1）*。这个SNMP的初始版本得到了广泛的认可，并且可能仍然是SNMP最常用的版本。
- en: Much of the history of SNMP since that time has been a rather confusing standards
    nightmare. SNMPv1 had a number of weaknesses, particularly in the area of security.
    For this reason, shortly after SNMPv1 was done, work began on a new version of
    SNMP. Unfortunately, this effort became a quagmire, with many competing variations
    of SNMPv2 being created. After many years of confusion, none of the SNMPv2 variants
    achieved significant success.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，SNMP的历史在很大程度上是一个相当混乱的标准噩梦。SNMPv1在安全领域存在一些弱点。因此，在SNMPv1完成后不久，就开始了一个新的SNMP版本的工作。不幸的是，这项工作变成了一片泥潭，许多SNMPv2的变体被创建出来。经过多年的混乱，没有一个SNMPv2变体取得了显著的成功。
- en: Recently, a third version of the SNMP Framework and protocol has been published,
    which adds new features and reunites SNMP under a single, universal protocol again.
    The discussions of SNMP versions and SNMP standards later in this chapter further
    explore the history of SNMP since 1988\. They can be considered a continuation
    of this historical overview, as they help clarify the very confusing story behind
    SNMP versions over the last decade and a half.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，已经发布了SNMP框架和协议的第三个版本，它增加了新功能，并将SNMP再次统一到一个单一的通用协议下。本章后面关于SNMP版本和SNMP标准的讨论进一步探讨了自1988年以来的SNMP历史。它们可以被视为这个历史概述的延续，因为它们有助于阐明过去十多年中SNMP版本背后的非常混乱的故事。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**RELATED INFORMATION** *More background on the SNMP protocol proper can be
    found in the overview of the actual protocol itself, in [Chapter 67](ch67.html
    "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION")*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *有关SNMP协议的更多背景信息可以在实际协议本身的概述中找到，在[第67章](ch67.html "第67章。TCP/IP简单网络管理协议(SNMP)概念和操作")中*。'
- en: TCP/IP SNMP Operational Model, Components, and Terminology
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP SNMP 操作模型、组件和术语
- en: So, it seems the *Simple* Network Management Protocol isn't quite so simple
    after all. There are many versions and standards and uses of SNMP, and so a lot
    to learn. I think a good place to start in understanding what SNMP does is to
    look at its *model of operation*. Then we can examine the components that compose
    a TCP/IP network management system and define the terminology used to describe
    them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来 *简单* 网络管理协议实际上并不那么简单。SNMP 有许多版本、标准和用途，因此有很多东西要学习。我认为理解 SNMP 做什么的良好起点是查看其
    *操作模型*。然后我们可以检查组成 TCP/IP 网络管理系统组件，并定义描述它们的术语。
- en: SNMP Device Types
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 设备类型
- en: 'The overall idea behind SNMP is to allow the information needed for network
    management to be exchanged using TCP/IP. More specifically, the protocol allows
    a network administrator to make use of a special network device that interacts
    with other network devices to collect information from them and modify how they
    operate. In the simplest sense, two different basic types of hardware devices
    are defined:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 的总体思想是允许使用 TCP/IP 交换网络管理所需的信息。更具体地说，该协议允许网络管理员利用一种特殊的网络设备，该设备与其他网络设备交互以收集信息并修改其操作方式。在最简单的意义上，定义了两种不同的基本类型的硬件设备：
- en: '**Managed Nodes** Regular nodes on a network that have been equipped with software
    to allow them to be managed using SNMP. These are, generally speaking, conventional
    TCP/IP devices. They are also sometimes called *managed devices*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**受管理节点** 网络上的常规节点，已经安装了软件，以便可以使用 SNMP 进行管理。这些通常是传统的 TCP/IP 设备。它们有时也被称为 *受管理设备*。'
- en: '**Network Management Station (NMS)** A designated network device that runs
    special software to allow it to manage the regular managed nodes mentioned just
    above. One or more NMSs must be present on the network, as these devices are the
    ones that really run SNMP.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络管理站 (NMS)** 一个指定的网络设备，运行特殊软件以允许其管理上面提到的常规受管理节点。网络中必须存在一个或多个 NMS，因为这些设备是真正运行
    SNMP 的设备。'
- en: SNMP Entities
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 实体
- en: Each device that participates in network management using SNMP runs a piece
    of software, generically called an *SNMP entity*. The SNMP entity is responsible
    for implementing all of the various functions of the SNMP protocol. Each entity
    consists of two primary software components. Which components make up the SNMP
    entity on a device depends on whether the device is a managed node or an NMS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 参与使用 SNMP 进行网络管理的每个设备都运行一个通称为 *SNMP 实体* 的软件。SNMP 实体负责实现 SNMP 协议的所有各种功能。每个实体由两个主要软件组件组成。组成设备上的
    SNMP 实体的组件取决于该设备是受管理节点还是 NMS。
- en: Managed Node Entities
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受管理节点实体
- en: 'The SNMP entity on a managed node consists of the following software elements
    and constructs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 受管理节点上的 SNMP 实体包括以下软件元素和结构：
- en: '**SNMP Agent** A software program that implements the SNMP protocol and allows
    a managed node to provide information to an NMS and accept instructions from it.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP 代理** 一个实现 SNMP 协议的软件程序，允许受管理节点向 NMS 提供信息并接受其指令。'
- en: '**SNMP Management Information Base (MIB)** An MIB defines the types of information
    stored about the node that can be collected and used to control the managed node.
    Information exchanged using SNMP takes the form of objects from the MIB.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP 管理信息库 (MIB)** MIB 定义了关于节点可以收集和用于控制受管理节点的信息类型。使用 SNMP 交换的信息采用 MIB 中的对象形式。'
- en: Network Management Station Entities
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络管理站实体
- en: 'The SNMP entity on an NMS consists of the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: NMS 上的 SNMP 实体包括以下内容：
- en: '**SNMP Manager** A software program that implements the SNMP protocol, allowing
    the NMS to collect information from managed nodes and to send instructions to
    them.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP 管理器** 一个实现 SNMP 协议的软件程序，允许 NMS 从受管理节点收集信息并向它们发送指令。'
- en: '**SNMP Applications** One or more software applications that allow a human
    network administrator to use SNMP to manage a network.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP 应用程序** 一个或多个软件应用程序，允许网络管理员使用 SNMP 管理网络。'
- en: SNMP Operational Model Summary
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 操作模型摘要
- en: So, to integrate and reiterate all of this, let's summarize. SNMP consists of
    a small number of *network management stations (NMSs)* that interact with regular
    TCP/IP devices that are called *managed nodes*. The *SNMP manager* on the NMS
    and the *SNMP agents* on the managed nodes implement the SNMP protocol and allow
    network management information to be exchanged. *SNMP applications* run on the
    NMS and provide the interface to the human administrator, and allow information
    to be collected from the *management information bases (MIBs)* at each SNMP agent.
    [Figure 65-1](ch65s02.html#snmp_operational_model_this_diagram_show "Figure 65-1. SNMP
    operational model This diagram shows a simplified implementation of SNMP, with
    one network management station (NMS) used to maintain three managed nodes. Each
    device has an SNMP entity, and they communicate using SNMP messages. The SNMP
    entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).") illustrates the SNMP operational model.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了综合和重申所有这些内容，让我们总结一下。SNMP由少数几个*网络管理站（NMSs）*组成，它们与被称为*管理节点*的常规TCP/IP设备交互。NMS上的*SNMP管理器*和管理节点上的*SNMP代理*实现了SNMP协议，并允许网络管理信息交换。*SNMP应用程序*运行在NMS上，为人类管理员提供接口，并允许从每个SNMP代理的*管理信息库（MIBs）*中收集信息。[图65-1](ch65s02.html#snmp_operational_model_this_diagram_show
    "图65-1. SNMP操作模型 此图显示了SNMP的简化实现，使用一个网络管理站（NMS）来维护三个管理节点。每个设备都有一个SNMP实体，它们通过SNMP消息进行通信。NMS的SNMP实体由SNMP管理器和一个或多个SNMP应用程序组成。每个管理节点运行一个SNMP代理并维护一个管理信息库（MIB）。")说明了SNMP操作模型。
- en: An SNMP managed node can be pretty much any network device that can communicate
    using TCP/IP, as long as it is programmed with the proper SNMP entity software.
    SNMP is designed to allow regular hosts to be managed, as well as intelligent
    network interconnection devices, such as routers, bridges, hubs, and switches.
    Other devices—printers, scanners, consumer electronic devices, specialized medical
    devices, and so on—can also be managed, as long as they connect to a TCP/IP internetwork.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SNMP管理的节点几乎可以是任何能够使用TCP/IP进行通信的网络设备，只要它被编程了适当的SNMP实体软件。SNMP的设计目的是允许普通主机被管理，以及智能网络互连设备，如路由器、桥接器、集线器和交换机。其他设备——打印机、扫描仪、消费电子设备、专用医疗设备等等——也可以被管理，只要它们连接到TCP/IP互连网络。
- en: On a larger network, an NMS may be a separate, high-powered TCP/IP computer
    dedicated to network management. However, it is really software that makes a device
    into an NMS, so the NMS may not be a separate hardware device. It may act as an
    NMS and also perform other functions on the network.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的网络中，一个NMS可能是一个独立的、高性能的TCP/IP计算机，专门用于网络管理。然而，真正使设备成为NMS的是软件，因此NMS可能不是一个独立的硬件设备。它可能充当NMS并同时在网络上执行其他功能。
- en: '![SNMP operational model This diagram shows a simplified implementation of
    SNMP, with one network management station (NMS) used to maintain three managed
    nodes. Each device has an SNMP entity, and they communicate using SNMP messages.
    The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).](httpatomoreillycomsourcenostarchimages288225.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP操作模型 此图显示了SNMP的简化实现，使用一个网络管理站（NMS）来维护三个管理节点。每个设备都有一个SNMP实体，它们通过SNMP消息进行通信。NMS的SNMP实体由SNMP管理器和一个或多个SNMP应用程序组成。每个管理节点运行一个SNMP代理并维护一个管理信息库（MIB）](http://atomoreilly.com/source/nostarch/images/288225.png.jpg)'
- en: Figure 65-1. SNMP operational model This diagram shows a simplified implementation
    of SNMP, with one network management station (NMS) used to maintain three managed
    nodes. Each device has an SNMP entity, and they communicate using SNMP messages.
    The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications.
    The managed nodes each run an SNMP agent and maintain a management information
    base (MIB).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图65-1. SNMP操作模型 此图显示了SNMP的简化实现，使用一个网络管理站（NMS）来维护三个管理节点。每个设备都有一个SNMP实体，它们通过SNMP消息进行通信。NMS的SNMP实体由SNMP管理器和一个或多个SNMP应用程序组成。每个管理节点运行一个SNMP代理并维护一个管理信息库（MIB）。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP allows a network administrator using a *network management
    station (NMS)* to control a set of managed nodes. Each device incorporates an
    *SNMP entity* that implements the technology. In an NMS, the entity consists of
    an *SNMP manager* module and a set of SNMP applications. In a managed node, the
    entity consists of an SNMP agent and *management information base (MIB)*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP 允许网络管理员使用 **网络管理站 (NMS)** 控制一组受管节点。每个设备都包含一个实现该技术的 **SNMP 实体**。在
    NMS 中，该实体由一个 **SNMP 管理器** 模块和一组 SNMP 应用程序组成。在受管节点中，该实体由一个 SNMP 代理和 **管理信息库 (MIB)**
    组成。'
- en: TCP/IP Internet Standard Management Framework Architecture and Protocol Components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 互联网标准管理框架架构和协议组件
- en: The Internet Standard Management Framework encompasses all of the technologies
    that compose the TCP/IP network management solution. The SNMP Framework consists
    of a number of architectural components that define how management information
    is structured, how it is stored, and how it is exchanged using the SNMP protocol.
    The Framework also describes how the different components fit together, how SNMP
    is to be implemented in network devices, and how the devices interact.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网标准管理框架包括构成 TCP/IP 网络管理解决方案的所有技术。SNMP 框架由多个定义管理信息结构、存储和通过 SNMP 协议交换方式的架构组件组成。框架还描述了不同组件如何组合在一起，如何在网络设备中实现
    SNMP，以及设备如何交互。
- en: SNMP Framework Components
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 框架组件
- en: 'As we will explore in more detail in the next chapter, the Internet Standard
    Management Framework is entirely *information-oriented*. It includes four primary
    components (see [Figure 65-2](ch65s03.html#components_of_the_tcpip_internet_standar
    "Figure 65-2. Components of the TCP/IP Internet Standard Management Framework")):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章中更详细地探讨的那样，互联网标准管理框架完全是 **信息导向的**。它包括四个主要组件（见 [图 65-2](ch65s03.html#components_of_the_tcpip_internet_standar
    "图 65-2. TCP/IP 互联网标准管理框架的组件"))：
- en: '**Structure of Management Information (SMI)** To ensure interoperability of
    various devices, we want to have a consistent way of describing the characteristics
    of devices to be managed using SNMP. In computer science, a *data description
    language (DDL)* is the tool for this job. The *SMI* is a standard that defines
    the structure, syntax, and characteristics of management information in SNMP.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理信息结构 (SMI)** 为了确保各种设备的互操作性，我们希望有一个一致的方式来描述使用 SNMP 管理的设备特性。在计算机科学中，*数据描述语言
    (DDL)* 是完成这项工作的工具。**SMI** 是一个标准，它定义了 SNMP 中管理信息的结构、语法和特性。'
- en: '**Management Information Bases (MIBs)** Each managed device contains a set
    of variables that is used to manage it. These variables represent information
    about the operation of the device that is sent to an NMS, and/or parameters sent
    to the managed device to control it. The *MIB* is the full set of these variables
    that describe the management characteristics of a particular type of device. Each
    variable in a MIB is called a *MIB object*, and it is defined using the SMI data
    description language. A device may have many objects, corresponding to the different
    hardware and software elements it contains.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理信息库 (MIBs)** 每个受管设备都包含一组用于管理的变量。这些变量代表发送到 NMS 的设备操作信息，以及/或发送到受管设备的参数以控制它。**MIB**
    是描述特定类型设备管理特性的这些变量的完整集合。MIB 中的每个变量称为 **MIB 对象**，它使用 SMI 数据描述语言定义。设备可能有多个对象，对应于它包含的不同硬件和软件元素。'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Initially, a single document defined the MIB for SNMP, but this model was
    inflexible. To allow new MIB objects to be more easily defined, groups of related
    MIB objects are now defined in separate RFC standards called* MIB modules. *More
    than 100 such MIB modules have been defined so far*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*最初，一个单独的文档定义了 SNMP 的 MIB，但这个模型不够灵活。为了更容易地定义新的 MIB 对象，现在将相关 MIB 对象组定义在单独的 RFC
    标准中，称为 *MIB 模块*。*到目前为止，已经定义了超过 100 个这样的 MIB 模块*。'
- en: '**Simple Network Management Protocol (SNMP)** This is the actual SNMP protocol
    itself. It defines how information is exchanged between SNMP agents and NMSs.
    The SNMP *protocol operations* define the various SNMP messages and how they are
    created and used. SNMP *transport mappings* describe how SNMP can be used over
    various underlying internetworks, such as TCP/IP, IPX, and others.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单网络管理协议 (SNMP)** 这实际上是 SNMP 协议本身。它定义了 SNMP 代理和 NMS 之间信息交换的方式。SNMP **协议操作**
    定义了各种 SNMP 消息以及它们的创建和使用方式。SNMP **传输映射** 描述了如何在不同底层互联网（如 TCP/IP、IPX 等）上使用 SNMP。'
- en: '**Security and Administration** To the previous three main architectural components,
    the SNMP Framework adds a number of supporting elements. These provide enhancements
    to the operation of the SNMP protocol for security and address issues related
    to SNMP implementation, version transition, and other administrative issues.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全和行政** 在前三个主要架构组件的基础上，SNMP 框架增加了许多支持元素。这些元素增强了 SNMP 协议的操作，并解决了与 SNMP 实施相关的问题，包括版本转换和其他管理问题。'
- en: '![Components of the TCP/IP Internet Standard Management Framework](httpatomoreillycomsourcenostarchimages288227.png.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP 互联网标准管理框架的组件](httpatomoreillycomsourcenostarchimages288227.png.jpg)'
- en: Figure 65-2. Components of the TCP/IP Internet Standard Management Framework
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 65-2. TCP/IP 互联网标准管理框架的组件
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The three main components of the Internet Standard Management
    Framework (SNMP Framework) are the Structure of Management Information (SMI),
    management information bases (MIBs), and the SNMP protocol itself. These are supported
    by SNMP security and administration elements.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 互联网标准管理框架（SNMP 框架）的三个主要组件是管理信息结构（SMI）、管理信息库（MIBs）以及 SNMP 协议本身。这些组件由
    SNMP 安全性和管理元素支持。'
- en: SNMP Framework Architecture
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 框架架构
- en: The creators of SNMP specifically designed the Framework to be modular, because
    when SNMP was originally created, it was seen as only a temporary solution until
    a transition could be made to another network management protocol from the OSI
    protocol suite. The modular architecture separated definitional, data, and functional
    (protocol) elements, to allow the SNMP protocol itself to be replaced without
    changing how network management information was defined and described.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 的创造者特意设计了框架以模块化，因为当 SNMP 最初被创建时，它被视为一个临时解决方案，直到可以从 OSI 协议套件过渡到另一个网络管理协议。模块化架构将定义性、数据和功能性（协议）元素分离，以便在不改变网络管理信息定义和描述方式的情况下替换
    SNMP 协议本身。
- en: This transition to the OSI protocol never occurred, but the architecture has
    still proven valuable in defining the entire scope of SNMP and in making its implementation
    much simpler. Each of the major components discussed in the previous section—the
    SMI, MIBs, and SNMP itself—are described in different standards. The modularity
    of the SNMP Framework has also allowed changes to be made to these components
    relatively independently of each other, making the transition between SNMP versions
    easier than it would have been if one huge document defined everything.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种向 OSI 协议的过渡从未发生，但该架构在定义整个 SNMP 范围以及在简化其实施方面仍然非常有价值。上一节讨论的每个主要组件——SMI、MIBs
    和 SNMP 本身——都在不同的标准中进行了描述。SNMP 框架的模块化也允许相对独立地对这些组件进行更改，使得在 SNMP 版本之间的转换比如果有一个庞大的文档定义一切要容易得多。
- en: TCP/IP Internet Standard Management Framework and SNMP Versions (SNMPv1, SNMPv2
    Variants, and SNMPv3)
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 互联网标准管理框架和 SNMP 版本（SNMPv1、SNMPv2 变体和 SNMPv3）
- en: In [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS"),
    I explained the differences between proprietary, de facto, and open standards,
    and described the many benefits of open standards. History is replete with examples
    of technologies that have succeeded because they used an open standard when a
    competing standard was proprietary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。网络标准和标准组织") 中，我解释了专有标准、事实标准和开放标准之间的区别，并描述了开放标准的许多好处。历史充满了使用开放标准而成功的技术例子，当时竞争的标准是专有的。
- en: TCP/IP and the Internet are often held up as a model for proper open-standards
    development. Thousands of TCP/IP standards have been developed and published using
    the well-known Request for Comments (RFC) standardization process. The result
    has been the most successful set of internetworking protocols in computing history,
    accepted and used worldwide.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 和互联网经常被作为一个合适的开放标准开发的典范。成千上万的 TCP/IP 标准是通过众所周知的请求评论（RFC）标准化过程开发和发布的。结果是计算历史上最成功的互联网互连协议集，被全球接受和使用。
- en: Nobody is perfect, however, and no process is perfect either. Some problems
    occurred in the introduction of SNMP version 2, leading to a virtual breakdown
    in the normally smooth protocol standardization method, and a proliferation of
    incompatible variants that we aren't used to seeing in TCP/IP. The story behind
    this is a continuation of the general SNMP overview and history from earlier in
    this chapter, and it explains the many SNMP standard names and numbers, so you
    can make sense of them. At the same time, the discussion serves as a vivid reminder
    of how important proper standard development is, and what the consequences are
    when there isn't universal agreement on how a standard should evolve.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有人是完美的，也没有任何过程是完美的。在引入SNMP版本2时出现了一些问题，导致通常平稳的协议标准化方法几乎崩溃，并出现了我们不习惯在TCP/IP中看到的许多不兼容的变体。这个故事是本章前面关于一般SNMP概述和历史的延续，并解释了许多SNMP标准名称和数字，以便你能理解它们。同时，讨论也生动地提醒了适当的标准发展的重要性，以及当没有就标准的演变达成普遍共识时可能产生的后果。
- en: SNMPv1
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv1
- en: 'The first version of SNMP was developed in early 1988 and published in the
    form of three RFC standards in August 1988\. This first version is now known as
    *SNMP version 1* or *SNMPv1*. The three SNMPv1 standards provided the initial
    description of the three main Internet Standard Management Framework components:
    the SMI, MIB, and SNMP protocol itself. However, the term *Internet Standard Management
    Framework* was not actually used at that time.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP的第一个版本是在1988年初开发的，并于1988年8月以三个RFC标准的形式发布。这个第一个版本现在被称为**SNMP版本1**或**SNMPv1**。三个SNMPv1标准提供了三个主要互联网标准管理框架组件的初始描述：SMI、MIB和SNMP协议本身。然而，当时并没有实际使用**互联网标准管理框架**这个术语。
- en: SNMPv1 was generally accepted and widely deployed in many networks. SNMPv1 got
    the job done and became the standard for TCP/IP network management. It is still
    widely used today. It is the Old Faithful of SNMP versions. Slight revisions were
    made to the initial standards, and more and more MIB modules were defined over
    time, but the technology remained the same for a number of years.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv1被普遍接受并在许多网络中得到广泛部署。SNMPv1完成了任务，并成为了TCP/IP网络管理的标准。它至今仍被广泛使用。它是SNMP版本中的“老忠实”。对初始标准进行了一些修订，随着时间的推移，定义了越来越多的MIB模块，但技术保持了多年不变。
- en: As with any technology, users of SNMPv1 identified weaknesses in it and opportunities
    for improvement. One of the areas in which SNMPv1 was most criticized was the
    area of security. SNMPv1 used only a "trivial" (as RFC 3410 puts it) authentication
    scheme, employing a password-like construct called a *community string*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何技术一样，SNMPv1的用户发现了它的弱点以及改进的机会。SNMPv1最被批评的领域之一是安全性。SNMPv1仅使用了一个“简单”的（如RFC 3410所述）认证方案，采用了一个类似密码的结构，称为**社区字符串**。
- en: The issue of security turned out to be the bone of contention that eventually
    led to serious problems in the development of SNMP. Some people felt that community
    strings were sufficient security, but many others felt it was important that better
    security be put into SNMP. There were many different ways proposed to add security
    to SNMP, but no universal agreement on how to do it. The points raised about the
    security weaknesses in the original SNMPv1 had some validity, as I explore in
    the discussion of SNMP protocol operations in [Chapter 67](ch67.html "Chapter 67. TCP/IP
    SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性问题最终成为导致SNMP发展出现严重问题的争议焦点。有些人认为社区字符串就足够安全，但许多人认为将更好的安全性引入SNMP很重要。提出了许多不同的方法来增加SNMP的安全性，但没有就如何实现达成普遍共识。关于原始SNMPv1中安全弱点的讨论具有一定的合理性，正如我在[第67章](ch67.html
    "第67章。TCP/IP简单网络管理协议(SNMP)概念和操作")中关于SNMP协议操作讨论中所述。
- en: SNMPsec
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPsec
- en: The first attempt to add security came in the form of three standards published
    in July 1992 that defined a new security mechanism using logical identifiers called
    *parties*. This is sometimes called *SNMP Security* or *SNMPsec*. This method
    was more secure than the original SNMPv1, but SNMPsec was never widely accepted,
    and it is now considered historical.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试增加安全性的措施是在1992年7月发布的三个标准中，这些标准定义了一种使用逻辑标识符称为**参与者**的新安全机制。这有时被称为**SNMP安全**或**SNMPsec**。这种方法比原始的SNMPv1更安全，但SNMPsec从未被广泛接受，现在被认为是历史性的。
- en: SNMPv2
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv2
- en: The idea of party-based security never went away, however. It was used as the
    basis of the definition of the first full revision of SNMP, when *SNMP version
    2 (SNMPv2)* was published in RFCs 1441 through 1452 in April 1993\. This new version
    incorporated the new security model, as well as making changes to the actual SNMP
    protocol operations, changes to the SMI standard (defining version 2 of SMI, SMIv2),
    and formalizing the concept of the Internet Standard Management Framework.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于党的安全的思想从未消失。它被用作定义SNMP的第一个完整修订版的基础，当时在1993年4月发布的RFC 1441至1452中发布了*SNMP版本2（SNMPv2）*。这个新版本包含了新的安全模型，并对实际的SNMP协议操作、SMI标准（定义SMI的版本2，SMIv2）进行了更改，并正式化了互联网标准管理框架的概念。
- en: Unfortunately, this new standard also was never universally accepted. Some people
    thought the whole new version was a great advance, but others took issue with
    the party-based security, claiming it was too complex. A great deal of debate
    and discussion took place over the next couple of years, as an attempt was made
    to get everyone on board with the new version.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个新标准也从未被普遍接受。有些人认为整个新版本是一个巨大的进步，但其他人对基于党的安全提出了异议，声称它太复杂。在接下来的几年里，进行了大量的辩论和讨论，试图让每个人都接受这个新版本。
- en: SNMPv2 Variants
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv2变体
- en: 'Acceptance of SNMPv2 never happened. Instead, different splinter groups broke
    off and began work on *variants* of SNMPv2\. To prevent confusion, the original
    SNMPv2 became known as either *SNMPv2 classic* (reminiscent of the name a particular
    soft drink) or *SNMPv2p*, with the *p* referring to party-based security. Things
    got very interesting (and confusing) when the following were proposed and/or developed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv2的接受从未发生。相反，不同的派生小组分道扬镳，开始着手于SNMPv2的*变体*。为了避免混淆，原始的SNMPv2被称为*SNMPv2经典*（这个名字让人联想到某种特定的软饮料）或*SNMPv2p*，其中的*p*指的是基于党的安全。当以下内容被提出和/或开发时，事情变得非常有趣（并且令人困惑）：
- en: '**SNMPv1.5** You can tell immediately that an idea is probably going to be
    a problem when it proposes a version number lower than a number already standardized.
    SNMPv1.5 was an attempt to retain the uncontroversial elements in SNMPv2p—the
    enhancements to the SNMP protocol and SMI—while going back to community-based
    security as in SNMPv1\. It never became a standard itself, but became the basis
    of the next variant.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMPv1.5** 当一个想法提出一个低于已标准化数字的版本号时，你可以立即判断这个想法可能是一个问题。SNMPv1.5试图保留SNMPv2p中无争议的元素——对SNMP协议和SMI的增强——同时回到SNMPv1中的基于社区的安全。它本身从未成为标准，但成为下一个变体的基础。'
- en: '**Community-Based SNMPv2 (SNMPv2c)** This is SNMPv2p modified to use community
    strings instead of party-based security; in essence, the same idea as SNMPv1.5,
    but with a more official-sounding name and a few changes. Interestingly, the standard
    that defines this, RFC 1901, still has an experimental status, despite the fact
    that SNMPv2c actually achieved some degree of commercial success, where the standard
    SNMPv2p did not. SNMPv2c was defined by standards RFC 1902 through 1908, which
    incorporate other changes, including a new version of SMI (SMIv2).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于社区的SNMPv2（SNMPv2c）** 这是对SNMPv2p的修改，使用社区字符串而不是基于党的安全；本质上与SNMPv1.5相同，但有一个听起来更官方的名字和一些更改。有趣的是，定义这个标准的RFC
    1901仍然处于实验状态，尽管SNMPv2c实际上在商业上取得了一定的成功，而标准的SNMPv2p没有。SNMPv2c由RFC 1902至1908的标准定义，这些标准包括其他更改，包括SMI的新版本（SMIv2）。'
- en: '**User-Based SNMPv2 (SNMPv2u)** This is an alternative security method for
    SNMPv2c, which is based on users rather than community strings. It is considered
    simpler than party-based but more secure than community-string security. It is
    defined by RFC 1909 and RFC 1910\. It, too, is formally considered experimental.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于用户的SNMPv2（SNMPv2u）** 这是一种SNMPv2c的替代安全方法，它基于用户而不是社区字符串。它被认为比基于党的安全更简单，但比基于社区字符串的安全更安全。它由RFC
    1909和RFC 1910定义。它也被正式认为是实验性的。'
- en: '**SNMPv2*** As if all of the other variants were not enough, a well-known vendor
    decided to define another variant called *SNMPv2** that combined elements of SNMPv2p
    and SNMPv2u. This was never formally standardized. (Yes, that''s an asterisk in
    the name. No, there''s no footnote at the bottom of the page, so don''t bother
    looking for one. Yes, putting an asterisk in a name is extremely confusing. No,
    I don''t know how it is that marketing people get paid good money to come up with
    names like this.)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMPv2*** 就像所有的其他变体都不够一样，一个知名的供应商决定定义另一个名为 *SNMPv2** 的变体，它结合了 SNMPv2p 和 SNMPv2u
    的元素。这从未正式标准化。（是的，名字中有星号。不，页脚下面没有脚注，所以不用找。是的，在名字中放星号是非常令人困惑的。不，我不知道营销人员是如何得到好钱的，他们能想出这样的名字。）'
- en: Now, imagine that you were a network administrator in the mid-1990s and were
    faced with SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv2*. Which one would you choose?
    Well, if you are like most people, you would choose none of the above, saying,
    "I think I'll stick with SNMPv1 until these version 2 folks get their act together!"
    And that's basically what happened. Some proponents of these variations promoted
    them, but there was never any agreement, and the result was that the success of
    all of the various and sundry SNMPv2s was limited. As I said, this is a classic
    illustration of how important universal standardization is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果你是 1990 年代中期的网络管理员，面临着 SNMPv2p、SNMPv2c、SNMPv2u 和 SNMPv2*。你会选择哪一个？好吧，如果你像大多数人一样，你可能会选择上面的任何一个都不选，说，“我想我会坚持使用
    SNMPv1，直到这些版本 2 的人把事情做好！”这正是发生的事情。这些变体的支持者中的一些推广了它们，但从未达成任何协议，结果是所有各种 SNMPv2 的成功都受到了限制。正如我所说，这是普遍标准化重要性的经典例证。
- en: SNMPv3
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv3
- en: I would imagine that, at some point, everyone realized that the situation was
    a mess and decided enough is enough. In 1996, work began on a new approach to
    resolve the outstanding issues and return universality to SNMP. In 1998, *SNMP
    version 3 (SNMPv3)* was developed, which includes additional enhancements to SNMP
    and finally gets all the players back on the same team.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我想象，在某个时候，每个人都意识到情况一团糟，并决定已经足够了。1996 年，开始了一种新的方法来解决悬而未决的问题，并将普遍性恢复到 SNMP。1998
    年，开发了 *SNMP 版本 3 (SNMPv3)*，它包括对 SNMP 的额外增强，并最终让所有参与者回到了同一个团队。
- en: SNMPv3 is the most current version of SNMP and is still being actively revised.
    One of the important changes in SNMPv3 is a more formalized way of handing different
    security approaches to SNMP—obviously, a lesson learned from the SNMPv2 experience.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv3 是 SNMP 的最新版本，仍在积极修订中。SNMPv3 中的一个重要变化是更正式地处理对 SNMP 的不同安全方法——显然，这是从 SNMPv2
    经验中吸取的教训。
- en: SNMPv3 uses SNMPv2 protocol operations and its protocol data unit (PDU) message
    format, and the SMIv2 standard from SNMPv2 as well. SNMPv3 allows a number of
    different security methods to be incorporated into its architecture, and includes
    standards describing user-based security as defined in SNMPv2u and SNMPv2*, as
    well as a new view-based access control model. It also includes additional tools
    to aid in the administration of SNMP.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv3 使用 SNMPv2 协议操作及其协议数据单元 (PDU) 消息格式，以及 SNMPv2 的 SMIv2 标准。SNMPv3 允许将多种不同的安全方法集成到其架构中，包括描述基于用户的安全性的标准，这些标准在
    SNMPv2u 和 SNMPv2* 中定义，以及一个新的基于视图的访问控制模型。它还包括额外的工具来帮助管理 SNMP。
- en: TCP/IP Internet Standard Management Framework and SNMP Standards
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 互联网标准管理框架和 SNMP 标准
- en: You've now seen that there are three different versions of the Internet Standard
    Management Framework. Some of these versions have different variants. Each version
    or variant of the Framework includes multiple modular components. Each component
    has one or more documents that define it. Some of these have multiple revisions.
    Add to that dozens of individual MIBs defined for SNMP and other support documents,
    and what do you have? A boatload of TCP/IP standards, that's what. There are probably
    more RFCs defining parts of SNMP than any other single TCP/IP protocol or technology.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到，互联网标准管理框架有三个不同的版本。其中一些版本有不同的变体。框架的每个版本或变体都包含多个模块化组件。每个组件都有一个或多个定义它的文档。其中一些有多个修订版。再加上为
    SNMP 和其他支持文档定义的数十个单独的 MIB，你会有什么？一大堆 TCP/IP 标准。可能定义 SNMP 各部分的 RFC 比任何其他单个 TCP/IP
    协议或技术都要多。
- en: 'It is specifically because there are so many versions and components and documents
    associated with SNMP that I feel it is important to keep all the standards straight.
    To that end, Tables [Table 65-1](ch65s05.html#snmp_version__snmpv_standards "Table 65-1. SNMP
    Version 1 (SNMPv1) Standards") through [Table 65-6](ch65s05.html#snmp_version__snmpv_standards-id001
    "Table 65-6. SNMP Version 3 (SNMPv3) Standards") show the major SNMP standards
    for each of the versions and variants of the SNMP Framework: SNMPv1, SNMPsec,
    SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv3\. (SNMPv2* was not standardized using the
    regular RFC process.) Each individual RFC defines one component of one version
    of the Framework.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The usual way that RFCs work is that when new versions of a standard are released
    that are direct replacements for older ones, the older ones are obsoleted by the
    new ones. With SNMP, due to the many versions and the controversy over the variants,
    this is a bit unclear. For example, the standards defining SNMPv2p are not considered
    by the IETF to obsolete the standards for SNMPv1, but the IETF says the standards
    for SNMPv2c and SNMPv2u do obsolete those of SNMPv2p.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: To keep all of this distinct, I decided to show the standards for each version
    or variant separately. I put the RFC numbers for obsolete RFCs only where those
    RFCs are for the same SNMP version or variant. For example, RFC 3410 obsoletes
    2570 because they both deal with SNMPv3 and 3410 is a direct replacement for 2570\.
    Also, there are a few cases where the name of a standard changed slightly between
    RFC numbers; I have shown the current name. A full, hyperlinked list of RFCs can
    be found at [http://www.rfc-editor.org/rfc-index.html](http://www.rfc-editor.org/rfc-index.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Table 65-1. SNMP Version 1 (SNMPv1) Standards
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| 1065 | 1155 | May 1990 | Structure and Identification of Management Information
    for TCP/IP-Based Internets |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| 1066 | 1156 | May 1990 | Management Information Base for Network Management
    of TCP/IP-Based Internets |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| 1067, 1098 | 1157 | May 1990 | Simple Network Management Protocol (SNMP)
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| 1158 | 1213 | March 1991 | Management Information Base for Network Management
    of TCP/IP-Based Internets: MIB-II |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: Table 65-2. SNMP Security (SNMPsec) Standards
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| — | 1351 | July 1992 | SNMP Administrative Model |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| — | 1352 | July 1992 | SNMP Security Protocols |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| — | 1353 | July 1992 | Definitions of Managed Objects for Administration
    of SNMP Parties |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: Table 65-3. Party-Based SNMP Version 2 (SNMPv2p) Standards
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| — | 1441 | April 1993 | Introduction to Version 2 of the Internet-Standard
    Network Management Framework |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| — | 1442 | April 1993 | Structure of Management Information for Version 2
    of the Simple Network Management Protocol (SNMPv2) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| — | 1442 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的管理信息结构 |'
- en: '| — | 1443 | April 1993 | Textual Conventions for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| — | 1443 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的文本约定 |'
- en: '| — | 1444 | April 1993 | Conformance Statements for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| — | 1444 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的符合性声明 |'
- en: '| — | 1445 | April 1993 | Administrative Model for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| — | 1445 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的行政模型 |'
- en: '| — | 1446 | April 1993 | Security Protocols for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| — | 1446 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的安全协议 |'
- en: '| — | 1447 | April 1993 | Party MIB for Version 2 of the Simple Network Management
    Protocol (SNMPv2) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| — | 1447 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的党派MIB |'
- en: '| — | 1448 | April 1993 | Protocol Operations for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| — | 1448 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的协议操作 |'
- en: '| — | 1449 | April 1993 | Transport Mappings for Version 2 of the Simple Network
    Management Protocol (SNMPv2) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| — | 1449 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的传输映射 |'
- en: '| — | 1450 | April 1993 | Management Information Base for Version 2 of the
    Simple Network Management Protocol (SNMPv2) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| — | 1450 | April 1993 | SNMPv2版本2的简单网络管理协议（SNMPv2）的管理信息库 |'
- en: '| — | 1451 | April 1993 | Manager-to-Manager Management Information Base |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| — | 1451 | April 1993 | 管理员到管理员的网络管理信息库 |'
- en: '| — | 1452 | April 1993 | Coexistence Between Version 1 and Version 2 of the
    Internet-Standard Network Management Framework |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| — | 1452 | April 1993 | 互联网标准网络管理框架第1版和第2版之间的共存 |'
- en: Table 65-4. Community-Based SNMP Version 2 (SNMPv2c) Standards
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表65-4. 基于社区的SNMP版本2（SNMPv2c）标准 |
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 已废弃的RFCs | 最近RFC | 最近RFC的日期 | 标准名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| — | 1901 | January 1996 | Introduction to Community-Based SNMPv2 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| — | 1901 | January 1996 | 基于社区的SNMPv2简介 |'
- en: '| — | 1902 | January 1996 | Structure of Management Information for Version
    2 of the Simple Network Management Protocol (SNMPv2) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| — | 1902 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的管理信息结构 |'
- en: '| — | 1903 | January 1996 | Textual Conventions for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| — | 1903 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的文本约定 |'
- en: '| — | 1904 | January 1996 | Conformance Statements for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| — | 1904 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的符合性声明 |'
- en: '| — | 1905 | January 1996 | Protocol Operations for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| — | 1905 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的协议操作 |'
- en: '| — | 1906 | January 1996 | Transport Mappings for Version 2 of the Simple
    Network Management Protocol (SNMPv2) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| — | 1906 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的传输映射 |'
- en: '| — | 1907 | January 1996 | Management Information Base for Version 2 of the
    Simple Network Management Protocol (SNMPv2) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| — | 1907 | January 1996 | SNMPv2版本2的简单网络管理协议（SNMPv2）的管理信息库 |'
- en: '| — | 1908 | January 1996 | Coexistence between Version 1 and Version 2 of
    the Internet-Standard Network Management Framework |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| — | 1908 | January 1996 | 互联网标准网络管理框架第1版和第2版之间的共存 |'
- en: Table 65-5. User-Based SNMP Version 2 (SNMPv2u) Standards
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表65-5. 基于用户的SNMP版本2（SNMPv2u）标准 |
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 已废弃的RFCs | 最近RFC | 最近RFC的日期 | 标准名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| — | 1909 | February 1996 | An Administrative Infrastructure for SNMPv2 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| — | 1909 | February 1996 | SNMPv2的行政基础设施 |'
- en: '| — | 1910 | February 1996 | User-Based Security Model for SNMPv2 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| — | 1910 | February 1996 | SNMPv2的用户安全模型 |'
- en: Table 65-6. SNMP Version 3 (SNMPv3) Standards
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表65-6. SNMP版本3（SNMPv3）标准 |
- en: '| Obsolete RFCs | Most Recent RFC | Date of Most Recent RFC | Standard Name
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 已废弃的RFCs | 最近RFC | 最近RFC的日期 | 标准名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| — | 2576 | March 2000 | Coexistence between Version 1, Version 2, and Version
    3 of the Internet-Standard Network Management Framework |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| — | 2576 | March 2000 | 第1版、第2版和第3版互联网标准网络管理框架之间的共存 |'
- en: '| — | 2578 | April 1999 | Structure of Management Information Version 2 (SMIv2)
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| — | 2578 | April 1999 | 管理信息结构版本2（SMIv2） |'
- en: '| — | 2579 | April 1999 | Textual Conventions for SMIv2 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| — | 2579 | 1999年4月 | SMIv2的文本约定|'
- en: '| — | 2580 | April 1999 | Conformance Statements for SMIv2 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| — | 2580 | 1999年4月 | SMIv2的符合性声明|'
- en: '| 2570 | 3410 | December 2002 | Introduction and Applicability Statements for
    Internet-Standard Management Framework |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 2570 | 3410 | 2002年12月 | 互联网标准管理框架的介绍和适用性声明|'
- en: '| 2261, 2271, 2571 | 3411 | December 2002 | An Architecture for Describing
    Simple Network Management Protocol (SNMP) Management Frameworks |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 2261, 2271, 2571 | 3411 | 2002年12月 | 描述简单网络管理协议（SNMP）管理框架的架构|'
- en: '| 2262, 2272, 2572 | 3412 | December 2002 | Message Processing and Dispatching
    for the Simple Network Management Protocol (SNMP) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 2262, 2272, 2572 | 3412 | 2002年12月 | 简单网络管理协议（SNMP）的消息处理和分发|'
- en: '| 2263, 2273, 2573 | 3413 | December 2002 | Simple Network Management Protocol
    (SNMP) Applications |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 2263, 2273, 2573 | 3413 | 2002年12月 | 简单网络管理协议（SNMP）的应用程序|'
- en: '| 2264, 2274, 2574 | 3414 | December 2002 | User-Based Security Model (USM)
    for Version 3 of the Simple Network Management Protocol (SNMPv3) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 2264, 2274, 2574 | 3414 | 2002年12月 | 简单网络管理协议（SNMPv3）的第3版用户安全模型（USM）|'
- en: '| 2265, 2275, 2575 | 3415 | December 2002 | View-Based Access Control Model
    (VACM) for the Simple Network Management Protocol (SNMP) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 2265, 2275, 2575 | 3415 | 2002年12月 | 简单网络管理协议（SNMP）的基于视图的访问控制模型（VACM）|'
- en: '| — | 3416 | December 2002 | Version 2 of the Protocol Operations for the Simple
    Network Management Protocol (SNMP) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| — | 3416 | 2002年12月 | 简单网络管理协议（SNMP）协议操作的版本2|'
- en: '| — | 3417 | December 2002 | Transport Mappings for the Simple Network Management
    Protocol (SNMP) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| — | 3417 | 2002年12月 | 简单网络管理协议（SNMP）的传输映射|'
- en: '| — | 3418 | December 2002 | Management Information Base (MIB) for the Simple
    Network Management Protocol (SNMP) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| — | 3418 | 2002年12月 | 简单网络管理协议（SNMP）的管理信息库（MIB）|'
- en: In addition to all of the standards listed in these tables, there are dozens
    of supplemental RFCs that describe MIB modules and also clarify various fine points
    of operation related to SNMP. You can find all the MIBs in an online list of RFCs
    by searching for "MIB" or "SNMP."
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些表中列出的所有标准之外，还有数十个补充的RFC，它们描述了MIB模块，并澄清了与SNMP相关的各种操作细节。您可以通过搜索“MIB”或“SNMP”来在线找到所有MIB的RFC列表。
- en: Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT
    INFORMATION BASES (MIBS)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第66章 TCP/IP结构化管理信息（SMI）和管理信息库（MIBS）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The Internet Standard Management Framework defines three major components that
    describe how devices can be managed on a TCP/IP internetwork. One of these, the
    actual Simple Network Management Protocol (SNMP) is relatively well known, but
    is only part of the overall picture. SNMP describes how information is exchanged
    between SNMP entities, but two other components are equally important, because
    they describe the information itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网标准管理框架定义了三个主要组件，描述了如何在TCP/IP互联网中管理设备。其中之一，实际的简单网络管理协议（SNMP）相对较为知名，但它只是整体图景的一部分。SNMP描述了SNMP实体之间信息交换的方式，但还有另外两个组件同样重要，因为它们描述了信息本身。
- en: 'In this chapter, I describe these two important supporting elements of the
    TCP/IP Internet Standard Management Framework: the Management Information Base
    (MIB) standard that describes types of information that SNMP works with, and the
    Structure of Management Information (SMI) standard that specifies how MIB information
    is defined. Understanding these two parts of the SNMP Framework is an important
    initial step before we examine the actual SNMP protocol itself.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了TCP/IP互联网标准管理框架的两个重要支持元素：描述SNMP处理的信息类型的MIB标准，以及定义MIB信息的结构管理信息（SMI）标准。在检查实际的SNMP协议本身之前，理解这两个SNMP框架的部分是一个重要的初步步骤。
- en: I begin with an overview description of the SMI data description language and
    how MIBs work. I discuss the MIB object name hierarchy and the notation used to
    refer to names. I also describe how MIB objects work, discussing the different
    object types and MIB object groups. I describe MIB concepts common to all of the
    versions of SNMP, and discuss both of the specific versions of SMI (SMIv1 and
    SMIv2) used in those SNMP versions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先概述了SMI数据描述语言以及MIBs的工作方式。我讨论了MIB对象名称层次结构和用于引用名称的符号。我还描述了MIB对象的工作方式，讨论了不同的对象类型和MIB对象组。我描述了所有SNMP版本中通用的MIB概念，并讨论了在那些SNMP版本中使用的特定SMI版本（SMIv1和SMIv2）。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *If you have not yet already read the preceding
    chapter describing the SNMP Internet Standard Management Framework, you should
    do so before proceeding here*.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *如果您还没有阅读前面章节中描述的SNMP互联网标准管理框架，您应该在继续阅读此处之前先阅读它*。'
- en: TCP/IP SMI and MIBs Overview
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP SMI和MIBs概述
- en: The key to really understanding TCP/IP network management is to comprehend the
    *information-oriented* nature of the entire Internet Standard Management Framework
    (SNMP Framework). To see what I mean by this, let's step back for a moment and
    consider in general terms the problem of network management, and more specifically,
    the problem of managing devices on a network.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 真正理解TCP/IP网络管理的关键是理解整个互联网标准管理框架（SNMP框架）的*信息导向*本质。为了理解我的意思，让我们暂时退后一步，从一般的角度考虑网络管理的问题，以及更具体地，管理网络中设备的问题。
- en: SNMP's Information-Oriented Design
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP的信息导向设计
- en: 'A network administrator needs to perform two basic types of actions: gather
    data about devices to learn how they are functioning and give commands to devices
    to change how they are functioning. In the simplest terms, the first category
    can be considered as a read operation, and the second is comparable to a write
    operation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员需要执行两种基本类型的操作：收集有关设备的功能数据，以及向设备下达命令以改变其功能。用最简单的话说，第一类操作可以被视为读取操作，而第二类则相当于写入操作。
- en: A classic way of implementing this functionality is to define a communication
    protocol. Most such protocols are *command-oriented*—they consist of a specific
    set of commands to perform the read and write operations. For example, a network
    management protocol might have a read command such as "report on number of hours
    device has been in use," and a write command might be something like "put this
    device into test mode." The network manager would control the device by giving
    the appropriate commands.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种功能的一种经典方式是定义一个通信协议。大多数此类协议都是*命令导向*的——它们由一组特定的命令组成，用于执行读取和写入操作。例如，一个网络管理协议可能有一个读取命令，如“报告设备使用的小时数”，以及一个写入命令可能类似于“将此设备置于测试模式”。网络管理员通过下达适当的命令来控制设备。
- en: 'A command-oriented management protocol has the advantage of simplicity, since
    it''s clear what the commands are for and how they are to be used. It can be reasonably
    well suited for use in certain environments, but it doesn''t work well on a large,
    heterogeneous TCP/IP internetwork. The main reason for this is that command-orientation
    inextricably ties the protocol to the devices being managed. Consider the following
    problems:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 命令导向的管理协议的优点在于其简单性，因为它很清楚命令的用途以及如何使用它们。它可能非常适合在某些环境中使用，但它不适合在大型、异构的TCP/IP互联网中工作。主要原因在于命令导向将协议与被管理的设备不可分割地联系在一起。考虑以下问题：
- en: Every type of device might require a distinct set of commands. For example,
    the commands given to a router might need to be different than those given to
    a host. This would lead either to a proliferation of commands in the protocol
    or to inflexibility in allowing proper management of different device types.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种设备可能都需要一组独特的命令。例如，给路由器下达的命令可能需要与给主机下达的命令不同。这可能导致协议中命令的激增，或者导致在允许适当管理不同设备类型时的不灵活性。
- en: Every time a company created a new type of device, or made a unique version
    of a type of device, the network management protocol would need to be changed.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当一家公司创造了一种新型设备，或者为某种设备制作了一个独特的版本，网络管理协议就需要进行更改。
- en: Whenever the operation of a kind of device changed, due perhaps to a change
    in another protocol, the management protocol would need to be updated.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当某种设备的功能发生变化时，可能是由于另一种协议的变化，管理协议就需要进行更新。
- en: The protocol itself could not be easily changed without affecting a lot of hardware.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有影响大量硬件，该协议本身很难进行更改。
- en: The solution to the problems of command-oriented management protocols is to
    use an *information-oriented* model. Instead of defining specific commands that
    interrogate or control devices, the devices are defined in terms of units of information
    that are to be exchanged between the devices and a management station.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 解决以命令为导向的管理协议问题的方法是使用*信息导向*模型。不是定义特定的命令来查询或控制设备，而是通过设备与管理站之间要交换的信息单元来定义设备。
- en: Instead of read commands and write commands, we have *variables* that can be
    read or written. Take the two examples mentioned earlier. Instead of a command
    like "report on a number of hours device has been in use," the device keeps a
    variable called "number of hours in use," and the network management station can
    read this as one of many variables, with no need for a specific protocol command.
    Instead of a write command called "put this device into test mode," the device
    has a variable called "current mode." The network manager can change the mode
    of the device to test mode by changing the value of the variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取命令和写入命令不同，我们拥有可以读取或写入的*变量*。以之前提到的两个例子来说明。不需要像“报告设备使用的小时数”这样的命令，设备会保留一个名为“使用的小时数”的变量，网络管理站可以将其作为众多变量之一读取，无需特定的协议命令。不需要名为“将此设备置于测试模式”的写入命令，设备有一个名为“当前模式”的变量。网络管理员可以通过更改变量的值来将设备的模式更改为测试模式。
- en: This difference may seem subtle, but it underlies every aspect of how SNMP works.
    I believe part of why the SNMP Framework is hard to understand is because insufficient
    emphasis is placed on looking at things in the "SNMP way," which means thinking
    about information objects and not commands.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异可能看起来很微妙，但它构成了SNMP工作方式的每一个方面。我相信SNMP框架难以理解的部分原因是因为没有足够强调以“SNMP方式”看待事物，这意味着考虑信息对象而不是命令。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Unlike most protocols, which are *command-oriented*, SNMP is
    *information-oriented*. SNMP operations are implemented using objects called *variables*
    that are maintained in managed devices. Rather than issuing commands, a network
    management station checks the status of a device by reading variables, and controls
    the operation of the device by changing (writing) variables.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 与大多数以命令为导向的协议不同，SNMP是*信息导向*的。SNMP操作通过在管理设备中维护的称为*变量*的对象来实现。而不是发布命令，网络管理站通过读取变量来检查设备的状态，通过更改（写入）变量来控制设备操作。'
- en: MIB and MIB Objects
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB和MIB对象
- en: Given this backdrop, we can look at the SNMP Framework in a new light. The actual
    SNMP protocol itself, which we'll examine in the next couple of chapters, has
    only a few, generic commands to accomplish read and write tasks. It deals with
    only the methods by which network management information is exchanged between
    SNMP agents and SNMP network management stations (NMSs), which were described
    in the previous chapter. The network management information is really the heart
    of TCP/IP network management.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的背景下，我们可以以新的视角看待SNMP框架。实际的SNMP协议本身，我们将在接下来的几章中对其进行考察，它只有少数几个通用的命令来完成读取和写入任务。它只处理网络管理信息在SNMP代理和网络管理站（NMS）之间的交换方法，这些方法在上一章中已经描述。网络管理信息实际上是TCP/IP网络管理的核心。
- en: So, instead of SNMP being defined in terms of commands used to control particular
    devices, it is defined in terms of management information variables, generally
    called *objects*. Each object describes a particular characteristic of a device.
    Some objects are fairly generic and are meaningful for any device on a TCP/IP
    network; for example, an object describing something related to the Internet Protocol
    (IP) itself, such as the device's IP address. Other objects might be particular
    to a specific type of device; for example, a router will have objects that a regular
    host's Ethernet network interface card would not.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SNMP不是通过控制特定设备的命令来定义的，而是通过称为*对象*的管理信息变量来定义的。每个对象描述了设备的特定特性。一些对象相当通用，对TCP/IP网络上的任何设备都有意义；例如，描述与互联网协议（IP）本身相关的对象，如设备的IP地址。其他对象可能特定于某种类型的设备；例如，路由器将具有普通主机以太网网络接口卡所不具备的对象。
- en: A collection of objects used in SNMP is called a *management information base*,
    or *MIB*. (In fact, SNMP objects are often called *MIB objects*.) The first version
    of SNMP, SNMPv1, had a single standard that defined the entire MIB for SNMP. Newer
    versions provide more flexibility by using different *MIB modules* that define
    sets of variables particular to the hardware or software used by a device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMP中使用的对象集合被称为*管理信息库（MIB）*，或*MIB*。（实际上，SNMP对象通常被称为*MIB对象*。）SNMP的第一个版本，SNMPv1，有一个单一的标准定义了整个SNMP的MIB。较新版本通过使用不同的*MIB模块*提供了更多的灵活性，这些模块定义了特定于设备使用的硬件或软件的变量集。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The management data variables in a managed device are maintained
    in a logical collection called a *management information base (MIB)*. The objects
    in the MIB are often called *MIB objects*, and they are typically collected into
    sets called *MIB modules*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 管理设备中的管理数据变量被维护在一个逻辑集合中，称为*管理信息库（MIB）*。MIB中的对象通常被称为*MIB对象*，它们通常被收集到称为*MIB模块*的集合中。'
- en: Defining objects using modules allows for significant flexibility in defining
    the variables that allow management of different types of devices. A device can
    incorporate all the MIB modules appropriate to the hardware and software it uses.
    For example, if you had a device using Ethernet, it would incorporate variables
    from the Ethernet MIB. A device using Token Ring would use the Token Ring MIB.
    Both devices would also use the common SNMP MIB that is used by all TCP/IP devices.
    Other modules might also be included as needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块定义对象允许在定义允许管理不同类型设备的变量方面具有很大的灵活性。设备可以包含适用于其硬件和软件的所有适当的MIB模块。例如，如果你有一个使用以太网的设备，它将包含来自以太网MIB的变量。使用令牌环的设备将使用令牌环MIB。这两个设备也会使用所有TCP/IP设备都使用的通用SNMP
    MIB。根据需要，也可能包括其他模块。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Due to its name, the MIB is often called a database. This is, strictly speaking,
    inaccurate. The MIB is a description of objects. The actual MIB in a device may
    be implemented as a software database, but that is not required*.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于其名称，MIB通常被称为数据库。严格来说，这是不准确的。MIB是对象的描述。设备中的实际MIB可能实现为软件数据库，但这不是必需的*。'
- en: 'Defining MIB Objects: SMI'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义MIB对象：SMI
- en: The use of MIB objects solves the problem of the network management protocol
    being tied to the network management information. However, we must be very particular
    about how we define these objects. Again, the reason is the wide variety of devices
    that TCP/IP allows to be connected together. Each device may represent information
    in a different way. For all of them to communicate with each other, we need to
    ensure that management information is represented in a consistent manner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIB对象可以解决网络管理协议与网络管理信息绑定的问题。然而，我们必须非常注意如何定义这些对象。再次强调，原因是TCP/IP允许连接的设备种类繁多。每种设备可能以不同的方式表示信息。为了确保它们能够相互通信，我们需要确保管理信息以一致的方式表示。
- en: The part of the SNMP Framework that ensures the universality of MIB objects
    is the *Structure of Management Information (SMI)* standard. SMI defines the rules
    for how MIB objects and MIB modules are constructed. In SMI, MIB objects are described
    using a precise set of definitions based on a data description language called
    the ISO *Abstract Syntax Notation 1 (ASN.1)* standard.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保MIB对象普遍性的SNMP框架部分是*管理信息结构（SMI）*标准。SMI定义了如何构建MIB对象和MIB模块的规则。在SMI中，MIB对象使用基于ISO
    *抽象语法表示1（ASN.1）*标准的精确定义集进行描述。
- en: In essence, we really have three levels of abstraction in SNMP. The actual SNMP
    protocol moves values that represent the state of management devices. The MIB
    defines what these variables are. And the SMI defines how the variables in the
    MIB are themselves defined.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们在SNMP中有三个抽象级别。实际的SNMP协议移动表示管理设备状态的值。MIB定义了这些变量是什么。SMI定义了MIB中的变量是如何定义的。
- en: There are two main SMI standards. The original, *SMIv1*, was part of the first
    SNMP Framework, SNMPv1, defined in RFC 1155\. It sets out the basic rules for
    MIBs and MIB variables. The second, *SMIv2*, was defined as part of SNMPv2p in
    RFC 1442 and further updated in RFC 2578, part of SNMPv3\. It is similar to the
    earlier version, but defines more object types, as well as the structure of MIB
    modules.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的SMI标准。最初的，*SMIv1*，是第一个SNMP框架的一部分，SNMPv1，在RFC 1155中定义。它规定了MIB和MIB变量的基本规则。第二个，*SMIv2*，在RFC
    1442中作为SNMPv2p的一部分定义，并在RFC 2578中进一步更新，这是SNMPv3的一部分。它与早期版本类似，但定义了更多的对象类型，以及MIB模块的结构。
- en: 'These SMI standards are responsible for defining the following important information
    elements in SNMP:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SMI 标准负责定义 SNMP 中的以下重要信息元素：
- en: The general characteristics associated with all MIB objects—the standard way
    by which all MIB objects are described
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与所有 MIB 对象相关的一般特征——描述所有 MIB 对象的标准方式
- en: The different types of MIB objects that can be created, such as integers, strings,
    and more complex data types
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以创建的不同类型的 MIB 对象，例如整数、字符串和更复杂的数据类型
- en: A hierarchical structure for naming MIB objects, so they can be addressed in
    a consistent manner without names overlapping
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为命名 MIB 对象创建一个层次结构，以便可以一致地引用它们，而不会发生名称重叠
- en: The information associated with each MIB module
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与每个 MIB 模块相关的信息
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *Structure of Management Information (SMI)* standard is
    responsible for defining the rules for how MIB objects are structured, described,
    and organized. SMI allows dissimilar devices to communicate by ensuring that they
    use a universal data representation for all management information.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *管理信息结构 (SMI)* 标准负责定义 MIB 对象的结构、描述和组织规则。SMI 通过确保不同设备使用通用数据表示来交换所有管理信息，从而允许不同设备进行通信。'
- en: TCP/IP MIB Objects, Object Characteristics, and Object Types
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP MIB 对象、对象特征和对象类型
- en: As explained in the previous sections, the SNMP Framework is designed to facilitate
    the exchange of management information. The MIB defines a device's management
    information and contains a number of variables called *MIB objects*, also called
    *managed objects*. These objects are defined according to the rules set out in
    the SMI standard.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，SNMP 框架旨在促进管理信息的交换。MIB 定义了设备的管理信息，并包含许多称为 *MIB 对象* 的变量，也称为 *受管对象*。这些对象是根据
    SMI 标准中规定的规则定义的。
- en: 'The best place to begin looking at MIB objects is by examining the SMI rules
    that define them. As I mentioned earlier in this chapter, two different versions
    of SMI have been created: SMIv1 as part of the original SNMP, and SMIv2 as part
    of SNMPv2 and SNMPv3\. The two are similar in terms of how MIB objects are described,
    but SMIv2 allows more information to be associated with each object.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 MIB 对象的最佳起点是检查定义它们的 SMI 规则。正如我在本章前面提到的，已经创建了两种不同的 SMI 版本：SMIv1 作为原始 SNMP
    的一部分，以及 SMIv2 作为 SNMPv2 和 SNMPv3 的一部分。这两个版本在描述 MIB 对象方面相似，但 SMIv2 允许与每个对象关联更多信息。
- en: MIB Object Characteristics
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB 对象特征
- en: 'Just as a typical protocol uses a field format for specifying the content of
    messages sent between devices using the protocol, SMI uses a format that specifies
    the fundamental characteristics of each MIB object. The most basic of these are
    five mandatory characteristics defined in SMIv1\. These are also used in SMIv2,
    but a couple of names were changed, and the possible values for some of the fields
    were modified as well. An MIB object may have the following characteristics (see
    [Figure 66-1](ch66s02.html#snmp_management_information_base_mib_thi "Figure 66-1. SNMP
    management information base (MIB) This diagram shows an SNMP MIB containing N
    MIB objects. Each object has five mandatory characteristics and a variable number
    of optional characteristics.")):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如典型的协议使用字段格式来指定使用该协议的设备之间发送的消息的内容一样，SMI 使用一种格式来指定每个 MIB 对象的基本特征。其中最基本的是在 SMIv1
    中定义的五个强制性特征。这些特征也用于 SMIv2，但一些名称有所更改，一些字段的可能值也有所修改。MIB 对象可能具有以下特征（参见[图 66-1](ch66s02.html#snmp_management_information_base_mib_thi
    "图 66-1. SNMP 管理信息库 (MIB) 此图显示了一个包含 N 个 MIB 对象的 SNMP MIB。每个对象有五个强制性特征和可变数量的可选特征。"））：
- en: '**Object Name** Each object has a name that serves to uniquely identify it.
    Actually, that''s not entirely true. Each object has *two* names: a textual name
    called an *object descriptor* and a numeric *object identifier*, which indicates
    the object''s place in the MIB object name hierarchy. We''ll explore these names
    and how they are used shortly.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象名称** 每个对象都有一个名称，用于唯一标识它。实际上，这并不完全正确。每个对象有两个名称：一个文本名称称为 *对象描述符* 和一个数字 *对象标识符*，它表示对象在
    MIB 对象名称层次结构中的位置。我们将在稍后探讨这些名称及其使用方法。'
- en: '**Syntax** Defines the object''s data type and the structure that describes
    it. This attribute is very important because it defines the data type of information
    that the object contains. There are two basic categories of data types allowed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法** 定义了对象的数据类型及其描述的结构。这个属性非常重要，因为它定义了对象包含的信息的数据类型。允许两种基本的数据类型类别：'
- en: Regular data types are single pieces of information, of the type we are used
    to dealing with on a regular basis, such as integers and strings. These are called
    *base types* in SMIv2\. SMIv1 differentiates between *primitive types* like integers
    defined in ASN.1, and *defined types* that are special forms of primitive types
    that are still single pieces of information but with certain special meaning attached
    to how they are used. SMIv2 doesn't use those two terms.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规数据类型是我们日常经常处理的信息的单个片段，例如整数和字符串。在SMIv2中，这些被称为*基本类型*。SMIv1区分*原始类型*，如ASN.1中定义的整数，以及*定义类型*，它们是原始类型的特殊形式，仍然是单个信息片段，但与它们的使用方式有关联的特殊含义。SMIv2不使用这两个术语。
- en: Tabular data types are collections of multiple data elements. They may take
    the form of a list of base types or a table of base types. For example, a table
    of integers could be constructed to represent a set of values. In SMIv1, these
    are called *constructor types*; in SMIv2 they are *conceptual tables*. They can
    be accessed using special SNMP mechanisms designed for reading tables. See the
    topic on SNMP table traversal for more on tables.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格数据类型是多个数据元素的集合。它们可能采取基本类型列表或基本类型表的形式。例如，可以构建一个整数表来表示一组值。在SMIv1中，这些被称为*构造类型*；在SMIv2中它们是*概念表*。它们可以使用为读取表格而设计的特殊SNMP机制进行访问。有关表格的更多信息，请参阅SNMP表遍历主题。
- en: '**Access (Max-Access in SMIv2)** This field defines the ways that an SNMP application
    will normally use the object. In SMIv1, there are four different possible values:
    *read-only*, *read-write*, *write-only*, and *not-accessible*. In SMIv2 there
    are five values, which are described as a hierarchy of sorts. SMIv2 calls this
    characteristic *Max-Access* (*maximum access*) to make it explicit that higher
    access levels include the lower levels as well. For example, an object with read-create
    access can also be used in any of the modes below it, such as read-write, but
    not vice versa. The following are the five SMIv2 access values, in decreasing
    order of access (note that write-only has been removed in SMIv2):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问（SMIv2中的Max-Access）** 此字段定义了SNMP应用程序通常使用对象的方式。在SMIv1中，有四个不同的可能值：*只读*、*读写*、*只写*和*不可访问*。在SMIv2中，有五个值，这些值被描述为一种层次结构。SMIv2将此特性称为*Max-Access*（*最大访问*），以明确指出较高的访问级别包括较低的级别。例如，具有读取创建访问的对象也可以用于其下任何模式，如读写，但反之则不行。以下为SMIv2的五个访问值，按访问级别降序排列（请注意，SMIv2中已删除只写）：'
- en: '*read-create* (object can be read, written, or created)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取创建*（对象可读、可写或创建）'
- en: '*read-write* (object can be read or written)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读写*（对象可读可写）'
- en: '*read-only* (object can only be read)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*只读*（对象只能读取）'
- en: '*accessible-for-notify* (object can be used only using SNMP notification or
    SNMP traps)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可通知访问*（对象只能通过SNMP通知或SNMP陷阱使用）'
- en: '*not-accessible* (used for special purposes)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可访问*（用于特殊目的）'
- en: '**Status** Indicates the currency of the object definition. In SMIv1 there
    are three values: *mandatory*, *optional*, and *obsolete*. In SMIv2, the first
    two are combined into simply *current*, meaning a current definition. The value
    *obsolete* is retained, and *deprecated* is added, meaning the definition is obsolete
    but maintained for compatibility.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**表示对象定义的有效性。在SMIv1中，有三个值：*强制*、*可选*和*过时*。在SMIv2中，前两个被合并为简单的*当前*，表示当前定义。保留值*过时*，并添加了*已弃用*，表示定义已过时但为兼容性而保留。'
- en: '**Definition (Description in SMIv2)** A textual description of the object.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义（SMIv2中的描述）** 对象的文本描述。'
- en: '**Optional Characteristics** SMIv2 adds the following optional characteristics
    that may appear in the definition of an object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选特性** SMIv2添加了以下可能出现在对象定义中的可选特性：'
- en: '*Units* is a textual description of the units associated with the object.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Units*是与对象相关的单位的文本描述。'
- en: '*Reference* is a text cross-reference to a related document or other information
    relevant to the object.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参考*是对相关文档或其他与对象相关的信息的文本交叉引用。'
- en: '*Index* is a value used to define objects that are actually more complex rows
    of other objects.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Index*是用于定义实际更复杂的其他对象行的值的值。'
- en: '*Augments* is an alternative to the Index field.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增强*是索引字段的替代品。'
- en: '*DefVal* defines an acceptable default value for the object.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DefVal*定义了对象的可接受默认值。'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each management information variable, called an *MIB object*,
    has associated with it five key attributes: its name, syntax, maximum access,
    status, and definition. It may also have a number of optional characteristics.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个管理信息变量，称为 *MIB 对象*，与其相关联五个关键属性：其名称、语法、最大访问权限、状态和定义。它还可能具有许多可选特性。'
- en: '![SNMP management information base (MIB) This diagram shows an SNMP MIB containing
    N MIB objects. Each object has five mandatory characteristics and a variable number
    of optional characteristics.](httpatomoreillycomsourcenostarchimages288229.png.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP 管理信息库 (MIB) 此图显示了包含 N 个 MIB 对象的 SNMP MIB。每个对象具有五个强制特性和一个可变数量的可选特性。](httpatomoreillycomsourcenostarchimages288229.png.jpg)'
- en: Figure 66-1. SNMP management information base (MIB) This diagram shows an SNMP
    MIB containing N MIB objects. Each object has five mandatory characteristics and
    a variable number of optional characteristics.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 66-1. SNMP 管理信息库 (MIB) 此图显示了包含 N 个 MIB 对象的 SNMP MIB。每个对象具有五个强制特性和一个可变数量的可选特性。
- en: SMI Data Types
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SMI 数据类型
- en: '[Table 66-1](ch66s02.html#snmp_smi_regular_data_types "Table 66-1. SNMP SMI
    Regular Data Types") shows the regular data types supported for objects in both
    SMIv1 and SMIv2\. (The names with 32 in them are the ones used in SMIv2; they
    were changed to make the type''s bit size explicit.) The first five entries in
    the table are primitive types; the rest are defined types, using the SMIv1 terminology.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 66-1](ch66s02.html#snmp_smi_regular_data_types "表 66-1. SNMP SMI 常规数据类型")
    显示了 SMIv1 和 SMIv2 中支持的对象的常规数据类型。（包含 32 的名称是在 SMIv2 中使用的；它们被更改以使类型的位数明确。）表中的前五个条目是原始类型；其余的是定义类型，使用
    SMIv1 术语。'
- en: Table 66-1. SNMP SMI Regular Data Types
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表 66-1. SNMP SMI 常规数据类型
- en: '| Data Type Code | Description | In SMIv1? | In SMIv2? |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型代码 | 描述 | 在 SMIv1 中？ | 在 SMIv2 中？ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Integer/Integer32 | A 32-bit signed integer in two''s complement notation,
    capable of holding a value from -2,147,483,648 to +2,147,483,647\. Can also be
    used to represent an enumerated type; for example, where 1 represents a particular
    constant, 2 represents a different one, and so on. | Yes | Yes |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Integer/Integer32 | 以二进制补码表示的 32 位有符号整数，能够存储从 -2,147,483,648 到 +2,147,483,647
    的值。也可以用来表示枚举类型；例如，其中 1 表示一个特定的常量，2 表示另一个，依此类推。 | 是 | 是 |'
- en: '| Octet String | A variable-length string of binary or text data. | Yes | Yes
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Octet String | 一个可变长度的二进制或文本数据字符串。 | 是 | 是 |'
- en: '| Null | Nothing. | Yes | No |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 空值 | 无。 | 是 | 否 |'
- en: '| Bits | An enumeration of named bits. Used to allow a set of bit flags to
    be treated as a single data type. | No | Yes |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| Bits | 命名位的枚举。用于允许一组位标志被当作一个单一的数据类型处理。 | 否 | 是 |'
- en: '| Unsigned | A 32-bit unsigned integer, from 0 to 4,294,967,295. | No | Yes
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 无符号 | 一个 32 位无符号整数，从 0 到 4,294,967,295。 | 否 | 是 |'
- en: '| Network Address/IpAddress | An IP address, encoded as a 4-byte octet string.
    | Yes | Yes |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 网络地址/IP 地址 | 一个 IP 地址，编码为一个 4 字节八位组字符串。 | 是 | 是 |'
- en: '| Counter/Counter32 | A 32-bit unsigned integer that begins at 0 and increases
    up to 4,294,967,295, then wraps back to 0. | Yes | Yes |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| Counter/Counter32 | 一个 32 位无符号整数，从 0 开始增加，直到 4,294,967,295，然后回绕到 0。 | 是 |
    是 |'
- en: '| Gauge/Gauge32 | A 32-bit unsigned integer that may have a value from 0 to
    4,294,967,295 and may increase or decrease, like a gauge. A minimum and maximum
    value are associated with the gauge, indicating its normal range. | Yes | Yes
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| Gauge/Gauge32 | 一个 32 位无符号整数，其值可以从 0 到 4,294,967,295，可以增加或减少，就像一个仪表。与仪表相关联的最小值和最大值表示其正常范围。
    | 是 | 是 |'
- en: '| TimeTicks | A 32-bit unsigned integer that indicates the number of hundredths
    of seconds since some arbitrary start date. Used for timestamping and to compute
    elapsed time. | Yes | Yes |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| TimeTicks | 一个 32 位无符号整数，表示自某个任意起始日期以来的百分之一秒数。用于时间戳和计算经过时间。 | 是 | 是 |'
- en: '| Opaque | Data using arbitrary ASN.1 syntax that is to be passed between devices
    without being interpreted. As in the Network File System''s (NFS) XDR (see [Chapter 58](ch58.html
    "Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM
    (NFS)")), the term opaque means that the data is treated like a black box, whose
    internal details cannot be seen. | Yes | Yes |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| Opaque | 使用任意 ASN.1 语法的数据，在设备之间传递时不会被解释。如在网络文件系统 (NFS) 的 XDR 中（见 [第 58 章](ch58.html
    "第 58 章. 网络文件和资源共享以及 TCP/IP 网络文件系统 (NFS)"))，术语 opaque 表示数据被当作一个黑盒处理，其内部细节无法看到。
    | 是 | 是 |'
- en: '| Counter64 | A counter like Counter32 but 64 bits wide, allowing a value from
    0 to 18,446,744,073,709,551,615. | No | Yes |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| Counter64 | 与Counter32类似但宽度为64位，允许从0到18,446,744,073,709,551,615的值。 | 无 |
    是 |'
- en: In addition to the types shown in [Table 66-1](ch66s02.html#snmp_smi_regular_data_types
    "Table 66-1. SNMP SMI Regular Data Types"), other defined types are also created
    to indicate more specific semantics for a particular data type. These are called
    *textual conventions* and are described in RFC 2579 for SMIv2\. For example, a
    type called *TimeStamp* is the same as *TimeTicks*. However, seeing an object
    using the former rather than the latter makes it more clear that the variable
    is representing a particular timestamp value. Another is called *TimeInterval*,
    which is also just an integer underneath its name, but conveys a different interpreted
    meaning.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[表66-1](ch66s02.html#snmp_smi_regular_data_types "表66-1. SNMP SMI常规数据类型")中显示的类型之外，还创建了其他定义的类型，以表示特定数据类型的更具体语义。这些被称为*文本约定*，并在RFC
    2579中描述了SMIv2的文本约定。例如，一个名为*TimeStamp*的类型与*TimeTicks*相同。然而，使用前者而不是后者来表示对象，可以使变量代表特定的时间戳值更加清晰。另一个名为*TimeInterval*的类型，其名称下也是一个整数，但传达了不同的解释意义。
- en: If all of this seems very confusing to you, note that this description is actually
    a significant simplification of SMI's object definitions. Check out [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"), which shows an object definition
    from RFC 3418, using SMIv2.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切对你来说都很混乱，请注意，这个描述实际上是SMI对象定义的重大简化。查看[示例66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "示例66-1. 示例SNMP SMIv2对象定义")，它展示了RFC 3418中使用SMIv2的一个对象定义。
- en: Example 66-1. Example SNMP SMIv2 object definition
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例66-1. 示例SNMP SMIv2对象定义
- en: '[PRE0]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that `DisplayString` is a textual convention for a displayed text string.
    The last part, `{ system 6 }`, will be explained in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DisplayString`是显示文本字符串的文本约定。最后一部分，`{ system 6 }`将在下一节中解释。
- en: TCP/IP MIB Object Descriptors and Identifiers and the Object Name Hierarchy
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP MIB对象描述符、标识符和对象名称层次结构
- en: Of the many MIB object characteristics, only one is sufficiently interesting
    that it really deserves its own exposition. Or perhaps I should say that only
    one is sufficiently complicated to require further explanation. This is the object
    name, part of the larger naming system used for MIB objects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多MIB对象特性中，只有一个足够有趣，以至于它真正值得单独阐述。或者也许我应该这么说，只有一个足够复杂，需要进一步的解释。这就是对象名称，它是用于MIB对象的更大命名系统的一部分。
- en: 'Each MIB object actually has two names: an *object descriptor* and an *object
    identifier*.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MIB对象实际上有两个名称：一个*对象描述符*和一个*对象标识符*。
- en: Object Descriptors
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象描述符
- en: The object descriptor is a conventional text name that provides a user-friendly
    handle to refer to the object. The name is assigned based on the particular MIB
    object group in which the object is located. In the previous example, `sysLocation`
    is the object descriptor for that MIB object. I describe these names in greater
    detail later in this chapter, when I discuss MIB modules and object groups.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对象描述符是一个传统的文本名称，它提供了一个用户友好的引用对象的手段。名称是根据对象所在的特定MIB对象组分配的。在先前的例子中，`sysLocation`是该MIB对象的对象描述符。我将在本章后面讨论MIB模块和对象组时，更详细地描述这些名称。
- en: Object Identifiers
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象标识符
- en: Text names are convenient, but they are generally unstructured. There are at
    present more than 10,000 different MIB objects, and even if each has a distinct
    text name, a huge collection of such names doesn't help us to manage these objects
    and see how they are related. For this, we need a more structured approach to
    categorizing and naming objects.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 文本名称很方便，但它们通常是未结构化的。目前有超过10,000个不同的MIB对象，即使每个都有一个独特的文本名称，这样一大堆名称也无法帮助我们管理这些对象并了解它们之间的关系。为此，我们需要一种更结构化的方法来分类和命名对象。
- en: 'This problem is similar to another problem that you may recall reading about:
    the problem of how to assign names on the Internet. Originally, names for hosts
    were simple, flat names, but this quickly grew unwieldy. The DNS hierarchical
    name space (see [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE,
    AND TERMINOLOGY")) allows every device to be arranged into a single hierarchical
    tree structure. The name of the device can be formed by traversing the tree from
    the top down to the location of the device, listing the labels traversed separated
    by dots. For example, the web server of The PC Guide is at [http://www.pcguide.com](http://www.pcguide.com).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与另一个你可能阅读过的类似问题相似：如何在互联网上分配名称的问题。最初，主机的名称是简单的、扁平的名称，但这很快变得难以管理。DNS层次命名空间（见[第53章](ch53.html
    "第53章。DNS名称空间、架构和术语"））允许每个设备被组织成一个单一的层次树结构。设备的名称可以通过从顶部向下遍历树到设备的位置，列出遍历的标签并用点分隔来形成。例如，PC
    Guide的Web服务器位于[http://www.pcguide.com](http://www.pcguide.com)。
- en: This same concept is used to organize MIB objects in SNMP. A single, universal
    hierarchy that contains all MIB objects is used. It is hierarchical in nature,
    and it is split into levels from the most general to the most specific. Each object
    has a particular place in the hierarchy.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的概念用于在SNMP中组织MIB对象。使用一个包含所有MIB对象的单一、通用的层次结构。它是按层次组织的，并且从最一般到最具体分为几个级别。每个对象在层次结构中都有一个特定的位置。
- en: 'There is an important difference between the MIB name hierarchy and the DNS
    one: the MIB name hierarchy is even more universal than the one for DNS. The entire
    subtree of all MIB objects is just one branch of the full, international object
    hierarchy maintained by the International Organization for Standardization (ISO)
    and the International Telecommunication Union (ITU). This object identification
    hierarchy is so general that it can contain a name for every object or variable
    in use by any technology in the entire world (and possibly other planets or solar
    systems).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: MIB名称层次结构与DNS名称层次结构之间有一个重要的区别：MIB名称层次结构比DNS的更通用。所有MIB对象的整个子树只是由国际标准化组织（ISO）和国际电信联盟（ITU）维护的完整、国际对象层次结构的一个分支。这个对象标识符层次结构如此通用，以至于它可以包含世界上任何技术使用的每个对象或变量的名称（以及可能的其他星球或太阳系）。
- en: The reason for my jocularity will become apparent in a moment. Suffice it to
    say that this object tree is enormous. Each node in this tree is identified with
    both a label and an integer. The labels are for descriptive purposes. Object (or
    subtree) identifiers are formed by listing the numbers in sequence from the top
    of the tree down to the node, separated by dots. SNMP doesn't reverse the order
    of the labels the way DNS does, however. They are listed top-down from left to
    right. (The text labels can be used for names, too, but they are not because they
    would get very long due to how deep the tree structure is.)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么这么幽默的原因将在稍后变得明显。只需说，这个对象树非常庞大。这个树中的每个节点都由一个标签和一个整数来标识。标签用于描述目的。对象（或子树）标识符是通过从树的顶部开始，按顺序列出数字，直到节点，并用点分隔来形成的。然而，SNMP并不像DNS那样反转标签的顺序。它们是从上到下，从左到右列出的。（文本标签也可以用作名称，但它们不是，因为由于树结构的深度，它们会变得非常长。）
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP MIB objects have two names. The first is a text *object
    descriptor*, which provides a means of addressing the object in a way that is
    familiar and easy for humans. The second is the *object identifier*, which consists
    of a sequence of integers that specifies the location of the object in the global
    object hierarchy maintained by the international standards bodies ISO and ITU.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP MIB对象有两个名称。第一个是一个文本*对象描述符*，它提供了一种以熟悉且易于人类的方式访问对象的方法。第二个是*对象标识符*，它由一系列整数组成，指定了对象在国际标准机构ISO和ITU维护的全局对象层次结构中的位置。'
- en: Structure of the MIB Object Name Hierarchy
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB对象名称层次结构
- en: Let's explore how the MIB object tree is structured, and more important, how
    SNMP MIB objects fit into it. [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.") illustrates the global object name hierarchy and SNMP
    MIB hierarchies.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨MIB对象树的构成，更重要的是，SNMP MIB对象是如何融入其中的。[图66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "图66-2. 全局对象名称层次结构和SNMP MIB层次结构 此图显示了ISO和CCITT（ITU）定义的对象名称层次结构，以允许所有类型的对象被普遍表示。通过跟随阴影框，可以找到通向与SNMP相关的树分支的路径。用于SNMP的两个子树以互联网(1)下的网纹框表示。每个子树都包含自己的子结构（其中一些在此处展示），定义了数千个不同的MIB对象。左侧的分支用于通用MIB对象，右侧的分支用于私有对象。还定义了一个单独的层次结构用于SNMPv2。")展示了全局对象名称层次结构和SNMP
    MIB层次结构。
- en: '![Global object name hierarchy and SNMP MIB hierarchies This diagram shows
    the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of
    objects to be universally represented. The path within this larger tree to the
    tree branches relevant to SNMP can be found by following the shaded boxes. The
    two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each
    contains its own substructure (some of which is illustrated here) defining thousands
    of different MIB objects. The branch on the left side is used for generic MIB
    objects and the one on the right for private ones. A separate hierarchy is also
    defined for SNMPv2.](httpatomoreillycomsourcenostarchimages288231.png.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![全局对象名称层次结构和SNMP MIB层次结构 此图显示了ISO和CCITT（ITU）定义的对象名称层次结构，以允许所有类型的对象被普遍表示。通过跟随阴影框，可以找到通向与SNMP相关的树分支的路径。用于SNMP的两个子树以互联网(1)下的网纹框表示。每个子树都包含自己的子结构（其中一些在此处展示），定义了数千个不同的MIB对象。左侧的分支用于通用MIB对象，右侧的分支用于私有对象。还定义了一个单独的层次结构用于SNMPv2。](httpatomoreillycomsourcenostarchimages288231.png.jpg)'
- en: Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图66-2. 全局对象名称层次结构和SNMP MIB层次结构 此图显示了ISO和CCITT（ITU）定义的对象名称层次结构，以允许所有类型的对象被普遍表示。通过跟随阴影框，可以找到通向与SNMP相关的树分支的路径。用于SNMP的两个子树以互联网(1)下的网纹框表示。每个子树都包含自己的子结构（其中一些在此处展示），定义了数千个不同的MIB对象。左侧的分支用于通用MIB对象，右侧的分支用于私有对象。还定义了一个单独的层次结构用于SNMPv2。
- en: 'The tree''s root has no label, and has three children:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 树的根没有标签，有三个子节点：
- en: ccitt(0) for ITU (formerly the CCITT) standards (also seen as itu(0)).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ccitt(0)用于ITU（以前称为CCITT）标准（也可见为itu(0)）。
- en: iso(1) for ISO standards.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iso(1)用于ISO标准。
- en: joint-iso-ccitt(2) for joint standards (also seen as joint-iso-itu(2)).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: joint-iso-ccitt(2)用于联合标准（也可见为joint-iso-itu(2))。
- en: 'Following the iso(1) node, we see the following at the next several levels:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在iso(1)节点之后，在接下来的几个级别上，我们看到以下内容：
- en: Within iso(1), the ISO has created a subtree for use by other organizations,
    called org(3).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iso(1)中，ISO为其他组织创建了一个子树，称为org(3)。
- en: 'Within org(3), there is a subtree for the United States Department of Defense
    (which, as you may recall, was the originator of the Internet): dod(6).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在org(3)中，有一个子树用于美国国防部（如您可能记得，它是互联网的发起者）：dod(6)。
- en: Within dod(6), there is a subtree called internet(1).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在dod(6)中，有一个名为internet(1)的子树。
- en: 'Everything we work with in SNMP is under this one very specific subtree: 1.3.6.1,
    which if we used the text labels would be iso.org.dod.internet. Within this part
    of the name space, there are six subtrees below:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 SNMP 中使用的一切都位于这个非常具体的子树中：1.3.6.1，如果使用文本标签，将是 iso.org.dod.internet。在这个命名空间的部分中，有六个子树：
- en: directory(1) is reserved for future use by ISO.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: directory(1) 是为 ISO 保留的，供将来使用。
- en: mgmt(2) is the primary subtree where MIB objects are located. This is 1.3.6.1.2\.
    It contains a subtree called mib(1), which is 1.3.6.1.2.1\. When MIB-II was created,
    a subtree called mib-2(1) was created using the same number, 1.3.6.1.2.1.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mgmt(2) 是 MIB 对象的主要子树。这是 1.3.6.1.2。它包含一个名为 mib(1) 的子树，即 1.3.6.1.2.1。当创建 MIB-II
    时，使用相同的数字 1.3.6.1.2.1 创建了一个名为 mib-2(1) 的子树。
- en: experimental(3) contains objects used for standards under development. This
    is 1.3.6.1.3.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: experimental(3) 包含用于正在开发中的标准的对象。这是 1.3.6.1.3。
- en: private(4) is used for objects defined by private companies. This node, 1.3.6.1.4,
    has a subtree called enterprise(1), which is 1.3.6.1.4.1.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: private(4) 用于由私有公司定义的对象。此节点 1.3.6.1.4 有一个名为 enterprise(1) 的子树，即 1.3.6.1.4.1。
- en: security(5) is reserved for security use.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: security(5) 是为安全用途保留的。
- en: snmpV2(6) defines objects used specifically for SNMP version 2.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: snmpV2(6) 定义了用于 SNMP 版本 2 的对象。
- en: 'So, what''s the bottom line of all this? Well, basically all MIB module objects
    are named within one of these two branches of the overall object tree:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切的底线是什么？好吧，基本上所有 MIB 模块对象都在整体对象树的两个分支之一中命名：
- en: '**Regular MIB Objects** These are in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规 MIB 对象** 这些位于 mgmt(2) 下 mib(1) 子树中：1.3.6.1.2.1。'
- en: '**Private MIB Objects** These are in the enterprise(1) subtree under private(4),
    which is 1.3.6.1.4.1\. For example, within enterprise(1), there is an entry cisco(9)
    for Cisco Systems. So all Cisco-specific MIB objects start with 1.3.6.1.4.1.9.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有 MIB 对象** 这些位于 private(4) 下 enterprise(1) 子树中，即 1.3.6.1.4.1。例如，在 enterprise(1)
    中有一个 cisco(9) 的条目用于 Cisco Systems。因此，所有 Cisco 特定的 MIB 对象都以 1.3.6.1.4.1.9 开头。'
- en: Clear as mud, right? Why didn't they just make a separate hierarchy where "mib"
    was at the top instead of six levels deep? How dare you even suggest such a thing?
    Don't you understand the importance of global standards?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚如泥，对吧？他们为什么不直接创建一个单独的层次结构，其中“mib”位于顶部而不是六层深？你怎么敢提出这样的建议？你不理解全球标准的重要性吗？
- en: All facetiousness aside, this name hierarchy is a bit cumbersome to deal with
    (okay, more than a bit), but it does allow us to keep MIB objects organized in
    a sensible way. Within the 1.3.6.1.2.1 subtree, we find most of the regular MIB
    objects used in SNMP. Each subtree within 1.3.6.1.2.1 corresponds to one of the
    regular SNMP object groups or a particular MIB module.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一切玩笑话 aside，这个名称层次结构处理起来有点繁琐（好吧，不止一点点），但它确实允许我们以合理的方式组织 MIB 对象。在 1.3.6.1.2.1
    子树中，我们找到了大多数在 SNMP 中使用的常规 MIB 对象。1.3.6.1.2.1 中的每个子树都对应于一个常规 SNMP 对象组或特定的 MIB 模块。
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** All MIB objects have object identifiers that fit within two
    branches of the global object hierarchy. Regular MIB objects (which are not vendor-specific)
    fit in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1\. Private objects, which
    can be created by a hardware vendor to assist in managing that vendor''s products,
    are in the enterprise(1) subtree under private(4), which is 1.3.6.1.4.1.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 所有 MIB 对象都具有适合于全局对象层次结构两个分支的对象标识符。常规 MIB 对象（非厂商特定）位于 mgmt(2) 子树下的
    mib(1) 下：1.3.6.1.2.1。私有对象，可以由硬件厂商创建以帮助管理该厂商的产品，位于 private(4) 子树下的 enterprise(1)
    下，即 1.3.6.1.4.1。'
- en: Recursive Definition of MIB Object Identifiers
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB 对象标识符的递归定义
- en: An object is given a text object descriptor by putting its name at the start
    of the object, as shown in [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"), but the definition of numeric
    object identifiers is, again, more complex. It is done by defining only the number
    of the object within its particular subtree. This means the object identifiers
    are defined recursively (one based on another) and are not explicitly stated for
    each object. This is syntactically precise, but makes it hard to see at a glance
    what the number is for any particular object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将对象名称放在对象的开头，给对象赋予一个文本对象描述符，如[示例 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "示例 66-1. 示例 SNMP SMIv2 对象定义")所示，但数字对象标识符的定义，再次，更为复杂。这是通过仅定义对象在其特定子树中的数字来完成的。这意味着对象标识符是递归定义的（一个基于另一个）并且没有为每个对象明确声明。这在语法上是精确的，但使得一眼就能看出任何特定对象的数字变得困难。
- en: Consider again the example in [Example 66-1](ch66s02.html#example_snmp_smiv2_object_definition
    "Example 66-1. Example SNMP SMIv2 object definition"). For this object, `sysLocation`
    is the object descriptor and `{ system 6 }` is the object identifier. This means
    it is object number 6 within the node system, which is in turn defined as `{ mib-2
    1 }`—it is the first node within the mib-2 subtree. Since mib-2 is 1.3.6.1.2.1,
    as noted in the previous section, this means `system` is 1.3.6.1.2.1.1 and `sysLocation`
    is 1.3.6.1.2.1.1.6.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑本章前面提到的 [示例 66-1](ch66s02.html#example_snmp_smiv2_object_definition "示例
    66-1. 示例 SNMP SMIv2 对象定义")。对于此对象，`sysLocation` 是对象描述符，`{ system 6 }` 是对象标识符。这意味着它是节点系统中的第
    6 个对象，而节点系统被定义为 `{ mib-2 1 }`——它是 mib-2 子树中的第一个节点。由于 mib-2 是 1.3.6.1.2.1，如前所述，这意味着
    `system` 是 1.3.6.1.2.1.1，而 `sysLocation` 是 1.3.6.1.2.1.1.6。
- en: TCP/IP MIB Modules and Object Groups
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP MIB 模块和对象组
- en: The MIB contains the collection of MIB objects that describe the characteristics
    of a device using the SNMP Framework. When SNMP was first created, there were
    not that many objects in the MIB. Furthermore, they were mostly generic objects
    that applied fairly universally to TCP/IP devices as a whole. In fact, most of
    the MIB objects were variables related to the operation of TCP/IP protocols such
    as IP, the Transmission Control Protocol (TCP), and the Internet Control Message
    Protocol (ICMP).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: MIB 包含了使用 SNMP 框架描述设备特性的 MIB 对象集合。当 SNMP 首次创建时，MIB 中的对象并不多。此外，它们大多是通用的对象，可以相当普遍地应用于整个
    TCP/IP 设备。实际上，MIB 中的大多数对象都与 TCP/IP 协议的操作相关，例如 IP、传输控制协议 (TCP) 和互联网控制消息协议 (ICMP)。
- en: For this reason, at first, a single document defined "the" MIB for SNMP. The
    first of these documents was RFC 1066, part of the initial SNMPv1 specification.
    It was then revised in RFC 1156\. In RFC 1158, a second version of the MIB, *MIB
    II*, was defined, which was essentially the same but made a few changes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最初，一个单独的文档定义了“MIB”的“定义”。这些文档中的第一个是 RFC 1066，它是初始 SNMPv1 规范的一部分。随后在 RFC 1156
    中进行了修订。在 RFC 1158 中，定义了 MIB 的第二个版本，即 *MIB II*，它与第一个版本基本相同，但做了一些修改。
- en: The Organization of MIB Objects into Object Groups
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 MIB 对象组织成对象组
- en: The number of MIB objects defined in the early MIB standards was relatively
    small. However, there were still several dozen of them, and it was recognized
    from the start that more would be created in time. To help organize the objects
    in a logical way, they were arranged into *object groups*. These groups serve
    the purpose of separating the objects and defining how they should be given object
    identifiers in the overall object name hierarchy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 MIB 标准中定义的 MIB 对象数量相对较少。然而，仍然有几十个，从一开始就认识到随着时间的推移将会有更多。为了以逻辑方式组织对象，它们被安排成
    *对象组*。这些组的作用是分离对象，并定义它们在整体对象名称层次结构中应如何分配对象标识符。
- en: 'Each group has associated with it three important pieces of information:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组都与以下三个重要信息相关联：
- en: '**Group Name** This is a name that is used as a text label in the object identification
    tree described earlier in this chapter (see [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.")). These objects are all located within the iso.org.dod.internet.mgmt.mib
    subtree. So, for example, the group system would be iso.org.dod.internet.mgmt.mib.system.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**组名** 这是一个用作本章前面所述的对象识别树中的文本标签的名称（参见 [图 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "图 66-2. 全局对象名称层次结构和 SNMP MIB 层次结构 此图显示了 ISO 和 CCITT（ITU）定义的对象名称层次结构，以允许所有类型的对象被普遍表示。可以通过跟随阴影框找到此较大树中与
    SNMP 相关的树分支。用于 SNMP 的两个子树显示为 internet(1) 下的阴影框。每个都包含自己的子结构（其中一些在此处展示），定义了数千个不同的
    MIB 对象。左侧的分支用于通用 MIB 对象，右侧的用于私有对象。还定义了一个单独的层次结构用于 SNMPv2。")). 这些对象都位于 iso.org.dod.internet.mgmt.mib
    子树中。例如，系统组将是 iso.org.dod.internet.mgmt.mib.system。'
- en: '**Group Number** This number corresponds to the group name used for making
    numeric identifiers from the object name tree. For example, the group system has
    the number 1, and so the group''s object identifier is 1.3.6.1.2.1.1\. All objects
    in that group will be under that tree; for example, `sysUpTime` is 1.3.6.1.2.1.1.3.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**组编号** 此数字对应于用于从对象名称树中创建数字标识符的组名称。例如，系统组有数字1，因此该组的对象标识符是1.3.6.1.2.1.1。该组中的所有对象都将位于该树之下；例如，`sysUpTime`是1.3.6.1.2.1.1.3。'
- en: '**Group Code** This is a text label that may be the same as the group name
    or may be an abbreviation. It is used as a prefix in making object descriptors
    (the text names of objects). For example, for the group system, the code is `sys`,
    and so an object in this group is `sysUpTime`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**组代码** 这是一个文本标签，可能与组名称相同，也可能是缩写。它用于在制作对象描述符（对象的文本名称）时作为前缀。例如，对于系统组，代码是`sys`，因此该组中的对象是`sysUpTime`。'
- en: '[Table 66-2](ch66s04.html#snmp_generic_mib_object_groups "Table 66-2. SNMP
    Generic MIB Object Groups") shows the eight generic SNMP groups defined in RFC
    1158, along with their codes, names, and numbers.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[表66-2](ch66s04.html#snmp_generic_mib_object_groups "表66-2. SNMP通用MIB对象组")展示了在RFC
    1158中定义的八个通用SNMP组，包括它们的代码、名称和数字。'
- en: Table 66-2. SNMP Generic MIB Object Groups
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 表66-2. SNMP通用MIB对象组
- en: '| Group Name | Group Code | Group Number | Full Group Identifier | Description
    |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| Group Name | Group Code | Group Number | Full Group Identifier | Description
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| system | `sys` | 1 | 1.3.6.1.2.1.1 | General objects of relevance to all
    or most devices. For example, a general description of the device is an object
    in this group, as is the identifier of the object. Later MIB versions greatly
    expanded the number of variables in this group. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| system | `sys` | 1 | 1.3.6.1.2.1.1 | 与所有或大多数设备相关的通用对象。例如，设备的通用描述是该组中的一个对象，对象的标识符也是如此。后来的MIB版本大大增加了该组中的变量数量。|'
- en: '| interfaces | `if` | 2 | 1.3.6.1.2.1.2 | Objects related to the IP interfaces
    between this device and the internetwork. (Recall that a regular host normally
    has one interface, while a router has two or more.) |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| interfaces | `if` | 2 | 1.3.6.1.2.1.2 | 与该设备与互联网之间的IP接口相关的对象。（回想一下，普通主机通常有一个接口，而路由器有两个或更多。）|'
- en: '| at (address translation) | `at` | 3 | 1.3.6.1.2.1.3 | Objects used for IP
    address translation. (No longer used.) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| at (地址转换) | `at` | 3 | 1.3.6.1.2.1.3 | 用于IP地址转换的对象。（不再使用。）|'
- en: '| ip | `ip` | 4 | 1.3.6.1.2.1.4 | Objects related to the IP layer of the device
    as a whole (as opposed to interface-specific information in the `if` group). |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| ip | `ip` | 4 | 1.3.6.1.2.1.4 | 与设备整体IP层相关的对象（与`if`组中的接口特定信息相对）。|'
- en: '| icmp | `icmp` | 5 | 1.3.6.1.2.1.5 | Objects related to the operation of ICMP.
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| icmp | `icmp` | 5 | 1.3.6.1.2.1.5 | 与ICMP操作相关的对象。|'
- en: '| tcp | `tcp` | 6 | 1.3.6.1.2.1.6 | Objects related to the operation of the
    TCP. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| tcp | `tcp` | 6 | 1.3.6.1.2.1.6 | 与TCP操作相关的对象。|'
- en: '| udp | `udp` | 7 | 1.3.6.1.2.1.7 | Objects related to the operation of the
    User Datagram Protocol (UDP). |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| udp | `udp` | 7 | 1.3.6.1.2.1.7 | 与用户数据报协议（UDP）的操作相关的对象。|'
- en: '| egp | `egp` | 8 | 1.3.6.1.2.1.8 | Objects related to the operation of the
    Exterior Gateway Protocol (EGP). |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| egp | `egp` | 8 | 1.3.6.1.2.1.8 | 与外部网关协议（EGP）的操作相关的对象。|'
- en: '| cmot | `cmot` | 9 | 1.3.6.1.2.1.9 | Objects related to running the CMIP protocol
    over TCP (historical, not used). |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| cmot | `cmot` | 9 | 1.3.6.1.2.1.9 | 与在TCP上运行CMIP协议相关的对象（历史性的，不再使用）。|'
- en: '| transmission | `trans` | 10 | 1.3.6.1.2.1.10 | Objects related to the specific
    method of information transmission used by each interface on the system. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| transmission | `trans` | 10 | 1.3.6.1.2.1.10 | 与系统上每个接口使用的特定信息传输方法相关的对象。|'
- en: '| snmp | `snmp` | 11 | 1.3.6.1.2.1.11 | Objects used to manage SNMP itself.
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| snmp | `snmp` | 11 | 1.3.6.1.2.1.11 | 用于管理SNMP本身的对象。|'
- en: All of the groups in this table are fairly generic, and with the exception of
    the one about EGP, apply to pretty much every TCP/IP system using SNMP. (The mention
    of EGP, a routing protocol now considered obsolete, shows the age of this list.)
    The first five groups and the last one are mandatory for all systems. The others
    are used only by devices that use the indicated protocols or functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的所有组都是相当通用的，除了关于EGP的那个组外，几乎适用于所有使用SNMP的TCP/IP系统。（提到EGP，这是一种现在被认为是过时的路由协议，显示了该列表的年龄。）前五个组和最后一个组对所有系统都是强制性的。其他组仅由使用指示协议或功能的设备使用。
- en: MIB Modules
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB模块
- en: What's most conspicuous about the object groups listed in [Table 66-2](ch66s04.html#snmp_generic_mib_object_groups
    "Table 66-2. SNMP Generic MIB Object Groups") is the groups that are not included.
    There are no groups for most of the other TCP/IP protocols, nor any for variables
    that might be needed for specific hardware types. For example, most hosts will
    have a network card in them using a layer 2 protocol like Ethernet or Token Ring.
    How does a manager check or control the operation of this hardware? What about
    newer routing protocols like Open Shortest Path First (OSPF) or Border Gateway
    Protocol (BGP)? How about objects related to running the Domain Name System (DNS)?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表66-2](ch66s04.html#snmp_generic_mib_object_groups "表66-2. SNMP通用MIB对象组")中列出的对象组中最引人注目的是那些未被包含的组。对于大多数其他TCP/IP协议，没有相应的组，也没有为特定硬件类型可能需要的变量设置任何组。例如，大多数主机都会内置一个使用层2协议（如以太网或令牌环）的网络卡。管理者如何检查或控制该硬件的操作？对于像开放最短路径优先（OSPF）或边界网关协议（BGP）这样的新路由协议呢？又或者是与运行域名系统（DNS）相关的对象呢？
- en: Updating the MIB document constantly would have been impractical. Instead, in
    SNMPv2, the MIB was changed from a single document to a group of documents. The
    basic organization into groups of objects was retained, but instead of all groups
    being in the same standard, they are divided into multiple standards. A method
    was also defined for how to create *MIB modules* that describe new groups of objects
    specific to a particular technology. A list of these modules is maintained by
    the *Internet Assigned Numbers Authority* (IANA), the organization that maintains
    all of these sorts of numbers. The current list of SNMP MIB modules can be found
    at [http://www.iana.org/assignments/smi-numbers](http://www.iana.org/assignments/smi-numbers).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 持续更新MIB文档是不切实际的。相反，在SNMPv2中，MIB从单一文档变为一系列文档。保留了将对象分组的基本组织结构，但不再是所有组都在同一标准中，而是被划分为多个标准。还定义了一种创建描述特定技术特定对象组的新方法的方法。这些模块的列表由*互联网数字分配机构*（IANA）维护，该机构维护所有这些类型的数字。当前SNMP
    MIB模块的列表可以在[http://www.iana.org/assignments/smi-numbers](http://www.iana.org/assignments/smi-numbers)找到。
- en: The use of MIB modules makes putting SNMP support into a device somewhat like
    going shopping. The basic groups common to all devices are incorporated into each
    device, and then other modules/groups are used as needed. [Table 66-3](ch66s04.html#some_common_snmp_mib_modules
    "Table 66-3. Some Common SNMP MIB Modules") provides a brief selection of MIB
    modules to give you an idea of what is out there, also showing the module's group
    number (within the 1.3.6.1.2.1 name subtree). There are many, many more modules
    than listed in this table.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIB模块将SNMP支持集成到设备中，有点像去购物。将所有设备共有的基本组纳入每个设备中，然后根据需要使用其他模块/组。[表66-3](ch66s04.html#some_common_snmp_mib_modules
    "表66-3. 一些常见的SNMP MIB模块")提供了一些MIB模块的简要选择，以给您一个关于现有内容的想法，同时也显示了模块的组号（在1.3.6.1.2.1名称子树中）。表中列出的模块远不止这些。
- en: Table 66-3. Some Common SNMP MIB Modules
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 表66-3. 一些常见的SNMP MIB模块
- en: '| MIB Module Name | Group Number | Description |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| MIB模块名称 | 组号 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ospf` | 14 | Objects related to OSPF |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `ospf` | 14 | 与OSPF相关的对象 |'
- en: '| `bgp` | 15 | Objects related to BGP |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `bgp` | 15 | 与BGP相关的对象 |'
- en: '| `rmon` | 16 | Objects used as part of Remote Network Monitoring (RMON) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `rmon` | 16 | 作为远程网络监控（RMON）一部分使用的对象 |'
- en: '| `snmpDot3 RptrMgt` | 22 | Objects related to IEEE 802.3 (Ethernet) repeaters
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `snmpDot3 RptrMgt` | 22 | 与IEEE 802.3（以太网）中继器相关的对象 |'
- en: '| `rip-2` | 23 | Objects used as part of version 2 of the Routing Information
    Protocol (RIP) |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `rip-2` | 23 | 作为路由信息协议（RIP）第2版一部分使用的对象 |'
- en: '| `snmpDot3 MauMgt` | 26 | Objects related to IEEE 802.3 (Ethernet) medium
    attachment units |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `snmpDot3 MauMgt` | 26 | 与IEEE 802.3（以太网）介质附件单元相关的对象 |'
- en: '| `etherMIB` | 35 | Ethernet-like generic objects |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `etherMIB` | 35 | 类似以太网的通用对象 |'
- en: '| `mipMIB` | 44 | Mobile IP objects |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `mipMIB` | 44 | 移动IP对象 |'
- en: '| `ipMIB` | 48 | IP objects for SNMPv2 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `ipMIB` | 48 | 用于SNMPv2的IP对象 |'
- en: '| `tcpMIB` | 49 | TCP objects for SNMPv2 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `tcpMIB` | 49 | 用于SNMPv2的TCP对象 |'
- en: '| `udpMIB` | 50 | UDP objects for SNMPv2 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `udpMIB` | 50 | 用于SNMPv2的UDP对象 |'
- en: The last three entries in [Table 66-3](ch66s04.html#some_common_snmp_mib_modules
    "Table 66-3. Some Common SNMP MIB Modules") might seem a bit confusing, since
    there were already groups for IP, TCP, and UDP, as shown in [Table 66-2](ch66s04.html#snmp_generic_mib_object_groups
    "Table 66-2. SNMP Generic MIB Object Groups"). The reason for these is that when
    the new modular architecture for MIB objects was created in SNMPv2, the definition
    of objects for the individual protocols that was part of the one document in SNMPv1
    was separated out into individual MIB documents for consistency and to allow them
    to be updated independently. In fact, the base SNMPv2 and SNMPv3 MIB documents
    now define only objects in the `system` and `snmp` groups.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[表66-3](ch66s04.html#some_common_snmp_mib_modules "表66-3. 一些常见的SNMP MIB模块")中的最后三个条目可能有些令人困惑，因为如[表66-2](ch66s04.html#snmp_generic_mib_object_groups
    "表66-2. SNMP通用MIB对象组")所示，已经存在IP、TCP和UDP的组。这些条目的原因在于，在SNMPv2中创建MIB对象的新模块化架构时，SNMPv1中作为单一文档一部分的各个协议的对象定义被分离出来，以保持一致性并允许它们独立更新。实际上，基本的SNMPv2和SNMPv3
    MIB文档现在只定义了`system`和`snmp`组中的对象。'
- en: Tip
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** MIB objects created early in SNMP''s history were organized
    into *MIB object groups* that reside within the mib(1) subtree, starting with
    identifier code 1.3.6.1.2.1\. As the popularity of TCP/IP grew, it became impractical
    to centrally define all MIB objects, so sets of objects particular to different
    hardware devices are now specified in *MIB modules*.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在SNMP早期历史中创建的MIB对象被组织成位于mib(1)子树中的*MIB对象组*，从标识符代码1.3.6.1.2.1开始。随着TCP/IP的普及，集中定义所有MIB对象变得不切实际，因此特定于不同硬件设备的对象集现在在*MIB模块*中指定。'
- en: MIB Module Format
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MIB模块格式
- en: 'The format for MIB modules is described in the SMI standard, version 2 (SMIv2).
    This document specifies how modules are to be defined in a way similar to how
    objects themselves are defined: by listing a set of characteristics that must
    be included in each module description. The module fields are as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: MIB模块的格式在SMI标准版本2（SMIv2）中描述。本文件指定了如何定义模块，类似于对象本身的定义：通过列出每个模块描述必须包含的一组特征。模块字段如下：
- en: '**Module Name** The name of the module. Remember that modules are really objects,
    syntactically, so like regular objects, they have a textual object descriptor
    (like `tcpMIB`) and an object identifier (in the case of `tcpMIB`, the number
    50).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块名称** 模块的名称。记住，从语法上讲，模块实际上是对象，因此像常规对象一样，它们有一个文本对象描述符（如`tcpMIB`）和一个对象标识符（在`tcpMIB`的情况下，数字50）。'
- en: '**Last Updated** The date and time that the module was last revised.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后更新** 模块最后修订的日期和时间。'
- en: '**Organization** The name of the organization that is managing the development
    of the module.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**组织** 管理模块开发的组织的名称。'
- en: '**Contact Information** The name, address, telephone number, and email address
    of the point person for this module.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**联系方式** 此模块负责人的姓名、地址、电话号码和电子邮件地址。'
- en: '**Description** A description of the module.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述** 模块的描述。'
- en: '**Revision and Revision Description** One Revision entry is placed for each
    revision of the module to show its history. Each entry has a description associated
    with it.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**修订和修订描述** 每次模块的修订都会有一条修订记录，以显示其历史。每条记录都与一个描述相关联。'
- en: After the definition of the module itself, the objects in the module are described.
    For an example, see RFC 2012, which defines the SNMPv2 TCP MIB.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块本身的定义之后，模块中的对象将被描述。例如，请参阅RFC 2012，它定义了SNMPv2 TCP MIB。
- en: Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第67章。TCP/IP简单网络管理协议（SNMP）概念和操作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The overall network management solution for TCP/IP networks is the Internet
    Standard Management Framework. In the previous two chapters, we have taken a look
    at the Framework as a whole, and also discussed the two components that define
    the management information transmitted between TCP/IP devices to accomplish network
    management. The third major part of the SNMP Framework is the actual *Simple Network
    Management Protocol (SNMP)*, which is responsible for moving management information
    between devices.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP网络的总体网络管理解决方案是互联网标准管理框架。在前两章中，我们整体地审视了该框架，并讨论了定义TCP/IP设备之间传输的管理信息的两个组件。SNMP框架的第三大组成部分是实际的*简单网络管理协议（SNMP）*，它负责在设备之间移动管理信息。
- en: The core of the protocol consists of a set of *protocol operations* that allow
    management information to be exchanged between SNMP agents and managers. Having
    previously examined the generalities of SNMP and what management information base
    (MIB) objects are, we can now get down to the nitty gritty of how management information
    is actually communicated using SNMP.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的核心由一组*协议操作*组成，这些操作允许在SNMP代理和管理器之间交换管理信息。在之前考察了SNMP的一般性和管理信息库（MIB）对象之后，我们现在可以深入探讨如何使用SNMP实际进行管理信息的通信。
- en: 'In this chapter, I provide a detailed description of the operations performed
    by the SNMP protocol. I begin with a brief overview and history of the protocol.
    I then provide a general description of how SNMP operates and the two basic methods
    that devices use to communicate. I also describe SNMP''s message classes and the
    basic operations performed in SNMP: basic request/response, table traversal, object
    modification, and notification. I conclude with a discussion of SNMP security
    issues and a summary of the security methods in each of the SNMP versions.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我详细描述了SNMP协议执行的操作。我首先简要概述和介绍协议的历史。然后提供SNMP如何操作的一般描述以及设备用于通信的两种基本方法。我还描述了SNMP的消息类和SNMP中执行的基本操作：基本请求/响应、表遍历、对象修改和通知。最后，我讨论了SNMP的安全问题，并总结了每个SNMP版本中的安全方法。
- en: Note
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The number and types of protocol operations in SNMP changed between SNMPv1
    and SNMPv2\. The operations defined in SNMPv2 have been carried forward into the
    newest version, SNMPv3\. Most of the discussion focuses on SNMPv3 as the newest
    implementation, noting the differences between it and the original and still widely
    used SNMPv1*.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*SNMP中协议操作的数量和类型在SNMPv1和SNMPv2之间发生了变化。SNMPv2中定义的操作已延续到最新的版本SNMPv3。大部分讨论都集中在最新的实现SNMPv3上，并指出它与原始的、仍然广泛使用的SNMPv1之间的差异*。'
- en: SNMP Protocol Overview
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP协议概述
- en: As explained in the previous chapters, the SNMP Framework is often described
    as being *information-oriented*. A specific decision was made in the design of
    the SNMP Framework to decouple the management information conveyed between SNMP
    agents and SNMP managers from the protocol used to carry that information. This
    provides numerous benefits to the technology as a whole, chief among them flexibility
    and modularity.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，SNMP框架通常被描述为*信息导向的*。在SNMP框架的设计中，做出了一项特定决策，将SNMP代理和SNMP管理器之间传递的管理信息与用于携带该信息的协议解耦。这对整个技术提供了许多好处，其中最重要的是灵活性和模块化。
- en: In this model, the operation of the management protocol is *not* defined in
    terms of specific commands made to check the status of a device or change how
    it operates. Instead, the protocol is defined in terms of management information
    variables called *objects*, and a communication protocol that allows these objects
    to be either examined or changed by a network administrator. I describe this concept
    thoroughly in the previous chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，管理协议的操作不是通过向设备发送特定命令来检查其状态或更改其操作方式来定义的。相反，协议是通过称为*对象*的管理信息变量来定义的，以及一个允许网络管理员检查或更改这些对象的通信协议。我在前一章中详细描述了这一概念。
- en: The MIB and Structure of Management Information (SMI) spell out the rules for
    how MIB objects are created and described. These MIB objects describe the types
    of information that can be read from the device or written to the device. The
    last piece of the puzzle is the actual protocol that is responsible for these
    read- and write-type operations. This is SNMP itself, which I give the somewhat
    redundant name *SNMP protocol* to differentiate it from the SNMP Framework.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: MIB和管理信息结构（SMI）规定了如何创建和描述MIB对象。这些MIB对象描述了可以从设备读取或写入设备的信息类型。最后一部分是负责这些读取和写入操作的协议本身。这就是SNMP本身，我给它起了一个有些冗余的名字*SNMP协议*，以区分它和SNMP框架。
- en: The result of the separation of the protocol from the management information
    it carries is that the protocol itself becomes significantly reduced in complexity.
    Instead of the SNMP protocol needing to define dozens or even hundreds of operations
    that specify particular network management functions, it needs to deal with only
    the transmission of MIB object information between SNMP agents and managers. The
    SNMP protocol itself does not pay attention to what is in these objects; it is
    merely concerned with moving them around. In some ways, the SNMP protocol is the
    only really simple part of SNMP!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将协议与其携带的管理信息分离的结果是，协议本身的复杂性显著降低。SNMP协议不需要定义数十个甚至数百个特定网络管理功能的操作，它只需要处理SNMP代理和管理员之间MIB对象信息的传输。SNMP协议本身并不关注这些对象中有什么；它只是关注移动它们。在某种程度上，SNMP协议是SNMP中唯一真正简单的部分！
- en: Early Development of SNMPv1
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv1的早期开发
- en: The history of the SNMP protocol goes back to the predecessor of the SNMP Framework,
    the *Simple Gateway Monitoring Protocol (SGMP)*, which was defined in RFC 1028
    in 1987\. SGMP was designed as an interim solution for network management while
    larger issues were being explored, as I explained in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"). However, this standard is where
    many of the basic design concepts underlying the modern SNMP protocol can be found.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP协议的历史可以追溯到SNMP框架的前身，即*简单网关监控协议（SGMP）*，该协议于1987年在RFC 1028中定义。SGMP被设计为一个临时解决方案，用于在探索更大问题期间进行网络管理，正如我在[第65章](ch65.html
    "第65章. TCP/IP互联网标准管理框架概述")中解释的那样。然而，这个标准中可以找到许多现代SNMP协议背后的基本设计概念。
- en: The SGMP standard specified the basic design model used in SNMP by describing
    SGMP in terms of only retrievals of, or alterations to, variables stored on an
    Internet gateway (router). The standard also outlines the small number of protocol
    operations that are still the basis for SNMP's operation today.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: SGMP标准通过仅用SGMP描述互联网网关（路由器）上存储的变量的检索或更改来描述SNMP使用的基本设计模型。该标准还概述了今天SNMP操作仍基于的少量协议操作。
- en: The first version of the SNMP Framework, SNMPv1, included the first formal definition
    of the SNMP protocol in RFC 1067 (later revised by RFCs 1098 and 1157). This standard
    refines the protocol operations given in the SGMP document. It makes the operation
    of the SNMP protocol fit into the overall SNMP Framework, working with formally
    defined MIB objects.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP框架的第一个版本，SNMPv1，在RFC 1067中包含了SNMP协议的第一个正式定义（后来由RFC 1098和RFC 1157修订）。这个标准精炼了SGMP文档中给出的协议操作。它使SNMP协议的操作适合于整个SNMP框架，与正式定义的MIB对象一起工作。
- en: SNMPv2 and the Division of SNMP into Protocol Operations and Transport Mappings
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv2和将SNMP分为协议操作和传输映射
- en: 'When SNMPv2 was created, the single document describing the SNMP protocol was
    split into two standards, to make the protocol more modular and better reflective
    of the layers used in internetworks:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建SNMPv2时，描述SNMP协议的单个文件被拆分为两个标准，以使协议更加模块化，并更好地反映互联网中使用的层：
- en: '**Protocol Operations** The first document of the pair describes the actual
    mechanics by which MIB objects are moved between SNMP devices using particular
    SNMP message types. In SNMPv3, it is RFC 3416, "Version 2 of the Protocol Operations
    for the Simple Network Management Protocol (SNMP)." When people talk about just
    "the SNMP standard," this is the document they usually mean.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议操作**这对文档中的第一份文件描述了通过特定的SNMP消息类型在SNMP设备之间移动MIB对象的实际机制。在SNMPv3中，它是RFC 3416，“简单网络管理协议（SNMP）的协议操作版本2。”当人们谈论“SNMP标准”时，通常指的是这份文档。'
- en: '**Transport Mappings** The second document details how the SNMP protocol operations
    described in the first standard can be transported over a variety of different
    protocol suites. By using the correct mapping, SNMP operations can be carried
    out using lower-layer technologies other than the Internet Protocol (IP). This
    standard is represented in SNMPv3 by RFC 3417, "Transport Mappings for the Simple
    Network Management Protocol (SNMP)."'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输映射**第二份文件详细说明了如何将第一标准中描述的SNMP协议操作传输到各种不同的协议套件中。通过使用正确的映射，SNMP操作可以使用除了互联网协议（IP）之外的下层技术执行。这个标准在SNMPv3中由RFC
    3417，“简单网络管理协议（SNMP）的传输映射”表示。'
- en: Tip
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The actual mechanism used to communicate management information
    between network management stations (NMSs) and managed devices is called the *Simple
    Network Management Protocol*, which may be called the *SNMP protocol* to differentiate
    it from the SNMP Framework. It consists of a number of *protocol operations* that
    describe the actual message exchanges that take place between devices, and a set
    of *transport mappings* that define how these messages are carried over various
    types of internetworks. The Internet Protocol (IP) is the most common transport
    mapping used for SNMP.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 实际上用于在网络管理站（NMS）和受管理设备之间通信管理信息的机制被称为*简单网络管理协议*，可能被称为*SNMP协议*以区分它和SNMP框架。它由一系列*协议操作*组成，描述了设备之间实际发生的消息交换，以及一组*传输映射*，定义了这些消息如何在各种类型的互联网中传输。互联网协议（IP）是用于SNMP的最常见的传输映射。'
- en: I discuss transport mappings in a little more detail in the description of SNMP
    messaging later in this chapter, but since the IP/User Datagram Protocol (UDP)
    method is by far the most common transport mechanism, there isn't a great deal
    to say about that aspect of the SNMP protocol.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面关于SNMP消息描述的更详细部分中讨论传输映射，但鉴于IP/用户数据报协议（UDP）方法是最常见的传输机制，关于这一方面的SNMP协议并没有太多可说的。
- en: SNMP Communication Methods
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP通信方法
- en: 'For SNMP to be useful in enabling the management of a network, it must allow
    a network administrator using a network management station (NMS) to easily check
    the status of SNMP agents in managed devices. In data communications, there are
    two general techniques that are used in a situation where one entity needs to
    be kept informed about activity or occurrences on another:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SNMP在使网络管理成为可能方面有用，它必须允许网络管理员使用网络管理站（NMS）轻松检查受管理设备中SNMP代理的状态。在数据通信中，有两种一般技术用于一个实体需要了解另一个实体的活动或事件的情况：
- en: '**Poll-Driven Communication** This term refers to the general technique of
    having the one who wants the information ask for it—just like someone might conduct
    a political poll. In SNMP, the NMS would poll SNMP agents for information. A common
    real-life example of polling is the model used by the regular mail service; every
    day you go to check your mailbox to see if you have any mail.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询驱动通信** 这个术语指的是一种一般技术，即想要信息的人去请求信息——就像有人可能进行政治民意调查一样。在SNMP中，NMS会轮询SNMP代理以获取信息。轮询的一个常见现实生活例子是常规邮件服务使用的模型；每天你都会去检查邮箱，看看是否有邮件。'
- en: '**Interrupt-Driven Communication** This term refers to having a device with
    information that another needs to know decide to send the information of its own
    volition. In SNMP, this would refer to an SNMP agent sending information to an
    NMS without being asked. This is the model used by that most famous of interrupters—the
    telephone.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断驱动通信** 这个术语指的是拥有信息而其他设备需要知道的信息设备决定主动发送信息。在SNMP中，这指的是SNMP代理在没有被要求的情况下向NMS发送信息。这是那个最著名的中断者——电话使用的模型。'
- en: 'Which communication method is better? The usual answer applies here: Neither
    is better or worse universally, which is why both options exist. Due to the obvious
    strengths and weaknesses of these models, the SNMP protocol is designed to use
    both. Polling is used for the periodic gathering of routine information, such
    as checking the usage statistics and general status of a device. Interrupts are
    used in the form of *traps* that a network administrator can set on a managed
    device. These traps cause an SNMP agent to interrupt an NMS when an event of importance
    occurs.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种通信方式更好？通常的答案在这里适用：两者在普遍意义上都不是更好或更差，这就是为什么两种选择都存在。由于这些模型的明显优势和劣势，SNMP协议被设计为同时使用两者。轮询用于定期收集常规信息，例如检查设备的利用率统计和一般状态。中断以*陷阱*的形式使用，网络管理员可以在受管理设备上设置这些陷阱。这些陷阱会在发生重要事件时使SNMP代理中断NMS。
- en: Tip
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP uses two basic methods for exchanging management information.
    Routine communication uses a *poll-driven* technique, where the network management
    station (NMS) requests information from managed nodes. An *interrupt-driven* model
    is also supported. In situations where a managed device needs to tell an NMS about
    an occurrence immediately, it can send a *trap* message without waiting for a
    request from the NMS.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP使用两种基本方法来交换管理信息。常规通信使用*轮询驱动*技术，其中网络管理站（NMS）从受管理节点请求信息。也支持*中断驱动*模型。在需要立即通知NMS发生情况的情况下，受管理设备可以发送一个*陷阱*消息，而不必等待NMS的请求。'
- en: 'The focus of most of our look at SNMP in this chapter will concentrate on SNMP
    protocol operations: what messages are used, how they are structured, and how
    they are exchanged. In examining these messages, we will see the two main ways
    that information exchanges occur in SNMP—by polling and by interrupt—and also
    discover how the SNMP protocol works with MIB objects.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将重点关注SNMP协议操作：使用哪些消息，它们的结构如何，以及它们是如何交换的。在检查这些消息时，我们将看到SNMP中信息交换的两种主要方式——通过轮询和通过中断——并了解SNMP协议如何与MIB对象协同工作。
- en: SNMP Protocol Operations
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP协议操作
- en: The actual communication of information in the SNMP protocol is performed in
    a manner similar to most other protocols, through the exchange of SNMP messages.
    These messages are sometimes called *protocol data units* or *PDUs*. This is a
    term you may have heard used in other protocols, and it is part of the formal
    definition of data encapsulation in the OSI Reference Model, as explained in [Chapter 5](ch05.html
    "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS"). A message is, of
    course, a data unit used by the protocol. SNMP messages all have *-PDU* at the
    ends of their names to identify them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP协议中实际的信息通信是通过类似于大多数其他协议的方式进行的，即通过交换SNMP消息。这些消息有时被称为*协议数据单元*或*PDUs*。你可能在其他协议中听说过这个术语，它是OSI参考模型中数据封装的正式定义的一部分，如[第5章](ch05.html
    "第5章. 一般OSI参考模型问题和概念")中所述。消息当然是由协议使用的数据单元。SNMP消息的名称末尾都有*-PDU*来标识它们。
- en: Some consider *protocol data unit* to be analogous to the military using oblong,
    metallic-headed, manually operated, fastener-acceleration device to refer to a
    hammer. To be fair though, strictly speaking, in SNMP, a PDU and a message are
    not exactly the same. The PDU is the higher-layer data that SNMP encapsulates,
    as described by the OSI model. The SNMP message format is a *wrapper* that encapsulates
    a PDU along with header fields, as I describe in the next chapter on SNMP messaging.
    However, the point of a message is to send a PDU, so the two are close enough,
    and the terms are sometimes used interchangeably.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为*协议数据单元*类似于军事使用长形、金属头、手动操作、加速固定装置来指代锤子。不过，公平地说，严格来说，在SNMP中，PDU和消息并不完全相同。PDU是SNMP封装的更高层数据，如OSI模型所述。SNMP消息格式是一个*包装器*，它封装了一个PDU以及头部字段，正如我在下一章“SNMP消息”中描述的那样。然而，消息的目的就是发送PDU，所以两者足够接近，术语有时可以互换使用。
- en: SNMP PDU Classes
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP PDU类别
- en: SNMPv1 originally defined six PDUs. The number of PDUs was expanded, and some
    changes were made to their names and uses in SNMPv2 and SNMPv3\. The current SNMP
    Framework categorizes the PDUs into different *classes*. These classes describe
    both the function of each message type and the kind of communication they use
    to perform their task (polling versus interrupting).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv1最初定义了六个PDUs。PDUs的数量得到了扩展，在SNMPv2和SNMPv3中对它们的名称和使用进行了某些更改。当前的SNMP框架将PDUs分类到不同的*类别*中。这些类别描述了每种消息类型的功能以及它们执行任务时使用的通信类型（轮询与中断）。
- en: Tip
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP messages consist of a set of fields wrapped around a data
    element called a *protocol data unit* or *PDU*. In some cases, the terms message
    and PDU are used interchangeably, although they are technically not the same.
    SNMP PDUs are arranged into *classes* based on their function.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP消息由一组围绕称为*协议数据单元*或*PDU*的数据元素的字段组成。在某些情况下，术语消息和PDU可以互换使用，尽管技术上它们并不相同。SNMP
    PDUs根据其功能被安排成*类别*。'
- en: '[Table 67-1](ch67s02.html#snmp_pdu_message_classes "Table 67-1. SNMP PDU (Message)
    Classes") lists the main SNMPv2/SNMPv3 PDU classes, describes them, and shows
    which PDUs are in each class in SNMPv2/SNMPv3\. These classes were not used in
    SNMPv1, but for clarity, I also show which messages from SNMPv1 fall into the
    classes conceptually.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 67-1](ch67s02.html#snmp_pdu_message_classes "表 67-1. SNMP PDU (消息) 类别")
    列出了主要的 SNMPv2/SNMPv3 PDU 类别，描述了它们，并显示了在 SNMPv2/SNMPv3 中每个类别包含哪些 PDU。这些类别在 SNMPv1
    中没有使用，但为了清晰起见，我也展示了哪些 SNMPv1 消息在概念上属于这些类别。'
- en: Table 67-1. SNMP PDU (Message) Classes
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 表 67-1. SNMP PDU (消息) 类别
- en: '| SNMPv3 PDU Class | Description | SNMPv1 PDUs | SNMPv2/SNMPv3 PDUs |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| SNMPv3 PDU 类 | 描述 | SNMPv1 PDUs | SNMPv2/SNMPv3 PDUs |'
- en: '| --- | --- | --- | --- |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Read | Messages that read management information from a managed device using
    a polling mechanism. | GetRequest-PDU, GetNextRequest-PDU | GetRequest-PDU, GetNextRequest-PDU,
    GetBulkRequest-PDU |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | 使用轮询机制从受管理设备读取管理信息的消息。 | GetRequest-PDU, GetNextRequest-PDU | GetRequest-PDU,
    GetNextRequest-PDU, GetBulkRequest-PDU |'
- en: '| Write | Messages that change management information on a managed device to
    affect the device''s operation. | SetRequest-PDU | SetRequest-PDU |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 写入 | 改变受管理设备上的管理信息以影响设备操作的消息。 | SetRequest-PDU | SetRequest-PDU |'
- en: '| Response | Messages sent in response to a previous request. | GetResponse-PDU
    | Response-PDU |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 响应 | 对先前请求的响应消息。 | GetResponse-PDU | Response-PDU |'
- en: '| Notification | Messages used by a device to send an interrupt-like notification
    to an SNMP manager. | Trap-PDU | Trapv2-PDU, InformRequest-PDU |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 通知 | 设备用于向 SNMP 管理器发送类似中断的通知的消息。 | Trap-PDU | Trapv2-PDU, InformRequest-PDU
    |'
- en: The GetBulkRequest-PDU and InformRequest-PDU messages are new in SNMPv2/v3\.
    The GetResponse-PDU message was renamed Response-PDU (since it is a response and
    not a message that gets anything), and the new Trapv2-PDU replaces Trap-PDU.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: GetBulkRequest-PDU 和 InformRequest-PDU 消息是 SNMPv2/v3 中的新消息。GetResponse-PDU 消息被重命名为
    Response-PDU（因为它是一个响应，而不是获取任何东西的消息），新的 Trapv2-PDU 替换了 Trap-PDU。
- en: There are three other special classes defined by the current SNMP Framework
    that are of less interest to us because they don't define actively used messages,
    but which I should mention for completeness. The Internal class contains a special
    message called Report-PDU defined for internal SNMP communication. The SNMP standards
    also provide two classes called Confirmed and Unconfirmed, which are used to categorize
    the messages listed in [Table 67-1](ch67s02.html#snmp_pdu_message_classes "Table 67-1. SNMP
    PDU (Message) Classes") based on whether or not they are acknowledged. The Report-PDU,
    Trapv2-PDU, and Response-PDU messages are considered Unconfirmed, and the rest
    are Confirmed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 SNMP 框架定义了三个其他特殊类别，对我们来说不太重要，因为它们没有定义积极使用的消息，但我应该提到以示完整。内部类别包含一个称为 Report-PDU
    的特殊消息，用于内部 SNMP 通信。SNMP 标准还提供了两个类别，称为已确认和未确认，用于根据消息是否被确认来对 [表 67-1](ch67s02.html#snmp_pdu_message_classes
    "表 67-1. SNMP PDU (消息) 类别") 中的消息进行分类。Report-PDU、Trapv2-PDU 和 Response-PDU 消息被认为是未确认的，其余的是已确认的。
- en: Now we will look at how the major message types in the four main classes are
    used. Note that in general terms, all protocol exchanges in SNMP are described
    in terms of one SNMP entity sending messages to another. Most commonly, the entity
    sending requests is an SNMP manager, and the one responding is an SNMP agent,
    except for traps, which are sent by agents. For greater clarity, I try to use
    these more specific terms (*manager* or *agent*) when possible, rather than just
    *entity*.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨四个主要类别中的主要消息类型是如何使用的。请注意，在一般术语中，SNMP 中的所有协议交换都是用一种 SNMP 实体向另一个实体发送消息来描述的。最常见的是，发送请求的实体是
    SNMP 管理器，而响应的是 SNMP 代理，除了陷阱，陷阱是由代理发送的。为了更清晰，我尽量在可能的情况下使用更具体的术语（*管理器* 或 *代理*），而不是仅仅
    *实体*。
- en: Basic Request/Response Information Poll Using GetRequest and (Get)Response Messages
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GetRequest 和 (Get)Response 消息进行基本请求/响应信息轮询
- en: The obvious place to begin our detailed look at SNMP protocol operations is
    with the simplest type of information exchange. This would be a simple *poll*
    operation to read one or more management information variables, used by one SNMP
    entity (typically an SNMP manager) to request or read information from another
    entity (normally an SNMP agent on a managed device). SNMP implements this as a
    simple, two-message request/response protocol exchange, similar to the request/reply
    processes found in so many TCP/IP protocols.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对SNMP协议操作进行详细研究的明显起点是信息交换的最简单类型。这将是一个简单的*轮询*操作，用于读取一个或多个管理信息变量，由一个SNMP实体（通常是SNMP管理器）请求或读取另一个实体（通常是在受管理设备上的SNMP代理）的信息。SNMP通过一个简单、两个消息的请求/响应协议交换来实现这一点，类似于在许多TCP/IP协议中找到的请求/回复过程。
- en: 'This information request process typically begins with the user of an application
    wanting to check the status of a device or look at information about it. As we''ve
    seen, all this information is stored on the device in the form of MIB objects.
    The communication, therefore, takes the form of a request for particular MIB objects
    and a reply from the device containing those objects'' values. In simplified form,
    the steps in the process are as follows (see [Figure 67-1](ch67s02.html#snmp_information_poll_process_the_basic_
    "Figure 67-1. SNMP information poll process The basic SNMP information polling
    process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager
    and a Response-PDU returned by an SNMP agent.")):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '此信息请求过程通常从应用程序的用户想要检查设备的状态或查看有关它的信息开始。正如我们所见，所有这些信息都以MIB对象的形式存储在设备上。因此，通信的形式是请求特定的MIB对象，并从包含这些对象值的设备获得回复。以简化的形式，该过程中的步骤如下（参见[图67-1](ch67s02.html#snmp_information_poll_process_the_basic_
    "图67-1. 基本的SNMP信息轮询过程 基本的SNMP信息轮询过程涉及一个简单的交换，即由SNMP管理器发送的GetRequest-PDU和由SNMP代理返回的Response-PDU。"))):'
- en: '**SNMP Manager Creates GetRequest-PDU** Based on the information required by
    the application and user, the SNMP software on the NMS creates a GetRequest-PDU
    message. It contains the names of the MIB objects whose values the application
    wants to retrieve.'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器创建GetRequest-PDU** 根据应用程序和用户所需的信息，NMS上的SNMP软件创建一个GetRequest-PDU消息。它包含应用程序想要检索的MIB对象名称。'
- en: '**SNMP Manager Sends GetRequest-PDU** The SNMP manager sends the PDU to the
    device that is being polled.'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器发送GetRequest-PDU** SNMP管理器将PDU发送到被轮询的设备。'
- en: '**SNMP Agent Receives and Processes GetRequest-PDU** The SNMP agent receives
    and processes the request. It looks at the list of MIB object names contained
    in the message and checks to see if they are valid (ones the agent actually implements).
    It looks up the value of each variable that was correctly specified.'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理接收并处理GetRequest-PDU** SNMP代理接收并处理请求。它查看消息中包含的MIB对象名称列表，并检查它们是否有效（代理实际实现的那些）。它查找每个正确指定的变量的值。'
- en: '**SNMP Agent Creates Response-PDU** The agent creates a Response-PDU to send
    back to the SNMP manager. This message contains the values of the MIB objects
    requested and/or error codes to indicate any problems with the request, such as
    an invalid object name.'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理创建响应-PDU** 代理创建一个响应-PDU以发送回SNMP管理器。此消息包含请求的MIB对象值以及/或错误代码，以指示请求中可能出现的任何问题，例如无效的对象名称。'
- en: '**SNMP Agent Sends Response-PDU** The agent sends the response back to the
    SNMP manager.'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理发送响应-PDU** 代理将响应发送回SNMP管理器。'
- en: '**SNMP Manager Processes Response-PDU** The manager processes the information
    in the Response-PDU received from the agent.'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器处理响应-PDU** 管理器处理从代理接收到的响应-PDU中的信息。'
- en: '![SNMP information poll process The basic SNMP information polling process
    involves a simple exchange of a GetRequest-PDU sent by an SNMP manager and a Response-PDU
    returned by an SNMP agent.](httpatomoreillycomsourcenostarchimages288233.png.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP信息轮询过程 基本的SNMP信息轮询过程涉及一个简单的交换，即由SNMP管理器发送的GetRequest-PDU和由SNMP代理返回的Response-PDU。](httpatomoreillycomsourcenostarchimages288233.png.jpg)'
- en: Figure 67-1. SNMP information poll process The basic SNMP information polling
    process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager
    and a Response-PDU returned by an SNMP agent.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图67-1. SNMP信息轮询过程 基本的SNMP信息轮询过程涉及一个简单的交换，即由SNMP管理器发送的GetRequest-PDU和由SNMP代理返回的Response-PDU。
- en: Tip
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The most basic type of communication in SNMP is an *information
    poll*, which allows an NMS to read one or more MIB objects from a managed node
    using a simple request/reply message exchange.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP中最基本的通信类型是*信息轮询*，它允许NMS通过简单的请求/回复消息交换从受管理节点读取一个或多个MIB对象。'
- en: The Response-PDU message is called GetResponse-PDU in SNMPv1\. Presumably, this
    name was chosen based on the fact that it was a response to a get operation, to
    make the names GetRequest-PDU and GetResponse-PDU somewhat symmetric. The problem
    is that this name is confusing, for two reasons. First, it sounds to some people
    like the purpose of the PDU is to "get a response." Second, the GetResponse-PDU
    was also defined as the response message for operations other than get operations,
    including the reply message for SetRequest-PDU. Having a GetResponse message be
    sent in reply to a SetRequest message is disconcerting. The new name is more generic
    and avoids these problems.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv1中，响应-PDU消息被称为GetResponse-PDU。据推测，这个名字是基于它是get操作的响应而选择的，以使GetRequest-PDU和GetResponse-PDU的名称在某种程度上对称。问题是这个名字令人困惑，有两个原因。首先，它听起来好像PDU的目的是“获取响应”。其次，GetResponse-PDU也被定义为除get操作之外的操作的响应消息，包括SetRequest-PDU的回复消息。将GetResponse消息发送作为SetRequest消息的回复令人不安。新的名字更通用，避免了这些问题。
- en: Table Traversal Using GetNextRequest and GetBulkRequest Messages
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GetNextRequest和GetBulkRequest消息进行表格遍历
- en: The GetRequest-PDU message is used by applications to request values for regular,
    single variables in an SNMP managed object's MIB. As I mentioned in [Chapter 66](ch66.html
    "Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION
    BASES (MIBS)"), however, the SMI also allows an MIB to contain *tabular data*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: GetRequest-PDU消息由应用程序用于请求SNMP受管理对象的MIB中常规、单个变量的值。然而，正如我在[第66章](ch66.html "第66章。管理信息结构（SMI）和管理信息库（MIBS）")中提到的，SMI还允许MIB包含*表格数据*。
- en: MIB tables are a useful way for a device to store and organize a set of related
    data items. It would be far from ideal to try to structure these items just as
    collections of regular objects. For example, a device may have multiple IP addresses.
    It would be inefficient to define one MIB object called ipAddr1, another called
    ipAddr2, and so on to store IP address information. Instead, an object called
    ipAddrTable is defined in the original SNMPv1 MIB, which specifies a table containing
    one or more entries called ipAddrEntry. Each entry contains the IP address and
    subnet mask for one of the interfaces of the device.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: MIB表格是设备存储和组织一组相关数据项的有用方式。试图将这些项目仅作为常规对象的集合来结构化将远非理想。例如，一个设备可能有多个IP地址。定义一个名为ipAddr1的MIB对象，另一个名为ipAddr2，以此类推来存储IP地址信息将是不高效的。相反，在原始SNMPv1
    MIB中定义了一个名为ipAddrTable的对象，它指定了一个包含一个或多个名为ipAddrEntry条目的表格。每个条目包含设备一个接口的IP地址和子网掩码。
- en: SNMPv1 Table Traversal Using GetNextRequest
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNMPv1使用GetNextRequest进行表格遍历
- en: 'There needs to be a way to let an SNMP manager read the contents of these tables
    from a device. This can be done using the regular GetRequest-PDU message, by specifying
    each entry in the table, one after the other. However, this is somewhat crude,
    and it leaves a problem: the SNMP manager may not know how many entries are in
    the table, and therefore, how many entries it should request.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 需要有一个方法让SNMP管理器从设备中读取这些表格的内容。这可以通过使用常规的GetRequest-PDU消息来完成，通过依次指定表中的每个条目。然而，这种方法有些粗糙，并且留下了一个问题：SNMP管理器可能不知道表中有多少条目，因此也不知道应该请求多少条目。
- en: The problem of *table traversal* was addressed in SNMPv1 through the creation
    of a new message type called GetNextRequest-PDU. You can think of this as a relative
    of the regular GetRequest-PDU. The GetNextRequest-PDU contains the name of a tabular
    variable, as well as a particular entry in the table. The device receiving the
    GetNextRequest-PDU uses this to look up the next value in the table and return
    it in a GetResponse-PDU message.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv1中，通过创建一个名为GetNextRequest-PDU的新消息类型来解决*表格遍历*问题。你可以将其视为常规GetRequest-PDU的一个亲戚。GetNextRequest-PDU包含一个表格变量的名称以及表中的一个特定条目。接收GetNextRequest-PDU的设备使用这个信息来查找表中的下一个值，并在GetResponse-PDU消息中返回它。
- en: 'The actual protocol exchange is about the same as that described in the previous
    section: a request is sent by the SNMP manager, and a reply is returned by the
    SNMP agent. The difference is that instead of the SNMP agent returning the value
    for the variable specified, it returns the value of the *next* variable in the
    table. This is then used as the value for the next request, and so on, until the
    last entry in the table is reached. Once this happens and a GetNextRequest-PDU
    is sent that contains this last entry, the responding device indicates this by
    returning the MIB object that conceptually follows the table in the implementation
    of the MIB. This signals to the SNMP manager that the table has been fully traversed.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的协议交换与上一节中描述的类似：SNMP 管理员发送请求，SNMP 代理返回回复。区别在于，SNMP 代理不是返回指定变量的值，而是返回表中下一个变量的值。然后，这个值用作下一个请求的值，依此类推，直到达到表中的最后一个条目。一旦发生这种情况，并且发送包含此最后一个条目的
    GetNextRequest-PDU，响应设备通过返回 MIB 对象来指示这一点，该对象在 MIB 的实现中概念上位于表格之后。这向 SNMP 管理员表明表格已被完全遍历。
- en: Tip
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The SNMP GetNextRequest-PDU message allows an NMS to request
    a series of consecutive variables in an MIB. This is most commonly used to allow
    tabular data to be more easily retrieved, without requiring that each variable
    in the table be individually specified.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP GetNextRequest-PDU 消息允许 NMS 请求 MIB 中的连续变量序列。这通常用于允许更轻松地检索表格数据，而无需为表中的每个变量单独指定。'
- en: SNMPv2/v3 Table Traversal Using GetBulkRequest
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GetBulkRequest 进行 SNMPv2/v3 表遍历
- en: The GetNextRequest-PDU message is functional, but while it is more elegant than
    using regular GetRequest-PDU messages, it is not any more efficient—each entry
    in the table must still be requested one at a time. This means that retrieving
    the information in a table takes a long time and also results in a great deal
    of traffic being generated, due to the number of requests and replies that must
    be sent.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: GetNextRequest-PDU 消息是功能性的，但尽管它比使用常规 GetRequest-PDU 消息更优雅，但它并不更高效——表中的每个条目仍然必须逐个请求。这意味着检索表中的信息需要很长时间，并且由于必须发送的大量请求和回复，还会产生大量流量。
- en: To make table traversal easier and more conservative in its use of network resources,
    SNMPv2 introduced a new message type called GetBulkRequest-PDU. You can probably
    surmise the idea here from the name. Instead of specifying a particular MIB object
    to get or to get next, a GetBulkRequest-PDU allows an SNMP manager to send a single
    request that results in a number of entries in a table being returned in a Response-PDU
    message.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使表格遍历更容易，并更保守地使用网络资源，SNMPv2 引入了一种新的消息类型，称为 GetBulkRequest-PDU。您可能可以从名称中推测出这个想法。与指定要获取或获取下一个特定
    MIB 对象不同，GetBulkRequest-PDU 允许 SNMP 管理员发送一个请求，该请求在 Response-PDU 消息中返回表中的多个条目。
- en: 'The GetBulkRequest-PDU is designed to allow both regular variables and tables
    to be retrieved in a single request. The PDU includes a list of objects, just
    as in a GetRequest-PDU or GetNextRequest-PDU. The list is organized so that regular
    objects appear first and table objects come afterwards. Two special parameters
    are included in the request:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: GetBulkRequest-PDU 被设计为允许在单个请求中检索常规变量和表格。PDU 包含一个对象列表，就像在 GetRequest-PDU 或 GetNextRequest-PDU
    中一样。列表按顺序组织，常规对象首先出现，表格对象随后。请求中包含两个特殊参数：
- en: '**Non Repeaters** Specifies the number of nonrepeating, regular objects to
    be retrieved. This is the number of regular objects at the start of the object
    list.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**非重复器** 指定要检索的非重复常规对象的数量。这是对象列表开头的常规对象数量。'
- en: '**Max Repetitions** Specifies the number of iterations, or entries, to read
    for the remaining tabular objects.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大重复次数** 指定要读取剩余表格对象的迭代次数或条目数。'
- en: For example, suppose an SNMP manager wanted to request four regular variables
    and three entries from a table. The GetNextRequest-PDU would contain five MIB
    object specifications, with the table last. The Non Repeaters field would be set
    to 4, and the Max Repetitions field set to 3.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个 SNMP 管理员想要请求四个常规变量和表中的三个条目。GetNextRequest-PDU 将包含五个 MIB 对象规范，其中表在最后。非重复器字段将被设置为
    4，最大重复次数字段设置为 3。
- en: Tip
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To improve the efficiency of table traversal, SNMPv2 introduced
    the GetBulkRequest-PDU message, which allows an NMS to request a sequence of MIB
    objects from a table using a single request to a managed node.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了提高表遍历的效率，SNMPv2引入了GetBulkRequest-PDU消息，允许NMS通过向受管理节点发送单个请求来从表中请求一系列MIB对象。'
- en: The original method of traversing tables using GetRequest-PDU and GetNextRequest-PDU
    from SNMPv1 was retained in SNMPv2 and SNMPv3 when they were developed. However,
    the introduction of the more efficient GetBulkRequest-PDU means that GetNextRequest-PDU
    is not as important as it was in SNMPv1\. Bear in mind, however, that using GetBulkRequest-PDU
    does require that the requesting entity know how many entries to ask for. So,
    some trial and error, or multiple requests, may be required to get a whole table
    if the number of entries is not known.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发SNMPv2和SNMPv3时，保留了使用GetRequest-PDU和GetNextRequest-PDU从SNMPv1遍历表的原始方法。然而，引入了更高效的GetBulkRequest-PDU意味着GetNextRequest-PDU的重要性不如SNMPv1中那么重要。然而，请注意，使用GetBulkRequest-PDU确实要求请求实体知道要请求多少条记录。因此，如果不知道条目数量，可能需要进行一些尝试和错误，或者多次请求才能获取整个表。
- en: Object Modification Using SetRequest Messages
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SetRequest消息进行对象修改
- en: 'The GetRequest-PDU, GetNextRequest-PDU, and GetBulkRequest-PDU messages are
    the three members of the SNMP Read class of PDUs—they are used to let an SNMP
    manager read MIB objects from an SNMP agent. The opposite function is represented
    by the SNMP Write class, which contains a single member: the SNMP SetRequest-PDU
    message.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'GetRequest-PDU、GetNextRequest-PDU和GetBulkRequest-PDU消息是SNMP读类PDUs的三个成员—they
    are used to let an SNMP manager read MIB objects from an SNMP agent. The opposite
    function is represented by the SNMP Write class, which contains a single member:
    the SNMP SetRequest-PDU message.'
- en: The use of this PDU is fairly obvious; where one of the three Get PDUs specifies
    a variable whose value is to be retrieved, the SetRequest-PDU message contains
    a specification for variables whose values are to be modified by the network administrator.
    Remember that SNMP does not include specific commands to let a network administrator
    control a managed device. This is the *control* method, which works by setting
    variables that affect the operation of the managed device.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此PDU的方法相当明显；其中三个Get PDUs之一指定了一个要检索其值的变量，而SetRequest-PDU消息包含网络管理员要修改其值的变量的规范。请记住，SNMP不包含允许网络管理员控制受管理设备的特定命令。这是*控制*方法，通过设置影响受管理设备操作变量的方式来实现。
- en: 'The set process is the complement of the get process, using the same basic
    idea, but a reversal in how the object values travel and what is done with them.
    The process follows these steps (see [Figure 67-2](ch67s02.html#snmp_object_modification_process_the_com
    "Figure 67-2. SNMP object modification process The communication process for setting
    a MIB object value is very similar to that used for reading one. The main difference
    is that the object values are sent from the SNMP manager to the SNMP agent, carried
    in the SetRequest-PDU message.")):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 集合过程是获取过程的补集，使用相同的基本思想，但在对象值如何传输以及如何处理它们方面进行了反转。该过程遵循以下步骤（参见[图67-2](ch67s02.html#snmp_object_modification_process_the_com
    "图67-2. SNMP对象修改过程 设置MIB对象值的通信过程与读取一个类似。主要区别在于对象值是从SNMP管理器发送到SNMP代理，包含在SetRequest-PDU消息中"))：
- en: '**SNMP Manager Creates SetRequest-PDU** Based on the information changes specified
    by the user through the SNMP application, the SNMP software on the NMS creates
    a SetRequest-PDU message. It contains a set of MIB object names and the values
    to which they are to be set.'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器创建SetRequest-PDU** 根据用户通过SNMP应用程序指定的信息更改，NMS上的SNMP软件创建一个SetRequest-PDU消息。它包含一组MIB对象名称以及它们要设置的值。'
- en: '**SNMP Manager Sends SetRequest-PDU** The SNMP manager sends the PDU to the
    device being controlled.'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器发送SetRequest-PDU** SNMP管理器将PDU发送到被控制的设备。'
- en: '**SNMP Agent Receives and Processes SetRequest-PDU** The SNMP agent receives
    and processes the set request. It examines each object in the request, along with
    the value to which the object is to be set, and determines if the request should
    or should not be honored.'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理接收并处理SetRequest-PDU** SNMP代理接收并处理设置请求。它检查请求中的每个对象以及对象要设置到的值，并确定是否应该或不应执行该请求。'
- en: '**SNMP Agent Makes Changes and Creates Response-PDU** Assuming that the information
    in the request was correct (and any security provisions have been satisfied),
    the SNMP agent makes changes to its internal variables. The agent creates a Response-PDU
    to send back to the SNMP manager, which either indicates that the request succeeded
    or contains error codes to indicate any problems with the request found during
    processing.'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理进行更改并创建响应-PDU** 假设请求中的信息是正确的（并且任何安全措施都已满足），SNMP代理会更改其内部变量。代理创建一个响应-PDU发送回SNMP管理器，要么指示请求成功，要么包含错误代码以指示在处理过程中发现的任何请求问题。'
- en: '**SNMP Agent Sends Response-PDU** The agent sends the response back to the
    SNMP manager.'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP代理发送响应-PDU** 代理将响应发送回SNMP管理器。'
- en: '**SNMP Manager Processes Response-PDU** The manager processes the information
    in the Response-PDU to see the results of the set.'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SNMP管理器处理响应-PDU** 管理器处理响应-PDU中的信息，以查看设置的成果。'
- en: '![SNMP object modification process The communication process for setting a
    MIB object value is very similar to that used for reading one. The main difference
    is that the object values are sent from the SNMP manager to the SNMP agent, carried
    in the SetRequest-PDU message.](httpatomoreillycomsourcenostarchimages288235.png.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP对象修改过程 设置MIB对象值的通信过程与读取一个非常相似。主要区别在于对象值是从SNMP管理器发送到SNMP代理，通过SetRequest-PDU消息携带。](httpatomoreillycomsourcenostarchimages288235.png.jpg)'
- en: Figure 67-2. SNMP object modification process The communication process for
    setting a MIB object value is very similar to that used for reading one. The main
    difference is that the object values are sent from the SNMP manager to the SNMP
    agent, carried in the SetRequest-PDU message.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图67-2. SNMP对象修改过程 设置MIB对象值的通信过程与读取一个非常相似。主要区别在于对象值是从SNMP管理器发送到SNMP代理，通过SetRequest-PDU消息携带。
- en: 'Obviously, telling a device to change a variable''s value is a more significant
    request than just asking the device to read the value. For this reason, the managed
    device must very carefully analyze and verify the information in the request to
    ensure that the request is valid. The checks performed include the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，要求设备更改变量的值比仅仅要求设备读取值是一个更重要的请求。因此，受管理的设备必须非常仔细地分析和验证请求中的信息，以确保请求有效。执行的检查包括以下内容：
- en: Verifying the names of the objects to be changed
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证要更改的对象的名称
- en: Verifying that the objects are allowed to be modified (based on their Access
    or Max-Access object characteristic, as described in [Chapter 66](ch66.html "Chapter 66. TCP/IP
    STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)"))
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证对象是否允许修改（基于它们的访问或最大访问对象特性，如第66章所述[第66章。管理信息（SMI）和MIB（MIB）的TCP/IP结构](ch66.html
    "第66章。管理信息（SMI）和MIB（MIB）的TCP/IP结构"")）
- en: Checking the value included in the request to ensure that its type and size
    are valid for the object to be changed
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查请求中包含的值，以确保其类型和大小对于要更改的对象是有效的
- en: This is also a place where general protocol security issues become more important,
    as I'll discuss near the end of this chapter.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一般协议安全问题变得更加重要的地方，我将在本章末尾讨论。
- en: Tip
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP NMSs control the operation of managed devices by changing
    MIB objects on those devices. This is done using the SetRequest-PDU message, which
    specifies the objects to be modified and their values.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP NMS通过更改设备上的MIB对象来控制受管理设备的操作。这是通过使用SetRequest-PDU消息完成的，该消息指定要修改的对象及其值。'
- en: Information Notification Using Trap and InformRequest Messages
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用陷阱和InformRequest消息进行信息通知
- en: 'Earlier in this chapter, I introduced the two basic methods of communicating
    information between SNMP devices: using polls or interrupts. All of the message
    types and exchanges we have examined thus far in this section have been poll-driven.
    They consist of an SNMP manager making a specific request that results in action
    being taken, and a response being generated by an SNMP agent.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我介绍了在SNMP设备之间传递信息的基本两种方法：使用轮询或中断。本节迄今为止我们检查的所有消息类型和交换都是轮询驱动的。它们包括SNMP管理器发出特定请求，导致采取行动，并由SNMP代理生成响应。
- en: Polling is ideal for the exchange of routine information that needs to be gathered
    on a regular basis. For example, the regular get requests could be used to verify
    the settings on a device, examine error counts over a period of time, or check
    its uptime or use statistics. And, obviously, polling is the only real method
    for performing a set operation, where data is changed.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 投票对于需要定期收集的常规信息交换是理想的。例如，定期的获取请求可以用来验证设备的设置，检查一段时间内的错误计数，或检查其运行时间或使用统计信息。显然，投票是执行设置操作的唯一真正方法，其中数据被更改。
- en: 'But polling is not well suited for important information that needs to be communicated
    quickly. The reason is that poll-driven communication is always initiated by the
    recipient of the information: the SNMP manager. If something significant occurs
    on a managed device that the manager wasn''t expecting, the manager won''t find
    out about it unless it specifically asks to see the variable that has changed.
    This means that important variables would need to be checked all the time by the
    SNMP manager, which is highly efficient.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于需要快速传达的重要信息，投票并不适用。原因是，由投票驱动的通信总是由信息的接收者：SNMP 管理员来发起的。如果管理设备上发生了管理员没有预料到的重要事件，除非管理员特意请求查看已更改的变量，否则管理员不会得知这一情况。这意味着重要的变量需要由
    SNMP 管理员持续检查，这非常高效。
- en: In the real world, using polling to implement situations where critical information
    needs to be sent would be like having the emergency response service in your town
    call everyone every hour to find out if they needed an ambulance or fire truck.
    Similarly, in SNMP, a mechanism was needed to let an SNMP agent initiate the communication
    of information. This capability was originally made part of the SNMPv1 protocol
    through the inclusion of the Trap-PDU message type.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，使用投票来实现需要发送关键信息的场景，就像是你所在城镇的紧急响应服务每小时给每个人打电话，以了解他们是否需要救护车或消防车。同样，在 SNMP
    中，需要一个机制让 SNMP 代理启动信息的通信。这种能力最初是通过包含 Trap-PDU 消息类型成为 SNMPv1 协议的一部分。
- en: In computer science, a *trap* is simply a set of conditions that a device monitors
    continuously. If the appropriate conditions occur, the trap is *triggered* and
    causes some sort of action to be taken. In SNMP, traps are programmed into SNMP
    agents, and when they are triggered, an SNMP Trap-PDU message is sent to an SNMP
    manager to inform it of the occurrence. Examples of traps in the SNMPv1 specification
    include ones that trigger in the event of a communication link failure, restart
    of the device, or an authentication problem.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*陷阱* 简单来说就是设备持续监控的一组条件。如果发生适当的条件，陷阱就会被*触发*，导致采取某种行动。在 SNMP 中，陷阱被编程到
    SNMP 代理中，当它们被触发时，会向 SNMP 管理员发送 SNMP 陷阱-PDU 消息，通知其事件的发生。SNMPv1 规范中陷阱的例子包括在通信链路故障、设备重启或认证问题发生时触发的陷阱。
- en: Use of SNMP Trap and Trapv2 Messages
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SNMP 陷阱和 Trapv2 消息
- en: The communication in the case of a trap is trivial. The SNMP agent sends the
    trap, and the SNMP manager is thereby considered informed of what happened. That's
    pretty much it. These are Unconfirmed messages, and no reply is made back to the
    SNMP agent. The triggering of the trap may lead the network administrator to take
    follow-up action at the device that sent the trap.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在陷阱的情况下，通信非常简单。SNMP 代理发送陷阱，因此认为 SNMP 管理员已经了解发生了什么。这就是全部。这些是未确认的消息，不会向 SNMP 代理发送回复。陷阱的触发可能会使网络管理员采取对发送陷阱的设备进行后续行动。
- en: The designer of a particular MIB must determine which traps to create for a
    particular group of objects. The implementation must specify the conditions under
    which the traps will trigger and also the destination to which the Trap-PDU message
    will be sent when this occurs. In SNMPv2, the trap notification message was retained
    in the form of the Trapv2-PDU message.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 某个 MIB 的设计者必须确定为特定对象组创建哪些陷阱。实现必须指定触发陷阱的条件，以及当这种情况发生时，将发送 Trap-PDU 消息的目的地。在 SNMPv2
    中，陷阱通知消息以 Trapv2-PDU 消息的形式保留。
- en: Use of the SNMPv2 InformRequest Message
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SNMPv2 InformRequest 消息
- en: 'SNMPv2 also incorporates a second notification message type: the InformRequest-PDU
    message. This type of message is not the same as a trap, but it is related to
    traps for two reasons: Both message types are used to communicate information
    without the recipient initiating the process, and the two messages are sometimes
    used in conjunction.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv2还包含第二种通知消息类型：InformRequest-PDU消息。这种类型的消息与陷阱不同，但它与陷阱有两个相关的原因：这两种消息类型都用于在不由接收方启动过程的情况下通信信息，并且这两种消息有时会一起使用。
- en: The purpose of the InformRequest-PDU is actually to facilitate the communication
    of information between NMSs. The SNMP manager on one NMS can choose to inform
    another of some piece of information by sending an InformRequest-PDU to that other
    SNMP manager. The receiving manager then replies back with a Response-PDU to the
    one that sent the InformRequest-PDU, confirming receipt of the inform message.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: InformRequest-PDU的目的实际上是为了促进NMS之间的信息交流。一个NMS上的SNMP管理器可以选择通过向另一个SNMP管理器发送InformRequest-PDU来通知它一些信息。接收的管理器随后会向发送InformRequest-PDU的管理器回复一个Response-PDU，确认已收到通知信息。
- en: A common way that this message is used is to spread the news when a trap occurs.
    Suppose a device experiences a power failure, which results in a Trapv2-PDU being
    sent to NMS 1\. The network administrator may want to set up NMS 1 so that receipt
    of particular traps causes the information in the trap to be forwarded to another
    NMS. The InformRequest-PDU would be used to carry that information from NMS 1
    to, say, NMS 2.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这种消息通常被用来在发生陷阱时传播消息。假设一个设备发生电源故障，导致一个Trapv2-PDU被发送到NMS 1。网络管理员可能希望设置NMS 1，使得接收到特定的陷阱时，陷阱中的信息会被转发到另一个NMS。InformRequest-PDU将被用来将信息从NMS
    1传输到，比如说，NMS 2。
- en: Tip
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP managed devices can inform an NMS of an important occurrence
    by sending it a Trap-PDU or Trapv2-PDU message. Network administrators determine
    the circumstances under which one of these messages should be transmitted. SNMPv2
    adds to this capability the InformRequest-PDU message, which can be used to propagate
    information about an event between management stations.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP管理的设备可以通过发送Trap-PDU或Trapv2-PDU消息来通知NMS一个重要事件。网络管理员确定在什么情况下应该发送这些消息之一。SNMPv2增加了InformRequest-PDU消息的这种能力，它可以用来在管理站之间传播关于事件的信息。'
- en: SNMP Protocol Security Issues and Methods
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP协议的安全问题和解决方法
- en: In my description of the various SNMP versions in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"), it's possible that I may have
    been a bit harsh on those who worked on SNMP during the 1990s. The proliferation
    of many SNMP version 2 variants really was unfortunate, and not something we often
    see in the world of TCP/IP. However, now that we've seen the sort of work that
    SNMP does, the desire for security in the protocol would seem to be clear. Given
    that, and given the very low level of security in the initial SNMPv1 protocol,
    it's understandable to some extent why a conflict over security issues arose.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对[第65章](ch65.html "第65章。TCP/IP互联网标准管理框架概述")中各种SNMP版本的描述中，我可能对那些在1990年代从事SNMP工作的人有些苛刻。许多SNMP版本2变体的泛滥确实是不幸的，这在TCP/IP的世界中并不常见。然而，现在我们已经看到了SNMP所做的工作，对协议中安全性的需求似乎很明确。考虑到这一点，以及初始SNMPv1协议中非常低的安全级别，对安全问题的冲突在一定程度上是可以理解的。
- en: The need for security in SNMP is obvious because the MIB objects being communicated
    contain critical information about network devices. We don't want just anyone
    snooping into our network to find out our IP addresses, how long our machines
    have been running, whether our links are down, or pretty much anything else. When
    it comes to object write operations using a SetRequest-PDU, the concerns are magnified
    even more, because we definitely don't want strangers being able to control or
    interfere with our managed devices by issuing bogus commands to change MIB objects
    that control device operation!
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMP中需要安全性的原因很明显，因为正在通信的MIB对象包含有关网络设备的临界信息。我们不希望任何人都能窥探我们的网络，以找出我们的IP地址、我们的机器运行了多长时间、我们的链路是否已断开，或者几乎所有其他信息。当涉及到使用SetRequest-PDU进行的对象写操作时，担忧会更大，因为我们绝对不希望陌生人能够通过发出虚假命令来控制或干扰我们的管理设备，以更改控制设备操作的MIB对象！
- en: Problems with SNMPv1 Security
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv1安全问题的困扰
- en: Unfortunately, the security incorporated into SNMPv1 was extremely limited.
    It really took the form of only one policy and one simple technology.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，SNMPv1中集成的安全性极为有限。它实际上只是一种政策和一种简单技术的形式。
- en: SNMP was created with the mindset that the MIB objects used in the protocol
    would be relatively *weak*. This means that the objects are designed so that any
    problems in working with them result in minimal damage. The policy of the designers
    of SNMP was that MIB objects that are normally read should not contain critical
    information, and objects that are written should not control critical functions.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP的创建是基于这样的观念，即协议中使用的MIB对象将会相对 *脆弱*。这意味着这些对象被设计成，在使用过程中出现任何问题只会造成最小损害。SNMP设计者的政策是，通常应该读取的MIB对象不应包含关键信息，而应该写入的对象不应控制关键功能。
- en: So, a read-only MIB object containing a description of a machine is fine, but
    one containing the administrative password is not. Similarly, a read-write MIB
    object that controls when the computer next reboots is acceptable, but one that
    tells the object to reformat its hard disk is definitely not!
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个只读的MIB对象，其中包含机器的描述，是可以的，但包含管理密码的就不是。同样，一个可读写MIB对象，控制计算机何时重新启动是可以接受的，但告诉对象重新格式化其硬盘的肯定不行！
- en: All the devices in an SNMP network managed by a particular set of NMSs are considered
    to be in a *community*. Each SNMPv1 message sent between members of the community
    is identified by a *community string* that appears in a field in the message header.
    This string is like a simple password. Any messages received with the wrong string
    will be rejected by the recipient.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 由一组特定的NMS管理的SNMP网络中的所有设备都被认为是处于一个 *社区* 中。社区成员之间发送的每个SNMPv1消息都通过消息头中的一个 *社区字符串*
    来标识。这个字符串就像一个简单的密码。任何收到错误字符串的消息都将被接收者拒绝。
- en: These security features are better than nothing, but not much. The use of weak
    objects is comparable to a policy that says not to leave your car in front of
    the convenience store with the doors unlocked and the key in the ignition—it is
    basically saying, "Don't ask for trouble." This is wise, but it's not a complete
    security solution.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安全特性总比没有好，但也不多。使用脆弱对象相当于一种政策，即不要将未锁门的汽车停在便利店前，钥匙留在点火开关上——这基本上是在说，“不要惹麻烦。”这是明智的，但不是完整的解决方案。
- en: The community strings protect against obvious tampering in the form of unauthorized
    messages. However, the strings are sent in plain text, and they can easily be
    discovered and then used to compromise the community. So, this is like locking
    your doors when parking your car—it protects against the casual thief but not
    a pro.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 社区字符串可以防止明显的篡改，如未经授权的消息。然而，这些字符串以明文形式发送，很容易被发现并被用来破坏社区。因此，这就像停车时锁上车门——它可以防止偶然的窃贼，但不能防止专业人士。
- en: Of course, for some people, not leaving their car running and locking the doors
    when they park provide enough security, and SNMPv1's security was also sufficient
    for some users of SNMP. But in newer, larger internetworks, especially ones spanning
    large distances or using public carriers, SNMPv1 wasn't up to the task. This is
    why all that fun stuff occurred with SNMPv2.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于一些人来说，停车时不开车，锁上车门就足够提供安全保障，SNMPv1的安全对于一些SNMP用户来说也足够了。但在新的、更大的互联网中，尤其是在跨越较大距离或使用公共运营商的情况下，SNMPv1无法胜任这项任务。这就是为什么SNMPv2出现了那么多有趣的事情。
- en: SNMPv2/v3 Security Methods
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv2/v3安全方法
- en: 'During the evolution of SNMPv2 variants, and eventually the creation of SNMPv3,
    several new security models were created to improve SNMPv1''s security:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv2变体的演变过程中，最终创建了SNMPv3，在此期间，为了提高SNMPv1的安全性，创建了几个新的安全模型：
- en: '**Party-Based Security Model** Party-based security was the model for the original
    SNMPv2 standard, now called *SNMPv2p*. A logical entity called a *party* is defined
    for communication that specifies a particular authentication protocol and a privacy
    (encryption) protocol. The information is used to verify that a particular request
    is authentic, and to ensure that the sender and receiver agree on how to encrypt
    and decrypt data.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于党的安全模型** 基于党的安全是原始SNMPv2标准的模型，现在称为 *SNMPv2p*。定义了一个名为 *party* 的逻辑实体，用于指定特定的认证协议和隐私（加密）协议的通信。这些信息用于验证特定请求的真实性，并确保发送者和接收者就如何加密和解密数据达成一致。'
- en: '**User-Based Security Model (USM)** USM was developed in the SNMPv2u variant
    and used in SNMPv2* (SNMPv2 asterisk). It eventually was adopted in SNMPv3\. The
    idea here is to move away from tying security to the machines and instead use
    more traditional security based on access rights of a user of a machine. A variety
    of authentication and encryption protocols can be used to ensure access rights
    are respected and to protect message privacy. The method relies on timestamps,
    clock synchronization, and other techniques to protect against certain types of
    attacks.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于用户的访问控制模型 (USM)** USM 是在 SNMPv2u 变体中开发的，并在 SNMPv2* (SNMPv2 星号) 中使用。它最终被纳入
    SNMPv3。这里的想法是摆脱将安全性与机器绑定在一起，而是使用更传统的基于机器用户访问权限的安全机制。可以使用各种身份验证和加密协议来确保尊重访问权限并保护消息隐私。该方法依赖于时间戳、时钟同步和其他技术来防止某些类型的攻击。'
- en: '**View-Based Access Control Model (VACM)** VACM is part of SNMPv3, and it defines
    a method where more fine control can be placed on access to objects on a device.
    A *view* specifies a particular set of MIB objects that can be accessed by a particular
    group in a particular context. By controlling these views, an administrator can
    manage what information is accessed by whom.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于视图的访问控制模型 (VACM)** VACM 是 SNMPv3 的一部分，它定义了一种方法，可以在设备上的对象访问上实现更精细的控制。一个
    *视图* 指定了一组特定的 MIB 对象，这些对象可以在特定上下文中由特定组访问。通过控制这些视图，管理员可以管理谁可以访问哪些信息。'
- en: Party-based security pretty much died with SNMPv2p. USM and VACM are part of
    SNMPv3 and provide enhanced security for those who need it. Again, it's interesting
    to note how many networks continue to use SNMPv1, security warts and all.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 基于实体的安全机制在 SNMPv2p 中几乎已经消失。USM 和 VACM 是 SNMPv3 的一部分，为需要它们的人提供了增强的安全性。再次值得注意的是，有多少网络继续使用
    SNMPv1，无论其安全问题如何。
- en: SNMPv3 took another important security-related step in redefining the SNMP architecture
    to seamlessly support multiple security models. This enables different implementations
    to choose the security model that is best for them. USM is the default model in
    SNMPv3.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv3 在重新定义 SNMP 架构以无缝支持多个安全模型方面又迈出了另一个重要的安全相关步骤。这使得不同的实现可以选择最适合它们的安全模型。USM
    是 SNMPv3 的默认模型。
- en: Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 68 章。SNMP 协议消息和消息格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: As we saw extensively in the previous chapter, the communication of management
    information is accomplished through the exchange of Simple Network Management
    Protocol (SNMP) messages that contain *protocol data units (PDUs)*. Like the messages
    of most TCP/IP protocols, these PDUs are designed to use a particular field format,
    and are created, addressed, and transported according to specific protocol rules.
    SNMP messages include fields that control the operation of the protocol, and they
    carry a payload of management information in the form of management information
    base (MIB) objects.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中广泛看到的那样，管理信息的通信是通过交换包含 *协议数据单元 (PDUs)* 的简单网络管理协议 (SNMP) 消息来完成的。像大多数
    TCP/IP 协议的消息一样，这些 PDU 被设计为使用特定的字段格式，并按照特定的协议规则创建、寻址和传输。SNMP 消息包括控制协议操作的字段，并以管理信息库
    (MIB) 对象的形式携带管理信息负载。
- en: In this chapter, I describe the details of how messaging is accomplished in
    the SNMP protocol. I begin with a general discussion of issues related to message
    generation, addressing, and transport, and a description of how retransmission
    of messages is handled when necessary. I discuss the way fields are defined in
    SNMP messages and describe their general format, explaining the difference between
    the overall message and the PDU it contains. I then examine the message format
    used in all of the important SNMP versions, showing the structure of each message
    type and the fields used.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了在 SNMP 协议中如何实现消息的细节。我首先从与消息生成、寻址和传输相关的一般问题开始讨论，并描述了在必要时如何处理消息的重传。我讨论了在
    SNMP 消息中定义字段的方式，并描述了它们的通用格式，解释了整体消息与其包含的 PDU 之间的区别。然后，我检查了所有重要 SNMP 版本中使用的消息格式，展示了每种消息类型的结构以及使用的字段。
- en: SNMP Protocol Message Generation
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP 协议消息生成
- en: Message generation in SNMP is a bit different than the typical TCP/IP client/server
    model used for most other protocols. There aren't really any formal clients and
    servers in SNMP, since management information can be obtained from any device;
    it is distributed. Most of the message exchanges use a matched pair of request
    and reply messages. The network management station (NMS) usually *acts* as the
    client in these exchanges, sending a particular get or set request to an SNMP
    agent, which plays the role of server for the information it contains. However,
    SNMP agents aren't usually considered servers in the conventional sense.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 中的消息生成与大多数其他协议使用的典型 TCP/IP 客户端/服务器模型略有不同。在 SNMP 中实际上并没有真正的客户端和服务器，因为管理信息可以从任何设备获取；它是分布式的。大多数的消息交换使用一对匹配的请求和回复消息。网络管理系统（NMS）通常在这些交换中充当客户端，向
    SNMP 代理发送特定的获取或设置请求，而 SNMP 代理则扮演包含信息的服务器角色。然而，SNMP 代理通常不被视为传统意义上的服务器。
- en: SNMP traps deviate from the normal request/reply model of message generation
    entirely. When a trap is triggered, an SNMP agent sends a trap message to an NMS
    on its own, not in reaction to receiving a request. Since trap messages are unconfirmed,
    there is no reply. Note, however, that the SNMP versions 2 and 3 (SNMPv2 and SNMPv3)
    InformRequest-PDU message (discussed later in this chapter) is confirmed, and
    a response message is thus sent back to the NMS that generates it.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 陷阱与消息生成的正常请求/回复模型完全不同。当陷阱被触发时，SNMP 代理会主动向其上的 NMS 发送陷阱消息，而不是作为对请求的响应。由于陷阱消息是不确认的，因此没有回复。然而，请注意，SNMP
    版本 2 和 3（SNMPv2 和 SNMPv3）的 InformRequest-PDU 消息（将在本章后面讨论）是确认的，因此会向生成它的 NMS 发送响应消息。
- en: SNMP Transport Mappings
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP 传输映射
- en: Once a message has been generated, it is sent using the protocols at the levels
    below the application layer where SNMP resides. As you saw in the overview of
    the SNMP protocol in the previous chapter, the current SNMP standard set separates
    the description of protocol operations and PDUs from the methods used to actually
    send them.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成消息，它就会使用位于应用层之下的协议层进行发送。正如你在上一章中关于 SNMP 协议概述中看到的，当前的 SNMP 标准集将协议操作和 PDUs
    的描述与实际发送它们的方法分开。
- en: Starting with version 2, SNMP has defined several *transport mappings* that
    describe how SNMP PDUs can be sent over a variety of internetworking protocol
    suites, including TCP/IP, OSI, IPX/SPX (Novell), and AppleTalk. Many of the specific
    details of SNMP messaging depend on the transport mapping that is used in a particular
    implementation. SNMP is primarily used on TCP/IP internetworks, and TCP/IP is
    where our interest lies here, so the rest of this discussion will deal with transport
    issues when SNMP is used over the Internet Protocol (IP).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2 开始，SNMP 定义了几个 *传输映射*，这些映射描述了 SNMP PDUs 如何通过各种互联网协议套件发送，包括 TCP/IP、OSI、IPX/SPX（Novell）和
    AppleTalk。SNMP 消息的许多具体细节取决于特定实现中使用的传输映射。SNMP 主要用于 TCP/IP 互联网，因此我们在这里的兴趣点在于 TCP/IP，所以接下来的讨论将涉及在互联网协议（IP）上使用
    SNMP 时的传输问题。
- en: The standard IP transport mapping for SNMP calls for it to be carried using
    the User Datagram Protocol (UDP). This decision goes back to the initial implementation
    of SNMPv1 (before there were distinct transport mappings). UDP was likely chosen
    because it is more efficient for the simple request/reply messaging scheme SNMP
    uses. The many Transmission Control Protocol (TCP) features were not considered
    necessary and add overhead that SNMP's designers wanted to avoid. It is possible
    that TCP could be used to carry SNMP, defined as a different transport mapping,
    but I don't believe this is actually done.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 的标准 IP 传输映射要求使用用户数据报协议（UDP）进行传输。这一决定可以追溯到 SNMPv1 的最初实现（在存在明确的传输映射之前）。UDP
    很可能被选择，因为它对于 SNMP 使用的简单请求/回复消息方案来说更有效率。许多传输控制协议（TCP）的特性被认为是不必要的，并增加了 SNMP 设计者想要避免的开销。虽然可以将
    TCP 用于携带 SNMP，定义为不同的传输映射，但我相信这实际上并没有这样做。
- en: Two well-known UDP port numbers are reserved for SNMP. The first is port 161,
    which is the general-purpose SNMP number. All devices that are set up to listen
    for SNMP requests—both agents and managers—listen on port 161\. Each device receives
    any messages sent and replies back to the client, the SNMP entity that issued
    the request, which uses an ephemeral port number to identify the requesting process.
    The second UDP port number is 162, which is reserved for SNMP traps. Having two
    numbers allows regular messages and traps to be kept separate. Normally, only
    NMSs would listen on port 162, since agents are not recipients of traps.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 为SNMP保留了两个著名的UDP端口号。第一个是端口161，这是通用SNMP号码。所有设置为监听SNMP请求的设备——包括代理和管理员——都在端口161上监听。每个设备接收发送的任何消息，并回复给客户端，即发出请求的SNMP实体，它使用一个临时端口号来识别请求进程。第二个UDP端口号是162，它为SNMP陷阱保留。有两个号码可以保持常规消息和陷阱的分离。通常，只有NMS会在端口162上监听，因为代理不是陷阱的接收者。
- en: The use of UDP allows SNMP information communication to be streamlined, since
    there is no need to establish a TCP connection, and since message headers are
    shorter and processing time slightly reduced. But the use of UDP introduces a
    couple of issues that SNMP implementations must be concerned with, including message
    size and lost messages.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP可以使SNMP信息通信更加流畅，因为不需要建立TCP连接，并且消息头更短，处理时间略有减少。但是，使用UDP引入了一些SNMP实现必须关注的问题，包括消息大小和丢失的消息。
- en: UDP Message Size Issues
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP消息大小问题
- en: The first issue is that of message length. SNMP PDUs can carry many MIB objects,
    which means they could potentially be rather large. However, UDP is limited in
    the size of message it can carry (where TCP is not). The standards specify that
    SNMP entities must accept messages up to at least 484 bytes in size. They also
    recommend that SNMP implementations be able to accept even larger messages, up
    to 1,472 bytes, which would correspond to the largest size message that can be
    encapsulated in an Ethernet frame (1,500 bytes, allowing 20 bytes for the IP header
    and 8 for the UDP header).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题就是消息长度。SNMP PDUs可以携带许多MIB对象，这意味着它们可能相当大。然而，UDP在可以携带的消息大小上有限制（而TCP则没有）。标准规定SNMP实体必须接受至少484字节大小的消息。它们还建议SNMP实现能够接受更大的消息，最多1,472字节，这相当于可以封装在以太网帧中的最大消息大小（1,500字节，允许IP头20字节和UDP头8字节）。
- en: The use of the GetBulkRequest-PDU message type in SNMPv2 and SNMPv3 requires
    particular care, since it allows a single request to result in many MIB objects
    being sent back in a response. The Max Repetitions parameter must be chosen conservatively
    so the SNMP agent doesn't try to send an enormous message that won't fit.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv2和SNMPv3中使用GetBulkRequest-PDU消息类型需要特别注意，因为它允许单个请求在响应中发送多个MIB对象。必须谨慎选择最大重复次数参数，以防止SNMP代理尝试发送一个过大而无法适应的消息。
- en: Lost Transmission Issues
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢失传输问题
- en: 'The second issue with UDP is the price we pay for its efficiency and simplicity:
    a lack of transport features. UDP doesn''t guarantee data delivery or handle retransmissions,
    which means a request or reply could, in theory, be lost in transit. Only the
    device that initially sends a request can know if there was a problem with transport.
    It sends the request, and if it receives no reply, it knows either the request
    or response got lost. This puts the responsibility for retransmission on the device
    that sends the request message.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的第二个问题是，我们为了其效率和简洁性所付出的代价：缺乏传输功能。UDP不保证数据交付或处理重传，这意味着请求或回复理论上可能在传输过程中丢失。只有最初发送请求的设备才能知道传输过程中是否存在问题。它发送请求，如果没有收到回复，它知道请求或响应已经丢失。这把重传的责任放在了发送请求消息的设备上。
- en: NMSs sending requests to SNMP agents generally use a timer to keep track of
    how much time has elapsed since a request was sent. If the response doesn't arrive
    within a certain time interval, the request is sent again. Because of how SNMP
    works, having a request be received more than once accidentally will normally
    not cause any problems (a property known as *idempotence*). The NMS does need
    to employ an algorithm to ensure that it does not generate too many retransmissions
    and clog the network (especially since congestion might be causing the loss of
    its messages in the first place).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 向SNMP代理发送请求的NMS通常使用计时器来跟踪自发送请求以来经过的时间。如果在一定时间间隔内没有收到响应，请求将再次发送。由于SNMP的工作方式，请求意外地被接收多次通常不会引起任何问题（这是一个称为*幂等性*的特性）。NMS确实需要采用算法来确保它不会生成过多的重传并阻塞网络（尤其是由于拥塞可能首先导致其消息丢失）。
- en: Since traps are unconfirmed, there is no way for the intended recipient of a
    trap PDU to know if did not arrive, nor is there any way for the sender of the
    trap PDU to know. This is just a weakness in the protocol; the overall reliability
    of TCP/IP (and the underlying networks) ensures that these messages are not lost
    very often.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 由于陷阱是不确认的，因此陷阱PDU的预期接收者无法知道它是否没有到达，发送者也无法知道。这只是协议的一个弱点；TCP/IP（及其底层网络）的整体可靠性确保这些消息很少丢失。
- en: Tip
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP is designed with a separately defined set of *protocol
    operations* and *transport mappings*, so it can be carried over many different
    internetworking technologies. The most common of these transport mechanisms is
    TCP/IP, where SNMP makes use of UDP running over IP, for its efficient and simple
    communication. The lack of reliability features in UDP means that requests must
    be tracked by the device sending them and retransmitted if no reply is received.
    The limited size of UDP messages restricts the amount of information that can
    be sent in any SNMP PDU.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP设计时使用了一个单独定义的协议操作集和传输映射集，因此它可以跨越许多不同的互连网络技术。这些传输机制中最常见的是TCP/IP，其中SNMP利用在IP上运行的UDP，以其实效和简单的通信。UDP缺乏可靠性特性意味着请求必须由发送它们的设备跟踪，如果没有收到回复，则必须重新发送。UDP消息大小的限制限制了任何SNMP
    PDU中可以发送的信息量。'
- en: SNMP General Message Format
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP通用消息格式
- en: To structure its messages for transport, SNMP uses a special field format, like
    most protocols. What's interesting about SNMP, however, is that its standards
    do not describe the SNMP message format using a simple list of fields the way
    most TCP/IP standards do. Instead, SNMP messages are defined using the same data
    description language (*Abstract Syntax Notation 1* or *ASN.1*) that is used to
    describe MIB objects.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结构化其消息以便传输，SNMP使用特殊的字段格式，就像大多数协议一样。然而，SNMP有趣的地方在于，其标准并没有像大多数TCP/IP标准那样使用简单的字段列表来描述SNMP消息格式。相反，SNMP消息使用与描述MIB对象相同的描述性数据语言（*抽象语法表示1*或*ASN.1*）来定义。
- en: The reason for this is that SNMP messages implement the various SNMP protocol
    operations with the ultimate goal of allowing MIB objects to be conveyed between
    SNMP entities. These MIB objects become fields within the messages to be sent.
    The MIB objects carried in SNMP messages are defined using ASN.1 as described
    in the Structure of Management Information (SMI) standard. So, it makes sense
    to define SNMP messages and all their fields using the same syntax.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为SNMP消息实现了各种SNMP协议操作，最终目标是允许MIB对象在SNMP实体之间传递。这些MIB对象成为要发送的消息中的字段。SNMP消息中携带的MIB对象使用在结构化管理信息（SMI）标准中描述的ASN.1进行定义。因此，使用相同的语法来定义SNMP消息及其所有字段是有意义的。
- en: Since all SNMP fields are defined like MIB objects, they are like objects in
    that they have certain characteristics. Specifically, each field has a name, and
    its contents are described using one of the standard SMI data types. So, unlike
    normal message formats where each field has just a name and a length, an SNMP
    message format field has a name and a *syntax*, such as Integer, Octet String,
    or IpAddress. The syntax of the field defines its length and how it is formatted
    and used.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有SNMP字段都像MIB对象一样定义，它们具有某些特性。具体来说，每个字段都有一个名称，其内容使用标准SMI数据类型之一进行描述。因此，与每个字段只有名称和长度的常规消息格式不同，SNMP消息格式字段有一个名称和一个*语法*，例如整数、字节字符串或IP地址。字段的语法定义了其长度以及其格式和用法。
- en: Just as regular message formats use integers to represent specific values (for
    example, the numeric Opcode field in the DNS message header, which indicates the
    DNS message type), this can be done in SNMP using an enumerated integer type.
    An example would be the Error Status field, where a range of integer values represents
    different error conditions.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规消息格式使用整数来表示特定值（例如，DNS 消息头中的数值操作码字段，它指示 DNS 消息类型），在 SNMP 中也可以使用枚举整数类型来完成。一个例子是错误状态字段，其中一系列整数值代表不同的错误条件。
- en: The decision to define SNMP messages using ASN.1 allows the message format description
    to be consistent with how the objects in the format are described, which is nice.
    Unfortunately, it means that the field formats are very hard to determine from
    the standards, because they are not described in one place. Instead, the overall
    message format is defined as a set of components, and those components contain
    subcomponents that may be defined elsewhere, and so on. In fact, the full message
    format isn't even defined in one standard; parts are spread across several standards.
    So, you can't look in one place and see the whole message format. Well, I should
    say that you can't if you use the standards, but you can if you look here.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用 ASN.1 定义 SNMP 消息，使得消息格式描述与格式中对象的描述保持一致，这是很不错的。不幸的是，这意味着字段格式很难从标准中确定，因为它们没有在同一个地方描述。相反，整体消息格式被定义为一系列组件，这些组件可能包含在其他地方定义的子组件，依此类推。实际上，完整的消息格式甚至没有在一个标准中定义；部分内容分散在几个标准中。因此，你无法在一个地方看到整个消息格式。好吧，我应该说我如果使用标准的话，你无法做到这一点，但如果你在这里查看，你就可以做到。
- en: To make things easier for you, I have converted these distributed syntax descriptions
    into the same tabular field formats I use throughout the rest of this book. I
    will begin here by describing the general format used for SNMP messages, and in
    the remainder of the chapter, explore the specific formats used in each version
    of SNMP.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更容易理解，我已经将这些分散的语法描述转换成了我在本书其他部分使用的相同表格字段格式。我将从这里开始描述用于 SNMP 消息的一般格式，并在本章的剩余部分探讨每个
    SNMP 版本中使用的特定格式。
- en: The Difference Between SNMP Messages and PDUs
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 消息和 PDU 的区别
- en: To understand SNMP messages, it is important that you first grasp the difference
    between SNMP messages and SNMP PDUs. We've seen in looking at SNMP protocol operations
    that the two terms are often used interchangeably. This is because each message
    carries one PDU, and the PDU is the most important part of the message.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 SNMP 消息，首先掌握 SNMP 消息和 SNMP PDU 之间的区别非常重要。我们在查看 SNMP 协议操作时看到，这两个术语经常被互换使用。这是因为每个消息都携带一个
    PDU，而 PDU 是消息中最重要的部分。
- en: 'However, strictly speaking, an SNMP PDU and an SNMP message are not exactly
    the same. The PDU is the actual piece of information that is being communicated
    between SNMP entities. It is carried within the SNMP message along with a number
    of header fields, which are used to carry identification and security information.
    Thus, conceptually, the SNMP message format can be considered to have two overall
    sections:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，严格来说，SNMP PDU 和 SNMP 消息并不完全相同。PDU 是在 SNMP 实体之间实际传递的信息。它包含在 SNMP 消息中，并带有多个头字段，这些字段用于携带标识和安全信息。因此，从概念上讲，SNMP
    消息格式可以被认为有两个主要部分：
- en: '**Message Header** Contains fields used to control how the message is processed,
    including fields for implementing SNMP security.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息头** 包含用于控制消息处理方式的字段，包括用于实现 SNMP 安全性的字段。'
- en: '**Message Body (PDU)** Contains the main portion of the message. In this case,
    the message body is the PDU being transmitted.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息体（PDU）** 包含消息的主要部分。在这种情况下，消息体就是正在传输的 PDU。'
- en: The overall SNMP message is sometimes called a *wrapper* for the PDU, since
    it encapsulates the PDU and precedes it with additional fields. The distinction
    between the PDU and the message format as a whole began as a formality in SNMPv1,
    but it became quite important in later versions. The reason is that it allows
    the fields used for basic protocol operations (which are in the PDU) to be kept
    separate from fields used to implement security features. In SNMPv2, the implementation
    of security became a very big deal indeed, so this flexibility was quite important.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 整个SNMP消息有时被称为PDU的*包装器*，因为它封装了PDU，并在其前面添加了额外的字段。PDU与整个消息格式的区别最初是SNMPv1中的一个形式，但在后续版本中变得非常重要。原因是它允许用于基本协议操作的字段（位于PDU中）与用于实现安全特性的字段保持分离。在SNMPv2中，安全性的实现确实变得非常重要，因此这种灵活性非常重要。
- en: General PDU Format
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用PDU格式
- en: 'The fields in each PDU depend on the PDU type, but can be divided into the
    following general substructure:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PDU中的字段取决于PDU类型，但可以分为以下通用子结构：
- en: '**PDU Control Fields** A set of fields that describe the PDU and communicate
    information from one SNMP entity to another.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**PDU控制字段** 描述PDU并从SNMP的一个实体向另一个实体传递信息的一组字段。'
- en: '**PDU Variable Bindings** A set of descriptions of the MIB objects in the PDU.
    Each object is described as a *binding* of a name to a value.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**PDU变量绑定** PDU中MIB对象的描述集合。每个对象都描述为名称到值的*绑定*。'
- en: Each PDU will follow this general structure, which is shown in [Figure 68-1](ch68s03.html#snmp_general_message_format-id001
    "Figure 68-1. SNMP general message format"), differing only in the number of control
    fields and variable bindings and how they are used. In theory, each PDU could
    have a different message format using a distinct set of control fields, but in
    practice, most PDUs for a given SNMP version use the same control fields (with
    some exceptions).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PDU都将遵循以下通用结构，如图[图68-1](ch68s03.html#snmp_general_message_format-id001 "图68-1.
    SNMP通用消息格式")所示，只是在控制字段的数量和变量绑定以及它们的使用方式上有所不同。理论上，每个PDU可以使用一组不同的控制字段具有不同的消息格式，但在实践中，大多数特定SNMP版本的PDU使用相同的控制字段（尽管有一些例外）。
- en: '![SNMP general message format](httpatomoreillycomsourcenostarchimages288237.png.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP通用消息格式](httpatomoreillycomsourcenostarchimages288237.png.jpg)'
- en: Figure 68-1. SNMP general message format
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-1. SNMP通用消息格式
- en: Each variable binding describes one MIB object. The binding consists of a pair
    of subfields, one specifying the name of the object in standard SNMP object identifier
    notation and one its value, formatted to match the object's SMI syntax. For example,
    if the object were of type Integer, the value field would be four bytes wide and
    contain a numeric integer value. [Table 68-1](ch68s03.html#snmp_variable_binding_format
    "Table 68-1. SNMP Variable Binding Format") describes the subfield format for
    each PDU variable binding.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量绑定描述一个MIB对象。绑定由一对子字段组成，一个指定对象的标准SNMP对象标识符表示法中的名称，另一个指定其值，格式化以匹配对象的SMI语法。例如，如果对象是整型，则值字段将宽四字节，并包含一个数值整数。[表68-1](ch68s03.html#snmp_variable_binding_format
    "表68-1. SNMP变量绑定格式")描述了每个PDU变量绑定的子字段格式。
- en: Table 68-1. SNMP Variable Binding Format
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-1. SNMP变量绑定格式
- en: '| Subfield Name | Syntax | Size (Bytes) | Description |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Object Name | Sequence of Integer | Variable | The numeric object identifier
    of the MIB object, specified as a sequence of integers. For example, the object
    `sysLocation` has the object identifier 1.3.6.1.2.1.1.6, so it would be specified
    as 1 3 6 1 2 1 1 6 using ASN.1. |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 整数序列 | 变量 | MIB对象的数值对象标识符，指定为整数序列。例如，对象`sysLocation`具有对象标识符1.3.6.1.2.1.1.6，因此它将使用ASN.1指定为1
    3 6 1 2 1 1 6。|'
- en: '| Object Value | Variable | Variable | In any type of get request, this subfield
    is a placeholder; it is structured using the appropriate syntax for the object
    but has no value (since the get request is asking for that value!). In a set request
    (SetRequest-PDU) or in a reply message carrying requested data (GetResponse-PDU
    or Response-PDU), the value of the object is placed here. |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| 对象值 | 变量 | 变量 | 在任何类型的get请求中，此子字段是一个占位符；它使用适当的语法结构化对象，但没有值（因为get请求是请求该值！）在set请求（SetRequest-PDU）或携带请求数据的回复消息（GetResponse-PDU或Response-PDU）中，对象的值放置在这里。|'
- en: Tip
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The general format of SNMP messages consists of a *message
    header* and a *message body*. The body of the message is also called the *protocol
    data unit*, or *PDU*, and contains a set of PDU *control fields* and a number
    of *variable bindings*. Each variable binding describes one MIB object and consists
    of the object''s name and value.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP 消息的通用格式由一个 *消息标题* 和一个 *消息体* 组成。消息体也称为 *协议数据单元* 或 *PDU*，包含一组 PDU
    *控制字段* 和多个 *变量绑定*。每个变量绑定描述一个 MIB 对象，并包括对象的名称和值。'
- en: SNMP Version 1 (SNMPv1) Message Format
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP 版本 1 (SNMPv1) 消息格式
- en: The SNMP general message format was first used to define the format of messages
    in the original SNMP protocol, SNMPv1\. This first version of SNMP is probably
    best known for its relative simplicity compared to the versions that followed
    it. This is reflected in its message format, which is quite straightforward.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 通用消息格式最初用于定义原始 SNMP 协议（SNMPv1）中消息的格式。这个 SNMP 的第一个版本可能因其相对于后续版本的相对简单性而最为人所知。这反映在其消息格式上，该格式相当直接。
- en: SNMPv1 General Message Format
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv1 通用消息格式
- en: The general message format in SNMPv1 is a wrapper consisting of a small header
    and an encapsulated PDU. Not very many header fields were needed in SNMPv1 because
    the community-based security method in SNMPv1 is very rudimentary. The overall
    format for SNMPv1 messages is described in [Table 68-2](ch68s04.html#snmp_version__snmpv_general_message_form
    "Table 68-2. SNMP Version 1 (SNMPv1) General Message Format") and illustrated
    in [Figure 68-2](ch68s04.html#snmpv1_general_message_format-id001 "Figure 68-2. SNMPv1
    general message format").
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv1 中的通用消息格式是一个由一个小标题和一个封装的 PDU 组成的包装器。在 SNMPv1 中，不需要很多标题字段，因为 SNMPv1 中的基于社区的网络安全方法非常原始。SNMPv1
    消息的整体格式在 [表 68-2](ch68s04.html#snmp_version__snmpv_general_message_form "表 68-2.
    SNMP 版本 1 (SNMPv1) 通用消息格式") 中描述，并在 [图 68-2](ch68s04.html#snmpv1_general_message_format-id001
    "图 68-2. SNMPv1 通用消息格式") 中展示。
- en: Table 68-2. SNMP Version 1 (SNMPv1) General Message Format
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-2. SNMP 版本 1 (SNMPv1) 通用消息格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv1,
    this value is actually 0, not 1. |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 整数 | 4 | 版本号：描述此消息的 SNMP 版本号；用于确保版本之间的兼容性。对于 SNMPv1，此值实际上是 0，而不是 1。
    |'
- en: '| Community | Octet String | Variable | Community String: Identifies the SNMP
    community in which the sender and recipient of this message are located. This
    is used to implement the simple SNMP community-based security mechanism, described
    in the previous chapter. |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| Community | 八位字节串 | 可变 | 社区字符串：标识发送者和接收者所在的 SNMP 社区。这用于实现前一章中描述的简单 SNMP 基于社区的安全机制。
    |'
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| PDU | — | Variable | 协议数据单元：作为消息体的通信 PDU。 |'
- en: '![SNMPv1 general message format](httpatomoreillycomsourcenostarchimages288239.png)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv1 通用消息格式](httpatomoreillycomsourcenostarchimages288239.png)'
- en: Figure 68-2. SNMPv1 general message format
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 图 68-2. SNMPv1 通用消息格式
- en: SNMPv1 PDU Formats
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv1 PDU 格式
- en: 'All of the PDUs in SNMPv1 have the same format, with one exception: Trap-PDU.
    The exact semantics of each field in the PDU depend on the particular message.
    For example, the ErrorStatus field only has meaning in a reply and not a request,
    and object values are used differently in requests and replies as well.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv1 中的所有 PDU 都具有相同的格式，只有一个例外：Trap-PDU。PDU 中每个字段的精确语义取决于特定的消息。例如，ErrorStatus
    字段只在回复中有意义，而不是请求中，并且对象值在请求和回复中的使用方式也不同。
- en: '[Table 68-3](ch68s04.html#snmpv_common_pdu_format "Table 68-3. SNMPv1 Common
    PDU Format") shows the common format for most of the SNMPv1 PDUs: GetRequest-PDU,
    GetNextRequest-PDU, SetRequest-PDU, and GetResponse-PDU.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 68-3](ch68s04.html#snmpv_common_pdu_format "表 68-3. SNMPv1 常见 PDU 格式") 展示了大多数
    SNMPv1 PDU 的通用格式：GetRequest-PDU、GetNextRequest-PDU、SetRequest-PDU 和 GetResponse-PDU。'
- en: Table 68-3. SNMPv1 Common PDU Format
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-3. SNMPv1 常见 PDU 格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type:0 = GetRequest-PDU1 = GetNextRequest-PDU2 = GetNextRequest-PDU3 =
    SetRequest-PDU |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| PDU 类型 | 整数（枚举） | 4 | PDU 类型：表示 PDU 类型的整数值：0 = GetRequest-PDU 1 = GetNextRequest-PDU
    2 = GetNextRequest-PDU 3 = SetRequest-PDU |'
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a GetResponse-PDU by the responding SNMP entity. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 请求 ID | 整数 | 4 | 请求标识符：用于匹配请求和响应的数字。由发送请求的设备生成，并由响应的 SNMP 实体复制到 GetResponse-PDU
    的此字段中。 |'
- en: '| Error Status | Integer (Enumerated) | 4 | Error Status: An integer value
    that is used in a GetResponse*-*PDU to tell the requesting SNMP entity the result
    of its request. A value of zero indicates that no error occurred; the other values
    indicate what sort of error happened, as listed in [Table 68-4](ch68s04.html#snmpv_error_status_field_values
    "Table 68-4. SNMPv1 Error Status Field Values"). |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| 错误状态 | 整数（枚举） | 4 | 错误状态：在 GetResponse-*-*PDU 中使用的整数值，用于告知请求的 SNMP 实体其请求的结果。零值表示没有发生错误；其他值表示发生了什么类型的错误，如
    [表 68-4](ch68s04.html#snmpv_error_status_field_values "表 68-4. SNMPv1 错误状态字段值")
    中列出。 |'
- en: '| Error Index | Integer | 4 | Error Index: When Error Status is nonzero, this
    field contains a pointer that specifies which object generated the error. Always
    zero in a request. |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| 错误索引 | 整数 | 4 | 错误索引：当错误状态非零时，此字段包含一个指针，指定哪个对象生成了错误。在请求中始终为零。 |'
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU, and in the case of a SetRequest-PDU
    or GetResponse-PDU, containing their values. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 变量绑定 | 变量 | 变量 | 变量绑定：一组标识 PDU 中 MIB 对象的名称/值对，在 SetRequest-PDU 或 GetResponse-PDU
    的情况下，包含它们的值。有关这些绑定的更多信息，请参阅本章前面关于通用 SNMP PDU 格式的讨论。 |'
- en: Table 68-4. SNMPv1 Error Status Field Values
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-4. SNMPv1 错误状态字段值
- en: '| Error Status Value | Error Code | Description |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| 错误状态值 | 错误代码 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | noError | No error occurred. This code is also used in all request PDUs,
    since they have no error status to report. |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| 0 | noError | 没有发生错误。此代码也用于所有请求 PDU，因为它们没有错误状态要报告。 |'
- en: '| 1 | tooBig | The size of the GetResponse-PDU would be too large to transport.
    |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 1 | tooBig | GetResponse-PDU 的大小将太大而无法传输。 |'
- en: '| 2 | noSuchName | The name of a requested object was not found. |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 2 | noSuchName | 请求的对象名称未找到。 |'
- en: '| 3 | badValue | A value in the request didn''t match the structure that the
    recipient of the request had for the object. For example, an object in the request
    was specified with an incorrect length or type. |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 3 | badValue | 请求中的某个值与请求接收者对对象的结构不符。例如，请求中的对象指定了错误的长度或类型。 |'
- en: '| 4 | readOnly | An attempt was made to set a variable that has an Access value
    indicating that it is read-only. |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| 4 | readOnly | 尝试设置一个具有表示只读访问值的变量。 |'
- en: '| 5 | genErr | An error other than one of the preceding four specific types
    occurred. |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 5 | genErr | 发生了前四种特定类型之外的错误。 |'
- en: '![SNMPv1 common PDU format](httpatomoreillycomsourcenostarchimages288241.png)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv1 常见 PDU 格式](httpatomoreillycomsourcenostarchimages288241.png)'
- en: Figure 68-3. SNMPv1 common PDU format
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 图 68-3. SNMPv1 常见 PDU 格式
- en: '[Table 68-5](ch68s04.html#snmpv_trap-pdu_format "Table 68-5. SNMPv1 Trap-PDU
    Format") describes the special format for the SNMPv1 Trap-PDU, and it is illustrated
    in [Figure 68-4](ch68s04.html#snmpv1_trap-pdu_format "Figure 68-4. SNMPv1 Trap-PDU
    format").'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 68-5](ch68s04.html#snmpv_trap-pdu_format "表 68-5. SNMPv1 Trap-PDU 格式") 描述了
    SNMPv1 Trap-PDU 的特殊格式，并在 [图 68-4](ch68s04.html#snmpv1_trap-pdu_format "图 68-4.
    SNMPv1 Trap-PDU 格式") 中进行了说明。'
- en: Table 68-5. SNMPv1 Trap-PDU Format
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-5. SNMPv1 Trap-PDU 格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type, which is 4 for a Trap-PDU message. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| PDU 类型 | 整数（枚举） | 4 | PDU 类型：指示 PDU 类型的整数值，对于 Trap-PDU 消息为 4。 |'
- en: '| Enterprise | Sequence of Integer | Variable | Enterprise: An object identifier
    for a group, which indicates the type of object that generated the trap. |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 企业 | 整数序列 | 变量 | 企业：表示生成陷阱的对象类型的对象标识符。 |'
- en: '| Agent Addr | NetworkAddress | 4 | Agent Address: The IP address of the SNMP
    agent that generated the trap. This is also in the IP header at lower levels but
    inclusion in the SNMP message format allows for easier trap logging within SNMP.
    Also, in the case of a multihomed host, this specifies the preferred address.
    |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 代理地址 | 网络地址 | 4 | 代理地址：生成陷阱的SNMP代理的IP地址。这在较低层级的IP头部中也有，但将其包含在SNMP消息格式中可以更容易地在SNMP中进行陷阱记录。此外，在多宿主主机的情况下，这指定了首选地址。|'
- en: '| Generic Trap | Integer (Enumerated) | 4 | Generic Trap Code: A code value
    specifying one of a number of predefined generic trap types. |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 通用陷阱 | 整数（枚举） | 4 | 通用陷阱代码：指定预定义的几种通用陷阱类型之一的代码值。|'
- en: '| Specific Trap | Integer | 4 | Specific Trap Code: A code value indicating
    an implementation-specific trap type. |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 特定陷阱 | 整数 | 4 | 特定陷阱代码：指示特定实现陷阱类型的代码值。|'
- en: '| Time Stamp | TimeTicks | 4 | Time Stamp: The amount of time since the SNMP
    entity sending this message last initialized or reinitialized. Used to time stamp
    traps for logging purposes. |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | TimeTicks | 4 | 时间戳：自发送此消息的SNMP实体上次初始化或重新初始化以来经过的时间。用于为记录目的对陷阱进行时间戳。|'
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| 变量绑定 | 变量 | 变量绑定：一组标识PDU中MIB对象的名称/值对。关于这些绑定的更多信息，请参阅本章前面关于通用SNMP PDU格式的讨论。|'
- en: '![SNMPv1 Trap-PDU format](httpatomoreillycomsourcenostarchimages288243.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv1陷阱-PDU格式](httpatomoreillycomsourcenostarchimages288243.png)'
- en: Figure 68-4. SNMPv1 Trap-PDU format
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-4. SNMPv1陷阱-PDU格式
- en: SNMP Version 2 (SNMPv2) Message Formats
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP版本2（SNMPv2）消息格式
- en: After SMNPv1 had been in use for several years, certain issues with it were
    noticed and areas for improvement identified. This led to the development of the
    original SNMPv2, which was intended to enhance SNMPv1 in many areas, including
    MIB object definitions, protocol operations, and security. This last area, security,
    led to the proliferation of SNMPv2 version variants that I described in [Chapter 65](ch65.html
    "Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW").
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv1使用了几年后，人们注意到了它的一些问题，并确定了改进的领域。这导致了原始SNMPv2的开发，其目的是在许多领域增强SNMPv1，包括MIB对象定义、协议操作和安全。最后一个领域，安全，导致了我在[第65章](ch65.html
    "第65章。TCP/IP互联网标准管理框架概述")中描述的SNMPv2版本变种的激增。
- en: Since there are several different SNMPv2s, there are also several message formats
    for SNMPv2\. This is confusing, but it would be even worse without the modular
    nature of SNMP messages coming to the rescue. The protocol operations in SNMPv2
    were changed from SNMPv1, which necessitated some modifications to the format
    of SNMPv2 PDUs. However, the protocol operations are the same for all the SNMPv2
    variations. The differences between SNMPv2 variants are in the areas of security
    implementation. Thus, the result of this is that the PDU format is the same for
    all the SNMPv2 types, while the overall message format differs for each variant.
    (This is why the distinction between a PDU and a message is not just an academic
    one!)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在几个不同的SNMPv2版本，因此也有几个SNMPv2的消息格式。这很令人困惑，但如果没有SNMP消息模块化特性的帮助，情况会更糟。SNMPv2中的协议操作从SNMPv1更改，这需要修改SNMPv2
    PDU的格式。然而，所有SNMPv2变体中的协议操作都是相同的。SNMPv2变体之间的差异在于安全实现方面。因此，结果是所有SNMPv2类型的PDU格式都是相同的，而每个变体的整体消息格式都不同。（这就是为什么PDU和消息之间的区别不仅仅是一个学术问题！）
- en: 'During the SNMPv2 divergence, four variations were defined: the original SNMPv2
    (SNMPv2p), community-based SNMPv2 (SNMPv2c), user-based SNMPv2 (SNMPv2u), and
    SNMPv2 asterisk (SNMPv2*). Of these, the first three were documented in sets of
    SNMP RFC standards, as discussed in [Chapter 65](ch65.html "Chapter 65. TCP/IP
    INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"); the fourth was not. The structure
    of the overall message format for each variant is discussed in an administrative
    or security standard for the variation in question, which makes reference to the
    shared SNMPv2 standard for the PDU format (RFC 1905).'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv2的分歧期间，定义了四种变体：原始SNMPv2（SNMPv2p）、基于社区的SNMPv2（SNMPv2c）、基于用户的SNMPv2（SNMPv2u）和SNMPv2星号（SNMPv2*）。其中，前三种在SNMP
    RFC标准集中进行了记录，如[第65章](ch65.html "第65章。TCP/IP互联网标准管理框架概述")中所述；第四种没有。每个变体的整体消息格式结构在讨论该变体的管理或安全标准中进行了讨论，该标准引用了共享的SNMPv2标准PDU格式（RFC
    1905）。
- en: SNMP Version 2 (SNMPv2p) Message Format
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 版本 2 (SNMPv2p) 消息格式
- en: The party-based security model is quite complex, but the basic messaging in
    this version is described through the definition of a *management communication*,
    which describes the source and destination party and makes reference to a *context*
    for the communication. The overall message format is described in detail in RFC
    1445\. This information is summarized in [Table 68-6](ch68s05.html#snmp_version__snmpvp_general_message_for
    "Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format") and shown graphically
    in [Figure 68-5](ch68s05.html#snmpv2p_general_message_format "Figure 68-5. SNMPv2p
    general message format").
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 基于实体的安全模型相当复杂，但本版本的基本消息通过定义一个 *管理通信* 来描述，该通信描述了源和目的实体，并引用了通信的 *上下文*。整体消息格式在
    RFC 1445 中详细描述。此信息在 [表 68-6](ch68s05.html#snmp_version__snmpvp_general_message_for
    "表 68-6. SNMP 版本 2 (SNMPv2p) 通用消息格式") 中总结，并在 [图 68-5](ch68s05.html#snmpv2p_general_message_format
    "图 68-5. SNMPv2p 通用消息格式") 中以图形方式展示。
- en: Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-6. SNMP 版本 2 (SNMPv2p) 通用消息格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2p,
    this value is 2. |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 整数 | 4 | 版本号：描述此消息的 SNMP 版本号；用于确保版本之间的兼容性。对于 SNMPv2p，此值为 2。 |'
- en: '| Dst Party | Sequence of Integer | Variable | Destination Party: An object
    identifier that specifies the party that is the intended recipient of the message.
    |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| 目的实体 | 整数序列 | 变量 | 目的实体：一个对象标识符，指定消息的预期接收者实体。 |'
- en: '| Src Party | Sequence of Integer | Variable | Source Party: An object identifier
    that specifies the party that is the sender of the message. |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| 源实体 | 整数序列 | 变量 | 源实体：一个对象标识符，指定消息的发送者实体。 |'
- en: '| Context | Sequence of Integer | Variable | Context: Defines a set of MIB
    object resources that is accessible by a particular entity. |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| 上下文 | 整数序列 | 变量 | 上下文：定义一组 MIB 对象资源，该资源可由特定实体访问。 |'
- en: '| PDU | — | Variable | PDU: The protocol data unit of the message. |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| PDU | — | 变量 | PDU：消息的协议数据单元。 |'
- en: '![SNMPv2p general message format](httpatomoreillycomsourcenostarchimages288245.png)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv2p 通用消息格式](httpatomoreillycomsourcenostarchimages288245.png)'
- en: Figure 68-5. SNMPv2p general message format
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 图 68-5. SNMPv2p 通用消息格式
- en: Community-Based SNMP Version 2 (SNMPv2c) Message Format
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于社区的 SNMP 版本 2 (SNMPv2c) 消息格式
- en: The community-based version of SNMPv2 was intended to keep the new protocol
    enhancements introduced by SNMPv2p but go back to the simple SNMPv1 security model.
    As such, the defining document for SNMPv2c, RFC 1901, specifies that its overall
    message format is the same as that of SNMPv1, except that the version number is
    changed. This is shown in [Table 68-7](ch68s05.html#community-based_snmp_version__snmpvc_gen
    "Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format")
    and illustrated in [Figure 68-6](ch68s05.html#snmpv2c_general_message_format "Figure 68-6. SNMPv2c
    general message format").
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv2 的基于社区的版本旨在保留 SNMPv2p 引入的新协议增强功能，但回归到简单的 SNMPv1 安全模型。因此，SNMPv2c 的定义文档
    RFC 1901 指定其整体消息格式与 SNMPv1 相同，除了版本号已更改。这显示在 [表 68-7](ch68s05.html#community-based_snmp_version__snmpvc_gen
    "表 68-7. 基于社区的 SNMP 版本 2 (SNMPv2c) 通用消息格式") 中，并在 [图 68-6](ch68s05.html#snmpv2c_general_message_format
    "图 68-6. SNMPv2c 通用消息格式") 中展示。
- en: Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-7. 基于社区的 SNMP 版本 2 (SNMPv2c) 通用消息格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2c,
    this value is 1. |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 整数 | 4 | 版本号：描述此消息的 SNMP 版本号；用于确保版本之间的兼容性。对于 SNMPv2c，此值为 1。 |'
- en: '| Community | Octet String | Variable | Community String: Identifies the SNMP
    community in which the sender and recipient of this message are located. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 社区 | 字节串 | 变量 | 社区字符串：标识发送者和接收者所在的 SNMP 社区。 |'
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| PDU | — | 变量 | 协议数据单元：作为消息主体的 PDU。 |'
- en: '![SNMPv2c general message format](httpatomoreillycomsourcenostarchimages288247.png)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv2c 通用消息格式](httpatomoreillycomsourcenostarchimages288247.png)'
- en: Figure 68-6. SNMPv2c general message format
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图 68-6. SNMPv2c 通用消息格式
- en: User-Based SNMP Version 2 (SNMPv2u) Message Format
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于用户的SNMP版本2（SNMPv2u）消息格式
- en: The user-based version of SNMPv2 was defined as an optional security model at
    the time that SNMPv2c was standardized. RFC 1910 defines the user-based security
    model and the message format described in [Table 68-8](ch68s05.html#user-based_snmp_version__snmpvu_general_
    "Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format") and
    illustrated in [Figure 68-7](ch68s05.html#snmpv2u_general_message_format "Figure 68-7. SNMPv2u
    general message format").
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNMPv2c标准化时，基于用户的SNMPv2版本被定义为可选的安全模型。RFC 1910定义了基于用户的安全模型和[表68-8](ch68s05.html#user-based_snmp_version__snmpvu_general_
    "表68-8. 基于用户的SNMP版本2 (SNMPv2u)通用消息格式")中描述的消息格式，并在[图68-7](ch68s05.html#snmpv2u_general_message_format
    "图68-7. SNMPv2u通用消息格式")中说明。
- en: Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-8. 基于用户的SNMP版本2（SNMPv2u）通用消息格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Version | Integer | 4 | Version Number: Describes the SNMP version number
    of this message; used for ensuring compatibility between versions. For SNMPv2u,
    this value is 2\. Note that this is the same value as used for SNMPv2p. |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 整数 | 4 | 版本号：描述此消息的SNMP版本号；用于确保版本之间的兼容性。对于SNMPv2u，此值为2。注意，这与SNMPv2p使用的值相同。|'
- en: '| Parameters | Octet String | Variable | Parameters: A string of parameters
    used to implement the user-based security model, which are briefly described in
    [Table 68-9](ch68s05.html#snmpvu_parameter_field_subfields "Table 68-9. SNMPv2u
    Parameter Field Subfields"). |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 字节串 | 可变 | 参数：用于实现基于用户的安全模型的一串参数，这些参数在[表68-9](ch68s05.html#snmpvu_parameter_field_subfields
    "表68-9. SNMPv2u参数字段子字段")中简要描述。|'
- en: '| PDU | — | Variable | Protocol Data Unit: The PDU being communicated as the
    body of the message. This may be in either encrypted or unencrypted form. |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| PDU | — | 可变 | 协议数据单元：作为消息主体的正在通信的PDU。这可能以加密或未加密的形式存在。|'
- en: '![SNMPv2u general message format](httpatomoreillycomsourcenostarchimages288249.png)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv2u通用消息格式](httpatomoreillycomsourcenostarchimages288249.png)'
- en: Figure 68-7. SNMPv2u general message format
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-7. SNMPv2u通用消息格式
- en: Table 68-9. SNMPv2u Parameter Field Subfields
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-9. SNMPv2u参数字段子字段
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Model | 1 | Model Number: Set to 1 to identify the user-based model. |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 1 | 模型号：设置为1以标识基于用户的模型。|'
- en: '| QoS | 1 | Quality of Service: Indicates whether authentication and/or privacy
    (encryption) have been used and whether generation of a Report-PDU is allowed.
    |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| QoS | 1 | 服务质量：指示是否使用了认证和/或隐私（加密），以及是否允许生成报告-PDU。|'
- en: '| Agent ID | 12 | Agent Identifier: The identifier of the agent sending the
    message. Used to defeat replay attacks and certain other types of security attacks.
    |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 代理ID | 12 | 代理标识符：发送消息的代理的标识符。用于防止重放攻击和其他某些类型的安全攻击。|'
- en: '| Agent Boots | 4 | Agent Number of Boots: The number of times the agent has
    been booted or rebooted since its Agent ID was set; used to defeat certain security
    attacks. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 代理启动次数 | 4 | 代理启动次数：自设置代理ID以来代理已启动或重启的次数；用于防止某些安全攻击。|'
- en: '| Agent Time | 4 | Agent Time Since Last Boot: The number of seconds since
    the last boot of this agent. Again, used to defeat replay and other security attacks.
    |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| 代理时间 | 4 | 代理自上次启动以来的时间：自上次启动以来此代理的秒数。再次用于防止重放和其他安全攻击。|'
- en: '| Max Size | 2 | Maximum Message Size: The maximum size of message that the
    sender of this message can receive. |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 最大大小 | 2 | 最大消息大小：发送此消息的发送者可以接收的消息的最大大小。|'
- en: '| User Len | 1 | User Length: The length of the User Name field below. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| 用户长度 | 1 | 用户长度：下面用户名字段的长度。|'
- en: '| User Name | Variable (1 to 16) | User Name: The name of the user on whose
    behalf the message is being sent. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 可变（1到16） | 用户名：发送消息的用户名。|'
- en: '| Auth Len | 1 | Authentication Digest Length: The length of the Auth Digest
    field. |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| 认证长度 | 1 | 认证摘要长度：认证摘要字段长度。|'
- en: '| Auth Digest | Variable (0 to 255) | Authentication Digest: An authentication
    value used to verify the identity and genuineness of this message, when authentication
    is used. |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| 认证摘要 | 可变（0到255） | 认证摘要：用于验证此消息的身份和真实性的认证值，当使用认证时。|'
- en: '| Context Selector | Variable (0 to 40) | Context Selector: A string that is
    combined with the Agent ID to specify a particular context that contains the management
    information referenced by this message. |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| 上下文选择器 | 变量（0到40） | 上下文选择器：一个字符串，与代理ID结合使用，以指定包含此消息引用的管理信息的特定上下文。|'
- en: SNMPv2 PDU Formats
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMPv2 PDU 格式
- en: The format of protocol data units in SNMPv2 is described in RFC 1905, and it
    is similar to that of SNMPv1\. The format for all PDUs in SNMPv2 is the same,
    except for the GetBulkRequest-PDU message. (Oddly, this includes the Trapv2-PDU
    message, even though the Trap-PDU message in SNMPv1 used a distinct format.)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv2中协议数据单元的格式在RFC 1905中描述，它与SNMPv1的格式相似。SNMPv2中所有PDUs的格式相同，除了GetBulkRequest-PDU消息。（奇怪的是，这包括Trapv2-PDU消息，尽管SNMPv1中的Trap-PDU消息使用了不同的格式。）
- en: '[Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001 "Table 68-10. SNMPv2
    Common PDU Format") shows the common SNMPv2 PDU format. [Table 68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "Table 68-11. SNMPv2 PDU Error Status Field Values") contains a listing of the
    different values for the Error Status field and how they are interpreted. [Figure 68-8](ch68s05.html#snmpv2_common_pdu_format
    "Figure 68-8. SNMPv2 common PDU format") illustrates the SNMPv2 common PDU format.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[表68-10](ch68s05.html#snmpv_common_pdu_format-id001 "表68-10. SNMPv2 通用 PDU
    格式")显示了常见的SNMPv2 PDU格式。[表68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "表68-11. SNMPv2 PDU 错误状态字段值")包含错误状态字段的不同的值及其解释。[图68-8](ch68s05.html#snmpv2_common_pdu_format
    "图68-8. SNMPv2 通用 PDU 格式")说明了SNMPv2通用PDU格式。'
- en: Table 68-10. SNMPv2 Common PDU Format
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-10. SNMPv2 通用 PDU 格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type:0 = GetRequest-PDU1 = GetNextRequest-PDU2 = Response-PDU3 = SetRequest-PDU4
    = Obsolete, not used (this was the old Trap-PDU in SNMPv1)5 = GetBulkRequest-PDU
    (has its own format; see [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format"))6 = InformRequest-PDU7 = Trapv2-PDU8
    = Report-PDU |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| PDU 类型 | 整数（枚举） | 4 | PDU 类型：表示PDU类型的整数值：0 = GetRequest-PDU1 = GetNextRequest-PDU2
    = Response-PDU3 = SetRequest-PDU4 = 已废弃，不再使用（这是SNMPv1中的旧Trap-PDU）5 = GetBulkRequest-PDU（有自己的格式；请参阅[表68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "表68-12. SNMPv2 GetBulkRequest-PDU 格式"))6 = InformRequest-PDU7 = Trapv2-PDU8 =
    Report-PDU |'
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a Response-PDU by the responding SNMP entity. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| 请求ID | 整数 | 4 | 请求标识符：用于匹配请求和响应的数字。由发送请求的设备生成，并由响应的SNMP实体复制到响应-PDU中的此字段。|'
- en: '| Error Status | Integer (Enumerated) | 4 | Error Status: An integer value
    that is used in a Response-PDU to tell the requesting SNMP entity the result of
    its request. A value of zero indicates that no error occurred; the other values
    indicate what sort of error happened (see [Table 68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "Table 68-11. SNMPv2 PDU Error Status Field Values")). |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| 错误状态 | 整数（枚举） | 4 | 错误状态：在响应-PDU中使用的整数值，用于告知请求的SNMP实体其请求的结果。零值表示没有发生错误；其他值表示发生了什么类型的错误（请参阅[表68-11](ch68s05.html#snmpv_pdu_error_status_field_values
    "表68-11. SNMPv2 PDU 错误状态字段值")）。|'
- en: '| Error Index | Integer | 4 | Error Index: When Error Status is nonzero, this
    field contains a pointer that specifies which object generated the error. Always
    zero in a request. |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| 错误索引 | 整数 | 4 | 错误索引：当错误状态不为零时，此字段包含一个指针，指定哪个对象生成了错误。在请求中始终为零。|'
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU, and in the case of messages other
    than requests, containing their values. See the discussion of the general SNMP
    general PDU format earlier in this chapter for more on these bindings. |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| 变量绑定 | 变量 | 变量 | 变量绑定：一组标识PDU中MIB对象的名称/值对，在请求以外的消息中包含它们的值。有关这些绑定的更多信息，请参阅本章前面关于通用SNMP
    PDU格式的讨论。|'
- en: Note
  id: totrans-654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The first six Error Status field values (0 to 5) are maintained as used in
    SNMPv1 for compatibility, but SNMPv2 adds many new error codes that provide more
    specific indication of the exact nature of an error in a request. The genErr code
    is still used only when none of the specific error types (either the old codes
    or the new ones) apply*.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '*前六个错误状态字段值（0到5）保持与SNMPv1中使用的值一致，以保持兼容性，但SNMPv2添加了许多新的错误代码，这些代码提供了对请求中错误确切性质的更具体指示。当没有特定的错误类型（无论是旧代码还是新代码）适用时，仍然使用genErr代码*。'
- en: Table 68-11. SNMPv2 PDU Error Status Field Values
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-11. SNMPv2 PDU错误状态字段值
- en: '| Error Status Value | Error Code | Description |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| 错误状态值 | 错误代码 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | noError | No error occurred. This code is also used in all request PDUs,
    since they have no error status to report. |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| 0 | noError | 没有发生错误。此代码也用于所有请求PDU，因为它们没有错误状态要报告。 |'
- en: '| 1 | tooBig | The size of the Response-PDU would be too large to transport.
    |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| 1 | tooBig | 响应-PDU的大小将太大而无法传输。 |'
- en: '| 2 | noSuchName | The name of a requested object was not found. |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| 2 | noSuchName | 请求的对象名称未找到。 |'
- en: '| 3 | badValue | A value in the request didn''t match the structure that the
    recipient of the request had for the object. For example, an object in the request
    was specified with an incorrect length or type. |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| 3 | badValue | 请求中的值与请求接收者对对象的预期结构不匹配。例如，请求中的对象指定了不正确的长度或类型。 |'
- en: '| 4 | readOnly | An attempt was made to set a variable that has an Access value
    indicating that it is read-only. |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| 4 | readOnly | 尝试设置一个具有只读访问值的变量。 |'
- en: '| 5 | genErr | An error occurred other than one indicated by a more specific
    error code in this table. |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| 5 | genErr | 发生了一个错误，该错误未在本表中的更具体错误代码中指示。 |'
- en: '| 6 | noAccess | Access was denied to the object for security reasons. |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| 6 | noAccess | 由于安全原因，拒绝访问对象。 |'
- en: '| 7 | wrongType | The object type in a variable binding is incorrect for the
    object. |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| 7 | wrongType | 变量绑定中的对象类型对于对象是不正确的。 |'
- en: '| 8 | wrongLength | A variable binding specifies a length incorrect for the
    object. |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 8 | wrongLength | 变量绑定指定了一个不适用于对象的长度。 |'
- en: '| 9 | wrongEncoding | A variable binding specifies an encoding incorrect for
    the object. |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| 9 | wrongEncoding | 变量绑定指定了一个不适用于对象的编码。 |'
- en: '| 10 | wrongValue | The value given in a variable binding is not possible for
    the object. |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| 10 | wrongValue | 变量绑定中给出的值对于对象来说是不可能的。 |'
- en: '| 11 | noCreation | A specified variable does not exist and cannot be created.
    |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| 11 | noCreation | 指定的变量不存在且无法创建。 |'
- en: '| 12 | inconsistentValue | A variable binding specifies a value that could
    be held by the variable but cannot be assigned to it at this time. |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| 12 | inconsistentValue | 变量绑定指定了一个变量可以持有的值，但在此时刻无法分配给它。 |'
- en: '| 13 | resourceUnavailable | An attempt to set a variable required a resource
    that is not available. |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| 13 | resourceUnavailable | 设置变量需要一种不可用的资源。 |'
- en: '| 14 | commitFailed | An attempt to set a particular variable failed. |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| 14 | commitFailed | 尝试设置特定变量失败。 |'
- en: '| 15 | undoFailed | An attempt to set a particular variable as part of a group
    of variables failed, and the attempt to then undo the setting of other variables
    was not successful. |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| 15 | undoFailed | 尝试将特定变量作为一组变量的一部分设置失败，然后尝试撤销其他变量的设置并未成功。 |'
- en: '| 16 | authorizationError | A problem occurred in authorization. |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| 16 | authorizationError | 授权过程中出现问题。 |'
- en: '| 17 | notWritable | The variable cannot be written or created. |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| 17 | notWritable | 变量无法写入或创建。 |'
- en: '| 18 | inconsistentName | The name in a variable binding specifies a variable
    that does not exist. |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| 18 | inconsistentName | 变量绑定中的名称指定了一个不存在的变量。 |'
- en: '![SNMPv2 common PDU format](httpatomoreillycomsourcenostarchimages288251.png)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv2常见PDU格式](httpatomoreillycomsourcenostarchimages288251.png)'
- en: Figure 68-8. SNMPv2 common PDU format
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-8. SNMPv2常见PDU格式
- en: The special format of the SNMPv2 GetBulkRequest-PDU message is shown in [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format") and illustrated in [Figure 68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "Figure 68-9. SNMPv2 GetBulkRequest-PDU format").
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv2 GetBulkRequest-PDU消息的特殊格式在[表68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "表68-12. SNMPv2 GetBulkRequest-PDU格式")中显示，并在[图68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "图68-9. SNMPv2 GetBulkRequest-PDU格式")中说明。
- en: '![SNMPv2 GetBulkRequest-PDU format](httpatomoreillycomsourcenostarchimages288253.png)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv2 GetBulkRequest-PDU格式](httpatomoreillycomsourcenostarchimages288253.png)'
- en: Figure 68-9. SNMPv2 GetBulkRequest-PDU format
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-9. SNMPv2 GetBulkRequest-PDU格式
- en: Table 68-12. SNMPv2 GetBulkRequest-PDU Format
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-12. SNMPv2 GetBulkRequest-PDU格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| PDU Type | Integer (Enumerated) | 4 | PDU Type: An integer value that indicates
    the PDU type, which is 5 for a GetBulkRequest-PDU message. |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| PDU类型 | 整数（枚举） | 4 | PDU类型：一个表示PDU类型的整数值，对于GetBulkRequest-PDU消息为5。 |'
- en: '| Request ID | Integer | 4 | Request Identifier: A number used to match requests
    with replies. It is generated by the device that sends a request and copied into
    this field in a Response-PDU by the responding SNMP entity. |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| 请求ID | 整数 | 4 | 请求标识符：用于匹配请求和响应的数字。由发送请求的设备生成，并由响应的SNMP实体复制到Response-PDU中的此字段。
    |'
- en: '| Non Repeaters | Integer | 4 | Non Repeaters: Specifies the number of nonrepeating,
    regular objects at the start of the variable list in the request. |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| 非重复项 | 整数 | 4 | 非重复项：指定请求变量列表开头非重复、常规对象的数量。 |'
- en: '| Max Repetitions | Integer | 4 | Maximum Repetitions: The number of iterations
    in the table to be read for the repeating objects that follow the nonrepeating
    objects. |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| 最大重复次数 | 整数 | 4 | 最大重复次数：在表中读取跟随非重复对象的重复对象的迭代次数。 |'
- en: '| Variable Bindings | Variable | Variable | Variable Bindings: A set of name/value
    pairs identifying the MIB objects in the PDU. See the discussion of the general
    SNMP general PDU format earlier in this chapter for more on these bindings. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| 变量绑定 | 变量 | 变量 | 变量绑定：一组标识PDU中MIB对象的名称/值对。有关这些绑定的更多信息，请参阅本章前面关于通用SNMP PDU格式的讨论。
    |'
- en: '[Chapter 67](ch67.html "Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL
    (SNMP) CONCEPTS AND OPERATION") contains full details on how the Non Repeaters
    and Max Repetitions fields are used.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '[第67章](ch67.html "第67章. TCP/IP简单网络管理协议(SNMP)概念和操作")包含了关于非重复字段和最大重复字段如何使用的详细信息。'
- en: SNMP Version 3 (SNMPv3) Message Format
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP版本3（SNMPv3）消息格式
- en: In the late 1990s, SNMPv3 was created to resolve the problems that occurred
    with the many different variations of SNMPv2\. The SNMPv3 Framework adopts many
    components that were created in SNMPv2, including the SNMPv2 protocol operations,
    PDU types, and PDU format. The significant changes made in SNMPv3 include a more
    flexible way of defining security methods and parameters to allow the coexistence
    of multiple security techniques.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代末，为了解决SNMPv2的许多不同变体中出现的各种问题，创建了SNMPv3。SNMPv3框架采用了SNMPv2中创建的许多组件，包括SNMPv2协议操作、PDU类型和PDU格式。SNMPv3中做出的重大变化包括定义安全方法和参数的更灵活方式，以允许多种安全技术的共存。
- en: The general message format for SNMPv3 still follows the same idea of an overall
    message wrapper that contains a header and an encapsulated PDU, but it is further
    refined. The fields in the header have themselves been divided into those dealing
    with security and those that do not deal with security matters. The fields not
    related to security are common to all SNMPv3 implementations. The use of the security
    fields can be tailored by each SNMPv3 security model, and processed by the module
    in an SNMP entity that deals with security. This solution provides considerable
    flexibility while avoiding the problems that plagued SNMPv2.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv3的通用消息格式仍然遵循整体消息包装器的基本思想，该包装器包含一个头和一个封装的PDU，但它得到了进一步的细化。头部字段本身已经被分为处理安全和未处理安全问题的字段。与安全无关的字段对所有SNMPv3实现都是通用的。安全字段的使用可以由每个SNMPv3安全模型定制，并由处理安全的SNMP实体中的模块处理。这种解决方案提供了相当大的灵活性，同时避免了困扰SNMPv2的问题。
- en: The overall SNMPv3 message format is described in RFC 3412, which specifies
    its message processing and dispatching. [Table 68-13](ch68s06.html#snmp_version__snmpv_general_messag-id001
    "Table 68-13. SNMP Version 3 (SNMPv3) General Message Format") describes the SNMPv3
    message format, and it is illustrated in [Figure 68-10](ch68s06.html#snmpv3_general_message_format
    "Figure 68-10. SNMPv3 general message format").
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: SNMPv3的整体消息格式在RFC 3412中有描述，该规范指定了其消息处理和分发。[表68-13](ch68s06.html#snmp_version__snmpv_general_messag-id001
    "表68-13. SNMP版本3 (SNMPv3)通用消息格式")描述了SNMPv3消息格式，并在[图68-10](ch68s06.html#snmpv3_general_message_format
    "图68-10. SNMPv3通用消息格式")中进行了说明。
- en: '![SNMPv3 general message format](httpatomoreillycomsourcenostarchimages288255.png.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![SNMPv3通用消息格式](httpatomoreillycomsourcenostarchimages288255.png.jpg)'
- en: Figure 68-10. SNMPv3 general message format
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-10. SNMPv3通用消息格式
- en: Table 68-13. SNMP Version 3 (SNMPv3) General Message Format
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 表68-13. SNMP版本3 (SNMPv3)通用消息格式
- en: '| Field Name | Syntax | Size (Bytes) | Description |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 语法 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Msg Version | Integer | 4 | Message Version Number: Describes the SNMP version
    number of this message; used for ensuring compatibility between versions. For
    SNMPv3, this value is 3. |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| 消息版本 | 整数 | 4 | 消息版本号：描述此消息的 SNMP 版本号；用于确保版本之间的兼容性。对于 SNMPv3，此值为 3。|'
- en: '| Msg ID | Integer | 4 | Message Identifier: A number used to identify an SNMPv3
    message and to match response messages to request messages. The use of this field
    is similar to that of the Request ID field in the SNMPv2 PDU format (see [Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001
    "Table 68-10. SNMPv2 Common PDU Format")), but they are not identical. This field
    was created to allow matching at the message-processing level, regardless of the
    contents of the PDU, to protect against certain security attacks. Thus, Msg ID
    and Request ID are used independently. |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| 消息标识符 | 整数 | 4 | 消息标识符：用于识别 SNMPv3 消息并将响应消息与请求消息匹配的数字。此字段的使用方式类似于 SNMPv2
    PDU 格式中的请求 ID 字段（参见 [表 68-10](ch68s05.html#snmpv_common_pdu_format-id001 "表 68-10.
    SNMPv2 Common PDU Format")），但它们并不相同。创建此字段是为了允许在消息处理级别进行匹配，而不管 PDU 的内容如何，以防止某些安全攻击。因此，Msg
    ID 和 Request ID 是独立使用的。|'
- en: '| Msg Max Size | Integer | 4 | Maximum Message Size: The maximum size of message
    that the sender of this message can receive. Minimum value of this field is 484.
    |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| 消息最大大小 | 整数 | 4 | 最大消息大小：发送此消息的发送者可以接收的消息的最大大小。此字段的最低值为 484。|'
- en: '| Msg Flags | Octet String | 1 | Message Flags: A set of flags that controls
    processing of the message. The current substructure of this field is shown in
    [Table 68-14](ch68s06.html#snmpv_msg_flags_subfields "Table 68-14. SNMPv3 Msg
    Flags Subfields"). |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| 消息标志 | 字节串 | 1 | 消息标志：控制消息处理的标志集。此字段的当前子结构在 [表 68-14](ch68s06.html#snmpv_msg_flags_subfields
    "表 68-14. SNMPv3 Msg Flags Subfields") 中显示。|'
- en: '| Msg Security Model | Integer | 4 | Message Security Model: An integer value
    indicating which security model was used for this message. For the user-based
    security model (the default in SNMPv3), this value is 3. |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| 消息安全模型 | 整数 | 4 | 消息安全模型：表示用于此消息的安全模型的整数值。对于基于用户的模型（SNMPv3 中的默认值），此值为 3。|'
- en: '| Msg Security Parameters | — | Variable | Message Security Parameters: A set
    of fields that contain parameters required to implement the particular security
    model used for this message. The contents of this field are specified in each
    document describing an SNMPv3 security model. For example, the parameters for
    the user-based model are in RFC 3414. |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| 消息安全参数 | — | 可变 | 消息安全参数：包含实现此消息所使用的特定安全模型所需参数的一组字段。此字段的内容在每个描述 SNMPv3 安全模型的文档中指定。例如，基于用户的模型参数在
    RFC 3414 中。|'
- en: '| Scoped PDU | — | Variable | Scoped PDU: Contains the PDU to be transmitted,
    along with parameters that identify an SNMP context, which describes a set of
    management information accessible by a particular entity. The PDU is said to be
    *scoped* because it is applied within the scope of this context. (Yes, security
    stuff is confusing, sorry; it would take pages and pages to properly explain contexts;
    see RFC 3411.) The field may be encrypted or unencrypted depending on the value
    of *Priv Flag*. Its structure is shown in [Table 68-15](ch68s06.html#snmpv_scoped_pdu_subfields
    "Table 68-15. SNMPv3 Scoped PDU Subfields"). |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| 作用域 PDU | — | 可变 | 作用域 PDU：包含要传输的 PDU，以及标识 SNMP 上下文的参数，该上下文描述了一组特定实体可访问的管理信息。PDU
    被称为 *作用域*，因为它是在此上下文的作用域内应用的。（是的，安全内容很复杂，抱歉；要正确解释上下文需要很多页；请参阅 RFC 3411。）该字段可能根据
    *私有标志* 的值进行加密或未加密。其结构在 [表 68-15](ch68s06.html#snmpv_scoped_pdu_subfields "表 68-15.
    SNMPv3 Scoped PDU Subfields") 中显示。|'
- en: Table 68-14. SNMPv3 Msg Flags Subfields
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 表 68-14. SNMPv3 消息标志子字段
- en: '| Subfield Name | Size (Bits) | Description |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Reserved | 5 | Reserved: Reserved for future use. |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 5 | 保留：供将来使用。|'
- en: '| Reportable Flag | 1 | Reportable Flag: When set to 1, a device receiving
    this message must send back a Report-PDU whenever conditions arise where such
    a PDU should be generated. |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| 可报告标志 | 1 | 可报告标志：当设置为 1 时，接收此消息的设备必须在出现应生成此类 PDU 的条件时发送回 Report-PDU。|'
- en: '| Priv Flag | 1 | Privacy Flag: When set to 1, indicates that encryption was
    used to protect the privacy of the message. May not be set to 1 unless Auth Flag
    is also set to 1. |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| 私有标志 | 1 | 私有标志：当设置为 1 时，表示已使用加密来保护消息的隐私。除非认证标志也设置为 1，否则不得设置为 1。|'
- en: '| Auth Flag | 1 | Authentication Flag: When set to 1, indicates that authentication
    was used to protect the authenticity of this message. |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| 认证标志 | 1 | 认证标志：当设置为1时，表示已使用认证来保护此消息的真实性。 |'
- en: Table 68-15. SNMPv3 Scoped PDU Subfields
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 68-15. SNMPv3范围PDU子字段
- en: '| Subfield Name | Syntax | Size | Description |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 语法 | 大小 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Context Engine ID | Octet String | Variable | Used to identify to which application
    the PDU will be sent for processing. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| 上下文引擎ID | 八位字节字符串 | 变量 | 用于标识PDU将被发送到哪个应用程序进行处理。 |'
- en: '| Context Name | Octet String | Variable | An object identifier specifying
    the particular context associated with this PDU. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| 上下文名称 | 八位字节字符串 | 变量 | 一个对象标识符，指定与该PDU关联的特定上下文。 |'
- en: '| PDU | — | Variable | The protocol data unit being transmitted. |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| PDU | — | 变量 | 正在传输的协议数据单元。 |'
- en: Fortunately, SNMPv3 uses the protocol operations from SNMPv2, as described in
    RFC 3416, which is just an update of RFC 1904\. Thus, the PDU formats for SNMPv3
    are the same as those of SNMPv2 (see Tables [Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001
    "Table 68-10. SNMPv2 Common PDU Format") through [Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format") and Figures [Figure 68-8](ch68s05.html#snmpv2_common_pdu_format
    "Figure 68-8. SNMPv2 common PDU format") and [Figure 68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "Figure 68-9. SNMPv2 GetBulkRequest-PDU format")).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SNMPv3使用了SNMPv2的协议操作，如RFC 3416所述，这只是RFC 1904的更新。因此，SNMPv3的PDU格式与SNMPv2相同（见表格[Table 68-10](ch68s05.html#snmpv_common_pdu_format-id001
    "Table 68-10. SNMPv2 Common PDU Format")至[Table 68-12](ch68s05.html#snmpv_getbulkrequest-pdu_format
    "Table 68-12. SNMPv2 GetBulkRequest-PDU Format")和图[Figure 68-8](ch68s05.html#snmpv2_common_pdu_format
    "Figure 68-8. SNMPv2 common PDU format")和[Figure 68-9](ch68s05.html#snmpv2_getbulkrequest-pdu_format
    "Figure 68-9. SNMPv2 GetBulkRequest-PDU format"))。
- en: Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第69章. TCP/IP远程网络监控（RMON）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: We've seen in the preceding chapters of this part that the Simple Network Management
    Protocol (SNMP) defines both a framework and a specific protocol for exchanging
    network information on a TCP/IP internetwork. The general model used by SNMP is
    that of a network management station (NMS) that sends requests to SNMP agents
    running on managed devices. The SNMP agents may also initiate certain types of
    communication by sending *trap* messages to tell the NMS when particular events
    occur.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的先前章节中，我们已经看到简单网络管理协议（SNMP）定义了在TCP/IP互联网上交换网络信息的框架和特定协议。SNMP使用的一般模型是网络管理站（NMS）向运行在受管理设备上的SNMP代理发送请求。SNMP代理还可以通过发送*trap*消息来启动某些类型的通信，告知NMS何时发生特定事件。
- en: This model works well, which is why SNMP has become so popular. However, one
    fundamental limitation of the protocol and the model it uses is that it is oriented
    around the communication of network information from SNMP agents that are normally
    part of regular TCP/IP devices, such as hosts and routers. The amount of information
    gathered by these devices is usually somewhat limited, because obviously hosts
    and routers have real work to do—that is, doing the jobs of being hosts and routers.
    They can't devote themselves to network management tasks.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型运行良好，这也是为什么SNMP如此受欢迎的原因。然而，该协议及其使用的模型的一个基本限制是它围绕从通常是常规TCP/IP设备（如主机和路由器）的SNMP代理通信网络信息。这些设备收集的信息通常有限，因为显然主机和路由器有实际的工作要做——即执行主机和路由器的任务。它们不能全身心投入网络管理任务。
- en: Thus, in situations where more information is needed about a network than is
    gathered by traditional devices, administrators often use special hardware units
    called *network analyzers*, *monitors*, or *probes*. These are dedicated pieces
    of equipment that are connected to a network and used strictly for the purpose
    of gathering statistics and watching for events of interest or concern to the
    administrator. It would obviously be very useful if these devices could use SNMP
    to allow the information they gather to be retrieved, and to let them generate
    traps when they notice something important. To enable this, the *Remote Network
    Monitoring (RMON)* specification was created.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在需要比传统设备收集的更多信息的情况下，管理员通常会使用称为*网络分析仪*、*监控器*或*探针*的特殊硬件单元。这些是专门用于连接到网络并严格用于收集统计数据和监视管理员感兴趣或关注的事件的设备。如果这些设备能够使用SNMP来允许检索它们收集的信息，并在它们注意到重要事项时生成陷阱，显然会非常有用。为了实现这一点，创建了*远程网络监控（RMON）*规范。
- en: RMON Standards
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RMON标准
- en: RMON is often called a protocol, and you will sometimes see SNMP and RMON referred
    to as the TCP/IP network management protocols. However, RMON really isn't a separate
    protocol at all—it defines no protocol operations. RMON is actually part of SNMP,
    and the RMON specification is simply a management information base (MIB) module
    that defines a particular set of MIB objects for use by network monitoring probes.
    Architecturally, it is just one of the many MIB modules that compose the SNMP
    Framework.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: RMON通常被称为一种协议，有时你会看到SNMP和RMON被提及为TCP/IP网络管理协议。然而，RMON实际上根本不是一种独立的协议——它不定义任何协议操作。RMON实际上是SNMP的一部分，RMON规范实际上是一个管理信息库（MIB）模块，它定义了一组特定的MIB对象，供网络监控探针使用。从架构上讲，它只是组成SNMP框架的许多MIB模块之一。
- en: Tip
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** SNMP *Remote Network Monitoring (RMON)* was created to enable
    the efficient management of networks using dedicated management devices such as
    network analyzers, monitors, or probes. RMON is often called a protocol, but it
    does not define any new protocol operations. It is actually an MIB module for
    SNMP that describes objects that permit advanced network management capabilities.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** SNMP *远程网络监控（RMON）*的创建是为了能够使用如网络分析仪、监控器或探针等专用管理设备有效地管理网络。RMON通常被称为一种协议，但它并不定义任何新的协议操作。它实际上是一个SNMP的MIB模块，描述了允许高级网络管理功能的对象。'
- en: The first standard documenting RMON was RFC 1271, "Remote Network Monitoring
    Management Information Base," published in 1991\. RFC 1271 was replaced by RFC
    1757 in 1995, which made a couple of changes to the specification. RFC 2819, published
    in May 2000, updates RMON to use the new Structure of Management Information version
    2 (SMIv2) specification that is part of SNMPv2 but is functionally the same as
    RFC 1757.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 记录RMON的第一个标准是RFC 1271，“远程网络监控管理信息库”，于1991年发布。RFC 1271在1995年被RFC 1757取代，该规范进行了一些更改。2000年5月发布的RFC
    2819更新了RMON，使其使用新的结构化管理信息版本2（SMIv2）规范，该规范是SNMPv2的一部分，但在功能上与RFC 1757相同。
- en: RMON MIB Hierarchy and Object Groups
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RMON MIB层次结构和对象组
- en: Since RMON is a MIB module, it consists almost entirely of descriptions for
    MIB objects, each with the standard characteristics belonging to all such objects.
    All the objects within RMON are arranged into the SNMP object name hierarchy within
    the *rmon* group, which is group number 16 within the SNMP mib (mib-2) object
    tree, 1.3.6.1.2.1\. So, all RMON objects have identifiers starting with 1.3.6.1.2.1.16\.
    This single RMON group is broken down into several lower-level groups that provide
    more structure for the RMON objects defined by the specification. [Figure 69-1](ch69s02.html#snmp_remote_network_monitoring_rmon_mib_
    "Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a
    special MIB module, rmon(16), which fits into the overall SNMP object hierarchy
    tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such
    as sys(1) and if(2); see Figure 66-2 in Chapter 66\. Within this group, which
    has the group identifier 1.3.6.1.2.1.16, are nine subgroups of RMON objects.")
    shows this structure.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RMON 是一个 MIB 模块，它几乎完全由 MIB 对象的描述组成，每个对象都具有所有此类对象的标准特征。RMON 中的所有对象都排列在 *rmon*
    组中的 SNMP 对象名称层次结构中，该组是 SNMP mib（mib-2）对象树中的第 16 组，1.3.6.1.2.1\. 因此，所有 RMON 对象的标识符都以
    1.3.6.1.2.1.16 开头。这个单一的 RMON 组被分解为几个更底层的组，为规范定义的 RMON 对象提供更多结构。 [图 69-1](ch69s02.html#snmp_remote_network_monitoring_rmon_mib_
    "图 69-1. SNMP 远程网络监控 (RMON) MIB 层次结构 RMON 使用一个特殊的 MIB 模块，rmon(16)，它适合于 mgmt(2)
    下的 mib/mib-2(1) 总体 SNMP 对象层次树中——就像其他 MIB 对象组，如 sys(1) 和 if(2)；参见图 66-2。在这个组中，该组的标识符为
    1.3.6.1.2.1.16，有九个子组属于 RMON 对象。") 展示了这种结构。
- en: '[Table 69-1](ch69s02.html#snmp_rmon_mib_object_groups "Table 69-1. SNMP RMON
    MIB Object Groups") describes each of the RMON groups, showing its name, group
    code (which is used as the prefix for object descriptors in the group), and RMON
    group number and SNMP object hierarchy identifier.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 69-1](ch69s02.html#snmp_rmon_mib_object_groups "表 69-1. SNMP RMON MIB 对象组")
    描述了每个 RMON 组，显示了其名称、组代码（在组中用作对象描述符的前缀）以及 RMON 组编号和 SNMP 对象层次标识符。'
- en: '![SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a special MIB
    module, rmon(16), which fits into the overall SNMP object hierarchy tree under
    mib/mib-2(1) within mgmt(2)—just like other MIB object groups such as sys(1) and
    if(2); see in . Within this group, which has the group identifier 1.3.6.1.2.1.16,
    are nine subgroups of RMON objects.](httpatomoreillycomsourcenostarchimages288257.png.jpg)'
  id: totrans-735
  prefs: []
  type: TYPE_IMG
  zh: '![SNMP 远程网络监控 (RMON) MIB 层次结构 RMON 使用一个特殊的 MIB 模块，rmon(16)，它适合于 mgmt(2) 下的
    mib/mib-2(1) 总体 SNMP 对象层次树中——就像其他 MIB 对象组，如 sys(1) 和 if(2)；参见 . 在这个组中，该组的标识符为
    1.3.6.1.2.1.16，有九个子组属于 RMON 对象。](httpatomoreillycomsourcenostarchimages288257.png.jpg)'
- en: Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a
    special MIB module, rmon(16), which fits into the overall SNMP object hierarchy
    tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such
    as sys(1) and if(2); see [Figure 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram
    shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types
    of objects to be universally represented. The path within this larger tree to
    the tree branches relevant to SNMP can be found by following the shaded boxes.
    The two subtrees used for SNMP are shown as the hatched boxes under internet(1).
    Each contains its own substructure (some of which is illustrated here) defining
    thousands of different MIB objects. The branch on the left side is used for generic
    MIB objects and the one on the right for private ones. A separate hierarchy is
    also defined for SNMPv2.") in [Chapter 66](ch66.html "Chapter 66. TCP/IP STRUCTURE
    OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)"). Within
    this group, which has the group identifier 1.3.6.1.2.1.16, are nine subgroups
    of RMON objects.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 图 69-1. SNMP 远程网络监控 (RMON) MIB 层次结构 RMON 使用一个特殊的 MIB 模块，rmon(16)，它适合于 mgmt(2)
    下的 mib/mib-2(1) 总体 SNMP 对象层次树中——就像其他 MIB 对象组，如 sys(1) 和 if(2)；参见 [图 66-2](ch66s03.html#global_object_name_hierarchy_and_snmp_mi
    "图 66-2. 全局对象名称层次结构和 SNMP MIB 层次结构 此图显示了 ISO 和 CCITT (ITU) 定义的由对象名称层次结构，以允许所有类型的对象被普遍表示。可以通过跟随阴影框找到此较大树中与
    SNMP 相关的树分支。用于 SNMP 的两个子树显示为 internet(1) 下的网状框。每个都包含自己的子结构（其中一些在此处展示）定义了数千个不同的
    MIB 对象。左侧的分支用于通用 MIB 对象，右侧的用于私有对象。还定义了一个单独的层次结构用于 SNMPv2。") 在 [第 66 章](ch66.html
    "第 66 章. TCP/IP 管理信息结构 (SMI) 和管理信息库 (MIBs)") 中。在这个组中，该组的标识符为 1.3.6.1.2.1.16，有九个子组属于
    RMON 对象。
- en: Table 69-1. SNMP RMON MIB Object Groups
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 表 69-1. SNMP RMON MIB 对象组
- en: '| RMON Group Name | RMON Group Code | RMON Group Number | Full Group Identifier
    | Description |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| RMON 组名称 | RMON 组代码 | RMON 组编号 | 完整组标识符 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| statistics | etherStats | 1 | 1.3.6.1.2.1.16.1 | This group contains objects
    that keep track of network statistics measured by the device. Statistics may include
    network traffic load, average packet size, number of broadcasts observed, counts
    of errors that have occurred, the number of packets in various size ranges, and
    so forth. |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| statistics | etherStats | 1 | 1.3.6.1.2.1.16.1 | 此组包含跟踪设备测量的网络统计信息的对象。统计信息可能包括网络流量负载、平均数据包大小、观察到的广播数量、发生的错误计数、各种大小范围内的数据包数量等。|'
- en: '| history | history, etherHistory | 2 | 1.3.6.1.2.1.16.2 | The history group
    contains a single table object that controls how often statistical data is sampled
    by the probe. The additional etherHistory group is optional and contains extra
    Ethernet-specific information; it is contained logically within the history group.
    |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| history | history, etherHistory | 2 | 1.3.6.1.2.1.16.2 | 历史组包含一个控制探针采样统计数据的频率的单个表对象。额外的
    etherHistory 组是可选的，包含额外的以太网特定信息；它逻辑上包含在历史组中。|'
- en: '| alarm | alarm | 3 | 1.3.6.1.2.1.16.3 | This group defines the parameters
    under which an alarm may be generated to inform an administrator of an occurrence
    of import. The alarm group contains a table that describes the thresholds that
    will cause an event to be triggered (see the event group description in this table).
    |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| alarm | alarm | 3 | 1.3.6.1.2.1.16.3 | 此组定义了可能生成警报以通知管理员发生导入的参数。警报组包含一个表，描述将触发事件的阈值（请参阅此表中的事件组描述）。|'
- en: '| hosts | host | 4 | 1.3.6.1.2.1.16.4 | This group contains objects that keep
    track of information for each host on a network. |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| hosts | host | 4 | 1.3.6.1.2.1.16.4 | 此组包含跟踪网络中每个主机信息的对象。|'
- en: '| hostsTopN | hostTopN | 5 | 1.3.6.1.2.1.16.5 | This group contains objects
    that facilitate reporting of hosts sorted in a particular way. The administrator
    determines how these ordered statistics are tracked. For example, an administrator
    could generate a report listing hosts sorted by the number of packets transmitted,
    showing the most active devices. |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| hostsTopN | hostTopN | 5 | 1.3.6.1.2.1.16.5 | 此组包含便于按特定方式报告主机的对象。管理员确定如何跟踪这些有序统计信息。例如，管理员可以生成一个报告，列出按发送数据包数量排序的主机，显示最活跃的设备。|'
- en: '| matrix | matrix | 6 | 1.3.6.1.2.1.16.6 | This group keeps track of statistics
    for data exchanges between particular pairs of hosts. The amount of data sent
    between any two devices on the network could be tracked here. Since a large network
    could have thousands of such device pairs, to conserve resources on the probe,
    often only the most recent conversations between device pairs are kept in the
    MIB. |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| 矩阵 | 矩阵 | 6 | 1.3.6.1.2.1.16.6 | 此组跟踪特定对主机之间数据交换的统计数据。网络中任何两个设备之间发送的数据量可以在此处跟踪。由于大型网络可能有数千个此类设备对，为了在探针上节省资源，通常只保留设备对之间最近的对话记录在MIB中。|'
- en: '| filter | filter | 7 | 1.3.6.1.2.1.16.7 | This group allows an administrator
    to set up filters that control what sorts of network packets the probe will capture.
    |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| filter | filter | 7 | 1.3.6.1.2.1.16.7 | 此组允许管理员设置过滤器，以控制探针将捕获哪些类型的网络数据包。|'
- en: '| capture | buffer, capture | 8 | 1.3.6.1.2.1.16.8 | This group is used to
    allow a probe to capture packets based on particular parameters set up in the
    filter group. |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| capture | buffer, capture | 8 | 1.3.6.1.2.1.16.8 | 此组用于允许探针根据在过滤器组中设置的特定参数捕获数据包。|'
- en: '| event | event | 9 | 1.3.6.1.2.1.16.9 | When a particular alarm is triggered
    based on the parameters in the objects in the alarm group, an event is generated.
    This group controls how these events are processed, including creating and sending
    an SNMP trap message to an NMS. |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 事件 | 9 | 1.3.6.1.2.1.16.9 | 当基于警报组中对象的参数触发特定警报时，将生成一个事件。此组控制这些事件的处理方式，包括创建并发送SNMP陷阱消息到NMS。|'
- en: The original RMON standard was heavily oriented around Ethernet local area networks
    (LANs), and you can see some of that in [Table 69-1](ch69s02.html#snmp_rmon_mib_object_groups
    "Table 69-1. SNMP RMON MIB Object Groups"). Probes can also gather and report
    information related to other networking technologies by using other RMON groups
    created for that purpose. The best example of this was the definition of a set
    of groups specifically for Token Ring, which was defined in RFC 1513 in 1993.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的RMON标准主要针对以太网局域网（LANs），您可以在[表69-1](ch69s02.html#snmp_rmon_mib_object_groups
    "表69-1. SNMP RMON MIB 对象组")中看到一些相关内容。探测器也可以通过使用为该目的创建的其他RMON组来收集和报告与其它网络技术相关的信息。这方面的最佳例子是1993年RFC
    1513中定义的一组专门针对令牌环的组。
- en: RMON Alarms, Events, and Statistics
  id: totrans-750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RMON警报、事件和统计信息
- en: Alarms and events are particularly useful constructs in RMON, as they allow
    the immediate communication of important information to an NMS. The administrator
    has full control over what conditions will cause an alarm to be sounded and how
    an event is generated. This includes specifying which variables or statistics
    to monitor, how often to check them, and what values will trigger an alarm. A
    log entry may also be recorded when an event occurs. If an event results in transmission
    of a trap message, the administrator will thus be notified and can decide how
    to respond, depending on the severity of the event.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 警报和事件在RMON中特别有用，因为它们允许将重要信息立即传达给NMS。管理员可以完全控制哪些条件会导致警报响起以及事件是如何产生的。这包括指定要监控哪些变量或统计信息，多久检查一次，以及哪些值会触发警报。当事件发生时，也可能记录一条日志条目。如果事件导致发送陷阱消息，管理员将因此被通知，并可以根据事件的严重性决定如何响应。
- en: Like all MIB modules and groups, a particular manufacturer may decide which
    RMON groups to implement. However, certain groups—such as alarm and event—are
    related, and some groups—such as statistics—are usually implemented in all RMON
    probes. Obviously, when RMON is used, the NMS must be aware of RMON groups and
    must allow a network management application to be run that will exploit the capabilities
    of the RMON MIB objects.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有MIB模块和组一样，特定的制造商可能决定实现哪些RMON组。然而，某些组——如警报和事件——是相关的，而某些组——如统计信息——通常在所有RMON探测器中实现。显然，当使用RMON时，NMS必须了解RMON组，并允许运行一个网络管理应用程序来利用RMON
    MIB对象的功能。
