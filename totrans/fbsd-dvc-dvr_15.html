<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;USB Drivers"><div class="titlepage"><div><div><h1 class="title"><a id="usb_drivers"/>Chapter 15. USB Drivers</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id15"/><div class="mediaobject"><a id="I_mediaobject15_d1e26247"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p><span class="emphasis"><em>Universal Serial Bus (USB)</em></span> is a connection protocol between a host controller (such as a personal computer) and a peripheral device. It was designed to replace a wide range of slow buses—the parallel port, serial port, and PS/2 connector—with a single bus that all devices could connect to (Corbet et al., 2005).<a class="indexterm" id="IDX-CHP-15-0001"/><a class="indexterm" id="IDX-CHP-15-0002"/></p><p>As described in the official USB documentation, available at <a class="ulink" href="http://www.usb.org/developers/">http://www.usb.org/developers/</a>, USB devices are hideously complex. Fortunately, FreeBSD provides a <span class="emphasis"><em>USB module</em></span> to handle most of the complexity. This chapter describes the interactions between the USB module and drivers. But first, some background on USB devices is needed.</p><div class="sect1" title="About USB Devices"><div class="titlepage"><div><div><h1 class="title"><a id="about_usb_devices"/>About USB Devices</h1></div></div></div><p>Communication between a USB host controller and a USB device occurs through a pipe (Orwick and Smith, 2007). A <span class="emphasis"><em>pipe</em></span> connects the host controller to an endpoint on a device. USB devices can have up to 32 endpoints. Each <span class="emphasis"><em>endpoint</em></span> performs a specific communication-related operation for a device, such as receiving commands or transferring data. An endpoint can be one of four types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Control</p></li><li class="listitem"><p>Interrupt</p></li><li class="listitem"><p>Bulk</p></li><li class="listitem"><p>Isochronous</p></li></ul></div><p><span class="emphasis"><em>Control endpoints</em></span> are used to send and receive information of a control nature (Oney, 2003). They are commonly used for configuring the device, issuing device commands, retrieving device information, and so on. Control transactions are guaranteed to succeed by the USB protocol. All USB devices have a control endpoint named endpoint 0.<a class="indexterm" id="IDX-CHP-15-0003"/><a class="indexterm" id="IDX-CHP-15-0004"/></p><p><span class="emphasis"><em>Interrupt endpoints</em></span> transfer small amounts of data at a fixed rate. See, USB devices cannot interrupt their host in the traditional sense—they don’t have an asynchronous interrupt. Instead, USB devices provide interrupt endpoints, which are polled periodically. These endpoints are the main transport method for USB keyboards and mice (Corbet et al., 2005). Interrupt transactions are guaranteed to succeed by the USB protocol.<a class="indexterm" id="IDX-CHP-15-0005"/></p><p><span class="emphasis"><em>Bulk endpoints</em></span> transfer large amounts of data. Bulk transactions are lossless. However, they are not guaranteed by the USB protocol to complete in a specific amount of time. Bulk endpoints are common on printers, mass storage devices, and network devices.<a class="indexterm" id="IDX-CHP-15-0006"/></p><p><span class="emphasis"><em>Isochronous endpoints</em></span> periodically transfer large amounts of data. Isochronous transactions can be lossy. As such, these endpoints are used in devices that can handle data loss but rely on keeping a constant stream of data flowing, such as audio and video devices (Corbet et al., 2005).<a class="indexterm" id="IDX-CHP-15-0007"/></p></div></div>
<div class="sect1" title="More About USB Devices"><div class="titlepage"><div><div><h1 class="title"><a id="more_about_usb_devices"/>More About USB Devices</h1></div></div></div><p>The endpoints on a USB device are grouped into <span class="emphasis"><em>interfaces</em></span>. For example, a USB speaker might define one group of endpoints as the interface for the buttons and another group of endpoints as the interface for the audio stream.<a class="indexterm" id="IDX-CHP-15-0008"/></p><p>All interfaces have one or more alternate settings. An <span class="emphasis"><em>alternate setting</em></span> defines the parameters of the interface. For example, a lossy audio stream interface may have several alternate settings that provide increasing levels of audio quality at the cost of additional bandwidth. Naturally, only one alternate setting can be active at a time.<a class="indexterm" id="IDX-CHP-15-0009"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The term “alternate setting” is kind of a misnomer, as the default interface setting is the first alternate setting.</p></div><p><a class="xref" href="ch15s02.html#an_example_usb_device_layout" title="Figure 15-1. An example USB device layout">Figure 15-1</a> depicts the relationship between endpoints, interfaces, and alternate settings.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-1" id="CHP-15-FN-1">10</a>]</sup><a class="indexterm" id="IDX-CHP-15-0010"/><a class="indexterm" id="IDX-CHP-15-0011"/><a class="indexterm" id="IDX-CHP-15-0012"/><a class="indexterm" id="IDX-CHP-15-0013"/></p><div class="figure"><a id="an_example_usb_device_layout"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject15_d1e26375"/><img alt="An example USB device layout" src="httpatomoreillycomsourcenostarchimages1137521.png.jpg"/></div></div><p class="title">Figure 15-1. An example USB device layout</p></div><p>As you can see, an endpoint cannot be shared among interfaces, but it can be used in multiple alternate settings within one interface. Also, each alternate setting can have a different number of endpoints. Note that endpoint 0, the default control endpoint, is not part of any interface.</p><p>A group of interfaces is known as a <span class="emphasis"><em>device configuration</em></span>, or simply a <span class="emphasis"><em>configuration</em></span>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-1" id="ftn.CHP-15-FN-1">10</a>] </sup><a class="xref" href="ch15s02.html#an_example_usb_device_layout" title="Figure 15-1. An example USB device layout">Figure 15-1</a> is adapted from <span class="emphasis"><em>Developing Drivers with the Windows Driver Foundation</em></span> by Penny Orwick and Guy Smith (Microsoft Press, 2007).</p></div></div></div>
<div class="sect1" title="USB Configuration Structures"><div class="titlepage"><div><div><h1 class="title"><a id="usb_configuration_structures"/>USB Configuration Structures</h1></div></div></div><p>In FreeBSD, <code class="literal">usb_config</code> structures are used to find and communicate with individual endpoints. <code class="literal">struct usb_config</code> is defined in the <code class="literal">&lt;dev/usb/usbdi.h&gt;</code> header as follows:</p><a id="I_programlisting15_d1e26404"/><pre class="programlisting">struct usb_config {
        /* USB Module Private Data */
        enum usb_hc_mode        usb_mode;

        /* Mandatory Fields */
        uint8_t                 type;
        uint8_t                 endpoint;
        uint8_t                 direction;
        usb_callback_t         *callback;
        usb_frlength_t          bufsize;

        /* Optional Fields */
        usb_timeout_t           timeout;
        usb_timeout_t           interval;
        usb_frcount_t           frames;
        uint8_t                 ep_index;
        uint8_t                 if_index;

        /* USB Transfer Flags */
        struct usb_xfer_flags   flags;
};</pre><p>Many of the fields in <code class="literal">struct usb_config</code> must be initialized by a USB driver. These fields are described in the following sections.<a class="indexterm" id="IDX-CHP-15-0014"/><a class="indexterm" id="IDX-CHP-15-0015"/><a class="indexterm" id="IDX-CHP-15-0016"/><a class="indexterm" id="IDX-CHP-15-0017"/><a class="indexterm" id="IDX-CHP-15-0018"/><a class="indexterm" id="IDX-CHP-15-0019"/><a class="indexterm" id="IDX-CHP-15-0020"/><a class="indexterm" id="IDX-CHP-15-0021"/><a class="indexterm" id="IDX-CHP-15-0022"/><a class="indexterm" id="IDX-CHP-15-0023"/><a class="indexterm" id="IDX-CHP-15-0024"/><a class="indexterm" id="IDX-CHP-15-0025"/><a class="indexterm" id="IDX-CHP-15-0026"/><a class="indexterm" id="IDX-CHP-15-0027"/><a class="indexterm" id="IDX-CHP-15-0028"/></p><div class="sect2" title="Mandatory Fields"><div class="titlepage"><div><div><h2 class="title"><a id="mandatory_fields"/>Mandatory Fields</h2></div></div></div><p>The <code class="literal">type</code> field specifies the endpoint type. Valid values for this field are <code class="literal">UE_CONTROL</code>, <code class="literal">UE_BULK</code>, <code class="literal">UE_INTERRUPT</code>, and <code class="literal">UE_ISOCHRONOUS</code>.</p><p>The <code class="literal">endpoint</code> field specifies the endpoint number. A value of <code class="literal">UE_ADDR_ANY</code> suggests that the endpoint number is unimportant—the other fields are used to find the correct endpoint.</p><p>The <code class="literal">direction</code> field specifies the endpoint direction. Valid values for this field are shown in <a class="xref" href="ch15s03.html#usb_endpoint_direction_symbolic_constant" title="Table 15-1. USB Endpoint Direction Symbolic Constants">Table 15-1</a>.</p><div class="table"><a id="usb_endpoint_direction_symbolic_constant"/><p class="title">Table 15-1. USB Endpoint Direction Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="USB Endpoint Direction Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_DIR_IN</code></p></td><td style="text-align: left" valign="top"><p>Stipulates that the endpoint be an IN endpoint; that is, the endpoint transfers data to the host from the device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_DIR_OUT</code></p></td><td style="text-align: left" valign="top"><p>Stipulates that the endpoint be an OUT endpoint; that is, the endpoint transfers data to the device from the host</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_DIR_ANY</code></p></td><td style="text-align: left" valign="top"><p>Stipulates that the endpoint support bidirectional transfers</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The direction of an endpoint is from the host’s perspective.</p></div><p>The <code class="literal">callback</code> field denotes a mandatory callback function. This function is executed before and after the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code> transfers data. We’ll discuss this function further in <a class="xref" href="ch15s04.html" title="USB Transfers (in FreeBSD)">USB Transfers (in FreeBSD)</a> in <a class="xref" href="ch15s04.html" title="USB Transfers (in FreeBSD)">USB Transfers (in FreeBSD)</a>.</p><p>The <code class="literal">bufsize</code> field denotes the buffer size for the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code>. As you would expect, <code class="literal">bufsize</code> is used for <code class="literal">type</code> transactions.</p><p>As this section’s heading implies, the preceding fields must be defined in every <code class="literal">usb_config</code> structure.</p></div><div class="sect2" title="Optional Fields"><div class="titlepage"><div><div><h2 class="title"><a id="optional_fields"/>Optional Fields</h2></div></div></div><p>The <code class="literal">timeout</code> field sets the transaction timeout in milliseconds. If <code class="literal">timeout</code> is <code class="literal">0</code> or undefined and <code class="literal">type</code> is <code class="literal">UE_ISOCHRONOUS</code>, then a timeout of 250 ms will be used.</p><p>The <code class="literal">interval</code> field’s meaning is based on the value of <code class="literal">type</code>. <a class="xref" href="ch15s03.html#intervalas_purpose_open_parenthesis_base" title="Table 15-2. interval’s Purpose (Based on Endpoint Type)">Table 15-2</a> details <code class="literal">interval</code>’s purpose (based on <code class="literal">type</code>).<a class="indexterm" id="IDX-CHP-15-0029"/><a class="indexterm" id="IDX-CHP-15-0030"/><a class="indexterm" id="IDX-CHP-15-0031"/><a class="indexterm" id="IDX-CHP-15-0032"/><a class="indexterm" id="IDX-CHP-15-0033"/><a class="indexterm" id="IDX-CHP-15-0034"/><a class="indexterm" id="IDX-CHP-15-0035"/><a class="indexterm" id="IDX-CHP-15-0036"/><a class="indexterm" id="IDX-CHP-15-0037"/><a class="indexterm" id="IDX-CHP-15-0038"/><a class="indexterm" id="IDX-CHP-15-0039"/><a class="indexterm" id="IDX-CHP-15-0040"/></p><div class="table"><a id="intervalas_purpose_open_parenthesis_base"/><p class="title">Table 15-2. interval’s Purpose (Based on Endpoint Type)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="interval’s Purpose (Based on Endpoint Type)"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Endpoint Type</p></th><th style="text-align: left" valign="bottom"><p>What interval Does</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_CONTROL</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">interval</code> sets the transaction delay in milliseconds; in other words, <code class="literal">interval</code> milliseconds must pass before a control transaction can occur</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_INTERRUPT</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">interval</code> sets the polling rate in milliseconds; in other words, the host controller will poll the interrupt endpoint every <code class="literal">interval</code> milliseconds; if <code class="literal">interval</code> is <code class="literal">0</code> or undefined, then the endpoint’s default polling rate will be used</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_BULK</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">interval</code> does nothing for bulk endpoints</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">UE_ISOCHRONOUS</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">interval</code> does nothing for isochronous endpoints</p></td></tr></tbody></table></div></div><p>The <code class="literal">frames</code> field denotes the maximum number of USB frames that the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code> supports. In FreeBSD, <span class="emphasis"><em>USB frames</em></span> are simply “data packets” that travel to or from an endpoint. USB frames are composed of one or more <span class="emphasis"><em>USB packets</em></span>, which actually contain the data.<a class="indexterm" id="IDX-CHP-15-0041"/><a class="indexterm" id="IDX-CHP-15-0042"/></p><p>The <code class="literal">ep_index</code> field demands a non-negative integer. If multiple endpoints are identified by type, endpoint, and direction—which can occur when endpoint is <code class="literal">UE_ADDR_ANY</code>—the value of <code class="literal">ep_index</code> will be used to select one.</p><p>The <code class="literal">if_index</code> field specifies the interface number (based on the <code class="literal">ifaces</code> argument passed to <code class="literal">usbd_transfer_setup</code>, which is described in <a class="xref" href="ch15s05.html" title="USB Configuration Structure Management Routines">USB Configuration Structure Management Routines</a> in <a class="xref" href="ch15s05.html" title="USB Configuration Structure Management Routines">USB Configuration Structure Management Routines</a>).</p></div><div class="sect2" title="USB Transfer Flags"><div class="titlepage"><div><div><h2 class="title"><a id="usb_transfer_flags"/>USB Transfer Flags</h2></div></div></div><p>The <code class="literal">flags</code> field sets the transactional properties for the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code>. This field expects a <code class="literal">usb_xfer_flags</code> structure.</p><p><code class="literal">struct usb_xfer_flags</code> is defined in the <code class="literal">&lt;dev/usb/usbdi.h&gt;</code> header as follows:</p><a id="I_programlisting15_d1e26818"/><pre class="programlisting">struct usb_xfer_flags {
        uint8_t force_short_xfer : 1;
        uint8_t short_xfer_ok    : 1;
        uint8_t short_frames_ok  : 1;
        uint8_t pipe_bof         : 1;
        uint8_t proxy_buffer     : 1;
        uint8_t ext_buffer       : 1;
        uint8_t manual_status    : 1;
        uint8_t no_pipe_ok       : 1;
        uint8_t stall_pipe       : 1;
};</pre><p>All of the fields in struct <code class="literal">usb_xfer_flags</code> are optional. These fields are 1-bit and function as flags. They are detailed in <a class="xref" href="ch15s03.html#usb_transfer_flags-id1" title="Table 15-3. USB Transfer Flags">Table 15-3</a>.</p><div class="table"><a id="usb_transfer_flags-id1"/><p class="title">Table 15-3. USB Transfer Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="USB Transfer Flags"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Flag<a class="indexterm" id="IDX-CHP-15-0043"/><a class="indexterm" id="IDX-CHP-15-0044"/><a class="indexterm" id="IDX-CHP-15-0045"/><a class="indexterm" id="IDX-CHP-15-0046"/><a class="indexterm" id="IDX-CHP-15-0047"/><a class="indexterm" id="IDX-CHP-15-0048"/><a class="indexterm" id="IDX-CHP-15-0049"/><a class="indexterm" id="IDX-CHP-15-0050"/><a class="indexterm" id="IDX-CHP-15-0051"/><a class="indexterm" id="IDX-CHP-15-0052"/><a class="indexterm" id="IDX-CHP-15-0053"/><a class="indexterm" id="IDX-CHP-15-0054"/></p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">force_short_xfer</code></p></td><td style="text-align: left" valign="top"><p>Causes a short transfer; <span class="emphasis"><em>short transfers</em></span> basically dispatch a short USB packet, which tends to indicate “end of transaction;” this flag can be set anytime</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">short_xfer_ok</code></p></td><td style="text-align: left" valign="top"><p>Indicates that it is okay to receive short transfers; this flag can be set anytime</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">short_frames_ok</code></p></td><td style="text-align: left" valign="top"><p>Indicates that it is okay to receive gobs of short USB frames; this flag can only affect <code class="literal">UE_INTERRUPT</code> and <code class="literal">UE_BULK</code> endpoints; it can be set anytime</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">pipe_bof</code></p></td><td style="text-align: left" valign="top"><p>Causes any failed USB transactions to remain first in their queue; this guarantees that all transactions complete in FIFO order; this flag can be set anytime</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">proxy_buffer</code></p></td><td style="text-align: left" valign="top"><p>Rounds <code class="literal">bufsize</code> up to the maximum USB frame size; this flag cannot be set after driver initialization</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ext_buffer</code></p></td><td style="text-align: left" valign="top"><p>Indicates that an external DMA buffer will be used for all transactions; this flag cannot be set after driver initialization</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">manual_status</code></p></td><td style="text-align: left" valign="top"><p>Stops the handshake/status stage from occurring in control transactions; this flag can be set anytime</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">no_pipe_ok</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">USB_ERR_NO_PIPE</code> errors to be ignored; this flag cannot be set after driver initialization</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stall_pipe</code></p></td><td style="text-align: left" valign="top"><p>Causes the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code> to “stall” before each transaction; this flag can be set anytime</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>If you don’t understand some of these descriptions, don’t worry; I’ll expand on them later.</p></div></div></div>
<div class="sect1" title="USB Transfers (in FreeBSD)"><div class="titlepage"><div><div><h1 class="title"><a id="usb_transfers_open_parenthesis_in_freebs"/>USB Transfers (in FreeBSD)</h1></div></div></div><p>Recall that <code class="literal">callback</code> is executed before and after the endpoint specified by <code class="literal">type</code>, <code class="literal">endpoint</code>, and <code class="literal">direction</code> transfers data. Below is its function prototype:</p><a id="I_programlisting15_d1e26997"/><pre class="programlisting">typedef void (usb_callback_t)(<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_xfer *, usb_error_t);</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27007"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">struct usb_xfer *</code> contains the transfer state:</p><a id="I_programlisting15_d1e27016"/><pre class="programlisting">struct usb_xfer {
...
        uint8_t         usb_state;
/* Set when callback is executed before a data transfer. */
#define USB_ST_SETUP            0
/* Set when callback is executed after a data transfer. */
#define USB_ST_TRANSFERRED      1
/* Set when a transfer error occurs. */
#define USB_ST_ERROR            2
...
};</pre><p>Generally, you’d use <code class="literal">struct usb_xfer *</code> in a <code class="literal">switch</code> statement to provide a code block for each transfer state. Some example code should help clarify what I mean.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Just concentrate on the structure of this code and ignore what it does.</p></div><a id="I_programlisting15_d1e27029"/><pre class="programlisting">static void
ulpt_status_callback(<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_xfer *transfer, usb_error_t error)
{
        struct ulpt_softc *sc = usbd_xfer_softc(transfer);
        struct usb_device_request req;
        struct usb_page_cache *pc;
        uint8_t current_status, new_status;

        switch (<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>USB_GET_STATE(transfer)) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>case USB_ST_SETUP:
                req.bmRequestType = UT_READ_CLASS_INTERFACE;
                req.bRequest = UREQ_GET_PORT_STATUS;
                USETW(req.wValue, 0);
                req.wIndex[0] = sc-&gt;sc_iface_num;
                req.wIndex[1] = 0;
                USETW(req.wLength, 1);

                pc = usbd_xfer_get_frame(transfer, 0);
                usbd_copy_in(pc, 0, &amp;req, sizeof(req));
                usbd_xfer_set_frame_len(transfer, 0, sizeof(req));
                usbd_xfer_set_frame_len(transfer, 1, 1);
                usbd_xfer_set_frames(transfer, 2);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usbd_transfer_submit(transfer);

                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>case USB_ST_TRANSFERRED:
                pc = usbd_xfer_get_frame(transfer, 1);
                usbd_copy_out(pc, 0, &amp;current_status, 1);

                current_status = (current_status ^ LPS_INVERT) &amp; LPS_MASK;
                new_status = current_status &amp; ˜sc-&gt;sc_previous_status;
                sc-&gt;sc_previous_status = current_status;

                if (new_status &amp; LPS_NERR)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>log(LOG_NOTICE, "%s: output error\n",
                            device_get_nameunit(sc-&gt;sc_dev));
                else if (new_status &amp; LPS_SELECT)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>log(LOG_NOTICE, "%s: offline\n",
                            device_get_nameunit(sc-&gt;sc_dev));
                else if (new_status &amp; LPS_NOPAPER)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>log(LOG_NOTICE, "%s: out of paper\n",
                            device_get_nameunit(sc-&gt;sc_dev));

                break;
        default:
                break;
        }
}</pre><p>Notice how <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27082"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">struct usb_xfer *</code> is used as the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27091"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> expression for the <code class="literal">switch</code> statement (as you would expect, the macro <code class="literal">USB_GET_STATE</code> returns the transfer state).<a class="indexterm" id="IDX-CHP-15-0055"/><a class="indexterm" id="IDX-CHP-15-0056"/><a class="indexterm" id="IDX-CHP-15-0057"/><a class="indexterm" id="IDX-CHP-15-0058"/><a class="indexterm" id="IDX-CHP-15-0059"/><a class="indexterm" id="IDX-CHP-15-0060"/><a class="indexterm" id="IDX-CHP-15-0061"/><a class="indexterm" id="IDX-CHP-15-0062"/></p><p>The constant <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27138"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">USB_ST_SETUP</code> is set when <code class="literal">callback</code> is executed before a data transfer. This case handles any pre-transfer operations. It always ends with <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27150"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">usbd_transfer_submit</code>, which starts the data transfer.</p><p>The constant <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27161"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">USB_ST_TRANSFERRED</code> is set when <code class="literal">callback</code> is executed after a data transfer. This case performs any post-transfer actions, such as <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27173"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27179"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27186"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> printing log messages.</p></div>
<div class="sect1" title="USB Configuration Structure Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="usb_configuration_structure_management"/>USB Configuration Structure Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following functions for working with <code class="literal">usb_config</code> structures:</p><a id="I_programlisting15_d1e27200"/><pre class="programlisting">#include &lt;dev/usb/usb.h&gt;
#include &lt;dev/usb/usbdi.h&gt;
#include &lt;dev/usb/usbdi_util.h&gt;

usb_error_t
usbd_transfer_setup(struct usb_device *udev, const uint8_t *ifaces,
    <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_xfer **pxfer, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>const struct usb_config *setup_start,
    <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>uint16_t n_setup, void *priv_sc, struct mtx *priv_mtx);

void
usbd_transfer_unsetup(<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>struct usb_xfer **pxfer, <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>uint16_t n_setup);

void
usbd_transfer_start(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>struct usb_xfer *xfer);

void
usbd_transfer_stop(<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>struct usb_xfer *xfer);

void
usbd_transfer_drain(struct usb_xfer *xfer);</pre><p>The <code class="literal">usbd_transfer_setup</code> function takes an <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27250"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> array of <code class="literal">usb_config</code> structures and sets up an <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27259"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> array of <code class="literal">usb_xfer</code> structures. The <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27269"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">n_setup</code> argument denotes the number of elements in the arrays.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>As you’ll see, a <code class="literal">usb_xfer</code> structure is required to initiate a USB data transfer.</p></div><p>The <code class="literal">usbd_transfer_unsetup</code> function destroys an <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27289"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> array of <code class="literal">usb_xfer</code> structures. The <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27298"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">n_setup</code> argument denotes the number of elements in the array.</p><p>The <code class="literal">usbd_transfer_start</code> function takes a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27312"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">usb_xfer</code> structure and starts a USB transfer (that is, it executes <code class="literal">callback</code> with <code class="literal">USB_ST_SETUP</code> set).</p><p>The <code class="literal">usbd_transfer_stop</code> function stops any transfers associated with the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27332"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">xfer</code> argument (that is, it executes <code class="literal">callback</code> with <code class="literal">USB_ST_ERROR</code> set).<a class="indexterm" id="IDX-CHP-15-0063"/><a class="indexterm" id="IDX-CHP-15-0064"/><a class="indexterm" id="IDX-CHP-15-0065"/><a class="indexterm" id="IDX-CHP-15-0066"/><a class="indexterm" id="IDX-CHP-15-0067"/><a class="indexterm" id="IDX-CHP-15-0068"/><a class="indexterm" id="IDX-CHP-15-0069"/></p><p>The <code class="literal">usbd_transfer_drain</code> function is like <code class="literal">usbd_transfer_stop</code>, but it waits for <code class="literal">callback</code> to complete before returning.</p></div>
<div class="sect1" title="USB Methods Structure"><div class="titlepage"><div><div><h1 class="title"><a id="usb_methods_structure"/>USB Methods Structure</h1></div></div></div><p>A <code class="literal">usb_fifo_methods</code> structure defines a USB driver’s entry points. You can think of <code class="literal">struct usb_fifo_methods</code> as <code class="literal">struct cdevsw</code>, but for USB drivers.</p><p><code class="literal">struct usb_fifo_methods</code> is defined in the <code class="literal">&lt;dev/usb/usbdi.h&gt;</code> header as follows:</p><a id="I_programlisting15_d1e27403"/><pre class="programlisting">struct usb_fifo_methods {
        /* Executed Unlocked */
        usb_fifo_open_t         *f_open;
        usb_fifo_close_t        *f_close;
        usb_fifo_ioctl_t        *f_ioctl;
        usb_fifo_ioctl_t        *f_ioctl_post;

        /* Executed With Mutex Locked */
        usb_fifo_cmd_t          *f_start_read;
        usb_fifo_cmd_t          *f_stop_read;
        usb_fifo_cmd_t          *f_start_write;
        usb_fifo_cmd_t          *f_stop_write;
        usb_fifo_filter_t       *f_filter_read;
        usb_fifo_filter_t       *f_filter_write;

        const char              *basename[4];
        const char              *postfix[4];
};</pre><p>The FreeBSD kernel provides the following functions for working with <code class="literal">usb_fifo_methods</code> structures:</p><a id="I_programlisting15_d1e27410"/><pre class="programlisting">#include &lt;dev/usb/usb.h&gt;
#include &lt;dev/usb/usbdi.h&gt;
#include &lt;dev/usb/usbdi_util.h&gt;

int
usb_fifo_attach(struct usb_device *udev, void *priv_sc,
    struct mtx *priv_mtx, struct usb_fifo_methods *pm,
  <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_fifo_sc *f_sc, uint16_t unit, uint16_t subunit,
    uint8_t iface_index, uid_t uid, gid_t gid, int mode);

void
usb_fifo_detach(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>struct usb_fifo_sc *f_sc);</pre><p>The <code class="literal">usb_fifo_attach</code> function creates a USB device node under <span class="emphasis"><em>/dev</em></span>. If successful, a magic cookie is saved in <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27432"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">f_sc</code>.</p><p>The <code class="literal">usb_fifo_detach</code> function takes a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27446"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> cookie created by <code class="literal">usb_fifo_attach</code> and destroys its associated USB device node.</p></div>
<div class="sect1" title="Tying Everything Together"><div class="titlepage"><div><div><h1 class="title"><a id="tying_everything_together-id4"/>Tying Everything Together</h1></div></div></div><p>Now that you’re familiar with the <code class="literal">usb_*</code> structures and their management routines, let’s dissect a real-world USB driver.</p><p><a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a> provides a terse, source-level overview of <code class="literal">ulpt(4)</code>, the USB printer driver.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To improve readability, some of the variables and functions presented in this section have been renamed and restructured from their counterparts in the FreeBSD source.</p></div><div class="example"><a id="ulpt.c"/><p class="title">Example 15-1. ulpt.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/conf.h&gt;
  #include &lt;sys/bus.h&gt;
  #include &lt;sys/lock.h&gt;
  #include &lt;sys/mutex.h&gt;
  #include &lt;sys/syslog.h&gt;
  #include &lt;sys/fcntl.h&gt;

  #include &lt;dev/usb/usb.h&gt;
  #include &lt;dev/usb/usbdi.h&gt;
  #include &lt;dev/usb/usbdi_util.h&gt;

  #define ULPT_BUF_SIZE           (1 &lt;&lt; 15)
  #define ULPT_IFQ_MAX_LEN        2

  #define UREQ_GET_PORT_STATUS    0x01
  #define UREQ_SOFT_RESET         0x02

  #define LPS_NERR                0x08
  #define LPS_SELECT              0x10
  #define LPS_NOPAPER             0x20
  #define LPS_INVERT              (LPS_NERR | LPS_SELECT)
  #define LPS_MASK                (LPS_NERR | LPS_SELECT | LPS_NOPAPER)

  enum {
          ULPT_BULK_DT_WR,
          ULPT_BULK_DT_RD,
          ULPT_INTR_DT_RD,
          ULPT_N_TRANSFER
  };

  struct ulpt_softc {
          device_t                sc_dev;
          struct usb_device      *sc_usb_device;
          struct mtx              sc_mutex;
          struct usb_callout      sc_watchdog;
          uint8_t                 sc_iface_num;
          struct usb_xfer        *sc_transfer[ULPT_N_TRANSFER];
          struct usb_fifo_sc      sc_fifo;
          struct usb_fifo_sc      sc_fifo_no_reset;
          int                     sc_fflags;
          struct usb_fifo        *sc_fifo_open[2];
          uint8_t                 sc_zero_length_packets;
          uint8_t                 sc_previous_status;
  };

  static device_probe_t           ulpt_probe;
  static device_attach_t          ulpt_attach;
  static device_detach_t          ulpt_detach;

  static usb_fifo_open_t          ulpt_open;
  static usb_fifo_open_t          unlpt_open;
  static usb_fifo_close_t         ulpt_close;
  static usb_fifo_ioctl_t         ulpt_ioctl;
  static usb_fifo_cmd_t           ulpt_start_read;
  static usb_fifo_cmd_t           ulpt_stop_read;
  static usb_fifo_cmd_t           ulpt_start_write;
  static usb_fifo_cmd_t           ulpt_stop_write;

  static void                     ulpt_reset(struct ulpt_softc *);
  static void                     ulpt_watchdog(void *);

  static usb_callback_t           ulpt_write_callback;
  static usb_callback_t           ulpt_read_callback;
  static usb_callback_t           ulpt_status_callback;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> static struct usb_fifo_methods ulpt_fifo_methods = {
          .f_open =               &amp;ulpt_open,
          .f_close =              &amp;ulpt_close,
          .f_ioctl =              &amp;ulpt_ioctl,
          .f_start_read =         &amp;ulpt_start_read,
          .f_stop_read =          &amp;ulpt_stop_read,
          .f_start_write =        &amp;ulpt_start_write,
          .f_stop_write =         &amp;ulpt_stop_write,
          .basename[0] =        <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>"ulpt"
  };

<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/> static struct usb_fifo_methods unlpt_fifo_methods = {
          .f_open =               &amp;unlpt_open,
          .f_close =              &amp;ulpt_close,
          .f_ioctl =              &amp;ulpt_ioctl,
          .f_start_read =         &amp;ulpt_start_read,
          .f_stop_read =          &amp;ulpt_stop_read,
          .f_start_write =        &amp;ulpt_start_write,
          .f_stop_write =         &amp;ulpt_stop_write,
          .basename[0] =        <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>"unlpt"
  };

  static const struct usb_config ulpt_config[ULPT_N_TRANSFER] = {
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>[ULPT_BULK_DT_WR] = {
                  .callback =     &amp;ulpt_write_callback,
                  .bufsize =      ULPT_BUF_SIZE,
                  .flags =        {.pipe_bof = 1, .proxy_buffer = 1},
                  .type =         UE_BULK,
                  .endpoint =     UE_ADDR_ANY,
                  .direction =    UE_DIR_OUT
          },

        <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>[ULPT_BULK_DT_RD] = {
                  .callback =     &amp;ulpt_read_callback,
                  .bufsize =      ULPT_BUF_SIZE,
                  .flags =        {.short_xfer_ok = 1, .pipe_bof = 1,
                                      .proxy_buffer = 1},
                  .type =         UE_BULK,
                  .endpoint =     UE_ADDR_ANY,
                  .direction =    UE_DIR_IN
          },

        <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>[ULPT_INTR_DT_RD] = {
                  .callback =     &amp;ulpt_status_callback,
                  .bufsize =      sizeof(struct usb_device_request) + 1,
                  .timeout =      1000,           /* 1 second. */
                  .type =         UE_CONTROL,
                  .endpoint =     0x00,
                  .direction =    UE_DIR_ANY
          }
  };

  static int
  ulpt_open(struct usb_fifo *fifo, int fflags)
  {
  ...
  }

  static void
  ulpt_reset(struct ulpt_softc *sc)
  {
  ...
  }

  static int
  unlpt_open(struct usb_fifo *fifo, int fflags)
  {
  ...
  }

  static void
  ulpt_close(struct usb_fifo *fifo, int fflags)
  {
  ...
  }

  static int
  ulpt_ioctl(struct usb_fifo *fifo, u_long cmd, void *data, int fflags)
  {
  ...
  }

  static void
  ulpt_watchdog(void *arg)
  {
  ...
  }

  static void
  ulpt_start_read(struct usb_fifo *fifo)
  {
  ...
  }

  static void
  ulpt_stop_read(struct usb_fifo *fifo)
  {
  ...
  }

  static void
  ulpt_start_write(struct usb_fifo *fifo)
  {
  ...
  }

  static void
  ulpt_stop_write(struct usb_fifo *fifo)
  {
  ...
  }

  static void
  ulpt_write_callback(struct usb_xfer *transfer, usb_error_t error)
  {
  ...
  }

  static void
  ulpt_read_callback(struct usb_xfer *transfer, usb_error_t error)
  {
  ...
  }

  static void
  ulpt_status_callback(struct usb_xfer *transfer, usb_error_t error)
  {
  ...
  }

  static int
  ulpt_probe(device_t dev)
  {
  ...
  }

  static int
  ulpt_attach(device_t dev)
  {
  ...
  }

  static int
  ulpt_detach(device_t dev)
  {
  ...
  }

  static device_method_t ulpt_methods[] = {
          /* Device interface. */
          DEVMETHOD(device_probe,         ulpt_probe),
          DEVMETHOD(device_attach,        ulpt_attach),
          DEVMETHOD(device_detach,        ulpt_detach),
          { 0, 0 }
  };

  static driver_t ulpt_driver = {
          "ulpt",
          ulpt_methods,
          sizeof(struct ulpt_softc)
  };

  static devclass_t ulpt_devclass;

  DRIVER_MODULE(ulpt, uhub, ulpt_driver, ulpt_devclass, 0, 0);
  MODULE_DEPEND(ulpt, usb, 1, 1, 1);
  MODULE_DEPEND(ulpt, ucom, 1, 1, 1);</pre></div></div><p>Note that <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a> defines three <code class="literal">usb_config</code> structures. Therefore, <code class="literal">ulpt(4)</code> communicates with three endpoints: a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27530"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> bulk OUT, a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27536"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> bulk IN, and the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27543"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> default control endpoint.<a class="indexterm" id="IDX-CHP-15-0070"/><a class="indexterm" id="IDX-CHP-15-0071"/><a class="indexterm" id="IDX-CHP-15-0072"/></p><p>Also, note that <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a> defines two <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27568"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27574"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">usb_fifo_methods</code> structures. So, <code class="literal">ulpt(4)</code> provides two device nodes: <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27587"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">ulpt%d</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27596"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">unlpt%d</code> (where <code class="literal">%d</code> is the unit number). As you’ll see, the <code class="literal">ulpt%d</code> device node resets the printer when opened, whereas <code class="literal">unlpt%d</code> does not.</p><p>Now, let’s discuss the functions found in <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a>.</p><div class="sect2" title="ulpt_probe Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_probe_function"/>ulpt_probe Function</h2></div></div></div><p>The <code class="literal">ulpt_probe</code> function is the <code class="literal">device_probe</code> implementation for <code class="literal">ulpt(4)</code>. Here is its function definition:</p><a id="I_programlisting15_d1e27633"/><pre class="programlisting">static int
ulpt_probe(device_t dev)
{
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_attach_arg *uaa = device_get_ivars(dev);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (uaa-&gt;usb_mode != USB_MODE_HOST)
                return (ENXIO);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>if ((uaa-&gt;info.bInterfaceClass == UICLASS_PRINTER) &amp;&amp;
            (uaa-&gt;info.bInterfaceSubClass == UISUBCLASS_PRINTER) &amp;&amp;
            ((uaa-&gt;info.bInterfaceProtocol == UIPROTO_PRINTER_UNI) ||
             (uaa-&gt;info.bInterfaceProtocol == UIPROTO_PRINTER_BI) ||
             (uaa-&gt;info.bInterfaceProtocol == UIPROTO_PRINTER_1284)))
                return (BUS_PROBE_SPECIFIC);

        return (ENXIO);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27655"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> ensures that the USB host controller is in host mode, which is needed to initiate data transfers. Then <code class="literal">ulpt_probe</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27664"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> determines whether <code class="literal">dev</code> is a USB printer.</p><p>Incidentally, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27675"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">struct usb_attach_arg</code> contains the printer’s instance variables.</p></div><div class="sect2" title="ulpt_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_attach_function"/>ulpt_attach Function</h2></div></div></div><p>The <code class="literal">ulpt_attach</code> function is the <code class="literal">device_attach</code> implementation for <code class="literal">ulpt(4)</code>. Here is its function definition:</p><a id="I_programlisting15_d1e27698"/><pre class="programlisting">static int
ulpt_attach(device_t dev)
{
        struct usb_attach_arg *uaa = device_get_ivars(dev);
        struct ulpt_softc *sc = device_get_softc(dev);
        struct usb_interface_descriptor *idesc;
        struct usb_config_descriptor *cdesc;
        uint8_t alt_index, iface_index = uaa-&gt;info.bIfaceIndex;
        int error, unit = device_get_unit(dev);

        sc-&gt;sc_dev = dev;
        sc-&gt;sc_usb_device = uaa-&gt;device;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>device_set_usb_desc(dev);
        mtx_init(&amp;sc-&gt;sc_mutex, "ulpt", NULL, MTX_DEF | MTX_RECURSE);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>usb_callout_init_mtx(&amp;sc-&gt;sc_watchdog, &amp;sc-&gt;sc_mutex, 0);

        idesc = usbd_get_interface_descriptor(uaa-&gt;iface);
        alt_index = −1;
        for (;;) {
                if (idesc == NULL)
                        break;

                if ((idesc-&gt;bDescriptorType == UDESC_INTERFACE) &amp;&amp;
                    (idesc-&gt;bLength &gt;= sizeof(*idesc))) {
                        if (idesc-&gt;bInterfaceNumber != <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>uaa-&gt;info.bIfaceNum)
                                break;
                        else {
                                alt_index++;
                                if ((idesc-&gt;bInterfaceClass ==
                                     UICLASS_PRINTER) &amp;&amp;
                                    (idesc-&gt;bInterfaceSubClass ==
                                     UISUBCLASS_PRINTER) &amp;&amp;
                                    (idesc-&gt;bInterfaceProtocol ==
                                   <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>UIPROTO_PRINTER_BI))
                                        goto found;
                        }
                }

                cdesc = usbd_get_config_descriptor(uaa-&gt;device);
                idesc = (void *)<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>usb_desc_foreach(cdesc, (void *)idesc);
        }
        goto detach;

found:
        if (alt_index) {
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>usbd_set_alt_interface_index(uaa-&gt;device,
                    iface_index, alt_index);
                if (error)
                        goto detach;
        }

        sc-&gt;sc_iface_num = idesc-&gt;bInterfaceNumber;

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>usbd_transfer_setup(uaa-&gt;device, &amp;iface_index,
            sc-&gt;sc_transfer, ulpt_config, ULPT_N_TRANSFER, sc,
            &amp;sc-&gt;sc_mutex);
        if (error)
                goto detach;

        device_printf(dev, "using bi-directional mode\n");

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>usb_fifo_attach(uaa-&gt;device, sc, &amp;sc-&gt;sc_mutex,
            &amp;ulpt_fifo_methods, &amp;sc-&gt;sc_fifo, unit, −1,
            iface_index, UID_ROOT, GID_OPERATOR, 0644);
        if (error)
                goto detach;

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>usb_fifo_attach(uaa-&gt;device, sc, &amp;sc-&gt;sc_mutex,
            &amp;unlpt_fifo_methods, &amp;sc-&gt;sc_fifo_no_reset, unit, −1,
            iface_index, UID_ROOT, GID_OPERATOR, 0644);
        if (error)
                goto detach;

        mtx_lock(&amp;sc-&gt;sc_mutex);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>ulpt_watchdog(sc);
        mtx_unlock(&amp;sc-&gt;sc_mutex);
        return (0);

detach:
        ulpt_detach(dev);
        return (ENOMEM);
}</pre><p>This function can be split into three parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27763"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> sets the verbose description of <code class="literal">dev</code> by calling <code class="literal">device_set_usb_desc(dev)</code>. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27775"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> initializes <code class="literal">ulpt(4)</code>’s <code class="literal">callout</code> structure.<a class="indexterm" id="IDX-CHP-15-0073"/><a class="indexterm" id="IDX-CHP-15-0074"/><a class="indexterm" id="IDX-CHP-15-0075"/><a class="indexterm" id="IDX-CHP-15-0076"/><a class="indexterm" id="IDX-CHP-15-0077"/><a class="indexterm" id="IDX-CHP-15-0078"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>All USB devices contain a textual description of themselves, which is why <code class="literal">device_set_usb_desc</code> just takes a <code class="literal">device_t</code> argument.</p></div><p>The second part essentially <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27829"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> iterates through the alternate settings for interface number <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27835"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">uaa-&gt;info.bIfaceNum</code>, until the alternate setting that supports <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27844"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> bidirectional mode is found. If the alternate setting that supports bi-directional mode is not alternate setting 0, then <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27850"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">usbd_set_alt_interface_index</code> is called to instate this alternate setting. Alternate setting 0 does not need to be instated, because it’s used by default.</p><p>Finally, the third part <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27862"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> initializes the USB transfers, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27868"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27874"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> creates <code class="literal">ulpt(4)</code>’s device nodes, and calls <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27883"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">ulpt_watchdog</code> (which we’ll walk through in <a class="xref" href="ch15s07.html#ulpt_underscore_watchdog_function" title="ulpt_watchdog Function">ulpt_watchdog Function</a> in <a class="xref" href="ch15s07.html#ulpt_underscore_watchdog_function" title="ulpt_watchdog Function">ulpt_watchdog Function</a>).</p></div><div class="sect2" title="ulpt_detach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_detach_function"/>ulpt_detach Function</h2></div></div></div><p>The <code class="literal">ulpt_detach</code> function is the <code class="literal">device_detach</code> implementation for <code class="literal">ulpt(4)</code>. Here is its function definition:</p><a id="I_programlisting15_d1e27911"/><pre class="programlisting">static int
ulpt_detach(device_t dev)
{
        struct ulpt_softc *sc = device_get_softc(dev);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>usb_fifo_detach(&amp;sc-&gt;sc_fifo);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>usb_fifo_detach(&amp;sc-&gt;sc_fifo_no_reset);

        mtx_lock(&amp;sc-&gt;sc_mutex);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>usb_callout_stop(&amp;sc-&gt;sc_watchdog);
        mtx_unlock(&amp;sc-&gt;sc_mutex);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usbd_transfer_unsetup(sc-&gt;sc_transfer, ULPT_N_TRANSFER);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>usb_callout_drain(&amp;sc-&gt;sc_watchdog);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>mtx_destroy(&amp;sc-&gt;sc_mutex);

        return (0);
}</pre><p>This function starts by <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27952"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27958"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> destroying its device nodes. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27964"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> stops the callout function, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27970"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> tears down the USB transfers, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27976"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> drains the callout function, and <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e27983"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> destroys its mutex.</p></div><div class="sect2" title="ulpt_open Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_open_function"/>ulpt_open Function</h2></div></div></div><p>The <code class="literal">ulpt_open</code> function is the <code class="literal">ulpt%d</code> device node’s open routine. Here is its function definition:</p><a id="I_programlisting15_d1e28001"/><pre class="programlisting">static int
ulpt_open(struct usb_fifo *fifo, int fflags)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

        if (sc-&gt;sc_fflags == 0)
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>ulpt_reset(sc);

        return (<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>unlpt_open(fifo, fflags));
}</pre><p>This function first calls <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28017"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">ulpt_reset</code> to reset the printer. Then <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28026"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">unlpt_open</code> is called to (actually) open the printer.<a class="indexterm" id="IDX-CHP-15-0079"/><a class="indexterm" id="IDX-CHP-15-0080"/><a class="indexterm" id="IDX-CHP-15-0081"/></p></div><div class="sect2" title="ulpt_reset Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_reset_function"/>ulpt_reset Function</h2></div></div></div><p>As mentioned in the previous section, the <code class="literal">ulpt_reset</code> function resets the printer. Here is its function definition:</p><a id="I_programlisting15_d1e28059"/><pre class="programlisting">static void
ulpt_reset(struct ulpt_softc *sc)
{
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct usb_device_request req;
        int error;

        req.bRequest = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>UREQ_SOFT_RESET;
        USETW(req.wValue, 0);
        USETW(req.wIndex, sc-&gt;sc_iface_num);
        USETW(req.wLength, 0);

        mtx_lock(&amp;sc-&gt;sc_mutex);

        req.bmRequestType = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>UT_WRITE_CLASS_OTHER;
        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usbd_do_request_flags(sc-&gt;sc_usb_device, &amp;sc-&gt;sc_mutex,
            &amp;req, NULL, 0, NULL, 2 * USB_MS_HZ);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if (error) {
                req.bmRequestType = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>UT_WRITE_CLASS_INTERFACE;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>usbd_do_request_flags(sc-&gt;sc_usb_device, &amp;sc-&gt;sc_mutex,
                    &amp;req, NULL, 0, NULL, 2 * USB_MS_HZ);
        }

        mtx_unlock(&amp;sc-&gt;sc_mutex);
}</pre><p>This function starts by defining a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28106"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">usb_device_request</code> structure to <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28115"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> reset the printer. It then <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28121"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> transmits the reset request to the printer.</p><p>Note that some printers typify a reset request as <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28129"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">UT_WRITE_CLASS_OTHER</code> and some typify it as <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28138"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">UT_WRITE_CLASS_INTERFACE</code>. Thus, <code class="literal">ulpt_reset</code> transmits the reset request a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28151"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> second time if the first request <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28157"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> fails.</p></div><div class="sect2" title="unlpt_open Function"><div class="titlepage"><div><div><h2 class="title"><a id="unlpt_underscore_open_function"/>unlpt_open Function</h2></div></div></div><p>The <code class="literal">unlpt_open</code> function is the <code class="literal">unlpt%d</code> device node’s open routine. Here is its function definition:<a class="indexterm" id="IDX-CHP-15-0082"/><a class="indexterm" id="IDX-CHP-15-0083"/><a class="indexterm" id="IDX-CHP-15-0084"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>You’ll recall that this function is also called at the end of <code class="literal">ulpt_open</code>.</p></div><a id="I_programlisting15_d1e28195"/><pre class="programlisting">static int
unlpt_open(struct usb_fifo *fifo, int fflags)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);
        int error;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_fflags &amp; fflags)
                return (EBUSY);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (fflags &amp; FREAD) {
                mtx_lock(&amp;sc-&gt;sc_mutex);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>usbd_xfer_set_stall(sc-&gt;sc_transfer[ULPT_BULK_DT_RD]);
                mtx_unlock(&amp;sc-&gt;sc_mutex);

                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usb_fifo_alloc_buffer(fifo,
                    usbd_xfer_max_len(sc-&gt;sc_transfer[ULPT_BULK_DT_RD]),
                    ULPT_IFQ_MAX_LEN);
                if (error)
                        return (ENOMEM);

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_fifo_open[USB_FIFO_RX] = fifo;
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>if (fflags &amp; FWRITE) {
                mtx_lock(&amp;sc-&gt;sc_mutex);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>usbd_xfer_set_stall(sc-&gt;sc_transfer[ULPT_BULK_DT_WR]);
                mtx_unlock(&amp;sc-&gt;sc_mutex);

                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>usb_fifo_alloc_buffer(fifo,
                    usbd_xfer_max_len(sc-&gt;sc_transfer[ULPT_BULK_DT_WR]),
                    ULPT_IFQ_MAX_LEN);
                if (error)
                        return (ENOMEM);

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_fifo_open[USB_FIFO_TX] = fifo;
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>sc-&gt;sc_fflags |= fflags &amp; (FREAD | FWRITE);
        return (0);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28260"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> tests the value of <code class="literal">sc-&gt;sc_fflags</code>. If it does not equal 0, which implies that another process has opened the printer, the error code <code class="literal">EBUSY</code> is returned. Next, <code class="literal">unlpt_open</code> determines whether we’re opening the printer to <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28275"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> read from or <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28282"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> write to it—the answer is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28288"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> stored in <code class="literal">sc-&gt;sc_fflags</code>. Then, a clear-stall request is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28297"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28303"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> issued to the appropriate endpoint.<a class="indexterm" id="IDX-CHP-15-0085"/><a class="indexterm" id="IDX-CHP-15-0086"/><a class="indexterm" id="IDX-CHP-15-0087"/><a class="indexterm" id="IDX-CHP-15-0088"/><a class="indexterm" id="IDX-CHP-15-0089"/><a class="indexterm" id="IDX-CHP-15-0090"/><a class="indexterm" id="IDX-CHP-15-0091"/><a class="indexterm" id="IDX-CHP-15-0092"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Any errors that a USB device detects in its own functionality, not counting transmission errors, cause the device to “stall” the endpoint for its current transaction (Oney, 2003). Control endpoints clear their stalls automatically, but other endpoint types require a clear-stall request. Naturally, stalled endpoints cannot perform any transactions.</p></div><p>Next, memory for the read or write is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28353"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28359"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> allocated. Afterward, the <code class="literal">fifo</code> argument is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28368"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28374"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> stored in <code class="literal">sc-&gt;sc_fifo_open</code>.</p></div><div class="sect2" title="ulpt_close Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_close_function"/>ulpt_close Function</h2></div></div></div><p>The <code class="literal">ulpt_close</code> function is the close routine for <code class="literal">ulpt%d</code> and <code class="literal">unlpt%d</code>. Here is its function definition:</p><a id="I_programlisting15_d1e28398"/><pre class="programlisting">static void
ulpt_close(struct usb_fifo *fifo, int fflags)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sc-&gt;sc_fflags &amp;= ˜(fflags &amp; (FREAD | FWRITE));

        if (fflags &amp; (FREAD | FWRITE))
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>usb_fifo_free_buffer(fifo);
}</pre><p>This function starts by <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28414"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> clearing <code class="literal">sc-&gt;sc_fflags</code>. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28423"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> releases the memory allocated in <code class="literal">unlpt_open</code>.</p></div><div class="sect2" title="ulpt_ioctl Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_ioctl_function"/>ulpt_ioctl Function</h2></div></div></div><p>The <code class="literal">ulpt_ioctl</code> function is the ioctl routine for <code class="literal">ulpt%d</code> and <code class="literal">unlpt%d</code>. Here is its function definition:</p><a id="I_programlisting15_d1e28446"/><pre class="programlisting">static int
ulpt_ioctl(struct usb_fifo *fifo, u_long cmd, void *data, int fflags)
{
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>return (ENODEV);
}</pre><p>As you can see, <code class="literal">ulpt(4)</code> does <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28459"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> not support ioctl.</p></div><div class="sect2" title="ulpt_watchdog Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_watchdog_function"/>ulpt_watchdog Function</h2></div></div></div><p>The <code class="literal">ulpt_watchdog</code> function periodically checks the printer’s status. Here is its function definition:<a class="indexterm" id="IDX-CHP-15-0093"/><a class="indexterm" id="IDX-CHP-15-0094"/><a class="indexterm" id="IDX-CHP-15-0095"/><a class="indexterm" id="IDX-CHP-15-0096"/><a class="indexterm" id="IDX-CHP-15-0097"/><a class="indexterm" id="IDX-CHP-15-0098"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>You’ll recall that this function is called at the end of <code class="literal">ulpt_attach</code>.</p></div><a id="I_programlisting15_d1e28509"/><pre class="programlisting">static void
ulpt_watchdog(void *arg)
{
        struct ulpt_softc *sc = arg;

        mtx_assert(&amp;sc-&gt;sc_mutex, MA_OWNED);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_fflags == 0)
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>usbd_transfer_start(sc-&gt;sc_transfer[<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ULPT_INTR_DT_RD]);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usb_callout_reset(&amp;sc-&gt;sc_watchdog, <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>hz,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;ulpt_watchdog, sc);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28550"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> ensures that the printer is not open. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28556"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> starts a transaction with the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28562"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> default control endpoint (to retrieve the printer’s status). Recall that <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28568"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">usbd_transfer_start</code> just executes a callback. In this case, that callback is <code class="literal">ulpt_status_callback</code> (for confirmation, see the third <code class="literal">usb_config</code> structure in <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a>). Finally, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28586"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">ulpt_watchdog</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28595"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> rescheduled to execute after <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28602"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> 1 second.</p></div><div class="sect2" title="ulpt_start_read Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_start_underscore_read_fu"/>ulpt_start_read Function</h2></div></div></div><p>The <code class="literal">ulpt_start_read</code> function is executed when a process reads from <code class="literal">ulpt%d</code> or <code class="literal">unlpt%d</code> (for verification, see their <code class="literal">usb_fifo_methods</code> structures). Here is its function definition:</p><a id="I_programlisting15_d1e28625"/><pre class="programlisting">static void
ulpt_start_read(struct usb_fifo *fifo)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

       <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>usbd_transfer_start(sc-&gt;sc_transfer[<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ULPT_BULK_DT_RD]);
}</pre><p>This function simply <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28641"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> starts a transaction with the printer’s <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28647"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> bulk IN endpoint. Note that the callback for a bulk IN endpoint is <code class="literal">ulpt_read_callback</code> (for confirmation, see the second <code class="literal">usb_config</code> structure in <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a>).</p></div><div class="sect2" title="ulpt_stop_read Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_stop_underscore_read_fun"/>ulpt_stop_read Function</h2></div></div></div><p>The <code class="literal">ulpt_stop_read</code> function is called when a process stops reading from <code class="literal">ulpt%d</code> or <code class="literal">unlpt%d</code>. Here is its function definition:<a class="indexterm" id="IDX-CHP-15-0099"/><a class="indexterm" id="IDX-CHP-15-0100"/><a class="indexterm" id="IDX-CHP-15-0101"/><a class="indexterm" id="IDX-CHP-15-0102"/><a class="indexterm" id="IDX-CHP-15-0103"/><a class="indexterm" id="IDX-CHP-15-0104"/><a class="indexterm" id="IDX-CHP-15-0105"/><a class="indexterm" id="IDX-CHP-15-0106"/><a class="indexterm" id="IDX-CHP-15-0107"/></p><a id="I_programlisting15_d1e28721"/><pre class="programlisting">static void
ulpt_stop_read(struct usb_fifo *fifo)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>usbd_transfer_stop(sc-&gt;sc_transfer[<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ULPT_BULK_DT_RD]);
}</pre><p>This function <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28737"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> stops any transactions associated with the printer’s <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28743"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> bulk IN endpoint.</p></div><div class="sect2" title="ulpt_start_write Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_start_underscore_write_f"/>ulpt_start_write Function</h2></div></div></div><p>The <code class="literal">ulpt_start_write</code> function is executed when a process writes to <code class="literal">ulpt%d</code> or <code class="literal">unlpt%d</code>. Here is its function definition:</p><a id="I_programlisting15_d1e28763"/><pre class="programlisting">static void
ulpt_start_write(struct usb_fifo *fifo)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>usbd_transfer_start(sc-&gt;sc_transfer[<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ULPT_BULK_DT_WR]);
}</pre><p>This function simply <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28779"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> starts a transaction with the printer’s <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28785"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> bulk OUT endpoint. Note that the callback for a bulk OUT endpoint is <code class="literal">ulpt_write_callback</code> (for confirmation, see the first <code class="literal">usb_config</code> structure in <a class="xref" href="ch15s07.html#ulpt.c" title="Example 15-1. ulpt.c">Example 15-1</a>).</p></div><div class="sect2" title="ulpt_stop_write Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_stop_underscore_write_fu"/>ulpt_stop_write Function</h2></div></div></div><p>The <code class="literal">ulpt_stop_write</code> function is executed when a process stops writing to <code class="literal">ulpt%d</code> or <code class="literal">unlpt%d</code>. Here is its function definition:</p><a id="I_programlisting15_d1e28813"/><pre class="programlisting">static void
ulpt_stop_write(struct usb_fifo *fifo)
{
        struct ulpt_softc *sc = usb_fifo_softc(fifo);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>usbd_transfer_stop(sc-&gt;sc_transfer[<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ULPT_BULK_DT_WR]);
}</pre><p>This function <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28829"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> stops any transactions associated with the printer’s <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28835"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> bulk OUT endpoint.</p></div><div class="sect2" title="ulpt_write_callback Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_write_underscore_callbac"/>ulpt_write_callback Function</h2></div></div></div><p>The <code class="literal">ulpt_write_callback</code> function transfers data from user space to the printer (to be printed). Recall that this function is the callback for a bulk OUT endpoint, so it’s executed before and after a bulk OUT transfers data.<a class="indexterm" id="IDX-CHP-15-0108"/><a class="indexterm" id="IDX-CHP-15-0109"/><a class="indexterm" id="IDX-CHP-15-0110"/><a class="indexterm" id="IDX-CHP-15-0111"/></p><p>The following is the function definition for <code class="literal">ulpt_write_callback</code>:</p><a id="I_programlisting15_d1e28872"/><pre class="programlisting">static void
ulpt_write_callback(struct usb_xfer *transfer, usb_error_t error)
{
        struct ulpt_softc *sc = usbd_xfer_softc(transfer);
        struct usb_fifo *fifo = sc-&gt;sc_fifo_open[USB_FIFO_TX];
        struct usb_page_cache *pc;
        int actual, max;

        usbd_xfer_status(transfer, &amp;actual, NULL, NULL, NULL);

        if (fifo == NULL)
                return;

        switch (USB_GET_STATE(transfer)) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>case USB_ST_SETUP:
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>case USB_ST_TRANSFERRED:
setup:
                pc = usbd_xfer_get_frame(transfer, 0);
                max = usbd_xfer_max_len(transfer);
                if (<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>usb_fifo_get_data(<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>fifo, <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>pc, 0,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>max,
                    <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>&amp;actual, 0)) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>usbd_xfer_set_frame_len(transfer, 0, <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>actual);
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>usbd_transfer_submit(transfer);
                }
                break;
        default:
                if (error != USB_ERR_CANCELLED) {
                        /* Issue a clear-stall request. */
                        usbd_xfer_set_stall(transfer);
                        goto setup;
                }
                break;
        }
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28937"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> copies <span class="emphasis"><em>foo</em></span> bytes from <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28946"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> user space to <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28952"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> kernel space. At most, <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28958"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">max</code> bytes of data are copied. The number of bytes actually copied is returned in <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28968"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">actual</code>. Next, the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28977"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> transfer length is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28983"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> set. Then, the data copied from user space is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e28989"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> sent to the printer.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the preceding paragraph, <span class="emphasis"><em>foo</em></span> is a placeholder, because I don’t know how many bytes are copied until <code class="literal">usb_fifo_get_data</code> returns.</p></div><p>Note that the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29006"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">USB_ST_SETUP</code> case and the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29015"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">USB_ST_TRANSFERRED</code> case are identical. This is because you can print more data than the maximum transfer length. Thus, this function “loops” until all the data is sent.<a class="indexterm" id="IDX-CHP-15-0112"/><a class="indexterm" id="IDX-CHP-15-0113"/><a class="indexterm" id="IDX-CHP-15-0114"/></p></div><div class="sect2" title="ulpt_read_callback Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_read_underscore_callback"/>ulpt_read_callback Function</h2></div></div></div><p>The <code class="literal">ulpt_read_callback</code> function gets data from the printer. Recall that this function is the callback for a bulk IN endpoint, so it’s executed before and after a bulk IN transfers data.</p><p>The following is the function definition for <code class="literal">ulpt_read_callback</code>:</p><a id="I_programlisting15_d1e29054"/><pre class="programlisting">static void
ulpt_read_callback(struct usb_xfer *transfer, usb_error_t error)
{
        struct ulpt_softc *sc = usbd_xfer_softc(transfer);
        struct usb_fifo *fifo = sc-&gt;sc_fifo_open[USB_FIFO_RX];
        struct usb_page_cache *pc;
        int actual, max;

        usbd_xfer_status(transfer, &amp;actual, NULL, NULL, NULL);

        if (fifo == NULL)
                return;

        switch (USB_GET_STATE(transfer)) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>case USB_ST_TRANSFERRED:
             <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (actual == 0) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>if (sc-&gt;sc_zero_length_packets == 4)
                                /* Throttle transfers. */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>usbd_xfer_set_interval(transfer, 500);
                        else
                                sc-&gt;sc_zero_length_packets++;
                } else {
                        /* Disable throttling. */
                        usbd_xfer_set_interval(transfer, 0);
                        sc-&gt;sc_zero_length_packets = 0;
                }

                pc = usbd_xfer_get_frame(transfer, 0);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>usb_fifo_put_data(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>fifo, <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>pc, 0, actual, 1);
                /* FALLTHROUGH */
        case USB_ST_SETUP:
setup:
                if (<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>usb_fifo_put_bytes_max(fifo) != 0) {
                        max = usbd_xfer_max_len(transfer);
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>usbd_xfer_set_frame_len(transfer, 0, max);
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>usbd_transfer_submit(transfer);
                }
                break;
        default:
                /* Disable throttling. */
                usbd_xfer_set_interval(transfer, 0);
                sc-&gt;sc_zero_length_packets = 0;

                if (error != USB_ERR_CANCELLED) {
                        /* Issue a clear-stall request. */
                        usbd_xfer_set_stall(transfer);
                        goto setup;
                }
                break;
        }
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29119"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> ensures that there’s room in user space for the printer’s data. Next, the maximum transfer length is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29125"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> specified. Then data from the printer is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29131"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> retrieved.<a class="indexterm" id="IDX-CHP-15-0115"/><a class="indexterm" id="IDX-CHP-15-0116"/><a class="indexterm" id="IDX-CHP-15-0117"/></p><p>After a transfer is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29154"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> complete, the printer’s data is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29160"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> copied from <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29166"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> kernel space to <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29172"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> user space. Note that if <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29178"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> nothing is returned <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29185"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> four times in a row, transfer throttling is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29191"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> enabled.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some USB devices cannot handle multiple rapid transfer requests, so staggering or throttling of transfers is required.</p></div></div><div class="sect2" title="ulpt_status_callback Function"><div class="titlepage"><div><div><h2 class="title"><a id="ulpt_underscore_status_underscore_callba"/>ulpt_status_callback Function</h2></div></div></div><p>The <code class="literal">ulpt_status_callback</code> function returns the printer’s current status. Recall that this function is the callback for the default control endpoint, so it’s executed before and after any transactions with endpoint 0.</p><p>The following is the function definition for <code class="literal">ulpt_status_callback</code>:</p><a id="I_programlisting15_d1e29213"/><pre class="programlisting">static void
ulpt_status_callback(struct usb_xfer *transfer, usb_error_t error)
{
        struct ulpt_softc *sc = usbd_xfer_softc(transfer);
        struct usb_device_request req;
        struct usb_page_cache *pc;
        uint8_t current_status, new_status;

        switch (USB_GET_STATE(transfer)) {
        case USB_ST_SETUP:
                req.bmRequestType = UT_READ_CLASS_INTERFACE;
                req.bRequest = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>UREQ_GET_PORT_STATUS;
                USETW(req.wValue, 0);
                req.wIndex[0] = sc-&gt;sc_iface_num;
                req.wIndex[1] = 0;
                USETW(req.wLength, 1);

                pc = usbd_xfer_get_frame(transfer, 0);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>usbd_copy_in(<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>pc, 0, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>&amp;req, sizeof(req));
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>usbd_xfer_set_frame_len(transfer, 0, sizeof(req));
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>usbd_xfer_set_frame_len(transfer, 1, 1);
                usbd_xfer_set_frames(transfer, <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>2);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>usbd_transfer_submit(transfer);

                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>case USB_ST_TRANSFERRED:
                pc = usbd_xfer_get_frame(transfer, 1);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>usbd_copy_out(pc, 0, &amp;current_status, 1);

                current_status = (current_status ^ LPS_INVERT) &amp; LPS_MASK;
                new_status = current_status &amp; ˜sc-&gt;sc_previous_status;
                sc-&gt;sc_previous_status = current_status;

                if (new_status &amp; LPS_NERR)
                        log(LOG_NOTICE, "%s: output error\n",
                            device_get_nameunit(sc-&gt;sc_dev));
                else if (new_status &amp; LPS_SELECT)
                        log(LOG_NOTICE, "%s: offline\n",
                            device_get_nameunit(sc-&gt;sc_dev));
                else if (new_status &amp; LPS_NOPAPER)
                        log(LOG_NOTICE, "%s: out of paper\n",
                            device_get_nameunit(sc-&gt;sc_dev));

                break;
        default:
                break;
        }
}</pre><p>This function first constructs a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29278"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> get status request. It then <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29284"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> plunks the <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29290"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> request into a <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29296"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> DMA buffer. Shortly afterward, the request is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29302"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> sent to the printer. Interestingly, this transaction involves <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29309"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> two USB frames. The <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29315"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> first contains the get status request. The <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29321"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> second will hold the printer’s status.</p><p>After a transaction is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29329"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> complete, the printer’s status is <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e29335"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> plucked from the DMA buffer.</p><p>The remainder of this function should be self-explanatory.</p></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id14"/>Conclusion</h1></div></div></div><p>This chapter was basically a primer on USB devices and drivers. For more information, see the official documentation, available at <a class="ulink" href="http://www.usb.org/developers/">http://www.usb.org/developers/</a>.</p></div></body></html>