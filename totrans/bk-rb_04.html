<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Arrays and Hashes"><div class="titlepage"><div><div><h1 class="title"><a id="arrays_and_hashes"/>Chapter 4. Arrays and Hashes</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id6"/><div class="mediaobject"><a id="I_mediaobject4_d1e3804"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Up to now, you’ve generally been using objects one at a time. In this chapter, you’ll find out how to create a list of objects. You’ll start by looking at the most common type of list structure: an array.<a id="IDX-CHP-4-0001" class="indexterm"/></p><div class="sect1" title="Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="arrays"/>Arrays</h1></div></div></div><p>An <span class="emphasis"><em>array</em></span> is a sequential collection of items in which each item can be indexed. In Ruby (unlike many other languages), a single array can contain items of mixed data types such as strings, integers, and floats or even a method call that returns some value. For example, the final element in <code class="literal">a1</code> shown here calls my method, <code class="literal">array_length</code>, which returns the length of the array, <code class="literal">a0</code>:<a id="IDX-CHP-4-0002" class="indexterm"/></p><p><span class="emphasis"><em>array0.rb</em></span></p><a id="I_programlisting4_d1e3839"/><pre class="programlisting">def array_length( anArray )
    return anArray.length
end

a0 = [1,2,3,4,5]
a1 = [1,'two', 3.0, array_length( a0 ) ]
p( a1 )        #=&gt;[1, "two", 3.0, 5]</pre><p>The first item in an array has the index 0, which means the final item has an index equal to the total number of items in the array minus 1. Given the array <code class="literal">a1</code>, shown previously, this is how to obtain the values of the first and last items:<a id="IDX-CHP-4-0003" class="indexterm"/><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/><a id="IDX-CHP-4-0006" class="indexterm"/></p><a id="I_programlisting4_d1e3866"/><pre class="programlisting">a1[0]        # returns 1st item (at index 0)
a1[3]        # returns 4th item (at index 3)</pre><p>You’ve already used arrays a few times—for example, in <span class="emphasis"><em>2adventure.rb</em></span> you used an array to store a map of Room objects:</p><a id="I_programlisting4_d1e3873"/><pre class="programlisting">mymap = Map.new([room1,room2,room3])</pre><div class="sect2" title="Creating Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="creating_arrays"/>Creating Arrays</h2></div></div></div><p>Like many other programming languages, Ruby uses square brackets to delimit an array. You can easily create an array, fill it with some comma-delimited values, and assign it to a variable:</p><a id="I_programlisting4_d1e3880"/><pre class="programlisting">arr = ['one','two','three','four']</pre><p>As with most other things in Ruby, arrays are objects. They are defined, as you might guess, by the Array class and, just like strings, they are indexed from 0. You can reference an item in an array by placing its index between square brackets. If the index is invalid, <code class="literal">nil</code> is returned:<a id="IDX-CHP-4-0007" class="indexterm"/></p><p><span class="emphasis"><em>array1.rb</em></span></p><a id="I_programlisting4_d1e3893"/><pre class="programlisting">arr = ['a', 'b', 'c']
puts(arr[0])      # shows 'a'
puts(arr[1])      # shows 'b'
puts(arr[2])      # shows 'c'
puts(arr[3])      # nil</pre><div class="sidebar"><a id="displaying_nil"/><p class="title">Displaying nil</p><p>When you attempt to display a <code class="literal">nil</code> value using <code class="literal">print</code> or <code class="literal">puts</code>, Ruby 1.8 displays “nil,” whereas Ruby 1.9 displays an empty string. If you want to be sure that the string representation of <code class="literal">nil</code> is displayed, use <code class="literal">p</code> or the <code class="literal">inspect</code> method instead of <code class="literal">print</code>. You may also display its class (<code class="literal">nil</code> is an instance of <code class="literal">NilClass</code>) or test whether it is <code class="literal">nil</code> using the <code class="literal">nil?</code> method:<a id="IDX-CHP-4-0008" class="indexterm"/><a id="IDX-CHP-4-0009" class="indexterm"/><a id="IDX-CHP-4-0010" class="indexterm"/><a id="IDX-CHP-4-0011" class="indexterm"/></p><a id="I_programlisting4_d1e3951"/><pre class="programlisting">puts(arr[3].inspect)     #=&gt; nil
puts(arr[3].class)       #=&gt; NilClass
p(arr[3])                #=&gt; nil
puts(arr[3].nil?)        #=&gt; true</pre></div><p><span class="emphasis"><em>array1.rb</em></span></p><p>An array may include expressions that yield values. Let’s assume you have already created this method:<a id="IDX-CHP-4-0012" class="indexterm"/><a id="IDX-CHP-4-0013" class="indexterm"/><a id="IDX-CHP-4-0014" class="indexterm"/></p><p><span class="emphasis"><em>array2.rb</em></span></p><a id="I_programlisting4_d1e3976"/><pre class="programlisting">def hello
  return "hello world"
end</pre><p>You can now declare this array:</p><a id="I_programlisting4_d1e3981"/><pre class="programlisting">x = [1+2, hello, `dir`]</pre><p>Here, the first element is a mathematical expression that yields the integer 3, and the second is the string “hello world” (returned by the method <code class="literal">hello</code>). If you run this on Windows, the third array element will be a string containing a directory listing. This is because <code class="literal">`dir`</code> is a back-quoted string, which is executed by the operating system (see <a class="xref" href="ch03.html" title="Chapter 3. Strings and Ranges">Chapter 3</a>). The final “slot” in the array is, therefore, filled with the value returned by the <code class="literal">dir</code> command, which happens to be a string of filenames. If you are running on a different operating system, you may need to substitute an appropriate command at this point. (For example, if you’re running a Unix-like operating system, you could substitute <code class="literal">`ls`</code> to get a similar string of filenames.)<a id="IDX-CHP-4-0015" class="indexterm"/></p><div class="sidebar"><a id="creating_an_array_of_filenames"/><p class="title">Creating an Array of Filenames</p><p>A number of Ruby classes have methods that return arrays of values. For example, the <code class="literal">Dir</code> class, which is used to perform operations on disk directories, has the <code class="literal">entries</code> method. Pass a directory name to the method, and it returns a list of files in an array:</p><a id="I_programlisting4_d1e4016"/><pre class="programlisting">Dir.entries( 'C:\\' )  # returns an array of files in C:\</pre></div><p><span class="emphasis"><em>dir_array.rb</em></span></p><p>If you want to create an array of single-quoted strings but can’t be bothered to type all the quotation marks, a shortcut is to put unquoted text separated by spaces between parentheses preceded by <code class="literal">%w</code> (or use a capital <code class="literal">%W</code> for double-quoted strings, as explained in <a class="xref" href="ch03.html" title="Chapter 3. Strings and Ranges">Chapter 3</a>).<a id="IDX-CHP-4-0016" class="indexterm"/><a id="IDX-CHP-4-0017" class="indexterm"/><a id="IDX-CHP-4-0018" class="indexterm"/><a id="IDX-CHP-4-0019" class="indexterm"/></p><p><span class="emphasis"><em>array2.rb</em></span></p><a id="I_programlisting4_d1e4046"/><pre class="programlisting">y = %w( this is an array of strings )</pre><p>The previous code assigns the array shown next to the variable, <code class="literal">y</code>:</p><a id="I_programlisting4_d1e4053"/><pre class="programlisting">["this", "is", "an", "array", "of", "strings"]</pre><p>You can also create arrays using the usual object construction method, <code class="literal">new</code>. Optionally, you can pass an integer to <code class="literal">new</code> to create an empty array of a specific size (with each element set to <code class="literal">nil</code>), or you can pass two arguments: the first to set the size of the array and the second to specify the element to place at each index of the array, like this:</p><a id="I_programlisting4_d1e4067"/><pre class="programlisting">a = Array.new                     # an empty array
a = Array.new(2)                  # [nil,nil]
a = Array.new(2,"hello world")    # ["hello world","hello world"]</pre></div><div class="sect2" title="Multidimensional Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="multidimensional_arrays"/>Multidimensional Arrays</h2></div></div></div><p>To create a multidimensional array, you can create one array and then add other arrays to each of its “slots.” For example, this creates an array containing two elements, each of which is itself an array of two elements:<a id="IDX-CHP-4-0020" class="indexterm"/></p><a id="I_programlisting4_d1e4079"/><pre class="programlisting">a = Array.new(2)
a[0]= Array.new(2,'hello')
a[1]= Array.new(2,'world')</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>You can also create an Array object by passing an array as an argument to the <code class="literal">new</code> method. Be careful, though: Ruby considers it a syntax error if you fail to leave a space between the <code class="literal">new</code> method and the opening square bracket. In other words, this works: <code class="literal">a = Array.new [1,2,3]</code>. However, this doesn’t: <code class="literal">a = Array.new[1,2,3]</code>. But using parentheses always works, no matter where you put a space: <code class="literal">a = Array.new([1,2,3])</code>.</p></div><p>It is also possible to nest arrays inside one another using square brackets. This creates an array of four arrays, each of which contains four integers:</p><a id="I_programlisting4_d1e4101"/><pre class="programlisting">a = [    [1,2,3,4],
    [5,6,7,8],
    [9,10,11,12],
    [13,14,15,16]  ]</pre><p>In the previous code, I have placed the four “subarrays” on separate lines. This is not obligatory, but it does help clarify the structure of the multidimensional array by displaying each subarray as though it were a row, similar to the rows in a spreadsheet. When talking about arrays within arrays, it is convenient to refer to each nested array as a “row” of the “outer” array.<a id="IDX-CHP-4-0021" class="indexterm"/></p><p>For some more examples of using multidimensional arrays, load the <span class="emphasis"><em>multi_array.rb</em></span> program. This starts by creating an array, <code class="literal">multiarr</code>, containing two other arrays. The first of these arrays is at index 0 of <code class="literal">multiarr</code>, and the second is at index 1:</p><p><span class="emphasis"><em>multi_array.rb</em></span></p><a id="I_programlisting4_d1e4124"/><pre class="programlisting">multiarr = [['one','two','three','four'],[1,2,3,4]]</pre><p>Next you need to find some way to locate the individual elements within arrays, which are themselves contained inside other arrays. You’ll consider this problem in the next section.</p></div><div class="sect2" title="Iterating over Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="iterating_over_arrays"/>Iterating over Arrays</h2></div></div></div><p>You can access the elements of an array by iterating over them using a <code class="literal">for</code> loop. In many programming languages, a <code class="literal">for</code> loop counts over a fixed number of elements from a starting number (such as 0) to an ending number (such as 10), incrementing a counter variable (such as <code class="literal">i</code>) at each pass through the loop. So, in other languages, you might be used to writing a loop something like this: <code class="literal">for i = 1 to 10</code>.<a id="IDX-CHP-4-0022" class="indexterm"/><a id="IDX-CHP-4-0023" class="indexterm"/></p><p>In Ruby, the normal <code class="literal">for</code> loop counts over all the items <span class="emphasis"><em>in</em></span> a collection and may be referred to as a <code class="literal">for..in</code> loop. Its counter variable is assigned each object in a collection, one by one, at each pass through the loop. The syntax may be summarized as <code class="literal">for</code> <em class="replaceable"><code>anObject</code></em> <code class="literal">in</code> <em class="replaceable"><code>aCollection</code></em>, and at each turn through the loop, the variable <code class="literal">anObject</code> is assigned a new item from the collection <code class="literal">aCollection</code> until no more items remain. The loop shown next iterates over two elements, namely, the two subarrays at index 0 and 1:</p><a id="I_programlisting4_d1e4183"/><pre class="programlisting">for i in multiarr
    puts(i.inspect)
end</pre><p>This displays the following:</p><a id="I_programlisting4_d1e4187"/><pre class="programlisting">["one", "two", "three", "four"]
[1, 2, 3, 4]</pre><p>So, how do you iterate over the items (the strings and integers) in each of the two subarrays? If there is a fixed number of items, you could specify a different iterator variable for each, in which case each variable will be assigned the value from the matching array index.</p><p>Here you have four subarray slots, so you could use four variables like this:</p><a id="I_programlisting4_d1e4193"/><pre class="programlisting">for (a,b,c,d) in multiarr
    print("a=#{a}, b=#{b}, c=#{c}, d=#{d}\n" )
end</pre><p>You could also use a <code class="literal">for</code> loop to iterate over all the items in each subarray individually:</p><p><span class="emphasis"><em>multi_array2.rb</em></span></p><a id="I_programlisting4_d1e4204"/><pre class="programlisting">for s in multiarr[0]
   puts(s)
end
for s in multiarr[1]
   puts(s)
end</pre><p>Both of these techniques (multiple iterator variables and multiple <code class="literal">for</code> loops) have two requirements: that you know how many items there are in either the “rows” or the “columns” of the grid of arrays and that each subarray contains the same number of items as each other.<a id="IDX-CHP-4-0024" class="indexterm"/><a id="IDX-CHP-4-0025" class="indexterm"/></p><p>For a more flexible way of iterating over multidimensional arrays, you could use nested <code class="literal">for</code> loops. An outer loop iterates over each row (subarray), and an inner loop iterates over each item in the current row. This technique works even when subarrays have varying numbers of items:</p><a id="I_programlisting4_d1e4226"/><pre class="programlisting">for row  in multiarr
   for item in row
     puts(item)
   end
end</pre><p>You’ll be looking at <code class="literal">for</code> loops and other iterators in more depth in the next chapter.</p></div><div class="sect2" title="Indexing into Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="indexing_into_arrays"/>Indexing into Arrays</h2></div></div></div><p>As with strings (see <a class="xref" href="ch03.html" title="Chapter 3. Strings and Ranges">Chapter 3</a>), you can index from the end of an array using negative numbers, where −1 is the index of the last element, −2 is the second-to-last, and so on. You can also use ranges, like this:</p><p><span class="emphasis"><em>array_index.rb</em></span></p><a id="I_programlisting4_d1e4244"/><pre class="programlisting">arr = ['h','e','l','l','o',' ','w','o','r','l','d']

print( arr[0,5] )        #=&gt; hello (or) ["h", "e", "l", "l", "o"]
print( arr[-5,5 ] )      #=&gt; world (or) ["w", "o", "r", "l", "d"]
print( arr[0..4] )       #=&gt; hello (or) ["h", "e", "l", "l", "o"]
print( arr[-5..-1] )     #=&gt; world (or) ["w", "o", "r", "l", "d"]</pre><p>Note that the output displayed by <code class="literal">print</code> or <code class="literal">puts</code> may vary depending on your version of Ruby. When Ruby 1.8 displays the elements in an array, it shows them one after the other so they look like a single string, as in <code class="literal">hello</code>. Ruby 1.9, however, shows the items in array format, as in <code class="literal">["h", "e", "l", "l", "o"]</code>.<a id="IDX-CHP-4-0026" class="indexterm"/><a id="IDX-CHP-4-0027" class="indexterm"/></p><p>If you use <code class="literal">p</code> instead of <code class="literal">print</code> to inspect the array, both Ruby 1.8 and 1.9 display the same result:</p><a id="I_programlisting4_d1e4278"/><pre class="programlisting">p( arr[0,5] )     #=&gt; ["h", "e", "l", "l", "o"]
p( arr[0..4] )    #=&gt; ["h", "e", "l", "l", "o"]</pre><p>As with strings, when you provide two integers in order to return a number of contiguous items from an array, the first integer is the start index, while the second is a <span class="emphasis"><em>count</em></span> of the number of items (<span class="emphasis"><em>not</em></span> an index):</p><a id="I_programlisting4_d1e4288"/><pre class="programlisting">arr[0,5]    # returns 5 chars - ["h", "e", "l", "l", "o"]</pre><p>You can also make assignments by indexing into an array. Here, for example, I first create an empty array and then put items into indexes 0, 1, and 3. The “empty” slot at index 2 will be filled with a <code class="literal">nil</code> value:<a id="IDX-CHP-4-0028" class="indexterm"/><a id="IDX-CHP-4-0029" class="indexterm"/></p><p><span class="emphasis"><em>array_assign.rb</em></span></p><a id="I_programlisting4_d1e4309"/><pre class="programlisting">arr = []

arr[0] = [0]
arr[1] = ["one"]
arr[3] = ["a", "b", "c"]

# arr now contains:
# [[0], ["one"], nil, ["a", "b", "c"]]</pre><p>Once again, you can use start-end indexes, ranges, and negative index values:</p><a id="I_programlisting4_d1e4313"/><pre class="programlisting">arr2 = ['h','e','l','l','o',' ','w','o','r','l','d']

arr2[0] = 'H'
arr2[2,2] = 'L', 'L'
arr2[4..6] = 'O','-','W'
arr2[-4,4] = 'a','l','d','o'

# arr2 now contains:
# ["H", "e", "L", "L", "O", "-", "W", "a", "l", "d", "o"]</pre></div><div class="sect2" title="Copying Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="copying_arrays"/>Copying Arrays</h2></div></div></div><p>Note that when you use the assignment operator (<code class="literal">=</code>) to assign one array variable to another variable, you are actually assigning a <span class="emphasis"><em>reference</em></span> to the array; you are not making a copy. For example, if you assign one array called <code class="literal">arr1</code> to another array called <code class="literal">arr2</code>, any changes made to either variable will also alter the value of the other because <span class="emphasis"><em>both variables refer to the same array</em></span>. If you want the variables to reference two different arrays, you can use the <code class="literal">clone</code> method to make a new copy:<a id="IDX-CHP-4-0030" class="indexterm"/></p><p><span class="emphasis"><em>array_copy.rb</em></span></p><a id="I_programlisting4_d1e4347"/><pre class="programlisting">arr1=['h','e','l','l','o',' ','w','o','r','l','d']
arr2=arr1  # arr2 is now the same as arr1.
           # Change arr1 and arr2 changes too!
arr3=arr1.clone
           # arr3 is a copy of arr1.
           # Change arr3 and arr2 is unaffected</pre></div><div class="sect2" title="Testing Arrays for Equality"><div class="titlepage"><div><div><h2 class="title"><a id="testing_arrays_for_equality"/>Testing Arrays for Equality</h2></div></div></div><p>The comparison operator for arrays is <code class="literal">&lt;=&gt;</code>. This compares two arrays—let’s call them <code class="literal">arr1</code> and <code class="literal">arr2</code>. It returns −1 if <code class="literal">arr1</code> is less than <code class="literal">arr2</code>, it returns 0 if <code class="literal">arr1</code> and <code class="literal">arr2</code> are equal, and it returns 1 if <code class="literal">arr2</code> is greater than <code class="literal">arr1</code>. But how does Ruby determine whether one array is “greater than” or “less than” another? It compares each item in one array with the corresponding item in the other. When two values are not equal, the result of their comparison is returned. In other words, if this comparison were made:<a id="IDX-CHP-4-0031" class="indexterm"/><a id="IDX-CHP-4-0032" class="indexterm"/><a id="IDX-CHP-4-0033" class="indexterm"/></p><a id="I_programlisting4_d1e4393"/><pre class="programlisting">[0,10,20] &lt;=&gt; [0,20,20]</pre><p>the value −1 would be returned. This means the first array is “less than” the second, since the integer at index 1 of the first array (10) is less than the integer at index 1 in the second array (20).</p><p>If you want to make a comparison based on the array’s length rather than the value of its elements, you can use the <code class="literal">length</code> method:</p><a id="I_programlisting4_d1e4402"/><pre class="programlisting">#  Here [2,3,4].length is less than [1,2,3,4].length
p([1,2,3].length&lt;=&gt;[1,2,3,4].length)    #=&gt; −1
p([2,3,4].length&lt;=&gt;[1,2,3,4].length)    #=&gt; −1</pre><p>If you are comparing arrays of strings, then comparisons are made on the ASCII values of the characters that make up those strings. If one array is longer than another and the elements in both arrays are equal, then the longer array is deemed to be “greater.” However, if two such arrays are compared and one of the elements in the shorter array is greater than the corresponding element in the longer array, then the <span class="emphasis"><em>shorter</em></span> array is deemed to be greater.</p><p><span class="emphasis"><em>array_compare.rb</em></span></p><a id="I_programlisting4_d1e4412"/><pre class="programlisting">p([1,2,3]&lt;=&gt;[2,3,4])            #=&gt; −1     (array 1 &lt; array 2)
p([2,3,4]&lt;=&gt;[1,2,3])            #=&gt; 1      (array 1 &gt; array 2)
p([1,2,3,4]&lt;=&gt;[1,2,3])          #=&gt; 1      (array 1 &gt; array 2)all
p([1,2,3,4]&lt;=&gt;[100,200,300])    #=&gt; −1     (array 1 &lt; array 2)
p([1,2,3]&lt;=&gt;["1","2","3"])      #=&gt; nil    (invalid comparison)</pre></div><div class="sect2" title="Sorting Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="sorting_arrays"/>Sorting Arrays</h2></div></div></div><p>The <code class="literal">sort</code> method compares adjacent array elements using the comparison operator <code class="literal">&lt;=&gt;</code>. This operator is defined for many Ruby classes, including Array, String, Float, Date, and Fixnum. The operator is not, however, defined for <span class="emphasis"><em>all</em></span> classes (that is to say, it is not defined for the Object class from which all other classes are derived). One of the unfortunate consequences of this is that it cannot be used to sort arrays containing <code class="literal">nil</code> values. However, it is possible to get around this limitation by defining your own sorting routine. This is done by sending a <span class="emphasis"><em>block</em></span> to the <code class="literal">sort</code> method. You’ll learn about blocks in detail in <a class="xref" href="ch10.html" title="Chapter 10. Blocks, Procs, and Lambdas">Chapter 10</a>, but for now it’s enough to know a block is a chunk of code delimited either by curly brackets or by the keywords <code class="literal">do</code> and <code class="literal">end</code>. The following block determines the comparison used by the <code class="literal">sort</code> method:<a id="IDX-CHP-4-0034" class="indexterm"/></p><a id="I_programlisting4_d1e4454"/><pre class="programlisting">arr.sort{
  |a,b|
    a.to_s &lt;=&gt; b.to_s
}</pre><p>Here <code class="literal">arr</code> is an array object, and the variables <code class="literal">a</code> and <code class="literal">b</code> represent two contiguous array elements. I’ve converted each variable to a string using the <code class="literal">to_s</code> method; this converts <code class="literal">nil</code> to an empty string that will be sorted “low.” Note that although my sorting block defines the sort order of the array items, it does not change the array items themselves. So, <code class="literal">nil</code> will remain as <code class="literal">nil</code>, and integers will remain as integers. The string conversion is used only to implement the comparison, not to change the array items.<a id="IDX-CHP-4-0035" class="indexterm"/><a id="IDX-CHP-4-0036" class="indexterm"/></p><p><span class="emphasis"><em>array_sort.rb</em></span></p><a id="I_programlisting4_d1e4489"/><pre class="programlisting">arr = ['h','e','l','l','o',' ',nil,'w','o','r','l','d',1,2,3,nil,4,5]

# sort ascending from nil upwards
sorted_arr = arr.sort{
    |a,b|
        a.to_s &lt;=&gt; b.to_s
    }

p(sorted_arr )</pre><p>This is the array created and displayed by the previous code:</p><a id="I_programlisting4_d1e4493"/><pre class="programlisting">[nil, nil, " ", 1, 2, 3, 4, 5, "d", "e", "h", "l", "l", "l", "o", "o", "r", "w"]</pre><p>The <span class="emphasis"><em>array_sort.rb</em></span> program supplied in the code archive also contains a method to sort in descending order. This is done simply by changing the order of the items on either side of the comparison operator:</p><a id="I_programlisting4_d1e4500"/><pre class="programlisting">reverse_sorted_arr = arr.sort{
    |a,b|
        b.to_s &lt;=&gt; a.to_s
    }</pre></div><div class="sect2" title="Comparing Values"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_values"/>Comparing Values</h2></div></div></div><p>The comparison “operator” <code class="literal">&lt;=&gt;</code> (which is, in fact, a method) is defined in the Ruby module named <code class="literal">Comparable</code>. For now, you can think of a module as a sort of reusable code library. You’ll be looking more closely at modules in <a class="xref" href="ch12.html" title="Chapter 12. Modules and Mixins">Chapter 12</a>.<a id="IDX-CHP-4-0037" class="indexterm"/></p><p>You can include the <code class="literal">Comparable</code> module in your own classes. This lets you override the <code class="literal">&lt;=&gt;</code> method to enable you to define exactly how comparisons will be made between specific object types. For example, you may want to subclass Array so that comparisons are made based purely on the length of two arrays rather than on the value of each item in the array (which is the default, as explained in See Testing Arrays for Equality). This is how you might do this:</p><p><span class="emphasis"><em>comparisons.rb</em></span></p><a id="I_programlisting4_d1e4529"/><pre class="programlisting">class MyArray &lt; Array
  include Comparable

  def &lt;=&gt; ( anotherArray )
    self.length &lt;=&gt; anotherArray.length
  end
end</pre><p>Now, you can initialize two MyArray objects like this:<a id="IDX-CHP-4-0038" class="indexterm"/><a id="IDX-CHP-4-0039" class="indexterm"/><a id="IDX-CHP-4-0040" class="indexterm"/><a id="IDX-CHP-4-0041" class="indexterm"/><a id="IDX-CHP-4-0042" class="indexterm"/></p><a id="I_programlisting4_d1e4548"/><pre class="programlisting">myarr1 = MyArray.new([0,1,2,3])
myarr2 = MyArray.new([1,2,3,4])</pre><p>And you can use the <code class="literal">&lt;=&gt;</code> method defined in MyArray to make comparisons:</p><a id="I_programlisting4_d1e4555"/><pre class="programlisting"># Two MyArray objects
myarr1 &lt;=&gt; myarr2        #=&gt; 0</pre><p>This comparison returns 0, which indicates that the two arrays are equal (since our <code class="literal">&lt;=&gt;</code> method evaluates equality according to length alone). If, on the other hand, you were to initialize two standard arrays with exactly the same integer values, the Array class’s own <code class="literal">&lt;=&gt;</code> method would perform the comparison:</p><a id="I_programlisting4_d1e4565"/><pre class="programlisting"># Two Array objects
arr1 &lt;=&gt; arr2        #=&gt; −1</pre><p>Here the comparison returns −1, which indicates that the first array evaluates to “less than” the second array, since the Array class’s <code class="literal">&lt;=&gt;</code> method compares the numerical values of each item in <code class="literal">arr1</code> and these are less than the values of the items at the same indexes in <code class="literal">arr2</code>.</p><p>But what if you want to make “less than,” “equal to,” and “greater than” comparisons using the traditional programming notation?</p><a id="I_programlisting4_d1e4581"/><pre class="programlisting">&lt;                 # less than
==                # equal to
&gt;                 # greater than</pre><p>In the MyArray class, you can make comparisons of this sort without writing any additional code. This is because the <code class="literal">Comparable</code> module, which has been included in the MyArray class, automatically supplies these three comparison methods; each method makes its comparison based on the definition of the <code class="literal">&lt;=&gt;</code> method. Since our <code class="literal">&lt;=&gt;</code> makes its evaluation based on the number of items in an array, the <code class="literal">&lt;</code> method evaluates to true when the first array is shorter than the second, <code class="literal">==</code> evaluates to true when both arrays are of equal length, and <code class="literal">&gt;</code> evaluates to true when the second array is longer than the first:</p><a id="I_programlisting4_d1e4604"/><pre class="programlisting">p( myarr1 &lt; myarr2 )      #=&gt; false
p( myarr1 == myarr2 )     #=&gt; true</pre><p>The standard Array class does not include the <code class="literal">Comparable</code> module. So if you try to compare two ordinary arrays using <code class="literal">&lt;</code>, <code class="literal">==</code>, or <code class="literal">&gt;</code>, Ruby will display an error message telling you that the method is undefined.</p><p>However, it’s easy to add these three methods to a subclass of Array. All you have to do is include Comparable, like this:<a id="IDX-CHP-4-0043" class="indexterm"/></p><a id="I_programlisting4_d1e4627"/><pre class="programlisting">class Array2 &lt; Array
  include Comparable
end</pre><p>The Array2 class will now perform its comparisons based on the <code class="literal">&lt;=&gt;</code> method of Array—that is, by testing the values of the items stored in the array rather than merely testing the length of the array. Assuming that the Array2 objects, <code class="literal">arr1</code> and <code class="literal">arr2</code>, are initialized with the same arrays that you previously used for <code class="literal">myarr1</code> and <code class="literal">myarr2</code>, you would now see these results:</p><a id="I_programlisting4_d1e4646"/><pre class="programlisting">p( arr1 &lt; arr2 )        #=&gt; true
p( arr1 &gt; arr2 )        #=&gt; false</pre></div><div class="sect2" title="Array Methods"><div class="titlepage"><div><div><h2 class="title"><a id="array_methods"/>Array Methods</h2></div></div></div><p>Several of the standard array methods modify the array itself rather than returning a modified copy of the array. These include the methods marked with a terminating exclamation point, such as <code class="literal">sort!</code>, <code class="literal">reverse!</code>, <code class="literal">flatten!</code>, and <code class="literal">compact!</code>. These also include the <code class="literal">&lt;&lt;</code> method, which modifies the array to its left by adding to it the array on its right; <code class="literal">clear</code>, which removes all the elements from the given array; and <code class="literal">delete</code> and <code class="literal">delete_at</code>, which remove selected elements. <a class="xref" href="ch04.html#commonly_used_array_methods" title="Table 4-1. Commonly Used Array Methods">Table 4-1</a> shows some of the more commonly used Array methods.<a id="IDX-CHP-4-0044" class="indexterm"/><a id="IDX-CHP-4-0045" class="indexterm"/><a id="IDX-CHP-4-0046" class="indexterm"/><a id="IDX-CHP-4-0047" class="indexterm"/><a id="IDX-CHP-4-0048" class="indexterm"/><a id="IDX-CHP-4-0049" class="indexterm"/><a id="IDX-CHP-4-0050" class="indexterm"/><a id="IDX-CHP-4-0051" class="indexterm"/><a id="IDX-CHP-4-0052" class="indexterm"/><a id="IDX-CHP-4-0053" class="indexterm"/><a id="IDX-CHP-4-0054" class="indexterm"/><a id="IDX-CHP-4-0055" class="indexterm"/></p><div class="table"><a id="commonly_used_array_methods"/><p class="title">Table 4-1. Commonly Used Array Methods</p><div class="table-contents"><table summary="Commonly Used Array Methods" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Array</p></th><th style="text-align: left" valign="bottom"><p>Task</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">&amp;</code><a id="IDX-CHP-4-0056" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>Returns common elements of two arrays, no duplicates</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code><a id="IDX-CHP-4-0057" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>Returns array concatenating two arrays</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code><a id="IDX-CHP-4-0058" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>Returns array with items in second array removed from first</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&lt;</code></p></td><td style="text-align: left" valign="top"><p>Modifies first array by appending items from second array</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">clear</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by removing all elements</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">compact</code></p></td><td style="text-align: left" valign="top"><p>Returns array with <code class="literal">nil</code> items removed</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">compact!</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by removing <code class="literal">nil</code> items</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">delete( object )</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by deleting object</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">delete_at( index )</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by deleting item at index</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">flatten</code></p></td><td style="text-align: left" valign="top"><p>Unpacks nested array items and returns array</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">flatten!</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by unpacking nested array items</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">length</code></p></td><td style="text-align: left" valign="top"><p>Returns number of elements in array</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">reverse</code></p></td><td style="text-align: left" valign="top"><p>Returns array with elements in reverse order</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">reverse!</code></p></td><td style="text-align: left" valign="top"><p>Modifies array by reversing element order</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sort</code></p></td><td style="text-align: left" valign="top"><p>Returns array sorted using <code class="literal">&lt;=&gt;</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sort!</code></p></td><td style="text-align: left" valign="top"><p>Modifies array sorted using <code class="literal">&lt;=&gt;</code></p></td></tr></tbody></table></div></div><p>You can try the previous methods in the <span class="emphasis"><em>array_methods.rb</em></span> sample program. Here are a few examples:<a id="IDX-CHP-4-0059" class="indexterm"/></p><p><span class="emphasis"><em>array_methods.rb</em></span></p><a id="I_programlisting4_d1e4921"/><pre class="programlisting">arr1 = [1,1,2,2,3,3]
arr2 = [1,2,3,4,5,6,7,8,9]
arr3 = ['h','e','l','l','o',' ',nil,'w','o','r','l','d']

p(arr1&amp;arr2 )       #=&gt; [1, 2, 3]
p(arr1+arr2)        #=&gt; [1, 1, 2, 2, 3, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9]
p(arr1-arr2)        #=&gt; []
p(arr2-arr1)        #=&gt; [4, 5, 6, 7, 8, 9]
arr1&lt;&lt;arr2
p(arr1)             #=&gt; [1, 1, 2, 2, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]]
arr1.clear
p(arr1)             #=&gt;[]</pre><p>Although most of the behavior array methods may be deduced from their names, the <code class="literal">flatten</code> and <code class="literal">compact</code> methods need some explanation. An array is said to be <span class="emphasis"><em>flattened</em></span> when it contains no subarrays. So if you have an array like <code class="literal">[1,[2,3]]</code>, you can call <code class="literal">[1,[2,3]].flatten</code> to return this array: <code class="literal">[1,2,3]</code>.<a id="IDX-CHP-4-0060" class="indexterm"/><a id="IDX-CHP-4-0061" class="indexterm"/></p><p>An array is said to be <span class="emphasis"><em>compacted</em></span> when it contains no <code class="literal">nil</code> items. So if you have an array like <code class="literal">[1,2,nil,3]</code>, you can call <code class="literal">[1,2,nil,3].compact</code> to return this array: <code class="literal">[1,2,3]</code>. The methods of Array can be chained together by placing one method call directly after the other:</p><p><span class="emphasis"><em>flatten_compact.rb</em></span></p><a id="I_programlisting4_d1e4974"/><pre class="programlisting">p( [1,nil,[2,nil,3]].flatten.compact ) #=&gt; [1,2,3]</pre></div></div></div>
<div class="sect1" title="Hashes"><div class="titlepage"><div><div><h1 class="title"><a id="hashes"/>Hashes</h1></div></div></div><p>Although arrays provide a good way of indexing a collection of items by number, sometimes it would be more convenient to index them in some other way. If, for example, you were creating a collection of recipes, it would be more meaningful to have each recipe indexed by name, such as “Rich Chocolate Cake” and “Coq au Vin,” rather than by numbers.<a id="IDX-CHP-4-0062" class="indexterm"/></p><p>Ruby has a class that lets you do just that, called a <span class="emphasis"><em>hash</em></span>. This is the equivalent of what some other languages call a dictionary or associative array. Just like a real dictionary, each entry is indexed by a unique <span class="emphasis"><em>key</em></span> (in a real-life dictionary, this would be a word) that is associated with a value (in a dictionary, this would be the definition of the word).</p><div class="sect2" title="Creating Hashes"><div class="titlepage"><div><div><h2 class="title"><a id="creating_hashes"/>Creating Hashes</h2></div></div></div><p>Just like an array, you can create a hash by creating a new instance of the Hash class:</p><p><span class="emphasis"><em>hash1.rb</em></span></p><a id="I_programlisting4_d1e5002"/><pre class="programlisting">h1 = Hash.new
h2 = Hash.new("Some kind of ring")</pre><p>Both the previous examples create an empty Hash object. A Hash object always has a default value—that is, a value that is returned when no specific value is found at a given index. In these examples, <code class="literal">h2</code> is initialized with the default value <code class="literal">"Some kind of ring"</code>; <code class="literal">h1</code> is not initialized with a value, so its default value will be <code class="literal">nil</code>.</p><p>Having created a Hash object, you can add items to it using an arraylike syntax—that is, by placing the index in square brackets and using <code class="literal">=</code> to assign a value. The obvious difference is that, with an array, the index (or <span class="emphasis"><em>key</em></span>) must be an integer; with a hash, it can be any unique data item:</p><a id="I_programlisting4_d1e5026"/><pre class="programlisting">h2['treasure1'] = 'Silver ring'
h2['treasure2'] = 'Gold ring'
h2['treasure3'] = 'Ruby ring'
h2['treasure4'] = 'Sapphire ring'</pre><p>Often, the key may be a number or, as in the previous code, a string. In principle, however, a key can be any type of object. For example, given some class X, the following assignment is perfectly legal:</p><a id="I_programlisting4_d1e5030"/><pre class="programlisting">x1 = X.new('my Xobject')
h2[x1] = 'Diamond ring'</pre><div class="sidebar"><a id="unique_keys_question"/><p class="title">Unique Keys?</p><p>Take care when assigning keys to hashes. If you use the same key twice in a hash, you will end up overwriting the original value. This is just like assigning a value twice to the same index in an array. Consider this example:<a id="IDX-CHP-4-0063" class="indexterm"/></p><a id="I_programlisting4_d1e5040"/><pre class="programlisting">h2['treasure1'] = 'Silver ring'
h2['treasure2'] = 'Gold ring'
h2['treasure3'] = 'Ruby ring'
h2['treasure1'] = 'Sapphire ring'</pre><p>Here the key <code class="literal">'treasure1'</code> has been used twice. As a consequence, the original value, <code class="literal">'Silver ring'</code>, has been replaced by <code class="literal">'Sapphire ring'</code>, resulting in this hash:</p><a id="I_programlisting4_d1e5053"/><pre class="programlisting">{"treasure1"=&gt;"Sapphire ring", "treasure2"=&gt;"Gold ring", "treasure3"=&gt;"Ruby ring"}</pre></div><p>There is a shorthand way of creating Hashes and initializing them with key-value pairs. Just add a key followed by <code class="literal">=&gt;</code> and its associated value; each key-value pair should be separated by a comma and the whole lot placed inside a pair of curly brackets:</p><a id="I_programlisting4_d1e5061"/><pre class="programlisting">h1 = {    'room1'=&gt;'The Treasure Room',
          'room2'=&gt;'The Throne Room',
          'loc1'=&gt;'A Forest Glade',
          'loc2'=&gt;'A Mountain Stream' }</pre></div><div class="sect2" title="Indexing into a Hash"><div class="titlepage"><div><div><h2 class="title"><a id="indexing_into_a_hash"/>Indexing into a Hash</h2></div></div></div><p>To access a value, place its key between square brackets:<a id="IDX-CHP-4-0064" class="indexterm"/><a id="IDX-CHP-4-0065" class="indexterm"/><a id="IDX-CHP-4-0066" class="indexterm"/><a id="IDX-CHP-4-0067" class="indexterm"/></p><a id="I_programlisting4_d1e5088"/><pre class="programlisting">puts(h1['room2'])            #=&gt; 'The Throne Room'</pre><p>If you specify a key that does not exist, the default value is returned. Recall that you have not specified a default value for <code class="literal">h1</code>, but you have for <code class="literal">h2</code>:<a id="IDX-CHP-4-0068" class="indexterm"/></p><a id="I_programlisting4_d1e5101"/><pre class="programlisting">p(h1['unknown_room'])        #=&gt; nil
p(h2['unknown_treasure'])    #=&gt; 'Some kind of ring'</pre><p>Use the <code class="literal">default</code> method to get the default value and the <code class="literal">default=</code> method to set it (see <a class="xref" href="ch02.html" title="Chapter 2. Class Hierarchies, Attributes, and Class Variables">Chapter 2</a> for more information on <code class="literal">get</code> and <code class="literal">set</code> accessor methods):<a id="IDX-CHP-4-0069" class="indexterm"/></p><a id="I_programlisting4_d1e5123"/><pre class="programlisting">p(h1.default)
h1.default = 'A mysterious place'</pre></div><div class="sect2" title="Copying a Hash"><div class="titlepage"><div><div><h2 class="title"><a id="copying_a_hash"/>Copying a Hash</h2></div></div></div><p>As with an array, you can assign one Hash variable to another, in which case both variables will refer to the same hash, and a change made using either variable will affect that hash:</p><p><span class="emphasis"><em>hash2.rb</em></span></p><a id="I_programlisting4_d1e5133"/><pre class="programlisting">h4 = h1
h4['room1']='A new Room'
puts(h1['room1'])        #=&gt; 'A new Room'</pre><p>If you want the two variables to refer to the same items in different Hash objects, use the <code class="literal">clone</code> method to make a new copy:<a id="IDX-CHP-4-0070" class="indexterm"/></p><a id="I_programlisting4_d1e5143"/><pre class="programlisting">h5 = h1.clone
h5['room1'] = 'An even newer Room'
puts(h1['room1'])        #=&gt; 'A new room' (i.e., its value is unchanged)</pre></div><div class="sect2" title="Hash Order"><div class="titlepage"><div><div><h2 class="title"><a id="hash_order"/>Hash Order</h2></div></div></div><p>The ordering of elements in a hash varies according to which version of Ruby you are using. In Ruby 1.8, a hash is generally stored in the order defined by its key where, for example, key 1 is less than key 2. When new items are added, these are inserted in key order. In Ruby 1.9, the hash is stored in the order in which it is defined. When new items are added, these are appended to the end of the hash.</p><p>As a general principle, it is best to make no assumptions about the order of elements in a hash. Most programming languages treat hashes or dictionaries as unordered collections. If you make the assumption that hash order is unpredictable, not only will you avoid bugs that may occur when running programs with different Ruby implementations, but you will also avoid problems that may arise when keys are of different types. Remember, a single hash may contain a mix of integer, string, and floating-point keys whose relative orders may not be self-evident.<a id="IDX-CHP-4-0071" class="indexterm"/><a id="IDX-CHP-4-0072" class="indexterm"/></p><p><span class="emphasis"><em>hash_order.rb</em></span></p><a id="I_programlisting4_d1e5163"/><pre class="programlisting">h = {2=&gt;"two", 1=&gt;"one", 4=&gt;"four" }
p( h )
h[3] = "three"
p( h )
h2 = {"one"=&gt;1, 2=&gt;"two", 4.5=&gt;"four" }
p (h2)</pre><p>When this code is run, Ruby 1.8 produces this output:</p><a id="I_programlisting4_d1e5167"/><pre class="programlisting">{1=&gt;"one", 2=&gt;"two", 4=&gt;"four"}
{1=&gt;"one", 2=&gt;"two", 3=&gt;"three", 4=&gt;"four"}
{4.5=&gt;"four", 2=&gt;"two", "one"=&gt;1}</pre><p>But Ruby 1.9 shows this:</p><a id="I_programlisting4_d1e5171"/><pre class="programlisting">{2=&gt;"two", 1=&gt;"one", 4=&gt;"four"}
{2=&gt;"two", 1=&gt;"one", 4=&gt;"four", 3=&gt;"three"}
{2=&gt;"two", "one"=&gt;1, 4.5=&gt;"four"}</pre></div><div class="sect2" title="Sorting a Hash"><div class="titlepage"><div><div><h2 class="title"><a id="sorting_a_hash"/>Sorting a Hash</h2></div></div></div><p>If you want to ensure that the elements of a hash are in a specific order, you may sort them. As with the Array class, you may find a slight problem with the <code class="literal">sort</code> method of Hash. It expects to be dealing with keys of the same data type, so if, for example, you merge two arrays, one of which uses integer keys and another of which uses strings, you won’t be able to sort the merged hash. The solution to this problem is, as with Array, to write some code to perform a custom type of comparison and pass this to the <code class="literal">sort</code> method. You might give it a method, like this:</p><p><span class="emphasis"><em>hash_sort.rb</em></span></p><a id="I_programlisting4_d1e5187"/><pre class="programlisting">def sorted_hash( aHash )
  return aHash.sort{
    |a,b|
      a.to_s &lt;=&gt; b.to_s
  }
end</pre><p>This performs the sort based on the string representation (<code class="literal">to_s</code>) of each key in the hash. In fact, the Hash <code class="literal">sort</code> method converts the hash to a nested array of <span class="emphasis"><em>[key, value]</em></span> arrays and sorts them using the Array <code class="literal">sort</code> method.</p></div><div class="sect2" title="Hash Methods"><div class="titlepage"><div><div><h2 class="title"><a id="hash_methods"/>Hash Methods</h2></div></div></div><p>The Hash class has numerous built-in methods. For example, to delete an item from a hash using its key, use the <code class="literal">delete</code> method:<a id="IDX-CHP-4-0073" class="indexterm"/><a id="IDX-CHP-4-0074" class="indexterm"/><a id="IDX-CHP-4-0075" class="indexterm"/><a id="IDX-CHP-4-0076" class="indexterm"/><a id="IDX-CHP-4-0077" class="indexterm"/><a id="IDX-CHP-4-0078" class="indexterm"/><a id="IDX-CHP-4-0079" class="indexterm"/><a id="IDX-CHP-4-0080" class="indexterm"/><a id="IDX-CHP-4-0081" class="indexterm"/><a id="IDX-CHP-4-0082" class="indexterm"/><a id="IDX-CHP-4-0083" class="indexterm"/></p><a id="I_programlisting4_d1e5265"/><pre class="programlisting">aHash.delete( someKey )To test if a key or value exists, use the
 has_key? and has_value? methods:aHash.has_key?( someKey )
aHash.has_value?( someValue )</pre><p>To combine two hashes, use the <code class="literal">merge</code> method: <code class="literal">hash1.merge( hash2 )</code>.</p><p>To return a new hash created using the original hash’s values as keys and its keys as values, use <code class="literal">aHash.invert</code>. To return an array populated with the hash’s keys or values, use <code class="literal">aHash.keys</code> and <code class="literal">aHash.values</code>.<a id="IDX-CHP-4-0084" class="indexterm"/><a id="IDX-CHP-4-0085" class="indexterm"/></p><p>Here’s an example that uses some of these methods:</p><p><span class="emphasis"><em>hash_methods.rb</em></span></p><a id="I_programlisting4_d1e5297"/><pre class="programlisting">h1 = {
    'room1'=&gt;'The Treasure Room',
    'room2'=&gt;'The Throne Room',
    'loc1'=&gt;'A Forest Glade',
    'loc2'=&gt;'A Mountain Stream'
    }

h2 = {1=&gt;'one', 2=&gt;'two', 3=&gt; 'three'}

h1['room1'] = 'You have wandered into a dark room'
h1.delete('loc2')
p(h1)
                         #=&gt; {"room1"=&gt;"You have wandered into a dark room",
                         #=&gt; "room2"=&gt;"The Throne Room",
                         #=&gt; "loc1"=&gt;"A Forest Glade"}
p(h1.has_key?('loc2'))   #=&gt; false
p(h2.has_value?("two"))  #=&gt;true
p(h2.invert)             #=&gt; {"one"=&gt;1, "two"=&gt;2, "three"=&gt;3}
p(h2.keys)               #=&gt;[1, 2, 3]
p(h2.values)             #=&gt;["one", "two", "three"]</pre><p>If you want to find the position of an item in a hash, use the <code class="literal">index</code> method with Ruby 1.8 and the <code class="literal">key</code> method in Ruby 1.9. The <code class="literal">index</code> method is still present in Ruby 1.9 but is deprecated, so it may be removed in future versions:</p><a id="I_programlisting4_d1e5310"/><pre class="programlisting">h2.index("two")    # use this with Ruby 1.8
h2.key("two")      # use this Ruby 1.9</pre><div class="sidebar"><a id="digging_deeper-id3"/><p class="title">Digging Deeper</p><p>In this section you will learn more ways of manipulating arrays and hashes as well as the fundamentals of matrices, vectors and sets.<a id="IDX-CHP-4-0086" class="indexterm"/><a id="IDX-CHP-4-0087" class="indexterm"/><a id="IDX-CHP-4-0088" class="indexterm"/><a id="IDX-CHP-4-0089" class="indexterm"/><a id="IDX-CHP-4-0090" class="indexterm"/></p><p><span class="bolditalic">Treating Hashes as Arrays</span></p><p>The <code class="literal">keys</code> and <code class="literal">values</code> methods of Hash each return an array, so you can use various Array methods to manipulate them. Here are a few simple examples (remember the order of the keys and value may differ according to the version of Ruby being used):</p><p><span class="emphasis"><em>hash_ops.rb</em></span></p><a id="I_programlisting4_d1e5356"/><pre class="programlisting">h1 = {'key1'=&gt;'val1', 'key2'=&gt;'val2', 'key3'=&gt;'val3', 'key4'=&gt;'val4'}
h2 = {'key1'=&gt;'val1', 'KEY_TWO'=&gt;'val2', 'key3'=&gt;'VALUE_3', 'key4'=&gt;'val4'}

p( h1.keys &amp; h2.keys )                         # set intersection (keys)
#=&gt; ["key1", "key3", "key4"]

p( h1.values &amp; h2.values )                     # set intersection (values)
#=&gt; ["val1", "val2", "val4"]

p( h1.keys+h2.keys )                           # concatenation
#=&gt; [ "key1", "key2", "key3", "key4", "key1", "key3", "key4", "KEY_TWO"]

p( h1.values-h2.values )                       # difference
#=&gt; ["val3"]

p( (h1.keys &lt;&lt; h2.keys)  )                     # append
#=&gt; ["key1", "key2", "key3", "key4", ["key1", "key3", "key4", "KEY_TWO"]]

p( (h1.keys &lt;&lt; h2.keys).flatten.reverse  )     # 'un-nest' arrays and reverse
#=&gt; ["KEY_TWO", "key4", "key3", "key1", "key4", "key3", "key2", "key1"]</pre><p><span class="bolditalic">Appending vs. Concatenating</span></p><p>Be careful to note the difference between concatenating using <code class="literal">+</code> to add the <span class="emphasis"><em>values</em></span> from the second array to the first and appending using <code class="literal">&lt;&lt;</code> to add the second <span class="emphasis"><em>array</em></span> itself as the final element of the first:<a id="IDX-CHP-4-0091" class="indexterm"/><a id="IDX-CHP-4-0092" class="indexterm"/><a id="IDX-CHP-4-0093" class="indexterm"/></p><p><span class="emphasis"><em>append_concat.rb</em></span></p><a id="I_programlisting4_d1e5392"/><pre class="programlisting">a =[1,2,3]
b =[4,5,6]
c = a + b            #=&gt; c=[1, 2, 3, 4, 5, 6]   a=[1, 2, 3]
a &lt;&lt; b               #=&gt; a=[1, 2, 3, [4, 5, 6]]</pre><p>In addition, <code class="literal">&lt;&lt;</code> modifies the first (the <span class="emphasis"><em>receiver</em></span>) array, whereas <code class="literal">+</code> returns a new array but leaves the receiver array unchanged.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In object-oriented terminology, the object to which a method belongs is called the <span class="emphasis"><em>receiver</em></span>. The idea is that instead of calling functions as in procedural languages, “messages” are sent to objects. For example, the message <code class="literal">+ 1</code> might be sent to an integer object, while the message <code class="literal">reverse</code> might be sent to a string object. The object that “receives” a message tries to find a way (that is, a <span class="emphasis"><em>method</em></span>) of responding to the message. A string object, for example, has a <code class="literal">reverse</code> method and so is able to respond to the <code class="literal">reverse</code> message, whereas an integer object has no such method so cannot respond.<a id="IDX-CHP-4-0094" class="indexterm"/><a id="IDX-CHP-4-0095" class="indexterm"/><a id="IDX-CHP-4-0096" class="indexterm"/><a id="IDX-CHP-4-0097" class="indexterm"/></p></div><p>You can use the <code class="literal">flatten</code> method to clean up two arrays you’ve combined with <code class="literal">&lt;&lt;</code>, like this:</p><a id="I_programlisting4_d1e5450"/><pre class="programlisting">a=[1, 2, 3, [4, 5, 6]]
a.flatten            #=&gt; [1, 2, 3, 4, 5, 6]</pre><p><span class="bolditalic">Vectors and Matrices</span></p><p>For the benefit of mathematicians, Ruby provides a Vector class and a Matrix class. A <span class="emphasis"><em>vector</em></span> is an ordered set of elements upon which certain mathematical operations may be performed. A <span class="emphasis"><em>matrix</em></span> is a collection of rows and columns, and each row is itself a vector. Matrices allow you to perform matrix manipulations, which is a subject beyond the scope of this book and is only likely to be of interest to mathematical programmers. However, you’ll look at some simple examples here.<a id="IDX-CHP-4-0098" class="indexterm"/></p><p>First, given two Matrix objects, <code class="literal">m1</code> and <code class="literal">m2</code>, you can add the values of each corresponding cell in the matrices with the plus sign, like this: <code class="literal">m3 = m1+m2</code>. You must import Matrix using a <code class="literal">require</code> directive in order to use it:</p><p><span class="emphasis"><em>matrix.rb</em></span></p><a id="I_programlisting4_d1e5483"/><pre class="programlisting">require "Matrix"    # This is essential!

m1 = Matrix[ [1,2,3,4],
            [5,6,7,8],
            [9,10,11,12],
            [13,14,15,16]  ]

m2 = Matrix[ [10,20,30,40],
            [50,60,70,80],
            [90,100,110,120],
            [130,140,150,160]  ]

m3 = m1+m2
p(m3)</pre><p>This outputs the following matrix:</p><a id="I_programlisting4_d1e5487"/><pre class="programlisting">Matrix[[11, 22, 33, 44], [55, 66, 77, 88], [99, 110, 121, 132], [143, 154, 165, 176]]</pre><p>The following example creates a matrix from two vectors. By passing vectors to the <code class="literal">Matrix.columns()</code> method, you construct a matrix whose rows are arrays of arrays. Here the matrix has two columns created from the vectors <code class="literal">v</code> and <code class="literal">v2</code>, with each row containing two items, one from each column:<a id="IDX-CHP-4-0099" class="indexterm"/><a id="IDX-CHP-4-0100" class="indexterm"/></p><a id="I_programlisting4_d1e5511"/><pre class="programlisting">v = Vector[1,2,3,4,5]
v2 = Vector[6,7,8,9,10]
m4 = Matrix.columns([v,v2])
p( m4 )</pre><p>This outputs the following:</p><a id="I_programlisting4_d1e5515"/><pre class="programlisting">Matrix[[1, 6], [2, 7], [3, 8], [4, 9], [5, 10]]</pre><p>If, on the other hand, you pass the same two vectors to the <code class="literal">Matrix.rows()</code> method, you would end up by creating a matrix that contains two rows, each of which is a vector:</p><a id="I_programlisting4_d1e5522"/><pre class="programlisting">m5 = Matrix.rows([v,v2])
p( m5 )</pre><p>This outputs the following:</p><a id="I_programlisting4_d1e5526"/><pre class="programlisting">Matrix[Vector[1, 2, 3, 4, 5], Vector[6, 7, 8, 9, 10]]</pre><p><span class="bolditalic">Sets</span></p><p>The Set class implements a collection of unordered values with no duplicates. You can initialize a Set with an array of values, in which case duplicates are ignored:</p><p><span class="emphasis"><em>sets.rb</em></span><a id="IDX-CHP-4-0101" class="indexterm"/></p><a id="I_programlisting4_d1e5539"/><pre class="programlisting">s1 = Set.new( [1,2,3,4,5,2] )
s2 = Set.new( [1,1,2,3,4,4,5,1] )
s3 = Set.new( [1,2,100] )
weekdays = Set.new( %w( Monday, Tuesday, Wednesday, Thursday,
        Friday, Saturday, Sunday ) )</pre><p>You can add new values using the <code class="literal">add</code> method:</p><a id="I_programlisting4_d1e5547"/><pre class="programlisting">s1.add( 1000 )</pre><p>The <code class="literal">merge</code> method combines values of one set with another:</p><a id="I_programlisting4_d1e5554"/><pre class="programlisting">s1.merge(s2)</pre><p>You can use <code class="literal">==</code> to test for equality. Two sets that contain the same values (remembering that duplicates will be removed when a set is created) are considered to be equal:<a id="IDX-CHP-4-0102" class="indexterm"/></p><a id="I_programlisting4_d1e5566"/><pre class="programlisting">p( s1 == s2 )            #=&gt; true</pre><p>If you display the contents of a set, the order may differ according to the version of Ruby being used. If order is important, you may convert a set to an array using the <code class="literal">to_a</code> method and use a standard or custom sort, as explained in <a class="xref" href="ch04.html#sorting_arrays" title="Sorting Arrays">Sorting Arrays</a> in <a class="xref" href="ch04.html#sorting_arrays" title="Sorting Arrays">Sorting Arrays</a>:<a id="IDX-CHP-4-0103" class="indexterm"/></p><a id="I_programlisting4_d1e5582"/><pre class="programlisting">p( weekdays.to_a.sort ) # sort alphabetically
#=&gt; ["Friday,", "Monday,", "Saturday,", "Sunday", "Thursday,", "Tuesday,",
 "Wednesday,"]</pre></div></div></div></body></html>