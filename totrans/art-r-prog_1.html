<html><head></head><body>
<p class="calibre1">[1] 123 4 5 6</p>
<p class="calibre1">&gt; scan("z2.txt")</p>
<p class="calibre1">Read 4 items</p>
<p class="calibre1">[1] 123.0 4.2 5.0 6.0</p>
<p class="calibre1">&gt; scan("z3.txt")</p>
<p class="calibre1">Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings, : scan() expected 'a real', got 'abc' </p>
<p class="calibre1">&gt; scan("z3.txt",what="")</p>
<p class="calibre1"><b class="calibre3">232</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p259"/>Read 4 items</p>
<p class="calibre1">[1] "abc" "de" "f" "g" </p>
<p class="calibre1">&gt; scan("z4.txt",what="")</p>
<p class="calibre1">Read 4 items</p>
<p class="calibre1">[1] "abc" "123" "6" "y" </p>
<p class="calibre1">In the first call, we got a vector of four integers (though the mode is numeric). The second time, since one number was nonintegral, the others were shown as floating-point numbers, too. </p>
<p class="calibre1">In the third case, we got an error. The scan() function has an optional argument named what, which specifies mode, defaulting to double mode. So, the nonnumeric contents of the file  <i class="calibre4">z3 </i> produced an error. But we then tried again, with what="". This assigns a character string to what, indicating that we want character mode. (We could have set what to any character string.) The last call worked the same way. The first item was a character string, so it treated all the items that followed as strings too. </p>
<p class="calibre1">Of course, in typical usage, we would assign the return value of scan() to a variable. Here’s an example:</p>
<p class="calibre1">&gt; v &lt;- scan("z1.txt")</p>
<p class="calibre1">By default, scan() assumes that the items of the vector are separated by <i class="calibre4">whitespace</i>, which includes blanks, carriage return/line feeds, and horizontal tabs. You can use the optional sep argument for other situations. As example, we can set sep to the newline character to read in each line as a string, as follows:</p>
<p class="calibre1">&gt; x1 &lt;- scan("z3.txt",what="")</p>
<p class="calibre1">Read 4 items</p>
<p class="calibre1">&gt; x2 &lt;- scan("z3.txt",what="",sep="\n") Read 3 items</p>
<p class="calibre1">&gt; x1</p>
<p class="calibre1">[1] "abc" "de" "f" </p>
<p class="calibre1">"g" </p>
<p class="calibre1">&gt; x2</p>
<p class="calibre1">[1] "abc" "de f" "g" </p>
<p class="calibre1">&gt; x1[2]</p>
<p class="calibre1">[1] "de" </p>
<p class="calibre1">&gt; x2[2]</p>
<p class="calibre1">[1] "de f" </p>
<p class="calibre1">In the first case, the strings "de" and "f" were assigned to separate elements of x1. But in the second case, we specified that elements of x2 were to be delineated by end-of-line characters, not spaces. Since "de" and "f" are on the same line, they are assigned together to x[2]. </p>
<p class="calibre1">More sophisticated methods for reading files will be presented later in this chapter, such as methods to read in a file one line at a time. But if you want to read the entire file at once, scan() provides a quick solution. </p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">233</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p260"/>You can use scan() to read from the keyboard by specifying an empty string for the filename:</p>
<p class="calibre1">&gt; v &lt;- scan("")</p>
<p class="calibre1">1: 12 5 13</p>
<p class="calibre1">4: 3 4 5</p>
<p class="calibre1">7: 8</p>
<p class="calibre1">8:</p>
<p class="calibre1">Read 7 items</p>
<p class="calibre1">&gt; v</p>
<p class="calibre1">[1] 12 5 13 3 4 5 8</p>
<p class="calibre1">Note that we are prompted with the index of the next item to be input, and we signal the end of input with an empty line. </p>
<p class="calibre1">If you do not wish scan() to announce the number of items it has read, include the argument quiet=TRUE. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.1.2 Using the readline() Function</b></i></p>
<p class="calibre1">If you want to read in a single line from the keyboard, readline() is very handy. </p>
<p class="calibre1">&gt; w &lt;- readline()</p>
<p class="calibre1">abc de f</p>
<p class="calibre1">&gt; w</p>
<p class="calibre1">[1] "abc de f" </p>
<p class="calibre1">Typically, readline() is called with its optional prompt, as follows:</p>
<p class="calibre1">&gt; inits &lt;- readline("type your initials: ")</p>
<p class="calibre1">type your initials: NM</p>
<p class="calibre1">&gt; inits</p>
<p class="calibre1">[1] "NM" </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.1.3 Printing to the Screen</b></i></p>
<p class="calibre1">At the top level of interactive mode, you can print the value of a variable or expression by simply typing the variable name or expression. This won’t work if you need to print from within the body of a function. In that case, you can use the print() function, like this:</p>
<p class="calibre1">&gt; x &lt;- 1:3</p>
<p class="calibre1">&gt; print(x^2)</p>
<p class="calibre1">[1] 1 4 9</p>
<p class="calibre1">Recall that print() is a  <i class="calibre4">generic </i> function, so the actual function called will depend on the class of the object that is printed. If, for example, the argument is of class "table", then the print.table() function will be called. </p>
<p class="calibre1"><b class="calibre3">234</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p261"/>It’s a little better to use cat() instead of print(), as the latter can print only one expression and its output is numbered, which may be a nuisance. </p>
<p class="calibre1">Compare the results of the functions:</p>
<p class="calibre1">&gt; print("abc")</p>
<p class="calibre1">[1] "abc" </p>
<p class="calibre1">&gt; cat("abc\n")</p>
<p class="calibre1">abc</p>
<p class="calibre1">Note that we needed to supply our own end-of-line character, "\n", in the call to cat(). Without it, our next call would continue to write to the same line. </p>
<p class="calibre1">The arguments to cat() will be printed out with intervening spaces:</p>
<p class="calibre1">&gt; x</p>
<p class="calibre1">[1] 1 2 3</p>
<p class="calibre1">&gt; cat(x,"abc","de\n")</p>
<p class="calibre1">1 2 3 abc de</p>
<p class="calibre1">If you don’t want the spaces, set sep to the empty string "", as follows:</p>
<p class="calibre1">&gt; cat(x,"abc","de\n",sep="")</p>
<p class="calibre1">123abcde</p>
<p class="calibre1">Any string can be used for sep. Here, we use the newline character:</p>
<p class="calibre1">&gt; cat(x,"abc","de\n",sep="\n")</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">abc</p>
<p class="calibre1">de</p>
<p class="calibre1">You can even set sep to be a vector of strings, like this:</p>
<p class="calibre1">&gt; x &lt;- c(5,12,13,8,88)</p>
<p class="calibre1">&gt; cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8</p>
<p class="calibre1">88</p>
<p class="calibre1"><b class="calibre3">10.2 Reading and Writing Files</b></p>
<p class="calibre1">Now that we’ve covered the basics of I/O, let’s get to some more practical applications of reading and writing files. The following sections discuss reading data frames or matrices from files, working with text files, accessing files on remote machines, and getting file and directory information. </p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">235</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p262"/> <i class="calibre4"><b class="calibre3">10.2.1 Reading a Data Frame or Matrix from a File</b></i></p>
<p class="calibre1">In Section 5.1.2, we discussed the use of the function read.table() to read in a data frame. As a quick review, suppose the file  <i class="calibre4">z </i> looks like this: name age</p>
<p class="calibre1">John 25</p>
<p class="calibre1">Mary 28</p>
<p class="calibre1">Jim 19</p>
<p class="calibre1">The first line contains an optional header, specifying column names. We could read the file this way:</p>
<p class="calibre1">&gt; z &lt;- read.table("z",header=TRUE)</p>
<p class="calibre1">&gt; z</p>
<p class="calibre1">name age</p>
<p class="calibre1">1 John 25</p>
<p class="calibre1">2 Mary 28</p>
<p class="calibre1">3 Jim 19</p>
<p class="calibre1">Note that scan() would not work here, because our file has a mixture of numeric and character data (and a header). </p>
<p class="calibre1">There appears to be no direct way of reading in a matrix from a file, but it can be done easily with other tools. A simple, quick way is to use scan() to read in the matrix row by row. You use the byrow option in the function matrix() to indicate that you are defining the elements of the matrix in a row-wise, rather than column-wise, manner. </p>
<p class="calibre1">For instance, say the file  <i class="calibre4">x </i> contains a 5-by-3 matrix, stored row-wise: 1 0 1</p>
<p class="calibre1">1 1 1</p>
<p class="calibre1">1 1 0</p>
<p class="calibre1">1 1 0</p>
<p class="calibre1">0 0 1</p>
<p class="calibre1">We can read it into a matrix this way:</p>
<p class="calibre1">&gt; x &lt;- matrix(scan("x"),nrow=5,byrow=TRUE)</p>
<p class="calibre1">This is fine for quick, one-time operations, but for generality, you can use read.table(), which returns a data frame, and then convert via as.matrix(). Here is a general method:</p>
<p class="calibre1">read.matrix &lt;- function(filename) {</p>
<p class="calibre1">as.matrix(read.table(filename))</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">236</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p263"/> <i class="calibre4"><b class="calibre3">10.2.2 Reading Text Files</b></i></p>
<p class="calibre1">In computer literature, there is often a distinction made between  <i class="calibre4">text files</i> and  <i class="calibre4">binary files</i>. That distinction is somewhat misleading—every file is binary in the sense that it consists of 0s and 1s. Let’s take the term  <i class="calibre4">text file </i> to mean a file that consists mainly of ASCII characters or coding for some other human language (such as GB for Chinese) and that uses newline characters to give humans the perception of lines. The latter aspect will turn out to be central here. Nontext files, such as JPEG images or executable program files, are generally called  <i class="calibre4">binary files</i>. </p>
<p class="calibre1">You can use readLines() to read in a text file, either one line at a time or in a single operation. For example, suppose we have a file  <i class="calibre4">z1 </i> with the following contents:</p>
<p class="calibre1">John 25</p>
<p class="calibre1">Mary 28</p>
<p class="calibre1">Jim 19</p>
<p class="calibre1">We can read the file all at once, like this:</p>
<p class="calibre1">&gt; z1 &lt;- readLines("z1")</p>
<p class="calibre1">&gt; z1</p>
<p class="calibre1">[1] "John 25" "Mary 28" "Jim 19" </p>
<p class="calibre1">Since each line is treated as a string, the return value here is a vector of strings—that is, a vector of character mode. There is one vector element for each line read, thus three elements here. </p>
<p class="calibre1">Alternatively, we can read it in one line at a time. For this, we first need to create a connection, as described next. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.2.3 Introduction to Connections</b></i></p>
<p class="calibre1"> <i class="calibre4">Connection </i> is R’s term for a fundamental mechanism used in various kinds of I/O operations. Here, it will be used for file access. </p>
<p class="calibre1">The connection is created by calling file(), url(), or one of several other R functions. To see a list of those functions, type this:</p>
<p class="calibre1">&gt; ?connection</p>
<p class="calibre1">So, we can now read in the  <i class="calibre4">z1 </i> file (introduced in the previous section) line by line, as follows:</p>
<p class="calibre1">&gt; c &lt;- file("z1","r")</p>
<p class="calibre1">&gt; readLines(c,n=1)</p>
<p class="calibre1">[1] "John 25" </p>
<p class="calibre1">&gt; readLines(c,n=1)</p>
<p class="calibre1">[1] "Mary 28" </p>
<p class="calibre1">&gt; readLines(c,n=1)</p>
<p class="calibre1">[1] "Jim 19" </p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">237</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p264"/>&gt; readLines(c,n=1)</p>
<p class="calibre1">character(0)</p>
<p class="calibre1">We opened the connection, assigned the result to c, and then read the file one line at a time, as specified by the argument n=1. When R encountered the end of file (EOF), it returned an empty result. We needed to set up a connection so that R could keep track of our position in the file as we read through it. </p>
<p class="calibre1">We can detect EOF in our code:</p>
<p class="calibre1">&gt; c &lt;- file("z","r")</p>
<p class="calibre1">&gt; while(TRUE) {</p>
<p class="calibre1">+</p>
<p class="calibre1">rl &lt;- readLines(c,n=1)</p>
<p class="calibre1">+</p>
<p class="calibre1">if (length(rl) == 0) {</p>
<p class="calibre1">+</p>
<p class="calibre1">print("reached the end")</p>
<p class="calibre1">+</p>
<p class="calibre1">break</p>
<p class="calibre1">+</p>
<p class="calibre1">} else print(rl)</p>
<p class="calibre1">+ }</p>
<p class="calibre1">[1] "John 25" </p>
<p class="calibre1">[1] "Mary 28" </p>
<p class="calibre1">[1] "Jim 19" </p>
<p class="calibre1">[1] "reached the end" </p>
<p class="calibre1">If we wish to “rewind”—to start again at the beginning of the file—we can use seek():</p>
<p class="calibre1">&gt; c &lt;- file("z1","r")</p>
<p class="calibre1">&gt; readLines(c,n=2)</p>
<p class="calibre1">[1] "John 25" "Mary 28" </p>
<p class="calibre1">&gt; seek(con=c,where=0)</p>
<p class="calibre1">[1] 16</p>
<p class="calibre1">&gt; readLines(c,n=1)</p>
<p class="calibre1">[1] "John 25" </p>
<p class="calibre1">The argument where=0 in our call to seek() means that we wish to position the file pointer zero characters from the start of the file—in other words, directly at the beginning. </p>
<p class="calibre1">The call returns 16, meaning that the file pointer was at position 16</p>
<p class="calibre1">before we made the call. That makes sense. The first line consists of "John 25" </p>
<p class="calibre1"> <i class="calibre4">plus </i> the end-of-line character, for a total of eight characters, and the same is true for the second line. So, after reading the first two lines, we were at position 16. </p>
<p class="calibre1">You can close a connection by calling—what else?—close(). You would use this to let the system know that the file you have been writing is complete and should now be officially written to disk. As another example, in a client/server relationship over the Internet (see Section 10.3.1), a client would use close() to indicate to the server that the client is signing off. </p>
<p class="calibre1"><b class="calibre3">238</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p265"/> <i class="calibre4"><b class="calibre3">10.2.4 Extended Example: Reading PUMS Census Files</b></i></p>
<p class="calibre1">The U.S. Census Bureau makes census data available in the form of Public Use Microdata Samples (PUMS). The term  <i class="calibre4">microdata </i> here means that we are dealing with raw data and each record is for a real person, as opposed to statistical summaries. Data on many, many variables are included. </p>
<p class="calibre1">The data is organized by household. For each unit, there is first a Household record, describing the various characteristics of that household, followed by one Person record for each person in the household. Character positions 106 and 107 (with numbering starting at 1) in the Household record state the number of Person records for that household. (The number can be very large, since some institutions count as households.) To enhance the integrity of the data, character position 1 contains H or P to confirm that this is a Household or Person record. So, if you read an H record, and it tells you there are three people in the household, then the following three records should be P records, followed by another H record; if not, you’ve encountered an error. </p>
<p class="calibre1">As our test file, we’ll take the first 1,000 records of the year 2000 1 percent sample. The first few records look like this:</p>
<p class="calibre1">H000019510649</p>
<p class="calibre1">06010</p>
<p class="calibre1">99979997 70</p>
<p class="calibre1">631973</p>
<p class="calibre1">15758</p>
<p class="calibre1">59967658436650000012000000 0 0 0 0 0 0 0 0 0 0 0 0 0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0 0 0</p>
<p class="calibre1">0 0</p>
<p class="calibre1">0 0000 0</p>
<p class="calibre1">0</p>
<p class="calibre1">0 0 0</p>
<p class="calibre1">00000000000000000000000000000</p>
<p class="calibre1">00000000000000000000000000</p>
<p class="calibre1">P00001950100010923000420190010110000010147050600206011099999904200000 0040010000</p>
<p class="calibre1">00300280</p>
<p class="calibre1">28600 70</p>
<p class="calibre1">9997</p>
<p class="calibre1">9997202020202020220000040000000000000006000000</p>
<p class="calibre1">00000 00</p>
<p class="calibre1">0000</p>
<p class="calibre1">00000000000000000132241057904MS</p>
<p class="calibre1">476041-20311010310</p>
<p class="calibre1">07000049010000000000900100000100000100000100000010000001000139010000490000</p>
<p class="calibre1">H000040710649</p>
<p class="calibre1">06010</p>
<p class="calibre1">99979997 70</p>
<p class="calibre1">631973</p>
<p class="calibre1">15758</p>
<p class="calibre1">599676584365300800200000300106060503010101010102010 01200006000000100001</p>
<p class="calibre1">00600020 0</p>
<p class="calibre1">0 0</p>
<p class="calibre1">0 0000 0</p>
<p class="calibre1">0</p>
<p class="calibre1">0 0 0</p>
<p class="calibre1">02000102010102200000000010750</p>
<p class="calibre1">02321125100004000000040000</p>
<p class="calibre1">P00004070100005301000010380010110000010147030400100009005199901200000 0006010000</p>
<p class="calibre1">00100000</p>
<p class="calibre1">00000 00</p>
<p class="calibre1">0000</p>
<p class="calibre1">0000202020202020220000040000000000000001000060</p>
<p class="calibre1">06010 70</p>
<p class="calibre1">9997</p>
<p class="calibre1">99970101004900100000001018703221</p>
<p class="calibre1">770051-10111010500</p>
<p class="calibre1">40004000000000000000000000000000000000000000000000000000004000000040000349</p>
<p class="calibre1">P00004070200005303011010140010110000010147050000204004005199901200000 0006010000</p>
<p class="calibre1">00100000</p>
<p class="calibre1">00000 00</p>
<p class="calibre1">0000</p>
<p class="calibre1">000020202020 0 0200000000000000000000000050000</p>
<p class="calibre1">00000 00</p>
<p class="calibre1">0000</p>
<p class="calibre1">000000000000000000000000000000000000000000-00000000000</p>
<p class="calibre1">000</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">00000000349</p>
<p class="calibre1">H000061010649</p>
<p class="calibre1">06010</p>
<p class="calibre1">99979997 70</p>
<p class="calibre1">631973</p>
<p class="calibre1">15758</p>
<p class="calibre1">599676584360801190100000200204030502010101010102010 00770004800064000001</p>
<p class="calibre1">1</p>
<p class="calibre1">0 030</p>
<p class="calibre1">0 0</p>
<p class="calibre1">0 0340 00660000000170 0</p>
<p class="calibre1">06010000000004410039601000000</p>
<p class="calibre1">00021100000004940000000000</p>
<p class="calibre1">The records are very wide and thus wrap around. Each one occupies</p>
<p class="calibre1">four lines on the page here. </p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">239</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p266"/>We’ll create a function called extractpums() to read in a PUMS file and create a data frame from its Person records. The user specifies the filename and lists fields to extract and names to assign to those fields. </p>
<p class="calibre1">We also want to retain the household serial number. This is good to have because data for persons in the same household may be correlated and we may want to add that aspect to our statistical model. Also, the household data may provide important covariates. (In the latter case, we would want to retain the covariate data as well.)</p>
<p class="calibre1">Before looking at the function code, let’s see what the function does. </p>
<p class="calibre1">In this data set, gender is in column 23 and age in columns 25 and 26. In the example, our filename is  <i class="calibre4">pumsa</i>. The following call creates a data frame consisting of those two variables. </p>
<p class="calibre1">pumsdf &lt;- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) Note that we are stating here the names we want the columns to have in the resulting data frame. We can use any names we want—say Sex and Ancientness. </p>
<p class="calibre1">Here is the first part of that data frame:</p>
<p class="calibre1">&gt; head(pumsdf)</p>
<p class="calibre1">serno Gender Age</p>
<p class="calibre1">2</p>
<p class="calibre1">195</p>
<p class="calibre1">2 19</p>
<p class="calibre1">3</p>
<p class="calibre1">407</p>
<p class="calibre1">1 38</p>
<p class="calibre1">4</p>
<p class="calibre1">407</p>
<p class="calibre1">1 14</p>
<p class="calibre1">5</p>
<p class="calibre1">610</p>
<p class="calibre1">2 65</p>
<p class="calibre1">6 1609</p>
<p class="calibre1">1 50</p>
<p class="calibre1">7 1609</p>
<p class="calibre1">2 49</p>
<p class="calibre1">The following is the code for the extractpums() function. </p>
<p class="calibre1">1</p>
<p class="calibre1"># reads in PUMS file pf, extracting the Person records, returning a data 2</p>
<p class="calibre1"># frame; each row of the output will consist of the Household serial 3</p>
<p class="calibre1"># number and the fields specified in the list flds; the columns of</p>
<p class="calibre1">4</p>
<p class="calibre1"># the data frame will have the names of the indices in flds</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">extractpums &lt;- function(pf,flds) {</p>
<p class="calibre1">7</p>
<p class="calibre1">dtf &lt;- data.frame() # data frame to be built</p>
<p class="calibre1">8</p>
<p class="calibre1">con &lt;- file(pf,"r") # connection</p>
<p class="calibre1">9</p>
<p class="calibre1"># process the input file</p>
<p class="calibre1">10</p>
<p class="calibre1">repeat {</p>
<p class="calibre1">11</p>
<p class="calibre1">hrec &lt;- readLines(con,1) # read Household record</p>
<p class="calibre1">12</p>
<p class="calibre1">if (length(hrec) == 0) break # end of file, leave loop</p>
<p class="calibre1">13</p>
<p class="calibre1"># get household serial number</p>
<p class="calibre1">14</p>
<p class="calibre1">serno &lt;- intextract(hrec,c(2,8))</p>
<p class="calibre1"><b class="calibre3">240</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p267"/>15</p>
<p class="calibre1"># how many Person records? </p>
<p class="calibre1">16</p>
<p class="calibre1">npr &lt;- intextract(hrec,c(106,107))</p>
<p class="calibre1">17</p>
<p class="calibre1">if (npr &gt; 0)</p>
<p class="calibre1">18</p>
<p class="calibre1">for (i in 1:npr) {</p>
<p class="calibre1">19</p>
<p class="calibre1">prec &lt;- readLines(con,1) # get Person record</p>
<p class="calibre1">20</p>
<p class="calibre1"># make this person's row for the data frame</p>
<p class="calibre1">21</p>
<p class="calibre1">person &lt;- makerow(serno,prec,flds)</p>
<p class="calibre1">22</p>
<p class="calibre1"># add it to the data frame</p>
<p class="calibre1">23</p>
<p class="calibre1">dtf &lt;- rbind(dtf,person)</p>
<p class="calibre1">24</p>
<p class="calibre1">}</p>
<p class="calibre1">25</p>
<p class="calibre1">}</p>
<p class="calibre1">26</p>
<p class="calibre1">return(dtf)</p>
<p class="calibre1">27</p>
<p class="calibre1">}</p>
<p class="calibre1">28</p>
<p class="calibre1">29</p>
<p class="calibre1"># set up this person's row for the data frame</p>
<p class="calibre1">30</p>
<p class="calibre1">makerow &lt;- function(srn,pr,fl) {</p>
<p class="calibre1">31</p>
<p class="calibre1">l &lt;- list()</p>
<p class="calibre1">32</p>
<p class="calibre1">l[["serno"]] &lt;- srn</p>
<p class="calibre1">33</p>
<p class="calibre1">for (nm in names(fl)) {</p>
<p class="calibre1">34</p>
<p class="calibre1">l[[nm]] &lt;- intextract(pr,fl[[nm]])</p>
<p class="calibre1">35</p>
<p class="calibre1">}</p>
<p class="calibre1">36</p>
<p class="calibre1">return(l)</p>
<p class="calibre1">37</p>
<p class="calibre1">}</p>
<p class="calibre1">38</p>
<p class="calibre1">39</p>
<p class="calibre1"># extracts an integer field in the string s, in character positions 40</p>
<p class="calibre1"># rng[1] through rng[2]</p>
<p class="calibre1">41</p>
<p class="calibre1">intextract &lt;- function(s,rng) {</p>
<p class="calibre1">42</p>
<p class="calibre1">fld &lt;- substr(s,rng[1],rng[2])</p>
<p class="calibre1">43</p>
<p class="calibre1">return(as.integer(fld))</p>
<p class="calibre1">44</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s see how this works. At the beginning of extractpums(), we create an empty data frame and set up the connection for the PUMS file read. </p>
<p class="calibre1">dtf &lt;- data.frame() # data frame to be built</p>
<p class="calibre1">con &lt;- file(pf,"r") # connection</p>
<p class="calibre1">The main body of the code then consists of a repeat loop. </p>
<p class="calibre1">repeat {</p>
<p class="calibre1">hrec &lt;- readLines(con,1) # read Household record</p>
<p class="calibre1">if (length(hrec) == 0) break # end of file, leave loop</p>
<p class="calibre1"># get household serial number</p>
<p class="calibre1">serno &lt;- intextract(hrec,c(2,8))</p>
<p class="calibre1"># how many Person records? </p>
<p class="calibre1">npr &lt;- intextract(hrec,c(106,107))</p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">241</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p268"/>if (npr &gt; 0)</p>
<p class="calibre1">for (i in 1:npr) {</p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">This loop iterates until the end of the input file is reached. The latter condition will be sensed by encountering a zero-length Household record, as seen in the preceding code. </p>
<p class="calibre1">Within the repeat loop, we alternate reading a Household record and reading the associated Person records. The number of Person records for the current Household record is extracted from columns 106 and 107 of that record, storing this number in npr. That extraction is done by a call to our function intextract(). </p>
<p class="calibre1">The for loop then reads in the Person records one by one, in each case forming the desired row for the output data frame and then attaching it to the latter via rbind():</p>
<p class="calibre1">for (i in 1:npr) {</p>
<p class="calibre1">prec &lt;- readLines(con,1) # get Person record</p>
<p class="calibre1"># make this person's row for the data frame</p>
<p class="calibre1">person &lt;- makerow(serno,prec,flds)</p>
<p class="calibre1"># add it to the data frame</p>
<p class="calibre1">dtf &lt;- rbind(dtf,person)</p>
<p class="calibre1">}</p>
<p class="calibre1">Note how makerow() creates the row to be added for a given person. Here the formal arguments are srn for the household serial number, pr for the given Person record, and fl for the list of variable names and column fields. </p>
<p class="calibre1">makerow &lt;- function(srn,pr,fl) {</p>
<p class="calibre1">l &lt;- list()</p>
<p class="calibre1">l[["serno"]] &lt;- srn</p>
<p class="calibre1">for (nm in names(fl)) {</p>
<p class="calibre1">l[[nm]] &lt;- intextract(pr,fl[[nm]])</p>
<p class="calibre1">}</p>
<p class="calibre1">return(l)</p>
<p class="calibre1">}</p>
<p class="calibre1">For instance, consider our sample call:</p>
<p class="calibre1">pumsdf &lt;- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) When makerow() executes, fl will be a list with two elements, named Gender and Age. The string pr, the current Person record, will have Gender in column 23 and Age in columns 25 and 26. We call intextract() to pull out the desired numbers. </p>
<p class="calibre1"><b class="calibre3">242</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p269"/>The intextract() function itself is a straightforward conversion of characters to numbers, such as converting the string "12" to the number 12. </p>
<p class="calibre1">Note that, if not for the presence of Household records, we could do all of this much more easily with a handy built-in R function: read.fwf(). The name of this function is an abbreviation for “read fixed-width formatted,” </p>
<p class="calibre1">alluding to the fact that each variable is stored in given character positions of a record. In essence, this function alleviates the need to write a function like intextract(). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.2.5 Accessing Files on Remote Machines via URLs</b></i></p>
<p class="calibre1">Certain I/O functions, such as read.table() and scan(), accept web URLs as arguments. (Check R’s online help facility to see if your favorite function allows this.)</p>
<p class="calibre1">As an example, we’ll read some data from the University of Califor-</p>
<p class="calibre1">nia, Irvine archive at  <i class="calibre4">http://archive.ics.uci.edu/ml/datasets.html</i>, using the Echocardiogram data set. After navigating the links, we find the location of that file and then read it from R, as follows:</p>
<p class="calibre1">&gt; uci &lt;- "http://archive.ics.uci.edu/ml/machine-learning-databases/" </p>
<p class="calibre1">&gt; uci &lt;- paste(uci,"echocardiogram/echocardiogram.data",sep="")</p>
<p class="calibre1">&gt; ecc &lt;- read.csv(uci)</p>
<p class="calibre1">(We’ve built up the URL in stages here to fit the page.)</p>
<p class="calibre1">Let’s take a look at what we downloaded:</p>
<p class="calibre1">&gt; head(ecc)</p>
<p class="calibre1">X11 X0 X71 X0.1 X0.260</p>
<p class="calibre1">X9 X4.600 X14</p>
<p class="calibre1">X1 X1.1 name X1.2 X0.2</p>
<p class="calibre1">1 19 0 72</p>
<p class="calibre1">0 0.380</p>
<p class="calibre1">6 4.100</p>
<p class="calibre1">14 1.700 0.588 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">2 16 0 55</p>
<p class="calibre1">0 0.260</p>
<p class="calibre1">4 3.420</p>
<p class="calibre1">14</p>
<p class="calibre1">1</p>
<p class="calibre1">1 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">3 57 0 60</p>
<p class="calibre1">0 0.253 12.062 4.603</p>
<p class="calibre1">16 1.450 0.788 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">4 19 1 57</p>
<p class="calibre1">0 0.160</p>
<p class="calibre1">22 5.750</p>
<p class="calibre1">18 2.250 0.571 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">5 26 0 68</p>
<p class="calibre1">0 0.260</p>
<p class="calibre1">5 4.310</p>
<p class="calibre1">12</p>
<p class="calibre1">1 0.857 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">6 13 0 62</p>
<p class="calibre1">0 0.230</p>
<p class="calibre1">31 5.430 22.5 1.875 0.857 name</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">We could then do our analyses. For example, the third column is age, so we could find its mean or perform other calculations on that data. See the echocardiogram.names page at  <i class="calibre4">http://archive.ics.uci.edu/ml/machine-learning-databases/echocardiogram/echocardiogram.names </i> for descriptions of all of the variables. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.2.6 Writing to a File</b></i></p>
<p class="calibre1">Given the statistical basis of R, file reads are probably much more common than writes. But writes are sometimes necessary, and this section will present methods for writing to files. </p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">243</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p270"/>The function write.table() works very much like read.table(), except that it writes a data frame instead of reading one. For instance, let’s take the little Jack and Jill example from the beginning of Chapter 5:</p>
<p class="calibre1">&gt; kids &lt;- c("Jack","Jill")</p>
<p class="calibre1">&gt; ages &lt;- c(12,10)</p>
<p class="calibre1">&gt; d &lt;- data.frame(kids,ages,stringsAsFactors=FALSE)</p>
<p class="calibre1">&gt; d</p>
<p class="calibre1">kids ages</p>
<p class="calibre1">1 Jack</p>
<p class="calibre1">12</p>
<p class="calibre1">2 Jill</p>
<p class="calibre1">10</p>
<p class="calibre1">&gt; write.table(d,"kds")</p>
<p class="calibre1">The file  <i class="calibre4">kds </i> will now have these contents:</p>
<p class="calibre1">"kids" "ages" </p>
<p class="calibre1">"1" "Jack" 12</p>
<p class="calibre1">"2" "Jill" 10</p>
<p class="calibre1">In the case of writing a matrix to a file, just state that you do not want row or column names, as follows:</p>
<p class="calibre1">&gt; write.table(xc,"xcnew",row.names=FALSE,col.names=FALSE) The function cat() can also be used to write to a file, one part at a time. </p>
<p class="calibre1">Here’s an example:</p>
<p class="calibre1">&gt; cat("abc\n",file="u")</p>
<p class="calibre1">&gt; cat("de\n",file="u",append=TRUE)</p>
<p class="calibre1">The first call to cat() creates the file  <i class="calibre4">u</i>, consisting of one line with contents "abc". The second call appends a second line. Unlike the case of using the writeLines() function (which we’ll discuss next), the file is automatically saved after each operation. For instance, after the previous calls, the file will look like this:</p>
<p class="calibre1">abc</p>
<p class="calibre1">de</p>
<p class="calibre1">You can write multiple fields as well. So:</p>
<p class="calibre1">&gt; cat(file="v",1,2,"xyz\n")</p>
<p class="calibre1">would produce a file  <i class="calibre4">v </i> consisting of a single line:</p>
<p class="calibre1">1 2 xyz</p>
<p class="calibre1"><b class="calibre3">244</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p271"/>You can also use writeLines(), the counterpart of readLines(). If you use a connection, you must specify "w" to indicate you are writing to the file, not reading from it:</p>
<p class="calibre1">&gt; c &lt;- file("www","w")</p>
<p class="calibre1">&gt; writeLines(c("abc","de","f"),c)</p>
<p class="calibre1">&gt; close(c)</p>
<p class="calibre1">The file  <i class="calibre4">www </i> will be created with these contents:</p>
<p class="calibre1">abc</p>
<p class="calibre1">de</p>
<p class="calibre1">f</p>
<p class="calibre1">Note the need to proactively close the file. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.2.7 Getting File and Directory Information</b></i></p>
<p class="calibre1">R has a variety of functions for getting information about directories and files, setting file access permissions, and the like. The following are a few examples:</p>
<p class="calibre1">•</p>
<p class="calibre1">file.info(): Gives file size, creation time, directory-versus-ordinary file status, and so on for each file whose name is in the argument, a character vector. </p>
<p class="calibre1">•</p>
<p class="calibre1">dir(): Returns a character vector listing the names of all the files in the directory specified in its first argument. If the optional argument recursive=TRUE is specified, the result will show the entire directory tree rooted at the first argument. </p>
<p class="calibre1">•</p>
<p class="calibre1">file.exists(): Returns a Boolean vector indicating whether the given file exists for each name in the first argument, a character vector. </p>
<p class="calibre1">•</p>
<p class="calibre1">getwd() and setwd(): Used to determine or change the current working directory. </p>
<p class="calibre1">To see all the file- and directory-related functions, type the following:</p>
<p class="calibre1">&gt; ?files</p>
<p class="calibre1">Some of these options will be demonstrated in the next example. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.2.8 Extended Example: Sum the Contents of Many Files</b></i></p>
<p class="calibre1">Here, we’ll develop a function to find the sum of the contents (assumed numeric) in all files in a directory tree. In our example, a directory  <i class="calibre4">dir1</i></p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">245</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p272"/>contains the files  <i class="calibre4">filea </i> and  <i class="calibre4">fileb</i>, as well as a subdirectory  <i class="calibre4">dir2</i>, which holds the file  <i class="calibre4">filec</i>. The contents of the files are as follows:</p>
<p class="calibre1">•</p>
<p class="calibre1"> <i class="calibre4">filea</i>: 5, 12, 13</p>
<p class="calibre1">•</p>
<p class="calibre1"> <i class="calibre4">fileb</i>: 3, 4, 5</p>
<p class="calibre1">•</p>
<p class="calibre1"> <i class="calibre4">filec</i>: 24, 25, 7</p>
<p class="calibre1">If  <i class="calibre4">dir1 </i> is in our current directory, the call sumtree("dir1") will yield the sum of those nine numbers, 98. Otherwise, we need to specify the full pathname of  <i class="calibre4">dir1</i>, such as sumtree("/home/nm/dir1"). Here is the code: 1</p>
<p class="calibre1">sumtree &lt;- function(drtr) {</p>
<p class="calibre1">2</p>
<p class="calibre1">tot &lt;- 0</p>
<p class="calibre1">3</p>
<p class="calibre1"># get names of all files in the tree</p>
<p class="calibre1">4</p>
<p class="calibre1">fls &lt;- dir(drtr,recursive=TRUE)</p>
<p class="calibre1">5</p>
<p class="calibre1">for (f in fls) {</p>
<p class="calibre1">6</p>
<p class="calibre1"># is f a directory? </p>
<p class="calibre1">7</p>
<p class="calibre1">f &lt;- file.path(drtr,f)</p>
<p class="calibre1">8</p>
<p class="calibre1">if (!file.info(f)$isdir) {</p>
<p class="calibre1">9</p>
<p class="calibre1">tot &lt;- tot + sum(scan(f,quiet=TRUE))</p>
<p class="calibre1">10</p>
<p class="calibre1">}</p>
<p class="calibre1">11</p>
<p class="calibre1">}</p>
<p class="calibre1">12</p>
<p class="calibre1">return(tot)</p>
<p class="calibre1">13</p>
<p class="calibre1">}</p>
<p class="calibre1">Note that this problem is a natural for recursion, which we discussed in Section 7.9. But here, R has done the recursion for us by allowing it as an option in dir(). Thus, in line 4, we set recursive=TRUE in order to find the files throughout the various levels of the directory tree. </p>
<p class="calibre1">To call file.info(), we need to account for the fact that the current filename  <i class="calibre4">f </i> is relative to drtr, so our file  <i class="calibre4">filea </i> would be referred to as  <i class="calibre4">dir1/filea</i>. </p>
<p class="calibre1">In order to form that pathname, we need to concatenate drtr, a slash, and filea. We could use the R string concatenation function paste() for this, but we would need a separate case for Windows, which uses a backslash instead of a slash. But file.path() does all that for us. </p>
<p class="calibre1">Some commentary pertaining to line 8 is in order. The function</p>
<p class="calibre1">file.info() returns information about f as a data frame, one of whose columns is isdir, with one row for each file and with row names being the filenames. That column consists of Boolean values indicating whether each file is a directory. In line 8, then, we can detect whether the current file  <i class="calibre4">f </i> is a directory. If  <i class="calibre4">f </i> is an ordinary file, we go ahead and add its contents to our running total. </p>
<p class="calibre1"><b class="calibre3">10.3 Accessing the Internet</b></p>
<p class="calibre1">R’s socket facilities give the programmer access to the Internet’s TCP/IP</p>
<p class="calibre1">protocol. For readers who are not familiar with this protocol, we begin with an overview of TCP/IP. </p>
<p class="calibre1"><b class="calibre3">246</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p273"/> <i class="calibre4"><b class="calibre3">10.3.1 Overview of TCP/IP</b></i></p>
<p class="calibre1">TCP/IP is quite complex, so the overview here will be something of an over-simplification, but we’ll cover enough for you to understand what R’s socket functions are doing. </p>
<p class="calibre1">For our purposes here, the term  <i class="calibre4">network </i> refers to a set of computers connected together locally, without going through the Internet. This typically consists of all the computers in a home, all the computers in a smaller business, and so on. The physical medium between them is usually an Ethernet connection of some form. </p>
<p class="calibre1">The Internet, as its name implies, connects networks. A network in the Internet is connected to one or more other networks via  <i class="calibre4">routers</i>, which are special-purpose computers that connect two or more networks together. </p>
<p class="calibre1">Every computer on the Internet has an Internet Protocol (IP) address. This is numeric, but it can be stated in characters, as in  <i class="calibre4">www.google.com</i>, which is then translated into the numeric address by the Domain Name Service. </p>
<p class="calibre1">However, the IP address is not enough. When A sends a message to</p>
<p class="calibre1">B, there may be several applications at computer B that are receiving Internet messages, such as web browsing, email service, and so on. How does the operating system at B know to which of these to send the message from A? The answer is that A will specify a  <i class="calibre4">port number </i> in addition to the IP address. </p>
<p class="calibre1">The port number indicates which program running at B is intended as the recipient. And A will also have a port number so that the response from B</p>
<p class="calibre1">reaches the correct application at A. </p>
<p class="calibre1">When A wishes to send something to B, it writes to a software entity called a  <i class="calibre4">socket</i>, using a system call syntactically similar to the one for writing to a file. In the call, A specifies B’s IP address and the port number to which A wishes to send a message. B has a socket, too, and it writes its responses to A in that socket. We say there is a  <i class="calibre4">connection </i> between A and B via those sockets, but that doesn’t mean anything physical—it’s just an agreement between A and B to exchange data. </p>
<p class="calibre1">Applications follow a  <i class="calibre4">client/server </i> model. Say a web server is running at B, at the standard port for the Web, port 80. The server at B is  <i class="calibre4">listening </i> at port 80. Again, this term should not be taken literally; it just means that the server program has made a function call that notifies the operating system that the server program is willing to have connections at port 80. When network node A requests such a connection, the function call at the server returns, and the connection is set up. </p>
<p class="calibre1">If you are a nonprivileged user and write some kind of server program—</p>
<p class="calibre1">say in R!—you must assign a port number above 1024. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">If a server program is taken down or crashes, there may be a few seconds’ delay before</i> <i class="calibre4">the same port is reusable again. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.3.2 Sockets in R</b></i></p>
<p class="calibre1">A very important point to keep in mind is that all the bytes sent by A to B</p>
<p class="calibre1">during the time the connection between them exists are collectively considered  <i class="calibre4">one big message</i>. Say A sends one line of text of 8 characters and then Input/Output</p>
<p class="calibre1"><b class="calibre3">247</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p274"/>another of 20 characters. From A’s point of view, that’s two lines, but to TCP/IP, it’s just 28 characters of a yet incomplete message. Splitting that long message back into lines can take a bit of doing. R provides various functions for this purpose, including the following:</p>
<p class="calibre1">•</p>
<p class="calibre1">readLines() and writeLines(): These allow you to program as if TCP/IP</p>
<p class="calibre1">were sending messages line by line, even though this is not actually the case. If your application is naturally viewed in terms of lines, these two functions can be quite handy. </p>
<p class="calibre1">•</p>
<p class="calibre1">serialize() and unserialize(): You can use these to send R objects, such as a matrix or the complex output of a call to a statistical function. The object is converted to character string form by the sender and then converted back to the original object form at the receiver. </p>
<p class="calibre1">•</p>
<p class="calibre1">readBin() and writeBin(): These are for sending data in binary form. </p>
<p class="calibre1">(Recall the comment on terminology at the beginning of Section 10.2.2.) Each of these functions operates on R connections, as you’ll see in the next example. </p>
<p class="calibre1">It’s important to choose the right function for each job. If you have a long vector, for example, using serialize() and unserialize() may be more convenient but far more time-consuming. This is not only because numbers must be converted to and from their character representations but also because the character representation is typically much longer, which means greater transmission time. </p>
<p class="calibre1">Here are two other R socket functions:</p>
<p class="calibre1">•</p>
<p class="calibre1">socketConnection(): This establishes an R connection via sockets. You specify the port number in the argument port, and state whether a</p>
<p class="calibre1">server or client is to be created, by setting the argument server to TRUE</p>
<p class="calibre1">or FALSE, respectively. In the client case, you must also supply the server’s IP address in the argument host. </p>
<p class="calibre1">•</p>
<p class="calibre1">socketSelect(): This is useful when a server is connected to multiple clients. Its main argument, socklist, is a list of connections, and its return value is the sublist of connections that have data ready for the server to read. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.3.3 Extended Example: Implementing Parallel R</b></i></p>
<p class="calibre1">Some statistical analyses have very long runtimes, so there naturally has been quite a bit of interest in “parallel R,” in which several R processes cooperate on a given task. Another possible reason to “go parallel” is memory limita-tions. If one machine does not have enough memory for the task at hand, it may help to pool the memories of several machines in some way. Chapter 16</p>
<p class="calibre1">gives an introduction to this important topic. </p>
<p class="calibre1">Sockets play a key role in many parallel R packages. The cooperating R</p>
<p class="calibre1">processes could be either on the same machine or on separate machines. In the latter case (and even the former), a natural approach to implementing parallelism is to use R sockets. This is one of the choices in the snow package <b class="calibre3">248</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p275"/>and in my Rdsm package (both available on CRAN, R’s code repository; see this book’s appendix for details), as follows:</p>
<p class="calibre1">•</p>
<p class="calibre1">In snow, the server sends out work tasks to the clients. The clients perform their tasks and send the results back to the server, which assembles them into the final result. Communication is done with serialize() and unserialize(), and the server uses socketSelect() to determine which client results are ready. </p>
<p class="calibre1">•</p>
<p class="calibre1">Rdsm implements a virtual shared-memory paradigm, and the server is used to store the shared variables. The clients contact the server whenever they need to read or write a shared variable. To optimize speed, communication between server and clients is done with readBin() and writebin(), instead of serialize() and unserialize(). </p>
<p class="calibre1">Let’s look at some of the socket-related details of Rdsm. First, here is the server code in which connections with the clients are set up, storing them in a list cons (there are ncon clients):</p>
<p class="calibre1">1</p>
<p class="calibre1"># set up socket connections with clients</p>
<p class="calibre1">2</p>
<p class="calibre1">#</p>
<p class="calibre1">3</p>
<p class="calibre1">cons &lt;&lt;- vector(mode="list",length=ncon) # list of connections 4</p>
<p class="calibre1"># prevent connection from dying during debug or long compute spell</p>
<p class="calibre1">5</p>
<p class="calibre1">options("timeout"=10000)</p>
<p class="calibre1">6</p>
<p class="calibre1">for (i in 1:ncon) {</p>
<p class="calibre1">7</p>
<p class="calibre1">cons[[i]] &lt;&lt;-</p>
<p class="calibre1">8</p>
<p class="calibre1">socketConnection(port=port,server=TRUE,blocking=TRUE,open="a+b") 9</p>
<p class="calibre1"># wait to hear from client i</p>
<p class="calibre1">10</p>
<p class="calibre1">checkin &lt;- unserialize(cons[[i]])</p>
<p class="calibre1">11</p>
<p class="calibre1">}</p>
<p class="calibre1">12</p>
<p class="calibre1"># send ACKs</p>
<p class="calibre1">13</p>
<p class="calibre1">for (i in 1:ncon) {</p>
<p class="calibre1">14</p>
<p class="calibre1"># send the client its ID number, and the group size</p>
<p class="calibre1">15</p>
<p class="calibre1">serialize(c(i,ncon),cons[[i]])</p>
<p class="calibre1">16</p>
<p class="calibre1">}</p>
<p class="calibre1">Since the client messages and server acknowledgments are short mes-</p>
<p class="calibre1">sages, serialize() and unserialize() are good enough for the purpose here. </p>
<p class="calibre1">The first part of the main loop of the server finds a ready client and reads from it. </p>
<p class="calibre1">1</p>
<p class="calibre1">repeat {</p>
<p class="calibre1">2</p>
<p class="calibre1"># any clients still there? </p>
<p class="calibre1">3</p>
<p class="calibre1">if (remainingclients == 0) break</p>
<p class="calibre1">4</p>
<p class="calibre1"># wait for service request, then read it</p>
<p class="calibre1">5</p>
<p class="calibre1"># find all the pending client requests</p>
<p class="calibre1">6</p>
<p class="calibre1">rdy &lt;- which(socketSelect(cons))</p>
<p class="calibre1">7</p>
<p class="calibre1"># choose one</p>
<p class="calibre1">8</p>
<p class="calibre1">j &lt;- sample(1:length(rdy),1)</p>
<p class="calibre1">Input/Output</p>
<p class="calibre1"><b class="calibre3">249</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p276"/>9</p>
<p class="calibre1">con &lt;- cons[[rdy[j]]]</p>
<p class="calibre1">10</p>
<p class="calibre1"># read client request</p>
<p class="calibre1">11</p>
<p class="calibre1">req &lt;- unserialize(con)</p>
<p class="calibre1">Again serialize() and unserialize() are good enough here to read the short message from the client indicating what kind of operation—typically reading a shared variable or writing one—it’s requesting. But the reads and writes of the shared variables themselves use the faster readBin() and writeBin() functions. Here’s the write part:</p>
<p class="calibre1"># write data dt, of mode md (integer of double), to connection cn</p>
<p class="calibre1">binwrite &lt;- function(dt,md,cn) {</p>
<p class="calibre1">writeBin(dt,con=cn)</p>
<p class="calibre1">And here’s the read part:</p>
<p class="calibre1"># read sz elements of mode md (integer of double) from connection cn binread &lt;- function(cn,md,sz) {</p>
<p class="calibre1">return(readBin(con=cn,what=md,n=sz))</p>
<p class="calibre1">On the client side, the connection setup code is as follows:</p>
<p class="calibre1">1</p>
<p class="calibre1">options("timeout"=10000)</p>
<p class="calibre1">2</p>
<p class="calibre1"># connect to server</p>
<p class="calibre1">3</p>
<p class="calibre1">con &lt;- socketConnection(host=host,port=port,blocking=TRUE,open="a+b") 4</p>
<p class="calibre1">serialize(list(req="checking in"),con)</p>
<p class="calibre1">5</p>
<p class="calibre1"># receive this client's ID and total number of clients from server</p>
<p class="calibre1">6</p>
<p class="calibre1">myidandnclnt &lt;- unserialize(con)</p>
<p class="calibre1">7</p>
<p class="calibre1">myinfo &lt;&lt;-</p>
<p class="calibre1">8</p>
<p class="calibre1">list(con=con,myid=myidandnclnt[1],nclnt=myidandnclnt[2])</p>
<p class="calibre1">The code for reading from and writing to the server is similar to the preceding server examples. </p>
<p class="calibre1"><b class="calibre3">250</b></p>
<p class="calibre1">Chapter 10</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p277"/><img src="index-277_1.png" alt="Image 23" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">11</b></p>
<p class="calibre1"><b class="calibre3">STRING MANIPULATION</b></p>
<p class="calibre1">Although R is a statistical language with</p>
<p class="calibre1">numeric vectors and matrices playing a</p>
<p class="calibre1">central role, character strings are surpris-</p>
<p class="calibre1">ingly important as well. Ranging from birth</p>
<p class="calibre1">dates stored in medical research data files to text-</p>
<p class="calibre1">mining applications, character data arises quite fre-</p>
<p class="calibre1">quently in R programs. Accordingly, R has a number</p>
<p class="calibre1">of string-manipulation utilities, many of which will be</p>
<p class="calibre1">introduced in this chapter. </p>
<p class="calibre1"><b class="calibre3">11.1 An Overview of String-Manipulation Functions</b></p>
<p class="calibre1">Here, we’ll briefly review just some of the many string-manipulation functions R has to offer. Note that the call forms shown in this introduction are very simple, usually omitting many optional arguments. We’ll use some of those arguments in our extended examples later in the chapter, but do check R’s online help for further details. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p278"/> <i class="calibre4"><b class="calibre3">11.1.1 grep()</b></i></p>
<p class="calibre1">The call grep(pattern,x) searches for a specified substring pattern in a vector x of strings. If x has  <i class="calibre4">n </i> elements—that is, it contains  <i class="calibre4">n </i> strings—then grep(pattern,x) will return a vector of length up to  <i class="calibre4">n</i>. Each element of this vector will be the index in x at which a match of pattern as a substring of x[i]) was found. </p>
<p class="calibre1">Here’s an example of using grep:</p>
<p class="calibre1">&gt; grep("Pole",c("Equator","North Pole","South Pole"))</p>
<p class="calibre1">[1] 2 3</p>
<p class="calibre1">&gt; grep("pole",c("Equator","North Pole","South Pole")) integer(0)</p>
<p class="calibre1">In the first case, the string "Pole" was found in elements 2 and 3 of the second argument, hence the output (2,3). In the second case, string "pole" </p>
<p class="calibre1">was not found anywhere, so an empty vector was returned. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.2 nchar()</b></i></p>
<p class="calibre1">The call nchar(x) finds the length of a string x. Here’s an example:</p>
<p class="calibre1">&gt; nchar("South Pole")</p>
<p class="calibre1">[1] 10</p>
<p class="calibre1">The string "South Pole" was found to have 10 characters. C programmers, take note: There is no NULL character terminating R strings. </p>
<p class="calibre1">Also note that the results of nchar() will be unpredictable if x is not in character mode. For instance, nchar(NA) turns out to be 2, and nchar(factor("abc")) is 1. For more consistent results on nonstring objects, use Hadley Wickham’s stringr package on CRAN. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.3 paste()</b></i></p>
<p class="calibre1">The call paste(...) concatenates several strings, returning the result in one long string. Here are some examples:</p>
<p class="calibre1">&gt; paste("North","Pole")</p>
<p class="calibre1">[1] "North Pole" </p>
<p class="calibre1">&gt; paste("North","Pole",sep="")</p>
<p class="calibre1">[1] "NorthPole" </p>
<p class="calibre1">&gt; paste("North","Pole",sep=".")</p>
<p class="calibre1">[1] "North.Pole" </p>
<p class="calibre1">&gt; paste("North","and","South","Poles")</p>
<p class="calibre1">[1] "North and South Poles" </p>
<p class="calibre1"><b class="calibre3">252</b></p>
<p class="calibre1">Chapter 11</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p279"/>As you can see, the optional argument sep can be used to put something other than a space between the pieces being spliced together. If you specify sep as an empty string, the pieces won’t have any character between them. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.4 sprintf()</b></i></p>
<p class="calibre1">The call sprintf(...) assembles a string from parts in a formatted manner. </p>
<p class="calibre1">Here’s a simple example:</p>
<p class="calibre1">&gt; i &lt;- 8</p>
<p class="calibre1">&gt; s &lt;- sprintf("the square of %d is %d",i,i^2)</p>
<p class="calibre1">&gt; s</p>
<p class="calibre1">[1] "the square of 8 is 64" </p>
<p class="calibre1">The name of the function is intended to evoke  <i class="calibre4">string print </i> for “printing” </p>
<p class="calibre1">to a string rather than to the screen. Here, we are printing to the string s. </p>
<p class="calibre1">What are we printing? The function says to first print “the square of” </p>
<p class="calibre1">and then print the decimal value of i. (The term  <i class="calibre4">decimal </i> here means in the base-10 number system, not that there will be a decimal point in the result.) The result is the string "the square of 8 is 64." </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.5 substr()</b></i></p>
<p class="calibre1">The call substr(x,start,stop) returns the substring in the given character position range start:stop in the given string x. Here’s an example:</p>
<p class="calibre1">&gt; substring("Equator",3,5)</p>
<p class="calibre1">[1] "uat" </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.6 strsplit()</b></i></p>
<p class="calibre1">The call strsplit(x,split) splits a string x into an R list of substrings based on another string split in x. Here’s an example:</p>
<p class="calibre1">&gt; strsplit("6-16-2011",split="-")</p>
<p class="calibre1">[[1]]</p>
<p class="calibre1">[1] "6" </p>
<p class="calibre1">"16" </p>
<p class="calibre1">"2011" </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.7 regexpr()</b></i></p>
<p class="calibre1">The call regexpr(pattern,text) finds the character position of the first instance of pattern within text, as in this example:</p>
<p class="calibre1">&gt; regexpr("uat","Equator")</p>
<p class="calibre1">[1] 3</p>
<p class="calibre1">String Manipulation</p>
<p class="calibre1"><b class="calibre3">253</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p280"/>This reports that “uat” did indeed appear in “Equator,” starting at character position 3. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.1.8 gregexpr()</b></i></p>
<p class="calibre1">The call gregexpr(pattern,text) is the same as regexpr(), but it finds all instances of pattern. Here’s an example:</p>
<p class="calibre1">&gt; gregexpr("iss","Mississippi")</p>
<p class="calibre1">[[1]]</p>
<p class="calibre1">[1] 2 5</p>
<p class="calibre1">This finds that “iss” appears twice in “Mississippi,” starting at character positions 2 and 5. </p>
<p class="calibre1"><b class="calibre3">11.2 Regular Expressions</b></p>
<p class="calibre1">When dealing with string-manipulation functions in programming languages, the notion of  <i class="calibre4">regular expressions </i> sometimes arises. In R, you must pay attention to this point when using the string functions grep(), grepl(), regexpr(), gregexpr(), sub(), gsub(), and strsplit(). </p>
<p class="calibre1">A regular expression is a kind of wild card. It’s shorthand to specify broad classes of strings. For example, the expression "[au]" refers to any string that contains either of the letters  <i class="calibre4">a </i> or  <i class="calibre4">u</i>. You could use it like this:</p>
<p class="calibre1">&gt; grep("[au]",c("Equator","North Pole","South Pole"))</p>
<p class="calibre1">[1] 1 3</p>
<p class="calibre1">This reports that elements 1 and 3 of ("Equator","North Pole","South Pole")—that is, “Equator” and “South Pole”—contain either an  <i class="calibre4">a </i> or a  <i class="calibre4">u</i>. </p>
<p class="calibre1">A period (.) represents any single character. Here’s an example of</p>
<p class="calibre1">using it:</p>
<p class="calibre1">&gt; grep("o.e",c("Equator","North Pole","South Pole"))</p>
<p class="calibre1">[1] 2 3</p>
<p class="calibre1">This searches for three-character strings in which an  <i class="calibre4">o </i> is followed by any single character, which is in turn followed by an  <i class="calibre4">e</i>. Here is an example of the use of two periods to represent any pair of characters:</p>
<p class="calibre1">&gt; grep("N..t",c("Equator","North Pole","South Pole"))</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Here, we searched for four-letter strings consisting of an  <i class="calibre4">N</i>, followed by any pair of characters, followed by a  <i class="calibre4">t</i>. </p>
<p class="calibre1">A period is an example of a  <i class="calibre4">metacharacter</i>, which is a character that is not to be taken literally. For example, if a period appears in the first argument of grep(), it doesn’t actually mean a period; it means any character. </p>
<p class="calibre1"><b class="calibre3">254</b></p>
<p class="calibre1">Chapter 11</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p281"/>But what if you want to search for a period using grep()? Here’s the naive approach:</p>
<p class="calibre1">&gt; grep(".",c("abc","de","f.g"))</p>
<p class="calibre1">[1] 1 2 3</p>
<p class="calibre1">The result should have been 3, not (1,2,3). This call failed because periods are metacharacters. You need to  <i class="calibre4">escape </i> the metacharacter nature of the period, which is done via a backslash:</p>
<p class="calibre1">&gt; grep("\\.",c("abc","de","f.g"))</p>
<p class="calibre1">[1] 3</p>
<p class="calibre1">Now, didn’t I say  <i class="calibre4">a </i> backslash? Then why are there two? Well, the sad truth is that the backslash itself must be escaped, which is accomplished by its own backslash! This goes to show how arcanely complex regular expressions can become. Indeed, a number of books have been written on the subject of regular expressions (for various programming languages). As a start in learning about the topic, refer to R’s online help (type ?regex). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.2.1 Extended Example: Testing a Filename for a Given Suffix</b></i></p>
<p class="calibre1">Suppose we wish to test for a specified suffix in a filename. We might, for instance, want to find all HTML files (those with suffix  <i class="calibre4">.html</i>,  <i class="calibre4">.htm</i>, and so on). Here is code for that:</p>
<p class="calibre1">1</p>
<p class="calibre1">testsuffix &lt;- function(fn,suff) {</p>
<p class="calibre1">2</p>
<p class="calibre1">parts &lt;- strsplit(fn,".",fixed=TRUE)</p>
<p class="calibre1">3</p>
<p class="calibre1">nparts &lt;- length(parts[[1]])</p>
<p class="calibre1">4</p>
<p class="calibre1">return(parts[[1]][nparts] == suff)</p>
<p class="calibre1">5</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s test it. </p>
<p class="calibre1">&gt; testsuffix("x.abc","abc")</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">&gt; testsuffix("x.abc","ac")</p>
<p class="calibre1">[1] FALSE</p>
<p class="calibre1">&gt; testsuffix("x.y.abc","ac")</p>
<p class="calibre1">[1] FALSE</p>
<p class="calibre1">&gt; testsuffix("x.y.abc","abc")</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">How does the function work? First note that the call to strsplit() on line 2 returns a list consisting of one element (because fn is a one-element vector)—a vector of strings. For example, calling testsuffix("x.y.abc","abc") will result in parts being a list consisting of a three-element vector with elements x, y, and abc. We then pick up the last element and compare it to suff. </p>
<p class="calibre1">String Manipulation</p>
<p class="calibre1"><b class="calibre3">255</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p282"/>A key aspect is the argument fixed=TRUE. Without it, the splitting argument . (called split in the list of strsplit()’s formal arguments) would have been treated as a regular expression. Without setting fixed=TRUE, strsplit() would have just separated all the letters. </p>
<p class="calibre1">Of course, we could also escape the period, as follows:</p>
<p class="calibre1">1</p>
<p class="calibre1">testsuffix &lt;- function(fn,suff) {</p>
<p class="calibre1">2</p>
<p class="calibre1">parts &lt;- strsplit(fn,"\\.")</p>
<p class="calibre1">3</p>
<p class="calibre1">nparts &lt;- length(parts[[1]])</p>
<p class="calibre1">4</p>
<p class="calibre1">return(parts[[1]][nparts] == suff)</p>
<p class="calibre1">5</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s check to see if it still works. </p>
<p class="calibre1">&gt; testsuffix("x.y.abc","abc")</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">Here’s another way to do the suffix-test code that’s a bit more involved but a good illustration:</p>
<p class="calibre1">1</p>
<p class="calibre1">testsuffix &lt;- function(fn,suff) {</p>
<p class="calibre1">2</p>
<p class="calibre1">ncf &lt;- nchar(fn) # nchar() gives the string length</p>
<p class="calibre1">3</p>
<p class="calibre1"># determine where the period would start if suff is the suffix in fn 4</p>
<p class="calibre1">dotpos &lt;- ncf - nchar(suff) + 1</p>
<p class="calibre1">5</p>
<p class="calibre1"># now check that suff is there</p>
<p class="calibre1">6</p>
<p class="calibre1">return(substr(fn,dotpos,ncf)==suff)</p>
<p class="calibre1">7</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s look at the call to substr() here, again with fn = "x.ac" and suff = "abc". In this case, dotpos will be 1, which means there should be a period at the first character in fn if there is an abc suffix. The call to substr() then becomes substr("x.ac",1,4), which extracts the substring in character positions 1 through 4 of x.ac. That substring will be x.ac, which is not abc, so the filename’s suffix is found not to be the latter. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">11.2.2 Extended Example: Forming Filenames</b></i></p>
<p class="calibre1">Suppose we want to create five files,  <i class="calibre4">q1.pdf </i> through  <i class="calibre4">q5.pdf</i>, consisting of histograms of 100 random N(0,  <i class="calibre4">i</i> 2) variates. We could execute the following code:</p>
<p class="calibre1">1</p>
<p class="calibre1">for (i in 1:5) {</p>
<p class="calibre1">2</p>
<p class="calibre1">fname &lt;- paste("q",i,".pdf")</p>
<p class="calibre1">3</p>
<p class="calibre1">pdf(fname)</p>
<p class="calibre1">4</p>
<p class="calibre1">hist(rnorm(100,sd=i))</p>
<p class="calibre1">5</p>
<p class="calibre1">dev.off()</p>
<p class="calibre1">6</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">256</b></p>
<p class="calibre1">Chapter 11</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p283"/>The main point in this example is the string manipulation we use to create the filename fname. For more details about the graphics operations used in this example, refer to Section 12.3. </p>
<p class="calibre1">The paste() function concatenates the string "q" with the string form of the number i. For example, when i = 2, the variable fname will be q 2 .pdf. </p>
<p class="calibre1">However, that isn’t quite what we want. On Linux systems, filenames with embedded spaces create headaches, so we want to remove the spaces. One solution is to use the sep argument, specifying an empty string for the separator, as follows:</p>
<p class="calibre1">1</p>
<p class="calibre1">for (i in 1:5) {</p>
<p class="calibre1">2</p>
<p class="calibre1">fname &lt;- paste("q",i,".pdf",sep="") 3</p>
<p class="calibre1">pdf(fname)</p>
<p class="calibre1">4</p>
<p class="calibre1">hist(rnorm(100,sd=i))</p>
<p class="calibre1">5</p>
<p class="calibre1">dev.off()</p>
<p class="calibre1">6</p>
<p class="calibre1">}</p>
<p class="calibre1">Another approach is to employ the sprintf() function, borrowed from C: 1</p>
<p class="calibre1">for (i in 1:5) {</p>
<p class="calibre1">2</p>
<p class="calibre1">fname &lt;- sprintf("q%d.pdf",i)</p>
<p class="calibre1">3</p>
<p class="calibre1">pdf(fname)</p>
<p class="calibre1">4</p>
<p class="calibre1">hist(rnorm(100,sd=i))</p>
<p class="calibre1">5</p>
<p class="calibre1">dev.off()</p>
<p class="calibre1">6</p>
<p class="calibre1">}</p>
<p class="calibre1">For floating-point quantities, note also the difference between %f and %g formats:</p>
<p class="calibre1">&gt; sprintf("abc%fdef",1.5)</p>
<p class="calibre1">[1] "abc1.500000def" </p>
<p class="calibre1">&gt; sprintf("abc%gdef",1.5)</p>
<p class="calibre1">[1] "abc1.5def" </p>
<p class="calibre1">The %g format eliminated the superfluous zeros. </p>
<p class="calibre1"><b class="calibre3">11.3 Use of String Utilities in the edtdbg Debugging Tool</b></p>
<p class="calibre1">The internal code of the edtdbg debugging tool, which will be discussed in Section 13.4, makes heavy use of string utilities. A typical example of such usage is the dgbsendeditcmd() function:</p>
<p class="calibre1"># send command to editor</p>
<p class="calibre1">dbgsendeditcmd &lt;- function(cmd) {</p>
<p class="calibre1">syscmd &lt;- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") system(syscmd)</p>
<p class="calibre1">}</p>
<p class="calibre1">String Manipulation</p>
<p class="calibre1"><b class="calibre3">257</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p284"/>What is going on here? The main point is that edtdbg sends remote commands to the Vim text editor. For instance, if you are running Vim with a server name of 168 and you want the cursor in Vim to move to line 12, you could type this into a terminal (shell) window:</p>
<p class="calibre1">vim --remote-send 12G --servername 168</p>
<p class="calibre1">The effect would be the same as if you had physically typed 12G at the Vim window. Since 12G is the Vim command to move the cursor to line 12, that’s what would occur. Consider this call:</p>
<p class="calibre1">paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") Here, cmd is the string "12G", vimserver is 168, and paste() concatenates all the indicated strings. The argument sep="" says to use the empty string as separator in this concatenation—that is, no separation. Thus, paste() returns the following:</p>
<p class="calibre1">vim --remote-send 12G --servername 168</p>
<p class="calibre1">Another core element in the operation of edtdbg is that the program has arranged, via a call to R’s sink() function, to record to the file  <i class="calibre4">dbgsink</i> most output from R’s debugger in your R window. (The edtdbg utility works in concert with that debugger.) That information includes the line numbers of your positions in your source file as you step through it using R’s debugger. </p>
<p class="calibre1">The line position information in the debugger output looks like this: debug at cities.r#16: {</p>
<p class="calibre1">So, there is code in edtdbg to determine the latest line in  <i class="calibre4">dbgsink </i> that begins with “debug at.” That line is then placed, as a string, in a variable named debugline. The following code then extracts the line number (16 in the example) and the source filename/Vim buffer name ( <i class="calibre4">cities.r </i> here): linenumstart &lt;- regexpr("#",debugline) + 1</p>
<p class="calibre1">buffname &lt;- substr(debugline,10,linenumstart-2)</p>
<p class="calibre1">colon &lt;- regexpr(":",debugline)</p>
<p class="calibre1">linenum &lt;- substr(debugline,linenumstart,colon-1)</p>
<p class="calibre1">The call to regexpr() determines where in debugline the # character is located (character 18 in this example). Adding 1 to that gives the position of the line number within debugline. </p>
<p class="calibre1"><b class="calibre3">258</b></p>
<p class="calibre1">Chapter 11</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p285"/>To get the buffer name, using the preceding example as a guide, we see that the name comes after debug at and ends just before the #. Since “debug at” contains nine characters, the buffer name will start at position 10—hence the 10 in the call, </p>
<p class="calibre1">substr(debugline,10,linenumstart-2)</p>
<p class="calibre1">The end of the buffer name field is at linenumstart-2, as it is just before the #, which precedes the start of the line number. The line number computation is then similar. </p>
<p class="calibre1">Another illustrative example of edtdbg’s internal code is its use of the strsplit() function. For example, at one point, it prints out a prompt to the user:</p>
<p class="calibre1">kbdin &lt;- readline(prompt="enter number(s) of fns you wish to toggle dbg: ") As you can see, the user’s response is stored in kbdin. It will consist of a set of numbers separated by spaces, such as this:</p>
<p class="calibre1">1 4 5</p>
<p class="calibre1">We need to extract the numbers from the string 1 4 5 into an integer vector. This is done first via strsplit(), which produces three strings: "1", "4", and "5". Then we call as.integer() to convert from characters to numbers: tognums &lt;- as.integer(strsplit(kbdin,split=" ")[[1]])</p>
<p class="calibre1">Note that the output of strsplit() is an R list, in this case consisting of one element, which is in turn the vector ("1","4","5"). This leads to the expression [[1]] in the example. </p>
<p class="calibre1">String Manipulation</p>
<p class="calibre1"><b class="calibre3">259</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p286"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p287"/><img src="index-287_1.png" alt="Image 24" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">12</b></p>
<p class="calibre1"><b class="calibre3">GRAPHICS</b></p>
<p class="calibre1">R has a very rich set of graphics facilities. </p>
<p class="calibre1">The R home page ( <i class="calibre4">http://www.r-project</i></p>
<p class="calibre1"> <i class="calibre4">.org/ </i>) has a few colorful examples, but to</p>
<p class="calibre1">really appreciate R’s graphical power, browse</p>
<p class="calibre1">through the R Graph Gallery at  <i class="calibre4">http://addictedtor.free</i></p>
<p class="calibre1"> <i class="calibre4">.fr/graphiques</i>. </p>
<p class="calibre1">In this chapter, we cover the basics of using R’s base, or traditional, graphics package. This will give you enough foundation to start working with graphics in R. If you’re interested in pursuing R graphics further, you may want to refer to the excellent books on the subject.1</p>
<p class="calibre1"><b class="calibre3">12.1 Creating Graphs</b></p>
<p class="calibre1">To begin, we’ll look at the foundational function for creating graphs: plot(). </p>
<p class="calibre1">Then we’ll explore how to build a graph, from adding lines and points to attaching a legend. </p>
<p class="calibre1">1 These include Hadley Wickham,  <i class="calibre4">ggplot2: Elegant Graphics for Data Analysis </i>(New York: Springer-Verlag, 2009); Dianne Cook and Deborah F. Swayne,  <i class="calibre4">Interactive and Dynamic Graphics for Data</i> <i class="calibre4">Analysis: With R and GGobi </i>(New York: Springer-Verlag, 2007); Deepayan Sarkar,  <i class="calibre4">Lattice: Multivariate Data Visualization with R </i>(New York: Springer-Verlag, 2008); and Paul Murrell,  <i class="calibre4">R Graphics</i> (Boca Raton, FL: Chapman and Hall/CRC, 2011). </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p288"/><img src="index-288_1.png" alt="Image 25" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.1 The Workhorse of R Base Graphics: The plot() Function</b></i></p>
<p class="calibre1">The plot() function forms the foundation for much of R’s base graphing operations, serving as the vehicle for producing many different kinds of graphs. As mentioned in Section 9.1.1, plot() is a generic function, or a placeholder for a family of functions. The function that is actually called depends on the class of the object on which it is called. </p>
<p class="calibre1">Let’s see what happens when we call plot() with an X vector and a Y</p>
<p class="calibre1">vector, which are interpreted as a set of pairs in the ( <i class="calibre4">x</i>,  <i class="calibre4">y</i>) plane. </p>
<p class="calibre1">&gt; plot(c(1,2,3), c(1,2,4))</p>
<p class="calibre1">This will cause a window to pop up, plotting the points (1,1), (2,2), and (3,4), as shown in Figure 12-1. As you can see, this is a very plain-Jane graph. </p>
<p class="calibre1">We’ll discuss adding some of the fancy bells and whistles later in the chapter. </p>
<p class="calibre1"> <i class="calibre4">Figure 12-1: Simple point plot</i></p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The points in the graph in Figure 12-1 are denoted by empty circles. If you want to</i> <i class="calibre4">use a different character type, specify a value for the named argument pch (for </i> point character <i class="calibre4">). </i></p>
<p class="calibre1">The plot() function works in stages, which means you can build up a graph in stages by issuing a series of commands. For example, as a base, we might first draw an empty graph, with only axes, like this:</p>
<p class="calibre1">&gt; plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y") This draws axes labeled  <i class="calibre4">x </i> and  <i class="calibre4">y</i>. The horizontal ( <i class="calibre4">x</i>) axis ranges from  <i class="calibre4">−</i> 3</p>
<p class="calibre1">to 3. The vertical ( <i class="calibre4">y</i>) axis ranges from  <i class="calibre4">−</i> 1 to 5. The argument type="n" means that there is nothing in the graph itself. </p>
<p class="calibre1"><b class="calibre3">262</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p289"/><img src="index-289_1.png" alt="Image 26" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.2 Adding Lines: The abline() Function</b></i></p>
<p class="calibre1">We now have an empty graph, ready for the next stage, which is adding a line:</p>
<p class="calibre1">&gt; x &lt;- c(1,2,3)</p>
<p class="calibre1">&gt; y &lt;- c(1,3,8)</p>
<p class="calibre1">&gt; plot(x,y)</p>
<p class="calibre1">&gt; lmout &lt;- lm(y ~ x)</p>
<p class="calibre1">&gt; abline(lmout)</p>
<p class="calibre1">After the call to plot(), the graph will simply show the three points, along with the  <i class="calibre4">x</i>- and  <i class="calibre4">y</i>- axes with hash marks. The call to abline() then adds a line to the current graph. Now, which line is this? </p>
<p class="calibre1">As you learned in Section 1.5, the result of the call to the linear-regression function lm() is a class instance containing the slope and intercept of the fitted line, as well as various other quantities that don’t concern us here. We’ve assigned that class instance to lmout. The slope and intercept will now be in lmout$coefficients. </p>
<p class="calibre1">So, what happens when we call abline()? This function simply draws</p>
<p class="calibre1">a straight line, with the function’s arguments treated as the intercept and slope of the line. For instance, the call abline(c(2,1)) draws this line on whatever graph you’ve built up so far:</p>
<p class="calibre1"> <i class="calibre4">y </i>= 2 + 1  <i class="calibre4">· x</i></p>
<p class="calibre1">But abline() is written to take special action if it is called on a regression object (though, surprisingly, it is not a generic function). Thus, it will pick up the slope and intercept it needs from lmout$coefficients and plot that line. It superimposes this line onto the current graph, the one that graphs the three points. In other words, the new graph will show both the points and the line, as in Figure 12-2. </p>
<p class="calibre1"> <i class="calibre4">Figure 12-2: Using </i> abline()</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">263</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p290"/>You can add more lines using the lines() function. Though there are many options, the two basic arguments to lines() are a vector of  <i class="calibre4">x</i>-values and a vector of  <i class="calibre4">y</i>-values. These are interpreted as ( <i class="calibre4">x</i>,  <i class="calibre4">y</i>) pairs representing points to be added to the current graph, with lines connecting the points. </p>
<p class="calibre1">For instance, if X and Y are the vectors (1.5,2.5) and (3,3), you could use this call to add a line from (1.5,3) to (2.5,3) to the present graph:</p>
<p class="calibre1">&gt; lines(c(1.5,2.5),c(3,3))</p>
<p class="calibre1">If you want the lines to “connect the dots,” but don’t want the dots themselves, include type="l" in your call to lines() or to plot(), as follows:</p>
<p class="calibre1">&gt; plot(x,y,type="l")</p>
<p class="calibre1">You can use the lty parameter in plot() to specify the type of line, such as solid or dashed. To see the types available and their codes, enter this command:</p>
<p class="calibre1">&gt; help(par)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.3 Starting a New Graph While Keeping the Old Ones</b></i></p>
<p class="calibre1">Each time you call plot(), directly or indirectly, the current graph window will be replaced by the new one. If you don’t want that to happen, use the command for your operating system:</p>
<p class="calibre1">•</p>
<p class="calibre1">On Linux systems, call X11(). </p>
<p class="calibre1">•</p>
<p class="calibre1">On a Mac, call macintosh(). </p>
<p class="calibre1">•</p>
<p class="calibre1">On Windows, call windows(). </p>
<p class="calibre1">For instance, suppose you wish to plot two histograms of vectors X</p>
<p class="calibre1">and Y and view them side by side. On a Linux system, you would type the following:</p>
<p class="calibre1">&gt; hist(x)</p>
<p class="calibre1">&gt; x11()</p>
<p class="calibre1">&gt; hist(y)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.4 Extended Example: Two Density Estimates on the Same Graph</b></i></p>
<p class="calibre1">Let’s plot nonparametric density estimates (these are basically smoothed histograms) for two sets of examination scores in the same graph. We use the function density() to generate the estimates. Here are the commands we issue:</p>
<p class="calibre1">&gt; d1 = density(testscores$Exam1,from=0,to=100)</p>
<p class="calibre1">&gt; d2 = density(testscores$Exam2,from=0,to=100)</p>
<p class="calibre1"><b class="calibre3">264</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p291"/><img src="index-291_1.png" alt="Image 27" class="calibre2"/></p>
<p class="calibre1"><img src="index-291_2.png" alt="Image 28" class="calibre2"/></p>
<p class="calibre1">&gt; plot(d1,main="",xlab="")</p>
<p class="calibre1">&gt; lines(d2)</p>
<p class="calibre1">First, we compute nonparametric density estimates from the two variables, saving them in objects d1 and d2 for later use. We then call plot() to draw the curve for exam 1, at which point the plot looks like Figure 12-3. We then call lines() to add exam 2’s curve to the graph, producing Figure 12-4. </p>
<p class="calibre1"> <i class="calibre4">Figure 12-3: Plot of first density</i></p>
<p class="calibre1"> <i class="calibre4">Figure 12-4: Addition of second density</i></p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">265</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p292"/>Note that we asked R to use blank labels for the figure as a whole and for the  <i class="calibre4">x</i>-axis. Otherwise, R would have gotten such labels from d1, which would have been specific to exam 1. </p>
<p class="calibre1">Also note that we needed to plot exam 1 first. The scores there were less diverse, so the density estimate was narrower and taller. Had we plotted exam 2, with its shorter curve, first, exam 1’s curve would have been too tall for the plot window. Here, we first ran the two plots separately to see which was taller, but let’s consider a more general situation. </p>
<p class="calibre1">Say we wish to write a broadly usable function that will plot several density estimates on the same graph. For this, we would need to automate the process of determining which density estimate is tallest. To do so, we would use the fact that the estimated density values are contained in the y component of the return value from the call to density(). We would then call max() on each density estimate and use which.max() to determine which density estimate is the tallest. </p>
<p class="calibre1">The call to plot() both initiates the plot and draws the first curve. (Without specifying type="l", only the points would have been plotted.) The call to lines() then adds the second curve. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.5 Extended Example: More on the Polynomial Regression Example</b></i></p>
<p class="calibre1">In Section 9.1.7, we defined a class "polyreg" that facilitates fitting polynomial regression models. Our code there included an implementation of the generic print() function. Let’s now add one for the generic plot() function: 1</p>
<p class="calibre1"># polyfit(x,maxdeg) fits all polynomials up to degree maxdeg; y is</p>
<p class="calibre1">2</p>
<p class="calibre1"># vector for response variable, x for predictor; creates an object of 3</p>
<p class="calibre1"># class "polyreg", consisting of outputs from the various regression 4</p>
<p class="calibre1"># models, plus the original data</p>
<p class="calibre1">5</p>
<p class="calibre1">polyfit &lt;- function(y,x,maxdeg) {</p>
<p class="calibre1">6</p>
<p class="calibre1">pwrs &lt;- powers(x,maxdeg) # form powers of predictor variable</p>
<p class="calibre1">7</p>
<p class="calibre1">lmout &lt;- list() # start to build class</p>
<p class="calibre1">8</p>
<p class="calibre1">class(lmout) &lt;- "polyreg" # create a new class</p>
<p class="calibre1">9</p>
<p class="calibre1">for (i in 1:maxdeg) {</p>
<p class="calibre1">10</p>
<p class="calibre1">lmo &lt;- lm(y ~ pwrs[,1:i])</p>
<p class="calibre1">11</p>
<p class="calibre1"># extend the lm class here, with the cross-validated predictions</p>
<p class="calibre1">12</p>
<p class="calibre1">lmo$fitted.xvvalues &lt;- lvoneout(y,pwrs[,1:i,drop=F])</p>
<p class="calibre1">13</p>
<p class="calibre1">lmout[[i]] &lt;- lmo</p>
<p class="calibre1">14</p>
<p class="calibre1">}</p>
<p class="calibre1">15</p>
<p class="calibre1">lmout$x &lt;- x</p>
<p class="calibre1">16</p>
<p class="calibre1">lmout$y &lt;- y</p>
<p class="calibre1">17</p>
<p class="calibre1">return(lmout)</p>
<p class="calibre1">18</p>
<p class="calibre1">}</p>
<p class="calibre1">19</p>
<p class="calibre1">20</p>
<p class="calibre1"># generic print() for an object fits of class "polyreg": print 21</p>
<p class="calibre1"># cross-validated mean-squared prediction errors</p>
<p class="calibre1">22</p>
<p class="calibre1">print.polyreg &lt;- function(fits) {</p>
<p class="calibre1">23</p>
<p class="calibre1">maxdeg &lt;- length(fits) - 2 # count lm() outputs only, not $x and $y <b class="calibre3">266</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p293"/>24</p>
<p class="calibre1">n &lt;- length(fits$y)</p>
<p class="calibre1">25</p>
<p class="calibre1">tbl &lt;- matrix(nrow=maxdeg,ncol=1)</p>
<p class="calibre1">26</p>
<p class="calibre1">cat("mean squared prediction errors, by degree\n")</p>
<p class="calibre1">27</p>
<p class="calibre1">colnames(tbl) &lt;- "MSPE" </p>
<p class="calibre1">28</p>
<p class="calibre1">for (i in 1:maxdeg) {</p>
<p class="calibre1">29</p>
<p class="calibre1">fi &lt;- fits[[i]]</p>
<p class="calibre1">30</p>
<p class="calibre1">errs &lt;- fits$y - fi$fitted.xvvalues</p>
<p class="calibre1">31</p>
<p class="calibre1">spe &lt;- sum(errs^2)</p>
<p class="calibre1">32</p>
<p class="calibre1">tbl[i,1] &lt;- spe/n</p>
<p class="calibre1">33</p>
<p class="calibre1">}</p>
<p class="calibre1">34</p>
<p class="calibre1">print(tbl)</p>
<p class="calibre1">35</p>
<p class="calibre1">}</p>
<p class="calibre1">36</p>
<p class="calibre1">37</p>
<p class="calibre1"># generic plot(); plots fits against raw data</p>
<p class="calibre1">38</p>
<p class="calibre1">plot.polyreg &lt;- function(fits) {</p>
<p class="calibre1">39</p>
<p class="calibre1">plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background 40</p>
<p class="calibre1">maxdg &lt;- length(fits) - 2</p>
<p class="calibre1">41</p>
<p class="calibre1">cols &lt;- c("red","green","blue")</p>
<p class="calibre1">42</p>
<p class="calibre1">dg &lt;- curvecount &lt;- 1</p>
<p class="calibre1">43</p>
<p class="calibre1">while (dg &lt; maxdg) {</p>
<p class="calibre1">44</p>
<p class="calibre1">prompt &lt;- paste("RETURN for XV fit for degree",dg,"or type degree", 45</p>
<p class="calibre1">"or q for quit ")</p>
<p class="calibre1">46</p>
<p class="calibre1">rl &lt;- readline(prompt)</p>
<p class="calibre1">47</p>
<p class="calibre1">dg &lt;- if (rl == "") dg else if (rl != "q") as.integer(rl) else break 48</p>
<p class="calibre1">lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])</p>
<p class="calibre1">49</p>
<p class="calibre1">dg &lt;- dg + 1</p>
<p class="calibre1">50</p>
<p class="calibre1">curvecount &lt;- curvecount + 1</p>
<p class="calibre1">51</p>
<p class="calibre1">}</p>
<p class="calibre1">52</p>
<p class="calibre1">}</p>
<p class="calibre1">53</p>
<p class="calibre1">54</p>
<p class="calibre1"># forms matrix of powers of the vector x, through degree dg</p>
<p class="calibre1">55</p>
<p class="calibre1">powers &lt;- function(x,dg) {</p>
<p class="calibre1">56</p>
<p class="calibre1">pw &lt;- matrix(x,nrow=length(x))</p>
<p class="calibre1">57</p>
<p class="calibre1">prod &lt;- x</p>
<p class="calibre1">58</p>
<p class="calibre1">for (i in 2:dg) {</p>
<p class="calibre1">59</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">60</p>
<p class="calibre1">pw &lt;- cbind(pw,prod)</p>
<p class="calibre1">61</p>
<p class="calibre1">}</p>
<p class="calibre1">62</p>
<p class="calibre1">return(pw)</p>
<p class="calibre1">63</p>
<p class="calibre1">}</p>
<p class="calibre1">64</p>
<p class="calibre1">65</p>
<p class="calibre1"># finds cross-validated predicted values; could be made much faster via 66</p>
<p class="calibre1"># matrix-update methods</p>
<p class="calibre1">67</p>
<p class="calibre1">lvoneout &lt;- function(y,xmat) {</p>
<p class="calibre1">68</p>
<p class="calibre1">n &lt;- length(y)</p>
<p class="calibre1">69</p>
<p class="calibre1">predy &lt;- vector(length=n)</p>
<p class="calibre1">70</p>
<p class="calibre1">for (i in 1:n) {</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">267</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p294"/>71</p>
<p class="calibre1"># regress, leaving out ith observation</p>
<p class="calibre1">72</p>
<p class="calibre1">lmo &lt;- lm(y[-i] ~ xmat[-i,])</p>
<p class="calibre1">73</p>
<p class="calibre1">betahat &lt;- as.vector(lmo$coef)</p>
<p class="calibre1">74</p>
<p class="calibre1"># the 1 accommodates the constant term</p>
<p class="calibre1">75</p>
<p class="calibre1">predy[i] &lt;- betahat %*% c(1,xmat[i,])</p>
<p class="calibre1">76</p>
<p class="calibre1">}</p>
<p class="calibre1">77</p>
<p class="calibre1">return(predy)</p>
<p class="calibre1">78</p>
<p class="calibre1">}</p>
<p class="calibre1">79</p>
<p class="calibre1">80</p>
<p class="calibre1"># polynomial function of x, coefficients cfs</p>
<p class="calibre1">81</p>
<p class="calibre1">poly &lt;- function(x,cfs) {</p>
<p class="calibre1">82</p>
<p class="calibre1">val &lt;- cfs[1]</p>
<p class="calibre1">83</p>
<p class="calibre1">prod &lt;- 1</p>
<p class="calibre1">84</p>
<p class="calibre1">dg &lt;- length(cfs) - 1</p>
<p class="calibre1">85</p>
<p class="calibre1">for (i in 1:dg) {</p>
<p class="calibre1">86</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">87</p>
<p class="calibre1">val &lt;- val + cfs[i+1] * prod</p>
<p class="calibre1">88</p>
<p class="calibre1">}</p>
<p class="calibre1">89</p>
<p class="calibre1">}</p>
<p class="calibre1">As noted, the only new code is plot.polyreg(). For convenience, the code is reproduced here:</p>
<p class="calibre1"># generic plot(); plots fits against raw data</p>
<p class="calibre1">plot.polyreg &lt;- function(fits) {</p>
<p class="calibre1">plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background maxdg &lt;- length(fits) - 2</p>
<p class="calibre1">cols &lt;- c("red","green","blue")</p>
<p class="calibre1">dg &lt;- curvecount &lt;- 1</p>
<p class="calibre1">while (dg &lt; maxdg) {</p>
<p class="calibre1">prompt &lt;- paste("RETURN for XV fit for degree",dg,"or type degree", </p>
<p class="calibre1">"or q for quit ")</p>
<p class="calibre1">rl &lt;- readline(prompt)</p>
<p class="calibre1">dg &lt;- if (rl == "") dg else if (rl != "q") as.integer(rl) else break lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])</p>
<p class="calibre1">dg &lt;- dg + 1</p>
<p class="calibre1">curvecount &lt;- curvecount + 1</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">As before, our implementation of the generic function takes the name of the class, which is plot.polyreg() here. </p>
<p class="calibre1">The while loop iterates through the various polynomial degrees. We</p>
<p class="calibre1">cycle through three colors, by setting the vector cols; note the expression curvecount %%3 for this purpose. </p>
<p class="calibre1"><b class="calibre3">268</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p295"/><img src="index-295_1.png" alt="Image 29" class="calibre2"/></p>
<p class="calibre1">The user can choose either to plot the next sequential degree or select a different one. The query, both user prompt and reading of the user’s reply, is done in this line:</p>
<p class="calibre1">rl &lt;- readline(prompt)</p>
<p class="calibre1">We use the R string function paste() to assemble a prompt, offering the user a choice of plotting the next fitted polynomial, plotting one of a different degree, or quitting. The prompt appears in the interactive R window in which we issued the plot() call. For instance, after taking the default choice twice, the command window looks like this:</p>
<p class="calibre1">&gt; plot(lmo)</p>
<p class="calibre1">RETURN for XV fit for degree 1 or type degree or q for quit</p>
<p class="calibre1">RETURN for XV fit for degree 2 or type degree or q for quit</p>
<p class="calibre1">RETURN for XV fit for degree 3 or type degree or q for quit</p>
<p class="calibre1">The plot window looks like Figure 12-5. </p>
<p class="calibre1"> <i class="calibre4">Figure 12-5: Plotting a polynomial fit</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.6 Adding Points: The points() Function</b></i></p>
<p class="calibre1">The points() function adds a set of ( <i class="calibre4">x</i>,  <i class="calibre4">y</i>) points, with labels for each, to the currently displayed graph. For instance, in our first example, suppose we entered this command:</p>
<p class="calibre1">points(testscores$Exam1,testscores$Exam3,pch="+")</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">269</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p296"/>The result would be to superimpose onto the current graph the points of the exam scores from that example, using plus signs (+) to mark them. </p>
<p class="calibre1">As with most of the other graphics functions, there are many options, such as point color and background color. For instance, if you want a yellow background, type this command:</p>
<p class="calibre1">&gt; par(bg="yellow")</p>
<p class="calibre1">Now your graphs will have a yellow background, until you specify</p>
<p class="calibre1">otherwise. </p>
<p class="calibre1">As with other functions, to explore the myriad of options, type this:</p>
<p class="calibre1">&gt; help(par)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.7 Adding a Legend: The legend() Function</b></i></p>
<p class="calibre1">The legend() function is used, not surprisingly, to add a legend to a multi-curve graph. This could tell the viewer something like, “The green curve is for the men, and the red curve displays the data for the women.” Type the following to see some nice examples:</p>
<p class="calibre1">&gt; example(legend)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.8 Adding Text: The text() Function</b></i></p>
<p class="calibre1">Use the text() function to place some text anywhere in the current graph. </p>
<p class="calibre1">Here’s an example:</p>
<p class="calibre1">text(2.5,4,"abc")</p>
<p class="calibre1">This writes the text “abc” at the point (2.5,4) in the graph. The center of the string, in this case “b,” would go at that point. </p>
<p class="calibre1">To see a more practical example, let’s add some labels to the curves in our exam scores graph, as follows:</p>
<p class="calibre1">&gt; text(46.7,0.02,"Exam 1")</p>
<p class="calibre1">&gt; text(12.3,0.008,"Exam 2")</p>
<p class="calibre1">The result is shown in Figure 12-6. </p>
<p class="calibre1">In order to get a certain string placed exactly where you want it, you may need to engage in some trial and error. Or you may find the locator() function to be a much quicker way to go, as detailed in the next section. </p>
<p class="calibre1"><b class="calibre3">270</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p297"/><img src="index-297_1.png" alt="Image 30" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-6: Placing text</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.9 Pinpointing Locations: The locator() Function</b></i></p>
<p class="calibre1">Placing text exactly where you wish can be tricky. You could repeatedly try different  <i class="calibre4">x</i>- and  <i class="calibre4">y</i>-coordinates until you find a good position, but the locator() function can save you a lot of trouble. You simply call the function and then click the mouse at the desired spot in the graph. The function returns the  <i class="calibre4">x</i>-</p>
<p class="calibre1">and  <i class="calibre4">y</i>-coordinates of your click point. Specifically, typing the following will tell R that you will click in one place in the graph:</p>
<p class="calibre1">locator(1)</p>
<p class="calibre1">Once you click, R will tell you the exact coordinates of the point you clicked. Call locator(2) to get the locations of two places, and so on. (Warning: Make sure to include the argument.)</p>
<p class="calibre1">Here is a simple example:</p>
<p class="calibre1">&gt; hist(c(12,5,13,25,16))</p>
<p class="calibre1">&gt; locator(1)</p>
<p class="calibre1">$x</p>
<p class="calibre1">[1] 6.239237</p>
<p class="calibre1">$y</p>
<p class="calibre1">[1] 1.221038</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">271</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p298"/>This has R draw a histogram and then calls locator() with the argument 1, indicating we will click the mouse once. After the click, the function returns a list with components x and y, the  <i class="calibre4">x</i>- and  <i class="calibre4">y</i>-coordinates of the point where we clicked. </p>
<p class="calibre1">To use this information to place text, combine it with text():</p>
<p class="calibre1">&gt; text(locator(1),"nv=75")</p>
<p class="calibre1">Here, text() was expecting an  <i class="calibre4">x</i>-coordinate and a  <i class="calibre4">y</i>-coordinate, specifying the point at which to draw the text “nv=75.” The return value of locator() supplied those coordinates. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.1.10 Restoring a Plot</b></i></p>
<p class="calibre1">R has no “undo” command. However, if you suspect you may need to undo your next step when building a graph, you can save it using recordPlot() and then later restore it with replayPlot(). </p>
<p class="calibre1">Less formally but more conveniently, you can put all the commands</p>
<p class="calibre1">you’re using to build up a graph in a file and then use source(), or cut and paste with the mouse, to execute them. If you change one command, you can redo the whole graph by sourcing or copying and pasting your file. </p>
<p class="calibre1">For our current graph, for instance, we could create file named</p>
<p class="calibre1">examplot.R with the following contents:</p>
<p class="calibre1">d1 = density(testscores$Exam1,from=0,to=100)</p>
<p class="calibre1">d2 = density(testscores$Exam2,from=0,to=100)</p>
<p class="calibre1">plot(d1,main="",xlab="")</p>
<p class="calibre1">lines(d2)</p>
<p class="calibre1">text(46.7,0.02,"Exam 1")</p>
<p class="calibre1">text(12.3,0.008,"Exam 2")</p>
<p class="calibre1">If we decide that the label for exam 1 was a bit too far to the right, we can edit the file and then either do the copy-and-paste or execute the following:</p>
<p class="calibre1">&gt; source("examplot.R")</p>
<p class="calibre1"><b class="calibre3">12.2 Customizing Graphs</b></p>
<p class="calibre1">You’ve seen how easy it is to build simple graphs in stages, starting with plot(). </p>
<p class="calibre1">Now you can begin to enhance those graphs, using the many options R</p>
<p class="calibre1">provides. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.1 Changing Character Sizes: The cex Option</b></i></p>
<p class="calibre1">The cex (for  <i class="calibre4">character expand</i>) function allows you to expand or shrink characters within a graph, which can be very useful. You can use it as a named <b class="calibre3">272</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p299"/>parameter in various graphing functions. For instance, you may wish to draw the text “abc” at some point, say (2.5,4), in your graph but with a larger font, in order to call attention to this particular text. You could do this by typing the following:</p>
<p class="calibre1">text(2.5,4,"abc",cex = 1.5)</p>
<p class="calibre1">This prints the same text as in our earlier example but with characters 1.5 times the normal size. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.2 Changing the Range of Axes: The xlim and ylim Options</b></i></p>
<p class="calibre1">You may wish to have the ranges on the  <i class="calibre4">x</i>- and  <i class="calibre4">y</i>-axes of your plot be broader or narrower than the default. This is especially useful if you will be displaying several curves in the same graph. </p>
<p class="calibre1">You can adjust the axes by specifying the xlim and/or ylim parameters in your call to plot() or points(). For example, ylim=c(0,90000) specifies a range on the  <i class="calibre4">y</i>-axis of 0 to 90,000. </p>
<p class="calibre1">If you have several curves and do not specify xlim and/or ylim, you should draw the tallest curve first so there is room for all of them. Otherwise, R will fit the plot to the first one your draw and then cut off taller ones at the top! </p>
<p class="calibre1">We took this approach earlier, when we plotted two density estimates on the same graph (Figures 12-3 and 12-4). Instead, we could have first found the highest values of the two density estimates. For d1, we find the following:</p>
<p class="calibre1">&gt; d1</p>
<p class="calibre1">Call:</p>
<p class="calibre1">density.default(x = testscores$Exam1, from = 0, to = 100)</p>
<p class="calibre1">Data: testscores$Exam1 (39 obs.); </p>
<p class="calibre1">Bandwidth 'bw' = 6.967</p>
<p class="calibre1">x</p>
<p class="calibre1">y</p>
<p class="calibre1">Min. </p>
<p class="calibre1">: 0</p>
<p class="calibre1">Min. </p>
<p class="calibre1">:1.423e-07</p>
<p class="calibre1">1st Qu.: 25</p>
<p class="calibre1">1st Qu.:1.629e-03</p>
<p class="calibre1">Median : 50</p>
<p class="calibre1">Median :9.442e-03</p>
<p class="calibre1">Mean</p>
<p class="calibre1">: 50</p>
<p class="calibre1">Mean</p>
<p class="calibre1">:9.844e-03</p>
<p class="calibre1">3rd Qu.: 75</p>
<p class="calibre1">3rd Qu.:1.756e-02</p>
<p class="calibre1">Max. </p>
<p class="calibre1">:100</p>
<p class="calibre1">Max. </p>
<p class="calibre1">:2.156e-02</p>
<p class="calibre1">So, the largest y-value is 0.022. For d2, it was only 0.017. That means we should have plenty of room if we set ylim at 0.03. Here is how we could draw the two plots on the same picture:</p>
<p class="calibre1">&gt; plot(c(0, 100), c(0, 0.03), type = "n", xlab="score", ylab="density")</p>
<p class="calibre1">&gt; lines(d2)</p>
<p class="calibre1">&gt; lines(d1)</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">273</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p300"/><img src="index-300_1.jpg" alt="Image 31" class="calibre2"/></p>
<p class="calibre1"><img src="index-300_2.jpg" alt="Image 32" class="calibre2"/></p>
<p class="calibre1">First we drew the bare-bones plot—just axes without innards, as shown in Figure 12-7. The first two arguments to plot() give xlim and ylim, so that the lower and upper limits on the Y axis will be 0 and 0.03. Calling lines() twice then fills in the graph, yielding Figures 12-8 and 12-9. (Either of the two lines() calls could come first, as we’ve left enough room.)</p>
<p class="calibre1"> <i class="calibre4">Figure 12-7: Axes only</i></p>
<p class="calibre1"> <i class="calibre4">Figure 12-8: Addition of </i> d2</p>
<p class="calibre1"><b class="calibre3">274</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p301"/><img src="index-301_1.jpg" alt="Image 33" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-9: Addition of </i> d1</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.3 Adding a Polygon: The polygon() Function</b></i></p>
<p class="calibre1">You can use polygon() to draw arbitrary polygonal objects. For example, the following code draws the graph of the function  <i class="calibre4">f </i>( <i class="calibre4">x</i>) = 1  <i class="calibre4">− e−x </i> and then adds a rectangle that approximates the area under the curve from  <i class="calibre4">x </i>= 1.2 to <i class="calibre4">x </i>= 1.4. </p>
<p class="calibre1">&gt; f &lt;- function(x) return(1-exp(-x))</p>
<p class="calibre1">&gt; curve(f,0,2)</p>
<p class="calibre1">&gt; polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),col="gray") The result is shown in Figure 12-10. </p>
<p class="calibre1">In the call to polygon() here, the first argument is the set of  <i class="calibre4">x</i>-coordinates for the rectangle, and the second argument specifies the  <i class="calibre4">y</i>-coordinates. The third argument specifies that the rectangle in this case should be shaded in solid gray. </p>
<p class="calibre1">As another example, we could use the density argument to fill the rectangle with striping. This call specifies 10 lines per inch:</p>
<p class="calibre1">&gt; polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),density=10)</p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">275</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p302"/><img src="index-302_1.jpg" alt="Image 34" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-10: Rectangular area strip</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.4 Smoothing Points: The lowess() and loess() Functions</b></i></p>
<p class="calibre1">Just plotting a cloud of points, connected or not, may give you nothing but an uninformative mess. In many cases, it is better to smooth out the data by fitting a nonparametric regression estimator such as lowess(). </p>
<p class="calibre1">Let’s do that for our test score data. We’ll plot the scores of exam 2</p>
<p class="calibre1">against those of exam 1:</p>
<p class="calibre1">&gt; plot(testscores)</p>
<p class="calibre1">&gt; lines(lowess(testscores))</p>
<p class="calibre1">The result is shown in Figure 12-11. </p>
<p class="calibre1">A newer alternative to lowess() is loess(). The two functions are similar but have different defaults and other options. You need some advanced knowledge of statistics to appreciate the differences. Use whichever you find gives better smoothing. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.5 Graphing Explicit Functions</b></i></p>
<p class="calibre1">Say you want to plot the function  <i class="calibre4">g</i>( <i class="calibre4">t</i>) = ( <i class="calibre4">t</i> 2 + 1)0 <i class="calibre4">. </i> 5 for t between 0 and 5. </p>
<p class="calibre1">You could use the following R code:</p>
<p class="calibre1">g &lt;- function(t) { return (t^2+1)^0.5 } # define g()</p>
<p class="calibre1">x &lt;- seq(0,5,length=10000) # x = [0.0004, 0.0008, 0.0012,..., 5]</p>
<p class="calibre1">y &lt;- g(x) # y = [g(0.0004), g(0.0008), g(0.0012), ..., g(5)]</p>
<p class="calibre1">plot(x,y,type="l")</p>
<p class="calibre1"><b class="calibre3">276</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p303"/><img src="index-303_1.jpg" alt="Image 35" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-11: Smoothing the exam score relation</i></p>
<p class="calibre1">But you could avoid some work by using the curve() function, which basically uses the same method:</p>
<p class="calibre1">&gt; curve((x^2+1)^0.5,0,5)</p>
<p class="calibre1">If you are adding this curve to an existing plot, use the add argument:</p>
<p class="calibre1">&gt; curve((x^2+1)^0.5,0,5,add=T)</p>
<p class="calibre1">The optional argument n has the default value 101, meaning that the function will be evaluated at 101 equally spaced points in the specified range of x. </p>
<p class="calibre1">Use just enough points for visual smoothness. If you find 101 is not enough, experiment with higher values of n. </p>
<p class="calibre1">You can also use plot(), as follows:</p>
<p class="calibre1">&gt; f &lt;- function(x) return((x^2+1)^0.5)</p>
<p class="calibre1">&gt; plot(f,0,5) # the argument must be a function name</p>
<p class="calibre1">Here, the call plot() leads to calling plot.function(), the implementation of the generic plot() function for the function class. </p>
<p class="calibre1">Again, the approach is your choice; use whichever one you prefer. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.2.6 Extended Example: Magnifying a Portion of a Curve</b></i></p>
<p class="calibre1">After you use curve() to graph a function, you may want to “zoom in” on one portion of the curve. You could do this by simply calling curve() again on Graphics</p>
<p class="calibre1"><b class="calibre3">277</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p304"/>the same function but with a restricted  <i class="calibre4">x </i> range. But suppose you wish to display the original plot and the close-up one in the same picture. Here, we will develop a function, which we’ll name inset(), to do this. </p>
<p class="calibre1">In order to avoid redoing the work that curve() did in plotting the original graph, we will modify its code slightly to save that work, via a return value. We can do this by taking advantage of the fact that you can easily inspect the code of R functions written in R (as opposed to the fundamental R functions written in C), as follows:</p>
<p class="calibre1">1</p>
<p class="calibre1">&gt; curve</p>
<p class="calibre1">2</p>
<p class="calibre1">function (expr, from = NULL, to = NULL, n = 101, add = FALSE, </p>
<p class="calibre1">3</p>
<p class="calibre1">type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)</p>
<p class="calibre1">4</p>
<p class="calibre1">{</p>
<p class="calibre1">5</p>
<p class="calibre1">sexpr &lt;- substitute(expr)</p>
<p class="calibre1">6</p>
<p class="calibre1">if (is.name(sexpr)) {</p>
<p class="calibre1">7</p>
<p class="calibre1"># ...lots of lines omitted here... </p>
<p class="calibre1">8</p>
<p class="calibre1">x &lt;- if (lg != "" &amp;&amp; "x" %in% strsplit(lg, NULL)[[1]]) {</p>
<p class="calibre1">9</p>
<p class="calibre1">if (any(c(from, to) &lt;= 0))</p>
<p class="calibre1">10</p>
<p class="calibre1">stop("'from' and 'to' must be &gt; 0 with log=\"x\"") 11</p>
<p class="calibre1">exp(seq.int(log(from), log(to), length.out = n))</p>
<p class="calibre1">12</p>
<p class="calibre1">}</p>
<p class="calibre1">13</p>
<p class="calibre1">else seq.int(from, to, length.out = n)</p>
<p class="calibre1">14</p>
<p class="calibre1">y &lt;- eval(expr, envir = list(x = x), enclos = parent.frame())</p>
<p class="calibre1">15</p>
<p class="calibre1">if (add)</p>
<p class="calibre1">16</p>
<p class="calibre1">lines(x, y, type = type, ...)</p>
<p class="calibre1">17</p>
<p class="calibre1">else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18</p>
<p class="calibre1">}</p>
<p class="calibre1">The code forms vectors x and y, consisting of the  <i class="calibre4">x</i>- and  <i class="calibre4">y</i>-coordinates of the curve to be plotted, at n equally spaced points in the range of  <i class="calibre4">x</i>. Since we’ll make use of those in inset(), let’s modify this code to return x and y. </p>
<p class="calibre1">Here’s the modified version, which we’ve named crv():</p>
<p class="calibre1">1</p>
<p class="calibre1">&gt; crv</p>
<p class="calibre1">2</p>
<p class="calibre1">function (expr, from = NULL, to = NULL, n = 101, add = FALSE, </p>
<p class="calibre1">3</p>
<p class="calibre1">type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)</p>
<p class="calibre1">4</p>
<p class="calibre1">{</p>
<p class="calibre1">5</p>
<p class="calibre1">sexpr &lt;- substitute(expr)</p>
<p class="calibre1">6</p>
<p class="calibre1">if (is.name(sexpr)) {</p>
<p class="calibre1">7</p>
<p class="calibre1"># ...lots of lines omitted here... </p>
<p class="calibre1">8</p>
<p class="calibre1">x &lt;- if (lg != "" &amp;&amp; "x" %in% strsplit(lg, NULL)[[1]]) {</p>
<p class="calibre1">9</p>
<p class="calibre1">if (any(c(from, to) &lt;= 0))</p>
<p class="calibre1">10</p>
<p class="calibre1">stop("'from' and 'to' must be &gt; 0 with log=\"x\"") 11</p>
<p class="calibre1">exp(seq.int(log(from), log(to), length.out = n))</p>
<p class="calibre1">12</p>
<p class="calibre1">}</p>
<p class="calibre1">13</p>
<p class="calibre1">else seq.int(from, to, length.out = n)</p>
<p class="calibre1">14</p>
<p class="calibre1">y &lt;- eval(expr, envir = list(x = x), enclos = parent.frame())</p>
<p class="calibre1">15</p>
<p class="calibre1">if (add)</p>
<p class="calibre1"><b class="calibre3">278</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p305"/>16</p>
<p class="calibre1">lines(x, y, type = type, ...)</p>
<p class="calibre1">17</p>
<p class="calibre1">else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18</p>
<p class="calibre1">return(list(x=x,y=y)) # this is the only modification</p>
<p class="calibre1">19</p>
<p class="calibre1">}</p>
<p class="calibre1">Now we can get to our inset() function. </p>
<p class="calibre1">1</p>
<p class="calibre1"># savexy: list consisting of x and y vectors returned by crv()</p>
<p class="calibre1">2</p>
<p class="calibre1"># x1,y1,x2,y2: coordinates of rectangular region to be magnified</p>
<p class="calibre1">3</p>
<p class="calibre1"># x3,y3,x4,y4: coordinates of inset region</p>
<p class="calibre1">4</p>
<p class="calibre1">inset &lt;- function(savexy,x1,y1,x2,y2,x3,y3,x4,y4) {</p>
<p class="calibre1">5</p>
<p class="calibre1">rect(x1,y1,x2,y2) # draw rectangle around region to be magnified</p>
<p class="calibre1">6</p>
<p class="calibre1">rect(x3,y3,x4,y4) # draw rectangle around the inset</p>
<p class="calibre1">7</p>
<p class="calibre1"># get vectors of coordinates of previously plotted points</p>
<p class="calibre1">8</p>
<p class="calibre1">savex &lt;- savexy$x</p>
<p class="calibre1">9</p>
<p class="calibre1">savey &lt;- savexy$y</p>
<p class="calibre1">10</p>
<p class="calibre1"># get subscripts of xi our range to be magnified</p>
<p class="calibre1">11</p>
<p class="calibre1">n &lt;- length(savex)</p>
<p class="calibre1">12</p>
<p class="calibre1">xvalsinrange &lt;- which(savex &gt;= x1 &amp; savex &lt;= x2)</p>
<p class="calibre1">13</p>
<p class="calibre1">yvalsforthosex &lt;- savey[xvalsinrange]</p>
<p class="calibre1">14</p>
<p class="calibre1"># check that our first box contains the entire curve for that X range 15</p>
<p class="calibre1">if (any(yvalsforthosex &lt; y1 | yvalsforthosex &gt; y2)) {</p>
<p class="calibre1">16</p>
<p class="calibre1">print("Y value outside first box")</p>
<p class="calibre1">17</p>
<p class="calibre1">return()</p>
<p class="calibre1">18</p>
<p class="calibre1">}</p>
<p class="calibre1">19</p>
<p class="calibre1"># record some differences</p>
<p class="calibre1">20</p>
<p class="calibre1">x2mnsx1 &lt;- x2 - x1</p>
<p class="calibre1">21</p>
<p class="calibre1">x4mnsx3 &lt;- x4 - x3</p>
<p class="calibre1">22</p>
<p class="calibre1">y2mnsy1 &lt;- y2 - y1</p>
<p class="calibre1">23</p>
<p class="calibre1">y4mnsy3 &lt;- y4 - y3</p>
<p class="calibre1">24</p>
<p class="calibre1"># for the ith point in the original curve, the function plotpt() will 25</p>
<p class="calibre1"># calculate the position of this point in the inset curve</p>
<p class="calibre1">26</p>
<p class="calibre1">plotpt &lt;- function(i) {</p>
<p class="calibre1">27</p>
<p class="calibre1">newx &lt;- x3 + ((savex[i] - x1)/x2mnsx1) * x4mnsx3</p>
<p class="calibre1">28</p>
<p class="calibre1">newy &lt;- y3 + ((savey[i] - y1)/y2mnsy1) * y4mnsy3</p>
<p class="calibre1">29</p>
<p class="calibre1">return(c(newx,newy))</p>
<p class="calibre1">30</p>
<p class="calibre1">}</p>
<p class="calibre1">31</p>
<p class="calibre1">newxy &lt;- sapply(xvalsinrange,plotpt)</p>
<p class="calibre1">32</p>
<p class="calibre1">lines(newxy[1,],newxy[2,])</p>
<p class="calibre1">33</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s try it out. </p>
<p class="calibre1">xyout &lt;- crv(exp(-x)*sin(1/(x-1.5)),0.1,4,n=5001)</p>
<p class="calibre1">inset(xyout,1.3,-0.3,1.47,0.3, 2.5,-0.3,4,-0.1)</p>
<p class="calibre1">The resulting plot looks like Figure 12-12. </p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">279</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p306"/><img src="index-306_1.png" alt="Image 36" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 12-12: Adding an inset graph</i></p>
<p class="calibre1"><b class="calibre3">12.3 Saving Graphs to Files</b></p>
<p class="calibre1">The R graphics display can consist of various graphics devices. The default device is the screen. If you want to save a graph to a file, you must set up another device. </p>
<p class="calibre1">Let’s go through the basics of R graphics devices first to introduce R</p>
<p class="calibre1">graphics device concepts, and then discuss a second approach that is much more direct and convenient. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.3.1 R Graphics Devices</b></i></p>
<p class="calibre1">Let’s open a file:</p>
<p class="calibre1">&gt; pdf("d12.pdf")</p>
<p class="calibre1">This opens the file  <i class="calibre4">d12.pdf</i>. We now have two devices open, as we can confirm:</p>
<p class="calibre1">&gt; dev.list()</p>
<p class="calibre1">X11 pdf</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1"><b class="calibre3">280</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p307"/>The screen is named X11 when R runs on Linux. (It’s named windows on Windows systems.) It is device number 2 here. Our PDF file is device number 3. Our active device is the PDF file:</p>
<p class="calibre1">&gt; dev.cur()</p>
<p class="calibre1">pdf</p>
<p class="calibre1">3</p>
<p class="calibre1">All graphics output will now go to this file instead of to the screen. But what if we wish to save what’s already on the screen? </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.3.2 Saving the Displayed Graph</b></i></p>
<p class="calibre1">One way to save the graph currently displayed on the screen is to reestablish the screen as the current device and then copy it to the PDF device, which is 3 in our example, as follows:</p>
<p class="calibre1">&gt; dev.set(2)</p>
<p class="calibre1">X11</p>
<p class="calibre1">2</p>
<p class="calibre1">&gt; dev.copy(which=3)</p>
<p class="calibre1">pdf</p>
<p class="calibre1">3</p>
<p class="calibre1">But actually, it is best to set up a PDF device as shown earlier and then rerun whatever analyses led to the current screen. This is because the copy operation can result in distortions due to mismatches between screen devices and file devices. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">12.3.3 Closing an R Graphics Device</b></i></p>
<p class="calibre1">Note that the PDF file we create is not usable until we close it, which we do as follows:</p>
<p class="calibre1">&gt; dev.set(3)</p>
<p class="calibre1">pdf</p>
<p class="calibre1">3</p>
<p class="calibre1">&gt; dev.off()</p>
<p class="calibre1">X11</p>
<p class="calibre1">2</p>
<p class="calibre1">You can also close the device by exiting R, if you’re finished working with it. But in future versions of R, this behavior may not exist, so it’s probably better to proactively close. </p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">281</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p308"/><img src="index-308_1.jpg" alt="Image 37" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">12.4 Creating Three-Dimensional Plots</b></p>
<p class="calibre1">R offers a number of functions to plot data in three dimensions such as persp() and wireframe(), which draw surfaces, and cloud(), which draws three-dimensional scatter plots. Here, we’ll look at a simple example that uses wireframe(). </p>
<p class="calibre1">&gt; library(lattice)</p>
<p class="calibre1">&gt; a &lt;- 1:10</p>
<p class="calibre1">&gt; b &lt;- 1:15</p>
<p class="calibre1">&gt; eg &lt;- expand.grid(x=a,y=b)</p>
<p class="calibre1">&gt; eg$z &lt;- eg$x^2 + eg$x * eg$y</p>
<p class="calibre1">&gt; wireframe(z ~ x+y, eg)</p>
<p class="calibre1">First, we load the lattice library. Then the call to expand.grid() creates a data frame, consisting of two columns named x and y, in all possible combinations of the values of the two inputs. Here, a and b had 10 and 15 values, respectively, so the resulting data frame will have 150 rows. (Note that the data frame that is input to wireframe() does not need to be created by expand.grid().)</p>
<p class="calibre1">We then added a third column, named z, as a function of the first two columns. Our call to wireframe() creates the graph. The arguments, given in regression model form, specify that z is to be graphed against x and y. Of course, z, x, and y refer to names of columns in eg. The result is shown in Figure 12-13. </p>
<p class="calibre1"> <i class="calibre4">Figure 12-13: Example of using </i> wireframe()</p>
<p class="calibre1"><b class="calibre3">282</b></p>
<p class="calibre1">Chapter 12</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p309"/>All the points are connected as a surface (like connecting points by lines in two dimensions). In contrast, with cloud(), the points are isolated. </p>
<p class="calibre1">For wireframe(), the ( <i class="calibre4">x</i>,  <i class="calibre4">y</i>) pairs must form a rectangular grid, though not necessarily be evenly spaced. </p>
<p class="calibre1">The three-dimensional plotting functions have many different options. </p>
<p class="calibre1">For instance, a nice one for wireframe() is shade=T, which makes the data easier to see. Many functions, some with elaborate options, and whole new graphics packages work at a higher (read “more convenient and powerful”) level of abstraction than R’s base graphics package. For more information, refer to the books cited in footnote 1 at the beginning of this chapter. </p>
<p class="calibre1">Graphics</p>
<p class="calibre1"><b class="calibre3">283</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p310"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p311"/><img src="index-311_1.png" alt="Image 38" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">13</b></p>
<p class="calibre1"><b class="calibre3">DEBUGGING</b></p>
<p class="calibre1">Programmers often find that they spend</p>
<p class="calibre1">more time debugging a program than</p>
<p class="calibre1">actually writing it. Good debugging skills</p>
<p class="calibre1">are invaluable. In this chapter, we’ll discuss</p>
<p class="calibre1">debugging in R. </p>
<p class="calibre1"><b class="calibre3">13.1 Fundamental Principles of Debugging</b></p>
<p class="calibre1">Beware of bugs in the above code; I have only proved it correct, </p>
<p class="calibre1">not tried it. </p>
<p class="calibre1">—Donald Knuth, pioneer of computer science</p>
<p class="calibre1">Though debugging is an art rather than a science, it involves some fundamental principles. Here, we’ll look at some debugging best practices. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.1.1 The Essence of Debugging: The Principle of Confirmation</b></i></p>
<p class="calibre1">As Pete Salzman and I said in our book on debugging,  <i class="calibre4">The Art of Debugging,</i> <i class="calibre4">with GDB, DDD, and Eclipse </i>(No Starch Press, 2008), the principle of confirmation is the essence of debugging. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p312"/>Fixing a buggy program is a process of confirming, one by one, that the many things you  <i class="calibre4">believe </i> to be true about the code actually <i class="calibre4">are </i> true. When you find that one of your assumptions is  <i class="calibre4">not </i> true, you have found a clue to the location (if not the exact nature) of</p>
<p class="calibre1">a bug. </p>
<p class="calibre1">Another way of saying this is, “Surprises are good!” For example, say you have the following code:</p>
<p class="calibre1">x &lt;- y^2 + 3*g(z,2)</p>
<p class="calibre1">w &lt;- 28</p>
<p class="calibre1">if (w+q &gt; 0) u &lt;- 1 else v &lt;- 10</p>
<p class="calibre1">Do you think the value of your variable x should be 3 after x is assigned? </p>
<p class="calibre1">Confirm it! Do you think the else will be executed, not the if on that third line? Confirm it! </p>
<p class="calibre1">Eventually, one of these assertions that you are so sure of will turn out to not confirm. Then you will have pinpointed the likely location of the error, thus enabling you to focus on the nature of the error. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.1.2 Start Small</b></i></p>
<p class="calibre1">At least at the beginning of the debugging process, stick to small, simple test cases. Working with large data objects may make it harder to think about the problem. </p>
<p class="calibre1">Of course, you should eventually test your code on large, complicated cases, but start small. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.1.3 Debug in a Modular, Top-Down Manner</b></i></p>
<p class="calibre1">Most good software developers agree that code should be written in a modular manner. Your first-level code should not be longer than, say, a dozen lines, with much of it consisting of function calls. And those functions should not be too lengthy and should call other functions if necessary. This makes the code easier to organize during the writing stage and easier for others to understand when it comes time for the code to be extended. </p>
<p class="calibre1">You should debug in a top-down manner, too. Suppose that you have set the debug status of your function f() (that is, you have called debug(f), to be explained shortly) and f() contains this line:</p>
<p class="calibre1">y &lt;- g(x,8)</p>
<p class="calibre1">You should take an “innocent until proven guilty” approach to g(). Do <i class="calibre4">not </i> call debug(g) yet. Execute that line and see if g() returns the value you expect. If it does, then you’ve just avoided the time-consuming process of single-stepping through g(). If g() returns the wrong value, then now is the time to call debug(g). </p>
<p class="calibre1"><b class="calibre3">286</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p313"/> <i class="calibre4"><b class="calibre3">13.1.4 Antibugging</b></i></p>
<p class="calibre1">You may adopt some “antibugging” strategies as well. Suppose you have a section of code in which a variable x should be positive. You could insert this line:</p>
<p class="calibre1">stopifnot(x &gt; 0)</p>
<p class="calibre1">If there is a bug earlier in the code that renders x equal to, say,  <i class="calibre4">−</i> 12, the call to stopifnot() will bring things to a halt right there, with an error message like this:</p>
<p class="calibre1">Error: x &gt; 0 is not TRUE</p>
<p class="calibre1">(C programmers may notice the similarity to C’s assert statement.)</p>
<p class="calibre1">After fixing a bug and testing the new code, you might want to keep that code handy so you can check later that the bug did not somehow reappear. </p>
<p class="calibre1"><b class="calibre3">13.2 Why Use a Debugging Tool? </b></p>
<p class="calibre1">In the old days, programmers would perform the debugging confirmation process by temporarily inserting print statements into their code and rerunning the program to see what printed out. For example, to confirm that x = 3 in our previous code, we would insert into our code a statement that printed the value of x and do something similar for the if-else, like this: x &lt;- y^2 + 3*g(z,2)</p>
<p class="calibre1">cat("x =",x,"\n")</p>
<p class="calibre1">w &lt;- 28</p>
<p class="calibre1">if (w+q &gt; 0) {</p>
<p class="calibre1">u &lt;- 1</p>
<p class="calibre1">print("the 'if' was done")</p>
<p class="calibre1">} else {</p>
<p class="calibre1">v &lt;- 10</p>
<p class="calibre1">print("the 'else' was done")</p>
<p class="calibre1">}</p>
<p class="calibre1">We would rerun the program and inspect the feedback printed out. We would then remove the print statements and put in new ones to track down the next bug. </p>
<p class="calibre1">This manual process is fine for one or two cycles, but it gets really tedious during a long debugging session. And worse, all that editing work distracts your attention, making it harder to concentrate on finding the bug. </p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">287</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p314"/>So, debugging by inserting print statements into your code is slow, cum-bersome, and distracting. If you are serious about programming in any particular language, you should seek a good debugging tool for that language. </p>
<p class="calibre1">Using a debugging tool will make it much easier to query the values of variables, check whether the if or the else gets executed, and so on. Moreover, if your bug causes an execution error, debugging tools can analyze it for you, possibly providing major clues as to the source of the error. All of this will increase your productivity substantially. </p>
<p class="calibre1"><b class="calibre3">13.3 Using R Debugging Facilities</b></p>
<p class="calibre1">The R base package includes a number of debugging facilities, and more functional debugging packages are also available. We’ll discuss both the base facilities and other packages, and our extended example will present a fully detailed debugging session. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.3.1 Single-Stepping with the debug() and browser() Functions</b></i></p>
<p class="calibre1">The core of R’s debugging facility consists of the  <i class="calibre4">browser</i>. It allows you to single-step through your code, line by line, taking a look around as you go. </p>
<p class="calibre1">You can invoke the browser through a call to either the debug() or browser() function. </p>
<p class="calibre1">R’s debugging facility is specific to individual functions. If you believe there is a bug in your function f(), you can make the call debug(f) to set the debug status for the function f(). This means that from that point onward, each time you call the function, you will automatically enter the browser at the beginning of the function. Calling undebug(f) will unset the debug status of the function so that entry to the function will no longer invoke the browser. </p>
<p class="calibre1">On the other hand, if you place a call to browser() at some line within f(), the browser will be invoked only when execution reaches that line. You then can single-step through your code until you exit the function. If you believe the bug’s location is not near the beginning of the function, you probably don’t want to be single-stepping from the beginning, so this approach is more direct. </p>
<p class="calibre1">Readers who have used C debuggers such as GDB (the GNU debugger)</p>
<p class="calibre1">will find similarity here, but some aspects will come as a surprise. As noted, for instance, debug() is called on the function level, not on the overall program level. If you believe you have bugs in several of your functions, you’ll need to call debug() on each one. </p>
<p class="calibre1">It can become tedious to call debug(f) and then undebug(f) when you just want to go through one debugging session for f(). Starting with R 2.10, one can now call debugonce() instead; calling debugonce(f) puts f() into debugging status the first time you execute it, but that status is reversed immediately upon exit from the function. </p>
<p class="calibre1"><b class="calibre3">288</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p315"/> <i class="calibre4"><b class="calibre3">13.3.2 Using Browser Commands</b></i></p>
<p class="calibre1">While you are in the browser, the prompt changes from  <i class="calibre4">&gt; </i> to Browse[d] <i class="calibre4">&gt; </i>. </p>
<p class="calibre1">(Here, d is the depth of the call chain.) You may submit any of the following commands at that prompt:</p>
<p class="calibre1">•</p>
<p class="calibre1">n (for  <i class="calibre4">next</i>): Tells R to execute the next line and then pause again. Hitting ENTER causes this action, too. </p>
<p class="calibre1">•</p>
<p class="calibre1">c (for  <i class="calibre4">continue</i>): This is like n, except that several lines of code may be executed before the next pause. If you are currently in a loop, this command will result in the remainder of the loop being executed and then pausing upon exit from the loop. If you are in a function but not in a loop, the remainder of the function will be executed before the next pause. </p>
<p class="calibre1">•</p>
<p class="calibre1">Any R command: While in the browser, you are still in R’s interactive mode and thus can query the value of, say, x by simply typing x. Of course, if you have a variable with the same name as a browser command, you must explicitly call something like print(), as in print(n). </p>
<p class="calibre1">•</p>
<p class="calibre1">where: This prints a  <i class="calibre4">stack trace</i>. It displays what sequence of function calls led execution to the current location. </p>
<p class="calibre1">•</p>
<p class="calibre1">Q: This quits the browser, bringing you back to R’s main interactive mode. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.3.3 Setting Breakpoints</b></i></p>
<p class="calibre1">Calling debug(f) places a call to browser() at the beginning of f(). However, this may be too coarse a tool in some cases. If you suspect that the bug is in the middle of the function, it’s wasteful to trudge through all the intervening code. </p>
<p class="calibre1">The solution is to set  <i class="calibre4">breakpoints </i> at certain key locations of your code—</p>
<p class="calibre1">places where you want execution to be paused. How can this be done in R? </p>
<p class="calibre1">You can call browser directly or use the setBreakpoint() function (with R version 2.10 and later). </p>
<p class="calibre1"><b class="calibre3">13.3.3.1 Calling browser() Directly</b></p>
<p class="calibre1">You can set a breakpoint by simply inserting calls to browser() at the places of interest in your code. This has the effect, essentially, of setting breakpoints there. </p>
<p class="calibre1">You can make invoking the browser conditional so that it is entered only in specified situations. Use the expr argument to define those situations. For instance, suppose you suspect that your bug arises only when a certain variable s is larger than 1. You could use this code:</p>
<p class="calibre1">browser(s &gt; 1)</p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">289</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p316"/>The browser will be invoked only if s is larger than 1. The following would have the same effect:</p>
<p class="calibre1">if (s &gt; 1) browser()</p>
<p class="calibre1">Calling the browser directly, rather than entering the debugger via debug() is very useful in situations in which you have a loop with many iterations and the bug surfaces only after, say, the 50th iteration. If the loop index is i, then you could write this:</p>
<p class="calibre1">if (i &gt; 49) browser()</p>
<p class="calibre1">That way, you would avoid the tedium of stepping through the first 49</p>
<p class="calibre1">iterations! </p>
<p class="calibre1"><b class="calibre3">13.3.3.2 Using the setBreakpoint() Function</b></p>
<p class="calibre1">Starting with R 2.10, you can use setBreakpoint() in the format</p>
<p class="calibre1">setBreakpoint( <i class="calibre4">filename,linenumber</i>)</p>
<p class="calibre1">This will result in browser() being called at line  <i class="calibre4">linenumber </i> of our source file <i class="calibre4">filename</i>. </p>
<p class="calibre1">This is especially useful when you are in the midst of using the debugger, single-stepping through code. Say you are currently at line 12 of your source file  <i class="calibre4">x.R </i> and want to have a breakpoint at line 28. Instead of exiting the debugger, adding a call to browser() at line 28, and then re-entering the function, you could simply type this:</p>
<p class="calibre1">&gt; setBreakpoint("x.R",28)</p>
<p class="calibre1">You could then resume execution within the debugger, say by issuing the c command. </p>
<p class="calibre1">The setBreakpoint() function works by calling the trace() function, discussed in the next section. Thus, to cancel the breakpoint, you cancel the trace. For instance, if we had called setBreakpoint() at a line in the function g(), we would cancel the breakpoint by typing the following:</p>
<p class="calibre1">&gt; untrace(g)</p>
<p class="calibre1">You can call setBreakpoint() whether or not you are currently in the debugger. If you are not currently running the debugger and you execute the affected function and hit the breakpoint during that execution, you will be put into the browser automatically. This is similar to the case of browser(), but using this approach, you save yourself the trouble of changing your code via your text editor. </p>
<p class="calibre1"><b class="calibre3">290</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p317"/> <i class="calibre4"><b class="calibre3">13.3.4 Tracking with the trace() Function</b></i></p>
<p class="calibre1">The trace() function is flexible and powerful, though it takes some initial effort to learn. We will discuss some of the simpler usage forms here, beginning with the following:</p>
<p class="calibre1">&gt; trace(f,t)</p>
<p class="calibre1">This call instructs R to call the function t() every time we enter the function f(). For instance, say we wish to set a breakpoint at the beginning of the function gy(). We could use this command:</p>
<p class="calibre1">&gt; trace(gy,browser)</p>
<p class="calibre1">This has the same effect as placing the command browser() in our source code for gy(), but it’s quicker and more convenient than inserting such a line, saving the file, and rerunning source() to load in the new version of the file. Calling trace() does  <i class="calibre4">not </i> change your source file, though it does change a temporary version of your file maintained by R. It would also be quicker and more convenient to undo, by simply running untrace:</p>
<p class="calibre1">&gt; untrace(gy)</p>
<p class="calibre1">You can turn tracing on or off globally by calling tracingState(), using the argument TRUE to turn it on or FALSE to turn it off. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.3.5 Performing Checks After a Crash with the traceback() and</b></i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">debugger() Functions</b></i></p>
<p class="calibre1">Say your R code crashes when you are not running the debugger. There is still a debugging tool available to you after the fact. You can do a “post-mortem” by simply calling traceback(). It will tell you in which function the problem occurred and the call chain that led to that function. </p>
<p class="calibre1">You can get a lot more information if you set up R to dump frames in the event of a crash:</p>
<p class="calibre1">&gt; options(error=dump.frames)</p>
<p class="calibre1">If you’ve done this, then after a crash, run this command:</p>
<p class="calibre1">&gt; debugger()</p>
<p class="calibre1">You will then be presented with a choice of levels of function calls to view. For each one that you choose, you can take a look at the values of the variables there. After browsing through one level, you can return to the debugger() main menu by hitting N. </p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">291</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p318"/>You can arrange to automatically enter the debugger by writing this code:</p>
<p class="calibre1">&gt; options(error=recover)</p>
<p class="calibre1">Note, though, that if you do choose this automatic route, it will whisk you into the debugger, even if you simply have a syntax error (not a useful time to enter the debugger). </p>
<p class="calibre1">To turn off any of this behavior, type the following:</p>
<p class="calibre1">&gt; options(error=NULL)</p>
<p class="calibre1">You’ll see a demonstration of this approach in the next section. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">13.3.6 Extended Example: Two Full Debugging Sessions</b></i></p>
<p class="calibre1">Now that we’ve looked at R’s debugging tools, let’s try using them to find and fix code problems. We’ll begin with a simple example and then move on to a more complicated one. </p>
<p class="calibre1"><b class="calibre3">13.3.6.1 Debugging Finding Runs of Ones</b></p>
<p class="calibre1">First recall our extended example of finding runs of 1s in Chapter 2. Here is a buggy version of the code:</p>
<p class="calibre1">1</p>
<p class="calibre1">findruns &lt;- function(x,k) {</p>
<p class="calibre1">2</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">3</p>
<p class="calibre1">runs &lt;- NULL</p>
<p class="calibre1">4</p>
<p class="calibre1">for (i in 1:(n-k)) {</p>
<p class="calibre1">5</p>
<p class="calibre1">if (all(x[i:i+k-1]==1)) runs &lt;- c(runs,i)</p>
<p class="calibre1">6</p>
<p class="calibre1">}</p>
<p class="calibre1">7</p>
<p class="calibre1">return(runs)</p>
<p class="calibre1">8</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s try it on a small test case:</p>
<p class="calibre1">&gt; source("findruns.R")</p>
<p class="calibre1">&gt; findruns(c(1,0,0,1,1,0,1,1,1),2)</p>
<p class="calibre1">[1] 3 4 6 7</p>
<p class="calibre1">The function was supposed to report runs at indices 4, 7, and 8, but it found some indices that it shouldn’t have and missed some as well. Something is wrong. Let’s enter the debugger and take a look around. </p>
<p class="calibre1">&gt; debug(findruns)</p>
<p class="calibre1">&gt; findruns(c(1,0,0,1,1,0,1,1,1),2)</p>
<p class="calibre1">debugging in: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)</p>
<p class="calibre1">debug at findruns.R#1: {</p>
<p class="calibre1"><b class="calibre3">292</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p319"/>n &lt;- length(x)</p>
<p class="calibre1">runs &lt;- NULL</p>
<p class="calibre1">for (i in 1:(n - k)) {</p>
<p class="calibre1">if (all(x[i:i + k - 1] == 1))</p>
<p class="calibre1">runs &lt;- c(runs, i)</p>
<p class="calibre1">}</p>
<p class="calibre1">return(runs)</p>
<p class="calibre1">}</p>
<p class="calibre1">attr(,"srcfile")</p>
<p class="calibre1">findruns.R</p>
<p class="calibre1">So, according to the principle of confirmation, let’s first make sure our test vector was received correctly:</p>
<p class="calibre1">Browse[2]&gt; x</p>
<p class="calibre1">[1] 1 0 0 1 1 0 1 1 1</p>
<p class="calibre1">So far, so good. Let’s step through the code a bit. We hit n a couple of times to single-step through the code. </p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at findruns.R#2: n &lt;- length(x)</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at findruns.R#3: runs &lt;- NULL</p>
<p class="calibre1">Browse[2]&gt; print(n)</p>
<p class="calibre1">[1] 9</p>
<p class="calibre1">Note that after each single step, R tells us which statement would be the <i class="calibre4">next </i> one to execute. In other words, at the time we executed print(n), we had <i class="calibre4">not </i> yet executed the assignment of NULL to runs. </p>
<p class="calibre1">Note, too, that although normally you can print out the value of a variable by simply typing its name, we could not do so here for our variable n, because n is also the abbreviation for the debugger’s next command. Thus, we needed print(). </p>
<p class="calibre1">At any rate, we found that the length of our test vector was 9, confirming what we knew. Now, let’s single-step some more, getting into the loop. </p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at findruns.R#4: for (i in 1:(n - k + 1)) {</p>
<p class="calibre1">if (all(x[i:i + k - 1] == 1))</p>
<p class="calibre1">runs &lt;- c(runs, i)</p>
<p class="calibre1">}</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at findruns.R#4: i</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at findruns.R#5: if (all(x[i:i + k - 1] == 1)) runs &lt;- c(runs, i) Debugging</p>
<p class="calibre1"><b class="calibre3">293</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p320"/>Since k is 2—that is, we are checking for runs of length 2— the if() statement should be checking the first two elements of x, which are (1,0). </p>
<p class="calibre1">Let’s confirm:</p>
<p class="calibre1">Browse[2]&gt; x[i:i + k - 1]</p>
<p class="calibre1">[1] 0</p>
<p class="calibre1">So, it did  <i class="calibre4">not </i> confirm. Let’s check that we have the correct subscript range, which should be 1:2. Is it? </p>
<p class="calibre1">Browse[2]&gt; i:i + k - 1</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Also wrong. Well, how about i and k? They should be 1 and 2, respectively. Are they? </p>
<p class="calibre1">Browse[2]&gt; i</p>
<p class="calibre1">[1] 1</p>
<p class="calibre1">Browse[2]&gt; k</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Well, those do confirm. Thus, our problem must be with the expression i:i + k - 1. After some thought, we realize there is an operator precedence problem there, and we correct it to i:(i + k - 1). </p>
<p class="calibre1">Is it okay now? </p>
<p class="calibre1">&gt; source("findruns.R")</p>
<p class="calibre1">&gt; findruns(c(1,0,0,1,1,0,1,1,1),2)</p>
<p class="calibre1">[1] 4 7</p>
<p class="calibre1">No, as mentioned, it should be (4,7,8). </p>
<p class="calibre1">Let’s set a breakpoint inside the loop and take a closer look. </p>
<p class="calibre1">&gt; setBreakpoint("findruns.R",5)</p>
<p class="calibre1">/home/nm/findruns.R#5:</p>
<p class="calibre1">findruns step 4,4,2 in &lt;environment: R_GlobalEnv&gt; </p>
<p class="calibre1">&gt; findruns(c(1,0,0,1,1,0,1,1,1),2)</p>
<p class="calibre1">findruns.R#5</p>
<p class="calibre1">Called from: eval(expr, envir, enclos)</p>
<p class="calibre1">Browse[1]&gt; x[i:(i+k-1)]</p>
<p class="calibre1">[1] 1 0</p>
<p class="calibre1">Good, we’re dealing with the first two elements of the vector, so our bug fix is working so far. Let’s look at the second iteration of the loop. </p>
<p class="calibre1">Browse[1]&gt; c</p>
<p class="calibre1">findruns.R#5</p>
<p class="calibre1">Called from: eval(expr, envir, enclos)</p>
<p class="calibre1"><b class="calibre3">294</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p321"/>Browse[1]&gt; i</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Browse[1]&gt; x[i:(i+k-1)]</p>
<p class="calibre1">[1] 0 0</p>
</body></html>