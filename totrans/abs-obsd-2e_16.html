<html><head></head><body><section class="chapter" epub:type="chapter" id="network_servers" title="Chapter&#xA0;16.&#xA0;Network Servers"><div class="titlepage"><div><div><h2 class="title">Chapter 16. Network Servers</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Working behind scenes,</em></span><br/>
<span class="emphasis"><em>taking care of vital things,</em></span><br/>
<span class="emphasis"><em>the daemon is here.</em></span></p></div></div><p><a class="indexterm" id="idx1500"/><span class="inlinemediaobject"><a id="inline_id00017"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> The OpenBSD base system includes several servers to support a network. This chapter covers the following network servers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Small-server handler <code class="literal">inetd</code></p></li><li class="listitem"><p>Printer daemon <code class="literal">lpd</code></p></li><li class="listitem"><p>DHCP daemon <code class="literal">dhcpd</code></p></li><li class="listitem"><p>TFTP daemon <code class="literal">tftpd</code></p></li><li class="listitem"><p>SNMP agent <code class="literal">snmpd</code></p></li><li class="listitem"><p>SSH server <code class="literal">sshd</code></p></li></ul></div><p>This miscellany of small daemons supports the features covered in upcoming chapters.</p><div class="sect1" title="The inetd Small-Server Handler"><div class="titlepage"><div><div><h2 class="title" id="the_inetd_small-server_handler" style="clear: both">The inetd Small-Server Handler</h2></div></div></div><p><a class="indexterm" id="idx1030"/><a class="indexterm" id="idx1503"/><a class="indexterm" id="idx2156"/>The <code class="literal">inetd(8)</code> “super-server” handles incoming network requests for network services that aren’t used very often. After all, many systems don’t have a steady stream of incoming FTP requests, so why have an FTP daemon running constantly? Instead, <code class="literal">inetd</code> listens for incoming network requests, and when an FTP request arrives, it starts the FTP server and feeds it the request. Other common services that frequently (but not always) run through <code class="literal">inetd</code> include ident, finger, and TFTP. Many of these services can also run standalone, if the application usage warrants it.</p><p><code class="literal">inetd</code> also handles functions so small and rarely used that they’re easier to implement within <code class="literal">inetd</code> itself, rather than by calling a separate program. These functions include <code class="literal">discard</code> (which dumps any data received into the bottomless pit of <span class="emphasis"><em>/dev/null</em></span>), <code class="literal">chargen</code> (which pours out a stream of characters), and <code class="literal">echo</code> (which repeats whatever you send to it). Most of these services are not needed on the modern Internet and are disabled by default, but you have access to them if necessary.</p><div class="sect2" title="Configuring inetd"><div class="titlepage"><div><div><h3 class="title" id="configuring_inetd">Configuring inetd</h3></div></div></div><p>You configure <code class="literal">inetd</code> in <span class="emphasis"><em>/etc/inetd.conf</em></span>. Here’s the default <code class="literal">inetd</code> configuration for OpenBSD’s FTP server:</p><a id="I_programlisting16_id480231"/><pre class="programlisting">#<span class="strong"><strong>1</strong></span>ftp <span class="strong"><strong>2</strong></span>stream <span class="strong"><strong>3</strong></span>tcp <span class="strong"><strong>4</strong></span>nowait <span class="strong"><strong>5</strong></span>root <span class="strong"><strong>6</strong></span>/usr/libexec/ftpd <span class="strong"><strong>7</strong></span>ftpd -US
#ftp    stream   tcp6  nowait   root   /usr/libexec/ftpd   ftpd -US</pre><p>The first thing you’ll notice is that these entries are commented out. OpenBSD’s default <code class="literal">inetd</code> offers only the identity server <code class="literal">identd(8)</code> and two time services by default.</p><p>The first field is the service name (<code class="literal">ftp</code> in this case) <span class="strong"><strong>1</strong></span>. The name in this field must match a name in <span class="emphasis"><em>/etc/services</em></span>. The <code class="literal">inetd</code> program uses the <span class="emphasis"><em>services</em></span> file to perform a service lookup to identify which ports it must listen on. To change the TCP/IP port that your FTP server runs on, change the port for FTP in <span class="emphasis"><em>/etc/services</em></span>. (You could also change the first field to use the name of the service that usually runs on the desired port, but I find starting my FTP server entry with the wrong name just gives me a headache.)</p><p>The second field is the socket type (<code class="literal">stream</code> in this case) <span class="strong"><strong>2</strong></span>. This field dictates what sort of connection this is. All TCP connections are of type <code class="literal">stream</code>, and UDP connections are of type <code class="literal">dgram</code>. The <code class="literal">inetd</code> program does support other types of connections, but they’re rarely used. If you’re considering using them, either you’re reading the documentation for a piece of software that needs that type of connection or you’re wrong (probably the latter).</p><p>The third field is the layer 4 network protocol, usually <code class="literal">tcp</code> <span class="strong"><strong>3</strong></span>, <code class="literal">udp</code>, <code class="literal">tcp6</code>, or <code class="literal">udp6</code>. If you want to offer a service over both IPv4 and IPv6, you need a separate entry for each. That’s why there are two otherwise identical configurations for the FTP server. The <code class="literal">inetd</code> program also supports RPC services, which have type <code class="literal">rpc/udp</code> or <code class="literal">rpc/tcp</code>.</p><p><a class="indexterm" id="idx1023"/>The fourth field (<code class="literal">nowait</code> in this case) <span class="strong"><strong>4</strong></span> indicates whether <code class="literal">inetd</code> should wait for the server program to close the connection or just start the program and go away. As a general rule, TCP-based daemons use <code class="literal">nowait</code>, and UDP-based daemons use <code class="literal">wait</code>. (There are rare exceptions.)</p><p>The fifth field (<code class="literal">root</code> in this case) <span class="strong"><strong>5</strong></span> names the user that the server daemon runs as. Many <code class="literal">inetd</code>-using programs must run as root, as they can affect multiple users or accept more specific logins, but some smaller programs have dedicated unprivileged users.</p><p>The sixth field is the full path to the server program <code class="literal">inetd</code> runs when a connection request arrives <span class="strong"><strong>6</strong></span>. Services implemented within <code class="literal">inetd</code> have a path of <code class="literal">internal</code>. The FTP server is at <span class="emphasis"><em>/usr/libexec/ftpd</em></span>.</p><p>Finally, the last field gives the command to start the server program, including any command-line arguments you want. This configuration runs the FTP server with the arguments <code class="literal">-US</code> <span class="strong"><strong>7</strong></span>.</p></div><div class="sect2" title="Restricting Incoming Connections"><div class="titlepage"><div><div><h3 class="title" id="restricting_incoming_connections">Restricting Incoming Connections</h3></div></div></div><p>Script kiddies occasionally try to knock a server off the Internet by sending it more connection requests than it can handle. The <code class="literal">inetd</code> program accepts up to 256 connections per minute per service. If a service receives too many connection requests, <code class="literal">inetd</code> logs the issue and stops answering requests for that service for 10 minutes.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note01"/>Note</h3><p>The IPv4 and IPv6 versions are limited separately, so you could accept 512 FTP connections per second if the requests are evenly divided between protocol families. You can override this globally with a command-line flag when starting <code class="literal">inetd</code>, or you can configure this on a per-service basis.</p></div><p>The <code class="literal">-R</code> flag controls how many connections per minute and per service that <code class="literal">inetd</code> accepts. For example, to accept 1000 requests per minute, you would set the following in <span class="emphasis"><em>/etc/rc.conf.local</em></span>:</p><a id="I_programlisting16_id480531"/><pre class="programlisting">inetd_flags='-R 1000'</pre><p>You can set per-service limits by editing the <code class="literal">wait/nowait</code> field in the service’s <span class="emphasis"><em>inetd.conf</em></span> entry. Add a dot to the <code class="literal">wait</code> or <code class="literal">nowait</code> entry, followed by the number of times per minute you want to allow the service to be called. For example, if you have an FTP server that should be used by only a few of your friends, you could limit the server to 10 requests per minute, as follows:</p><a id="I_programlisting16_id480556"/><pre class="programlisting">ftp   stream  tcp    nowait.10  root    /usr/libexec/ftpd       ftpd -US
ftp   stream  tcp6   nowait.10  root    /usr/libexec/ftpd       ftpd -US</pre><p>Now, if more than 10 connection requests arrive in one minute, <code class="literal">inetd</code> stops servicing FTP requests for ten minutes. An attacker could still use this to knock your FTP service offline, but not to knock the entire server offline. At least this way you get to choose your failure mode and when you reach it.</p></div></div><div class="sect1" title="The lpd Printing Daemon"><div class="titlepage"><div><div><h2 class="title" id="the_lpd_printing_daemon" style="clear: both">The lpd Printing Daemon</h2></div></div></div><p><a class="indexterm" id="idx0700"/><a class="indexterm" id="idx1246"/><a class="indexterm" id="idx1502"/><a class="indexterm" id="idx1852"/><a class="indexterm" id="idx1865"/>OpenBSD includes the <code class="literal">lpd(8)</code> printing daemon common on Unix-like operating systems. The <code class="literal">lpd</code> daemon has options to support thousands of different printers, but getting the right mix of options to support any one specific printer can be a challenge.</p><p>The simplest way to use a printer on OpenBSD is through a PostScript server, and that’s the method I’ll cover here. Many modern printers, particularly the popular multifunction fax/scanner/printer combinations, support PostScript, and you’ll find that every office print server does, too.</p><p>Every printer your system knows about needs an entry in <span class="emphasis"><em>/etc/printcap</em></span>, the printer capability database. This is another <code class="literal">termcap(5)</code>-style configuration file. You don’t need to know everything about the printer to change settings here. This entry just needs the hostname or IP address of the print server and the print server’s name for the printer you want to access. Then use the following template:</p><a id="I_programlisting16_id480658"/><pre class="programlisting">lp|<span class="emphasis"><em>printername</em></span>:\
  :sh=:\
  :rm=<span class="emphasis"><em>printservername</em></span>:\
  :sd=/var/spool/output/<span class="emphasis"><em>printername</em></span>:\
  :lf=/var/log/lpd-errs:\
  :rp=<span class="emphasis"><em>printername</em></span>:</pre><p>The first line gives the printer’s names. Every printer can have any number of names, separated by the pipe (<code class="literal">|</code>) symbol. The default printer on a Unix-like system is named <code class="literal">lp</code>, so be sure that one of the printers has that name attached to it. Another name should be the one used by the print server for this printer (such as <code class="literal">Billing</code>). (Microsoft print servers frequently share one printer under several different names, and each name prints differently, so be sure to use the name that represents the PostScript facility.)</p><p>The other lines list attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>By default, <code class="literal">lpd</code> precedes each print job with a page giving the job name, number, host, and other identifying information. This used to be important when people paid for printing by the page, but unless you’re in an environment with a single, massive printer, this probably wastes paper. The <code class="literal">:sh:=\</code> entry suppresses this page.</p></li><li class="listitem"><p>The <code class="literal">:rm=</code> attribute gives the hostname or IP address of the print server. You must be able to ping the print server by this name.</p></li><li class="listitem"><p>Printing works best if each printer has a unique spool directory, given by the <code class="literal">:sd=</code> attribute. The printer daemon stores documents en route to the print server here. This directory must be owned by the user root and the group daemon.</p></li><li class="listitem"><p>Several printers can share a common log file, shown by the <code class="literal">:lf=</code> attribute.</p></li><li class="listitem"><p>Finally, specify the remote printer name with the <code class="literal">:rp=</code> attribute. This last attribute is the only one that doesn’t end with a backslash.</p></li></ul></div><p><a class="indexterm" id="idx0446"/><a class="indexterm" id="idx0531"/><a class="indexterm" id="idx1188"/><a class="indexterm" id="idx1254"/><a class="indexterm" id="idx1343"/><a class="indexterm" id="idx1501"/>Always end <span class="emphasis"><em>/etc/printcap</em></span> with a newline. I usually use an entire blank line, just to be certain.</p><p>Now that you have a printer configuration, you start <code class="literal">lpd</code> at boot with this <span class="emphasis"><em>rc.conf.local</em></span> entry:</p><a id="I_programlisting16_id480824"/><pre class="programlisting">lpd_flags=""</pre><p>Restart <code class="literal">lpd</code> with <code class="literal">/etc/rc.d/lpd restart</code> any time you edit <span class="emphasis"><em>/etc/printcap</em></span>.</p><p>Finally, view the print queue with <code class="literal">lpq(1)</code>, and watch <span class="emphasis"><em>/var/log/lpd-errs</em></span> for problems.</p></div><div class="sect1" title="The DHCP Server dhcpd"><div class="titlepage"><div><div><h2 class="title" id="the_dhcp_server_dhcpd" style="clear: both">The DHCP Server dhcpd</h2></div></div></div><p>DHCP is the standard method for dynamically configuring clients on an IP network. You might know DHCP as a way to give computers basic IP information, but it can also hand out configuration files for embedded devices such as routers and phones, point diskless machines to their kernel and userland, and much more.</p><p>OpenBSD includes a heavily modified ISC DHCP server, <code class="literal">dhcpd(8)</code>. Here, we’ll cover the basics of using <code class="literal">dhcpd</code> for configuring dynamic clients in a shared Ethernet system. In <a class="xref" href="ch23.html" title="Chapter 23. Customizing OpenBSD">Chapter 23</a>, we’ll discuss the details of using DHCP to configure diskless workstations.</p><div class="sect2" title="How DHCP Works"><div class="titlepage"><div><div><h3 class="title" id="how_dhcp_works">How DHCP Works</h3></div></div></div><p>A client seeking DHCP information broadcasts a request across the local network asking for someone—<span class="emphasis"><em>anyone</em></span>—to give it a network configuration. If your DHCP server is on that Ethernet segment, it answers directly. If it’s on another network segment, the router for that network segment can forward the DHCP request to your server, which will then offer a configuration to the client, maintaining a list of which clients have been assigned which unique configuration values (such as IP addresses). A configuration issued to a client is called a <span class="emphasis"><em>lease</em></span>. Like all leases, DHCP leases expire and must be renewed in order to be valid.</p><p>Clients can request certain DHCP features to support their operations. For example, Microsoft clients request the IP addresses of the network Windows Internet Name Service (WINS) servers, Voice over IP (VoIP) desktop phones request their configuration file, and diskless systems (discussed in <a class="xref" href="ch23.html" title="Chapter 23. Customizing OpenBSD">Chapter 23</a>) ask where to find their kernel and userland. The DHCP server can offer this information, or not.</p><p>The DHCP server uniquely identifies each client by the MAC address of the network card it uses to connect to the network. To find out what information a client received from the DHCP server, get the client’s MAC address and search for it in the <span class="emphasis"><em>/var/db/dhcpd.lease</em></span> file.</p></div><div class="sect2" title="Configuring dhcpd(8)"><div class="titlepage"><div><div><h3 class="title" id="configuring_dhcpd8">Configuring dhcpd(8)</h3></div></div></div><p><a class="indexterm" id="idx0585"/>Configure <code class="literal">dhcpd</code> in <span class="emphasis"><em>/etc/dhcpd.conf</em></span>. The default <span class="emphasis"><em>dhcpd.conf</em></span> file includes a sample configuration suitable for a small office environment, as well as a diskless client sample configuration.</p><p>I’m going to assume that you’re running a single DHCP server on your network, and that this server is authoritative for DHCP services. (OpenBSD’s DHCP server also supports clustering for fault tolerance.)</p><p>Before configuring <code class="literal">dhcpd</code> to configure clients dynamically, you’ll need a few facts about your network:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Domain name</p></li><li class="listitem"><p>DNS servers</p></li><li class="listitem"><p>IP network and netmask</p></li><li class="listitem"><p>Range of IP addresses in the network used for DHCP clients</p></li><li class="listitem"><p>Default router</p></li></ul></div><p>Once you have this information, you can assemble a brief <span class="emphasis"><em>dhcpd.conf</em></span>. Here’s an example:</p><a id="I_programlisting16_id481019"/><pre class="programlisting"><span class="strong"><strong>1</strong></span> option domain-name "blackhelicopters.org";
<span class="strong"><strong>2</strong></span> option domain-name-servers 192.0.2.5 192.0.2.10;
<span class="strong"><strong>3</strong></span> subnet 198.51.100.0 netmask 255.255.255.0 {
<span class="strong"><strong>4</strong></span>     option routers 198.51.100.1;
<span class="strong"><strong>5</strong></span>     range 198.51.100.51 198.51.100.100;
  }</pre><p>All hosts that get their configuration from this host are told that their domain name is <span class="emphasis"><em>blackhelicopters.org</em></span> <span class="strong"><strong>1</strong></span>, and that they should use the name servers 192.0.2.5 and 192.0.2.10 <span class="strong"><strong>2</strong></span>. The client can be configured to ignore or override this DHCP configuration, but you can’t prevent local sysadmins from hanging themselves.</p><p>Each subnet needs its own configuration. Even if you have only one subnet, you must still have a <code class="literal">subnet</code> statement defining the IP network for that subnet so that <code class="literal">dhcpd</code> can determine which clients get which configuration. This example defines the configuration for clients on the network at 198.51.100.0/24 <span class="strong"><strong>3</strong></span>. Everything inside the brackets that follow applies only to hosts on this subnet.</p><p>The <code class="literal">routers</code> option at <span class="strong"><strong>4</strong></span> identifies the default gateway for this network. Because the <code class="literal">dhcpd</code> server won’t let you define additional static routes to feed to clients, your local network router must have proper routes to reach the destination. If you have multiple gateways on your local network, your default router should send an ICMP redirect to the DHCP client to correct its routing. (You don’t unilaterally block ICMP from your firewalls, do you?)</p><p>The <code class="literal">range</code> keyword gives the IP addresses that the DHCP server can assign to clients. In this example, the DHCP server controls the addresses 198.51.100.51 to 198.51.100.100, inclusive <span class="strong"><strong>5</strong></span>. If 52 dynamic clients connect simultaneously, the last client won’t get an address.</p><p>This configuration should get your clients on the network.</p></div><div class="sect2" title="Static IP Address Assignments"><div class="titlepage"><div><div><h3 class="title" id="static_ip_address_assignments">Static IP Address Assignments</h3></div></div></div><p><a class="indexterm" id="idx0445"/><a class="indexterm" id="idx0447"/><a class="indexterm" id="idx0719"/><a class="indexterm" id="idx0864"/>You can tell your DHCP server to assign a specific address to specific hosts by specifying the Ethernet address of the client in the configuration and using a stanza within the <code class="literal">subnet</code> statement. Here’s the earlier DHCP configuration with a static entry added:</p><a id="I_programlisting16_id481193"/><pre class="programlisting"> subnet 198.51.100.0 netmask 255.255.255.0 {
    option routers 198.51.100.1;
    host lucas-desktop {
        hardware ethernet 00:cf:01:b1:9b:07;
        fixed-address 192.0.2.254;
    }
}</pre><p>I’ve found the MAC address of my workstation, and used it to assign a static IP address to that machine. This client machine inherits the default router from the subnet definition, as well as any default DHCP information.</p></div><div class="sect2" title="Enabling dhcpd"><div class="titlepage"><div><div><h3 class="title" id="enabling_dhcpd">Enabling dhcpd</h3></div></div></div><p>Enable <code class="literal">dhcpd</code> in <span class="emphasis"><em>rc.conf.local</em></span>.</p><a id="I_programlisting16_id481226"/><pre class="programlisting">dhcpd_flags=""</pre><p>If you have only one network-facing interface, <code class="literal">dhcpd</code> will automatically listen for DHCP requests on that interface. If you have multiple interfaces, give the interface name as an argument. For example, here’s how to tell <code class="literal">dhcpd</code> to listen for requests only on the interface <code class="literal">fxp1</code>:</p><a id="I_programlisting16_id481246"/><pre class="programlisting">dhcpd_flags="fxp1"</pre><p>The interface name must be the last <code class="literal">dhcpd</code> argument in <span class="emphasis"><em>rc.conf.local</em></span>. If <code class="literal">dhcpd</code> needs to handle several interfaces, the list of interfaces must come after any other arguments in <code class="literal">dhcpd_flags</code>.</p></div><div class="sect2" title="dhcpd and Firewalls"><div class="titlepage"><div><div><h3 class="title" id="dhcpd_and_firewalls">dhcpd and Firewalls</h3></div></div></div><p>The OpenBSD packet filtering system includes <span class="emphasis"><em>tables</em></span>, which are lists of IP addresses that the packet filter applies rules to. Traffic from IP addresses in tables can be blocked, have its bandwidth throttled or prioritized, or be allowed to pass. Each table has a unique name.</p><p>The <code class="literal">dhcpd</code> server can add addresses to packet filter tables, thereby dynamically changing the firewall rules depending on whether an IP address is leased. Here, we’ll look at configuring <code class="literal">dhcpd</code> to give addresses to the packet filter tables. <a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a> discusses how to configure the packet filter to handle addresses from <code class="literal">dhcpd</code>.</p><p>DHCP considers IP addresses in its address pool to be in one of three states: leased, abandoned, or changed. <span class="emphasis"><em>Leased</em></span> addresses are addresses assigned to a host attached to the network. Use <code class="literal">-L</code> to give <code class="literal">dhcpd</code> the name of the packet filter table for leased addresses, and then configure the packet filter to allow or deny those addresses access to the rest of the network.</p><p><a class="indexterm" id="idx0016"/><a class="indexterm" id="idx0453"/><a class="indexterm" id="idx1087"/><a class="indexterm" id="idx1506"/><a class="indexterm" id="idx2245"/><a class="indexterm" id="idx2412"/><a class="indexterm" id="idx2415"/><a class="indexterm" id="idx2458"/><span class="emphasis"><em>Abandoned</em></span> addresses are ones that have been assigned to a host, but that are not currently in use. In practice, that means that if you shut down your laptop, the DHCP server will consider the IP address assigned to it abandoned. The problem with that is that unauthorized users might try to get on the network by taking an unused address from the address pool, without going through the DHCP server. To address this problem, give the packet filter the list of addresses not in use, and give illicit network hosts their own special packet filter rules. Use the <code class="literal">-A</code> argument to tell <code class="literal">dhcpd</code> the name of the packet filter table for abandoned addresses.</p><p>If a host changes its address despite the DHCP server’s configuration instructions, the DHCP server considers the address <span class="emphasis"><em>changed</em></span>, and <code class="literal">dhcpd</code> can add its new address to the changed address table. Use the <code class="literal">-C</code> argument to tell <code class="literal">dhcpd</code> the name of the changed address table. (In <a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a>, we’ll do something interesting with these tables.)</p><a id="I_programlisting16_id481436"/><pre class="programlisting">dhcpd_enable="-A table1 -L table2 -C table3 fxp1"</pre><div class="note" title="Note"><h3 class="title"><a id="ch16note02"/>Note</h3><p>Static IP address assignments do not go into tables. If you assign a static address to a host, you must manually configure firewall rules for that address.</p></div></div></div><div class="sect1" title="The TFTP Daemon tftpd"><div class="titlepage"><div><div><h2 class="title" id="the_tftp_daemon_tftpd" style="clear: both">The TFTP Daemon tftpd</h2></div></div></div><p>The Trivial File Transfer Protocol (TFTP) is used to transfer files across a network. Unlike FTP, TFTP doesn’t include authentication. Anyone who can access the TFTP server can upload or download files from it.</p><p>TFTP is an inflexible protocol. It doesn’t work through network address translation without a proxy or some kind of intelligence within the translation device, and there’s no interactive session as there is with FTP and SFTP. TFTP is most commonly used to copy configuration files and operating system images for embedded devices such as routers.</p><p>OpenBSD uses TFTP to bootstrap diskless systems, as discussed in <a class="xref" href="ch23.html" title="Chapter 23. Customizing OpenBSD">Chapter 23</a>.</p><div class="sect2" title="Specifying a tftpd Directory"><div class="titlepage"><div><div><h3 class="title" id="specifying_a_tftpd_directory">Specifying a tftpd Directory</h3></div></div></div><p>OpenBSD’s <code class="literal">tftpd(8)</code> serves files from a directory, much like a web server. Traditionally, this directory is <span class="emphasis"><em>/tftpboot</em></span>, but don’t follow tradition in this case (you don’t want a TFTP user filling your server’s root partition!). If you use <span class="emphasis"><em>/tftpboot</em></span> on your root partition, make sure that your TFTP clients can’t write to the directory. (You could create a <span class="emphasis"><em>/tftpboot</em></span> partition.) Normally, I create <span class="emphasis"><em>/var/tftpboot</em></span> and tell <code class="literal">tftpd</code> to use that as its root directory. If your fingers are used to typing <code class="literal">/tftpboot</code>, create a symlink.</p><p>To enable <code class="literal">tftpd</code>, set <code class="literal">tftpd_flags</code> in <span class="emphasis"><em>rc.conf.local</em></span> to the TFTP root directory.</p><a id="I_programlisting16_id481539"/><pre class="programlisting">tftpd_flags="/var/tftpboot"</pre><p><a class="indexterm" id="idx1242"/><a class="indexterm" id="idx1753"/><a class="indexterm" id="idx2410"/><a class="indexterm" id="idx2414"/><code class="literal">tftpd</code> <code class="literal">chroot</code>s to the directory you specify, so <code class="literal">tftpd</code> cannot access files outside this directory.</p></div><div class="sect2" title="tftpd and Files"><div class="titlepage"><div><div><h3 class="title" id="tftpd_and_files">tftpd and Files</h3></div></div></div><p>TFTP uses file permissions as an access control method. Because all files on the TFTP server can be read by anyone who can access the server port, TFTP will let clients read files in its root directory only if they are world-readable. To make them world-readable, do this:</p><a id="I_programlisting16_id481605"/><pre class="programlisting"># <span class="strong"><strong>chmod +r /var/tftpboot/<span class="emphasis"><em>filename</em></span></strong></span></pre><p>Similarly, <code class="literal">tftpd</code> will not allow anyone to upload a file unless a file of that name already exists and is world-writable. This means that anyone who knows a file’s name can overwrite it, so make vital files read-only. If an attacker can’t write files, he can’t fill your hard drive.</p><p>To create files via TFTP, so that you can upload files that don’t already exist, run <code class="literal">tftpd</code> with the <code class="literal">-c</code> option.</p><p><code class="literal">tftpd</code> starts as root in order to bind UDP port 69, but it then drops privileges and runs as the unprivileged user <code class="literal">_tftpd</code>. Any files <code class="literal">tftpd</code> created will be owned by its user. As a general rule, the files in the TFTP root directory should not be owned by <code class="literal">_tftpd</code>, in order to make sure that the server cannot affect the files it serves.</p></div><div class="sect2" title="tftpd Logging"><div class="titlepage"><div><div><h3 class="title" id="tftpd_logging">tftpd Logging</h3></div></div></div><p>You should log your TFTP transfers. Use the <code class="literal">-v</code> flag to send the transaction log to <code class="literal">syslogd</code>.</p><a id="I_programlisting16_id481676"/><pre class="programlisting">tftpd_flags="-v /var/tftpboot"</pre><p><code class="literal">tftpd</code> logs uses the FTP facility to log messages to <span class="emphasis"><em>/var/log/daemon</em></span>.</p></div><div class="sect2" title="Testing the TFTP Server"><div class="titlepage"><div><div><h3 class="title" id="testing_the_tftp_server">Testing the TFTP Server</h3></div></div></div><p>Use <code class="literal">tftp(1)</code> to test your TFTP server.</p><a id="I_programlisting16_id481708"/><pre class="programlisting">$ <span class="strong"><strong>tftp caddis</strong></span>
tftp&gt; <span class="strong"><strong>get testboot.iso</strong></span>
Received 20879569 bytes in 10.4 seconds</pre><p>You won’t see any friendly hash marks as you download the file, and you can’t change to another directory or list the contents of the TFTP server. Once the test is complete, use <code class="literal">quit</code> to end your TFTP session.</p><p>After you have a TFTP client and server set up, you’ll be ready to serve diskless OpenBSD machines, router operating system images, or anything else you need.</p></div></div><div class="sect1" title="The SNMP Agent snmpd"><div class="titlepage"><div><div><h2 class="title" id="the_snmp_agent_snmpd" style="clear: both">The SNMP Agent snmpd</h2></div></div></div><p><a class="indexterm" id="idx1366"/><a class="indexterm" id="idx1483"/><a class="indexterm" id="idx1504"/><a class="indexterm" id="idx2165"/>SNMP is the de facto standard for gathering information from network devices. Many different devices from many different vendors support SNMP as a management protocol.</p><p>OpenBSD includes an SNMP agent, <code class="literal">snmpd(8)</code>, which supports all of the usual SNMP functions, and also offers visibility into OpenBSD-specific features such as packet filtering.</p><p>SNMP works according to the standard client/server model. The SNMP client (usually a server performing network management or monitoring) queries the SNMP server (or <span class="emphasis"><em>agent</em></span>) running on a network device. The SNMP agent, <code class="literal">snmpd</code>, gathers information from the local system and returns it to the client.</p><p>In traditional SNMP, an SNMP client with the correct privileges can also request that the SNMP agent modify its device. Most Unix-like operating systems are designed to be configured at the command line and generally don’t accept write requests from SNMP. OpenBSD follows this trend, and we will focus specifically on read-only SNMP.</p><p>In addition to having an SNMP agent answer requests from an SNMP client, the agent can transmit SNMP traps to a <span class="emphasis"><em>trap receiver</em></span> somewhere on the network. SNMP traps are much like <code class="literal">syslogd(8)</code> messages, except that they follow a specific format required by SNMP.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note03"/>Note</h3><p>OpenBSD does not include an SNMP trap receiver. If you need one, check out <code class="literal">snmptrapd</code> in the <code class="literal">net-snmp</code> package.</p></div><div class="sect2" title="SNMP MIBs"><div class="titlepage"><div><div><h3 class="title" id="snmp_mibs">SNMP MIBs</h3></div></div></div><p>SNMP manages information via a Management Information Base (MIB), which is a tree-like structure that contains hierarchical information in ASN.1 format. Each SNMP agent has a list of information it can extract from the local system, arranged in a hierarchical SNMP MIB with very general main categories, such as network, physical, programs, and so on.</p><p>Think of the MIB tree as a well-organized filing cabinet, where individual drawers hold specific information, and files within drawers hold particular facts. Similarly, the uppermost MIB contains a list of MIBs beneath it.</p><div class="sect3" title="MIB References"><div class="titlepage"><div><div><h4 class="title" id="mib_references">MIB References</h4></div></div></div><p>MIBs can be referred to by name or number. For example, here’s a MIB pulled from an OpenBSD test machine:</p><a id="I_programlisting16_id481884"/><pre class="programlisting">interfaces.ifTable.ifEntry.ifDescr.1 = STRING: "em0"</pre><p>The first term in this MIB, <code class="literal">interfaces</code>, tells us that we’re looking at this machine’s network interfaces. If this machine had no interfaces, this category would not even exist (although an OpenBSD machine will always have at least a loopback interface). The <code class="literal">ifTable</code> is the <span class="emphasis"><em>interface table</em></span>, which is a list of all network interfaces on the system. The field <code class="literal">ifEntry</code> shows one particular entry, and <code class="literal">ifDescr</code> means that we’re looking at a description of this interface. This MIB could be expressed as “Interface number 1 on this machine is called <code class="literal">em0</code>.”</p><p><a class="indexterm" id="idx0980"/><a class="indexterm" id="idx1017"/><a class="indexterm" id="idx1340"/><a class="indexterm" id="idx1471"/><a class="indexterm" id="idx1626"/><a class="indexterm" id="idx2163"/>MIBs can also be expressed as numbers, and most SNMP clients do their work natively in numerical MIBs. Your management tool should be able to translate between numbers and names, but just so you’re not terribly surprised, here’s the earlier example in numerical form:</p><a id="I_programlisting16_id481970"/><pre class="programlisting">.1.3.6.1.2.1.2.2.1.2.1 = STRING: "em0"</pre><p>Expressed in words, this MIB has five parts separated by dots. Expressed in numbers, the MIB has 11 parts. Aren’t they supposed to be the same thing? Well, the numerical MIB is longer because it includes the default address .1.3.6.1.2.1, which translates to <span class="emphasis"><em>.iso.org.dod.internet.mgmt.mib-2</em></span>, the standard subset of MIBs used on the Internet. Most SNMP MIBs start with this string, so the management tools no longer bother printing out this name.</p></div><div class="sect3" title="MIB Definitions"><div class="titlepage"><div><div><h4 class="title" id="mib_definitions">MIB Definitions</h4></div></div></div><p>OpenBSD supports two groups of MIBs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The standard host MIBs, which every network management system understands. This information includes network and disk space utilization, software running on the system, and so on.</p></li><li class="listitem"><p>MIBs for OpenBSD-specific functions, such as the packet filter, network failover, bridging, and so on. Most network management systems will not understand the OpenBSD-specific MIBs out of the box, so you’ll want to teach your management system about OpenBSD’s MIBs.</p></li></ul></div><p>MIBs are defined according to a very strict syntax documented in MIB files. For example, <code class="literal">snmpd</code> includes MIB files for the OpenBSD-specific functions in <span class="emphasis"><em>/usr/share/snmp/mibs</em></span>. These files are written in plaintext, in the very stilted and formal ASN.1 syntax. While you can read and interpret them with nothing more than your brain, I highly recommend copying them to your network management workstation and using an SNMP client to examine them.</p><p>MIB browsers interpret MIB files and present them in their full tree-like splendor, complete with definitions of each part of the tree and descriptions of each MIB, taken from the MIB files. Generally speaking, you enter a MIB in the MIB browser, which displays its numerical and word descriptions, and offers the ability to query an SNMP agent for that MIB.</p><p>If you don’t already have a MIB browser on your OpenBSD workstation, use the <code class="literal">mbrowse</code> package. If you don’t want a graphical interface, use the <code class="literal">net-snmp</code> package for a full assortment of command-line SNMP client tools, but be prepared to type some long command lines.</p></div></div><div class="sect2" title="SNMP Security"><div class="titlepage"><div><div><h3 class="title" id="snmp_security">SNMP Security</h3></div></div></div><p><a class="indexterm" id="idx0270"/><a class="indexterm" id="idx0751"/><a class="indexterm" id="idx1873"/><a class="indexterm" id="idx1895"/><a class="indexterm" id="idx2070"/><a class="indexterm" id="idx2166"/>The most common alternate acronym for SNMP is “Security? Not My Problem!” This is unkind, but true. You should use SNMP only behind firewalls or on trusted networks. If you must use SNMP on the naked Internet, employ packet filtering to keep the public from querying your SNMP service. SNMP agents run on UDP port 161, so allow your management hosts access to that port on only your SNMP hosts.</p><p>SNMP provides basic security through <span class="emphasis"><em>communities</em></span>. If you read the SNMP documentation, you’ll see all kinds of explanations of why a community is not the same as a password, but as far as a sysadmin is concerned, a community is a password.</p><p>Most SNMP agents have two communities by default: <code class="literal">public</code> (read-only access) and <code class="literal">private</code> (read-write access). OpenBSD’s <code class="literal">snmpd</code> daemon supports both of these communities by default. One of your first tasks will be to change these community names to something that the whole world doesn’t know. Just like passwords, community names should be hard for intruders to guess and easy for you to remember.</p><p>As you might expect, there have been various versions of SNMP. Version 1 was the first attempt. Version 2c (SNMPv2c) is the more commonly deployed update. Version 3 (SNMPv3) uses encryption to protect data on the wire, and it includes strong authentication. In practice, few vendors actually use it because it’s very complicated. The <code class="literal">snmpd</code> daemon has partial support for SNMPv3. Here, we’ll focus on the completely supported SNMPv2c.</p></div><div class="sect2" title="Configuring snmpd"><div class="titlepage"><div><div><h3 class="title" id="configuring_snmpd">Configuring snmpd</h3></div></div></div><p>Configure <code class="literal">snmpd</code> in <span class="emphasis"><em>/etc/snmpd.conf</em></span>. The configuration format is a series of text statements. Defining new community strings overrides the defaults of <code class="literal">public</code> and <code class="literal">private</code>.</p><p>We start by defining new read-only and read-write community strings, as follows:</p><a id="I_programlisting16_id482181"/><pre class="programlisting">read-only community hansteen
read-write community henning</pre><p>In general, most <code class="literal">snmpd</code> configuration statements look like these two. The <code class="literal">snmpd.conf(5)</code> man page lists all valid <span class="emphasis"><em>snmpd.conf</em></span> configuration statements.</p><p>Every SNMP system is expected to list a contact, a description, and a location, as in this example:</p><a id="I_programlisting16_id482205"/><pre class="programlisting">system contact "mwlucas@michaelwlucas.com"
system description "Web server"
system location "Rack Row 9, Cabinet 6, Under the Meal Replacement Bars"</pre><p>Many network management systems will automatically pull in this information to populate the database. Here, I’ve defined these values for my system. Make similar entries for your system.</p><p><a class="indexterm" id="idx0563"/><a class="indexterm" id="idx0721"/><a class="indexterm" id="idx2167"/><a class="indexterm" id="idx2593"/>The default <span class="emphasis"><em>snmpd.conf</em></span> listens to only the localhost IP address, 127.0.0.1, so outside hosts cannot contact the SNMP daemon. If you want to listen on all available addresses, comment out the lines, like the following, that specify an address.</p><a id="I_programlisting16_id482269"/><pre class="programlisting">listen_addr="127.0.0.1"
listen on $listen_addr</pre><p>Alternatively, you can give an interface IP address to have <code class="literal">snmpd</code> listen to a specific external IP address for those machines with many addresses.</p><a id="I_programlisting16_id482281"/><pre class="programlisting">listen_addr="192.0.2.5"</pre><p>With this configuration, <code class="literal">snmpd</code> can provide information about your system. Enable it in <span class="emphasis"><em>/etc/rc.conf.local</em></span>.</p><a id="I_programlisting16_id482296"/><pre class="programlisting">snmpd_flags=""</pre><p>This will start <code class="literal">snmpd</code> at boot, or you can run <span class="emphasis"><em>/etc/rc.d/snmpd</em></span>.</p></div><div class="sect2" title="Debugging snmpd"><div class="titlepage"><div><div><h3 class="title" id="debugging_snmpd">Debugging snmpd</h3></div></div></div><p>SNMP can be an annoying protocol to debug. For one, because it’s UDP, there’s no easy way to test connectivity to the agent. Also, it runs fairly silently, in that it doesn’t log queries.</p><p>To verify that queries from your network management system are reaching your server, try running <code class="literal">snmpd</code> in verbose mode and with debugging.</p><a id="I_programlisting16_id482335"/><pre class="programlisting"># <span class="strong"><strong>snmpd -vd</strong></span>
startup
snmpe_bind: binding to address 0.0.0.0:161</pre><p>When an SNMP query reaches your server, you should see the server parse the requests. By the same token, <code class="literal">snmpd</code> is very good about telling you why it can’t provide an answer.</p><a id="I_programlisting16_id482353"/><pre class="programlisting">snmpe_parse: 192.0.2.197: wrong read community</pre><p>Errors, like the following, that arise from requests for a nonexistent MIB are a little more difficult to understand.</p><a id="I_programlisting16_id482363"/><pre class="programlisting">snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 1 request 1141724535
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.2041
snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 0 request 1141724536
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.2041
snmpe_parse: 192.0.2.197: invalid varbind element, error index 1</pre><p><a class="indexterm" id="idx0225"/><a class="indexterm" id="idx0264"/><a class="indexterm" id="idx1318"/><a class="indexterm" id="idx1365"/><a class="indexterm" id="idx1682"/><a class="indexterm" id="idx2168"/><a class="indexterm" id="idx2248"/>Here, the MIB request is trying to find the object identifier (OID) <code class="literal">iso.org.dod.internet.private.enterprises.2041</code>, but OpenBSD’s <code class="literal">snmpd</code> does not support that. (It does support <code class="literal">20</code><span class="emphasis"><em><code class="literal">2</code></em></span><code class="literal">1</code>, part of the Net-SNMP MIB.) The SNMP client is requesting an invalid MIB.</p><p>This example shows a successful request and the MIB that <code class="literal">snmpd</code> sends in response:</p><a id="I_programlisting16_id482454"/><pre class="programlisting">snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 1 request 1531862688
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.ucDavis</pre><p>By reading the output carefully, you should be able to see why <code class="literal">snmpd</code> is not answering requests as expected.</p></div><div class="sect2" title="Getting snmpd Information"><div class="titlepage"><div><div><h3 class="title" id="getting_snmpd_information">Getting snmpd Information</h3></div></div></div><p>The most important feature of SNMP is that it lets you read statistics from the operating system and/or software. In addition to the usual features supported by SNMP, such as resource utilization and processes, <code class="literal">snmpd</code> lets you grab OpenBSD-specific system information. You can get information about the packet filter, sensor data, interface memory, and Command Address Redundancy Protocol (CARP). All of this appears under the .1.3.6.1.4.1.30155 MIB, OpenBSD’s private (enterprise) MIB tree.</p><div class="sect3" title="The PF SNMP MIB"><div class="titlepage"><div><div><h4 class="title" id="the_pf_snmp_mib">The PF SNMP MIB</h4></div></div></div><p>The OpenBSD packet filtering feature keeps a lot of statistics, and everything I’ve ever wanted is available through the PF MIB. You’ll find information such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Whether PF is on, and how long has it been running (in hundredths of a second)</p></li><li class="listitem"><p>The number of packets that have matched filter rules</p></li><li class="listitem"><p>The number of fragments and reassembled packets</p></li><li class="listitem"><p>The number of packets dropped because of memory problems, internal packet-filtering problems, overfilling the state tables, and so on</p></li><li class="listitem"><p>The number of states added and removed from the state table</p></li><li class="listitem"><p>The number of timeouts of various protocols</p></li><li class="listitem"><p>The amount of traffic blocked on each interface</p></li><li class="listitem"><p>Packet filtering table usage, number of addresses in each table</p></li></ul></div><p>And there’s more. The PF SNMP MIB gives you more useful visibility into packet filtering. Point your MIB browser at the .1.3.6.1.4.1.30155.1 MIB to see everything.</p></div><div class="sect3" title="Sensors"><div class="titlepage"><div><div><h4 class="title" id="sensors">Sensors</h4></div></div></div><p><a class="indexterm" id="idx0226"/><a class="indexterm" id="idx0243"/><a class="indexterm" id="idx0265"/><a class="indexterm" id="idx0455"/><a class="indexterm" id="idx0535"/><a class="indexterm" id="idx0629"/><a class="indexterm" id="idx0744"/><a class="indexterm" id="idx1346"/><a class="indexterm" id="idx1505"/><a class="indexterm" id="idx2054"/><a class="indexterm" id="idx2083"/><a class="indexterm" id="idx2125"/><a class="indexterm" id="idx2212"/>You can view the same kernel values processed by <code class="literal">sensorsd(8)</code> (see <a class="xref" href="ch15.html" title="Chapter 15. System Maintenance">Chapter 15</a>) via <code class="literal">snmpd</code>, including a list of sensors on this device, the value reported by the sensor, and whether each sensor is in an alarm state. This means you can use <code class="literal">snmpd</code> instead of <code class="literal">sensorsd</code> to monitor your hardware.</p><p>To view sensor data via SNMP, examine the MIB tree .1.3.6.1.4.1.30155.2.</p></div><div class="sect3" title="Interface Memory"><div class="titlepage"><div><div><h4 class="title" id="interface_memory">Interface Memory</h4></div></div></div><p>You can view the amount of memory used by an interface, and how often (if ever) an interface was starved for memory as a result of system load. View the MIB tree .1.3.6.1.4.1.30155.5 to see these values.</p></div><div class="sect3" title="CARP"><div class="titlepage"><div><div><h4 class="title" id="carp">CARP</h4></div></div></div><p>CARP is an OpenBSD invention for sharing one address between two or more machines. It was designed to provide highly available IP services. The <code class="literal">snmpd</code> daemon exposes CARP’s innards, including these items:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The name of each CARP interface</p></li><li class="listitem"><p>CARP configuration values (preemption, <code class="literal">advskew</code>, and so on)</p></li><li class="listitem"><p>The number of IPv4 and IPv6 packets received</p></li><li class="listitem"><p>The number of packets discarded for various reasons</p></li><li class="listitem"><p>The number of times the host has become master</p></li></ul></div><p>To see the CARP MIB tree, view .1.3.6.1.4.1.30155.6.</p></div><div class="sect3" title="Other MIBs"><div class="titlepage"><div><div><h4 class="title" id="other_mibs">Other MIBs</h4></div></div></div><p>The <code class="literal">snmpd</code> daemon is constantly being expanded. According to the MIB files, they’ve reserved space for IPsec and <code class="literal">relayd(8)</code>. Check <span class="emphasis"><em>/usr/share/snmp/mibs</em></span> for additional MIB files, and use your MIB browser to see what your specific version of OpenBSD supports. The OpenBSD team adds MIBs as they’re needed and as code is contributed. If you need IPsec MIBs, feel free to write and submit the code.</p></div></div></div><div class="sect1" title="The SSH Server sshd"><div class="titlepage"><div><div><h2 class="title" id="the_ssh_server_sshd" style="clear: both">The SSH Server sshd</h2></div></div></div><p>Secure Shell (SSH) is a protocol for building encrypted tunnels between hosts. SSH is most commonly used for remote command-line access to a system, but you can use it as a generic wrapper around other protocols or even to build virtual private networks. One common use for SSH is to support secure file transfer protocol service, or SFTP, which doesn’t give you a shell prompt but does encrypt files and authentication information as they cross the network.</p><p><a class="indexterm" id="idx0718"/><a class="indexterm" id="idx0754"/><a class="indexterm" id="idx2214"/><a class="indexterm" id="idx2217"/><a class="indexterm" id="idx2218"/>The OpenBSD project supports OpenSSH, a freely licensed client and server. OpenSSH is the most widely deployed SSH server in the world, with roughly 97 percent market share, and is generally considered the standard SSH server. Entire books have been written about OpenSSH, including mine (<span class="emphasis"><em>SSH Mastery,</em></span> Tilted Windmill Press, 2012).</p><p>OpenBSD includes the OpenSSH server <code class="literal">sshd(8)</code>, the OpenSSH command-line client <code class="literal">ssh(1)</code>, and the SFTP client <code class="literal">sftp(1)</code>. We’ll focus on <code class="literal">sshd</code> here, since you can use any number of SSH clients. The ones I use most commonly are <code class="literal">ssh</code> (for Unix-like systems) and PuTTY (for Windows). For SFTP, I commonly use <code class="literal">sftp</code> (for Unix-like systems) and WinSCP (for Windows).</p><div class="sect2" title="Disabling sshd"><div class="titlepage"><div><div><h3 class="title" id="disabling_sshd">Disabling sshd</h3></div></div></div><p>Unless you specified otherwise during installation, OpenBSD starts <code class="literal">sshd</code> by default. If you don’t want <code class="literal">sshd</code> to run, disable it in <span class="emphasis"><em>/etc/rc.conf.local</em></span>.</p><a id="I_programlisting16_id482934"/><pre class="programlisting">sshd_flags=NO</pre></div><div class="sect2" title="SSH Host Keys"><div class="titlepage"><div><div><h3 class="title" id="ssh_host_keys">SSH Host Keys</h3></div></div></div><p>The first time you start <code class="literal">sshd</code>, OpenBSD creates <span class="emphasis"><em>host keys</em></span> in <span class="emphasis"><em>/etc/ssh</em></span>. These are sets of public and private keys that uniquely identify an SSH server. Each key file includes the word <span class="emphasis"><em>key</em></span> in its name. When your client first connects to the SSH server, it presents a fingerprint summary of the server’s host key. If you tell the client to accept the key, the client will cache the server’s host key. If this key ever changes, the client warns the user that the server’s unique identity has changed, and that the user might be offering his login credentials to a different server. (Anyone who gets copies of the host keys can have another server masquerade as yours.) Be sure to back up your host keys, and protect them from theft.</p></div><div class="sect2" title="sshd Network Options"><div class="titlepage"><div><div><h3 class="title" id="sshd_network_options">sshd Network Options</h3></div></div></div><p>You could change <code class="literal">sshd</code>’s behavior by adding command-line flags, but the most common way to reconfigure <code class="literal">sshd</code> is to edit the files in <span class="emphasis"><em>/etc/ssh</em></span>.</p><p>OpenSSH has many configuration options. The ones that are most commonly changed involve the network settings. You can control the port, IP address, and version of IP <code class="literal">sshd</code> listens to by editing the configuration file <span class="emphasis"><em>/etc/ssh/sshd_config</em></span>. Here’s an example:</p><a id="I_programlisting16_id483011"/><pre class="programlisting">Port 22
AddressFamily any
ListenAddress 0.0.0.0
ListenAddress ::</pre><p><a class="indexterm" id="idx0252"/><a class="indexterm" id="idx0450"/><a class="indexterm" id="idx0970"/><a class="indexterm" id="idx1211"/><a class="indexterm" id="idx2550"/>The <code class="literal">Port</code> keyword specifies the TCP/IP port that <code class="literal">sshd</code> attaches to. The default is TCP port 22.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note04"/>Note</h3><p>Some people recommend using a port other than 22 to avoid password-guessing worms. Far better ways to protect your SSH server are to allow only public-key authentication or use a packet filter to allow logins from only selected hosts or networks.</p></div><p>The <code class="literal">AddressFamily</code> keyword specifies the version of IP that <code class="literal">sshd</code> uses. The default is to use both IPv4 and IPv6, but you can restrict it to a specific protocol with the <code class="literal">inet</code> (IPv4) or <code class="literal">inet6</code> (IPv6) keyword.</p><p>Lastly, you can attach <code class="literal">sshd</code> to a specific IP address with the <code class="literal">ListenAddress</code> option.</p></div><div class="sect2" title="chrooting Users"><div class="titlepage"><div><div><h3 class="title" id="chrooting_users">chrooting Users</h3></div></div></div><p>Organizations commonly need to confine users to a particular directory or subset of directories. For example, many websites allow users command-line access over SSH so that they can edit their files and debug problems more easily, or even just SFTP access to their files. Those users should have access to their own directories, but not to other users’ files, or any other part of the system. One solution is to <code class="literal">chroot</code> the user in his home directory. If you have several users who need to access a shared directory, you can <code class="literal">chroot</code> all of them in that directory.</p><p>Locking users in a directory involves three steps: choosing the directory to lock users into, populating that directory, and configuring <code class="literal">sshd</code> to <code class="literal">chroot</code> those users. To demonstrate, we’ll walk through an example of <code class="literal">chroot</code>ing the user <code class="literal">lasnyder</code> in his home directory, and give him command-line access, so he will be able to access only the programs in his <code class="literal">chroot</code>.</p><div class="sect3" title="Choosing the Directory"><div class="titlepage"><div><div><h4 class="title" id="choosing_the_directory">Choosing the Directory</h4></div></div></div><p>First, specify the <code class="literal">chroot</code> directory with the <code class="literal">ChrootDirectory</code> option.</p><a id="I_programlisting16_id483185"/><pre class="programlisting">ChrootDirectory /home/lasnyder</pre><p>This works well if all of your users need to be locked into the same directory, but if you want users to have their own private directory, or if you want to specify a directory elsewhere on the filesystem, things get more complex.</p><p>OpenSSH supports the <code class="literal">%%</code>, <code class="literal">%h</code>, and <code class="literal">%u</code> macros to represent home directories. If your <code class="literal">chroot</code> directory includes a literal <code class="literal">%</code>, use the <code class="literal">%%</code> macro to represent it. The server in this example has home directories on <span class="emphasis"><em>/disk%3/home</em></span>, so the <code class="literal">%%</code> macro is needed to escape the percent sign.</p><a id="I_programlisting16_id483228"/><pre class="programlisting">ChrootDirectory /disk%%3/home/lasnyder</pre><p><a class="indexterm" id="idx1328"/><a class="indexterm" id="idx2589"/>The <code class="literal">%u</code> macro expands to the user’s username. You could use this to give users a <code class="literal">chroot</code> some place other than their home directory (though I don’t know why you wouldn’t just give them a home directory in the desired location). Here, each user has a directory under <span class="emphasis"><em>/var/www</em></span>:</p><a id="I_programlisting16_id483265"/><pre class="programlisting">ChrootDirectory /var/www/%u</pre><p>Finally, you could lock each user in his home directory with the <code class="literal">%h</code> macro.</p><a id="I_programlisting16_id483276"/><pre class="programlisting">ChrootDirectory %h</pre><p>Wherever you lock a user, you must give that directory everything the user needs to function, since the user won’t be able to leave that directory to get a tool that he might need.</p></div><div class="sect3" title="Populating the chroot"><div class="titlepage"><div><div><h4 class="title" id="populating_the_chroot">Populating the chroot</h4></div></div></div><p>Most programs, such as a shell, require at least a few device nodes, and the user must have a shell program to be able to run one. If a user has only SFTP access, you don’t need to do any special preparation of the <code class="literal">chroot</code>. OpenSSH’s SFTP server includes everything it needs. But if users have shell access, they need basic device nodes and a shell program.</p><p>For our example, to give <code class="literal">lasnyder</code> what he needs, go to the <code class="literal">chroot</code> directory, create a <span class="emphasis"><em>dev</em></span> directory, and then make the standard device nodes using <code class="literal">/dev/MAKEDEV</code>. You can remove the <code class="literal">console</code>, <code class="literal">klog</code>, <code class="literal">kmem</code>, <code class="literal">ksyms</code>, <code class="literal">mem</code>, and <code class="literal">xf86</code> devices.</p><a id="I_programlisting16_id483311"/><pre class="programlisting"># <span class="strong"><strong>cd /home/lasnyder</strong></span>
# <span class="strong"><strong>/dev/MAKEDEV std</strong></span>
# <span class="strong"><strong>rm console klog kmem ksyms mem xf86</strong></span></pre><p>Now we need to get the user a shell. Since programs running inside the shell cannot access any files outside the <code class="literal">chroot</code>, including shared libraries, any shell copied into a <code class="literal">chroot</code> must be statically linked. The included system shells are statically linked, and most shells in the ports tree can be built in static flavors.</p><p>Verify that a shell is statically linked with <code class="literal">file(1)</code>, and then create a <span class="emphasis"><em>bin</em></span> directory inside the <code class="literal">chroot</code> and copy the shell there.</p><a id="I_programlisting16_id483396"/><pre class="programlisting"># <span class="strong"><strong>file /bin/ksh</strong></span>
/bin/ksh: ELF 32-bit LSB executable, Intel 80386, version 1, for OpenBSD, statically linked, stripped
# <span class="strong"><strong>cd /home/lasnyder</strong></span>
# <span class="strong"><strong>mkdir bin</strong></span>
# <span class="strong"><strong>cd bin</strong></span>
# <span class="strong"><strong>cp /bin/ksh .</strong></span></pre><p>Lastly, although a <code class="literal">chroot</code>ed user should not have write access to his own root directory, he needs a real home directory. The user’s home directory in <span class="emphasis"><em>/etc/passwd</em></span> is relative to the <code class="literal">chroot</code>; in other words, if a user’s home directory in <span class="emphasis"><em>/etc/passwd</em></span> is <span class="emphasis"><em>/home/lasnyder</em></span>, and the user is <code class="literal">chroot</code>ed to <span class="emphasis"><em>/home/lasnyder</em></span>, his personal files and dotfiles actually go in <span class="emphasis"><em>/home/lasnyder/home/lasnyder</em></span>.</p><a id="I_programlisting16_id483465"/><pre class="programlisting"># <span class="strong"><strong>chown root:wheel /home/lasnyder</strong></span>
# <span class="strong"><strong>mkdir -p /home/lasnyder/home/lasnyder</strong></span>
# <span class="strong"><strong>chown lasnyder:lasnyder /home/lasnyder/home/lasnyder</strong></span></pre><p><a class="indexterm" id="idx2219"/>The user now has a command-line friendly jail cell on the system. Now we need to tell <code class="literal">sshd</code> to lock the user in it.</p></div><div class="sect3" title="chrooting Specific Users"><div class="titlepage"><div><div><h4 class="title" id="chrooting_specific_users">chrooting Specific Users</h4></div></div></div><p>Applying this <code class="literal">chroot</code> strategy to all of your users probably isn’t advisable—if nothing else, your sysadmins need unfettered system access to perform maintenance.</p><p>To tell <code class="literal">sshd</code> to <code class="literal">chroot</code> specific users, either by name or by group, use the <code class="literal">Match</code> keyword at the end of <span class="emphasis"><em>sshd_config</em></span>. Match lets you change <code class="literal">sshd</code>’s default behavior based on factors such as user and client IP address. (<code class="literal">Match</code> has many more functions; see <code class="literal">sshd_config(5)</code> for examples.)</p><p>For example, if you wanted to <code class="literal">chroot</code> only the user <code class="literal">lasnyder</code>, you could use <code class="literal">Match</code> to specify his username. Early in the configuration, you would have a <code class="literal">ChrootDirectory</code> statement that turns off <code class="literal">chroot</code> for most users. Then, at the end of the configuration, you would change the setting based on matching that username.</p><a id="I_programlisting16_id483575"/><pre class="programlisting">…
ChrootDirectory none
…
Match User lasnyder
      ChrootDirectory %h</pre><p>You could also <code class="literal">chroot</code> all users in a group.</p><a id="I_programlisting16_id483587"/><pre class="programlisting">…
ChrootDirectory none
…
Match Group webcustomers
      ChrootDirectory %h</pre><p>If you have multiple <code class="literal">Match</code> terms, separate them with commas.</p><a id="I_programlisting16_id483598"/><pre class="programlisting">…
ChrootDirectory none
…
Match User lasnyder, jgballard, pkdick
      ChrootDirectory %h</pre><p>Or, if most of your users are <code class="literal">chroot</code>ed, reverse the default and specifically de<code class="literal">chroot</code> your sysadmins.</p><a id="I_programlisting16_id483614"/><pre class="programlisting">…
ChrootDirectory %h
…
Match Group wheel
      ChrootDirectory none</pre><p>With careful configuration, you can restrict access to only the desired users.</p><p>SSH can do a whole lot more, such as securely eliminate passwords from your network. It’s worth your time to fully master this protocol.</p><p>OpenBSD’s built-in services can help you hold your network together, and they provide all kinds of useful support infrastructure. Now that you know how to configure some of these built-in programs, let’s see how to use OpenBSD as a desktop.</p></div></div></div></section></body></html>