<html><head></head><body><section class="chapter" epub:type="chapter" id="customizing_openbsd" title="Chapter&#xA0;23.&#xA0;Customizing OpenBSD"><div class="titlepage"><div><div><h2 class="title">Chapter 23. Customizing OpenBSD</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Customize installs</em></span><br/>
<span class="emphasis"><em>with files and DHCP,</em></span><br/>
<span class="emphasis"><em>then run without disk.</em></span></p></div></div><p><a class="indexterm" id="idx1594"/><span class="inlinemediaobject"><a id="inline_id00024"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> This chapter covers different ways to use OpenBSD to customize itself, as well as how to install OpenBSD in nonstandard situations and debug problems with your system. The first task we’ll address is diskless installation. Diskless systems are usually used to install OpenBSD without attaching any installation media, but they can also be used to run a system without a hard drive. Next, we’ll create a USB flash drive for use as OpenBSD installation media. Finally, we’ll cover various ways to customize the OpenBSD installation and upgrade processes.</p><p>All of these tasks assume that you already have an OpenBSD machine running the version you want to customize. You can accomplish some of these tasks using a virtual machine, as long as the virtual machine software has the necessary support. Because virtualization is such a common choice, let’s tackle it first.</p><div class="sect1" title="Virtualizing OpenBSD"><div class="titlepage"><div><div><h2 class="title" id="virtualizing_openbsd" style="clear: both">Virtualizing OpenBSD</h2></div></div></div><p><a class="indexterm" id="idx0486"/><a class="indexterm" id="idx1181"/><a class="indexterm" id="idx1371"/><a class="indexterm" id="idx1595"/><a class="indexterm" id="idx1600"/><a class="indexterm" id="idx1639"/><a class="indexterm" id="idx1858"/><a class="indexterm" id="idx1898"/><a class="indexterm" id="idx2566"/><a class="indexterm" id="idx2615"/><a class="indexterm" id="idx2618"/><a class="indexterm" id="idx2620"/><a class="indexterm" id="idx2629"/>The OpenBSD developers are pretty clear on virtualization. OpenBSD is written for real hardware. Virtual hardware is not real hardware. While it can be very similar, it’s not exactly the same.</p><p>This approach has a number of implications, the most problematic of which is that not all virtualization software can run OpenBSD. As I write this, Oracle’s VirtualBox can’t cleanly run either i386 or amd64 OpenBSD. (Some people report being able to boot some versions of VirtualBox and/or OpenBSD, but OpenBSD software crashes all over the place.) This is not an OpenBSD bug. VirtualBox doesn’t sufficiently emulate real hardware.</p><p>That said, OpenBSD does run well on some virtual machines. VMware works well enough that OpenBSD includes specific drivers for VMware integration, including a VMware Tools driver in the kernel. KVM virtualization also works, although KVM requires some tweaks depending on the exact combination of KVM and OpenBSD you’re using. Microsoft’s virtualization mostly works, although Virtual PC has some commercially motivated limitations.</p><p>The main problem with virtualization is that a compromise of the virtualization platform automatically gives an intruder hardware-level access to all virtual machines, and OpenBSD cannot possibly secure you against that kind of attack. In fact, no operating system can. And it does you no good to run your database on OpenBSD when any script kiddie can compromise the underlying virtualization server.</p><p>In my experience, OpenBSD virtual machines are excellent for experimentation and reference. I used them to document the installation process for this book, and I always test software configurations on virtual machines before rolling them out to production. (The real benefit of virtualization might be that there’s no longer any excuse for not testing changes.) But when I want a server that’s actually secure, I put OpenBSD on real hardware.</p><div class="note" title="Note"><h3 class="title"><a id="ch23note01"/>Note</h3><p>If you want to run virtual machines on OpenBSD, you can find <code class="literal">qemu</code>, <code class="literal">bochs</code>, <code class="literal">dosbox</code>, and other packages in the packages collection. Check <span class="emphasis"><em>/usr/ports/emulators</em></span> for other options.</p></div></div><div class="sect1" title="Diskless Installation"><div class="titlepage"><div><div><h2 class="title" id="diskless_installation" style="clear: both">Diskless Installation</h2></div></div></div><p>Booting a blank system into the OpenBSD installer without using local media can save you time and energy. A lot of modern hardware doesn’t come with CD or floppy drives. Of course, you could temporarily add a CD drive, but if you have a whole bunch of OpenBSD machines to install, that’s just an annoyance.</p><p>You can also use network booting to boot OpenBSD on hardware that lacks an installed operating system, or with a different operating system that you plan to overwrite. This process is called <span class="emphasis"><em>pxebooting</em></span>, or <span class="emphasis"><em>diskless</em></span>, operation. Diskless systems can have disks—they just don’t use them to boot the operating system.</p><p><a class="indexterm" id="idx0050"/><a class="indexterm" id="idx0949"/><a class="indexterm" id="idx1001"/>If you’ve never worked with diskless systems before, your first attempts will probably give you a headache. Setting up your first diskless environment can be tricky, and will teach you all sorts of things you didn’t know about your operating system and hardware. But test everything along the way, read the error messages carefully, and soon you’ll wonder why you thought this was hard.</p><div class="note" title="Note"><h3 class="title"><a id="ch23note02"/>Note</h3><p>I’ll cover diskless installations on amd64 and i386 hardware. Other platforms have different requirements that may be very different. Read the <code class="literal">diskless(8)</code> man page for your particular architecture to get an overview of your platform.</p></div><p>Diskless systems work because a computer doesn’t need a hard disk to run. It needs an operating system. The easiest way to store a computer’s operating system is on the local hard drive, but a sufficiently smart network card can use information provided by DHCP to find an initial boot loader.</p><p>All amd64 and modern i386 hardware use Intel’s Preboot Execution Environment (PXE, pronounced “pixie”). The DHCP server tells the network card the name of a file and the IP address where the file can be found, and the server fetches the file via TFTP. This file is usually called <span class="emphasis"><em>pxeboot</em></span>, but <span class="emphasis"><em>pxeboot</em></span> files can vary widely among operating systems. A <span class="emphasis"><em>pxeboot</em></span> file for OpenBSD probably won’t boot a FreeBSD system, let alone anything from Microsoft. It’s specific to each operating system.</p><p>Once the computer has loaded <span class="emphasis"><em>pxeboot</em></span>, it goes back to the TFTP server to look for the appropriate kernel. An OpenBSD <span class="emphasis"><em>pxeboot</em></span> looks for a file called <span class="emphasis"><em>bsd</em></span>, assumes that it’s a kernel, loads the kernel into memory, and boots it. To install OpenBSD, you’ll load the install kernel file <span class="emphasis"><em>bsd.rd</em></span> instead, which you can do automatically.</p><div class="sect2" title="Diskless Hardware"><div class="titlepage"><div><div><h3 class="title" id="diskless_hardware">Diskless Hardware</h3></div></div></div><p>OpenBSD systems installed over diskless systems must have enough smarts to find their boot loader and operating system over the network or they won’t boot. Any machine built in the past several years uses PXE.</p><p>You’ve probably seen a computer try to boot from the network more than once, and for most people, those BIOS messages are just an annoyance that they keep forgetting to disable. For diskless installation, you need to make sure that feature is on.</p><p>To enable PXE, boot the hardware and go into the BIOS setup. Somewhere in the BIOS, you should find an option to set the device boot order. If the machine supports PXE, one of those options will be to boot over a network. Enable that option and see if it works. While you’re in the BIOS, make a note of the MAC address of your network card. Your DHCP server will need it. If your BIOS uses the Unified Extensible Firmware Interface (UEFI) by default, disable that.</p><p>Save your changes and exit. Your hardware should now be prepared. Let’s ready the server.</p></div><div class="sect2" title="DHCP Server Setup"><div class="titlepage"><div><div><h3 class="title" id="dhcp_server_setup">DHCP Server Setup</h3></div></div></div><p><a class="indexterm" id="idx0443"/><a class="indexterm" id="idx0487"/>DHCP is not just a way to hand out IP addresses and network configurations. A DHCP server can tell network-aware phones where to find their configuration, server hardware where to find its operating system, printers where to find their print server, and so on. Diskless installations use DHCP to feed diskless servers the location of the <span class="emphasis"><em>pxeboot</em></span> file.</p><div class="sect3" title="Per-Host or Per-Network Configuration"><div class="titlepage"><div><div><h4 class="title" id="per-host_or_per-network_configuration">Per-Host or Per-Network Configuration</h4></div></div></div><p>DHCP expects to configure hosts either by the network or by the host. When a DHCP server receives a DHCP request, it knows the address of the network that the host is on and the host’s MAC address. The DHCP server must decide which configuration to give the host based on this information. This means you can configure your DHCP server so that any host on a given network is told to install OpenBSD, or you can give it the MAC address of the machine you’re going to install and tell the DHCP server to start the installation only on that machine.</p><p>Because I install machines frequently, I usually set up a small VLAN where any machine plugged onto the network is told to install OpenBSD. That way, workers who plug their laptops into random Ethernet cables in my office get a free operating system upgrade. If you only occasionally install machines, and have control over the DHCP server, it’s pretty easy to configure the DHCP server to tell a host with a specific MAC address to install OpenBSD.</p><p>The DHCP server needs to tell the client the location of a PXE boot file, which gives the client just enough brains to find a bootable kernel. This is just like the on-disk boot loader, except that the PXE boot file talks to the network. OpenBSD’s i386 and amd64 platforms include the file <span class="emphasis"><em>/usr/mdec/pxeboot</em></span> for just this purpose.</p><p>Give the name of the PXE boot file with the <code class="literal">filename</code> option, and then use the <code class="literal">next-server</code> option to specify the IP address of the TFTP server where the client can get the file. This example tells DHCP clients to load the file <span class="emphasis"><em>pxeboot</em></span> from the server at 192.0.2.34:</p><a id="I_programlisting23_id506477"/><pre class="programlisting">filename "pxeboot";
next-server 192.0.2.34;</pre><p>Place these statements according to whether you have an installation network or your DHCP server is set for a specific MAC address.</p></div><div class="sect3" title="Per-Network Configuration"><div class="titlepage"><div><div><h4 class="title" id="per-network_configuration">Per-Network Configuration</h4></div></div></div><p>If you want all the hosts on your network to receive the OpenBSD installation PXE boot file, put the <code class="literal">filename</code> and <code class="literal">next-server</code> options in the <code class="literal">subnet</code> stanza, like this:</p><a id="I_programlisting23_id506510"/><pre class="programlisting">option  domain-name "michaelwlucas.com";
option  domain-name-servers 192.0.2.1;
subnet 192.0.2.0 netmask 255.255.255.0 {
        option routers 192.0.2.1;
        range 192.0.2.10 192.0.2.15;
        filename "pxeboot";
        next-server 192.0.2.34;
}</pre><p><a class="indexterm" id="idx0490"/><a class="indexterm" id="idx2413"/><a class="indexterm" id="idx2560"/>Any host on this network that makes a DHCP request at boot will learn where to get the PXE boot file.</p></div><div class="sect3" title="Per-Machine Configuration"><div class="titlepage"><div><div><h4 class="title" id="per-machine_configuration">Per-Machine Configuration</h4></div></div></div><p>If you’ve hard-coded a machine’s MAC address into your DHCP configuration, as discussed in <a class="xref" href="ch16.html" title="Chapter 16. Network Servers">Chapter 16</a>, you can feed the PXE boot information to that host.</p><a id="I_programlisting23_id506567"/><pre class="programlisting">subnet 192.0.2.0 netmask 255.255.255.0 {
…
    host installationtarget {
        hardware ethernet 02:03:04:05:06:07;
        filename "pxeboot";
        next-server 192.0.2.34; }
    }</pre><p>Machines on this subnet that make a PXE request at boot will get the location of the PXE boot file only if they have MAC address 02:03:04:05:06:07.</p><p>Decide how you want your DHCP server to behave and make similar configuration changes.</p><p>Now let’s look at the TFTP server.</p></div></div><div class="sect2" title="TFTP Server Setup"><div class="titlepage"><div><div><h3 class="title" id="tftp_server_setup">TFTP Server Setup</h3></div></div></div><p>The next task is to make the OpenBSD-specific boot files available on your TFTP server. As a minimum, you need the <span class="emphasis"><em>pxeboot</em></span> file and a kernel, but adding a <span class="emphasis"><em>boot.conf</em></span> file will simplify your life.</p><p>OpenBSD includes an architecture-specific <span class="emphasis"><em>pxeboot</em></span> file in <span class="emphasis"><em>/usr/mdec/</em></span>. If you’re installing an i386 machine, grab this file and <span class="emphasis"><em>/bsd.rd</em></span> from an existing i386 installation. If you’re installing amd64 hardware, get <span class="emphasis"><em>pxeboot</em></span> and <span class="emphasis"><em>/bsd.rd</em></span> from an existing amd64 system. Copy them to the TFTP server root directory, and verify that they’re world-readable.</p><p><span class="emphasis"><em>pxeboot</em></span> tells the machine to look for the standard kernel <span class="emphasis"><em>/bsd</em></span>, not the installation kernel <span class="emphasis"><em>/bsd.rd</em></span>. When <span class="emphasis"><em>pxeboot</em></span> finishes loading, it looks exactly like the standard OpenBSD boot loader. You could interrupt the boot, as described in <a class="xref" href="ch05.html" title="Chapter 5. The Boot Process">Chapter 5</a>, and choose a different kernel, but <span class="emphasis"><em>pxeboot</em></span> also recognizes <span class="emphasis"><em>/etc/boot.conf</em></span>.</p><p>To tell <span class="emphasis"><em>pxeboot</em></span> to load a different kernel, create an <span class="emphasis"><em>etc</em></span> directory in your TFTP server’s root directory, and then create the file <span class="emphasis"><em>boot.conf</em></span> inside that. This new <span class="emphasis"><em>boot.conf</em></span> file has exactly the same syntax as <span class="emphasis"><em>/etc/boot.conf</em></span>, so you can do a one-line entry like this:</p><a id="I_programlisting23_id506684"/><pre class="programlisting">boot bsd.rd</pre><p>You can include additional boot options, such as setting a serial console.</p></div><div class="sect2" title="Completing Diskless Installation"><div class="titlepage"><div><div><h3 class="title" id="completing_diskless_installation">Completing Diskless Installation</h3></div></div></div><p><a class="indexterm" id="idx0187"/><a class="indexterm" id="idx0489"/><a class="indexterm" id="idx0596"/><a class="indexterm" id="idx1597"/><a class="indexterm" id="idx1921"/><a class="indexterm" id="idx1967"/>Once you have DHCP and TFTP, power on the installation target. You should see the network card make a DHCP request, get an IP address, and grab <span class="emphasis"><em>pxeboot</em></span> via TFTP. You should then see the OpenBSD boot loader load the installation <span class="emphasis"><em>bsd.rd</em></span>. Finally, you should get the OpenBSD install script.</p><p>If you don’t get the installer, take a step back. Does the network card get an address from DHCP? If not, check your wiring and DHCP server configuration. If you get an IP address, but can’t fetch <span class="emphasis"><em>pxeboot</em></span>, check that you put the <code class="literal">filename</code> and <code class="literal">next-server</code> statements in the correct part of your DHCP configuration, and verify that you don’t have a packet filter blocking access to the TFTP server. Try to fetch those files from a different TFTP client to make sure that the TFTP server works. If the installation target partially boots OpenBSD, but doesn’t activate the installer, make sure you have an <span class="emphasis"><em>etc/boot.conf</em></span> entry pointing the client at <span class="emphasis"><em>bsd.rd</em></span> rather than <span class="emphasis"><em>bsd</em></span>.</p><p>At this point, you should be able to install OpenBSD normally, as described in <a class="xref" href="ch02.html" title="Chapter 2. Installation Preparations">Chapter 2</a> and <a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a>. But what if you want to run a full OpenBSD system without a hard drive? That’s where diskless operation comes in.</p></div></div><div class="sect1" title="Running Diskless"><div class="titlepage"><div><div><h2 class="title" id="running_diskless" style="clear: both">Running Diskless</h2></div></div></div><p>If you manage many computers, you probably understand that moving parts cause trouble. Spinning hard drives, in particular, are just a very bad idea.</p><p>Try this: If you have a roomful of identical machines, try simplifying maintenance by running them without hard drives. Each machine in this group will use a root directory and filesystem mounted via NFS rather than stored locally. You’ll still need data storage, but you can use a central high-availability disk array, flash drives, or some other mechanism with better reliability than lowest-common-denominator hard drives.</p><p>You can extend the diskless installation process to run OpenBSD in full multiuser mode without a local hard drive. Your server will need three additional services to support fully diskless clients: <code class="literal">rarpd(8)</code>, <code class="literal">bootparamd(8)</code>, and NFS. (Only diskless clients need <code class="literal">rarpd</code> and <code class="literal">bootparamd</code>.)</p><div class="sect2" title="Using rarpd(8) for Reverse ARP"><div class="titlepage"><div><div><h3 class="title" id="using_rarpd8_for_reverse_arp">Using rarpd(8) for Reverse ARP</h3></div></div></div><p>In a standard ARP request, a client knows an IP address and wants to get the corresponding MAC address. For reverse ARP, a client knows a MAC address and wants to know the corresponding IP address. OpenBSD needs to get reverse ARP during the diskless boot process, and it uses <code class="literal">rarpd(8)</code> to provide reverse ARP services to other hosts.</p><p><code class="literal">rarpd</code> uses <span class="emphasis"><em>/etc/ethers</em></span> as a table of Ethernet addresses and hostnames. Each diskless client needs an <span class="emphasis"><em>/etc/ethers</em></span> entry much like this:</p><a id="I_programlisting23_id506887"/><pre class="programlisting">00:50:56:00:01:01       gill.blackhelicopters.org</pre><p>This entry means that the host with MAC address 00:50:56:00:01:01 has the hostname <span class="emphasis"><em>gill.blackhelicopters.org</em></span>. The <code class="literal">rarpd</code> server must be able to resolve the hostname to an IP address, either in DNS or in <span class="emphasis"><em>/etc/hosts</em></span>.</p><p><a class="indexterm" id="idx0574"/><a class="indexterm" id="idx0599"/><a class="indexterm" id="idx1534"/><a class="indexterm" id="idx2541"/>Now decide which network interfaces you want to run <code class="literal">rarpd</code> on. If your server has only one network interface, that’s the one to use. If you have multiple network interfaces, however, it might make sense to listen on only a single interface.</p><p>To use a specific interface, use the interface name as a command-line argument; otherwise, use <code class="literal">-a</code> to listen on all network interfaces. For example, this <span class="emphasis"><em>rc.conf.local</em></span> entry tells <code class="literal">rarpd</code> to listen on only interface <code class="literal">em0</code>:</p><a id="I_programlisting23_id506970"/><pre class="programlisting">rarpd_flags="em0"</pre><p>Start <code class="literal">rarpd</code> with <span class="emphasis"><em>/etc/rc.d/rarpd</em></span>, and go on to <code class="literal">bootparamd</code>.</p></div><div class="sect2" title="Running bootparamd(8)"><div class="titlepage"><div><div><h3 class="title" id="running_bootparamd8">Running bootparamd(8)</h3></div></div></div><p>The boot parameter daemon <code class="literal">bootparamd</code> tells a diskless OpenBSD machine where to find its root filesystem. When a boot parameter request arrives at the server, <code class="literal">bootparamd</code> checks the file <span class="emphasis"><em>/etc/bootparams</em></span> for a matching configuration and returns that to the client.</p><p>Entries in <span class="emphasis"><em>/etc/bootparams</em></span> give a hostname, followed by the string <code class="literal">root=</code>, an NFS server, and the directory where the client’s root directory is stored.</p><a id="I_programlisting23_id507026"/><pre class="programlisting">gill.blackhelicopters.org root=192.0.2.34:/var/diskless/client1</pre><p>In this example, the host <span class="emphasis"><em>gill.blackhelicopters.org</em></span> will use an NFS root directory from a server at 192.0.2.34, in the directory <span class="emphasis"><em>/var/diskless/client1</em></span>.</p><p>For almost all environments, you can run <code class="literal">bootparamd</code> without any command-line options. Enable it in <span class="emphasis"><em>rc.conf.local</em></span> like so:</p><a id="I_programlisting23_id507053"/><pre class="programlisting">bootparamd_flags=""</pre><p>Start <code class="literal">bootparamd</code>. Now it’s time to deal with your NFS server.</p></div><div class="sect2" title="Setting Up the NFS Root Directory"><div class="titlepage"><div><div><h3 class="title" id="setting_up_the_nfs_root_directory">Setting Up the NFS Root Directory</h3></div></div></div><p>A multiuser OpenBSD system needs a userland. Without a local disk, you’ll need to create an OpenBSD userland. It is possible to export the NFS server’s root directory for use as the diskless client’s root directory, but this isn’t merely insecure, it’s also a good way to damage the NFS server itself. Create a separate userland for your diskless machine.</p><div class="sect3" title="Exporting the Root Directory"><div class="titlepage"><div><div><h4 class="title" id="exporting_the_root_directory">Exporting the Root Directory</h4></div></div></div><p>You must export the userland’s root directory to the diskless machine. For example, here’s an <span class="emphasis"><em>/etc/exports</em></span> line that shares the directory <span class="emphasis"><em>/var/diskless/client1</em></span> to the IP address 192.0.2.37:</p><a id="I_programlisting23_id507103"/><pre class="programlisting">/var/diskless/client1 -maproot=root 192.0.2.37</pre><p>Note the <code class="literal">-maproot</code> option here. The diskless client will expect to be able to write and own files as the root user. This <code class="literal">-maproot</code> entry maps UID 0 (root) on the client to the root account on the NFS server. You can also set up a separate user for the diskless client’s root account, map the client’s root account to that new account, and change the ownership of all files in the diskless userland to that root account. As this is your first diskless host, however, we’ll start off basic.</p></div><div class="sect3" title="Populating the Diskless Userland"><div class="titlepage"><div><div><h4 class="title" id="populating_the_diskless_userland">Populating the Diskless Userland</h4></div></div></div><p><a class="indexterm" id="idx0108"/><a class="indexterm" id="idx0116"/><a class="indexterm" id="idx0294"/><a class="indexterm" id="idx0488"/><a class="indexterm" id="idx0779"/><a class="indexterm" id="idx1129"/><a class="indexterm" id="idx2542"/><a class="indexterm" id="idx2621"/>The easy way to install a minimal userland is to extract the <span class="emphasis"><em>etcXX.tgz</em></span> and <span class="emphasis"><em>baseXX.tgz</em></span> file sets from your chosen OpenBSD release into the NFS root directory. In the following example, I’ve copied these file sets into <span class="emphasis"><em>/tmp</em></span>, and I’m using them to create a userland in <span class="emphasis"><em>/var/diskless/client1</em></span>.</p><a id="I_programlisting23_id507215"/><pre class="programlisting"># <span class="strong"><strong>cd /var/diskless/client1</strong></span>
# <span class="strong"><strong>tar -xzpf /tmp/etc53.tgz</strong></span>
# <span class="strong"><strong>tar -xzpf /tmp/base53.tgz</strong></span></pre><p>Note the use of the <code class="literal">-p</code> flag in the <code class="literal">tar</code> command, preserving the original permissions on extracted files.</p><p>The diskless client also needs device nodes. Go into the new userland’s <span class="emphasis"><em>dev</em></span> directory and create them.</p><a id="I_programlisting23_id507255"/><pre class="programlisting"># <span class="strong"><strong>cd dev</strong></span>
# <span class="strong"><strong>./MAKEDEV all</strong></span></pre><p>While <code class="literal">bootparamd</code> told the kernel where to find the root of the filesystem, userland programs expect to read <span class="emphasis"><em>/etc/fstab</em></span> for that information. Create an <span class="emphasis"><em>/etc/fstab</em></span> file that points the root directory to your NFS share.</p><a id="I_programlisting23_id507285"/><pre class="programlisting">192.0.2.34:/var/diskless/client1 / nfs rw 0 0</pre><p>You can also add any other NFS-mounted directories you desire here.</p><p>This should be everything you need.</p></div></div><div class="sect2" title="Power On!"><div class="titlepage"><div><div><h3 class="title" id="power_on">Power On!</h3></div></div></div><p>Once you have a basic userland, device nodes, and a filesystem table, you can power on your diskless node, and it should boot. If it doesn’t boot to a login prompt, read the console error messages. Usually, they’re pretty clear.</p><p>Because you’ve bypassed the OpenBSD installer, there are no root password or user accounts yet. Immediately, log in as root and change the root password, and then set up a regular user account.</p><p>For your first diskless setup, once you have a working userland, back it up right away. Even a tar file containing the entire userland will prove useful. You’ll muck up the diskless userland more than once as you’re trying to get things working exactly as you wish, and being able to blow the entire userland away and restore it from the backup file is invaluable.</p><p>Once you have a basic system working, expand it. Add additional file sets as needed, set up more users, add packages, and deploy for your users.</p><p>Congratulations, you’re now on the cutting edge of OpenBSD users.</p></div></div><div class="sect1" title="USB Installation Media"><div class="titlepage"><div><div><h2 class="title" id="usb_installation_media" style="clear: both">USB Installation Media</h2></div></div></div><p><a class="indexterm" id="idx1599"/><a class="indexterm" id="idx2007"/><a class="indexterm" id="idx2487"/><a class="indexterm" id="idx2513"/>For many people, burning a CD to install an operating system seems like a waste. They prefer to write an image to a USB flash drive and install from that. OpenBSD doesn’t provide such an image, but if you’re willing to do some extra work, you can create a bootable USB device that you can use to install on your target hardware.</p><p>The official recommendation is to install OpenBSD on the USB device, copy <span class="emphasis"><em>bsd.rd</em></span> and the file sets to that device, and use that to install your new hardware. The OpenBSD installer lets you choose the target hard drive. You select the USB device in the installer, and OpenBSD installs to the USB just as it would any other data-storage device. But how do you install OpenBSD on the USB device without burning a CD in the first place? There are a few ways around this, including a couple of approaches already covered in this chapter.</p><div class="sect2" title="Using a Virtual Machine"><div class="titlepage"><div><div><h3 class="title" id="using_a_virtual_machine">Using a Virtual Machine</h3></div></div></div><p>Your first choice is to perform the USB installation in a virtual machine. Many desktop virtual machine software packages let you attach a physical USB port to a guest virtual machine. (OpenBSD’s virtualization options are discussed in <a class="xref" href="ch23.html#virtualizing_openbsd" title="Virtualizing OpenBSD">Virtualizing OpenBSD</a>.)</p><p>If you have virtualization software that runs OpenBSD and supports USB, choose this option.</p></div><div class="sect2" title="Running a Diskless Installation"><div class="titlepage"><div><div><h3 class="title" id="running_a_diskless_installation">Running a Diskless Installation</h3></div></div></div><p>Your second choice is to run a diskless installation. Most DHCP servers embedded in cheap home hardware will let you send a filename and a TFTP server address to a client. If yours won’t, you can get suitable DHCP servers for any platform. You can find freely available TFTP servers for just about any operating system.</p><p>Boot your install target with the USB drive, but load the <span class="emphasis"><em>bsd.rd</em></span> kernel. You now have the OpenBSD installer running on the target system, and an OpenBSD system that fits in your pocket and that you can run almost anywhere. If you’re already running OpenBSD on something with the right architecture and a USB socket, it’s even easier: You boot the system from the appropriate <span class="emphasis"><em>bsd.rd</em></span>, choose the <code class="literal">disk</code> option, and point the installer to sets in a local directory.</p></div><div class="sect2" title="Converting ISO Images"><div class="titlepage"><div><div><h3 class="title" id="converting_iso_images">Converting ISO Images</h3></div></div></div><p>As a less official method, you can find software to convert ISO images to bootable USB images. I’ve used Rufus (<span class="emphasis"><em><a class="ulink" href="http://rufus.akeo.ie/" target="_top">http://rufus.akeo.ie/</a></em></span>) on Windows and UNetbootin (<span class="emphasis"><em><a class="ulink" href="http://unetbootin.sourceforge.net/" target="_top">http://unetbootin.sourceforge.net/</a></em></span>) on other Unix-like systems. This approach might work, but it’s certainly not OpenBSD-approved.</p></div></div><div class="sect1" title="Customizing OpenBSD Installations"><div class="titlepage"><div><div><h2 class="title" id="customizing_openbsd_installations" style="clear: both">Customizing OpenBSD Installations</h2></div></div></div><p><a class="indexterm" id="idx0828"/><a class="indexterm" id="idx1037"/><a class="indexterm" id="idx1596"/><a class="indexterm" id="idx2151"/><a class="indexterm" id="idx2367"/>Many of us follow a set of steps when installing a machine. All freshly installed hosts of a specific operating system revision have a common SSH server configuration. My machines all have <code class="literal">tcsh</code> installed and attach to the central authentication system. You probably have your own list. These tasks can be done by hand after installation, but it’s much easier to let OpenBSD do them for you during the installation process.</p><p>Installations can be customized by adding files during installation or by running commands after the installation.</p><div class="sect2" title="Custom File Sets"><div class="titlepage"><div><div><h3 class="title" id="custom_file_sets">Custom File Sets</h3></div></div></div><p>A custom file set includes files that you want copied to your new installation. I use custom file sets to install the default <span class="emphasis"><em>/etc/sudoers</em></span>, a SSH server configuration, my company’s default <span class="emphasis"><em>pf.conf</em></span>, and similar files. As I’m the lead sysadmin, I also include dotfiles in my home directory and other personal touches to make my life easier. Some people include several home directories, including <span class="emphasis"><em>authorized_keys</em></span> files for SSH.</p><p>Bundle these files together as a <span class="emphasis"><em>siteXX.tgz</em></span> file, which the installer can extract in the root directory of the new installation. (Be sure to replace the <span class="emphasis"><em>XX</em></span> with the OpenBSD version you’re installing on; for example, name a <span class="emphasis"><em>siteXX.tgz</em></span> file for OpenBSD 5.4 <span class="emphasis"><em>site54.tgz</em></span>.)</p><p>Start by installing an OpenBSD machine of the exact same version and platform that you want to customize. Make your changes and add your files to this system, verify that this template system works exactly as you desire, and then copy the changed files to a tar file.</p><div class="note" title="Note"><h3 class="title"><a id="ch23note03"/>Note</h3><p>You could make a directory hierarchy and copy the files you want to it, but I find that to be more error-prone. A small virtual machine will let you build a <span class="emphasis"><em>siteXX.tgz</em></span> file more reliably.</p></div><p>The following example creates a <span class="emphasis"><em>site54.tar</em></span> file containing one file, <span class="emphasis"><em>/etc/ssh/sshd_config</em></span>. Note that I start by creating a plain tar file. Since I can’t easily add files to a compressed tar file, I’ll need to compress the file after it’s complete.</p><a id="I_programlisting23_id507628"/><pre class="programlisting"># <span class="strong"><strong>cd /</strong></span>
# <span class="strong"><strong>tar -cf site54.tar etc/ssh/sshd_config</strong></span></pre><p>Now that I have the initial file, I can add additional files. I’ve customized a few files on the system, as well as added new ones, all of which I add to the <span class="emphasis"><em>site54.tar</em></span> file. The <code class="literal">-r</code> flag tells <code class="literal">tar</code> to add a file to an archive.</p><a id="I_programlisting23_id507659"/><pre class="programlisting"># <span class="strong"><strong>tar -rf site54.tar etc/sudoers</strong></span>
# <span class="strong"><strong>tar -rf site54.tar etc/pf/mgmt-hosts.conf</strong></span>
# <span class="strong"><strong>tar -rf site54.tar etc/pf.conf</strong></span></pre><p>Here’s how to compress the tar file:</p><a id="I_programlisting23_id507683"/><pre class="programlisting"># <span class="strong"><strong>gzip site54.tar</strong></span>
# <span class="strong"><strong>mv site54.tar.gz site54.tgz</strong></span></pre><p>I’ve built my own custom release of OpenBSD, so I have a local FTP server that contains all of the release files. If you’re using the official OpenBSD release, but you’re installing enough OpenBSD machines to warrant making a <span class="emphasis"><em>siteXX.tgz</em></span> file, you can copy the official release to a local FTP or HTTP mirror. Copy your <span class="emphasis"><em>siteXX.tgz</em></span> file to this directory and update the <span class="emphasis"><em>index.txt</em></span> file.</p><a id="I_programlisting23_id507714"/><pre class="programlisting"># <span class="strong"><strong>ls -l &gt; index.txt</strong></span></pre><p>Now start your installation. Tell the installer to use your local release mirror rather than an official OpenBSD mirror. You should see the following sets:</p><a id="I_programlisting23_id507728"/><pre class="programlisting">Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
sets are labelled '[X]'.
    [X] bsd           [X] etc54.tgz     [X] xbase54.tgz   [X] xserv54.tgz
    [X] bsd.rd        [X] comp54.tgz    [X] xetc54.tgz    [ ] site54.tgz
    [ ] bsd.mp        [X] man54.tgz     [X] xshare54.tgz
    [X] base54.tgz    [X] game54.tgz    [X] xfont54.tgz
Set name(s)? (or 'abort' or 'done') [done] <span class="strong"><strong>site52.tgz</strong></span></pre><p>Your <span class="emphasis"><em>site54.tgz</em></span> file should now be available as a file set. Add it because the installer won’t automatically include it. Once the installation finishes, you should find your customized and added files on the new system.</p></div><div class="sect2" title="Post-Install Shell Scripts"><div class="titlepage"><div><div><h3 class="title" id="post-install_shell_scripts">Post-Install Shell Scripts</h3></div></div></div><p>Some tasks can be accomplished by copying files, but that’s annoying. For example, I want the shell <code class="literal">tcsh</code> installed on all of my OpenBSD servers. I could put all the files in the <code class="literal">tcsh</code> package, as well as the contents of <span class="emphasis"><em>/var/db/pkg/tcsh</em></span>, in <span class="emphasis"><em>siteXX.tgz</em></span>, but I know I’m likely to mess that up somehow. It would be much easier to run <code class="literal">pkg_add tcsh</code> after the installation, and let OpenBSD do what it’s supposed to do. That’s where the <code class="literal">install.site</code> script comes in.</p><p>After completing the installation, but before giving you the final command prompt, OpenBSD checks for <span class="emphasis"><em>/install.site</em></span>. If this file exists, the installer runs it. The script is run <code class="literal">chroot</code>ed into the new installed system, so you don’t need to worry about changing any paths. The script does need to run on a minimal kernel, however, so it’s best to wait for low-level kernel twiddling until the first real boot.</p><p>Here’s a sample <code class="literal">install.site</code> script that installs the two packages <code class="literal">tcsh</code> and <code class="literal">python</code>:</p><a id="I_programlisting23_id507815"/><pre class="programlisting">#<span class="strong"><strong>/bin/sh</strong></span>
export PKG_PATH=ftp://ftp13.usa.openbsd.org/pub/OpenBSD/snapshots/packages/i386/
pkg_add -v tcsh
pkg_add -v python-2.7.3p1</pre><p><a class="indexterm" id="idx0251"/><a class="indexterm" id="idx1598"/><a class="indexterm" id="idx1628"/><a class="indexterm" id="idx2150"/><a class="indexterm" id="idx2503"/><a class="indexterm" id="idx2505"/>When working with <code class="literal">install.site</code> scripts, if a package’s name could be ambiguous, be sure to give the full package name. There’s only one <code class="literal">tcsh</code> package, but Python comes in several versions. I specify the full package name, rather than using plain <code class="literal">python</code>.</p><p>Also note that while you’re running in a <code class="literal">chroot</code> that contains a full userland, that userland isn’t fully initialized. When dropping into the <code class="literal">chroot</code>, OpenBSD doesn’t do a full multiuser startup of that <code class="literal">chroot</code>. The environment is roughly equivalent to single-user mode. The <code class="literal">install.site</code> script is not where you initialize your database.</p><p>When you have a real userland ready to go, to automatically run commands on the system’s first real boot, append the commands to <span class="emphasis"><em>/etc/rc.firsttime</em></span>. This file runs once, at the system’s first boot after installation, and then deletes itself.</p></div></div><div class="sect1" title="Customizing Upgrades"><div class="titlepage"><div><div><h2 class="title" id="customizing_upgrades-id00002" style="clear: both">Customizing Upgrades</h2></div></div></div><p>OpenBSD lets you use custom file sets and shell scripts during binary upgrades. If you have a lot of machines to upgrade, run these to ensure that your systems are as identical after the upgrade as they were before. I highly recommend automating known changes during an upgrade.</p><p>The <span class="emphasis"><em>siteXX.tgz</em></span> file works for upgrades exactly as for installations. Put the files you want on this system in <span class="emphasis"><em>siteXX.tgz</em></span>, and the install program should copy those files to the system as it installs the upgraded files. Rather than <code class="literal">install.site</code>, however, the upgrade software looks for the script <code class="literal">upgrade.site</code>. Any <span class="emphasis"><em>install.site</em></span> file is ignored during an upgrade, so you can use the same <span class="emphasis"><em>siteXX.tgz</em></span> for upgrades and for new installations.</p><p>I find the <code class="literal">upgrade.site</code> script especially useful in conjunction with the <span class="emphasis"><em>OpenBSD Upgrade Guide</em></span> for that release. The <span class="emphasis"><em>Upgrade Guide</em></span> includes tasks that must be performed during an upgrade, many of which are very suitable for scripting. For example, the common tasks of deleting files, programs, and libraries removed from the new OpenBSD release are easily added to <code class="literal">upgrade.site</code>.</p><p>One convenient thing about <code class="literal">upgrade.site</code> is that you can copy the script to the target machine before running the upgrade. It doesn’t need to be part of <span class="emphasis"><em>siteXX.tgz</em></span>. That said, I don’t recommend running <code class="literal">pkg_add -u</code> in <code class="literal">upgrade.site</code>. While the idea of automatically upgrading all your packages sounds good, remember that you’re running on a limited kernel with a less than completely initialized userland. Have your <code class="literal">upgrade.site</code> script add any commands that need to run on a fully multiuser system to <span class="emphasis"><em>/etc/rc.firsttime</em></span>, so that they run when the system boots the first time.</p><p>With the hints in this chapter, you can customize OpenBSD any way you need. And with the information throughout this book, you should know where OpenBSD fits into your network. Remember that they really are out to get you, and you’ll achieve practical paranoia.</p></div></section></body></html>