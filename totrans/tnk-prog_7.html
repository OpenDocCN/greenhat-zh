<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Solving Problems with Code Reuse"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_code_reuse"/>Chapter 7. Solving Problems with Code Reuse</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id7"/><div class="mediaobject"><a id="I_mediaobject7_d1e13446"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>This chapter is very different from those that came before. In previous chapters, I stressed the importance of finding your own solution to problems. That’s what the book is about, after all: writing original solutions to programming problems. Even in previous chapters, though, we talked about how you are always learning from what you’ve written before, and that’s why you should retain all the code that you write for future reference. In this chapter, we’ll go one step further and discuss how to use code and ideas from other programmers to solve our problems.</p><p>If you remember how this book started, this topic may seem like an odd inclusion. At the beginning, I talked about what a mistake it was to try to solve complex problems by modifying someone else’s code. Not only does this have a low chance of success, but even when it succeeds, it provides no learning experience for you. And if this is all you ever do, you never actually become a programmer and are of limited use in software development. That said, once any programming problem reaches a respectable size, it’s not reasonable to expect a programmer to develop a solution entirely from scratch. That’s an inefficient use of the programmer’s time, and it relies too heavily on the programmer being an expert in all things. Plus, it’s more likely to lead to a buggy or difficult-to-maintain program.<a id="IDX-CHP-7-0001" class="indexterm"/><a id="IDX-CHP-7-0002" class="indexterm"/></p><div class="sect1" title="Good Reuse and Bad Reuse"><div class="titlepage"><div><div><h1 class="title"><a id="good_reuse_and_bad_reuse"/>Good Reuse and Bad Reuse</h1></div></div></div><p>We must therefore distinguish between good reuse, which allows us to write better programs and write them more quickly, and bad reuse, which may allow us to impersonate a programmer for a while but ultimately leads to poor development, of both the code and the programmer. <a class="xref" href="ch07.html#good_and_bad_code_reuse" title="Table 7-1. Good and Bad Code Reuse">Table 7-1</a> summarizes the differences. The left column shows the properties of good reuse and the right column shows the properties of bad reuse. When considering whether or not to attempt a reuse of code, ask yourself whether you are more likely to produce the properties in the left column or the right column.</p><div class="table"><a id="good_and_bad_code_reuse"/><p class="title">Table 7-1. Good and Bad Code Reuse</p><div class="table-contents"><table summary="Good and Bad Code Reuse" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good Reuse</p></th><th style="text-align: left" valign="bottom"><p>Bad Reuse</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Following a blueprint</p></td><td style="text-align: left" valign="top"><p>Copying someone else’s work</p></td></tr><tr><td style="text-align: left" valign="top"><p>Magnifies and extends your capabilities</p></td><td style="text-align: left" valign="top"><p>Falsifies your capabilities</p></td></tr><tr><td style="text-align: left" valign="top"><p>Helps you learn</p></td><td style="text-align: left" valign="top"><p>Helps you avoid learning</p></td></tr><tr><td style="text-align: left" valign="top"><p>Saves time in the short term and the long term</p></td><td style="text-align: left" valign="top"><p>May save time in the short term but may lengthen time in the long term</p></td></tr><tr><td style="text-align: left" valign="top"><p>Results in a working program</p></td><td style="text-align: left" valign="top"><p>May result in a program that doesn’t work anyway</p></td></tr></tbody></table></div></div><p>It’s important to note that the difference between good reuse and bad reuse doesn’t reside in what code you reuse or how you reuse it but in your relationship to the code and concepts that you are borrowing. Once, in writing a term paper in a literature class, I discovered that something I had learned in a previous course was relevant to my paper’s topic, so I included it. When I submitted a draft of my paper to the professor, she told me I needed a citation for that information. Frustrated, I asked my professor at what point I could simply state my knowledge in a paper without providing a reference. Her answer was that I could stop referencing others for what was in my head when I became such an expert that others were referencing me.</p><p>In programming terms, good reuse occurs when you write code yourself based on reading someone’s description of a general concept or when you make use of code that you could have written yourself. Throughout this chapter, we’re going to talk about how you can take ownership of coding concepts so that you can be sure that your reuse is helping you become a better programmer, not a lazier one.</p><p>Let me also draw attention to the last row in <a class="xref" href="ch07.html#good_and_bad_code_reuse" title="Table 7-1. Good and Bad Code Reuse">Table 7-1</a>. Attempts at bad reuse often fail altogether. This is not surprising, because it involves a programmer using code that he or she doesn’t actually understand. In some situations, the borrowed code will work initially, but when the programmer attempts to modify or expand the borrowed code base, the lack of deep comprehension removes the possibility of an organized approach. The programmer then resorts to flailing about and trial and error, thus violating the first and most important of our general problem-solving rules: Always have a plan.<a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/></p></div><div class="sect1" title="Review of Component Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_component_fundamentals"/>Review of Component Fundamentals</h1></div></div></div><p>Now that we know the kind of reuse we are aiming for, let’s categorize the different ways in which code can be reused. In this book, I’m going to use the term <span class="emphasis"><em>component</em></span> to refer to anything created by one programmer that can be reused by another to help solve a programming problem. Components can exist anywhere on the continuum from abstract to concrete, from an idea to fully implemented code. If we think of solving a programming problem as analogous to tackling a handyman project, the techniques we’ve learned for solving problems are like tools, and components are like specialty parts. Each of the following components is a different way of reusing prior work of programmers.<a id="IDX-CHP-7-0005" class="indexterm"/><a id="IDX-CHP-7-0006" class="indexterm"/></p><div class="sect2" title="Code Block"><div class="titlepage"><div><div><h2 class="title"><a id="code_block"/>Code Block</h2></div></div></div><p>A <span class="emphasis"><em>code block</em></span> is just that: a block of code that has been copied from one program listing to another. More colloquially, we would call this a <span class="emphasis"><em>copy-and-paste job</em></span>. This is the lowest form of component use and is often bad reuse, with all of the problems that implies. Of course, if the code you are copying is your own, there’s no real harm done, except that you might consider packaging the existing code as a class library or other structure to allow it to be reused in a cleaner and more easily maintained way.<a id="IDX-CHP-7-0007" class="indexterm"/><a id="IDX-CHP-7-0008" class="indexterm"/><a id="IDX-CHP-7-0009" class="indexterm"/></p></div><div class="sect2" title="Algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="algorithms"/>Algorithms</h2></div></div></div><p>An <span class="emphasis"><em>algorithm</em></span> is a programming recipe; it’s a particular method of accomplishing a goal and is expressed either in plain language or pictorially as in a flowchart. For example, back in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a>, we discussed the <span class="emphasis"><em>sort</em></span> operation for arrays and different ways this sort could be accomplished. One method of sorting an array is the insertion-sort algorithm, and I showed a sample implementation of the algorithm. It’s important to note that the given code was one implementation of the insertion sort, but insertion sort is the algorithm itself—that way of sorting an array—and not the particular code. Insertion sort works by repeatedly taking the next unsorted value in the array and shifting the sorted values “up” one position until we’ve made a hole in the correct position for the value we’re currently inserting. Any code that uses this method to sort an array is an insertion sort.<a id="IDX-CHP-7-0010" class="indexterm"/><a id="IDX-CHP-7-0011" class="indexterm"/></p><p>Algorithms are a high-level form of reuse and generally lead to good reuse properties. Algorithms are essentially just ideas, and you, the programmer, must implement the ideas, calling upon your programming skills and your deep understanding of the algorithm itself. The algorithms you will commonly use are well studied and have predictable performance in various situations. With an algorithm as a blueprint, you can have confidence in the correctness of your code and in its performance.<a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/></p><p>There are some potential downsides to basing code on an algorithm, though. When you use an algorithm, you are starting at the conceptual level. Therefore, you have a long road ahead to the finished code for that section of the program. The algorithm certainly saves time, because the problem-solving aspect is essentially complete, but depending on the algorithm and its particular application in your programming, the implementation of the algorithm can be nontrivial.</p></div><div class="sect2" title="Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="patterns"/>Patterns</h2></div></div></div><p>In programming, a <span class="emphasis"><em>pattern</em></span> (or <span class="emphasis"><em>design pattern</em></span>) is a template for a particular programming technique. The concept is related to an algorithm but distinguishable. Algorithms are like recipes for solving particular problems, while patterns are general techniques used in particular programming situations. The problems that patterns solve are typically within the structure of the code itself. For example, in <a class="xref" href="ch06.html" title="Chapter 6. Solving Problems with Recursion">Chapter 6</a> we discussed the problem presented by a recursive function in a linked-list class: The recursive function needed the “head” pointer to the first node in the list as a parameter, but that data needed to remain private. The solution was to create a <span class="emphasis"><em>wrapper</em></span>, a function that would adapt one parameter list to another. The wrapper technique is a design pattern. We can use this pattern to solve the problem of a recursive function in a class, but it can be used in other ways as well. For example, suppose we had a <code class="literal">linkedList</code> class that allowed items to be inserted or removed at any point in the list, but what we needed was a stack class—that is, a list that allowed insertion and removal only at one end. We could create a new class stack that had public methods for the typical stack operations, such as <code class="literal">push</code> and <code class="literal">pop</code>. These methods would just call member functions on the <code class="literal">linkedList</code> object that was a private data member of our <code class="literal">stack</code> class. In this way, we would reuse the functionality of a linked-list class while providing the interface of a stack class.<a id="IDX-CHP-7-0014" class="indexterm"/><a id="IDX-CHP-7-0015" class="indexterm"/></p><p>Like algorithms, patterns are a high-level form of component use, and learning patterns is a great way to build up your programming tool chest. Patterns share some of the potential problems of algorithms, though. Knowing that a pattern exists is not the same as knowing how to implement a pattern in the particular language you have chosen for a programming solution, and patterns are often tricky to implement correctly or with maximum performance. For example, there is a pattern known as a <span class="emphasis"><em>singleton</em></span>, which is a class that allows only one object of the class to be created. Creating a singleton class is straightforward, but creating a singleton class that does not create the one allowed instance object until it is actually needed can be surprisingly difficult, and the best technique may vary from language to language.<a id="IDX-CHP-7-0016" class="indexterm"/><a id="IDX-CHP-7-0017" class="indexterm"/></p></div><div class="sect2" title="Abstract Data Types"><div class="titlepage"><div><div><h2 class="title"><a id="abstract_data_types"/>Abstract Data Types</h2></div></div></div><p>An <span class="emphasis"><em>abstract data type</em></span>, as we discussed in <a class="xref" href="ch05.html" title="Chapter 5. Solving Problems with Classes">Chapter 5</a>, is a type defined by its operations, not by how those operations are implemented. The stack type, which we have used several times in this book, is a good example. Abstract data types are like patterns in that they define the effects of operations, but they do not specifically define how those operations are implemented. As with algorithms, however, there are well-known implementation techniques for these operations. For example, a stack can be implemented using any number of underlying data structures, such as a linked list or an array. Once we make the decision to use a particular data structure, though, the implementation decisions are sometimes already made. Suppose we implemented a stack using a linked list and are unable to wrap around an existing linked list, but we must write our own list code. Because the stack is a last-in-first-out structure, it only makes sense for us to insert and remove items at one end of the linked list. Furthermore, it only makes sense to insert and remove at the front of the list. Theoretically, you could insert and remove at the end, but this would result in an inefficient traversal of the entire list for every insertion or removal. To avoid those traversals would require a doubly linked list with a separate pointer to the last node in the list. Inserting and removing at the beginning of the list allows the simplest, most efficient implementation, so linked-list implementations of stacks are almost all implemented the same way.<a id="IDX-CHP-7-0018" class="indexterm"/><a id="IDX-CHP-7-0019" class="indexterm"/><a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/></p><p>Thus, even though the <span class="emphasis"><em>abstract</em></span> in <span class="emphasis"><em>abstract data type</em></span> means the type is conceptual and without implementation detail, in practice, when you choose to implement an abstract data type in your code, you won’t be figuring out the implementation from scratch. Rather, you will have existing implementations of the type as guides.</p></div><div class="sect2" title="Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="libraries"/>Libraries</h2></div></div></div><p>In programming, a <span class="emphasis"><em>library</em></span> is a collection of related pieces of code. A library typically includes the code in compiled form, along with needed source code declarations. Libraries can include stand-alone functions, classes, type declarations, or anything else that can appear in code. In C++, the most obvious examples are the standard libraries. The <code class="literal">strcmp</code> function we used in previous chapters comes from the old C library <span class="emphasis"><em>cstring</em></span>, the container classes such as <code class="literal">vector</code> come from the C++ Standard Template Library, and even the <code class="literal">NULL</code> we have used in all of our pointer-based code is not part of the C++ language itself but defined in a library header file, <span class="emphasis"><em>stdlib.h</em></span>. Because so much core functionality is contained within libraries, library use is inevitable in modern programming.<a id="IDX-CHP-7-0022" class="indexterm"/><a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><p>Generally, library use is good code reuse. Code is included in a library because it provides functionality that is commonly needed in a variety of programs—library code helps programmers avoid “reinventing the wheel.” Nevertheless, as developing programmers, when we use library code, we must strive to learn from the experience and not merely take a shortcut. We’ll see an example of this later in the chapter.</p><p>Note that while many libraries are general purpose, others are designed as <span class="emphasis"><em>application programming interfaces (APIs)</em></span> providing the high-level language programmer with a simplified or more coherent view of an underlying platform. For example, the Java language includes an API called JDBC, which provides classes that allow programs to interact with relational databases in a standard way. Another example is DirectX, which provides Microsoft Windows game programmers extensive functionality with sound and graphics. In both cases, the library provides a connection between the high-level program and foundation-level hardware and software—the database engine in the case of JDBC and the graphics and sound hardware in the case of DirectX. Moreover, in both cases, the code reuse is not just good—it is, for all practical purposes, required. A database programmer in Java or a graphics programmer writing C++ code for Windows is going to make use of an API—if not these APIs, then something else, but the programmer isn’t going to cook up a new connection to the platform from scratch.<a id="IDX-CHP-7-0025" class="indexterm"/><a id="IDX-CHP-7-0026" class="indexterm"/><a id="IDX-CHP-7-0027" class="indexterm"/><a id="IDX-CHP-7-0028" class="indexterm"/><a id="IDX-CHP-7-0029" class="indexterm"/><a id="IDX-CHP-7-0030" class="indexterm"/><a id="IDX-CHP-7-0031" class="indexterm"/><a id="IDX-CHP-7-0032" class="indexterm"/><a id="IDX-CHP-7-0033" class="indexterm"/><a id="IDX-CHP-7-0034" class="indexterm"/></p></div></div><div class="sect1" title="Building Component Knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="building_component_knowledge"/>Building Component Knowledge</h1></div></div></div><p>Components are so helpful that programmers make use of them whenever possible. In order to use a component to aid in solving a problem, though, a programmer must know of its existence. Depending on how finely you define them, available components might number into the hundreds or even thousands, and a beginning programmer is going to be exposed to only a few of them. A good programmer must therefore always be adding component knowledge to his or her toolkit. Such knowledge gathering occurs in two different ways: A programmer may explicitly allot time for learning new components as a general task, or the programmer may search for a component to solve a specific problem. We’ll call the first approach <span class="emphasis"><em>exploratory learning</em></span> and the second approach <span class="emphasis"><em>as-needed learning</em></span>. To develop as a programmer, you will need to employ both approaches. Once you have mastered the syntax of your chosen programming language, discovering new components is one of the primary ways for you to better yourself as a programmer.<a id="IDX-CHP-7-0035" class="indexterm"/></p><div class="sect2" title="Exploratory Learning"><div class="titlepage"><div><div><h2 class="title"><a id="exploratory_learning"/>Exploratory Learning</h2></div></div></div><p>Let’s start with an exploratory learning example. Suppose we wanted to learn more about design patterns. Fortunately, there is general agreement about which design patterns are the most useful or frequently used, so we could begin with any number of resources on this topic and be fairly sure that we aren’t missing anything important. We would benefit by simply finding a list of design patterns and studying it, but we would gain more insight if we implemented some of the patterns.</p><p>One pattern we’ll find in a typical list is called <span class="emphasis"><em>strategy</em></span> or <span class="emphasis"><em>policy</em></span>. This is the idea of allowing an algorithm, or part of an algorithm, to be chosen at run-time. In the purest form, the strategy form, this pattern allows changing how a function or method operates but does not alter the result. For example, a method of a class that sorts its data, or involves sorting data, might allow the sort methodology (quicksort or insertion sort, for example) to be chosen. The result is the same in any case—sorted data—but allowing the client to choose the sort methodology could offer performance benefits. For example, the client could avoid using quicksort for data with a high rate of duplicates. In the policy form, the client’s choice affects the outcome. For example, suppose a class represents a hand of playing cards. The sorting policy could determine whether aces are considered high (above a king) or low (less than a 2).<a id="IDX-CHP-7-0036" class="indexterm"/><a id="IDX-CHP-7-0037" class="indexterm"/><a id="IDX-CHP-7-0038" class="indexterm"/><a id="IDX-CHP-7-0039" class="indexterm"/><a id="IDX-CHP-7-0040" class="indexterm"/><a id="IDX-CHP-7-0041" class="indexterm"/><a id="IDX-CHP-7-0042" class="indexterm"/></p><div class="sect3" title="Putting Learning into Practice"><div class="titlepage"><div><div><h3 class="title"><a id="putting_learning_into_practice"/>Putting Learning into Practice</h3></div></div></div><p>Reading that paragraph, you now know what the strategy/policy pattern is, but you haven’t made it your own. It’s the difference between browsing tools at the hardware store and actually buying one and using it. So let’s take this design pattern down from the shelf and put it to use. The fastest way to try out a new technique is to incorporate it into code you’ve already written. Let’s create a problem that can be solved using this pattern and that is built upon code we’ve already written.</p><div class="sidebar"><a id="problem_colon_the_first_student"/><p class="title">Problem: The First Student</p><p>At a particular school, each class has a designated “first student” who is responsible for maintaining order in the classroom if the teacher has to leave the room. Originally, this title was bestowed upon the student with the highest grade, but now some teachers think the first student should be the student with the greatest seniority, which means the lowest student ID number, as they are assigned sequentially. Another faction of teachers thinks the first student tradition is silly and intends to protest by simply choosing the student whose name appears first in the alphabetical class roll. Our task is to modify the student collection class, adding a method to retrieve the first student from the collection, while accommodating the selection criteria of the various teacher groups.</p></div><p>As you can see, this problem is going to employ the policy form of the pattern. We want our method that returns the first student to return a different student based on a chosen criterion. In order to make this happen in C++, we’re going to use function pointers. We’ve briefly seen this concept in action in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a> with the <code class="literal">qsort</code> function, which takes a pointer to a function that compares two items in the array to be sorted. We’ll do something similar here; we’ll have a set of comparison functions that takes two of our <code class="literal">studentRecord</code> objects and determines whether the first student is “better” than the second by looking at the grades, ID numbers, or names of the students.</p><p>To get started, we need to define a type for our comparison functions:</p><a id="I_programlisting7_d1e13856"/><pre class="programlisting">typedef bool <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>(* firstStudentPolicy)(studentRecord r1, studentRecord r2);</pre><p>This declaration creates a type named <code class="literal">firstStudentPolicy</code> as a pointer to a function that returns a <code class="literal">bool</code> and takes two parameters of type <code class="literal">studentRecord</code>. The parentheses around <code class="literal">* firstStudentPolicy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e13878"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> are necessary to prevent the declaration from being interpreted as a function that returns a pointer to a <code class="literal">bool</code>. With this declaration in place, we can create our three policy functions:</p><a id="I_programlisting7_d1e13888"/><pre class="programlisting">bool higherGrade(studentRecord r1, studentRecord r2) {
   return r1.grade() &gt; r2.grade();
}
bool lowerStudentNumber(studentRecord r1, studentRecord r2) {
   return r1.studentID() &lt; r2.studentID();
}
bool nameComesFirst(studentRecord r1, studentRecord r2) {
   return <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>strcmp(r1.name().c_str()<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>, r2.name().c_str()<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>)
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>&lt; 0;
}</pre><p>The first two functions are very simple: <code class="literal">higherGrade</code> returns <code class="literal">true</code> when the first record has the higher grade, and <code class="literal">lowerStudent</code> number returns <code class="literal">true</code> when the first record has the lower student number. The third function, <code class="literal">nameComesFirst</code>, is essentially the same, but it requires the <code class="literal">strcmp</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e13935"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> library function, which expects two “C-style” strings—that is, null-terminated character arrays instead of <code class="literal">string</code> objects. So we have to invoke the <code class="literal">c_str()</code><span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e13946"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> method on the <code class="literal">name</code> strings in both student records. The <code class="literal">strcmp</code> function returns a negative number when the first string comes before the second alphabetically, so we check the return value to see whether it’s less than zero <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e13959"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Now we are ready to modify the <code class="literal">studentCollection</code> class itself:<a id="IDX-CHP-7-0043" class="indexterm"/></p><a id="I_programlisting7_d1e13973"/><pre class="programlisting">class studentCollection {
private:
   struct studentNode {
      studentRecord studentData;
      studentNode * next;
   };
public:
   studentCollection();
   ˜studentCollection();
   studentCollection(const studentCollection &amp;copy);
   studentCollection&amp; operator=(const studentCollection &amp;rhs);
   void addRecord(studentRecord newStudent);
   studentRecord recordWithNumber(int IDnum);
   void removeRecord(int IDnum);
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>void setFirstStudentPolicy(firstStudentPolicy f);
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord firstStudent();
private:
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>firstStudentPolicy _currentPolicy;
   typedef studentNode * studentList;
   studentList _listHead;
   void deleteList(studentList &amp;listPtr);
   studentList copiedList(const studentList copy);
};</pre><p>This is the class declaration we saw back in <a class="xref" href="ch05.html" title="Chapter 5. Solving Problems with Classes">Chapter 5</a> with three new members: a private data member, <code class="literal">_currentPolicy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14000"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, to store a pointer to one of our policy functions; a <code class="literal">setFirstStudentPolicy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14009"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> method to change this policy; and the <code class="literal">firstStudent</code> method itself <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14019"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, which will return the first student according to the current policy. The code for <code class="literal">setFirstStudentPolicy</code> is simple:<a id="IDX-CHP-7-0044" class="indexterm"/></p><a id="I_programlisting7_d1e14032"/><pre class="programlisting">void studentCollection::setFirstStudentPolicy(firstStudentPolicy f) {
   _currentPolicy = f;
}</pre><p>We also need to modify the default constructor to initialize the current policy:<a id="IDX-CHP-7-0045" class="indexterm"/><a id="IDX-CHP-7-0046" class="indexterm"/></p><a id="I_programlisting7_d1e14044"/><pre class="programlisting">studentCollection::studentCollection() {
   _listHead = NULL;
   _currentPolicy = NULL;
}</pre><p>Now we are ready to write <code class="literal">firstStudent</code>:</p><a id="I_programlisting7_d1e14051"/><pre class="programlisting">studentRecord studentCollection::firstStudent() {
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (_listHead == NULL || _currentPolicy == NULL) {
      studentRecord dummyRecord(−1, −1, "");
      return dummyRecord;
   }
   studentNode * loopPtr = _listHead;
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord first = loopPtr-&gt;studentData;
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>loopPtr = loopPtr-&gt;next;
   while (loopPtr != NULL) {
      if (<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>_currentPolicy(loopPtr-&gt;studentData, first)) {
         first = loopPtr-&gt;studentData;
      }
    <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>loopPtr = loopPtr-&gt;next;
   }
   return first;
}</pre><p>The method begins by checking for special cases. If there is no list to review or no policy in place <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14085"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, we return a dummy record. Otherwise, we traverse the list to find the student who best meets the current policy, using the basic searching techniques we’ve been using throughout this book. We assign the record at the beginning of the list to <code class="literal">first</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14094"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, start our loop variable at the second record in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14100"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, and begin the traversal. Inside the traversal loop, a call to the current policy function <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14106"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> tells us whether the student we’re currently looking at is “better” than the best student we’ve found so far, based on the current criterion. When the loop is over, we return the “first student” <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14113"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>.<a id="IDX-CHP-7-0047" class="indexterm"/><a id="IDX-CHP-7-0048" class="indexterm"/></p></div><div class="sect3" title="Analysis of First Student Solution"><div class="titlepage"><div><div><h3 class="title"><a id="analysis_of_first_student_solution"/>Analysis of First Student Solution</h3></div></div></div><p>Having solved a problem using the strategy/policy pattern, we’re much more likely to recognize situations in which the technique can be employed than if we had just read about the technique once and never used it. We can also analyze our sample problem to start forming our own opinion about the worth of the technique, when it can be properly employed, and when it might be a mistake, or at least more trouble than it’s worth. One thought that may have occurred to you about this particular pattern is that it weakens encapsulation and information hiding. For example, if the client code is providing the policy functions, it requires access to types that would normally remain internal to the class, in this case, the <code class="literal">studentRecord</code> type. (We’ll consider a way around this problem in the exercises.) This means the client code could break if we ever modify that type, and we must weigh this concern against the benefits of the pattern before applying it in other projects. In previous chapters, we discussed how knowing when to use a technique—or when not to use it—is as important as knowing how to use it. By examining your own code, you gain insight into this critical question.<a id="IDX-CHP-7-0049" class="indexterm"/><a id="IDX-CHP-7-0050" class="indexterm"/><a id="IDX-CHP-7-0051" class="indexterm"/><a id="IDX-CHP-7-0052" class="indexterm"/><a id="IDX-CHP-7-0053" class="indexterm"/></p><p>For further practice, you can review your library of completed projects in search of code that could be refactored using this technique. Remember that much “real world” programming involves supplementing or modifying an existing code base, so this is excellent practice for such modifications, in addition to developing your skill with the particular component. Moreover, one of the benefits of good code reuse is that we learn from it, and this practice maximizes learning.</p></div></div><div class="sect2" title="As-Needed Learning"><div class="titlepage"><div><div><h2 class="title"><a id="as-needed_learning"/>As-Needed Learning</h2></div></div></div><p>The previous section described what we might call “learning through wandering.” While such journeys are valuable to programmers, there are other times where we must move toward a particular goal. If you’re working on a particular problem, especially if you’re working against any kind of deadline, and you suspect that a component could be of great help to you, you don’t want to wander randomly through the world of programming and hope that you stumble upon what you need. Instead, you want to find the component or components that directly apply to your situation as quickly as possible. That sounds very tricky, though—how do you find what you need when you don’t know exactly what you’re looking for? Consider the following sample problem:</p><div class="sidebar"><a id="problem_colon_efficient_traversal"/><p class="title">Problem: Efficient Traversal</p><p>A programming project will use your <code class="literal">studentCollection</code> class. The client code needs the ability to traverse all of the students in the collection. Obviously, to maintain information hiding, the client code cannot be given direct access to the list, but it’s a requirement that the traversals are efficient.</p></div><p>Because the key word in this description is <span class="emphasis"><em>efficient</em></span>, let’s be precise about what that means in this case. Let’s suppose that a particular object of our <code class="literal">stu</code><code class="literal">dentCollection</code> class has 100 students. If we had direct access to the linked list, we could write a loop to traverse the list that would loop 100 times. That’s the most efficient any list traversal can be. Any solution that requires us to loop more than 100 times to determine the result would be inefficient.<a id="IDX-CHP-7-0054" class="indexterm"/><a id="IDX-CHP-7-0055" class="indexterm"/><a id="IDX-CHP-7-0056" class="indexterm"/><a id="IDX-CHP-7-0057" class="indexterm"/></p><p>Without the requirement for efficiency, we might try to solve the problem by adding a simple <code class="literal">recordAt</code> method to our class that would return the student record at a particular position in the collection, numbering the first record as 1:<a id="IDX-CHP-7-0058" class="indexterm"/></p><a id="I_programlisting7_d1e14207"/><pre class="programlisting">studentRecord studentCollection::recordAt(int position) {
   studentNode * loopPtr = _listHead;
   int i = 1;
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>while (loopPtr != NULL &amp;&amp; i &lt; position) {
      i++;
      loopPtr = loopPtr-&gt;next;
   }
   if (loopPtr == NULL) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord dummyRecord(−1, −1, "");
      return dummyRecord;
   } else {
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>return loopPtr-&gt;studentData;
   }
}</pre><p>In this method, we use a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14229"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> to traverse the list until we reach the desired position or we reach the end of the list. At the end of the loop, if the end of the list has been reached, we create and return a dummy record <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14235"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, or we return the record at the specified position <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14241"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. The problem is that we are performing a traversal merely to find one student record. This is not necessarily a full traversal, because we will stop when we reach the desired position, but it is a traversal nonetheless. Suppose the client code is attempting to average student grades:<a id="IDX-CHP-7-0059" class="indexterm"/></p><a id="I_programlisting7_d1e14250"/><pre class="programlisting">int gradeTotal = 0;
for (int recNum = 1; recNum &lt;= numRecords; recNum++) {
   studentRecord temp = sc.recordAt(recNum);
   gradeTotal += temp.grade();
}
double average = (double) gradeTotal / numRecords;</pre><p>For this code segment, assume that <code class="literal">sc</code> is a previously declared and populated <code class="literal">studentCollection</code> and <code class="literal">recNum</code> is an <code class="literal">int</code> storing the number of records. Suppose <code class="literal">recNum</code> is 100. If you just glance at this code, it might appear that computing the average takes just 100 trips through the loop, but since each call to <code class="literal">recordAt</code> is itself a partial list traversal, this code involves 100 traversals, each of which will involve looping about 50 times for the average case. So instead of 100 steps, which would be efficient, this could require about 5,000 steps, which is very inefficient.<a id="IDX-CHP-7-0060" class="indexterm"/><a id="IDX-CHP-7-0061" class="indexterm"/><a id="IDX-CHP-7-0062" class="indexterm"/><a id="IDX-CHP-7-0063" class="indexterm"/><a id="IDX-CHP-7-0064" class="indexterm"/></p><div class="sect3" title="When to Search for a Component"><div class="titlepage"><div><div><h3 class="title"><a id="when_to_search_for_a_component"/>When to Search for a Component</h3></div></div></div><p>We have now arrived at the real problem. Providing client access to collection members for traversals is easy; providing such access efficiently is not. We could, of course, try to solve this problem using only our own problem-solving ability, but we would reach the solution much faster if we could use a component. The first step in finding a previously unknown component that can aid our solution is assuming that such a component actually exists. Put another way, you won’t find a component unless you start searching for one. Therefore, to maximize the benefit of components, you need to be on the lookout for situations where they can help. When you find yourself stuck on some aspect of the problem, try the following:<a id="IDX-CHP-7-0065" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Restate the problem generically.</p></li><li class="listitem"><p>Ask yourself: Is this likely to be a common problem?</p></li></ol></div><p>The first step is important because if we state our problem as “Allow client code to efficiently compute the average student grade in a linked list of records encapsulated in a class,” it sounds like it’s specific to our situation. If, however, we state the problem as “Allow client code to efficiently traverse a linked list without providing direct access to the list’s pointers,” then we begin to understand that this might be a common problem. Surely, we might ask ourselves, as often as programs store linked lists and other sequentially accessed structures within classes, other programmers must have figured out ways to allow efficient access to every item in the structure?</p></div><div class="sect3" title="Finding a Component"><div class="titlepage"><div><div><h3 class="title"><a id="finding_a_component"/>Finding a Component</h3></div></div></div><p>Now that we’ve agreed to look, it’s time to find our component. To make things clear, let’s restate the original programming problem as a research problem: “Find a component we can use to modify our <code class="literal">studentCollection</code> class to allow client code to efficiently traverse the internal list.” How do we solve <span class="emphasis"><em>this</em></span> problem? We could start by looking at any of our component types: patterns, algorithms, abstract data types, or libraries.<a id="IDX-CHP-7-0066" class="indexterm"/></p><p>Suppose we started by looking at the standard C++ libraries. We would not necessarily be looking for a class to “plug in” to our solution, but we instead could mine a library class that was similar to our <code class="literal">studentCollection</code> class for ideas. This employs the analogy strategy we used to solve programming problems. If we find a class that has an analogous problem, we can borrow its analogous solution. Our previous exposure to the C++ library has brought us into contact with its container classes, such as <code class="literal">vector</code>, and we should look for the container class that’s most like our student collection class. If we go to a favorite C++ reference, be that a book or a site on the Web, and review the C++ container classes, we see there is a “sequence container” called <code class="literal">list</code> that fits the bill. Does the <code class="literal">list</code> class allow efficient traversal by client code? It does, using an object known as an <span class="emphasis"><em>iterator</em></span>. We see that the list class provides methods <code class="literal">begin</code> and <code class="literal">end</code> that produce iterators, which are objects that can reference a particular item in the list and be incremented to make the iterator reference the next object in the list. If <code class="literal">integerList</code> is a <code class="literal">list&lt;int&gt;</code>, populated with integers, and <code class="literal">iter</code> is a <code class="literal">list&lt;int&gt;::iterator</code>, then we could display all of the integers in the list with the following:<a id="IDX-CHP-7-0067" class="indexterm"/><a id="IDX-CHP-7-0068" class="indexterm"/><a id="IDX-CHP-7-0069" class="indexterm"/><a id="IDX-CHP-7-0070" class="indexterm"/><a id="IDX-CHP-7-0071" class="indexterm"/><a id="IDX-CHP-7-0072" class="indexterm"/></p><a id="I_programlisting7_d1e14390"/><pre class="programlisting">iter = intList.begin();
while (iter != intList.end()) {
   cout &lt;&lt; *iter &lt;&lt; "\n";
   iter++;
}</pre><p>Through the use of the iterator, the <code class="literal">list</code> class has solved the problem of providing a mechanism to the client for efficiently traversing the list. At this point, we might think to drop the <code class="literal">list</code> class itself into our <code class="literal">studentCollection</code> class, replacing our home-built linked list. We could then create <code class="literal">begin</code> and <code class="literal">end</code> methods for our class that would wrap the same methods from the embedded list object, and the problem would be solved. This, however, runs straight into the issue of good versus bad reuse. Once we fully understand the iterator concept and can reproduce it on our own in our own code, plugging an existing class from the Standard Template Library into our code will be a good option—perhaps the best option. If we’re not able to do that, using the <code class="literal">list</code> class becomes a shortcut that doesn’t help us grow as programmers. Sometimes, of course, we must avail ourselves of components that we couldn’t reproduce, but if we fall into the habit of depending on other programmers to solve our problems, we risk never becoming problem solvers ourselves.</p><p>So let’s implement the iterator ourselves. Before we do that, though, let’s briefly look at other ways we could have arrived at the same place. We began the search in the standard template libraries, but we could have begun elsewhere. For example, we could have searched through a list of common design patterns. Under the heading of “behavioral patterns,” we would find the <span class="emphasis"><em>iterator</em></span> pattern, in which the client is allowed sequential access to a collection of items without exposing the underlying structure of the collection. This is exactly what we need, but we could have found it only by searching through a list of patterns or remembering it from previous investigations of patterns. We could have started our search with abstract data types because <span class="emphasis"><em>list</em></span> in general, and <span class="emphasis"><em>linked list</em></span> in particular, are common abstract data types. However, many discussions and implementations of the list abstract data type do not consider client list traversal to be a basic operation, so the iterator concept never comes up. Finally, if we begin our search in the algorithms area, we would be unlikely to find anything helpful. Algorithms tend to describe tricky code, and the code to create an iterator is fairly simple, as we will soon see. In this case, then, the class library was the quickest route to our destination, followed by patterns. As a general rule, however, you must consider all component types when searching for a helpful component.<a id="IDX-CHP-7-0073" class="indexterm"/></p></div><div class="sect3" title="Applying the Component"><div class="titlepage"><div><div><h3 class="title"><a id="applying_the_component"/>Applying the Component</h3></div></div></div><p>We now know we’re going to make an iterator for our <code class="literal">studentCollection</code> class, but all the <code class="literal">list</code> standard library class has shown us is how the iterator methods work externally. If we got stuck on implementation, we might consider reviewing the source code <code class="literal">list</code> and its ancestor classes, but given the difficulty of reading large swaths of unfamiliar code, that’s a measure of last resort. Instead, let’s just think our way through this. Using the previous code example as a guide, we can say that an iterator is defined by four central operations:<a id="IDX-CHP-7-0074" class="indexterm"/><a id="IDX-CHP-7-0075" class="indexterm"/><a id="IDX-CHP-7-0076" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A method in the collection class that provides an iterator that references the first item in the collection. In the <code class="literal">list</code> class, this was <code class="literal">begin</code>.</p></li><li class="listitem"><p>A mechanism to test whether the iterator has advanced past the last item in the collection. In the previous example, this was a method called <code class="literal">end</code> in the <code class="literal">list</code> class that produced a special iterator object to test against.</p></li><li class="listitem"><p>A method in the iterator class that moves the iterator so that it references the next item in the collection. In the previous example, this was the overloaded <code class="literal">++</code> operator.</p></li><li class="listitem"><p>A method in the iterator class that returns the currently referenced item in the collection. In the previous example, this was the overloaded <code class="literal">*</code> (prefixed) operator.</p></li></ol></div><p>In terms of writing the code, nothing here looks difficult. It’s just a question of putting everything in the right place. So let’s get started. From the descriptions above, our iterator, which we’ll call <code class="literal">scIterator</code>, needs to store a reference to an item in the <code class="literal">studentCollection</code> and needs to be able to advance to the next item. Thus, our iterator should store a pointer to a <code class="literal">studentNode</code>. That will allow it to return the <code class="literal">studentRecord</code> contained within, as well as advance to the next <code class="literal">studentNode</code>. Therefore, the private section of iterator class will have this data member:</p><a id="I_programlisting7_d1e14505"/><pre class="programlisting">studentCollection::studentNode * current;</pre><p>Right away, we’ve got a problem. The <code class="literal">studentNode</code> type is declared within a private section of <code class="literal">studentCollection</code>, and therefore the line above won’t work. Our first thought is that perhaps <code class="literal">studentNode</code> shouldn’t have been declared privately, but that’s not the right answer. The node type is inherently private because we don’t want random client code to depend upon a particular implementation of the node type, thus creating code that could break if we modify our class. Nevertheless, we need to allow <code class="literal">scIterator</code> access to our -private type. We do that with a <code class="literal">friend</code> declaration. In the public section of <code class="literal">studentCollection</code>, we add:</p><a id="I_programlisting7_d1e14528"/><pre class="programlisting">friend class scIterator;</pre><p>Now <code class="literal">scIterator</code> can access the private declarations within <code class="literal">studentCollection</code>, including the declaration for <code class="literal">studentNode</code>. We can also declare some constructors:<a id="IDX-CHP-7-0077" class="indexterm"/><a id="IDX-CHP-7-0078" class="indexterm"/></p><a id="I_programlisting7_d1e14551"/><pre class="programlisting">scIterator::scIterator() {
   current = NULL;
}
scIterator::scIterator(studentCollection::studentNode * initial) {
   current = initial;
}</pre><p>Let’s hop over to the <code class="literal">studentCollection</code> for a second and write our <span class="emphasis"><em>begin</em></span> method—a method that returns an iterator that references the first item in our collection. Following the naming scheme I have used in this book, this method should have a noun for a name, such as <code class="literal">firstItemIterator</code>:</p><a id="I_programlisting7_d1e14564"/><pre class="programlisting">scIterator studentCollection::firstItemIterator() {
   return scIterator(_listHead);
}</pre><p>As you can see, all we need to do here is stuff the head pointer of the linked list into a <code class="literal">scIterator</code> object and return it. If you’re anything like me, seeing the pointers flying around here may make you a little nervous, but note that <code class="literal">scIterator</code> is just going to hold onto a reference to an item in the <code class="literal">studentCollection</code> list. It’s not going to allocate any memory of its own, and therefore we don’t need to worry about deep copy and overloaded assignment operators.</p><p>Let’s return to <code class="literal">scIterator</code> and write our other methods. We need a method to advance the iterator to the next item, as well as a method to determine whether we are past the end of the collection. We should think about both of these at the same time. In advancing the iterator, we need to know what value the iterator should have when it passes beyond the last node in the list. If we do nothing special, the iterator would naturally get the value of <code class="literal">NULL</code>, so that would be the easiest value to use. Note that we have initialized our iterator to <code class="literal">NULL</code> in the default constructor, so when we use <code class="literal">NULL</code> to indicate past-the-end we lose any distinction between these two states, but for this current problem that’s not an issue. The code for the methods is:</p><a id="I_programlisting7_d1e14592"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> void scIterator::advance() {
   <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (current != NULL)
       <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>current = current-&gt;next;
  }
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> bool scIterator::pastEnd() {
     return current == NULL;
  }</pre><p>Remember that we are just using the iterator concept to solve the original problem. We are not trying to duplicate the exact specification of a C++ Standard Template Library iterator, so we don’t have to use the same interface. In this case, rather than overloading the <code class="literal">++</code> operator, I have a method called <code class="literal">advance</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14625"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which checks to see that the <code class="literal">current</code> pointer isn’t <code class="literal">NULL</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14638"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> before advancing it to the next node <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14644"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Similarly, I find having to create a special “end” iterator to compare against cumbersome, so I just have a <code class="literal">bool</code> method called <code class="literal">pastEnd</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14656"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> that determines whether we’ve run out of nodes.<a id="IDX-CHP-7-0079" class="indexterm"/><a id="IDX-CHP-7-0080" class="indexterm"/><a id="IDX-CHP-7-0081" class="indexterm"/></p><p>Lastly, we need a way to get the currently referenced <code class="literal">studentRecord</code> object:</p><a id="I_programlisting7_d1e14681"/><pre class="programlisting">studentRecord scIterator::student() {
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (current == NULL) {
      studentRecord dummyRecord(−1, −1, "");
      return dummyRecord;
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>} else {
      return current-&gt;studentData;
   }
}</pre><p>As we’ve done previously, for safety, if our pointer is <code class="literal">NULL</code>, we create and return a dummy record <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14700"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Otherwise, we return the currently referenced record <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14706"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. This completes the implementation of the iterator concept with our <code class="literal">studentCollection</code> class. For clarity, here’s the complete declaration of the <code class="literal">scIterator</code> class:<a id="IDX-CHP-7-0082" class="indexterm"/></p><a id="I_programlisting7_d1e14722"/><pre class="programlisting">class scIterator {
public:
   scIterator();
   scIterator(studentCollection::studentNode * initial);
   void advance();
   bool pastEnd();
   studentRecord student();
private:
   studentCollection::studentNode * current;
};</pre><p>With the code all in place, we can test our code with a sample traversal. Let’s implement that average grade computation for comparison:</p><a id="I_programlisting7_d1e14726"/><pre class="programlisting">scIterator iter;
  int gradeTotal = 0;
  int numRecords = 0;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> iter = sc.firstItemIterator();
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> while (!iter.pastEnd()) {
     numRecords++;
   <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>gradeTotal += iter.student().grade();
   <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>iter.advance();
  }
  double average = (double) gradeTotal / numRecords;</pre><p>This listing makes use of all of our iterator-related methods, so it’s a good test of our code. We call <code class="literal">firstItemIterator</code> to initialize our <code class="literal">scIterator</code> object <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14760"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. We call <code class="literal">pastEnd</code> as our loop termination test <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14769"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. We call the <code class="literal">student</code> method of the iterator object to get the current <code class="literal">studentRecord</code> so that we can extract the grade <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14782"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Finally, to move the iterator to the next record, we call the <code class="literal">advance</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14791"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. When this code works, we can be reasonably confident that we have implemented the various methods correctly, and more than that, that we have a firm understanding of the iterator concept.</p></div><div class="sect3" title="Analysis of Efficient Traversal Solution"><div class="titlepage"><div><div><h3 class="title"><a id="analysis_of_efficient_traversal_solution"/>Analysis of Efficient Traversal Solution</h3></div></div></div><p>As before, just because the code works doesn’t mean the potential for learning from this event is over. We should carefully consider what we have done, its positive effects and negative effects, and contemplate expansions of the basic idea we have just implemented. In this case, we can say that the iterator concept definitely solves the original problem of inefficient client traversal of our collection, and once implemented, the use of the iterator is elegant and highly readable. On the downside, there’s no denying that the inefficient approach based on the <code class="literal">recordAt</code> method was much easier to write. In deciding whether or not the implementation of an iterator is valuable for a particular situation, we have to ask ourselves how often traversals would occur, how many items would typically be in our list, and so on. If traversals are infrequent and the list is small, the inefficiency is probably not important, but if we expect the list to grow large or cannot guarantee that it will not, the iterator may be required.</p><p>Of course, if we had decided to use a <code class="literal">list</code> object from the Standard Template Library, we would no longer worry about the difficulty of implementing the iterator because we would not be implementing it ourselves. The next time a situation like this arises, we can make use of the <code class="literal">list</code> class without feeling we are shortchanging ourselves or setting ourselves up for later difficulties, because we have investigated both lists and iterators to the point where we understand what must be going on behind the scenes, even if we never reviewed the actual source code.</p><p>Going further, we can think about broader applications of iterators and their possible limitations. Suppose, for example, we needed an iterator that could efficiently move not just to the next item in our <code class="literal">studentCollection</code> but also to the previous item. Now that we know how the iterator works, we can see that there is really no way to do this with our current <code class="literal">studentCollection</code> implementation. If the iterator maintains a link to a particular node in the list, advancing to the next node requires merely following the link in the node. Retreating to the previous node, however, requires traversing the list again up to that point. Instead, we would need a doubly linked list, where the nodes have pointers in both directions, to both the next node and the previous one. We can generalize this thought and start to consider different data structures and what kinds of traversals or data access can be efficiently offered to clients. For example, in the previous chapter on recursion, we briefly encountered the binary tree structure. Is there some way to allow an efficient client traversal of this structure in its standard form? If not, how would we have to modify it to allow efficient reversals? What is even the right order for the nodes in a binary tree to be traversed? Thinking through questions like these helps us to become better programmers. Not only will we teach ourselves new skills, but we’ll also learn more about the strengths and weaknesses of different components. Knowing the pros and cons of a component will allow us to use it wisely. Failing to consider the limitations of a particular approach can lead to dead ends, and the more we know about the components we use, the less likely this will happen to us.<a id="IDX-CHP-7-0083" class="indexterm"/><a id="IDX-CHP-7-0084" class="indexterm"/><a id="IDX-CHP-7-0085" class="indexterm"/></p></div></div></div><div class="sect1" title="Choosing a Component Type"><div class="titlepage"><div><div><h1 class="title"><a id="choosing_a_component_type"/>Choosing a Component Type</h1></div></div></div><p>As we’ve seen in these examples, the same problem can be solved using different types of components. A pattern may express the idea of a solution, an algorithm may outline an implementation of that idea or another idea that will solve the same problem, an abstract data type may encapsulate the concept, and a class in a library may contain a fully tested implementation of the abstract data type. If each of these is an expression of the same concept that we need to solve our problem, how do we know which component type to pull out of our toolbox?<a id="IDX-CHP-7-0086" class="indexterm"/><a id="IDX-CHP-7-0087" class="indexterm"/></p><p>One primary consideration is how much work may be required to integrate the component into our solution. Linking a class library into our code is often a fast way to solve a problem, whereas implementing an algorithm from a pseudocode description may take a lot of time. Another important consideration is how much flexibility the proposed component offers. Often, a component will come in a nice, prepackaged form, but when it is integrated into the project, the programmer discovers that while the component does most of what he or she needs, it doesn’t do everything. Perhaps the return value of one method is in the wrong format and requires additional processing, for example. If the component is used anyway, more trouble may be discovered down the road before the component is eventually discarded altogether and new code for that part of the problem is developed from scratch. If the programmer had chosen a component at a higher conceptual level, such as a pattern, the resulting code implementation would fit the problem perfectly because it was created specifically for that problem.</p><p><a class="xref" href="ch07.html#flexibility_versus_work_required_for_com" title="Figure 7-1. Flexibility versus work required for component types">Figure 7-1</a> summarizes the interplay of these two factors. Generally, code from a library comes ready to use, but it cannot be directly modified. It can only be indirectly modified either through the use of C++ templates or if the code in question implements something like the <span class="emphasis"><em>strategy</em></span> pattern we saw earlier in this chapter. At the other end of the scale, a pattern may be presented as nothing more than an idea (“a class that can have only one instance”), offering maximum implementation flexibility but requiring a lot of work from the programmer.</p><p>Of course, this is just a general guideline, and individual cases will differ. Perhaps the class we’re using from the library is at such a low level in our program that flexibility won’t suffer. For example, we might wrap a collection class of our own design around a basic container class like <code class="literal">list</code>, which is broad enough in capabilities that even if we have to expand the functionality of our container class, we can expect the <code class="literal">list</code> class to handle it. Before using a pattern, perhaps we’ve already implemented a particular pattern before, so we’re not so much creating new code as adapting previously written code.</p><div class="figure"><a id="flexibility_versus_work_required_for_com"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e14868"/><img src="httpatomoreillycomsourcenostarchimages1273267.png.jpg" alt="Flexibility versus work required for component types"/></div></div><p class="title">Figure 7-1. Flexibility versus work required for component types</p></div><p>The more experience you have in using components, the more confident you can be that you are starting in the right place. Until you develop that experience, you can use the trade-off between flexibility and work required as a rough guide. For each specific situation, ask yourself questions such as the following:<a id="IDX-CHP-7-0088" class="indexterm"/><a id="IDX-CHP-7-0089" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Can I use the component as is, or does it require additional code to bolt it into my project?</p></li><li class="listitem"><p>Am I confident that I understand the full extent of the problem, or the part that relates to this component, and that it will not change in the future?</p></li><li class="listitem"><p>Will I increase my programming knowledge by choosing this component?</p></li></ul></div><p>Your answers to these questions will help you estimate how much work will be involved and how much benefit you receive from each possible approach.</p><div class="sect2" title="Component Choice in Action"><div class="titlepage"><div><div><h2 class="title"><a id="component_choice_in_action"/>Component Choice in Action</h2></div></div></div><p>Now that we understand the general idea, let’s run through a quick example to demonstrate the specifics.</p><div class="sidebar"><a id="problem_colon_sorting_some_comma_leaving"/><p class="title">Problem: Sorting Some, Leaving Others Alone</p><p>A project requires you to sort an array of <code class="literal">studentRecord</code> objects by grade, but there’s a catch. Another part of the program is using a special grade value of −1 to indicate a student whose record cannot be moved. So while all the other records must be moved around, those with −1 grades should be left exactly where they are, resulting in an array that is sorted except for −1 grades interspersed throughout.</p></div><p>This is a tricky problem, and there are lots of ways we could attempt to solve it. To keep things simple, let’s reduce our choices to two: Either we choose an algorithm—that is, a sorting routine like insertion sort—and modify it to ignore the <code class="literal">studentRecord</code> objects with −1 grades, or we figure out a way to use the <code class="literal">qsort</code> library routine to solve this problem. Both of these options are possible. Because we’re comfortable with the insertion-sort code, it shouldn’t be too difficult to throw in some <code class="literal">if</code> statements to explicitly check and skip over records with −1 grades. Making <code class="literal">qsort</code> do the work for us will take a bit of a workaround. We could copy the student records with the real grades into a separate array, sort them using <code class="literal">qsort</code>, and then copy them back, making sure we don’t copy over any of the −1 grade records.<a id="IDX-CHP-7-0090" class="indexterm"/><a id="IDX-CHP-7-0091" class="indexterm"/><a id="IDX-CHP-7-0092" class="indexterm"/></p><p>Let’s follow through with both options to see how the choice of component type affects the resulting code. We’ll start with the algorithm component, writing our own modified insertion sort to solve the problem. As usual, we’ll approach this problem in stages. First, let’s reduce the problem by removing the whole −1 grade issue and just sorting an array of <code class="literal">studentRecord</code> objects without any special rules. If <code class="literal">sra</code> is an array containing <code class="literal">arraysize</code> objects of type <code class="literal">studentRecord</code>, the resulting code looks like this:</p><a id="I_programlisting7_d1e14955"/><pre class="programlisting">int start = 0;
int end = arraySize - 1;
for (int i = start + 1; i &lt;= end; i++) {
   for (int j = i; j &gt; start &amp;&amp; <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>sra[j-1].grade() &gt; sra[j].grade(); j--) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord temp = sra[j-1];
      sra[j-1] = sra[j];
      sra[j] = temp;
   }
}</pre><p>This code is very similar to the insertion sort for integers. The only differences are that the comparison requires calls to the <code class="literal">grade</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14974"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, and our temporary object used for swap space has changed type <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14980"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. This code works fine, but there is one caveat for testing this and other code blocks that follow in this section: Our <code class="literal">studentRecord</code> class validates data, and as previously written, it will not accept a −1 grade, so make sure you make the necessary changes. Now we’re ready to complete this version of the solution. We need the insertion sort to ignore records with −1 grades. This is not as simple as it sounds. In the basic insertion-sort algorithm, we are always swapping adjacent locations in the array, <code class="literal">j</code> and <code class="literal">j - 1</code> in the code above. If we are leaving records with −1 grades in place, though, the locations of the next records to be swapped could be an arbitrary distance apart.<a id="IDX-CHP-7-0093" class="indexterm"/></p><p><a class="xref" href="ch07.html#arbitrary_distance_between_records_to_be" title="Figure 7-2. Arbitrary distance between records to be swapped in modified insertion sort">Figure 7-2</a> illustrates this problem with an example. If this shows the array in its original configuration, then the arrows indicate the locations of the first records to be swapped, and they are not adjacent. Furthermore, eventually the last record (for Art) will have to be swapped from location <code class="literal">[5]</code> to <code class="literal">[3]</code> and then from <code class="literal">[3]</code> to <code class="literal">[0]</code>, so all the swaps required to sort this array (as much as we are sorting it) involve nonadjacent records.</p><div class="figure"><a id="arbitrary_distance_between_records_to_be"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e15017"/><img src="httpatomoreillycomsourcenostarchimages1273269.png" alt="Arbitrary distance between records to be swapped in modified insertion sort"/></div></div><p class="title">Figure 7-2. Arbitrary distance between records to be swapped in modified insertion sort</p></div><p>In considering how to solve this problem, I looked out for an analogy and found one in the processing of linked lists. In many linked-list algorithms, we have to maintain a pointer not only to the current node in our list traversal but also to the previous node. So at the end of loop bodies, we often assign the current pointer to the previous pointer before advancing the current pointer. Something similar needs to go on here. We need to keep track of the last “real” student record as we progress linearly through the array to find the next “real” record. Putting this idea into practice results in the following code:<a id="IDX-CHP-7-0094" class="indexterm"/></p><a id="I_programlisting7_d1e15027"/><pre class="programlisting">for (int i = start + 1; i &lt;= end; i++) {
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (sra[i].grade() != −1) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int rightswap = i;
      for (int leftswap = i - 1;
         leftswap &gt;= start
         &amp;&amp; (sra[leftswap].grade() &gt; sra[rightswap].grade()
          <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>|| sra[leftswap].grade() == −1);
         leftswap--)
      {
       <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>if(sra[leftswap].grade() != −1) {
            studentRecord temp = sra[leftswap];
            sra[leftswap] = sra[rightswap];
            sra[rightswap] = temp;
          <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>rightswap = leftswap;
         }
      }
   }
}</pre><p>In the basic insertion-sort algorithm, we repeatedly insert unsorted items into an ever-growing sorted area within the array. The outer loop selects the next unsorted item to be placed in sorted order. In this version of the code, we start by checking that the grade in location <code class="literal">i</code> is not −1 <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15065"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> inside the outer loop body. If it is, we will just skip to the next record, leaving this record in place. Once we have established that the student record at location <code class="literal">i</code> can be moved, we initialize <code class="literal">rightswap</code> to this location <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15077"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Then we begin the inner loop. In the basic insertion-sort algorithm, each iteration of the inner loop swaps an item with its neighbor. In our version, though, because we are leaving records with −1 grades in place, we perform a swap only when location <code class="literal">j</code> does not contain a grade of −1 <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15087"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. We then swap between locations <code class="literal">leftswap</code> and <code class="literal">rightswap</code> and assign <code class="literal">leftswap</code> to <code class="literal">rightswap</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15106"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>, setting up the next swap in the inner loop if there is one. Finally, we have to modify our inner loop condition. Normally the inner loop in an insertion sort stops when we reach the front end of the array or when we find a value that is less than the value we are inserting. Here, we have to make a compound condition using logical <span class="emphasis"><em>or</em></span> so that the loop continues past −1 grades <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15115"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> (because −1 will be less than any legitimate grade, thus stopping the loop prematurely).<a id="IDX-CHP-7-0095" class="indexterm"/><a id="IDX-CHP-7-0096" class="indexterm"/><a id="IDX-CHP-7-0097" class="indexterm"/><a id="IDX-CHP-7-0098" class="indexterm"/></p><p>This code solves our problem, but it’s possible that it may be giving off some “bad smells.” The standard insertion-sort code is easy to read, especially if you understand the gist of what it’s doing, but this modified version is hard on the eyes and probably needs some comment lines if we want to be able to understand it later. Perhaps a refactoring is in order, but let’s try the other approach for solving this problem and see how that reads.<a id="IDX-CHP-7-0099" class="indexterm"/></p><p>The first thing we’ll need is a comparison function for use with <code class="literal">qsort</code>. In this case, we’ll be comparing two <code class="literal">studentRecord</code> objects, and our function will subtract one grade from the other:<a id="IDX-CHP-7-0100" class="indexterm"/><a id="IDX-CHP-7-0101" class="indexterm"/></p><a id="I_programlisting7_d1e15162"/><pre class="programlisting">int compareStudentRecord(const void * voidA, const void * voidB) {
   studentRecord * recordA = (studentRecord *) voidA;
   studentRecord * recordB = (studentRecord *) voidB;
   return recordA-&gt;grade() - recordB-&gt;grade();
}</pre><p>Now we’re ready to sort the records. We’ll do this in three phases. First, we will copy all of the records that don’t have a −1 grade to a secondary array, leaving no gaps. Then, we’ll call <code class="literal">qsort</code> to sort the secondary array. Finally, we will copy the records from the secondary array back to the original array, skipping over the records with the −1 grades. The resulting code looks like this:</p><a id="I_programlisting7_d1e15169"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> studentRecord sortArray[arraySize];
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> int sortArrayCount = 0;
  for (int i = 0; i &lt; arraySize; i++) {
   <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>if (sra[i].grade() != −1) {
        sortArray[sortArrayCount] = sra[i];
        sortArrayCount++;
     }
  }
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> qsort(sortArray,
 sortArrayCount, sizeof(studentRecord), compareStudentRecord);
<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/> sortArrayCount = 0;
<img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/> for (int i = 0; i &lt; arraySize; i++) {
   <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>if (sra[i].grade() != −1) {
        sra[i] = sortArray[sortArrayCount];
        sortArrayCount++;
     }
  }</pre><p>Although this code is about the same length as the other solution, it’s more straightforward and easier to read. We begin by declaring our secondary array, <code class="literal">sortArray</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15218"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, of the same size as the original array. The variable <code class="literal">sortArrayCount</code> is initialized to zero <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15227"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>; in the first loop, we’ll use this to track how many records we have copied into the secondary array. Inside that loop, each time we encounter a record without a −1 grade <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15233"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, we assign it to the next available slot in <code class="literal">sortArray</code> and increment <code class="literal">sortArrayCount</code>. When the loop is over, we sort the secondary array <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15246"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. The variable <code class="literal">sortArrayCount</code> is reset to 0 <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15255"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>; we’ll use it in the second loop to track how many records we have copied from the secondary array back to the original array. Note that the second loop traverses the <span class="emphasis"><em>original</em></span> array <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15265"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, looking for slots that need to be filled <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e15271"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. If we approach this the other way, trying to loop through the secondary array and pushing the records over to the original array, we would need a double loop, with the inner loop searching for the next real-grade slot in the original array. This is another example of how the problem can be made easy or difficult based on our conceptualization of it.<a id="IDX-CHP-7-0102" class="indexterm"/><a id="IDX-CHP-7-0103" class="indexterm"/></p></div><div class="sect2" title="Comparing the Results"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_the_results"/>Comparing the Results</h2></div></div></div><p>Both solutions work and are reasonable approaches. For most programmers, the first solution, in which we modified insertion sort to leave some records in place as we sorted around them, is harder to write and harder to read. The second solution, though, appears to introduce some inefficiency because it requires copying the data to the secondary array and back again. Here’s where a little knowledge of algorithm analysis comes in handy. Suppose we were sorting 10,000 records—if we were sorting much fewer, we wouldn’t really care about the efficiency. We can’t know for sure what algorithm underlies the <code class="literal">qsort</code> call, but the worst case for a general-purpose sort would require 100 million record swaps, and the best case would be around 130,000. Regardless of where along the range we end up, copying 10,000 records back and forth isn’t going to be a major performance drain compared to the sorting. Also, we have to consider that whatever algorithm is used by <code class="literal">qsort</code> may be more efficient than our simple insertion sort, wiping out any benefit we may have gained from avoiding copying the data to and from the secondary array.<a id="IDX-CHP-7-0104" class="indexterm"/><a id="IDX-CHP-7-0105" class="indexterm"/><a id="IDX-CHP-7-0106" class="indexterm"/></p><p>So in this scenario, the second approach, using <code class="literal">qsort</code>, appears to be the winner. It’s simpler to implement, simpler to read and therefore more easily maintained, and we can expect its performance to be as good as, or possibly better than, the first solution. The best thing we can say about the first approach is that we may have learned skills that we can apply to other problems, whereas the second approach, by virtue of its simplicity, offers no such insights. As a general rule, when you are at the stage of programming where you are trying to maximize your learning, you should favor higher-level components such as algorithms and patterns. When you are at the stage of trying to maximize your efficiency as a programmer (or are under a hard deadline), you should favor lower-level components, choosing prebuilt code when possible. Of course, if time permits, trying several different approaches, as we have done here, provides the best of all worlds.</p></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id7"/>Exercises</h1></div></div></div><p>Try out as many components as you can. Once you get a handle on how to learn new components, your abilities as a programmer will start to grow quickly.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A complaint offered against the <span class="emphasis"><em>policy/strategy</em></span> pattern is that it requires exposing some internals of the class, such as types. Modify the “first student” program from earlier in this chapter so that the policy functions are all stored within the class and are chosen by passing a code value (of a new, enumerated type, for example), instead of passing the policy function itself.</p></li><li class="listitem"><p>Rewrite our <code class="literal">studentCollection</code> functions from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a> (<code class="literal">addRecord</code> and <code class="literal">averageRecord</code>) so that instead of directly implementing a linked list, you use a class from the C++ library.</p></li><li class="listitem"><p>Consider a collection of <code class="literal">studentRecord</code> objects. We want to be able to quickly find a particular record based on student number. Store the student records in an array, sort the array by student number, and investigate and implement the <span class="emphasis"><em>interpolation search</em></span> algorithm.</p></li><li class="listitem"><p>For the problem in 7-3, implement a solution by implementing an abstract data type that allows an arbitrary number of items to be stored and individual records to be retrieved based on a key value. A generic term for a structure that can efficiently store and retrieve items based on a key value is a <span class="emphasis"><em>symbol table</em></span>, and common implementations of the symbol table idea are <span class="emphasis"><em>hash tables</em></span> and <span class="emphasis"><em>binary search trees</em></span>.</p></li><li class="listitem"><p>For the problem in 7-3, implement a solution using a class from the C++ library.</p></li><li class="listitem"><p>Suppose you are working on a project in which a particular <code class="literal">studentRecord</code> may need to be augmented with one of the following pieces of data: term paper title, year of enrollment, or a <code class="literal">bool</code> indicating whether the student is auditing the class. You don’t want to include all of these data fields in the base <code class="literal">studentRecord</code> class, knowing that in most cases they won’t be used. Your first thought is to create three subclasses, each having one of the data fields, with names such as <code class="literal">studentRecordTitle</code>, <code class="literal">studentRecordYear</code> and <code class="literal">studentRecordAudit</code>. Then you are informed that some student records will contain two of these additional data fields or perhaps all three. Creating subclasses for each possible variation is impractical. Find a design pattern that addresses this conundrum, and implement a solution.</p></li><li class="listitem"><p>Develop a solution to the problem described in 7-6 that does not make use of the pattern you discovered but instead solves the problem using C++ library classes. Rather than focusing on the three particular data fields described in the previous question, try to make a general solution: a version of the <code class="literal">studentRecord</code> class that allows arbitrary extra fields of data to be added to particular objects. So, for example, if <code class="literal">sr1</code> is a <code class="literal">studentRecord</code>, you might want client code to make the call <code class="literal">sr1.addExtraField("Title", "Problems of Unconditiona</code>l Branching"), and then later <code class="literal">sr1.retrieveField("Title")</code> would return “Problems of Unconditional Branching.”</p></li><li class="listitem"><p>Design your own: Take a problem you have already solved, and solve it again using a different component. Remember to analyze the results in comparison to your original solution.</p></li></ol></div></div></div></body></html>