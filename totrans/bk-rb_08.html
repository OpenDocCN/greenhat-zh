<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Passing Arguments and Returning Values"><div class="titlepage"><div><div><h1 class="title"><a id="passing_arguments_and_returning_values"/>Chapter 8. Passing Arguments and Returning Values</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id10"/><div class="mediaobject"><a id="I_mediaobject8_d1e9421"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>In this chapter, you’ll be looking at many of the effects (and side effects) of passing arguments and returning values to and from methods. First, though, I’ll take a moment to summarize the types of methods you’ve used up to now.<a id="IDX-CHP-8-0001" class="indexterm"/><a id="IDX-CHP-8-0002" class="indexterm"/></p><div class="sect1" title="Summarizing Instance, Class, and Singleton Methods"><div class="titlepage"><div><div><h1 class="title"><a id="summarizing_instance_comma_class_comma_a"/>Summarizing Instance, Class, and Singleton Methods</h1></div></div></div><p>An instance method is declared inside a class definition and is intended for use by a specific object or “instance” of the class, like this:</p><p><span class="emphasis"><em>methods.rb</em></span></p><a id="I_programlisting8_d1e9444"/><pre class="programlisting">class MyClass
    # declare instance method
    def instanceMethod
        puts( "This is an instance method" )
    end
end

    # create object
ob = MyClass.new
    # use instance method
ob.instanceMethod</pre><p>A class method may be declared inside a class definition, in which case the method name may be preceded by the class name, or a <code class="literal">class &lt;&lt; self</code> block may contain a “normal” method definition. Either way, a class method is intended for use by the class itself, not by a specific object, like this:<a id="IDX-CHP-8-0003" class="indexterm"/><a id="IDX-CHP-8-0004" class="indexterm"/></p><a id="I_programlisting8_d1e9459"/><pre class="programlisting">class MyClass
    # a class method
    def MyClass.classmethod1
        puts( "This is a class method" )
    end

    # another class method
    class &lt;&lt; self
        def classmethod2
             puts( "This is another class method" )
        end
    end
end

    # call class methods from the class itself
MyClass.classmethod1
MyClass.classmethod2</pre><p>Singleton methods are methods that are added to a single object and cannot be used by other objects. A singleton method may be defined by appending the method name to the object name followed by a dot or by placing a “normal” method definition inside an <em class="replaceable"><code>ObjectName</code></em> <code class="literal">&lt;&lt; self</code> block like this:<a id="IDX-CHP-8-0005" class="indexterm"/><a id="IDX-CHP-8-0006" class="indexterm"/></p><a id="I_programlisting8_d1e9477"/><pre class="programlisting"># create object
ob = MyClass.new

    # define a singleton method
def ob.singleton_method1
    puts( "This is a singleton method" )
end

    # define another singleton method
class &lt;&lt; ob
    def singleton_method2
        puts( "This is another singleton method" )
    end
end

    # use the singleton methods
ob.singleton_method1
ob.singleton_method2</pre></div></div>
<div class="sect1" title="Returning Values"><div class="titlepage"><div><div><h1 class="title"><a id="returning_values"/>Returning Values</h1></div></div></div><p>In many programming languages, a distinction is made between functions or methods that return a value to the calling code and those that do not. In Pascal, for example, a <span class="emphasis"><em>function</em></span> returns a value, but a <span class="emphasis"><em>procedure</em></span> does not. No such distinction is made in Ruby. All methods always return a value, though of course you are not obliged to use it.<a id="IDX-CHP-8-0007" class="indexterm"/><a id="IDX-CHP-8-0008" class="indexterm"/><a id="IDX-CHP-8-0009" class="indexterm"/></p><p>When no return value is specified, Ruby methods return the result of the last expression evaluated. Consider this method:</p><p><span class="emphasis"><em>return_vals.rb</em></span></p><a id="I_programlisting8_d1e9508"/><pre class="programlisting">def method1
    a = 1
    b = 2
    c = a + b   # returns 3
end</pre><p>The last expression evaluated is <code class="literal">a + b</code>, which happens to return 3, so that is the value returned by this method. There may often be times when you don’t want to return the last expression evaluated. In such cases, you can specify the return value using the <code class="literal">return</code> keyword:</p><a id="I_programlisting8_d1e9518"/><pre class="programlisting">def method2
    a = 1
    b = 2
    c = a + b
    return b   # returns 2
end</pre><p>A method is not obliged to make any assignments in order to return a value. If a simple piece of data happens to be the last thing evaluated in a method, that will be the value the method returns. When nothing is evaluated, <code class="literal">nil</code> is returned:</p><a id="I_programlisting8_d1e9525"/><pre class="programlisting">def method3
   "hello"     # returns "hello"
end

def method4
   a = 1 + 2
   "goodbye"   # returns "goodbye"
end

def method5
end            # returns nil</pre><p>My own programming prejudice is to write code that is clear and unambiguous whenever possible. For that reason, whenever I plan to use the value returned by a method, I prefer to specify it using the <code class="literal">return</code> keyword; only when I do not plan to use the returned value do I omit this. However, this is not obligatory—Ruby leaves the choice to you.</p></div>
<div class="sect1" title="Returning Multiple Values"><div class="titlepage"><div><div><h1 class="title"><a id="returning_multiple_values"/>Returning Multiple Values</h1></div></div></div><p>But what about those occasions when you need a method to return more than one value? In other program languages, you may be able to “fake” this by passing arguments by reference (pointers to the original data items) rather than by value (a copy of the data); when you alter the values of “by reference” arguments, you alter the original values without explicitly having to return any values to the calling code.<a id="IDX-CHP-8-0010" class="indexterm"/></p><p>Ruby doesn’t make a distinction between “by reference” and “by value,” so this technique is not available to you (though you will see some exceptions to the rule shortly). However, Ruby is capable of returning multiple values all in one go, as shown here:<a id="IDX-CHP-8-0011" class="indexterm"/></p><p><span class="emphasis"><em>return_many.rb</em></span></p><a id="I_programlisting8_d1e9552"/><pre class="programlisting">def ret_things
    greeting = "Hello world"
    a = 1
    b = 2.0
    return a, b, 3, "four", greeting, 6 * 10
end</pre><p>Multiple return values are placed into an array. If you were to evaluate <code class="literal">ret_things.class</code>, Ruby would inform you that the returned object is an Array. You could, however, explicitly return a different collection type such as a Hash:</p><a id="I_programlisting8_d1e9559"/><pre class="programlisting">def ret_hash
    return {'a'=&gt;'hello', 'b'=&gt;'goodbye', 'c'=&gt;'fare thee well'}
end</pre></div>
<div class="sect1" title="Default and Multiple Arguments"><div class="titlepage"><div><div><h1 class="title"><a id="default_and_multiple_arguments"/>Default and Multiple Arguments</h1></div></div></div><p>Ruby lets you specify default values for arguments. Default values can be assigned in the parameter list of a method using the usual assignment operator:<a id="IDX-CHP-8-0012" class="indexterm"/></p><a id="I_programlisting8_d1e9571"/><pre class="programlisting">def aMethod( a=10, b=20 )</pre><p>If an unassigned variable is passed to that method, the default value will be assigned to it. If an assigned variable is passed, however, the assigned value takes precedence over the default. Here I use the <code class="literal">p()</code> method to inspect and print the return values:</p><a id="I_programlisting8_d1e9578"/><pre class="programlisting">def aMethod( a=10, b=20 )
   return a, b
end

p( aMethod )            #=&gt; displays: [10,  20]
p( aMethod( 1 ))        #=&gt; displays: [1, 20]
p( aMethod( 1, 2 ))     #=&gt; displays: [1, 2]</pre><p>In some cases, a method may need to be capable of receiving an uncertain number of arguments—say, for example, a method that processes a variable-length list of items. In this case, you can “mop up” any number of trailing items by preceding the final argument with an asterisk:</p><p><span class="emphasis"><em>default_args.rb</em></span></p><a id="I_programlisting8_d1e9585"/><pre class="programlisting">def aMethod( a=10, b=20, c=100, *d )
   return a, b, c, d
end

p( aMethod( 1,2,3,4,6 ) )     #=&gt; displays: [1, 2, 3, [4, 6]]</pre></div>
<div class="sect1" title="Assignment and Parameter Passing"><div class="titlepage"><div><div><h1 class="title"><a id="assignment_and_parameter_passing"/>Assignment and Parameter Passing</h1></div></div></div><p>Most of the time, Ruby methods come with two access points—like the doors into and out of a room. The argument list provides the way in; the return value provides the way out. Modifications made to the input arguments do not affect the original data for the simple reason that when Ruby evaluates an expression, the result of that evaluation creates a new object, so any changes made to an argument affect only the new object, not the original piece of data. But there are exceptions to this rule, which I’ll show you now.</p><p>Let’s start by looking at the simplest case—a method that takes one value as a named parameter and returns another value:</p><p><span class="emphasis"><em>in_out.rb</em></span></p><a id="I_programlisting8_d1e9597"/><pre class="programlisting">def change( x )
    x += 1
    return x
end</pre><p>On the face of it, you might think you are dealing with a single object, <code class="literal">x</code>, here: The object <code class="literal">x</code> goes into the <code class="literal">change</code> method, and the same object <code class="literal">x</code> is returned. In fact, that is not the case. One object goes in (the argument), and a different object comes out (the return value). You can easily verify this using the <code class="literal">object_id</code> method to show a number that uniquely identifies each object in your program:<a id="IDX-CHP-8-0013" class="indexterm"/></p><a id="I_programlisting8_d1e9620"/><pre class="programlisting">num = 10
puts( "num.object_id=#{num.object_id}" )
num = change( num )
puts( "num.object_id=#{num.object_id}" )</pre><p>The identifier of the variable, <code class="literal">num</code>, is different before and after you call the <code class="literal">change</code> method. This shows that even though the variable name remains the same, the <code class="literal">num</code> object that is returned by the <code class="literal">change</code> method is different from the <code class="literal">num</code> object that was sent to it.</p><p>The method call itself has nothing to do with the change of the object. You can verify this by running <span class="emphasis"><em>method_call.rb</em></span>. This simply passes the <code class="literal">num</code> object to the change method and returns it:</p><p><span class="emphasis"><em>method_call.rb</em></span></p><a id="I_programlisting8_d1e9650"/><pre class="programlisting">def nochange( x )
   return x
end</pre><p>In this case, the <code class="literal">object_id</code> is the same after <code class="literal">num</code> is returned as it was before <code class="literal">num</code> was sent to the method. In other words, the object that went into the method is the same object as the one that came out again. That leads to the inevitable conclusion that there is something about the <span class="emphasis"><em>assignment</em></span> in the <code class="literal">change</code> method (<code class="literal">x += 1</code>) that caused the creation of a new object.<a id="IDX-CHP-8-0014" class="indexterm"/></p><p>But assignment itself isn’t the whole explanation. If you simply assign a variable to itself, no new object is created:</p><p><span class="emphasis"><em>assignment.rb</em></span></p><a id="I_programlisting8_d1e9682"/><pre class="programlisting">num = 10
num = num     # a new num object is not created</pre><p>If you now display the <code class="literal">object_id</code> of the <code class="literal">num</code> variable, the number is the same before an after assignment, proving that this really is the same object. So, what if you assign to the object the same value that it already has?</p><a id="I_programlisting8_d1e9692"/><pre class="programlisting">num = 10
num = 10      # a new num object is not created</pre><p>Once again, the <code class="literal">object_id</code> is unchanged after the assignment. This demonstrates that assignment alone does not necessarily create a new object. Now let’s try assigning a new value:</p><a id="I_programlisting8_d1e9699"/><pre class="programlisting">num = 10
num += 1      # this time a new num object is created</pre><p>This time, if you display <code class="literal">num.object_id</code> before and after the assignment, you will see a different number—say 21 before and 23 after. The actual numbers are automatically determined by Ruby and may vary. The important thing to understand is that a different object ID indicates a different object. If the same variable returns a different <code class="literal">object_id</code> when a value is assigned to it, that means a new object has been created.</p><p>Most data items are treated as unique, so one string “hello” is considered to be different from another string “hello,” and one float 10.5 is considered to be different from another float 10.5. Thus, any string or float assignment will create a new object.</p><p>But when working with integers, only when the assignment value is <span class="emphasis"><em>different</em></span> from the previous value is a new object created. You can do all kinds of complicated operations on the right side of the assignment, but if the yielded value is the same as the original value, no new object is created.</p><a id="I_programlisting8_d1e9717"/><pre class="programlisting">num = 11
puts( "num.object_id=#{num.object_id}" )
num = (((num + 1 - 1) * 100) / 100)
puts( "num.object_id=#{num.object_id}" )</pre><p>In the previous code, the first assignment creates a new <code class="literal">num</code> object with the integer value 11. Even though the result of a fairly complex expression is used in the next assignment, this still has the value 11. Since the value of <code class="literal">num</code> is not changed, no new objects are created, and its <code class="literal">object_id</code> remains the same:<a id="IDX-CHP-8-0015" class="indexterm"/><a id="IDX-CHP-8-0016" class="indexterm"/></p><a id="I_programlisting8_d1e9738"/><pre class="programlisting">num.object_id=23
num.object_id=23</pre></div>
<div class="sect1" title="Integers Are Special"><div class="titlepage"><div><div><h1 class="title"><a id="integers_are_special"/>Integers Are Special</h1></div></div></div><p>In Ruby, an integer (or Fixnum) has a fixed identity. Every instance of the number 10 or every variable to which the value 10 is assigned will have the same <code class="literal">object_id</code>. The same cannot be said of other data types. Each instance of a floating-point number such as 10.5 or of a string such as “hello world” will be a different object with a unique <code class="literal">object_id</code>. Be aware that when you assign an integer to a variable, that variable will have the <code class="literal">object_id</code> <span class="emphasis"><em>of the integer itself</em></span>. But when you assign some other type of data to a variable, a new object will be created even if the data itself is the same at each assignment:</p><p><span class="emphasis"><em>object_ids.rb</em></span></p><a id="I_programlisting8_d1e9760"/><pre class="programlisting"># 10 and x after each assignment are the same object
puts( 10.object_id )
x = 10
puts( x.object_id )
x = 10
puts( x.object_id )

# 10.5 and x after each assignment are 3 different objects!
puts( 10.5.object_id )
x = 10.5
puts( x.object_id )
x = 10.5
puts( x.object_id )</pre><p>But why does all this matter?</p><p>It matters because of a few rare exceptions to the rule. As I said earlier, most of the time, a method has a well-defined way in and a well-defined way out. Once an argument goes inside a method, it enters a closed room. Any code outside that method has no way of learning about any changes that have been made to the argument until it comes out again in the form of a returned value. This is, in fact, one of the deep secrets of “pure” object orientation. The implementation details of methods should, in principle, be hidden away, or <span class="emphasis"><em>encapsulated</em></span>. This ensures that code outside an object cannot be dependent on things that happen inside that object.</p></div>
<div class="sect1" title="The One-Way-In, One-Way-Out Principle"><div class="titlepage"><div><div><h1 class="title"><a id="the_one-way-in_comma_one-way-out_princip"/>The One-Way-In, One-Way-Out Principle</h1></div></div></div><p>In most modern object-oriented languages such as Java and C#, encapsulation and information hiding are not rigorously enforced. In Smalltalk, on the other hand—the most famous and influential object-oriented language—encapsulation and information hiding are fundamental principles: If you send a variable <code class="literal">x</code> to a method <code class="literal">y</code> and the value of <code class="literal">x</code> is changed inside <code class="literal">y</code>, you cannot obtain the changed value of <code class="literal">x</code> from outside the method—<span class="emphasis"><em>unless the method explicitly returns that value</em></span>.<a id="IDX-CHP-8-0017" class="indexterm"/><a id="IDX-CHP-8-0018" class="indexterm"/><a id="IDX-CHP-8-0019" class="indexterm"/><a id="IDX-CHP-8-0020" class="indexterm"/></p><div class="sidebar"><a id="encapsulation_or_information_hiding_ques"/><p class="title">Encapsulation or Information Hiding?</p><p>Often these two terms are used interchangeably. To be nitpicky, however, there is a difference. <span class="emphasis"><em>Encapsulation</em></span> refers to the grouping together of an object’s “state” (its data) and the operations that may alter or interrogate its state (its methods). <span class="emphasis"><em>Information hiding</em></span> refers to the fact that data is sealed off and can be accessed only using well-defined routes in and out—in object-oriented terms, this implies “accessor methods” to get or return values. In procedural languages, information hiding may take other forms; for example, you might have to define interfaces to retrieve data from code “units” or “modules” rather than from objects.</p><p>In object-oriented terms, encapsulation and information hiding are almost synonymous—true encapsulation necessarily implies that the internal data of an object is hidden. However, many modern object-oriented languages such as Java, C#, C++, and Object Pascal are quite permissive in the degree to which information hiding is enforced (if at all).</p></div><p>Usually, Ruby adheres to this principle: Arguments go into a method, but any changes made inside the method cannot be accessed from the outside unless Ruby returns the changed value:</p><p><span class="emphasis"><em>hidden.rb</em></span></p><a id="I_programlisting8_d1e9823"/><pre class="programlisting">def hidden( aStr, anotherStr )
    anotherStr = aStr + " " + anotherStr
    return anotherStr.reverse
end

str1 = "dlrow"
str2 = "olleh"
str3 = hidden(str1, str2)
puts( str1 )    #=&gt; dlrow
puts( str2 )    #=&gt; olleh
puts( str3 )    #=&gt; hello world</pre><p>In the previous code, the string value of the second object, <code class="literal">str2</code>, is received by the <code class="literal">anotherStr</code> argument of the <code class="literal">hidden</code> method. The argument is assigned a new string value and reversed. Even so, neither of the original variables, <code class="literal">str1</code> or <code class="literal">str2</code>, is changed. Only the variable assigned the return value, <code class="literal">str3</code>, contains the changed “hello world” string.</p><p>It turns out that there are occasions when arguments passed to a Ruby method can be used like the “by reference” arguments of other languages (that is, changes made <span class="emphasis"><em>inside</em></span> the method may affect variables <span class="emphasis"><em>outside</em></span> the method). This is because some Ruby methods modify the original object rather than yielding a value and assigning this to a new object.<a id="IDX-CHP-8-0021" class="indexterm"/><a id="IDX-CHP-8-0022" class="indexterm"/><a id="IDX-CHP-8-0023" class="indexterm"/></p><p>For example, there are some methods ending with an exclamation mark that alter the original object. Similarly, the String append method <code class="literal">&lt;&lt;</code> concatenates the string on its right to the string on its left but does not create a new string object in the process: So, the value of the string on the left is modified, but the string object itself retains its original <code class="literal">object_id</code>.<a id="IDX-CHP-8-0024" class="indexterm"/></p><p>The consequence of this is that if you use the <code class="literal">&lt;&lt;</code> operator instead of the <code class="literal">+</code> operator in a method, your results will change:</p><p><span class="emphasis"><em>not_hidden.rb</em></span></p><a id="I_programlisting8_d1e9890"/><pre class="programlisting">def nothidden( aStr, anotherStr )
    anotherStr = aStr &lt;&lt; " " &lt;&lt; anotherStr
    return anotherStr.reverse
end

str1 = "dlrow"
str2 = "olleh"
str3 = nothidden(str1, str2)
puts( str1 )      #=&gt; dlrow olleh
puts( str2 )      #=&gt; olleh
puts( str3 )      #=&gt; hello world</pre><p>In the previous code, the <code class="literal">anotherStr</code> argument is concatenated with a space and the <code class="literal">aStr</code> argument using <code class="literal">&lt;&lt;</code>, and the resulting string is reversed when returned. If information hiding were rigorously enforced, this might be expected to produce the same results as in the previous program—that is, <code class="literal">str1</code> and <code class="literal">str2</code> would remain unchanged. However, the use of <code class="literal">&lt;&lt;</code> has had profound effects because it has caused the modifications made to the <code class="literal">aStr</code> argument <span class="emphasis"><em>inside</em></span> the <code class="literal">nothidden</code> method to change the value of the <code class="literal">str1</code> object <span class="emphasis"><em>outside</em></span> the method.</p><p>This behavior, incidentally, would be the same if the <code class="literal">nothidden</code> method were placed into a separate class:</p><p><span class="emphasis"><em>nothidden2.rb</em></span></p><a id="I_programlisting8_d1e9936"/><pre class="programlisting">class X
    def nothidden( aStr, anotherStr )
        anotherStr = aStr &lt;&lt; " " &lt;&lt; anotherStr
        return anotherStr.reverse
    end
end
ob = X.new
str1 = "dlrow"
str2 = "olleh"
str3 = ob.nothidden(str1, str2)
puts( str1 )    #=&gt; dlrow olleh</pre><p>This shows that, in certain cases, the internal implementation details of an object’s methods may accidentally alter the code that calls it. It is generally safer to make implementation details hidden; otherwise, when code is rewritten inside a class, the changes may have side effects on code that uses that class.<a id="IDX-CHP-8-0025" class="indexterm"/><a id="IDX-CHP-8-0026" class="indexterm"/></p></div>
<div class="sect1" title="Modifying Receivers and Yielding New Objects"><div class="titlepage"><div><div><h1 class="title"><a id="modifying_receivers_and_yielding_new_obj"/>Modifying Receivers and Yielding New Objects</h1></div></div></div><p>You may recall from <a class="xref" href="ch04.html" title="Chapter 4. Arrays and Hashes">Chapter 4</a> that I made the distinction between methods that modify their receiver and those that do not. (Remember that a <span class="emphasis"><em>receiver</em></span> is the object that “owns” the method.) In most cases, Ruby methods do not modify the receiver object. However, some methods, such as those ending with <code class="literal">!</code>, do modify their receiver.</p><p>The <span class="emphasis"><em>str_reverse.rb</em></span> sample program should help clarify this. This shows that when you use the <code class="literal">reverse</code> method, for example, no change is made to the receiver object (that is, an object such as <code class="literal">str1</code>). But when you use the <code class="literal">reverse!</code> method, a change <span class="emphasis"><em>is</em></span> made to the object (its letters are reversed). Even so, no new object is created: <code class="literal">str1</code> is the same object before and after the <code class="literal">reverse!</code> method is called.</p><p>Here <code class="literal">reverse</code> operates like most Ruby methods: It yields a value, and in order to use that value, you must assign it to a new object. Consider the following:</p><p><span class="emphasis"><em>str_reverse.rb</em></span></p><a id="I_programlisting8_d1e9995"/><pre class="programlisting">str1 = "hello"
str1.reverse</pre><p>Here, <code class="literal">str1</code> is unaffected by calling <code class="literal">reverse</code>. It still has the value “hello” and still has its original <code class="literal">object_id</code>. Now look at this:</p><a id="I_programlisting8_d1e10008"/><pre class="programlisting">str1 = "hello"
str1.reverse!</pre><p>This time, <code class="literal">str1</code> <span class="emphasis"><em>is</em></span> changed (it becomes “olleh”). Even so, no new object is created: <code class="literal">str1</code> has the same <code class="literal">object_id</code> with which it started. So, how about this:</p><a id="I_programlisting8_d1e10024"/><pre class="programlisting">str1 = "hello"
str1 = str1.reverse</pre><p>This time, the value yielded by <code class="literal">str1.reverse</code> is assigned to <code class="literal">str1</code>. The yielded value is a new object, so <code class="literal">str1</code> is now assigned the reversed string (“olleh”), and it now has a new <code class="literal">object_id</code>.</p><p>Refer to the sample program <span class="emphasis"><em>concat.rb</em></span> for an example of the string concatenation method, <code class="literal">&lt;&lt;</code>, which, just like those methods that end with <code class="literal">!</code>, modifies the receiver object without creating a new object (once again, the actual <code class="literal">object_id</code> numbers may be different when you run the code):<a id="IDX-CHP-8-0027" class="indexterm"/></p><p><span class="emphasis"><em>concat.rb</em></span></p><a id="I_programlisting8_d1e10063"/><pre class="programlisting">str1 = "hello"          #object_id = 23033940
str2 = "world"          #object_id = 23033928
str3 = "goodbye"        #object_id = 23033916
str3 = str2 &lt;&lt; str1
puts( str1.object_id )  #=&gt; 23033940 # unchanged
puts( str2.object_id )  #=&gt; 23033928 # unchanged
puts( str3.object_id )  #=&gt; 23033928 # now the same as str2!</pre><p>In this example, <code class="literal">str1</code> is never modified, so it has the same <code class="literal">object_id</code> throughout; <code class="literal">str2</code> <span class="emphasis"><em>is</em></span> modified through concatenation. However, the <code class="literal">&lt;&lt;</code> operator does not create a new object, so <code class="literal">str2</code> also retains its original <code class="literal">object_id</code>.<a id="IDX-CHP-8-0028" class="indexterm"/><a id="IDX-CHP-8-0029" class="indexterm"/><a id="IDX-CHP-8-0030" class="indexterm"/><a id="IDX-CHP-8-0031" class="indexterm"/><a id="IDX-CHP-8-0032" class="indexterm"/></p><p>But <code class="literal">str3</code> is a different object at the end than at the beginning, because it is assigned the value yielded by this expression: <code class="literal">str2 &lt;&lt; str1</code>. This value happens to be the <code class="literal">str2</code> object itself, so the <code class="literal">object_id</code> of <code class="literal">str3</code> is now identical to that of <code class="literal">str2</code> (that is, <code class="literal">str2</code> and <code class="literal">str3</code> <span class="emphasis"><em>now reference the same object</em></span>).</p><p>In summary, then, methods ending with a <code class="literal">!</code> such as <code class="literal">reverse!</code>, plus some other methods such as the <code class="literal">&lt;&lt;</code> concatenation method, change the value of the receiver object. Most other methods do not change the value of the receiver object. To use any new value yielded as a result of calling one of these methods, you have to assign that value to a variable (or pass the yielded value as an argument to a method).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The fact that a few methods modify the receiver object whereas most do not may seem harmless enough, but beware: This behavior provides you with the ability to retrieve the values of arguments “by reference” rather than retrieving values that are explicitly returned. Doing so breaks encapsulation by allowing your code to rely upon the internal implementation details of a method. This can potentially lead to unpredictable side effects and, in my view, should be avoided.</p></div></div>
<div class="sect1" title="Potential Side Effects of Reliance on Argument Values"><div class="titlepage"><div><div><h1 class="title"><a id="potential_side_effects_of_reliance_on_ar"/>Potential Side Effects of Reliance on Argument Values</h1></div></div></div><p>For a simple (but, in real-world programming, potentially serious) example of how relying on the modified values of arguments rather than on explicit return values can introduce undesirable dependencies on implementation details, see <span class="emphasis"><em>side_effects.rb</em></span>. Here is a method called <code class="literal">stringProcess</code> that takes two string arguments, messes about with them, and returns the results:</p><p><span class="emphasis"><em>side_effects.rb</em></span></p><a id="I_programlisting8_d1e10169"/><pre class="programlisting">def stringProcess( aStr, anotherStr )
    aStr.capitalize!
    anotherStr.reverse!.capitalize!
    aStr = aStr +  " " + anotherStr.reverse!
    return aStr
end</pre><p>Let’s assume the object of the exercise is to take two lowercase strings and return a single string that combines these two strings, separated by a space and with the first and last letters capitalized. So, the two original strings might be “hello” and “world,” and the returned string is “Hello worlD.” This works fine:</p><a id="I_programlisting8_d1e10173"/><pre class="programlisting">str1 = "hello"
str2 = "world"
str3 = stringProcess( str1, str2 )
puts( "#{str3}" )    #=&gt; Hello worlD</pre><p>But now there is an impatient programmer who can’t be bothered with return values. He notices that the modifications made inside the method change the values of the ingoing arguments. So, heck! (he decides), he might as well use the arguments themselves! This is his version:</p><a id="I_programlisting8_d1e10177"/><pre class="programlisting">puts( "#{str1} #{str2}" ) #=&gt; Hello worlD</pre><p>By using the values of the input arguments, <code class="literal">str1</code> and <code class="literal">str2</code>, he has obtained the same result as if he had used the returned value, <code class="literal">str3</code>. He then goes away and writes a fabulously complicated text-processing system with thousands of bits of code reliant on the changed values of those two arguments.</p><p>But now the programmer who originally wrote the <code class="literal">stringProcess</code> method decides that the original implementation was inefficient or inelegant and so rewrites the code confident in the knowledge that the return value is unchanged (if “hello” and “world” are sent as arguments, “Hello worlD” is returned just as it was by the previous version):</p><a id="I_programlisting8_d1e10195"/><pre class="programlisting">def stringProcess( aStr, anotherStr )
    myStr = aStr.capitalize!
    anotherStr.reverse!.capitalize!
    myStr = myStr + " " + anotherStr.reverse
    return myStr
end

str1 = "hello"
str2 = "world"
str3 = stringProcess( str1, str2 )

puts( "#{str3}" )             #=&gt; Hello worlD
puts( "#{str1} #{str2}" )     #=&gt; Hello Dlrow</pre><p>Aha! But the new implementation causes the values of the input arguments to be changed inside the body of the method. So, the impatient programmer’s text-processing system, which relies on those <span class="emphasis"><em>arguments</em></span> rather than on the return value, is now filled with bits of text saying “hello Dlrow” instead of the “Hello worlD” he was expecting (actually, it turns out that his program was processing the works of Shakespeare, so a generation of actors will end up declaiming, “To eb or ton to eb, that si the noitseuq...”). This is the kind of unexpected side effect that can easily be avoided by following the one-way-in, one-way-out principle.</p></div>
<div class="sect1" title="Parallel Assignment"><div class="titlepage"><div><div><h1 class="title"><a id="parallel_assignment"/>Parallel Assignment</h1></div></div></div><p>I mentioned earlier that it is possible for a method to return multiple values, separated by commas. Often you will want to assign these returned values to a set of matching variables.<a id="IDX-CHP-8-0033" class="indexterm"/><a id="IDX-CHP-8-0034" class="indexterm"/></p><p>In Ruby, you can do this in a single operation by parallel assignment. This means you can have several variables to the left or an assignment operator and several values to the right. The values to the right will be assigned, in order, to the variables on the left, like this:<a id="IDX-CHP-8-0035" class="indexterm"/></p><p><span class="emphasis"><em>parallel_assign.rb</em></span></p><a id="I_programlisting8_d1e10226"/><pre class="programlisting">s1, s2, s3 = "Hickory", "Dickory", "Dock"</pre><p>This ability not only gives you a shortcut way to make multiple assignments; it also lets you swap the values of variables (you just change their orders on either side of the assignment operator):</p><a id="I_programlisting8_d1e10230"/><pre class="programlisting">i1 = 1
i2 = 2

i1, i2 = i2, i1        #=&gt; i1 is now 2, i2 is 1</pre><p>And you can make multiple assignments from the values returned by a method:</p><a id="I_programlisting8_d1e10234"/><pre class="programlisting">def returnArray( a, b, c )
    a = "Hello, " + a
    b = "Hi, " + b
    c = "Good day, " + c
    return a, b, c
end
x, y, z = returnArray( "Fred", "Bert", "Mary" )</pre><p>If you specify more variables to the left than there are values on the right of an assignment, any “trailing” variables will be assigned <code class="literal">nil</code>:</p><a id="I_programlisting8_d1e10241"/><pre class="programlisting">x, y, z, extravar = returnArray( "Fred", "Bert", "Mary" ) # extravar = nil</pre><p>Multiple values returned by a method are put into an array. When you put an array to the right of a multiple-variable assignment, its individual elements will be assigned to each variable, and once again if too many variables are supplied, the extra ones will be assigned <code class="literal">nil</code>:</p><a id="I_programlisting8_d1e10249"/><pre class="programlisting">s1, s2, s3 = ["Ding", "Dong", "Bell"]</pre><div class="sidebar"><a id="digging_deeper-id7"/><p class="title">Digging Deeper</p><p>In this section we look at some of the inner workings of parameter-passing and object equality. I also discuss the value of parentheses for code clarity.<a id="IDX-CHP-8-0036" class="indexterm"/><a id="IDX-CHP-8-0037" class="indexterm"/><a id="IDX-CHP-8-0038" class="indexterm"/><a id="IDX-CHP-8-0039" class="indexterm"/></p><p><span class="bolditalic">By Reference or By Value?</span></p><p>Earlier, I said that Ruby does not make a distinction between arguments that are passed “by value” and “by reference.” Even so, if you search the Internet, you’ll soon discover that Ruby programmers often get into arguments about how exactly arguments are passed. In many procedural programming languages such as Pascal or C, there is a clear distinction between arguments passed by value or by reference.<a id="IDX-CHP-8-0040" class="indexterm"/></p><p>A <span class="emphasis"><em>by value</em></span> argument is a <span class="emphasis"><em>copy</em></span> of the original variable; you can pass it to a function and mess around with it, and the value of the original variable remains unchanged.</p><p>A <span class="emphasis"><em>by reference</em></span> argument, on the other hand, is a <span class="emphasis"><em>pointer</em></span> to the original variable. When this gets passed to a procedure, you are not passing a new copy but a reference to the bit of memory in which the original data is stored. So, any changes made inside the procedure are made to the original data and necessarily affect the value of the original variable.</p><p>So, which way does Ruby pass arguments? It’s actually pretty easy to resolve this issue. If Ruby passes by value, then it makes a copy of the original variable, and that copy will therefore have a different <code class="literal">object_id</code>. In fact, this is not the case. Try the <span class="emphasis"><em>arg_passing.rb</em></span> program to prove this point.</p><p><span class="emphasis"><em>arg_passing.rb</em></span></p><a id="I_programlisting8_d1e10309"/><pre class="programlisting">def aMethod( anArg )
    puts( "#{anArg.object_id}\n\n" )
end

class MyClass
end


i = 10
f = 10.5
s = "hello world"
ob = MyClass.new


puts( "#{i}.object_id = #{i.object_id}" )
aMethod( i )
puts( "#{f}.object_id = #{f.object_id}" )
aMethod( f )
puts( "#{s}.object_id = #{s.object_id}" )
aMethod( s )
puts( "#{ob}.object_id = #{ob.object_id}" )
aMethod( ob )</pre><p>This prints out the object IDs of an integer, a floating-point number, a string, and a custom object both when they are originally declared and when they are passed as arguments to the <code class="literal">aMethod()</code> method. In each case, the ID of the argument is the same as the ID of the original variable, so the arguments must be passed by reference.<a id="IDX-CHP-8-0041" class="indexterm"/><a id="IDX-CHP-8-0042" class="indexterm"/></p><p>Now, it may well be that in certain circumstances the passing of arguments could, “behind the scenes” so to speak, be <span class="emphasis"><em>implemented</em></span> as “by value.” However, such implementation details should be of interest to writers of Ruby interpreters and compilers rather than to Ruby programmers. The plain fact of the matter is that if you program in a “pure” object-oriented way—by passing arguments into methods but only subsequently using the values that those methods return—the implementation details (by value or by reference) will be of no consequence to you.</p><p>Nevertheless, because Ruby can occasionally modify arguments (for example, using <code class="literal">!</code> methods or <code class="literal">&lt;&lt;</code>, as explained in <a class="xref" href="ch08s08.html" title="Modifying Receivers and Yielding New Objects">Modifying Receivers and Yielding New Objects</a> in <a class="xref" href="ch08s08.html" title="Modifying Receivers and Yielding New Objects">Modifying Receivers and Yielding New Objects</a>), some programmers have formed the habit of using the modified values of the arguments themselves (equivalent to using by reference arguments in C) rather than using the values returned. In my view, this is a bad practice. It makes your programs reliant upon the implementation details of methods and should, therefore, be avoided.</p><p><span class="bolditalic">Are Assignments Copies or References?</span></p><p>I said earlier that a new object is created when a value is <span class="emphasis"><em>yielded</em></span> by some expression. So, for example, if you assign a new value to a variable called <code class="literal">x</code>, the object after the assignment will be a different object from the one before the assignment (that is, it will have a different <code class="literal">object_id</code>):</p><a id="I_programlisting8_d1e10356"/><pre class="programlisting">x = 10      # this x has one object_id
x +=1       # and this x has a different one</pre><p>But it isn’t the assignment that creates a new object. It is the value that is yielded that causes a new object to be created. In the previous example, <code class="literal">+=1</code> is an expression that yields a value (<code class="literal">x+=1</code> is equivalent to the expression <code class="literal">x=x+1</code>).</p><p>Simple assignment of one variable to another does not create a new object. So, let’s assume you have one variable called <code class="literal">num</code> and another called <code class="literal">num2</code>. If you assign <code class="literal">num2</code> to <code class="literal">num</code>, both variables will refer to the same object. You can test this using the <code class="literal">equal?</code> method of the Object class:<a id="IDX-CHP-8-0043" class="indexterm"/></p><p><span class="emphasis"><em>assign_ref.rb</em></span></p><a id="I_programlisting8_d1e10393"/><pre class="programlisting">num = 11.5
num2 = 11.5

    # num and num 2 are not equal
puts( "#{num.equal?(num2)}" )    #=&gt; false

num = num2
    # but now they are equal
puts( "#{num.equal?(num2)}" )    #=&gt; true</pre><p><span class="bolditalic">Tests for Equality: == or equal?</span></p><p>By default (as defined in Ruby’s <code class="literal">Kernel</code> module), a test using <code class="literal">==</code> returns <code class="literal">true</code> when both objects being tested are the same object. So, it will return <code class="literal">false</code> if the values are the same but the objects are different:<a id="IDX-CHP-8-0044" class="indexterm"/><a id="IDX-CHP-8-0045" class="indexterm"/><a id="IDX-CHP-8-0046" class="indexterm"/><a id="IDX-CHP-8-0047" class="indexterm"/><a id="IDX-CHP-8-0048" class="indexterm"/><a id="IDX-CHP-8-0049" class="indexterm"/><a id="IDX-CHP-8-0050" class="indexterm"/></p><p><span class="emphasis"><em>equal_tests.rb</em></span></p><a id="I_programlisting8_d1e10444"/><pre class="programlisting">ob1 = Object.new
ob2 = Object.new
puts( ob1==ob2 ) #=&gt; false</pre><p>In fact, <code class="literal">==</code> is frequently overridden by classes such as String and will then return <code class="literal">true</code> when the values are the same but the objects are different:</p><a id="I_programlisting8_d1e10454"/><pre class="programlisting">s1 = "hello"
s2 = "hello"
puts( s1==s2 ) #=&gt; true</pre><p>For that reason, the <code class="literal">equal?</code> method is preferable when you want to establish whether two variables refer to the same object:<a id="IDX-CHP-8-0051" class="indexterm"/></p><a id="I_programlisting8_d1e10464"/><pre class="programlisting">puts( ob1.equal?(ob2) )    #=&gt; false
puts( s1.equal?(s2) )      #=&gt; false</pre><p><span class="bolditalic">When Are Two Objects Identical?</span></p><p>As a general rule, if you initialize 10 variables with 10 values, each variable will refer to a different object. For example, if you create two strings like this:</p><p><span class="emphasis"><em>identical.rb</em></span></p><a id="I_programlisting8_d1e10474"/><pre class="programlisting">s1 = "hello"
s2 = "hello"</pre><p>then <code class="literal">s1</code> and <code class="literal">s2</code> will refer to independent objects. The same goes for two floats:</p><a id="I_programlisting8_d1e10484"/><pre class="programlisting">f1 = 10.00
f2 = 10.00</pre><p>But, as mentioned earlier, integers are different. Create two integers with the same value, and they will end up referencing the same object:</p><a id="I_programlisting8_d1e10489"/><pre class="programlisting">i1 = 10
i2 = 10</pre><p>This is even true with literal integer values. If in doubt, use the <code class="literal">equals?</code> method to test whether two variables or values reference exactly the same object:</p><a id="I_programlisting8_d1e10496"/><pre class="programlisting">10.0.equal?(10.0) # compare floats - returns false
10.equal?(10)     # compare integers (Fixnums) - returns true</pre><p><span class="bolditalic">Parentheses Avoid Ambiguity</span></p><p>Methods may share the same name as local variables. For example, you might have a variable called <code class="literal">name</code> and a method called <code class="literal">name</code>. If it is your habit to call methods without parentheses, it may not be obvious whether you are referring to a method or a variable. Once again, parentheses avoid ambiguity:<a id="IDX-CHP-8-0052" class="indexterm"/><a id="IDX-CHP-8-0053" class="indexterm"/><a id="IDX-CHP-8-0054" class="indexterm"/><a id="IDX-CHP-8-0055" class="indexterm"/></p><p><span class="emphasis"><em>parentheses.rb</em></span></p><a id="I_programlisting8_d1e10528"/><pre class="programlisting">greet = "Hello"
name = "Fred"

def greet
    return "Good morning"
end

def name
    return "Mary"
end

def sayHi( aName )
    return "Hi, #{aName}"
end

puts( greet )                 #=&gt; Hello
puts greet                    #=&gt; Hello
puts greet()                  #=&gt; good morning
puts( sayHi( name ) )         #=&gt; Hi, Fred
puts( sayHi( name() ) )       #=&gt; Hi, Mary</pre></div></div></body></html>