["```\n  #!/usr/bin/env ruby    *ELS*\n  # els_parser.rb\n\n  require 'palindrome2.rb'\n  # I want all Strings to have the private letters_only\n  # method from this file.\n\n  class String\n\n  =begin rdoc\n  This provides a public method to access the private letters_only\n  method we required from palindrome2.rb.\n  =end\n    def just_letters(case_matters)\n❶     letters_only(case_matters)\n    end\n\n  end\n\n  =begin rdoc\n  A text-processing parser that does ASCII-only\n  Equidistant Letter Sequence analyses similar to that described\n  at http://en.wikipedia.org/wiki/Equidistant_letter_sequencing\n\n  For my example, I use Moby Dick taken from\n  Project Gutenberg, http://www.gutenberg.org.\n  =end\n  class ELS_Parser\n\n❷   DEFAULT_SEARCH_PARAMS = {\n      :start_pt => 4500,\n      :end_pt   => nil, # assumes the end of the String to search when nil\n      :min_skip => 126995,\n      :max_skip => 127005,\n      :term     => 'ssirhan',\n    }\n\n    def initialize(filename, search_params=nil)\n      @contents = prepare(filename)\n      @filename = filename\n      reset_params(search_params || DEFAULT_SEARCH_PARAMS)\n    end\n\n    def reset_params(search_params)\n      @search_params            = search_params\n      @search_params[:end_pt] ||= (@contents.size-1)\n      # ||= for :end_pt allows nil for 'end of file'\n      return self # return self so we can chain methods\n    end\n\n  =begin rdoc\n  Performs an ELS analysis on the <i>filename</i> argument, searching for\n  the term argument, falling back to the default.\n  =end\n❸   def search(term=@search_params[:term])\n      @search_params[:term] = term\n      reversed_term = term.reverse\n      warn \"Starting search within #{@filename} \" +    ***`$DEBUG`***\n        \"using #{@search_params.inspect}\" if ($DEBUG)\n❹     final_start_pt = @search_params[:end_pt] - @search_params[:term].size\n      @search_params[:start_pt].upto(final_start_pt) do |index|\n        @search_params[:min_skip].upto(@search_params[:max_skip]) do |skip|\n❺         candidate = construct_candidate(index, skip)\n\n❻         if (candidate == @search_params[:term])\n            return report_match(skip, index)\n          end\n\n          if (candidate == reversed_term)\n            return report_match(skip, index, 'reversed ')\n          end\n\n        end\n      end\n❼     return report_match(false, false)\n    end\n\n    private\n\n❽   def construct_candidate(index, skip)\n      output = ''\n      0.upto(@search_params[:term].size-1) do |char_index|\n        new_index = (index + (char_index * (skip + 1)))\n        return '' if (new_index >= @contents.size)\n        output += @contents[new_index].chr    *The **`chr`** Method*\n      end\n      return output\n    end\n\n  =begin rdoc\n  Creates a 'letters only' version of the contents of a <i>filename</i>\n  argument in preparation for ELS analysis. Assumes case-insensitivity.\n  =end\n❾   def prepare(filename, case_matters=false)\n      File.open(filename, 'r').readlines.to_s.just_letters(case_matters)\n    end\n\n  =begin\n  Either report the variables at which a match was found, or report\n  failure for this set of search params.\n  =end\n❿   def report_match(skip, index, reversed='')\n      return \"No match within #{@filename} using \" +\n        @search_params.inspect unless index\n      return \"Match for #{@search_params[:term]} \" +\n        \"#{reversed}within #{@filename} \" +\n        \"at index #{index}, using skip #{skip}\"\n    end\n\n  end # ELS_Parser\n```", "```\nirb(main):001:0> s = 'abcde'\n=> \"abcde\"\nirb(main):002:0> s[0]\n=> 97\nirb(main):003:0> s[0].chr\n=> \"a\"\n```", "```\n#!/usr/bin/env ruby\n# demo_els_parser.rb\n\nrequire 'els_parser.rb'\n\nmoby_dick = ELS_Parser.new('extras/moby_dick.txt')\nputs moby_dick.search() # assumes 'ssirhan'\nputs moby_dick.reset_params( {\n  :start_pt => 93060,\n  :end_pt   => nil, # assumes 'to the end'\n  :min_skip => 13790,\n  :max_skip => 13800,\n  :term     => 'kennedy'\n} ).search()\nputs moby_dick.reset_params( {\n  :start_pt => 327400,\n  :end_pt   => nil, # 'to the end' again\n  :min_skip => 0,\n  :max_skip => 5,\n  :term     => 'rabin'\n} ).search()\nputs moby_dick.reset_params( {\n  :start_pt => 104620,\n  :end_pt   => 200000, # not to the end\n  :min_skip => 26020,\n  :max_skip => 26030,\n  :term     => 'mlking'\n} ).search()\n```", "```\nruby -w --debug demo_els_parser.rb\nStarting search within extras/moby_dick.txt using {:end_pt=>924955,\n:min_skip=>126995, :max_skip=>127005, :term=>\"ssirhan\", :start_pt=>4500}\nMatch for ssirhan within extras/moby_dick.txt at index 4546, using skip 126999\nStarting search within extras/moby_dick.txt using {:end_pt=>924955,\n:min_skip=>13790, :max_skip=>13800, :term=>\"kennedy\", :start_pt=>93060}\nMatch for kennedy within extras/moby_dick.txt at index 93062, using skip 13797\nStarting search within extras/moby_dick.txt using {:end_pt=>924955,\n:min_skip=>0, :max_skip=>5, :term=>\"rabin\", :start_pt=>327400}\nMatch for rabin reversed within extras/moby_dick.txt at index 327500, using\nskip 3\nStarting search within extras/moby_dick.txt using {:end_pt=>200000,\n:min_skip=>26020, :max_skip=>26030, :term=>\"mlking\", :start_pt=>104620}\nMatch for mlking reversed within extras/moby_dick.txt at index 104629, using\nskip 26025\n```", "```\n  #!/usr/bin/env ruby\n  # methinks.rb\n\n  =begin rdoc\n  Recreate Richard Dawkins' Blind Watchmaker program, in which a purely\n  random string is mutated and filtered until it matches the target string.\n  =end\n\n❶ class Children < Array    *Inheritance*\n\n    def select_fittest(target)\n      inject(self[0]) do |fittest,child|\n        child.fitter_than?(fittest, target) ? child : fittest\n      end\n    end\n\n  end\n\n❷ class String\n\n    ALPHABET = ('a'..'z').to_a\n\n    LETTER_OFFSET = 'a'[0]\n\n    PARAMS = {\n      :generation_size => 20,\n      :mutation_rate   => 10,\n      :display_filter  => 5,\n      :mutation_amp    => 6\n    }\n\n    TARGET = 'methinksitislikeaweasel'\n\n    @mutation_attempts ||= 0\n\n❸   def deviance_from(target)    *Differences between Strings*\n      deviance = 0\n      split('').each_index do |index|\n        deviance += (self[index] - target[index]).abs\n      end\n      return deviance\n    end\n\n    def fitter_than?(other, target)\n      deviance_from(target) < other.deviance_from(target)\n    end\n\n❹   def mutate(params)\n      split('').map do |char|\n        mutate_char(char, params)\n      end.join('')\n    end\n\n❺   def mutate_until_matches!(target=TARGET, params=PARAMS)\n      return report_success if (self == target)\n      report_progress(params)\n      @mutation_attempts += 1\n      children = propagate(params)\n      fittest  = children.select_fittest(target)\n      replace(fittest)\n      mutate_until_matches!(target, params)\n    end\n\n❻   def propagate(params)\n      children = Children.new()\n      children << self\n      params[:generation_size].times do |generation|\n        children << self.mutate(params)\n      end\n      return children\n    end\n\n❼   def report_progress(params)\n      return unless (@mutation_attempts % params[:display_filter] == 0)\n      puts \"string ##{@mutation_attempts} = #{self}\"\n    end\n\n    def report_success()\n      puts <<END_OF_HERE_DOC\n  I match after #{@mutation_attempts} mutations\n  END_OF_HERE_DOC\n      return @mutation_attempts\n    end\n\n  =begin rdoc\n  Replace self with a <b>String</b> the same length as the\n  <i>target</i> argument, consisting entirely of lowercase\n  letters.\n  =end\n❽   def scramble!(target=TARGET)\n      @mutation_attempts = 0\n      replace( scramble(target) )\n    end\n\n    def scramble(target=TARGET)\n      target.split('').map do |char|\n        ALPHABET[rand(ALPHABET.size)]\n      end.join('')\n    end\n\n    private\n\n  =begin rdoc\n  Limit 'out of bounds' indices at end points of the ALPHABET.\n  =end\n❾   def limit_index(alphabet_index)\n      alphabet_index = [ALPHABET.size-1,  alphabet_index].min\n      alphabet_index = [alphabet_index, 0].max\n      return alphabet_index\n    end\n\n❿   def mutate_char(original_char, params)\n      return original_char if rand(100) > params[:mutation_rate]\n      variance = rand(params[:mutation_amp]) - (params[:mutation_amp] / 2)\n      # variance with amp of 6 now ranges from -3 to 2,\n      variance += 1 if variance.zero? # therefore move (0..2) up to (1..3)\n      alphabet_index = (original_char[0] + variance - LETTER_OFFSET)\n      alphabet_index = limit_index(alphabet_index)\n      mutated_char = ALPHABET[alphabet_index]\n      return mutated_char\n    end\n\n  end\n```", "```\n$ irb -r methinks.rb\nirb(main):001:0> a = Array.new\n=> []\nirb(main):002:0> c = Children.new\n=> []\nirb(main):003:0> a.class\n=> Array\nirb(main):004:0> c.class\n=> Children\n```", "```\nirb(main):001:0> s = 'abcde'\n=> \"abcde\"\nirb(main):002:0> s[0]\n=> 97\nirb(main):003:0> s[0].chr\n=> \"a\"\nirb(main):004:0> 'a'[0]\n=> 97\nirb(main):005:0> s[1]\n=> 98\n```", "```\nirb(main):001:0> letters = ('a'..'z').to_a\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n\"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\nirb(main):002:0> 's'[0]\n=> 115\nirb(main):003:0> 's'[0] - 'a'[0]\n=> 18\nirb(main):004:0> letters[18]\n=> \"s\"\n```", "```\nirb -r methinks.rb\nirb(main):001:0> 'aaa'.deviance_from('aaa')\n=> 0\nirb(main):002:0> 'aaa'.deviance_from('aab')\n=> 1\nirb(main):003:0> 'aaa'.deviance_from('aac')\n=> 2\nirb(main):004:0> 'aaa'.deviance_from('bac')\n=> 3\nirb(main):005:0> 'aaa'.deviance_from('baq')\n=> 17\n```", "```\nirb -r methinks.rb\nirb(main):001:0> candidate = String.new.scramble!()\n=> \"rnvrtdldcgaxlsleyrmzych\"\nirb(main):002:0> candidate.mutate_until_matches!()\n```", "```\nstring #0 = rnvrtdldcgaxlsleyrmzych\nstring #5 = okvpqekfcicsnsleysmzsci\nstring #10 = pkvnnekhdkdslrjeztmvseh\nstring #15 = pkvjnekjfmgslrjeytjrsei\nstring #20 = plvflekjhmislljettjosel\nstring #25 = oisfmejkimisllkeqtjlsel\nstring #30 = mfsgmgjnimislkkeotgjsel\nstring #35 = mfsglgjqimislkkeivfhsel\nstring #40 = mesgigkqiriskhleivffsel\nstring #45 = mesgikkqirislhleivfasel\nstring #50 = mesgikkqirislhkegvfasel\nstring #55 = metiilksitislhkegvfasem\nstring #60 = metiilksitislhkefvfasem\nstring #65 = meshinlsitislhkeaweasel\nstring #70 = methinlsitislhkeaweasel\nstring #75 = methinlsitislhkeaweasel\nstring #80 = methinlsitislikeaweasel\nstring #85 = methinlsitislikeaweasel\nstring #90 = methinlsitislikeaweasel\nstring #95 = methinlsitislikeaweasel\nstring #100 = methinlsitislikeaweasel\nstring #105 = methinlsitislikeaweasel\nstring #110 = methinlsitislikeaweasel\nstring #115 = methinlsitislikeaweasel\nstring #120 = methinlsitislikeaweasel\nstring #125 = methinlsitislikeaweasel\nstring #130 = methinlsitislikeaweasel\nstring #135 = methinlsitislikeaweasel\nstring #140 = methinlsitislikeaweasel\nstring #145 = methinlsitislikeaweasel\nstring #150 = methinlsitislikeaweasel\nI match after 152 mutations\n=> 152\n```", "```\nirb(main):005:0> candidate = String.new.scramble!('hello')\n=> \"wnwdi\"\nirb(main):006:0> candidate.mutate_until_matches!('hello')\nstring #0 = wnwdi\nstring #5 = onsdj\nstring #10 = lnpgj\nstring #15 = ijlkj\nstring #20 = hemlj\nstring #25 = hemll\nstring #30 = hemlo\nI match after 34 mutations\n=> 34\n```", "```\nreturn sort_by do |child|\n  child.deviance_from(target)\nend[0]\n```", "```\nreturn [self] +\n  (1..params[:generation_size]).to_a.map do |gen|\n    self.mutate(params)\n  end\n```", "```\n  #!/usr/bin/env ruby\n  # methinks_meta.rb\n\n❶ require 'methinks'\n\n  class Hash\n\n❷   def get_child()\n      new_hash = {}\n      each_pair do |k,v|\n        new_hash[k] = (rand(v) + (v/2))\n      end\n      new_hash[:display_filter] = 5\n      return new_hash\n    end\n\n  end # Hash\n\n  ###\n\n❸ class Meta_Mutator\n\n    NEW_TARGET   = 'ruby'\n    MAX_ATTEMPTS = 2\n    TARGET = NEW_TARGET || String::TARGET\n\n    def initialize()\n      @params_by_number_of_mutations = {}\n    end\n\n❹   def mutate_mutations!(params, did_no_better_count=0)\n      return if did_no_better_count > MAX_ATTEMPTS\n\n      num = update_params_by_number_of_mutations!(params)\n\n      return mutate_mutations!(\n        @params_by_number_of_mutations[best_num],\n        get_no_better_count(num, did_no_better_count)\n      )\n\n    end\n\n❺   def report()\n      @params_by_number_of_mutations.sort.each do |pair|\n        num, params = pair\n        puts sprintf(\"%0#{digits_needed}d\", num) +\n          \" generations with #{params.inspect}\"\n      end\n    end\n\n    private\n\n❻   def best_num()\n      @params_by_number_of_mutations.keys.sort[0] || nil\n    end\n\n❼   def digits_needed()\n      @params_by_number_of_mutations.keys.max.to_s.size\n    end\n\n❽   def get_children(params, number_of_children = 10)\n      (0..number_of_children).to_a.map do |i|\n        params.get_child()\n      end\n    end\n\n❾   def get_no_better_count(num, did_no_better_count)\n      return did_no_better_count if (num == best_num)\n      did_no_better_count + 1\n    end\n\n❿   def update_params_by_number_of_mutations!(params)\n      children = get_children(params)\n      number_of_mutations = nil\n      children.each do |params|\n        candidate = String.new.scramble!(TARGET)\n        number_of_mutations = candidate.mutate_until_matches!(TARGET, params)\n        @params_by_number_of_mutations[number_of_mutations] = params.dup\n      end\n      return number_of_mutations\n    end\n\n  end # Meta_Mutator\n\n  ###\n\n  params = {\n    :generation_size => 200,\n    :mutation_rate   => 30,\n    :display_filter  => 5,\n    :mutation_amp    => 7\n  }\n\n  mm = Meta_Mutator.new()\n  mm.mutate_mutations!(params)\n  mm.report()\n```", "```\n$ ruby -w methinks_meta.rb\n```", "```\nstring #0 = onfi\nstring #5 = ppbm\nstring #10 = rtbq\nstring #15 = rubv\nI match after 18 mutations\nstring #0 = tfjc\nstring #5 = uuar\nI match after 9 mutations\nstring #0 = qmsi\nstring #5 = rqln\nstring #10 = rugv\nI match after 13 mutations\nstring #0 = yuqa\nstring #5 = uupf\n... (several lines removed)...\nstring #0 = umsv\nstring #5 = rupy\nI match after 10 mutations\nstring #0 = vclv\nstring #5 = rlay\nI match after 8 mutations\n04 generations with {:generation_size=>243, :mutation_rate=>25,\n:mutation_amp=>11, :display_filter=>5}\n08 generations with {:generation_size=>251, :mutation_rate=>28,\n:mutation_amp=>7, :display_filter=>5}\n09 generations with {:generation_size=>234, :mutation_rate=>31,\n:mutation_amp=>10, :display_filter=>5}\n10 generations with {:generation_size=>112, :mutation_rate=>15,\n:mutation_amp=>7, :display_filter=>5}\n11 generations with {:generation_size=>162, :mutation_rate=>26,\n:mutation_amp=>7, :display_filter=>5}\n12 generations with {:generation_size=>118, :mutation_rate=>30,\n:mutation_amp=>5, :display_filter=>5}\n13 generations with {:generation_size=>100, :mutation_rate=>24,\n:mutation_amp=>3, :display_filter=>5}\n14 generations with {:generation_size=>191, :mutation_rate=>29,\n:mutation_amp=>5, :display_filter=>5}\n15 generations with {:generation_size=>146, :mutation_rate=>22,\n:mutation_amp=>8, :display_filter=>5}\n17 generations with {:generation_size=>161, :mutation_rate=>14,\n:mutation_amp=>7, :display_filter=>5}\n18 generations with {:generation_size=>112, :mutation_rate=>18,\n:mutation_amp=>3, :display_filter=>5}\n22 generations with {:generation_size=>277, :mutation_rate=>40,\n:mutation_amp=>4, :display_filter=>5}\n24 generations with {:generation_size=>112, :mutation_rate=>41,\n:mutation_amp=>4, :display_filter=>5}\n27 generations with {:generation_size=>120, :mutation_rate=>24,\n:mutation_amp=>3, :display_filter=>5}\n36 generations with {:generation_size=>140, :mutation_rate=>17,\n:mutation_amp=>4, :display_filter=>5}\n```", "```\ndef inspect()\n  '{' + keys.sort_by do |k|\n    k.inspect\n  end.map do |k|\n    \"#{k.inspect} => #{self[k].inspect}\"\n  end.join(', ') + '}'\nend\n```"]