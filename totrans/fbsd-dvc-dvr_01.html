<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building and Running Modules"><div class="titlepage"><div><div><h1 class="title"><a id="building_and_running_modules"/>Chapter 1. Building and Running Modules</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id1"/><div class="mediaobject"><a id="I_mediaobject1_d1e341"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>This chapter provides an introduction to FreeBSD device drivers. We’ll start by describing the four different types of UNIX device drivers and how they are represented in FreeBSD. We’ll then describe the basics of building and running loadable kernel modules, and we’ll finish this chapter with an introduction to character drivers.<a class="indexterm" id="IDX-CHP-1-0001"/><a class="indexterm" id="IDX-CHP-1-0002"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you don’t understand some of the terms used above, don’t worry; we’ll define them all in this chapter.</p></div><div class="sect1" title="Types of Device Drivers"><div class="titlepage"><div><div><h1 class="title"><a id="types_of_device_drivers"/>Types of Device Drivers</h1></div></div></div><p>In FreeBSD, a <span class="emphasis"><em>device</em></span> is any hardware-related item that belongs to the system; this includes disk drives, printers, video cards, and so on. A <span class="emphasis"><em>device driver</em></span> is a computer program that controls or “drives” a device (or sometimes numerous devices). In UNIX and pre-4.0 FreeBSD, there are four different types of device drivers:<a class="indexterm" id="IDX-CHP-1-0003"/><a class="indexterm" id="IDX-CHP-1-0004"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Character drivers, which control character devices<a class="indexterm" id="IDX-CHP-1-0005"/></p></li><li class="listitem"><p>Block drivers, which control block devices<a class="indexterm" id="IDX-CHP-1-0006"/></p></li><li class="listitem"><p>Network drivers, which control network devices<a class="indexterm" id="IDX-CHP-1-0007"/></p></li><li class="listitem"><p>Pseudo-device drivers, which control pseudo-devices<a class="indexterm" id="IDX-CHP-1-0008"/></p></li></ul></div><p><span class="emphasis"><em>Character devices</em></span> provide either a character-stream-oriented I/O interface or, alternatively, an unstructured (raw) interface (McKusick and Neville-Neil, 2005).</p><p><span class="emphasis"><em>Block devices</em></span> transfer randomly accessible data in fixed-size blocks (Corbet et al., 2005). In FreeBSD 4.0 and later, block drivers are gone (for more information on this, See <a class="xref" href="ch01s07.html" title="Block Drivers Are Gone">Block Drivers Are Gone</a> in <a class="xref" href="ch01s06.html#dev_underscore_module_macro" title="DEV_MODULE Macro">DEV_MODULE Macro</a>).</p><p><span class="emphasis"><em>Network devices</em></span> transmit and receive data packets that are driven by the network subsystem (Corbet et al., 2005).</p><p>Finally, a <span class="emphasis"><em>pseudo-device</em></span> is a computer program that emulates the behavior of a device using only software (that is, without any underlying hardware).</p></div></div>
<div class="sect1" title="Loadable Kernel Modules"><div class="titlepage"><div><div><h1 class="title"><a id="loadable_kernel_modules"/>Loadable Kernel Modules</h1></div></div></div><p>A device driver can be either statically compiled into the system or dynamically loaded using a loadable kernel module (KLD).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Most operating systems call a loadable kernel module an <span class="emphasis"><em>LKM</em></span>—FreeBSD just had to be different.</p></div><p>A <span class="emphasis"><em>KLD</em></span> is a kernel subsystem that can be loaded, unloaded, started, and stopped after bootup. In other words, a KLD can add functionality to the kernel and later remove said functionality while the system is running. Needless to say, our “functionality” will be device drivers.</p><p>In general, two components are common to all KLDs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A module event handler</p></li><li class="listitem"><p>A <code class="literal">DECLARE_MODULE</code> macro call</p></li></ul></div><div class="sect2" title="Module Event Handler"><div class="titlepage"><div><div><h2 class="title"><a id="module_event_handler"/>Module Event Handler</h2></div></div></div><p>A <span class="emphasis"><em>module event handler</em></span> is the function that handles the initialization and shutdown of a KLD. This function is executed when a KLD is loaded into the kernel or unloaded from the kernel, or when the system is shut down. Its function prototype is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e465"/><pre class="programlisting">typedef int (*modeventhand_t)(module_t, int /* <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>modeventtype_t */, void *);</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e475"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">modeventtype_t</code> is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header like so:</p><a id="I_programlisting1_d1e487"/><pre class="programlisting">typedef enum modeventtype {
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>MOD_LOAD,       /* Set when module is loaded. */
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>MOD_UNLOAD,     /* Set when module is unloaded. */
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>MOD_SHUTDOWN,   /* Set on shutdown. */
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>MOD_QUIESCE     /* Set when module is about to be unloaded. */
} modeventtype_t;</pre><p>As you can see, <code class="literal">modeventtype_t</code> labels whether the KLD is being <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e518"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> loaded into the kernel or <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e524"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> unloaded from the kernel, or whether the system is about to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e530"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> shut down. (For now, ignore the value at <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e536"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span>; we’ll discuss it in <a class="xref" href="ch04.html" title="Chapter 4. Thread Synchronization">Chapter 4</a>.)<a class="indexterm" id="IDX-CHP-1-0009"/><a class="indexterm" id="IDX-CHP-1-0010"/></p><p>Generally, you’d use the <code class="literal">modeventtype_t</code> argument in a <code class="literal">switch</code> statement to set up different code blocks for each situation. Some example code should help clarify what I mean:</p><a id="I_programlisting1_d1e559"/><pre class="programlisting">static int
modevent(module_t mod __unused, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>event, void *arg __unused)
{
        int error = 0;

        switch (<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>event) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>case MOD_LOAD:
                uprintf("Hello, world!\n");
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>case MOD_UNLOAD:
                uprintf("Good-bye, cruel world!\n");
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>default:
                error = EOPNOTSUPP;
                break;
        }

        return (error);
}</pre><p>Notice how the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e593"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> second argument is the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e599"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> expression for the <code class="literal">switch</code> statement. Thus, this module event handler prints “Hello, world!” when the KLD is <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e608"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> loaded into the kernel, prints “Good-bye, cruel world!” when the KLD is <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e614"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> unloaded from the kernel, and returns <code class="literal">EOPNOTSUPP</code> (which stands for <span class="emphasis"><em>error: operation not supported</em></span>) prior to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e627"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> system shutdown.</p></div><div class="sect2" title="DECLARE_MODULE Macro"><div class="titlepage"><div><div><h2 class="title"><a id="declare_underscore_module_macro"/>DECLARE_MODULE Macro</h2></div></div></div><p>The <code class="literal">DECLARE_MODULE</code> macro registers a KLD and its module event handler with the system. Here is its function prototype:</p><a id="I_programlisting1_d1e641"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/module.h&gt;

DECLARE_MODULE(name, moduledata_t data, sub, order);</pre><p>The arguments expected by this macro are as follows.</p><div class="sect3" title="name"><div class="titlepage"><div><div><h3 class="title"><a id="name"/>name</h3></div></div></div><p>The <code class="literal">name</code> argument is the module name, which is used to identify the KLD.<a class="indexterm" id="IDX-CHP-1-0011"/><a class="indexterm" id="IDX-CHP-1-0012"/><a class="indexterm" id="IDX-CHP-1-0013"/><a class="indexterm" id="IDX-CHP-1-0014"/><a class="indexterm" id="IDX-CHP-1-0015"/><a class="indexterm" id="IDX-CHP-1-0016"/><a class="indexterm" id="IDX-CHP-1-0017"/><a class="indexterm" id="IDX-CHP-1-0018"/><a class="indexterm" id="IDX-CHP-1-0019"/><a class="indexterm" id="IDX-CHP-1-0020"/><a class="indexterm" id="IDX-CHP-1-0021"/><a class="indexterm" id="IDX-CHP-1-0022"/><a class="indexterm" id="IDX-CHP-1-0023"/><a class="indexterm" id="IDX-CHP-1-0024"/><a class="indexterm" id="IDX-CHP-1-0025"/><a class="indexterm" id="IDX-CHP-1-0026"/><a class="indexterm" id="IDX-CHP-1-0027"/></p></div><div class="sect3" title="data"><div class="titlepage"><div><div><h3 class="title"><a id="data"/>data</h3></div></div></div><p>The <code class="literal">data</code> argument expects a filled-out <code class="literal">moduledata_t</code> structure, which is defined in the <code class="literal">&lt;sys/module.h&gt;</code> header as follows:</p><a id="I_programlisting1_d1e747"/><pre class="programlisting">typedef struct moduledata {
        const char      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*name;
        modeventhand_t  <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>evhand;
        void            <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*priv;
} moduledata_t;</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e769"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">name</code> is the official module name, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e778"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">evhand</code> is the KLD’s module event handler, and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e787"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">priv</code> is a pointer to private data (if any exists).</p></div><div class="sect3" title="sub"><div class="titlepage"><div><div><h3 class="title"><a id="sub"/>sub</h3></div></div></div><p>The <code class="literal">sub</code> argument specifies the kernel subsystem that the KLD belongs in. Valid values for this argument are defined in the <code class="literal">sysinit_sub_id</code> enumeration, found in <code class="literal">&lt;sys/kernel.h&gt;</code>.</p><a id="I_programlisting1_d1e811"/><pre class="programlisting">enum sysinit_sub_id {
        SI_SUB_DUMMY            = 0x0000000,    /* Not executed.        */
        SI_SUB_DONE             = 0x0000001,    /* Processed.           */
        SI_SUB_TUNABLES         = 0x0700000,    /* Tunable values.      */
        SI_SUB_COPYRIGHT        = 0x0800001,    /* First console use.   */
        SI_SUB_SETTINGS         = 0x0880000,    /* Check settings.      */
        SI_SUB_MTX_POOL_STATIC  = 0x0900000,    /* Static mutex pool.   */
        SI_SUB_LOCKMGR          = 0x0980000,    /* Lock manager.        */
        SI_SUB_VM               = 0x1000000,    /* Virtual memory.      */
...
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>SI_SUB_DRIVERS          = 0x3100000,     /* Device drivers.      */
...
};</pre><p>For obvious reasons, we’ll almost always set <code class="literal">sub</code> to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e824"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">SI_SUB_DRIVERS</code>, which is the device driver subsystem.</p></div><div class="sect3" title="order"><div class="titlepage"><div><div><h3 class="title"><a id="order"/>order</h3></div></div></div><p>The <code class="literal">order</code> argument specifies the KLD’s order of initialization within the <code class="literal">sub</code> subsystem. Valid values for this argument are defined in the <code class="literal">sysinit_elem_order</code> enumeration, found in <code class="literal">&lt;sys/kernel.h&gt;</code>.</p><a id="I_programlisting1_d1e850"/><pre class="programlisting">enum sysinit_elem_order {
        SI_ORDER_FIRST          = 0x0000000,    /* First.               */
        SI_ORDER_SECOND         = 0x0000001,    /* Second.              */
        SI_ORDER_THIRD          = 0x0000002,    /* Third.               */
        SI_ORDER_FOURTH         = 0x0000003,    /* Fourth.              */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>SI_ORDER_MIDDLE         = 0x1000000,    /* Somewhere in the middle. */
        SI_ORDER_ANY            = 0xfffffff     /* Last.                    */
};</pre><p>In general, we’ll always set <code class="literal">order</code> to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e863"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">SI_ORDER_MIDDLE</code>.<a class="indexterm" id="IDX-CHP-1-0028"/><a class="indexterm" id="IDX-CHP-1-0029"/></p></div></div></div>
<div class="sect1" title="Hello, world!"><div class="titlepage"><div><div><h1 class="title"><a id="hello_comma_world_exclamation"/>Hello, world!</h1></div></div></div><p>You now know enough to write your first KLD. <a class="xref" href="ch01s03.html#hello.c" title="Example 1-1. hello.c">Example 1-1</a> is the complete skeleton code for a KLD.</p><div class="example"><a id="hello.c"/><p class="title">Example 1-1. hello.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> hello_modevent(module_t mod __unused, int event, void *arg __unused)
  {
          int error = 0;

          switch (event) {
          case MOD_LOAD:
                  uprintf("Hello, world!\n");
                  break;
          case MOD_UNLOAD:
                  uprintf("Good-bye, cruel world!\n");
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> static moduledata_t hello_mod = {
          "hello",
          hello_modevent,
          NULL
  };

<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/> DECLARE_MODULE(hello, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>hello_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);</pre></div></div><p>This code contains a <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e918"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> module event handler—it’s identical to the one described in <a class="xref" href="ch01s02.html#module_event_handler" title="Module Event Handler">Module Event Handler</a> in <a class="xref" href="ch01s02.html" title="Loadable Kernel Modules">Loadable Kernel Modules</a>—and a filled-out <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e928"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">moduledata_t</code> structure, which is passed as the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e938"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> second argument to the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e944"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">DECLARE_MODULE</code> macro.</p><p>In short, this KLD is just a module event handler and a <code class="literal">DECLARE_MODULE</code> call. Simple, eh?</p></div>
<div class="sect1" title="Compiling and Loading"><div class="titlepage"><div><div><h1 class="title"><a id="compiling_and_loading"/>Compiling and Loading</h1></div></div></div><p>To compile a KLD, you can use the <code class="literal">&lt;bsd.kmod.mk&gt;</code> Makefile. Here is the complete Makefile for <a class="xref" href="ch01s03.html#hello.c" title="Example 1-1. hello.c">Example 1-1</a>:<a class="indexterm" id="IDX-CHP-1-0030"/><a class="indexterm" id="IDX-CHP-1-0031"/><a class="indexterm" id="IDX-CHP-1-0032"/><a class="indexterm" id="IDX-CHP-1-0033"/><a class="indexterm" id="IDX-CHP-1-0034"/><a class="indexterm" id="IDX-CHP-1-0035"/></p><a id="I_programlisting1_d1e990"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> KMOD=   hello
<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> SRCS=   hello.c

  .include &lt;bsd.kmod.mk&gt;</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1005"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">KMOD</code> is the KLD’s name and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1014"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">SRCS</code> is the KLD’s source files. Incidentally, I’ll adapt this Makefile to compile every KLD.</p><p>Now, assuming <a class="xref" href="ch01s03.html#hello.c" title="Example 1-1. hello.c">Example 1-1</a> and its Makefile are in the same directory, simply type <code class="literal">make</code>, and the compilation should proceed (very verbosely) and produce an executable named <span class="emphasis"><em>hello.ko</em></span>, as shown here:</p><a id="I_programlisting1_d1e1033"/><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
Warning: Object directory not changed from original /usr/home/ghost/hello
@ -&gt; /usr/src/sys
machine -&gt; /usr/src/sys/i386/include
cc -O2 -fno-strict-aliasing -pipe  -D_KERNEL -DKLD_MODULE -std=c99 -nostdinc
-I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 -
-param large-function-growth=1000 -fno-common  -mno-align-long-strings -mpref
erred-stack-boundary=2  -mno-mmx -mno-3dnow -mno-sse -mno-sse2 -mno-sse3 -ffr
eestanding -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmi
ssing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-s
ign -fformat-extensions -c hello.c
ld  -d -warn-common -r -d -o hello.kld hello.o
:&gt; export_syms
awk -f /sys/conf/kmod_syms.awk hello.kld  export_syms | xargs -J% objcopy % h
ello.kld
ld -Bshareable  -d -warn-common -o hello.ko hello.kld
objcopy --strip-debug hello.ko
$ <strong class="userinput"><code>ls -F</code></strong>
@@           export_syms  hello.kld    hello.o
Makefile     hello.c      hello.ko*    machine@</pre><p>You can then load and unload <span class="emphasis"><em>hello.ko</em></span> with <code class="literal">kldload(8)</code> and <code class="literal">kldunload(8)</code>, respectively:</p><a id="I_programlisting1_d1e1052"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./hello.ko</code></strong>
Hello, world!
$ <strong class="userinput"><code>sudo kldunload hello.ko</code></strong>
Good-bye, cruel world!</pre><p>As an aside, with a Makefile that includes <code class="literal">&lt;bsd.kmod.mk&gt;</code>, you can use <code class="literal">make load</code> and <code class="literal">make unload</code> instead of <code class="literal">kldload(8)</code> and <code class="literal">kldunload(8)</code>, as shown here:</p><a id="I_programlisting1_d1e1077"/><pre class="programlisting">$ <strong class="userinput"><code>sudo make load</code></strong>
/sbin/kldload -v /usr/home/ghost/hello/hello.ko
Hello, world!
Loaded /usr/home/ghost/hello/hello.ko, id=3
$ <strong class="userinput"><code>sudo make unload</code></strong>
/sbin/kldunload -v hello.ko
Unloading hello.ko, id=3
Good-bye, cruel world!</pre><p>Congratulations! You’ve now successfully loaded code into a live kernel. Before moving on, one additional point is also worth mentioning. You can display the status of any file dynamically linked into the kernel using <code class="literal">kldstat(8)</code>, like so:<a class="indexterm" id="IDX-CHP-1-0036"/><a class="indexterm" id="IDX-CHP-1-0037"/><a class="indexterm" id="IDX-CHP-1-0038"/></p><a id="I_programlisting1_d1e1106"/><pre class="programlisting">$ <strong class="userinput"><code>kldstat</code></strong>
Id Refs Address    Size     Name
 1    4 0xc0400000 906518   kernel
 2    1 0xc0d07000 6a32c    acpi.ko
 3    1 0xc3301000 2000     hello.ko</pre><p>As you can see, the output is pretty self-explanatory. Now, let’s do something more interesting.</p></div>
<div class="sect1" title="Character Drivers"><div class="titlepage"><div><div><h1 class="title"><a id="character_drivers"/>Character Drivers</h1></div></div></div><p><span class="emphasis"><em>Character drivers</em></span> are basically KLDs that create character devices. As mentioned previously, character devices provide either a character-stream-oriented I/O interface or, alternatively, an unstructured (raw) interface. These (<span class="emphasis"><em>character-device</em></span>) <span class="emphasis"><em>interfaces</em></span> establish the conventions for accessing a device, which include the set of procedures that can be called to do I/O operations (McKusick and Neville-Neil, 2005). In short, character drivers produce character devices, which provide device access. For example, the <code class="literal">lpt(4)</code> driver creates the <code class="literal">/dev/lpt0</code> character device, which is used to access the parallel port printer. In FreeBSD 4.0 and later, most devices have a character-device interface.<a class="indexterm" id="IDX-CHP-1-0039"/></p><p>In general, three components are common to all character drivers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">d_foo</code> functions</p></li><li class="listitem"><p>A character device switch table</p></li><li class="listitem"><p>A <code class="literal">make_dev</code> and <code class="literal">destroy_dev</code> function call</p></li></ul></div><div class="sect2" title="d_foo Functions"><div class="titlepage"><div><div><h2 class="title"><a id="d_underscore_foo_functions"/>d_foo Functions</h2></div></div></div><p>The <code class="literal">d_foo</code> functions, whose function prototypes are defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header, are the I/O operations that a process can execute on a device. These I/O operations are mostly associated with the file I/O system calls and are accordingly named <code class="literal">d_open</code>, <code class="literal">d_read</code>, and so on. A character driver’s <code class="literal">d_foo</code> function is called when “foo” is done on its device. For example, <code class="literal">d_read</code> is called when a process reads from a device.</p><p><a class="xref" href="ch01s05.html#d_underscore_foo_functions-id1" title="Table 1-1. d_foo Functions">Table 1-1</a> provides a brief description of each <code class="literal">d_foo</code> function.<a class="indexterm" id="IDX-CHP-1-0040"/><a class="indexterm" id="IDX-CHP-1-0041"/></p><div class="table"><a id="d_underscore_foo_functions-id1"/><p class="title">Table 1-1. d_foo Functions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="d_foo Functions"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Function</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">d_open</code></p></td><td style="text-align: left" valign="top"><p>Called to open the device in preparation for I/O operations</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_close</code></p></td><td style="text-align: left" valign="top"><p>Called to close the device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_read</code></p></td><td style="text-align: left" valign="top"><p>Called to read data from the device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_write</code></p></td><td style="text-align: left" valign="top"><p>Called to write data to the device</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_ioctl</code></p></td><td style="text-align: left" valign="top"><p>Called to perform an operation other than a read or a write</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_poll</code></p></td><td style="text-align: left" valign="top"><p>Called to check the device to see whether data is available for reading or space is available for writing</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_mmap</code></p></td><td style="text-align: left" valign="top"><p>Called to map a device offset into a memory address</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_kqfilter</code></p></td><td style="text-align: left" valign="top"><p>Called to register the device with a kernel event list</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_strategy</code></p></td><td style="text-align: left" valign="top"><p>Called to start a read or write operation and then immediately return</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d_dump</code></p></td><td style="text-align: left" valign="top"><p>Called to write all physical memory to the device</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>If you don’t understand some of these operations, don’t worry; we’ll describe them in detail later when we implement them.</p></div></div><div class="sect2" title="Character Device Switch Table"><div class="titlepage"><div><div><h2 class="title"><a id="character_device_switch_table"/>Character Device Switch Table</h2></div></div></div><p>A character device switch table, <code class="literal">struct cdevsw</code>, specifies which <code class="literal">d_foo</code> functions a character driver implements. It is defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header as follows:<a class="indexterm" id="IDX-CHP-1-0042"/><a class="indexterm" id="IDX-CHP-1-0043"/></p><a id="I_programlisting1_d1e1318"/><pre class="programlisting">struct cdevsw {
        int                     d_version;
        u_int                   d_flags;
        const char              *d_name;
        d_open_t                *d_open;
        d_fdopen_t              *d_fdopen;
        d_close_t               *d_close;
        d_read_t                *d_read;
        d_write_t               *d_write;
        d_ioctl_t               *d_ioctl;
        d_poll_t                *d_poll;
        d_mmap_t                *d_mmap;
        d_strategy_t            *d_strategy;
        dumper_t                *d_dump;
        d_kqfilter_t            *d_kqfilter;
        d_purge_t               *d_purge;
        d_spare2_t              *d_spare2;
        uid_t                   d_uid;
        gid_t                   d_gid;
        mode_t                  d_mode;
        const char              *d_kind;

        /* These fields should not be messed with by drivers. */
        LIST_ENTRY(cdevsw)      d_list;
        LIST_HEAD(, cdev)       d_devs;
        int                     d_spare3;
        struct cdevsw           *d_gianttrick;
};</pre><p>Here is an example character device switch table for a read/write device:<a class="indexterm" id="IDX-CHP-1-0044"/><a class="indexterm" id="IDX-CHP-1-0045"/><a class="indexterm" id="IDX-CHP-1-0046"/><a class="indexterm" id="IDX-CHP-1-0047"/><a class="indexterm" id="IDX-CHP-1-0048"/><a class="indexterm" id="IDX-CHP-1-0049"/></p><a id="I_programlisting1_d1e1352"/><pre class="programlisting">static struct cdevsw echo_cdevsw = {
        .d_version =    D_VERSION,
        .d_open =       echo_open,
        .d_close =      echo_close,
        .d_read =       echo_read,
        .d_write =      echo_write,
        .d_name =       "echo"
};</pre><p>As you can see, not every <code class="literal">d_foo</code> function or attribute needs to be defined. If a <code class="literal">d_foo</code> function is undefined, the corresponding operation is unsupported (for example, a character device switch table for a read-only device would not define <code class="literal">d_write</code>).</p><p>Unsurprisingly, <code class="literal">d_version</code> (which denotes the version of FreeBSD this driver supports) and <code class="literal">d_name</code> (which is the driver’s name) must be defined. Generally, <code class="literal">d_version</code> is set to <code class="literal">D_VERSION</code>, which is a macro substitution for whichever version of FreeBSD it’s compiled on.</p></div><div class="sect2" title="make_dev and destroy_dev Functions"><div class="titlepage"><div><div><h2 class="title"><a id="make_underscore_dev_and_destroy_undersco"/>make_dev and destroy_dev Functions</h2></div></div></div><p>The <code class="literal">make_dev</code> function takes a character device switch table and creates a character device node under <span class="emphasis"><em>/dev</em></span>. Here is its function prototype:</p><a id="I_programlisting1_d1e1390"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/conf.h&gt;

struct <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>cdev *
make_dev(struct cdevsw *cdevsw, int minor, uid_t uid, gid_t gid,
    int perms, const char *fmt, ...);</pre><p>Conversely, the <code class="literal">destroy_dev</code> function takes the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1403"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">cdev</code> structure returned by <code class="literal">make_dev</code> and destroys the character device node. Here is its function prototype:</p><a id="I_programlisting1_d1e1415"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/conf.h&gt;

void
destroy_dev(struct cdev *dev);</pre></div></div>
<div class="sect1" title="Mostly Harmless"><div class="titlepage"><div><div><h1 class="title"><a id="mostly_harmless"/>Mostly Harmless</h1></div></div></div><p><a class="xref" href="ch01s06.html#echo.c" title="Example 1-2. echo.c">Example 1-2</a> is a complete character driver (based on code written by Murray Stokely and Søren Straarup) that manipulates a memory area as though it were a device. This pseudo (or memory) device lets you write and read a single character string to and from it.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Take a quick look at this code and try to discern some of its structure. If you don’t understand all of it, don’t worry; an explanation follows.</p></div><div class="example"><a id="echo.c"/><p class="title">Example 1-2. echo.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/conf.h&gt;
  #include &lt;sys/uio.h&gt;
  #include &lt;sys/malloc.h&gt;

  #define BUFFER_SIZE     256

  /* Forward declarations. */
  static d_open_t         echo_open;
  static d_close_t        echo_close;
  static d_read_t         echo_read;
  static d_write_t        echo_write;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> static struct cdevsw echo_cdevsw = {
          .d_version =    D_VERSION,
          .d_open =       echo_open,
          .d_close =      echo_close,
          .d_read =       echo_read,
          .d_write =      echo_write,
          .d_name =       "echo"
  };

  typedef struct echo {
          <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>char buffer[BUFFER_SIZE];
          <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>int length;
  } echo_t;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/> static echo_t *echo_message;
<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/> static struct cdev *echo_dev;

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/> echo_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
  {
          uprintf("Opening echo device.\n");
          return (0);
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/> echo_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
  {
          uprintf("Closing echo device.\n");
          return (0);
  }

  static int
  echo_write(struct cdev *dev, struct uio *uio, int ioflag)
  {
          int error = 0;

          error = copyin(uio-&gt;uio_iov-&gt;iov_base, echo_message-&gt;buffer,
              MIN(uio-&gt;uio_iov-&gt;iov_len, BUFFER_SIZE - 1));
          if (error != 0) {
                  uprintf("Write failed.\n");
                  return (error);
          }

          *(echo_message-&gt;buffer +
              MIN(uio-&gt;uio_iov-&gt;iov_len, BUFFER_SIZE - 1)) = 0;

          echo_message-&gt;length = MIN(uio-&gt;uio_iov-&gt;iov_len, BUFFER_SIZE - 1);

          return (error);
  }

  static int
  echo_read(struct cdev *dev, struct uio *uio, int ioflag)
  {
          int error = 0;
          int amount;

          amount = MIN(uio-&gt;uio_resid,
              (echo_message-&gt;length - uio-&gt;uio_offset &gt; 0) ?
               echo_message-&gt;length - uio-&gt;uio_offset : 0);

          error = uiomove(echo_message-&gt;buffer + uio-&gt;uio_offset, amount, uio);
          if (error != 0)
                  uprintf("Read failed.\n");

          return (error);
  }

  static int
  echo_modevent(module_t mod __unused, int event, void *arg __unused)
  {
          int error = 0;

          switch (event) {
          case MOD_LOAD:
                  echo_message = malloc(sizeof(echo_t), M_TEMP, M_WAITOK);
                  echo_dev = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>make_dev(&amp;echo_cdevsw, 0, UID_ROOT, GID_WHEEL,
                      0600, "echo");
                  uprintf("Echo driver loaded.\n");
                  break;
          case MOD_UNLOAD:
                  destroy_dev(echo_dev);
                  free(echo_message, M_TEMP);
                  uprintf("Echo driver unloaded.\n");
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

  DEV_MODULE(echo, echo_modevent, NULL);</pre></div></div><p>This driver starts by <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1482"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> defining a character device switch table, which contains four <code class="literal">d_foo</code> functions named <code class="literal">echo_foo</code>, where <code class="literal">foo</code> equals to <code class="literal">open</code>, <code class="literal">close</code>, <code class="literal">read</code>, and <code class="literal">write</code>. Consequently, the ensuing character device will support only these four I/O operations.<a class="indexterm" id="IDX-CHP-1-0050"/><a class="indexterm" id="IDX-CHP-1-0051"/><a class="indexterm" id="IDX-CHP-1-0052"/></p><p>Next, there are two variable declarations: an <code class="literal">echo</code> structure pointer named <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1530"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">echo_message</code> (which will contain a <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1539"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> character string and its <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1545"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> length) and a <code class="literal">cdev</code> structure pointer named <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1555"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">echo_dev</code> (which will maintain the <code class="literal">cdev</code> returned by the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1567"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">make_dev</code> call).</p><p>Then, the <code class="literal">d_foo</code> functions <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1581"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">echo_open</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1590"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">echo_close</code> are defined—each just prints a debug message. Generally, the <code class="literal">d_open</code> function prepares a device for I/O, while <code class="literal">d_close</code> breaks apart those preparations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>There is a difference between “preparing a device for I/O” and “preparing (or initializing) a device.” For pseudo-devices like <a class="xref" href="ch01s06.html#echo.c" title="Example 1-2. echo.c">Example 1-2</a>, device initialization is done in the module event handler.</p></div><p>The remaining bits—<code class="literal">echo_write</code>, <code class="literal">echo_read</code>, <code class="literal">echo_modevent</code>, and <code class="literal">DEV_MODULE</code>—require a more in-depth explanation and are therefore described in their own sections.</p><div class="sect2" title="echo_write Function"><div class="titlepage"><div><div><h2 class="title"><a id="echo_underscore_write_function"/>echo_write Function</h2></div></div></div><p>The <code class="literal">echo_write</code> function acquires a character string from user space and stores it. Here is its function definition (again):</p><a id="I_programlisting1_d1e1633"/><pre class="programlisting">static int
echo_write(struct cdev *dev, <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct uio *uio, int ioflag)
{
        int error = 0;

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>copyin(<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>uio-&gt;uio_iov-&gt;iov_base,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>echo_message-&gt;buffer,
            MIN(<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>uio-&gt;uio_iov-&gt;iov_len, <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>BUFFER_SIZE - 1));
        if (error != 0) {
                uprintf("Write failed.\n");
                return (error);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*(echo_message-&gt;buffer +
            MIN(uio-&gt;uio_iov-&gt;iov_len, BUFFER_SIZE - 1)) = 0;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>echo_message-&gt;length = MIN(uio-&gt;uio_iov-&gt;iov_len, BUFFER_SIZE - 1);

        return (error);
}</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1686"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">struct uio</code> describes a character string in motion—the variables <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1695"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">iov_base</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1704"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">iov_len</code> specify the character string’s base address and length, respectively.<a class="indexterm" id="IDX-CHP-1-0053"/><a class="indexterm" id="IDX-CHP-1-0054"/><a class="indexterm" id="IDX-CHP-1-0055"/></p><p>So, this function starts by <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1731"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> copying a character string from <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1737"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> user space to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1743"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> kernel space. At most, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1749"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">'BUFFER_SIZE - 1'</code> bytes of data are copied. Once this is done, the character string is <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1759"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> null-terminated, and its length (minus the null terminator) is <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1765"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> recorded.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>This isn’t the proper way to copy data from user space to kernel space. I should’ve used <code class="literal">uiomove</code> instead of <code class="literal">copyin</code>. However, <code class="literal">copyin</code> is easier to understand, and at this point, I just want to cover the basic structure of a character driver.</p></div></div><div class="sect2" title="echo_read Function"><div class="titlepage"><div><div><h2 class="title"><a id="echo_underscore_read_function"/>echo_read Function</h2></div></div></div><p>The <code class="literal">echo_read</code> function returns the stored character string to user space. Here is its function definition (again):</p><a id="I_programlisting1_d1e1791"/><pre class="programlisting">static int
echo_read(struct cdev *dev, struct uio *uio, int ioflag)
{
        int error = 0;
        int amount;

        amount = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>MIN(<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>uio-&gt;uio_resid,
            <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>(echo_message-&gt;length - <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>uio-&gt;uio_offset &gt; 0) ?
            echo_message-&gt;length - uio-&gt;uio_offset : 0);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>uiomove(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>echo_message-&gt;buffer + uio-&gt;uio_offset,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>amount,
            <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>uio);
        if (error != 0)
                uprintf("Read failed.\n");

        return (error);
}</pre><p>Here, the variables <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1844"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">uio_resid</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1853"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">uio_offset</code> specify the amount of data remaining to be transferred and an offset into the character string, respectively.</p><p>So, this function first <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1864"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> determines the number of characters to return—either the <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1870"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> amount the user requests or <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1876"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> all of it. Then <code class="literal">echo_read</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1885"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> transfers that <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1892"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> number from <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1898"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> kernel space to <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1904"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> user space.<a class="indexterm" id="IDX-CHP-1-0056"/><a class="indexterm" id="IDX-CHP-1-0057"/><a class="indexterm" id="IDX-CHP-1-0058"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>For more on copying data between user and kernel space, see the <code class="literal">copy(9)</code> and <code class="literal">uio(9)</code> manual pages. I’d also recommend the OpenBSD <code class="literal">uiomove(9)</code> manual page.</p></div></div><div class="sect2" title="echo_modevent Function"><div class="titlepage"><div><div><h2 class="title"><a id="echo_underscore_modevent_function"/>echo_modevent Function</h2></div></div></div><p>The <code class="literal">echo_modevent</code> function is the module event handler for this character driver. Here is its function definition (again):</p><a id="I_programlisting1_d1e1946"/><pre class="programlisting">static int
echo_modevent(module_t mod __unused, int event, void *arg __unused)
{
        int error = 0;

        switch (event) {
        case MOD_LOAD:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>echo_message = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>malloc(sizeof(echo_t), M_TEMP, M_WAITOK);
                echo_dev = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>make_dev(&amp;echo_cdevsw, 0, UID_ROOT, GID_WHEEL,
                    0600, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>"echo");
                uprintf("Echo driver loaded.\n");
                break;
        case MOD_UNLOAD:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>destroy_dev(echo_dev);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>free(echo_message, M_TEMP);
                uprintf("Echo driver unloaded.\n");
                break;
        default:
                error = EOPNOTSUPP;
                break;
        }

        return (error);
}</pre><p>On module load, this function first calls <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1987"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">malloc</code> to allocate <code class="literal">sizeof(echo_t)</code> bytes of memory. Then it calls <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e1999"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">make_dev</code> to create a character device node named <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e2009"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">echo</code> under <span class="emphasis"><em>/dev</em></span>. Note that when <code class="literal">make_dev</code> returns, the character device is “live” and its <code class="literal">d_foo</code> functions can be executed. Consequently, if I had called <code class="literal">make_dev</code> ahead of <code class="literal">malloc</code>, <code class="literal">echo_write</code> or <code class="literal">echo_read</code> could be executed before <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e2040"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">echo_message</code> points to valid memory, which would be disastrous. The point is: Unless your driver is completely ready, don’t call <code class="literal">make_dev</code>.</p><p>On module unload, this function first calls <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e2054"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">destroy_dev</code> to destroy the <code class="literal">echo</code> device node. Then it calls <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e2066"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">free</code> to release the allocated memory.</p></div><div class="sect2" title="DEV_MODULE Macro"><div class="titlepage"><div><div><h2 class="title"><a id="dev_underscore_module_macro"/>DEV_MODULE Macro</h2></div></div></div><p>The <code class="literal">DEV_MODULE</code> macro is defined in the <code class="literal">&lt;sys/conf.h&gt;</code> header as follows:<a class="indexterm" id="IDX-CHP-1-0059"/><a class="indexterm" id="IDX-CHP-1-0060"/><a class="indexterm" id="IDX-CHP-1-0061"/><a class="indexterm" id="IDX-CHP-1-0062"/><a class="indexterm" id="IDX-CHP-1-0063"/><a class="indexterm" id="IDX-CHP-1-0064"/><a class="indexterm" id="IDX-CHP-1-0065"/><a class="indexterm" id="IDX-CHP-1-0066"/><a class="indexterm" id="IDX-CHP-1-0067"/><a class="indexterm" id="IDX-CHP-1-0068"/></p><a id="I_programlisting1_d1e2133"/><pre class="programlisting">#define DEV_MODULE(name, evh, arg)                                      \
  static moduledata_t name##_mod = {                                      \
      #name,                                                              \
      evh,                                                                \
      arg                                                                 \
  };                                                                      \
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)</pre><p>As you can see, <code class="literal">DEV_MODULE</code> merely wraps <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e2146"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">DECLARE_MODULE</code>. So <a class="xref" href="ch01s06.html#echo.c" title="Example 1-2. echo.c">Example 1-2</a> could have called <code class="literal">DECLARE_MODULE</code>, but <code class="literal">DEV_MODULE</code> is cleaner (and it saves you some keystrokes).</p></div><div class="sect2" title="Don’t Panic"><div class="titlepage"><div><div><h2 class="title"><a id="donat_panic"/>Don’t Panic</h2></div></div></div><p>Now that we’ve walked through <a class="xref" href="ch01s06.html#echo.c" title="Example 1-2. echo.c">Example 1-2</a>, let’s give it a try:</p><a id="I_programlisting1_d1e2171"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./echo.ko</code></strong>
Echo driver loaded.
$ <strong class="userinput"><code>ls -l /dev/echo</code></strong>
crw-------  1 root  wheel    0,  95 Jun  4 23:23 /dev/echo
$ <strong class="userinput"><code>su</code></strong>
Password:
# <strong class="userinput"><code>echo "DON'T PANIC" &gt; /dev/echo</code></strong>
Opening echo device.
Closing echo device.
# <strong class="userinput"><code>cat /dev/echo</code></strong>
Opening echo device.
DON'T PANIC
Closing echo device.</pre><p>Unsurprisingly, it works. Before this chapter is concluded, a crucial topic bears mentioning.</p></div></div>
<div class="sect1" title="Block Drivers Are Gone"><div class="titlepage"><div><div><h1 class="title"><a id="block_drivers_are_gone"/>Block Drivers Are Gone</h1></div></div></div><p>As mentioned previously, block devices transfer randomly accessible data in fixed-size blocks; for example, disk drives. Naturally, <span class="emphasis"><em>block drivers</em></span> provide access to block devices. Block drivers are characterized by the fact that all I/O is cached within the kernel’s buffer cache, which makes block drivers unreliable, for two reasons. First, because caching can reorder a sequence of write operations, it deprives the writing process of the ability to identify the exact disk contents at any moment in time. This makes reliable crash recovery of on-disk data structures (for example, filesystems) impossible. Second, caching can delay write operations. So if an error occurs, the kernel cannot report to the process that did the write which particular operation failed. For these reasons, every serious application that accesses block devices specifies that a character-device interface always be used. Consequently, FreeBSD dropped support for block drivers during the modernization of the disk I/O infrastructure.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Obviously, FreeBSD still supports block devices. For more on this, see <a class="xref" href="ch13.html" title="Chapter 13. Storage Drivers">Chapter 13</a>.</p></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion"/>Conclusion</h1></div></div></div><p>This chapter introduced you to the basics of FreeBSD device driver development. In the following chapters, we’ll build upon the concepts described here to complete your driver toolkit. As an aside, because most FreeBSD device drivers are character drivers, don’t think of them as a primary driver class—they’re more like a tool used to create character device nodes.</p></div></body></html>