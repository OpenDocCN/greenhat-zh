["```\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n\nint\ntsleep(void *chan, int priority, const char *wmesg, int timo);\n\nvoid\nwakeup(void *chan);\n\nvoid\nwakeup_one(void *chan);\n\nvoid\npause(const char *wmesg, int timo);\n\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\nint\nmtx_sleep(void *chan, struct mtx *mtx, int priority, const char *wmesg,\n    int timo);\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n\nint\nmsleep_spin(void *chan, struct mtx *mtx, const char *wmesg, int timo);\n\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\n\nint\nsx_sleep(void *chan, struct sx *sx, int priority, const char *wmesg,\n    int timo);\n\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/rwlock.h>\n\nint\nrw_sleep(void *chan, struct rwlock *rw, int priority, const char *wmesg,\n    int timo);\n```", "```\n#define INVARIANTS\n  #define INVARIANT_SUPPORT\n\n  #include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/kthread.h>\n  #include <sys/proc.h>\n  #include <sys/sched.h>\n  #include <sys/unistd.h>\n  #include <sys/lock.h>\n  #include <sys/mutex.h>\n  #include <sys/condvar.h>\n  #include <sys/sysctl.h>\n\n #define MAX_EVENT 1\n\n static struct proc *kthread;\n static int event;\n static struct cv event_cv;\n static struct mtx event_mtx;\n\n  static struct sysctl_ctx_list clist;\n  static struct sysctl_oid *poid;\n\n  static void\n sleep_thread(void *arg)\n  {\n          int ev;\n\n          for (;;) {\n                  mtx_lock(&event_mtx);\n                  while ((ev = event) == 0)\n                          cv_wait(&event_cv, &event_mtx);\n                  event = 0;\n                  mtx_unlock(&event_mtx);\n\n                  switch (ev) {\n                  case −1:\n                          kproc_exit(0);\n                          break;\n                  case 0:\n                          break;\n                  case 1:\n                          printf(\"sleep... is alive and well.\\n\");\n                          break;\n                  default:\n                          panic(\"event %d is bogus\\n\", event);\n                  }\n          }\n  }\n\n  static int\n sysctl_debug_sleep_test(SYSCTL_HANDLER_ARGS)\n  {\n          int error, i = 0;\n\n          error = sysctl_handle_int(oidp, &i, 0, req);\n          if (error == 0 && req->newptr != NULL) {\n                  if (i >= 1 && i <= MAX_EVENT) {\n                          mtx_lock(&event_mtx);\n                          KASSERT(event == 0, (\"event %d was unhandled\",\n                              event));\n                          event = i;\n                          cv_signal(&event_cv);\n                          mtx_unlock(&event_mtx);\n                  } else\n                          error = EINVAL;\n          }\n\n          return (error);\n  }\n\n  static int\n load(void *arg)\n  {\n          int error;\n          struct proc *p;\n          struct thread *td;\n\n          error = kproc_create(sleep_thread, NULL, &p, RFSTOPPED, 0, \"sleep\");\n          if (error)\n                  return (error);\n\n          event = 0;\n          mtx_init(&event_mtx, \"sleep event\", NULL, MTX_DEF);\n          cv_init(&event_cv, \"sleep\");\n\n          td = FIRST_THREAD_IN_PROC(p);\n          thread_lock(td);\n          TD_SET_CAN_RUN(td);\n          sched_add(td, SRQ_BORING);\n          thread_unlock(td);\n          kthread = p;\n\n          sysctl_ctx_init(&clist);\n          poid = SYSCTL_ADD_NODE(&clist, SYSCTL_STATIC_CHILDREN(_debug),\n              OID_AUTO, \"sleep\", CTLFLAG_RD, 0, \"sleep tree\");\n          SYSCTL_ADD_PROC(&clist, SYSCTL_CHILDREN(poid), OID_AUTO, \"test\",\n              CTLTYPE_INT | CTLFLAG_RW, 0, 0, sysctl_debug_sleep_test, \"I\",\n              \"\");\n\n          return (0);\n  }\n\n  static int\n unload(void *arg)\n  {\n          sysctl_ctx_free(&clist);\n          mtx_lock(&event_mtx);\n          event = −1;\n          cv_signal(&event_cv);\n          mtx_sleep(kthread, &event_mtx, PWAIT, \"sleep\", 0);\n          mtx_unlock(&event_mtx);\n          mtx_destroy(&event_mtx);\n          cv_destroy(&event_cv);\n\n          return (0);\n  }\n\n  static int\n sleep_modevent(module_t mod __unused, int event, void *arg)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  error = load(arg);\n                  break;\n          case MOD_UNLOAD:\n                  error = unload(arg);\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  static moduledata_t sleep_mod = {\n          \"sleep\",\n          sleep_modevent,\n          NULL\n  };\n\n  DECLARE_MODULE(sleep, sleep_mod, SI_SUB_SMP, SI_ORDER_ANY);\n```", "```\nstatic int\nsleep_modevent(module_t mod __unused, int event, void *arg)\n{\n\n        int error = 0;\n\n        switch (event) {\n        case MOD_LOAD:\n                error = load(arg);\n                break;\n        case MOD_UNLOAD:\n                error = unload(arg);\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\nstatic int\nload(void *arg)\n{\n        int error;\n        struct proc *p;\n        struct thread *td;\n\n        error = kproc_create(sleep_thread, NULL, &p,\n RFSTOPPED, 0,\n            \"sleep\");\n        if (error)\n                return (error);\n\n      event = 0;\n        mtx_init(&event_mtx, \"sleep event\", NULL, MTX_DEF);\n        cv_init(&event_cv, \"sleep\");\n\n        td = FIRST_THREAD_IN_PROC(p);\n        thread_lock(td);\n        TD_SET_CAN_RUN(td);\n      sched_add(td, SRQ_BORING);\n        thread_unlock(td);\n      kthread = p;\n\n        sysctl_ctx_init(&clist);\n        poid = SYSCTL_ADD_NODE(&clist, SYSCTL_STATIC_CHILDREN(_debug),\n            OID_AUTO, \"sleep\", CTLFLAG_RD, 0, \"sleep tree\");\n        SYSCTL_ADD_PROC(&clist, SYSCTL_CHILDREN(poid), OID_AUTO, \"test\",\n            CTLTYPE_INT | CTLFLAG_RW, 0, 0, sysctl_debug_sleep_test, \"I\",\n            \"\");\n\n        return (0);\n}\n```", "```\nstatic void\nsleep_thread(void *arg)\n{\n        int ev;\n\n      for (;;) {\n              mtx_lock(&event_mtx);\n              while ((ev = event) == 0)\n                      cv_wait(&event_cv, &event_mtx);\n              event = 0;\n              mtx_unlock(&event_mtx);\n\n              switch (ev) {\n              case −1:\n                      kproc_exit(0);\n                        break;\n                case 0:\n                        break;\n                case 1:\n                        printf(\"sleep... is alive and well.\\n\");\n                        break;\n                default:\n                        panic(\"event %d is bogus\\n\", event);\n                }\n        }\n}\n```", "```\nstatic int\nsysctl_debug_sleep_test(SYSCTL_HANDLER_ARGS)\n{\n        int error, i = 0;\n\n        error = sysctl_handle_int(oidp, &i, 0, req);\n      if (error == 0 && req->newptr != NULL) {\n              if (i >= 1 && i <= MAX_EVENT) {\n                      mtx_lock(&event_mtx);\n                      KASSERT(event == 0, (\"event %d was unhandled\",\n                            event));\n                      event = i;\n                      cv_signal(&event_cv);\n                        mtx_unlock(&event_mtx);\n                } else\n                        error = EINVAL;\n        }\n\n        return (error);\n}\n```", "```\nstatic int\nunload(void *arg)\n{\n      sysctl_ctx_free(&clist);\n        mtx_lock(&event_mtx);\n      event = −1;\n      cv_signal(&event_cv);\n      mtx_sleep(kthread, &event_mtx, PWAIT, \"sleep\", 0);\n        mtx_unlock(&event_mtx);\n      mtx_destroy(&event_mtx);\n      cv_destroy(&event_cv);\n\n        return (0);\n}\n```", "```\n$ `sudo kldload ./sleep.ko`\n$ `sudo sysctl debug.sleep.test=1`\ndebug.sleep.test: 0 -> 0\n$ `dmesg | tail -n 1`\nsleep... is alive and well.\n$ `sudo kldunload ./sleep.ko`\n$\n```", "```\n#include <sys/eventhandler.h>\n\n eventhandler_tag\nEVENTHANDLER_REGISTER(name, func, arg, priority);\n\nEVENTHANDLER_DEREGISTER(name, tag);\n\nEVENTHANDLER_INVOKE(name, ...);\n```", "```\n#include <sys/types.h>\n#include <sys/systm.h>\n\ntypedef void timeout_t (void *);\n\nvoid\ncallout_init(struct callout *c, int mpsafe);\n\nvoid\ncallout_init_mtx(struct callout *c, struct mtx *mtx, int flags);\n\nvoid\ncallout_init_rw(struct callout *c, struct rwlock *rw, int flags);\n\nint\ncallout_stop(struct callout *c);\n\nint\ncallout_drain(struct callout *c);\n\nint\ncallout_reset(struct callout *c, int ticks, timeout_t *func,\n    void *arg);\n\nint\ncallout_schedule(struct callout *c, int ticks);\n```", "```\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/taskqueue.h>\n\ntypedef void (*task_fn_t)(void *context, int pending);\n\nstruct task {\n        STAILQ_ENTRY(task)      ta_link;        /* Link for queue. */\n        u_short               ta_pending;     /* # of times queued. */\n        u_short                 ta_priority;    /* Task priority. */\n        task_fn_t               ta_func;        /* Task handler function. */\n        void                    *ta_context;    /* Argument for handler. */\n};\n\nTASK_INIT(struct task *task, int priority, task_fn_t *func,\n    void *context);\n\nint\ntaskqueue_enqueue(struct taskqueue *queue, struct task *task);\n\nvoid\ntaskqueue_run(struct taskqueue *queue);\n\nvoid\ntaskqueue_drain(struct taskqueue *queue, struct task *task);\n```"]