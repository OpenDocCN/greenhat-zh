- en: Chapter 10. MASHUP PROJECTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, I've demonstrated how to perform some common tasks with
    web maps and geographic data. Now I'll put many of these lessons together in example
    projects. The mashups in this chapter show how to retrieve, convert, and utilize
    external data sources.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also create interfaces that go beyond just showing a few locations on
    a map. Using events to capture clicks and mouse movements, we'll add some interactivity
    to the maps.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Mashup?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web is much more than a collection of interconnected documents. Millions
    of applications are creating, collecting, and consuming data all the time. When
    these applications talk to each other, sharing this data with application programming
    interfaces (APIs), the resulting feature is called a *mashup*.
  prefs: []
  type: TYPE_NORMAL
- en: The name comes from music. Musically, a mashup is created when a DJ layers two
    or more songs together to make something new. This analogy describes what programmers
    and designers are creating with web mashups. They combine APIs to create something
    new, often an enlightening way of envisioning the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: We've been using a different type of API throughout this book. Maps, in addition
    to graphing and charting APIs, are used for visualizing data, either from your
    own or other APIs. Most APIs, however, are used to make data available to developers.
    Those that I'll use in this chapter provide publicly available location data.
  prefs: []
  type: TYPE_NORMAL
- en: The Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The five projects in this chapter will get you started creating mashups. They
    were chosen for their conceptual diversity, so you can learn a number of techniques
    in this single chapter. Here''s a brief overview of the projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weather**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like your daily newspaper, this map shows weather conditions across the
    United States—only this weather map is interactive and updated each time the page
    loads. See [http://mapscripting.com/weather](http://mapscripting.com/weather).
  prefs: []
  type: TYPE_NORMAL
- en: '**Earthquakes**'
  prefs: []
  type: TYPE_NORMAL
- en: You'll get geological and create a map showing last week's earthquakes plotted
    across the globe. Using the Richter scale measure of a quake's intensity, you
    can see where the big ones were and zoom in on the world's seismic hotspots. See
    [http://mapscripting.com/earthquakes](http://mapscripting.com/earthquakes).
  prefs: []
  type: TYPE_NORMAL
- en: '**Concerts**'
  prefs: []
  type: TYPE_NORMAL
- en: Turn this mashup to 11! We'll create a tool to search a city or surrounding
    area for concerts. We'll even let users be frugal and declare their budget before
    searching. We'll filter only the results that match their criteria. See [http://mapscripting.com/concerts](http://mapscripting.com/concerts).
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter**'
  prefs: []
  type: TYPE_NORMAL
- en: Help users find tweets near their location, or anywhere they search. Optionally,
    users can add a keyword to the search to zero in on both the *what* and *where*
    stored in Twitter status messages. See [http://mapscripting.com/twitter](http://mapscripting.com/twitter).
  prefs: []
  type: TYPE_NORMAL
- en: '**Midpoint search**'
  prefs: []
  type: TYPE_NORMAL
- en: Meet in the middle! Just searching for coffee isn't enough. The final mashup
    shows you how to first find the midpoint of a route and then search for coffee
    near that midpoint. That way, you don't have to be the one to drive across town
    when you find a place to meet in the middle. See [http://mapscripting.com/middle](http://mapscripting.com/middle).
  prefs: []
  type: TYPE_NORMAL
- en: These five projects use many of the concepts you've learned earlier in this
    book. Complete them and you will definitely be on your way to map mashup mastery.
    Let the mashing begin!
  prefs: []
  type: TYPE_NORMAL
- en: '#69: Create a Weather Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big map with current conditions isn't just for your local meteorologist. Using
    the Yahoo! Weather API, you can make a visual forecast of a region, a country,
    or the whole world. In this example, I'll show how I created a US weather map
    with icons of current conditions marked for major regional cities.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see, most of the effort to create the weather map involves manipulating
    data. Once the data is in a format that JavaScript can easily access, all we need
    is a basic map with some custom markers. Things get a little tricky when we zoom
    in on a city and show its forecast in an overlay, but even that should be a cinch
    for a map master like you. By the end of this project, your map will look like
    [Figure 10-1](ch10s02.html#complete_us_weather_map "Figure 10-1. Complete US weather
    map").
  prefs: []
  type: TYPE_NORMAL
- en: '![Complete US weather map](httpatomoreillycomsourcenostarchimages672111.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Complete US weather map
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a Basic US Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the essential elements of a web map? A center point and a zoom level.
    Okay, so you also need the HTML with a `div` for your map and some basic styles.
    Plus, you'll need to load some JavaScript files. Once that foundation is in place,
    however, you just need to `setCenterAndZoom`.
  prefs: []
  type: TYPE_NORMAL
- en: I decided early on that I only wanted to show the continental United States.
    Sorry Alaska and Hawaii—I'll make it up in the earthquake example later in this
    chapter. I arrived at the center and the zoom level with a little guess and check.
    Drag the map to where you want it and set the zoom to the perfect level. Then,
    call `getCenter` and `getZoom` (or do this automatically whenever the map is dragged).
  prefs: []
  type: TYPE_NORMAL
- en: 'The center I arrived at has a latitude of 38 and a longitude of −98\. Although
    not the exact center of the United States, it looked best. I chose a zoom level
    of four, which is enough to see major cities and highways. Here is the code to
    create the basic map that we''ll build on in upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code likely looks familiar from other simple maps. We''ll add
    to it soon but you can already spot signs that this code is looking ahead: I included
    *jQuery* ❶, a JavaScript framework that makes applying effects and using Ajax
    to retrieve data easy. I also set `center` ❷ and `zoom` ❸ variables globally,
    so we''ll be able to return users to the original view after zooming in.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic map, as seen in [Figure 10-2](ch10s02.html#basic_us_weather_map "Figure 10-2. Basic
    US weather map"), is now ready for markers. Before we can plot the weather conditions
    on the map, however, we'll need some data in an accessible format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic US weather map](httpatomoreillycomsourcenostarchimages672113.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. Basic US weather map
  prefs: []
  type: TYPE_NORMAL
- en: Convert Weather Results to JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our map a mashup, we need some data, specifically current weather condition
    data. Yahoo! has an easy-to-use weather API that accepts a postal code or a proprietary
    location identifier. The result comes as GeoRSS, which is a plaintext XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example call to the Yahoo! Weather API. To get the current
    conditions and forecast for Minneapolis, Minnesota, we fetch this URL: [http://weather.yahooapis.com/forecastrss?p=USMN0503](http://weather.yahooapis.com/forecastrss?p=USMN0503).'
  prefs: []
  type: TYPE_NORMAL
- en: The bold portion of the URL is the location ID. The API will also accept a postal
    code, but in this example, we'll use the ID. When we plot the conditions on the
    map, I'll explain where to get the location IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you visit this URL, the result will look similar to this abbreviated version
    of the XML that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Not to be too picky about the format of free data, but parsing XML with JavaScript
    can be troublesome, as I discussed in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML") in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52:
    Use XML"). Many APIs now offer JavaScript Object Notation (JSON), a format that
    can be immediately plugged into JavaScript. Yahoo! Weather only provides XML,
    but another Yahoo! product can convert the data for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Yahoo! Pipes can perform many complex operations to merge, filter, and sort
    data. In this example, we won't be pushing the boundaries. All we want to do is
    read in XML from the API and output JSON. This is easy using Pipes. You could
    also use Yahoo! Query Language or run the XML through a process on your server.
    I'll show the second method in a project later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Create a New Pipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because all we have to do is convert from XML to JSON, we''ll be creating about
    as simple a pipe as we can make. You can see a more in-depth version of this example
    in [#57: Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON")
    in [#57: Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON"),
    where you''ll also find more advanced uses for Pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: From the Pipes home page at [http://pipes.yahoo.com/](http://pipes.yahoo.com/),
    click **Create a Pipe** to get a brand new, empty pipe. On the left, you'll see
    pieces of "plumbing" that you can use. Drag a **Fetch Feed Source** to the workspace.
    This point is where the data will flow in.
  prefs: []
  type: TYPE_NORMAL
- en: What is the feed's URL? We'll be making several calls to the Weather API, one
    for each city we want to look up. The calls will be routed through Pipes, which
    means the feed URL cannot be static. To accept input to the pipe, drag a **Text
    Input** to the workspace. Name the input **location**, and set the prompt to something
    like, **Enter a location**. For default and debug values, use your postal code
    or city name. You could also use a location ID, such as the one for Minneapolis,
    **USMN0503**. This helps you confirm the pipe is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve set up the text input to provide a location value, you''re
    ready to create the URL. To merge the static and dynamic portions of the URL,
    we''ll use one final piece of piping. Drag a **String Builder** to the workspace.
    For a first value, add the beginning of the Weather API URL: [http://weather.yahooapis.com/forecastrss?p=](http://weather.yahooapis.com/forecastrss?p=).'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the output of the **Text Input** to the second value of the **String Builder**.
    This action will append the location ID to the end of the call to the Weather
    API. Now you have a complete feed URL. Drag the output of the **String Builder**
    to the **Fetch Feed URL** line. Finally, drag the **Fetch Feed** output to the
    **Pipe Output** at the bottom of the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: You've just created a Yahoo! Pipe! The final product should look something like
    [Figure 10-3](ch10s02.html#complete_yahoo_exclamation_pipe_to_retri "Figure 10-3. Complete
    Yahoo! Pipe to retrieve weather data"). At the bottom of the screen in the Debug
    Output section, you should see some sample results based on the location you entered
    as the debug value for the Text Input.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use your pipe, you need to save it. Once you''ve saved it, you can run it
    to retrieve more example results by entering different locations. From the sample
    results screen, click **Get as JSON**. You may need to right-click (ctrl-click
    on Mac) and copy the link. The Pipes URL will look something like this: [http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503](http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Complete Yahoo! Pipe to retrieve weather data](httpatomoreillycomsourcenostarchimages672115.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3. Complete Yahoo! Pipe to retrieve weather data
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL will retrieve the weather conditions for Minneapolis in JSON format.
    Here is an abbreviated version of what it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That URL is what we'll use to get weather conditions for several cities, replacing
    the Minneapolis-specific location ID. In fact, that's what we're ready to do now
    that we've converted the XML results to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Plot Conditions on the Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our JSON feed ready to go, let's dive into the JavaScript to retrieve the
    weather conditions and plot them on our US map. First, you need to decide which
    cities to plot. I chose 11 prominent places, focusing on geographic diversity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To gather the location IDs for my cities, I went to [http://weather.yahoo.com/](http://weather.yahoo.com/)
    and typed each city name into the search box. The result forwards to a URL like
    this: [http://weather.yahoo.com/forecast/USMN0503.html](http://weather.yahoo.com/forecast/USMN0503.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The part of the filename without the extension, the bold portion, is the location
    ID. Once I had the IDs for all of my cities, I created a variable at the top of
    my JavaScript to hold the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `weatherids` variable is an array, which holds a list of values. I spread
    the variable declaration over several lines to improve readability and make adding
    or removing cities easy. The city names are comments, so you can easily tell which
    location ID corresponds to which city.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the map loads, we want to cycle through each city and look it up in our
    piped version of the Yahoo! Weather API. Add this loop code to the `create_map`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The variable `i` holds the index of the array, which begins at zero and counts
    up to 10 (Nashville, the 11th item in the array). Each time through the loop,
    we create a URL to call our pipe using the location ID value of the current weather
    station.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the JSON from our pipe, we use jQuery, a small JavaScript framework.
    When we set up the basic map previously, we included a reference to the jQuery
    file, so we're all set; most of the work of creating the Ajax call is done for
    us by jQuery's `getJSON` function with the URL we just created.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `location` parameter, we add a new argument to the URL, `_callback=?`.
    This security feature lets us get JSON from a site other than our own. Yahoo!
    Pipes will wrap the results so only our callback function has access to the data.
    The question mark is a holding place for the function, which we pass along as
    the second parameter for `getJSON`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When jQuery gets results from the Weather API, those results are passed to
    our `add_weather` function, which we now need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The JSON data is automatically passed as a parameter to our callback function.
    In this case, I've used a variable called `data` to hold the response from the
    pipe. The weather conditions we want to get at are inside the first result of
    an array called `items`, which is itself inside an object named `value`. Sure,
    we've got some unnecessary overhead, but these are XML remnants.
  prefs: []
  type: TYPE_NORMAL
- en: The main data we need is latitude, longitude, and description. Wherever possible,
    I use JavaScript dot notation like `item.description`. Several field names in
    this feed contain a colon, which would be interpreted incorrectly with dot notation.
    In this case, I use the bracket notation to retrieve the properties from `item`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Every weather condition has a numbered code that matches a particular description.
    The number allows machines to interpret a forecast easily without needing to parse
    text. The code is also used by Yahoo! Weather to call up the image designated
    for each condition. For example, a code of 30 means the sky is partly cloudy.
    The corresponding graphic is stored at [http://l.yimg.com/a/i/us/we/52/30.gif](http://l.yimg.com/a/i/us/we/52/30.gif).
    I piece together this image URL into the `imgsrc` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the data we need, we wrap it inside an object with curly braces
    and pass it off to the `add_marker` function to do the work of plotting this marker
    on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why did I pass the data as a JavaScript object (the `options` variable) instead
    of individual parameters? You could use parameters, but four parameters would
    be a lot to pass along to a function. Every time we called it, we would need to
    double-check the order. Is description third or fourth? Also, JavaScript objects
    are commonly used to share data between JavaScript functions, so using them is
    good practice.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the `add_marker` function creates a straight-forward custom marker.
    The only line that might look strange is the shadow icon ❶, which I want to be
    empty. Because a shadowless marker is not an option, I used one transparent pixel
    for the shadow icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have all the pieces to plot the conditions for our list of cities. Put
    them together and you have a complete weather map, with a little graphical representation
    of the current weather hovering above each city. Here''s a brief recap of everything
    that happens as the mashup loads:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML page is loaded, the `create_map` function is called, which sets up
    the basic map and calls the `get_weather` function for each location ID in the
    `weatherids` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON is retrieved from the Yahoo! Pipe, the data gets passed to the `add_weather`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The important bits get extracted from the JSON into a JavaScript object, which
    is itself passed to the `add_marker` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Custom markers are created and placed on the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's make this mashup a little more interactive. When the user clicks a
    marker, the map will zoom in on the forecast details for that location.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Forecast Details Pane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A visual representation of current conditions is great, but we cannot show much
    content from the Weather API. In this section, we'll add a Forecast Details pane.
    For added interactivity, we'll make the pane appear when the user clicks a marker,
    as shown in [Figure 10-4](ch10s02.html#forecast_pane_for_our_weather_map "Figure 10-4. Forecast
    pane for our weather map").
  prefs: []
  type: TYPE_NORMAL
- en: '![Forecast pane for our weather map](httpatomoreillycomsourcenostarchimages672117.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4. Forecast pane for our weather map
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to add the HTML shell for the new content. Right below the
    map `div`, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the map, the shell is empty. We''ll use JavaScript to load it with content.
    Because we want to overlay the forecast details on the map itself, we''ll use
    CSS to position the new `div`. In the `<style>` section of the header, add these
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This CSS creates a thin, tall, white box to the right side of the map. In fact,
    save your file, load it in a browser, and from Michigan east will be obscured
    with the box. That's certainly not what we want. We want the forecast pane only
    to show up when a city is selected. By default, we'll need to hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by adding this one line of jQuery to the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we call the jQuery `hide` function on the forecast `div`. When the map
    is first loaded, the pane will be hidden, waiting for a user to click.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use Mapstraction to fill the Forecast Details pane with content.
    Rather than creating infoBubbles when a marker is clicked, we'll instead call
    `setInfoDiv` with the forecast data from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we actually need to get at that data. An entire description of the current
    conditions plus a forecast is passed from the Weather API in the description field.
    We need a fifth variable in the `add_weather` function. After the `imgsrc` line,
    add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you''ll alter the call to `add_marker` by adding another option to the
    passed object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you''ll use the new value inside the `add_marker` function. Add this line
    before the call to `addMarker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we set the Forecast Details pane to contain the description ❶ from the
    API, plus a clickable US map image ❷ that calls a new JavaScript function to return
    the map to the center and clear the Forecast Details pane. How does Mapstraction
    know which `div` to use? We pass its `id` as the second variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the Forecast Details pane in action, we need to write code to show the
    hidden `div` when a marker is clicked. Add this line after the call to `addMarker`,
    as we''ll be working with the marker object we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are listening for a click event on a marker and then responding with
    a function reference. Let''s write the `marker_clicked` function, which will be
    called whenever any of our markers is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When any marker is clicked, we set it to the center of the map and zoom in ❹.
    We use the clicked marker's location as the center, which comes to the function
    via the `event_source` argument. Then, to account for the Forecast Details pane
    on the right side of the map, we shift the map center to the west ❺, so the marker
    will appear centered in the visible portion of the map. Finally, we make sure
    the Forecast Details pane is visible ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Save your file and load it in a browser. Now you should be able to click a marker
    and zoom in to see the forecast. The only piece that isn't connected is the ability
    to zoom back out and see the whole contiguous United States again. To do this,
    we'll need to write the `return_center` function called whenever you click the
    US map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function to the JavaScript section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This housekeeping function returns the map to its original center and zoom level
    and then hides the Forecast Details pane. Now we can see the whole US map again.
  prefs: []
  type: TYPE_NORMAL
- en: With the house cleaned, the mashup is complete. You pulled in data from Yahoo!
    Weather using Yahoo! Pipes to convert to JSON. Then you displayed the conditions
    for several cities, along with a descriptive graphic, on a map. Finally, upon
    clicking the marker, you zoomed the map into the city and displayed the forecast
    in its own overlaid info pane.
  prefs: []
  type: TYPE_NORMAL
- en: The best part, of course, is that you no longer need to read the weather page
    in the newspaper. You have an online, always-updating replacement.
  prefs: []
  type: TYPE_NORMAL
- en: '#70: Display Recent Earthquakes Worldwide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you an aspiring geologist? Or maybe you're just looking for a quick way
    to see what's shaking in the world? In this mashup, I'll show you how to use a
    public data source to make sense of the world around you. We'll plot a week's
    worth of earthquakes, as tallied by the United States Geological Survey (USGS).
  prefs: []
  type: TYPE_NORMAL
- en: Lucky for us, the USGS logs earthquake data not just for the United States,
    but for the whole world. Even luckier for us, they're hip to the latest data formats.
    The organization publishes an XML feed that is geographically encoded as GeoRSS.
    It covers earthquakes that register 2.5 or greater on the Richter scale. That
    should still give us plenty of earthquakes to reveal some interesting trends on
    our map, as shown in [Figure 10-5](ch10s03.html#map_showing_recent_earthquakes_by_magnit
    "Figure 10-5. Map showing recent earthquakes by magnitude").
  prefs: []
  type: TYPE_NORMAL
- en: '![Map showing recent earthquakes by magnitude](httpatomoreillycomsourcenostarchimages672119.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5. Map showing recent earthquakes by magnitude
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the feed into a web browser to view the content directly: [http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml](http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many browsers will display a "pretty" version by default. View its source to
    get a glimpse at all the data it sends along with it. Here is an abbreviated version
    of the XML file from the USGS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's some good stuff. Let's start using that data on our maps. First, we'll
    automatically parse GeoRSS, a feature that Mapstraction makes look easy. Then,
    if that basic visualization isn't enough, we'll create a completely custom solution.
  prefs: []
  type: TYPE_NORMAL
- en: Show Earthquakes with GeoRSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, you've chosen the quick version. You simply want to see these earthquakes
    get tossed up on a map. And you want to see this done using the fewest lines of
    code possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these very few lines to a new HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As always, remember to use your own API key. Otherwise, the code is ready to
    go. Save and load it in a browser to see something similar to [Figure 10-6](ch10s03.html#earthquakes_shown_with_direct_georss_ove
    "Figure 10-6. Earthquakes shown with direct GeoRSS overlay"). The actual location
    of the markers will differ based on the past week's geological activity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Earthquakes shown with direct GeoRSS overlay](httpatomoreillycomsourcenostarchimages672121.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6. Earthquakes shown with direct GeoRSS overlay
  prefs: []
  type: TYPE_NORMAL
- en: Did you catch all those zeroes on the line where we set the center and zoom
    ❶? Those aren't typos. A latitude of zero is the equator. A longitude of zero
    is roughly the international dateline, running through London. Finally, a zoom
    level of zero shows the whole world.
  prefs: []
  type: TYPE_NORMAL
- en: The money line, which loads the earthquake data, is shown in bold. Mapstraction's
    `addOverlay` function does most of the work. It creates dozens of markers and
    even adds infoBubble content to them. Unfortunately, the fun stops here. Once
    we outsource all that work to a single function, we've handcuffed our ability
    to make exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: To give this earthquake map our personal touches, we need to get deeper into
    the code. We need to go custom.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Custom Earthquake Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all you want to do is visualize where earthquakes are, using Mapstraction's
    built-in GeoRSS support gets the job done easily. On the other hand, if you want
    to prefilter content or show different icons based on quake intensity, you'll
    need a more custom solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll show you how to convert the GeoRSS to JSON using Yahoo!
    Query Language. Then you'll choose a marker icon based on the earthquake's Richter
    value. Finally, you'll get extra clever and zoom in on zones that usually have
    considerable earthquake activity.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you need a basic view of the world on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare Basic World Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic map of the world doesn't need to be much different from the map in
    the GeoRSS version of the earthquake mapper. We need to load the map and then
    set a center and zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to a new HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, load it into a browser, and you'll see a markerless map of the
    world, like [Figure 10-7](ch10s03.html#empty_map_of_the_world_comma_waiting_for
    "Figure 10-7. Empty map of the world, waiting for markers"). I've made a few changes
    to the code to look ahead as we customize the map. For one, I included jQuery
    ❶, the JavaScript framework that makes applying effects and using Ajax to retrieve
    data easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Empty map of the world, waiting for markers](httpatomoreillycomsourcenostarchimages672123.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7. Empty map of the world, waiting for markers
  prefs: []
  type: TYPE_NORMAL
- en: I created an object variable to hold the default location and zoom level ❷,
    rather than individual variables. The values I chose were based on guessing and
    then checking to find a good location where the entire world would be visible
    and the location of the earthquakes would make the most sense. Because a world
    map is a two-dimensional view of a three-dimensional object, problems can crop
    up with where markers and polylines wrap. I chose the center of our basic map
    so our hotspot regions are completely within view globally.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I created an entire function ❸ to use the default center and zoom values.
    Later with this mashup, we'll zoom into those hotspot regions, but afterward we
    need a way to zoom back to the original center. We might as well reuse code where
    we can.
  prefs: []
  type: TYPE_NORMAL
- en: Convert Earthquake Data to JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the basic map is set up, we need to start thinking about data. The
    USGS provides an XML feed. JavaScript can parse XML, but we would need to download
    the XML to a server first for security reasons. If we can get the data as JSON,
    our job is so much easier.
  prefs: []
  type: TYPE_NORMAL
- en: We have a number of options for converting the earthquake data from XML to JSON.
    In the weather mashup, we used Yahoo! Pipes. In this case, we'll use another Yahoo!
    product, Yahoo! Query Language (YQL). Among many other uses of the technology
    YQL makes converting any GeoRSS feed to JSON easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'YQL''s syntax is similar to SQL, the language used to query a database. You
    can try out commands in the YQL console at [http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/).
    Instead of querying a database table, we''ll work against the USGS GeoRSS URL
    we used in the previous section. Here''s the query to grab all the data from that
    feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Type that command in the YQL console, select the JSON output, and click the
    **Test** button. As shown in [Figure 10-8](ch10s03.html#yql_console_showing_results_from_earthqu
    "Figure 10-8. YQL Console showing results from earthquake feed"), you'll see the
    results in the pane below. If you prefer to see a more structured view, click
    the **Tree View** tab to peruse the data. From there, you can see the items we'll
    have available to us when we load the data into our map.
  prefs: []
  type: TYPE_NORMAL
- en: '![YQL Console showing results from earthquake feed](httpatomoreillycomsourcenostarchimages672125.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8. YQL Console showing results from earthquake feed
  prefs: []
  type: TYPE_NORMAL
- en: Copy the long URL at the bottom of the console under The REST Query and store
    it somewhere. We'll use that URL in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Plot Earthquakes on Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you've seen, simply plotting earthquakes on a map requires a single line
    call to a GeoRSS feed. That's too basic for us, however. The purpose of this mashup
    is to create something more customized. We want to provide a visual way to see
    the intensity of earthquakes at a glance by using bigger icons in places the Richter
    value is higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two JavaScript functions will load the data from the YQL JSON
    URL we found in the previous section, determine which icon to use, and plot the
    marker on the world map. Add this code to your basic map following the `create_map`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `get_quakes` function is actually a single line, but it's a really long
    line. It calls the `getJSON` function in jQuery. The JavaScript framework requires
    two variables to retrieve our JSON from YQL. The first is the URL to call. The
    second is a reference to a callback function. I used an anonymous, inline function.
    This callback function is what takes up most of the space in the `get_quakes`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The YQL URL ❶ is spread out over a few lines as a single, long string that is
    almost exactly the same as you copied from the YQL console. The only change is
    that the callback argument (the last part of the URL) is a question mark. By including
    a question mark, jQuery replaces it with the callback function for us.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a result, it is passed to the anonymous function as the `data`
    variable, which will be a JavaScript object. Within the object, `data.query.results.entry`
    refers to the array of all earthquake results. Using jQuery's `each` function
    ❷, we iterate through every result. Each earthquake is passed to yet another anonymous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For each earthquake, we first retrieve the geographic coordinates from the `point`
    value. As you may recall from the USGS XML, both the latitude and longitude are
    stored as a single value, with a space between. Our code splits them into two
    values ❸ and stores the result in an array. The first item in the array (with
    an index of zero) is the latitude; the second is the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find the Richter value. The *Richter value* is the measurement
    of an earthquake's intensity and is usually given a decimal value less than 10\.
    Unfortunately, the USGS does not directly pass this value, even though it's sitting
    right there in the title. For example, `M 2.6, Washington`. By sucking out a substring
    from the title, we can find the Richter value. In this case, we want 2.6 and nothing
    more.
  prefs: []
  type: TYPE_NORMAL
- en: The Richter value begins at the third character in the string, which is referred
    to as *slot two* because textual strings, like arrays, start counting at zero.
    Then the Richter value continues for three characters. So our call to `substr`
    ❹ begins at slot two and continues three characters. The value of the `richter`
    variable is now 2.6 in this example, just like we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: With the Richter value in hand, we can determine which icon to use by passing
    it to the `get_icon` function. I selected three levels and created a graphic for
    each of them. If an earthquake is relatively small, less than four, I assign it
    the smallest icon. If the earthquake is between four and five, it gets a medium-sized
    icon. Anything five and greater gets the largest icon. The icons are also colored
    differently among the levels, so the earthquake markers get bigger and redder
    with greater magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: Using the latitude/longitude array that we split from the data, we create a
    marker for this earthquake. We give it a custom icon based on the Richter value,
    and then give it no shadow ❺. I used one transparent pixel for the shadow icon
    and set the width and height to be zero. As you'll see, our map will have so many
    earthquakes, we won't have room for shadows.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, I added a very simple message inside the infoBubble ❻. The message
    shows the full title, the date, and a link to the page on the USGS site where
    the user can get more information about this earthquake.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Legend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In just a few lines, this map is easier to read than the one generated by the
    GeoRSS. The many earthquakes take up less space because of the smaller markers.
    We have shown that some earthquakes are more noteworthy than others by changing
    the size and color of the icons. Will the map make sense to someone who doesn't
    know the method to our Richter-based madness?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a legend, like the one shown in the finished map ([Figure 10-5](ch10s03.html#map_showing_recent_earthquakes_by_magnit
    "Figure 10-5. Map showing recent earthquakes by magnitude")), below the map to
    show what each icon means. Following the map `div`, add this ordered list, which
    describes the different icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want the legend to look like an ordered list because that takes up
    too much space. Most of the time, something like this will be shown along one
    line. Enter a little CSS to make it look the way you want. Add this to your stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now the ordered list exists on a single line. Each list item is padded to the
    right, so which icon goes with which description is still obvious. Now that we've
    made it clear what the icons mean, let's add a little interactivity to this map.
  prefs: []
  type: TYPE_NORMAL
- en: Zoom to Hotspot Regions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can tell from this mashup, some areas of the world are more seismically
    active than others. These spots are fairly predictable regions. Some, like California,
    may be more obvious than others. Due to the clustering of many markers in these
    areas, having a way to zoom in for a better view would be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'I identified four of these regions and created a system that makes adding others
    easy. In the variable section of your code, add these lines to create an object
    containing the regions'' boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At its most basic level, the `regions` variable holds text keys that correspond
    to Mapstraction `BoundingBox` objects. For our purposes, the key is a unique identifier
    for the region. The four numbers used to create the bounds are the minimum necessary
    to describe the region. The first pair describes the southwest corner of the box.
    The second describes the northeast corner. The other two corners of the box can
    be extrapolated from these values.
  prefs: []
  type: TYPE_NORMAL
- en: As the user mouses around the map, we want to determine when the cursor is hovering
    over one of these regions. If it is, we'll highlight the region by drawing a box
    around it. Then, if the user clicks, we'll zoom in to that region, like in [Figure 10-9](ch10s03.html#zoomed_into_an_earthquake_hotspot_region
    "Figure 10-9. Zoomed into an earthquake hotspot region").
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to listen for two events: mouse moving and clicking.
    Add these lines to your `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first ❶ listens for mouse movement and highlights a region if the mouse
    is within its bounding box. We have to use Google's native `addListener` function,
    because the `mousemove` event is not supported by Mapstraction. An event object
    is passed along to the `check_hover` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoomed into an earthquake hotspot region](httpatomoreillycomsourcenostarchimages672127.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-9. Zoomed into an earthquake hotspot region
  prefs: []
  type: TYPE_NORMAL
- en: Though we used a little Google-specific code, we are still able to use Mapstraction
    for everything else. The second ❷ event listens for a click somewhere on the map.
    If a region is already highlighted, it zooms in ❸ to give a closer look at the
    quakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the two functions (in bold) that are called from our event
    code. First, we''ll write the code to determine whether the mouse is hovering
    over any of our identified regions. Add this to your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `check_hover` function, we also have a helper function. Together,
    this duo determines whether the user is hovering over a region and, if so, which
    region. The `find_region` function does most of this work. It loops through the
    region's array and compares the mouse's latitude/longitude to the four edges of
    the bounding box ❶ using the handy `contains` function.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is hovering over a region, the name of the region is returned to
    `check_hover`. Assuming we aren't already highlighting that region❷, we pass the
    name along to the `highlight_region` function, which draws the box. If the mouse
    is not over a region, but one was previously highlighted ❸, then we know the user
    moved the mouse outside of the region. Therefore, we can remove the box from the
    screen ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t created the function to add the box, so we''ll do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of highlighting is fairly simple, though I have separated it into
    two functions. I have reprinted the second function, `BoundingBox_to_Polyline`,
    from [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a Rectangle
    to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area").'
  prefs: []
  type: TYPE_NORMAL
- en: The box created in the `highlight_region` function uses a white polyline ❺.
    You may wish to change the polyline to another color. The rest is simply drawing
    the box on the map.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, as a user moves the mouse around the map, regions will be highlighted.
    Now we need to make something happen when a user clicks while a region is highlighted.
    In other words, we need to set the current region and zoom in, fulfilling the
    second function called by the event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Quite simply, if the region exists in our array, we set the map's boundaries
    to include only the selected region. The map zooms in and is centered to show
    the earthquakes in the region.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need a way to get back to the world map. Very early on in this mashup,
    we created a `view_world` function. How do we call it? We'll use a graphic of
    the world and call the function whenever the image is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding this functionality is something that touches several sections of the
    mashup. So we need to include a few lines in a number of places. First, add the
    graphic to your HTML between the map and the legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can find this image, along with the marker icons I've used in this example
    at [http://mapscripting.com/earthquake-mashup](http://mapscripting.com/earthquake-mashup).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add some CSS so the graphic appears in the upper-right corner
    of our map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use jQuery to respond to a user clicking the image. Add this code to
    the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This retrieves the link element, which surrounds the image using CSS selector
    syntax and tells the browser to call the `view_world` function whenever that object
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: If we weren't picky, we'd stop here. In a perfect world, the clickable graphic
    would only be visible when the map is zoomed in. Let's see if we can't make this
    world a little more perfect, again using some jQuery functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want the graphic to disappear whenever we''re viewing the whole
    world, we''ll need to add this line inside the `view_world` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The image will now be invisible all the time. Of course, we want it to appear
    when we''ve zoomed in. Inside the `set_region` function, directly under the `setBounds`
    line, we add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With that, we've incorporated a better interface into our interactive earthquake
    map. Zooming in by region is cool, as long as you can return to the map. We may
    not have made a perfect world, but this world map mashup is close to perfect.
  prefs: []
  type: TYPE_NORMAL
- en: We converted USGS data from XML to JSON. Then we read in every earthquake in
    the past week, determined its intensity, and gave it an appropriate icon. Finally,
    we implemented zooming into hotspot regions. The only thing left to do is monitor
    tectonic movements; at least now you have a tool to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '#71: Search Music Events by Location'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Want to check out a concert tonight? Where shall we go and who's playing? This
    information is out there. Let's get our hands on it and plot it on a map.
  prefs: []
  type: TYPE_NORMAL
- en: For this mashup, we'll be using Yahoo!'s Upcoming API. Upcoming is an events
    calendar showing conferences, concerts, user group meetings, and more. We want
    to search only for music, an option made possible by using the API's tag-based
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Unless we can count on users all being from the same city, we'll need to provide
    a way to search by location. Lucky us—that's also an option with Upcoming. Because
    some people are willing to drive farther than others, we also want users to be
    able to specify distance. Yep, that option is also supported.
  prefs: []
  type: TYPE_NORMAL
- en: Some people are more frugal than others. You may be willing to drop $75 to see
    an aging rocker, but I prefer to pay a small cover to see a local band at a bar.
    We'll need to plan for different price ranges. Alas, Upcoming does not directly
    support this option. We can query free concerts, but I'm not a total cheapskate;
    I'll pay five or ten bucks. Seeing as Upcoming does pass along ticket cost, however,
    we can handle price filtering ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: This mashups requires a lot of features. You can see in [Figure 10-10](ch10s04.html#shows_within_25_miles_of_san_francisco
    "Figure 10-10. Shows within 25 miles of San Francisco") that they all come together
    nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a game plan so let's jam! Before we get into the data itself, we'll
    get a feel for the interface we'll create for users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shows within 25 miles of San Francisco](httpatomoreillycomsourcenostarchimages672129.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-10. Shows within 25 miles of San Francisco
  prefs: []
  type: TYPE_NORMAL
- en: Prepare HTML for Search Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This being a map mashup, the map will be the center of our experience. The user
    will need to let us in on his or her whims regarding location and price. We'll
    need to put the search functions close to the map, so it's obvious that one controls
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a new file and add this code to create a basic map and form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Much of this HTML will look familiar. As with most maps, I've loaded the Google
    Maps and Mapstraction JavaScript libraries. I also included jQuery ❶, which makes
    applying effects and using Ajax easy.
  prefs: []
  type: TYPE_NORMAL
- en: The search location text defaults to Portland, Oregon, in this example. When
    the map first loads, it is centered on Portland. You can change the center to
    your city, but you'll need to edit multiple places. First, I used geographic coordinates
    ❷ to set the center. You've memorized these for your city now, right? Second,
    you need to change the value of the text field ❸. Of course, your user may edit
    the location, but starting with a logical default makes sense. For me, I used
    my hometown.
  prefs: []
  type: TYPE_NORMAL
- en: The radius and cost fields are drop-down boxes. The values hold the maximums.
    For example, if you choose a radius of five miles ❹, nothing even a foot farther
    than five miles will show in the results. The same goes for price values. For
    the option of showing results regardless of cost ❺, we're hoping no concert is
    charging more than $9,999.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basic interface for a mashup, as we have here, can help you figure
    out everything you need to do. Look back at the code listing and note the function
    names in bold. You need to write those—one to search and another to filter—at
    the very least to be able to convert this interface into a working mashup.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start building the functions we need, let's look at the data we'll
    be using. To do that, we need to become familiar with the Upcoming API.
  prefs: []
  type: TYPE_NORMAL
- en: Perform an Upcoming API Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upcoming uses a REST API, which means we can play around with it in the browser
    before coding anything. As a first step, you need a Yahoo! account to sign into
    Upcoming. Then, you need to get an Upcoming API key. This key is different than
    ones you've used for any other Yahoo! service.
  prefs: []
  type: TYPE_NORMAL
- en: 'While logged into Upcoming, request a key here: [http://upcoming.yahoo.com/api/url](http://upcoming.yahoo.com/api/url).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an API key, try out this Upcoming search by copying this
    URL into your browser: [http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR](http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample of the results from this simple search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The search term has merely restricted to a location. We need to add more options
    to the search before it will find the data we seek. See [Table 10-1](ch10s04.html#upcoming_api_event_search_option
    "Table 10-1. Upcoming API Event Search Option") for a description of the arguments
    we'll use. Many more are listed in Upcoming's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1. Upcoming API Event Search Option
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `api_key` | Your API key (required) |'
  prefs: []
  type: TYPE_TB
- en: '| `location` | City and state to search for events |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | How far away from center of location to search |'
  prefs: []
  type: TYPE_TB
- en: '| `min_date` | What date to start searching for events |'
  prefs: []
  type: TYPE_TB
- en: '| `max_date` | What date to stop searching for events |'
  prefs: []
  type: TYPE_TB
- en: '| `tags` | The metadata keywords to filter results |'
  prefs: []
  type: TYPE_TB
- en: Retrieve Event Data Server-Side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know what to expect from the Upcoming API, we're ready to connect
    to it. Rather than use JavaScript to get directly at the data, we'll run the data
    through a server-side PHP script. If you're unsure about whether you have PHP
    or how to use it, go check out [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using PHP to pass the results to JavaScript for two reasons: First,
    we have to take into account security issues with accessing outside APIs directly
    with JavaScript. In many cases, browsers won''t allow it. Second, we can do some
    preprocessing to the data. We need to find the concert cost and put the price
    in a format that will make filtering results easier. Also, even though the API
    provides XML, we''ll output as JSON with the server-side script. JSON can be read
    directly into a JavaScript object, which again will make our lives easier.'
  prefs: []
  type: TYPE_NORMAL
- en: The PHP code we'll use to access the Upcoming API is about 60 lines long. Rather
    than display it all at once, I'll go through one section at a time. That way I
    can describe what's happening, and you'll understand each piece before moving
    on to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s create a new PHP file on your server and retrieve arguments
    from the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Even though we're using someone else's API, writing a middleman PHP script like
    this is sort of like creating our own API. Most of our query string arguments
    (in bold) will be passed unchanged to Upcoming. The `timeframe` argument, however,
    is my own creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument specifies how far in the future to search. This simple version
    allows three options: one day (`1d`), one week (`1w`), and one month (`1m`). Because
    Upcoming does not have this option, we need to convert the timeframe to a maximum
    date by finding the timestamp that represents a day in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: We already set the minimum date to be today ❶. PHP's `date` function, if a second
    argument isn't included, assumes the current date. We can achieve the same result
    by passing `time()` as the second argument. In fact, with a timeframe of one day,
    we simply set the timestamp equal to `time()` ❷. That leaves the minimum date
    as today and the maximum date as today, just like we want.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a week or month, we need to do a little date math. PHP has a
    `strtotime` function that takes many different types of input. In this example
    ❸, the function starts at today and adds a week. Then it subtracts a day. Why?
    Because otherwise we'd have eight days, which is more than a week. The same is
    true of the month option.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we convert our timeframe to a timestamp format the computer understands.
    Now all we need is to set the `$maxdate` variable by passing the `timeframe` to
    the `date` function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve figured out all the variables that we''re sending to the Upcoming
    API, we''re ready for the next bit of code. In this section, we actually retrieve
    data and preprocess it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the variables we created in the previous section, we piece together the
    URL to call Upcoming''s API ❺. The content from the URL will come through as XML,
    which we convert into a `SimpleXML` object. In [#61: Retrieve a Web Page](ch09s03.html
    "#61: Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page"), we wrote the `get_xml` function to perform this task. We might as
    well save ourselves some time and reuse that function here ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the XML now easily accessible, let''s loop through all the events that
    the Upcoming API returned. We''ll grab each `<event>` tag ❼ one at a time. The
    data about the event is stored as the event tag''s attributes. We can grab all
    the attributes at once ❽ and then pick and choose only the ones we want: the unique
    `id` assigned by Upcoming, latitude, longitude, the event''s title, its date,
    and its cost. Most of these are straightforward, but we''ll need to do a little
    voodoo to get the price of the event in the format we want.'
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming includes a dollar sign in front of the ticket price, and many events
    have a price range instead of a single amount. To filter by the cost in our JavaScript
    code, we need our PHP code to return a simple number.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I used a regular expression to look for all instances of a dollar sign
    followed by one or more digits ❾. This way, we can take the last dollar amount,
    which should be at the highest end of the range if one exists. If tickets are
    just one price, the expression will find that, too. Finally, we remove the dollar
    sign, so we return only a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the data from the event we need, we put it into an associative
    array, `$eventobj`. That new array then gets "pushed" onto the end of the results
    object ❿, which is a normal array. I''ve named the results object `$outobj` because
    we''ll print it. In fact, with all the preprocessing complete, we can do that
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We first print the header to declare that we're sending plain text. PHP defaults
    to HTML. Next, we print out the results object, but we make sure it is JSON-encoded.
    That way, we're giving our JavaScript code something easy to digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember when we used the `get_xml` function to retrieve the Upcoming URL and
    convert the XML content to a `SimpleXML` object? We never actually included the
    function in our code. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Hey! That's two functions!
  prefs: []
  type: TYPE_NORMAL
- en: You caught me. Because one calls the other, we need to include them both. If
    you find yourself using these functions often, adding them to their own file is
    probably worthwhile. Then you can make them part of your project as needed with
    the PHP `include` function.
  prefs: []
  type: TYPE_NORMAL
- en: And that's that. We've written some PHP to call the Upcoming API. From the XML
    returned by Upcoming, we take only the stuff we want and output it as JSON. I
    saved the PHP file as *upcoming.php* in the same directory as the HTML search
    interface we created earlier. Now let's return to that HTML file, so we can use
    JavaScript to connect to our newly created PHP file.
  prefs: []
  type: TYPE_NORMAL
- en: Plot Event Search Results on a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to get data from Upcoming, let's put that data on our
    map. We'll connect to the PHP file we just created, sending it the information
    it needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall from setting up the HTML that we need to create two functions.
    First, we write the `search_upcoming` function to perform the Ajax call to our
    PHP. Add these lines in the JavaScript below the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Before we can search Upcoming, we need to retrieve the user's values from the
    form. To do this, I used the `document.getElementById` function, doing a little
    data cleanup for the location.
  prefs: []
  type: TYPE_NORMAL
- en: I hard-coded some values that are options in our PHP file that we don't currently
    use as input from the user. For example, the tags ❶ that we look for can be changed
    to something else if you aren't looking for concerts. The timeframe defaults to
    one week, which seems the most useful for planning impromptu entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: The values that I hard-coded, plus a couple from the form, are put into a JavaScript
    object ❷. The jQuery `getJSON` function ❸ that calls our PHP file using the `data`
    variable to include values requires this format. The last parameter is a function
    reference to `plot_upcoming` ❹. That's one we need to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new function, we want to loop through all the results in the JavaScript
    object. As we find each event, we plot it on the map. Add this code to your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function unpacks the variables that are output by the PHP and uses them
    to add a marker for every Upcoming event the API returned. Remember, we used an
    array holding many associative arrays. The JavaScript object is also an array.
    We iterate through it with the `for` command ❺, putting each event result into
    the `ev` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `id` returned from Upcoming, we can piece together the URL ❻ where
    the user can find out more information about the event. Other data, like the latitude
    and longitude, we put directly into variables that we use to create the marker.
  prefs: []
  type: TYPE_NORMAL
- en: If the PHP was able to determine the cost of the event, we add an attribute
    to the marker with that information ❼. This information will be useful when we
    filter by ticket price. In fact, at the end of this function, once all the markers
    have been added to the map, we call that filter function ❽, which means we better
    go write it.
  prefs: []
  type: TYPE_NORMAL
- en: Filter Results by Ticket Price
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the results are returned, they contain all the music events in an area,
    not just the ones that match the user's budget. The Upcoming API has no way to
    query for events under a specific ticket price, though it does provide the price
    in the results, if available. The PHP we wrote takes the ticket price and produces
    a numeric cost that we can use as a filter.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we added a `cost` attribute for every marker containing
    the ticket price. Just having the attribute is not enough to remove overpriced
    concerts. We also need to apply the filter, which comes from a drop-down box in
    the HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter_select` function is called when all the markers are added to the
    page, or whenever the value in the drop-down box changes. Add these functions
    to your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with other examples, two functions perform this one task. The first retrieves
    the value from the drop-down box ❶ and then passes the cost to the second. The
    `filter_cost` function does the actual filtering work.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating a new filter, we need to remove any previous filters ❷. Why?
    Mapstraction's filtering is additive, meaning a second filter does not replace
    the first, but instead is applied in addition to the first. In this case, we only
    want to use a single filtering method, we remove all filters before adding new
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a filter requires three pieces of information: the attribute to be
    filtered by, the operator to use (in this case `le` for less than or equal to
    ❸), and finally the value to compare. Markers don''t actually get filtered until
    Mapstraction''s `doFilter` function is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Now with only the markers matching our filter being displayed, we can make sure
    they're all visible on the map. Mapstraction has a function specifically for situations
    like this ❹. We don't want to set the center and zoom based on all the markers;
    we simply want to use the visible markers.
  prefs: []
  type: TYPE_NORMAL
- en: These filtering functions are called from our mashup whenever the user searches
    for concerts. We also save a little bandwidth whenever the user changes the value
    in the ticket price drop-down box. Because we've stored concerts for all price
    ranges, we call these filtering functions to show only the ones that match, as
    shown in [Figure 10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "Figure 10-11. Filtered results show only concerts that match the search").
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtered results show only concerts that match the search](httpatomoreillycomsourcenostarchimages672131.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11. Filtered results show only concerts that match the search
  prefs: []
  type: TYPE_NORMAL
- en: If you look back to [Figure 10-10](ch10s04.html#shows_within_25_miles_of_san_francisco
    "Figure 10-10. Shows within 25 miles of San Francisco"), you can see all the results
    for concerts within 25 miles of San Francisco. Then, in [Figure 10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "Figure 10-11. Filtered results show only concerts that match the search"), you
    see only the two concerts that are $10 or less. The map automatically zooms to
    show only the concerts that match our filter criteria. Pretty slick. Now which
    band are we going to hear?
  prefs: []
  type: TYPE_NORMAL
- en: '#72: Plot Twitter Geo-Tweets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twitter is a popular service for sharing short messages with friends. In 140
    characters or less, people send rants, links, photos, or whatever else they feel
    like. Optionally, those messages (called *tweets*) can be geo-tagged. When content
    is tied to a location, you can do some interesting things with that data.
  prefs: []
  type: TYPE_NORMAL
- en: In this mashup, we'll create a tool for users to search for geo-tagged tweets
    by city name, ZIP Code, or address. We'll also create an optional way to search
    by keyword. Do you want all the geo-tagged tweets nearby that mention *lunch*?
    You can do that! Just take a look at [Figure 10-12](ch10s05.html#where_san_franciscans_like_to_tweet_abou
    "Figure 10-12. Where San Franciscans like to tweet about their lunch").
  prefs: []
  type: TYPE_NORMAL
- en: '![Where San Franciscans like to tweet about their lunch](httpatomoreillycomsourcenostarchimages672133.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12. Where San Franciscans like to tweet about their lunch
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with searching tweets, we''ll integrate a few other projects from earlier
    in the book. Because we need the user to enter a location, we''ll need a geocoder
    to translate the name of a place to latitude and longitude coordinates. For that,
    we''ll use [#12: Geocode with JavaScript](ch03s03.html "#12: Geocode with JavaScript")
    in [#12: Geocode with JavaScript](ch03s03.html "#12: Geocode with JavaScript").
    And because we need to start somewhere, I''ve used [#50: Get Location by IP](ch07s04.html
    "#50: Get Location by IP") in [#50: Get Location by IP](ch07s04.html "#50: Get
    Location by IP") to guess where the user is.'
  prefs: []
  type: TYPE_NORMAL
- en: But first we need to create the HTML for the page where our map will reside.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the Map with User Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most maps we've created start with a default location. That's the biggest difference
    between this map and the others. Here, we'll use Google's `ClientLocation` to
    guess the user's city. If that's not available, we'll instead show a map of the
    entire United States. In either case, the form below the map will be accessible
    to set a new location or other search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an empty file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we include the jQuery library ❶, which we'll use to make the Ajax call
    to Twitter. Then we load the generic Google JavaScript API script ❷. This distinction
    from the normal way of loading the Google Maps API is important; we use this alternate
    method so we can retrieve the user's location. Because we will also be using the
    JavaScript geocoder, we need to include that, too ❸.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've loaded all our scripts the standard way. All we've included
    from Google, however, is a script that loads other scripts. The first thing we
    need to do in the JavaScript section is load Google Maps ❹.
  prefs: []
  type: TYPE_NORMAL
- en: When we create the map, we need to check whether we can determine the user's
    location. If we can, then we can set the center of the map based on the coordinates
    retrieved from `ClientLocation`. We'll also prepopulate the search form with the
    name of this location ❺ and call to the `get_twitter_geo` function, which retrieves
    search results from Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: If we can't determine the user's location, we'll just zoom out so the entire
    United States is shown on the map ❻. And calling for search results from this
    view is futile, so we'll wait for the user to search manually. How does that happen?
    Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Geocode User Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accepting user input is an important part of this mashup. Users want to interact
    with the map and the data, which requires the ability to look for any location.
    The form we created in the previous section has inputs for a keyword, radius,
    and place. Twitter can use all of these to find tweets, but first we need to convert
    the place into the latitude and longitude coordinates that Twitter expects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user submits the form, the browser will call the `geocode_form` function,
    which is used to initiate a call to the JavaScript geocoder. Let''s create this
    function by adding the following lines to your JavaScript section, outside any
    other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If the user has left the location field empty ❶, we assume they want to search
    using the center of the current map. Otherwise, we create a geocoder and set the
    callback function ❷. Then, we perform geocoding ❸ using the location the user
    entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In either case, the next function that will be called is `call_twitter_geo`
    (either directly or as a callback from the geocoder), which passes the point and
    other criteria to our `get_twitter_geo` function, which does the heavy lifting.
    Let''s create the first and simpler of those two functions now. Add the following
    code within the JavaScript section, but not within another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The argument expected is a location object ❹, which is a `point` attribute containing
    a Mapstraction `LatLonPoint`. Even though we sometimes call this function directly,
    it is designed to accept the results of the JavaScript geocoder.
  prefs: []
  type: TYPE_NORMAL
- en: We gather the rest of the form fields (keyword, radius) and pass them off to
    be used to retrieve geo-tweets ❺.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're through with the overhead. Now we're ready to search tweets.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Geo-Tweets from Twitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have only determined (in various ways) a point around which to search,
    but we haven''t performed the actual search. That''s what we''ll do here: Send
    our requirements to Twitter, and receive tweets in return.'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter's search API does not require a key, so you can get started right away.
    The base URL is *search.twitter.com/search.json*, and you can use a number of
    parameters to call it. The ones we'll use are listed in [Table 10-2](ch10s05.html#some_twitter_search_parameters
    "Table 10-2. Some Twitter Search Parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2. Some Twitter Search Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | Search query/keyword |'
  prefs: []
  type: TYPE_TB
- en: '| `geocode` | Coordinates in `lat,lon,radius` format |'
  prefs: []
  type: TYPE_TB
- en: '| `page` | Page of results to retrieve |'
  prefs: []
  type: TYPE_TB
- en: '| `rpp` | Results per page |'
  prefs: []
  type: TYPE_TB
- en: 'You can search in your browser by adjusting the URL. Here are some abbreviated
    example results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the results contain the username, tweet text, and date. Also,
    the `geo` attribute contains information about geocoded tweets. Not every tweet
    will contain this data, however, even when we send the `geocode` argument in the
    search query. We'll need to watch for that as we create the function to plot geocoded
    tweets. In fact, because so many non-geocoded tweets are out there, we may need
    to go through many pages of results before we get enough tweets to plot on our
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Much more data than I have shown is sent along with the tweet, such as the client
    used to create the tweet and the profile image of the user who wrote it. You can
    find full documentation of the search API on Twitter's site at [http://dev.twitter.com/doc/get/search](http://dev.twitter.com/doc/get/search).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you better understand the data you''ll get from Twitter''s API, let''s
    write the `get_twitter_geo` function that we call from our mashup. Add the following
    code to your JavaScript, outside any other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The function contains five parameters, but only one (the location) is required.
    The others—radius, keyword, page, and results per page—are set to defaults if
    need be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the search is for the first page of results, we know that this is
    a new search, so we have to remove previous results from the map. Then, based
    on the center point, we draw a circle around the search area. I''ve used a polygon
    to approximate a circle, as described in [#18: Add Circles to Show Search Radius](ch04s03.html
    "#18: Add Circles to Show Search Radius") in [Set the Fill Color and Opacity](ch04s02.html#set_the_fill_color_and_opacity
    "Set the Fill Color and Opacity"). For convenience, the `polygon_circle` ❶ function
    is reprinted at the end of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the function arguments (or the defaults), we then create the URL for a
    Twitter search. At the end, we include the `callback` parameter ❷ with a question
    mark that will be filled in by jQuery with a generated function name.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get query results, we loop through until we find a tweet that is geocoded
    ❸. Then we grab its coordinates (an array, with latitude before longitude) and
    create a marker with them. I've given the marker a message box containing the
    text of the tweet. You could also include more data about the tweet if you want.
  prefs: []
  type: TYPE_NORMAL
- en: When we've looped through all the results, we aren't necessarily done. Because
    not every tweet is geocoded, we need to view many pages. Twitter will only return
    1,500 tweets. The number of pages will depend on the results per page. As long
    as we're below the limit and still receiving a full set of tweets ❹, we want to
    keep searching. In some areas, especially without searching by keyword, your tweet
    map will get pretty full, like in [Figure 10-13](ch10s05.html#many_comma_many_tweets_near_downtown_por
    "Figure 10-13. Many, many tweets near downtown Portland").
  prefs: []
  type: TYPE_NORMAL
- en: This `get_twitter_geo` function is what computer scientists call *recursive*,
    meaning it calls itself. This can be dangerous, because if you aren't careful
    about the conditions when you make another call, you've got the potential for
    an infinite loop. Perhaps the most important part of the function is that we increase
    the page number ❺ with each call. Doing so will ensure that eventually we'll stop
    calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! Before your code will work, you''ll need to include the code, which
    I am reprinting from [Chapter 4](ch04.html "Chapter 4. LAYER IT ON"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now you've written a mashup that geocodes a location and searches Twitter for
    tweets near that place. You've tapped into the geographic hivemind. Now start
    using it to uncover some interesting data. Where in your city are people tweeting
    about lunch?
  prefs: []
  type: TYPE_NORMAL
- en: '![Many, many tweets near downtown Portland](httpatomoreillycomsourcenostarchimages672135.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13. Many, many tweets near downtown Portland
  prefs: []
  type: TYPE_NORMAL
- en: '#73: Find a Coffee Shop to Meet in the Middle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meeting in the middle is the secret to a happy marriage and the key to passing
    kindergarten. And when it comes to physically finding a place to meet, meeting
    in the middle makes for a great map mashup. Whether you and a friend are just
    across town or many miles apart, we'll make a map that will find coffee shops
    as close to the midpoint between your two locations as possible, as shown in [Figure 10-14](ch10s06.html#a_search_for_coffee_shop_at_the_midpoint
    "Figure 10-14. A search for coffee shop at the midpoint of a route").
  prefs: []
  type: TYPE_NORMAL
- en: 'The map we create will use several examples covered earlier in this book. First,
    we''ll take input from the user and determine the route, as I showed in [#37:
    Find True Distance with Routing](ch06s02.html "#37: Find True Distance with Routing")
    in [#37: Find True Distance with Routing](ch06s02.html "#37: Find True Distance
    with Routing"). Then we''ll go through each step of the driving directions to
    determine when we''re about halfway. To find the exact midpoint, we''ll use another
    method described in [#40: Find a Point Along a Line](ch06s05.html "#40: Find a
    Point Along a Line") in [#40: Find a Point Along a Line](ch06s05.html "#40: Find
    a Point Along a Line"). Finally, we''ll use the midpoint to perform a local search
    using the review service Yelp''s API.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this game plan, read on to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '![A search for coffee shop at the midpoint of a route](httpatomoreillycomsourcenostarchimages672137.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-14. A search for coffee shop at the midpoint of a route
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the Map and Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can incorporate the other examples from [Chapter 6](ch06.html "Chapter 6. EXPLORE
    PROXIMITY"), we need to think about the pieces to include on our web page. Obviously,
    we need to include a map. We also need a way to get two locations from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file, and add the following HTML to create a map with a view of
    the entire United States and the input fields we need to get user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I have included the jQuery JavaScript library ❶, which we''ll use later to
    connect to Yelp. Looking ahead, I added the `gdir` variable ❷ to hold driving
    directions from Google. Save and load the file, and it will look like [Figure 10-15](ch10s06.html#the_foundation_of_the_mashup_colon_our_m
    "Figure 10-15. The foundation of the mashup: our map and form").'
  prefs: []
  type: TYPE_NORMAL
- en: '![The foundation of the mashup: our map and form](httpatomoreillycomsourcenostarchimages672139.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-15. The foundation of the mashup: our map and form'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the form doesn't do anything right now. If you click the Submit button
    or press enter within a text field, it will attempt to call the `goDir()` function,
    as instructed in the HTML ❸. The function does not exist yet, however, so the
    next step is to create it. We'll do that and retrieve driving directions from
    the user's input in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Driving Directions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This mashup *could* have found the midpoint between two start and end points,
    but that would have only been the middle if you and your friends are crows. Or
    pilots. You are much more likely to drive than to fly, so we'll use Google's driving
    directions API.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from [Chapter 6](ch06.html "Chapter 6. EXPLORE PROXIMITY"),
    to retrieve driving directions we first need to tell Google to load the appropriate
    code. In the `create_map` function, add the following lines to prepare for driving
    directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: First, we've created a comment ❶ to note that we're writing provider-specific
    code; in this case, the code only works with Google. If you ever need to convert
    this mashup to use a different mapping provider, including this will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use driving directions, we must create a `DirectionsService` object
    ❷. Later, we can call functions on that object or pass it to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are ready to look up driving directions, let''s write the `goDir`
    function. This function gets called when the user fills out the form. Add this
    code to the JavaScript section but outside the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `goDir` function is to hand off the two locations to the
    driving directions service. We first store the text the user entered into variables.
    In case this is a subsequent search and the map already contains results, we need
    to clear the map of markers and polylines before calling for directions.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to pass the locations to Google's directions. We include them
    in a special options object ❸. Then we can call the directions service using the
    options and also give Google a callback function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we find the midpoint, let''s add the directions to the map. Here is
    the code for the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This function is passed the results from the Google driving directions service.
    From the results, we can get the points ❺ that make up the route. Then, loop through
    those points, adding each to a new array of points ❻ after converting each into
    a Mapstraction `LatLonPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have all the points in the route, we can use them to create a new polyline.
    The line will serve as a visual of the entire route between the two locations,
    as shown in [Figure 10-16](ch10s06.html#the_full_directions_shown_while_we_find
    "Figure 10-16. The full directions shown while we find coffee shops"). We''re
    almost ready to find the midpoint, but we need one more thing from the Google
    directions: the total route distance (in km) ❼. Then, we pass the new array of
    points and the distance to the `findMidpoint` function ❽.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll create that function, which does most of the real
    work involved in this mashup.
  prefs: []
  type: TYPE_NORMAL
- en: '![The full directions shown while we find coffee shops](httpatomoreillycomsourcenostarchimages672141.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-16. The full directions shown while we find coffee shops
  prefs: []
  type: TYPE_NORMAL
- en: Find the Route's Midpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've set up the web page and retrieved the route from Google's directions
    service, we need to write the code to traverse the route data returned. As we
    go through each point in the directions, we'll add the total distance traveled
    so far, stopping when we've gone half the total distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findMidpoint` function receives two arguments, the route points and the
    total distance. Add the function to your JavaScript code but outside other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each time through the loop, we look at two points—the previous point and the
    current one. Because we need two points, our loop begins at 1 (the second point)
    instead of 0\. We calculate the distance between these two points. As long as
    the distance between all points so far is less than half the total distance ❶,
    we just add the distance between the two points to a running total and move on
    to the next point in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have found a halfway point, the real work begins. Most likely the point
    we found is actually *farther* than halfway. Because we are looking at each point
    in order, however, we know the two points that our midpoint is between. And we
    can calculate how far between the two points ❷ we need to go for the midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have two points and a distance from the first to the second, we
    have all the information needed to use the example from [#40: Find a Point Along
    a Line](ch06s05.html "#40: Find a Point Along a Line") in [#40: Find a Point Along
    a Line](ch06s05.html "#40: Find a Point Along a Line"). The two functions from
    that project, `get_bearing` and `get_destination`, are reprinted at the end of
    this section.'
  prefs: []
  type: TYPE_NORMAL
- en: When we have the midpoint, we can use it to create a marker ❸, which we add
    to the map. Then we will also use that point to search Yelp. But first we need
    to determine what radius to send to search. Yelp will accept anything that is
    25 miles or less. If our user is only searching a route across town, 25 miles
    is probably a longer search than the entire route. Yet, if we choose too small
    a radius, we run the risk of there not being any coffee nearby when the midpoint
    is in a more rural area.
  prefs: []
  type: TYPE_NORMAL
- en: I've chosen to make the search radius at least one mile, but then I add ten
    percent of the total distance. That way, small distances have proportionally small
    search radii. And, if my users are driving across the country, a radius of 25
    miles is reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we send all this information to Yelp ❹. Before we get to that, here
    are the reprinted functions from [Chapter 6](ch06.html "Chapter 6. EXPLORE PROXIMITY"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now the only thing missing from this mashup is the call to Yelp. We'll write
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Search for Coffee on Yelp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This mashup isn't just about finding a midpoint; it's about finding a place
    to meet near that midpoint. As the title of the mashup suggests, we're searching
    for coffee shops, though you could have your mashup search for any keyword you
    want. To perform the search, we'll use Yelp, a site that catalogues local businesses.
  prefs: []
  type: TYPE_NORMAL
- en: Yelp has an API that makes searching based on a latitude and longitude point
    easy. Better yet, the response from Yelp is in JSON, a format that makes incorporating
    it into our mashup quick. Before you can use the API, you'll need to get an access
    key, just as you did for maps. Sign up as a Yelp developer at [http://yelp.com/developers](http://yelp.com/developers).
    Now you're ready to make your first call to the Yelp API. The base URL is *api.yelp.com/business_review_search*,
    but we'll also include the parameters shown in [Table 10-3](ch10s06.html#yelp_api_search_options
    "Table 10-3. Yelp API Search Options").
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try out a few searches in your browser and see the text for the JSON
    results. For example, here''s a snippet response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Table 10-3. Yelp API Search Options
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ywsid` | Your API key (required) |'
  prefs: []
  type: TYPE_TB
- en: '| `num_biz_requested` | Number of search results |'
  prefs: []
  type: TYPE_TB
- en: '| `term` | Keyword(s) to search |'
  prefs: []
  type: TYPE_TB
- en: '| `lat` | Latitude of search point |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | Longitude of search point |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | Radius to search (in miles—25 or less) |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s dive in and create the `loadYelp` function that we''ve already called
    in earlier code. Add the following function to your JavaScript section, being
    careful to place it outside all other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadYelp` function requires three arguments: the keyword to search, the
    location to search (as a Mapstraction `LatLonPoint`), and the radius (in miles).
    The first thing the function does is use the arguments to create the URL for Yelp''s
    API. We include the `callback` parameter ❶ with a question mark that will be filled
    in by jQuery with a generated function name.'
  prefs: []
  type: TYPE_NORMAL
- en: To interpret the results from Yelp, we'll use an anonymous, inline function
    ❷ that accepts a single parameter, `x`, to hold the JSON object results. Once
    we've confirmed that we have usable data, we loop through all the results and
    grab each business listing ❸. From there, we can also find the business' location
    ❹ and other information.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I created a message box with some simple business information
    and basic styling. You could go wild here and include any HTML you want inside
    the message box. Yelp also provides some fun data in its response that I haven't
    included here. You can get the distance from the search point, average reviews,
    and even pictures of some locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re done looping through the results, we''ll have a marker for each
    business. Then we center and zoom on just those markers ❺, passing an array of
    points we collected during the loop. This function is different than one shown
    in [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html
    "#8: Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). The `autoCenterAndZoom`
    function takes polylines into consideration, too, which shows the entire route.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example search in [Figure 10-17](ch10s06.html#meet_in_the_middle_results_show_coffee_s
    "Figure 10-17. Meet in the Middle results show coffee shops in Kansas between
    Boulder, Colorado, and Little Rock, Arkansas."), where the mashup finds a few
    Kansas coffee shops between Boulder and Little Rock.
  prefs: []
  type: TYPE_NORMAL
- en: '![Meet in the Middle results show coffee shops in Kansas between Boulder, Colorado,
    and Little Rock, Arkansas.](httpatomoreillycomsourcenostarchimages672143.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-17. Meet in the Middle results show coffee shops in Kansas between
    Boulder, Colorado, and Little Rock, Arkansas.
  prefs: []
  type: TYPE_NORMAL
- en: The next time you want to meet a friend, either across town or across the country,
    neither of you has to drive the whole way. You can meet halfway, thanks to driving
    directions, a little math, Yelp, and this little mashup you've just created.
  prefs: []
  type: TYPE_NORMAL
